{"id1": "10266116", "id2": "1122585", "code1": "    public InputStream retrieveStream(String url) {\n        HttpGet getRequest = new HttpGet(url);\n        try {\n            HttpResponse getResponse = getClient().execute(getRequest);\n            final int statusCode = getResponse.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n                Log.w(getClass().getSimpleName(), \"Error \" + statusCode + \" for URL \" + url);\n                return null;\n            }\n            HttpEntity getResponseEntity = getResponse.getEntity();\n            return getResponseEntity.getContent();\n        } catch (Exception e) {\n            getRequest.abort();\n            Log.w(getClass().getSimpleName(), \"Error for URL \" + url, e);\n        }\n        return null;\n    }\n", "code2": "    private String copyImageFile(String urlString, String filePath) {\n        FileOutputStream destination = null;\n        File destination_file = null;\n        String inLine;\n        String dest_name = \"\";\n        byte[] buffer;\n        int bytes_read;\n        int last_offset = 0;\n        int offset = 0;\n        InputStream imageFile = null;\n        try {\n            URL url = new URL(urlString);\n            imageFile = url.openStream();\n            dest_name = url.getFile();\n            offset = 0;\n            last_offset = 0;\n            offset = dest_name.indexOf('/', offset + 1);\n            while (offset > -1) {\n                last_offset = offset + 1;\n                offset = dest_name.indexOf('/', offset + 1);\n            }\n            dest_name = filePath + File.separator + dest_name.substring(last_offset);\n            destination_file = new File(dest_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    if (!destination_file.canWrite()) {\n                        System.out.println(\"FileCopy: destination \" + \"file is unwriteable: \" + dest_name);\n                    }\n                    System.out.println(\"File \" + dest_name + \" already exists. File will be overwritten.\");\n                } else {\n                    System.out.println(\"FileCopy: destination \" + \"is not a file: \" + dest_name);\n                }\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory doesn't exist: \" + dest_name);\n                }\n                if (!parentdir.canWrite()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory is unwriteable: \" + dest_name);\n                }\n            }\n            destination = new FileOutputStream(dest_name);\n            buffer = new byte[1024];\n            while (true) {\n                bytes_read = imageFile.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(\"Bad URL \" + urlString);\n        } catch (IOException ex) {\n            System.out.println(\" IO error: \" + ex.getMessage());\n        } finally {\n            if (imageFile != null) {\n                try {\n                    imageFile.close();\n                } catch (IOException e) {\n                }\n            }\n            if (destination != null) {\n                try {\n                    destination.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return (dest_name);\n    }\n", "label": 0, "substitutes": {"retrieveStream": ["retriveContent", "retrieveContent", "retrievedObject", "retriveStream", "retriveSteam", "retrievedSteam", "retrievedStream", "RetrievedObject", "RetrievedSteam", "retrieveObject", "retrievingContent", "RetrieveObject", "RetrieveSteam", "RetrievedContent", "RetrieveStream", "RetrieveContent", "retrievedContent", "retriveObject", "retrievingStream", "retrieveSteam", "RetrievedStream", "retrievingSteam", "retrievingObject"], "url": ["path", "string", "address", "ssl", "base", "server", "uri", "resource", "id", "username", "feed", "http", "filename", "ref", "location", "l", "host", "URL", "el", "fr", "email", "source", "connection", "ug", "str", "config", "file", "src", "route", "li", "request", "ll", "log", "href", "style", "ls", "name", "image", "full", "sl", "rl", "layer", "Url", "ur", "f", "gl", "service", "download", "loc"], "getRequest": ["showResp", "GetResponse", " getResp", "checkRequest", "getResp", " getSession", "checkSession", "findResponse", "findRequest", "checkResult", "getResult", "Getrequest", "httpRequest", "findResp", " getUrl", "getrequest", "getSession", " getResult", "showRequest", "showUrl", "GetRequest", "getUrl", "findUrl", "httpResult", "httpResponse", "GetSession", "checkResponse", "showResponse", "checkrequest", " getrequest"], "getResponse": [" getReply", " getView", "initresponse", "gotView", " getResp", "findReply", "gotRequest", "getResp", " getresponse", "findResponse", "getStatus", "findRequest", "initResponse", "updateResponse", "httpResp", "gotReply", "getResult", "updateResult", "getReply", "findView", "getView", "updateResp", "httpRequest", "gotResponse", "httpStatus", " getResult", "initResp", "updateresponse", "initStatus", " getStatus", "httpResponse", "getresponse", "initRequest", "initResult"], "statusCode": ["resourceCode", "StatusInfo", "servicecode", "statcode", "statusInfo", "statType", "serviceInfo", "resourceType", " statusType", "statusType", "statuscode", "contentType", "contentInfo", "serviceCode", "statusStatus", "statStatus", "StatusType", "resourcecode", "contentCode", "statCode", " statuscode", "StatusCode", "Statuscode", "contentcode", "resourceStatus", "StatusStatus", "serviceType"], "getResponseEntity": ["getResponseContent", "apiResponseUrl", "getRespentity", "getResponseentity", "apiresponseContent", "initResponseContent", "initStatusentity", "getStatusBody", "getRespUrl", "initStatusBody", "getResponseUrl", "getRespUnit", "getStatusUnit", "getResponseUnit", "getStatusEntity", "apiResponseContent", "apiresponseUnit", "getResponseBody", "getresponseUrl", "getRespEntity", "getresponseUnit", "getStatusentity", "initResponseEntity", "getresponseEntity", "getStatusUrl", "apiresponseUrl", "apiresponseEntity", "apiResponseEntity", "initStatusEntity", "getresponseentity", "getStatusContent", "initStatusContent", "getRespContent", "getRespBody", "initResponseentity", "initResponseBody", "getresponseContent", "getresponseBody", "apiResponseUnit"]}}
{"id1": "17296916", "id2": "21125261", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"logging": ["logger", "blogting", "Loging", "loging", "blogger", " logger", "Logting", " logting", "Logger", " loging", "bloging", "blogging", "logting", "Logging"], "wrap": ["nw", "handler", "rap", "self", " wrapped", "lock", "wp", "now", "message", "run", "util", "ad", "bag", "wra", "ws", "use", "cover", "wb", "cache", "binary", "default", "div", "w", "build", "pipe", "war", "work", "web", "h", "get", "p", "widget", "flash", "init", "format", "or", "force", "frame", "image", "box", "word", "stream", "parse", "create", "b", "wire", "wrapper", "we", " Wrap", "sw", "wa", "process", "f", "ow", "handle", "transform", "api"], "buffer": ["base", "loader", "pause", "Buffer", "server", " receive", "copy", "response", "uffer", "feed", "builder", "report", "bridge", "ref", "message", "board", "table", "document", "cb", "result", "shell", "bin", "manager", "pb", "queue", "iter", "uf", "bar", "reader", "cache", "player", "cover", "binary", "buff", "source", "buf", "ob", "surface", " buf", "batch", "BU", "fb", "flash", "bb", "log", "null", "reply", "msg", "template", "header", "frame", "writer", "image", "nb", "layer", "bc", "url", "comment", "b", "reference", "wrapper", "bm", "print", "transfer", " buffers", "code", "view"], "encoding": ["Encet", "decoded", "packoder", "ecoded", "decoder", "enoder", "Encoded", "Encoder", "coder", "Encryption", "coding", "unicode", "encode", "unicoded", "ecryption", "decoding", "encet", "Encoding", "encryption", "packet", "packoding", "coded", "enoded", "enoding", "unicoding", "enode", "ecoder", "cet", "packoded", "decryption", "unicoder", "encoder", "decode", "ecoding", "encoded"], "getEncoding": [" getEncasing", " getEncoded", "getCoded", "getEncoder", "getencoding", " getEncocol", "getEnoding", " getEnoding", "getEnoder", "getEnoded", " getEnoded", "getencocol", "getEnocol", "getCoder", "getencasing", "getencoder", "getCasing", "getCoding", " getEnocol", " getEnasing", "getEncocol", "getEncasing", "getEnasing", "getEncoded", " getEnoder", " getEncoder", "getCocol", "getencoded"], "headers": ["keys", "head", "settings", "http", "ers", "features", "writers", "s", "host", "caps", "rs", "ids", "workers", "content", "ings", "parts", "params", "links", "lines", "strings", "blocks", "ports", "str", "names", "body", "vals", "objects", "options", "h", "plugins", "groups", "breaks", "frames", "header", "dict", "ters", "ppers", "ints", "types", "details", "files", "values", "relations", "fields", "wrapper", "heads", "padding", "properties", "bits"], "is": ["bis", "i", "iss", "lis", "fs", "IS", "isa", "http", "Is", "as", "tis", "api", "bs", "s", "abs", "ins", "ois", "ui", "in", "ms", "ori", "isl", "cms", "its", "ws", "so", "ops", "ais", "bas", "nis", "out", "las", "\u00eds", "es", "has", "or", "js", "ris", "obs", "ists", "io", "oss", "aos", "iris", "ios", "us", "ses", "isi", "sis", "are", "isol", "os", "was", "iso", "mis"], "bos": ["uds", "bis", "base", "mos", "ko", "oses", "fs", "fits", "bh", "zos", "tis", "bones", "outs", "bs", "bo", "obos", "ois", "bin", "oos", "obo", "mobi", "obi", "bes", "flo", "cms", "so", "ws", "ros", "ops", "org", "ubis", "bas", "ob", "bott", "las", "ubs", "bi", "oes", "opus", "aos", "obs", "bots", "home", "oks", "lins", "beans", "ios", "bc", "ses", "osa", "pins", "bot", "shadow", "los", "zo", "abi", "oops", "os", "osi", "bits", "cos", "mis"], "e": ["ite", "ise", "fe", "i", "ee", "ke", "be", "ie", "c", "o", "se", "l", "ception", "ec", "er", "type", "one", "d", "ce", "ale", "je", "ea", "de", "exc", "x", "p", "ae", "E", "ze", "a", "ev", "pe", "me", "err", "f", "error", "oe", "esi", "re"]}}
{"id1": "255765", "id2": "15971794", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"f": ["path", "fun", "fe", "sf", "n", "fs", "feed", "cf", "df", "fa", "lf", "bf", "rf", "filename", "c", "ref", "j", "fc", "fp", "fi", "l", "s", "fn", "fr", "ff", "form", "fold", "d", "r", "g", "w", "file", "flat", "h", "x", "p", "name", "folder", "e", "m", "io", "t", "fo", "fm", "function", "F", "fd", "self", "a", "fen", "of", "v", "b", "tf", "inf", "this", "fx"], "in": ["IN", "pin", "ssl", "fa", "token", "ini", "ic", "ins", "bin", "thin", "vin", "get", "gen", "it", "a", "with", "din", "ex", "serv", "lock", "part", "source", "up", "connection", "min", "r", "str", "g", "w", "rin", "again", "exec", "isin", "In", "lin", "b", "v", "inn", "win", "n", "gin", "con", "inner", "socket", "session", "reader", "d", "diff", "p", "init", "or", "m", "image", "nin", "ac", "cin", "fe", "input", "c", "l", "pass", "is", "login", "inc", "config", "data", "rec", "t", "err"], "cbuf": ["cbux", "dbuf", "zbuff", "bbuff", "fbbuf", "cfbuf", "rbuff", "bbull", "cbul", "bcul", "CBuc", "bcuc", "bcull", "CBuf", "CBuff", "zbuu", "cfuf", "fbuc", "bcurs", "dbuc", "rbuc", "cbutf", "rbuu", "cbbuf", "cburs", "CBul", "bault", "bux", "buff", "ebuu", "buf", "cfuc", "rbutf", "rbbuf", "rbull", "bcuf", "bcuff", "bcault", "ebuf", "fbuff", "rbux", "zbuf", "bcur", "ebutf", "cbuff", "rbuf", "rburs", "rbul", "cbull", "cbuc", "bbuf", "cbuu", "cfuff", "fbuf", "zbutf", "dbuff", "ebuff", "bburs", "bcux", "dbur", "cfur", "rbault", "cbur", "cbault"], "read": ["index", "Read", "each", "hex", "run", "ride", "en", "raw", "only", "q", "build", "open", "used", "get", "lex", "it", "readable", "ed", "print", "know", "buffer", "num", "id", "feed", "rc", "add", "report", "oct", "ack", "ind", "end", "find", "sync", "use", "load", "r", "g", "work", "w", "level", "un", " READ", "fill", "name", "bit", "ing", "full", "skip", "connect", " reading", "val", "play", "close", "reading", "ok", "socket", "se", "length", "write", "record", "iter", "sleep", "loop", "er", "allow", "reader", "d", "old", " Read", "bind", "insert", "start", "change", "io", "update", "create", "y", "wait", "repeat", " write", "ink", "error", "view", "valid", "ak", "input", "child", "draw", "reads", "pass", "key", "last", "select", "type", "want", "seek", "inc", "data", "text", "config", "check", "x", "size", "log", "put", "cel", "send", "call", "pe", "k", "parse", "stream", "ize", "count", "READ", "re", "orig"], "totRead": ["octotoLength", "tottedWrite", "TotGet", "tcotClose", "tcotRead", "dottLoad", "octotWrite", " totalBuild", "tottedGet", "tntReader", "tottUse", "octotoRead", "totLink", "totBuild", "towLength", "dottReader", "totoLength", "tazonClose", "tetReading", "toyDraw", "totClose", "totiBuild", " totWrite", "notLoad", "notWrite", "intottBuild", "tottLength", "tottAccept", "totalLoad", "towLoad", "totalLink", " totalWrite", "nottAccept", "towWrite", "nottRead", "totoSearch", "tochRead", "intotLoad", "tottReading", "tottWrite", "toyWrite", "tollRead", "tottedRead", "tottLoad", "octotLength", "TotConnect", "ntotWrite", "tetRead", "TotLoad", "totoUse", "tntRead", "dottUse", "octotReading", "TottConnect", "ntottLoad", "TotSearch", "TotaRead", "totoLoad", "tntLoad", "TotaLoad", "tottClose", "totDraw", "totLength", "towAccept", "TottReading", "tobyRead", "intotClose", "towReading", "totingSearch", "totaDraw", "totoWrite", "TotDraw", "nottLoad", "toyRead", "tcotBuild", "totReading", "totConnect", "octotRead", "ntottWrite", "totalAccept", "totalRead", "totLoad", "tazonBuild", "totalBuild", "tntWrite", "totoRead", "dotRead", "ntotRead", "totingWrite", "ntotLoad", "totReader", "notAccept", "totaRead", " totBuild", "tottSearch", "ntottReader", "notRead", "totingRead", "totWrite", "tazonLoad", "totingGet", "dotLoad", "dotReader", "dotUse", "dottFind", "tobyFind", "TotaWrite", "tochLoad", "tottedFollow", "ntotReader", "intotRead", "intottLoad", "totUse", "totaReading", "totaLoad", "totaWrite", "tcotLoad", "TottReader", "tottReader", "totiRead", "tatRead", "totiWrite", "dottWrite", "toyLoad", "TottFollow", "tottFollow", "tatLoad", "totingConnect", "dotFind", "tochReader", "tottConnect", "dottReading", "intotBuild", "TotReader", "totoFind", "tollLoad", "tochWrite", "tobyUse", "tottDraw", "dottRead", "totaLink", "tobyLoad", "totoConnect", " totalRead", "totingFollow", "TottLoad", "TottWrite", "TotaDraw", "tottRead", "tetWrite", "totFind", "nottWrite", "towRead", "TotReading", "totalWrite", "octotoReading", "tollReading", "tatReader", "tollWrite", "dotReading", "tottFind", "ntottRead", "intottRead", "totiLink", "totFollow", "tetLoad", " totalLink", "tazonRead", "totSearch", "TotFollow", "totGet", "octotoWrite", "TottRead", "TotRead", "totaBuild", "TottGet", " totLink", "intottClose", "totoReading", "tottGet", "TottSearch", "totaReader", "dotWrite", "totAccept", "tottBuild", "tatWrite", "TotWrite"], "out": ["ex", "output", "n", "plus", "outer", "net", "c", "OUT", "socket", "o", "outs", "l", "fn", "s", "off", "bin", "client", "sync", "part", "d", "up", "connection", "r", "g", "w", "inc", "parent", "file", "h", "x", "p", "conn", "init", "again", "exec", "Out", "io", "t", "exp", "writer", "In", "a", "ext", "conf", "v", "b", "err", "obj", "ac"], "i": ["index", "ini", "ic", "ii", "q", "chi", "ci", "I", "eni", "zi", "it", "hi", "iu", "multi", "info", "buffer", "id", "ind", "z", "ui", "ori", "ti", "source", "r", "g", "ip", "mi", "ai", "name", "oi", "e", "b", "v", "ik", "uri", "ei", "yi", "slice", "o", "length", "qi", "one", "ji", "d", "phi", "h", "p", "bi", "u", "init", "start", "m", "io", "di", "y", "ni", "api", "ix", "input", "pi", "ie", "c", "current", "j", "fi", "ri", "l", "si", "is", "key", "my", "data", "li", "x", "xi", "gi", "k", "me", "abi"]}}
{"id1": "8182932", "id2": "8079516", "code1": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"unzip": ["ungz", "UNZip", "unarchive", " unZip", " unarchive", "UNzip", "Unarchive", " ungz", "unZip", "Unzip", "Ungz", "UNarchive", "UNgz", "UnZip"], "file": ["directory", "zip", "path", "string", "base", "info", "class", "letter", "resource", "handler", "ile", "lock", "http", "mail", "document", "filename", "message", "per", "phase", "place", "fp", "socket", "child", "table", "line", "flow", "database", "File", "queue", "part", "source", "reader", "use", "dir", "binary", "book", "connection", "model", "FILE", "application", "work", "parent", "data", "archive", "collection", "machine", "local", "le", "object", "get", "page", "log", "single", "view", "folder", "ball", "force", "name", "image", "db", "full", "files", "url", "pe", "stream", "unit", "xml", "f", "module", "service"], "zipFile": ["targetin", "Zipfile", "downloadfile", " zipfile", "zipfile", "archiveDirectory", "archivefile", "targetfile", "archivein", "downloadFile", "targetDir", "downloadDir", " zipDirectory", "Zipin", "zipDirectory", "zipDir", "downloadDirectory", "ZipFile", " zipDir", "ZipDirectory", "archiveFile"], "targetDirectory": ["targetFolder", " targetFolder", "TargetDirectory", "sourceDir", "externalDir", "externalDirectory", "sourcePath", "TargetPath", "TargetFolder", "sourceFile", " targetDir", " targetDatabase", "targetDatabase", "TargetDir", "goalFolder", "targetDir", "targetPath", "goalFile", "goalDatabase", "TargetFile", "externalFolder", "sourceDirectory", "externalFile", "goalDirectory", "TargetDatabase", " targetPath", "sourceFolder"], "zipin": ["Zipinc", "gzout", "zipout", "packin", "zipinc", " zipIN", "zIn", "zout", "gzinc", " zipins", "zipoin", "zipIn", "lockin", "zipIN", "Zipins", "Zipout", "zins", "packIN", "gzin", "plugIn", "lockIn", "plugoin", "Zipin", " zipIn", "plugins", "plugin", "zoin", "zipins", "lockIN", "zin", " zipoin", "zinc", "packIn", "gzins"], "entry": ["zip", "index", "resource", "jo", "ries", "ident", "Entry", "in", "country", "ent", "archive", "row", "it", "comment", "office", "module", "element", "info", "address", "server", "id", "add", "result", "next", "part", "source", "lc", "dir", "connection", "r", "section", "route", "page", "object", "way", "plugin", "name", "e", "exp", "array", "service", "directory", "event", "path", "ge", "system", "inner", "se", "line", "record", "reader", "cat", "or", "internal", "image", "card", "ga", "api", "auto", "enter", "cell", "ry", "ie", "child", "si", "key", "pattern", "je", "inc", "data", "de", "entity", "folder", "pe", "parse"], "targetFile": ["targetFolder", " targetFiles", " targetFolder", "remoteFile", "TargetDirectory", "Targetfile", "parentDirectory", "goalFiles", "TargetLine", "remoteEntry", "sourceFolder", "targetEntry", "TargetFolder", "targetFiles", "TargetFine", "sourceFile", " targetfile", "targetfile", " targetDir", "TargetFiles", "TargetDir", "remoteDirectory", "goalFolder", "sourceEntry", "targetDir", "goalFile", " targetEntry", "parentDir", "parentfile", "TargetFile", "parentLine", "parentFile", "sourceDirectory", "goalFine", " targetLine", "targetLine", "parentFiles", " targetFine", "targetFine", "remoteFolder"], "parentTargetFile": [" parentTargetDirectory", "parenttargetFiles", " parentParentDirectory", "ParentParentDir", "parentTargetfile", "ParentTargetFiles", " parentTargetImage", "parentShortFile", " parentTargetFiles", "parentParentfile", "ParentTargetPath", " parentParentImage", "parentTargetImage", "parentParentDir", "parentSourceFile", "ParentParentFile", " parentParentDir", "parentSourceDir", "parenttargetPath", "parentTargetDir", "parentNetfile", "parentShortDir", "parenttargetDir", "ParentParentDirectory", "parentSourcefile", "parentNetFile", "parentNetDirectory", "ParentTargetDir", "ParentParentFiles", "parentParentDirectory", "parenttargetFile", "parentSourceDirectory", "parentTargetDirectory", " parentParentFiles", " parentParentPath", " parentTargetPath", "parentShortPath", " parentParentfile", "parentParentFile", " parentParentFile", "parentParentPath", " parentTargetDir", "ParentTargetDirectory", "parentSourceFiles", "parentSourcePath", " parentTargetfile", "parentSourceImage", "parentParentImage", "parentShortFiles", "parentNetFiles", "ParentTargetFile", "ParentParentPath", "parentParentFiles", "parentTargetFiles", "parentTargetPath", "parenttargetDirectory"], "input": ["audio", "error", "i", "temp", "resource", "feed", "qa", "http", "auto", "socket", "current", "inner", "instance", "child", "length", "flow", "in", "form", "client", "session", "reader", "source", "binary", "Input", "type", "up", "connection", "inf", "q", "inc", "config", "data", "out", "acl", "local", "request", "get", "context", "exec", "image", "but", "pull", "url", "stream", "print", "container", "single", "initial"], "output": ["writing", "ou", "outer", "response", "console", "Output", "oper", "ilo", "result", "global", "write", "memory", "queue", "exit", "source", "after", "operation", "target", "other", "default", "config", "out", "export", "web", "page", "environment", "put", "log", "object", "control", "complete", "writer", "image", "generation", "kernel", "update", "unit", "reference", "left", "office", "module", "service", "external", "stop"], "readBytes": ["readValues", "readPages", " readbytes", "writeBytes", "readbytes", "writebytes", "Readbytes", "ReadPages", "ReadValues", "readItems", "execOffset", "writePages", "execbytes", "execItems", "writeValues", " readPages", " readOffset", "execBytes", " readValues", "writeItems", " readItems", "ReadBytes", "readOffset", "writeOffset"], "buffer": ["border", "base", "Buffer", "uffer", "resource", "feed", "server", "duration", "vector", "message", "slice", "table", "document", "result", "window", "length", "memory", "read", "queue", "type", "source", "cache", "binary", "reader", "buff", "value", "buf", "wave", "data", "variable", "request", "bb", "null", "header", "writer", "image", "FFER", "array", "layer", "position", "flush", "url", "comment", "reference", "stack", "padding", "block", "width", "batch", "transfer"]}}
{"id1": "19335986", "id2": "11032546", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["CaughtException", "uncachedexc", "uncatchedexc", "uncaughtEvent", "CatchedEvent", "Catchedexc", "Caughtexc", "uncaughtexc", "uncachedEvent", "uncachedException", "uncatchedException", "unchandledException", "unchandledexc", "CatchedException", "uncatchedEvent", "CaughtEvent", "unchandledEvent"], "t": ["n", "c", "l", "s", "te", " T", "ty", "type", "d", "r", "g", "w", "out", "p", "ts", "let", "title", "m", "tree", "ing", "it", " td", "T", "tr", "ed", "f", "tx"], "e": ["event", "fe", "i", "ace", "ee", "be", "ie", "eb", "c", "ge", "j", "se", "o", "s", "el", "ception", "ele", "en", "ec", "er", "d", "ce", "diff", "r", "data", "de", "exc", "ep", "p", "es", "ae", "environment", "ne", "eu", "example", "m", "E", "ev", "ed", "pe", "me", "err", "f", "error", "oe", "Exception", "element", "code", "enter", "esi"], "display": ["play", "fe", "console", "panel", "report", "profile", "description", "window", "host", "layout", "content", "monitor", "scroll", "d", "hide", "show", "default", "config", "de", "body", "page", "object", "p", "style", "dis", "status", "image", "screen", "Display", "position", "app", "me", "summary", "design", "container", "process", "this", "view", "platform"], "shell": ["hell", "buffer", "console", "server", "copy", "lock", "mail", "system", "echo", "l", "child", "host", "el", "clone", "loop", "tools", "sb", "live", " Shell", "machine", "math", "body", "cl", "launch", "h", "environment", "log", "bash", "m", "exec", "image", "status", "Shell", "ml", "kernel", "sym", "app", "sh", "sound", "b", "poll", "container", "process", "xml", "help", "gui", "cli", "tool"], "message": ["event", " exception", "address", "buffer", "translation", "mess", "console", "server", "output", "copy", "response", "report", "mail", "document", "description", "result", "management", "queue", "content", "monitor", "email", "member", "value", "media", "model", "application", "data", "body", "page", "object", "request", "flash", "Message", "log", "msg", "header", "m", "meter", "status", "image", " messenger", "update", "summary", "xml", "essage", "error", "view"], "e1": [" e3", "e3", "exc2", "e8", " e2", "E1", "e2", "E3", "E2", " e8", "E8", "exc3", "exc8", "exc1"]}}
{"id1": "4223002", "id2": "6987642", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getPasswordMD5": ["getPasswordMac5", "getPasswordSHA512", "getpasswordMD5", "getpasswordMD512", "getpasswordSHA5", "getpasswordSHA1", "getpasswordSHA256", "getpasswordMD1", "getPasswordMD256", "getPasswordMAC512", "getPasswordSHA1", "getPasswordMD512", "getPasswordSHA256", "getPasswordMD1", "getpasswordSHA512", "getPasswordMac256", "getPasswordMAC1", "getPasswordSHA5", "getPasswordMAC256", "getPasswordMac512", "getpasswordMD256", "getPasswordMAC5", "getPasswordMac1"], "algorithm": ["alm", " algo", "alger", "Alignment", "omalphabet", "agignment", "fgebra", " alignment", "omalgorithm", " algorith", "Alm", "geger", "aggorithm", "algo", "algorith", " alm", "fgo", " alger", "alrator", "calgebra", "Alger", "calgorith", "Alest", "alphabet", "aggo", "Algo", "Alphabet", "omalgorith", "gegorithm", "calgo", "algebra", "alignment", "gem", "Algebra", "Algorithm", " alrator", "fgorith", "fgorithm", " alphabet", "geest", "omalgo", "calgorithm", "Alrator", "agrator", " alest", "Algorith", "alest"], "messageDigest": ["messageModested", "MessageDigester", "messageMDest", " messagedigEST", "messagedigString", "messageDested", " messagedigString", "messageMDester", "messagedigest", " messagedigest", "messageDigString", "MessageDigEST", "phrasedigester", "messagedigester", "messageDigester", "MessageModEST", "messagedigEST", " messageDigester", "messageDEST", "MessageDigested", "phrasedigest", "phraseDigested", "messageModester", "messageDest", "messageModest", "messageModString", "MessageModester", "messageDester", "messageDigested", "messageDigEST", "messageModEST", "MessageModested", "messageMDEST", "messagedigested", "phraseDigester", "phraseDigEST", "MessageModest", "phrasedigested", "phrasedigEST", "MessageDigest", " messagedigester", "phraseDigest", " messageDigString", " messageDigEST", "messageMDString"], "hexString": ["checkString", "hexBuffer", "textstring", "hexArray", "hexLine", "hashStr", "hexstring", "shortString", " hexStr", "textStream", " hexBuffer", "checkFunction", " hexArray", "hashBuffer", " hexFunction", "hexStream", "textArray", "byteStream", "textString", "byteString", "hashFunction", "shortArray", "textLine", "hexStr", "hashString", " hexStream", "checkBuffer", "hexFunction", "shortBuffer", " hexstring", "textBuffer", "byteLine", "shortstring", "byteArray", "checkStr", " hexLine"], "i": ["index", "info", "id", "n", "pi", "uri", "mu", "slice", "c", "j", "end", "ri", "o", "volume", "l", "s", "fi", "si", "ui", "ii", "in", "key", "type", "ti", "d", "phi", "r", "chi", "li", "h", "x", "p", "mi", "bi", "u", "ai", "oi", "e", "I", "ci", "t", "m", "io", "zi", "xi", "di", "gi", "a", "hi", "v", "b", "abi", "multi", "f", "ix"]}}
{"id1": "12106167", "id2": "9526031", "code1": "    public static void init(Locale lng) {\n        try {\n            Locale toLoad = lng != null ? lng : DEFAULT_LOCALE;\n            URL url = ClassLoader.getSystemResource(\"locales/\" + toLoad.getISO3Language() + \".properties\");\n            if (url == null) {\n                url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n            }\n            PROPS.clear();\n            PROPS.load(url.openStream());\n        } catch (IOException ioe) {\n            try {\n                URL url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n                PROPS.clear();\n                PROPS.load(url.openStream());\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(99);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(99);\n        }\n    }\n", "code2": "    public boolean register(Object o) {\n        String passwordAsText;\n        if (o == null) throw new IllegalArgumentException(\"object cannot be null\");\n        if (!(o instanceof User)) {\n            throw new IllegalArgumentException(\"passed argument is not an instance of the User class\");\n        }\n        User newUser = (User) o;\n        passwordAsText = newUser.getPassword();\n        newUser.setPassword(passwordEncoder.encodePassword(passwordAsText, null));\n        newUser.setRegDate(new Date());\n        logger.debug(\"Setting default Authority {} to new user!\", Authority.DEFAULT_NAME);\n        newUser.getAuthorities().add(super.find(Authority.class, 1));\n        logger.debug(\"Creating hash from email address! using Base64\");\n        newUser.setHash(new String(Base64.encodeBase64(newUser.getEmail().getBytes())));\n        logger.debug(\"Creating phpBB forum User, by calling URL: {}\", forumUrl);\n        try {\n            StringBuilder urlString = new StringBuilder(forumUrl);\n            urlString.append(\"phpBB.php?action=register\").append(\"&login=\").append(newUser.getLogin()).append(\"&password=\").append(passwordAsText).append(\"&email=\").append(newUser.getEmail());\n            sqlInjectionPreventer(urlString.toString());\n            logger.debug(\"Connecting to URL: {}\", urlString.toString());\n            URL url = new URL(urlString.toString());\n            URLConnection urlCon = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlCon.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) newUser.setForumID(Integer.valueOf(inputLine));\n            in.close();\n        } catch (IOException io) {\n            logger.error(\"Connecting failed! Msg: {}\", io.getMessage());\n            throw new RuntimeException(\"Couldn't conntect to phpBB\");\n        } catch (NumberFormatException e) {\n            logger.error(\"phpBB user generation failed! Msg: {}\", e.getMessage());\n            throw new RuntimeException(\"phpBB user generation failed!\");\n        }\n        entityManager.persist(newUser);\n        try {\n            sendConfirmationEmail(newUser);\n            return true;\n        } catch (MailException ex) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"init": ["info", "loader", "setup", "reset", "register", "construct", "load", "up", "build", "config", "strap", "file", "check", "launch", "loading", "get", "start", "pack", "it", "create", "ize", "parse", "process", "Init", "boot", "install", "initial"], "lng": [" lgn", "Lgn", "lang", "sleng", "leng", "slng", "Lang", "lcang", "lgn", "lcong", "lcng", "lcnd", "Lng", " leng", " lnd", "Leng", "Lnd", " lang", "slong", "lnd", "slang", "slgn"], "toLoad": ["poLoader", "ToLoader", "poLoad", " toload", "TOLoader", "TOSave", " toSave", " toLoader", "ToLoad", "TOLoad", "toLoader", "TOAdd", "poSave", "toSave", "poAdd", "toAdd", "Toload", " toAdd", "ToAdd", "TOload", "toload"], "url": ["impl", "event", "string", "path", "address", "base", "loader", "buffer", "job", "server", "resource", "uri", "feed", "element", "id", "user", "entry", "http", "class", "ref", "lr", "location", "l", "host", "URL", "orb", "el", "fl", "source", "zip", "browser", "ob", "parent", "file", "ssl", "page", "object", "ll", "bb", "log", "null", "bel", "web", "or", "name", "coll", "image", "blog", "sl", "rl", "layer", "Url", "pull", "www", "stream", "service", "ur", "obj", "err", "ul", "xml", "f", "gl", "ource", "org", "loc"]}}
{"id1": "596993", "id2": "9550506", "code1": "    private String makeLoginRequest(URL url) throws IOException {\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setDoInput(true);\n        urlConnection.setDoOutput(true);\n        urlConnection.setUseCaches(false);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"Email=\").append(URLEncoder.encode(EMAIL, \"UTF-8\"));\n        content.append(\"&Passwd=\").append(URLEncoder.encode(PASSWORD, \"UTF-8\"));\n        content.append(\"&service=\").append(URLEncoder.encode(SERVICE, \"UTF-8\"));\n        content.append(\"&source=\").append(URLEncoder.encode(\"Google Base data API\", \"UTF-8\"));\n        OutputStream outputStream = urlConnection.getOutputStream();\n        outputStream.write(content.toString().getBytes(\"UTF-8\"));\n        outputStream.close();\n        int responseCode = urlConnection.getResponseCode();\n        InputStream inputStream;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = urlConnection.getInputStream();\n        } else {\n            inputStream = urlConnection.getErrorStream();\n        }\n        return toString(inputStream);\n    }\n", "code2": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"makeLoginRequest": [" makeLoginResponse", " makeAuthCall", " makeloginPost", " makeloginResponse", " makeJSONPost", " makeAuthResponse", " makeJSONCall", "makeLoginResponse", "makeAuthRequest", " makeAuthPost", " makeloginCall", "makeAuthResponse", "makeAuthCall", " makeJSONRequest", " makeloginRequest", "makeAuthPost", " makeJSONResponse", " makeAuthRequest", "makeLoginCall", " makeLoginPost", "makeLoginPost", " makeLoginCall"], "url": ["string", "base", "address", "loader", "ssl", "server", "uri", "resource", "http", "c", "o", "l", "URL", "orb", "client", "twitter", "email", "source", "lc", "connection", "str", "org", "build", "ob", "config", "file", "web", "object", "page", "log", "u", "conn", " URL", "image", "t", "link", "sl", "Url", "www", "ur", "obj", "f", "gl", "service", "download"], "urlConnection": [" urlCon", "slConnect", "fileConnection", "sslConnector", " urlNode", " urlFunction", "UrlStream", " urlSocket", "UrlConnection", "urlSource", "URLConnection", "urlConnect", "lUnit", " urlDescription", "webConnector", " urlUnit", "URLconnection", "URLCode", "httpCon", "sslConnect", "fileBody", "fileCode", "fileConn", "URLFunction", "slDescription", "fileStream", "UrlUnit", "urlServer", "urlCode", "httpConnection", "lConnection", " urlconnection", "lConnect", "fileConnector", " urlConnect", "urlFunction", "urlUnit", "URLConnector", "URLConn", "urlconnection", " urlCode", "eventFunction", "slBody", "userConnect", "URLSocket", "webConnection", "sslConnection", "webCode", " urlStream", "eventConnection", "urlBody", "webNode", " urlConn", "URLStream", "sslSource", "URLCon", "httpConn", "URLConnect", "userConnection", " urlServer", "urlConnector", "UrlConnect", "publicConnection", "urlDescription", "webSocket", "webConn", "userConnector", "slStream", "publicUnit", "urlNode", "userSource", "publicConnect", " urlConnector", "UrlCode", "lDescription", "urlSocket", "webFunction", "URLNode", " urlSource", "eventServer", "publicCode", "urlCon", "UrlFunction", "UrlConnector", "URLServer", "UrlSocket", "slUnit", "URLUnit", "eventconnection", "urlConn", "fileConnect", "httpConnector", "slConnection", " urlBody", "urlStream"], "content": ["string", "info", "address", "core", "job", "buffer", "server", "output", "response", "resource", "cf", "more", "message", "json", "document", "cont", "version", "current", "result", "html", "child", "host", "write", "query", "currency", "time", "key", "Content", "expression", "source", "load", "lc", "activity", "connection", "value", "media", "model", "application", "feature", "section", "config", "data", "text", "body", "work", "page", "request", "size", "language", "context", "software", "format", "complete", "header", "exec", "image", "function", "word", "full", "layer", "create", "comment", "xml", "script", "service", "code"], "outputStream": ["inputChannel", "controlPath", "OutputWriter", "controlstream", " outputWriter", "responseStream", "leftStreamer", "OutputChannel", "outputSteam", "inputSteam", "responsestream", "controlStream", "leftStream", "OutputStreamer", "responseSteam", "outputPath", " outputstream", "controlSteam", "outSteam", "outStream", "OutputSteam", "outputstream", "outputStreamer", "OutputStream", " outputChannel", "responsePath", " outputPath", "leftWriter", "outputChannel", "inputWriter", "leftSteam", "outputWriter", "outStreamer", " outputSteam", "outWriter"], "responseCode": ["ResponseCount", "statusCode", "statusText", "responseCount", "responseMessage", " responseCount", "respCode", "statusType", "respCount", "respType", "ResponseText", "respMessage", "responseStatus", "ResponseType", " responseStatus", "ResponseCode", "statusStatus", "ResponseStatus", " responseType", " responseMessage", "responseText", " responseText", "ResponseMessage", "responseType"], "inputStream": ["InputForm", "feedStream", " inputView", "inputStreamer", "inputForm", "upSteam", "outputForm", "InputStreamer", "outputSteam", "inputSteam", "feedView", " inputstream", "tempStream", "inputView", "upView", "inputFlow", "outputstream", " inputSteam", "upStream", " inputStreamer", "tempFlow", "outputFlow", "feedSteam", " inputForm", "upStreamer", "tempSteam", "tempstream", " inputFlow", "inputstream", "InputSteam", "feedStreamer", "InputStream", "InputView"]}}
{"id1": "14794404", "id2": "11082670", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException {\n        StringBuilder json = new StringBuilder();\n        String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n        try {\n            URL url = new URL(requestUrl.toString());\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                json.append(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            throw new GtugsException(e);\n        }\n        List<Event> events = new ArrayList<Event>();\n        JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString());\n        JSONArray results = (JSONArray) jsonObj.get(\"results\");\n        for (int i = 0; i < results.size(); i++) {\n            JSONObject result = (JSONObject) results.get(i);\n            Event e = new Event();\n            e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\")));\n            e.setCity((String) result.get(\"venue_city\"));\n            e.setDescription((String) result.get(\"description\"));\n            e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\")));\n            e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\")));\n            e.setName((String) result.get(\"name\"));\n            Date myDate = null;\n            String time = (String) result.get(\"time\");\n            try {\n                myDate = meetupDateFormat.parse(time);\n                e.setStartTime(timeDateFormat.format(myDate));\n                e.setEndTime(timeDateFormat.format(myDate));\n                e.setStartDate(myDate);\n                e.setEndDate(myDate);\n                String tz = tzDateFormat.format(myDate);\n                if (tz != null && tz.startsWith(\"+\")) {\n                    tz = tz.substring(1);\n                }\n                e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100));\n            } catch (ParseException ex) {\n                ex.printStackTrace();\n                continue;\n            }\n            e.setState((String) result.get(\"venue_state\"));\n            StringBuilder addressBuilder = new StringBuilder();\n            if (result.get(\"venue_address1\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address1\") + \" \");\n            }\n            if (result.get(\"venue_address2\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address2\") + \" \");\n            }\n            if (result.get(\"venue_address3\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address3\") + \" \");\n            }\n            if (result.get(\"venue_address4\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address4\"));\n            }\n            e.setStreetAddress(addressBuilder.toString().trim());\n            e.setZipCode((String) result.get(\"venue_zip\"));\n            e.setUrl((String) result.get(\"event_url\"));\n            events.add(e);\n        }\n        return events;\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encipherPassword", "encressString", "encryptedpassword", "EncipherString", "encryptString", "encipherSecret", "EncryptPassword", "encipherpassword", "EncryptSecret", "encryptSecret", "EncipherSecret", "encressPassword", "encryptpassword", "encryptedString", "EncryptString", "encresspassword", "Encipherpassword", "encressSecret", "EncipherPassword", "Encryptpassword", "encipherString", "encryptedSecret"], "password": ["string", "path", "address", "buffer", "input", "resource", "token", "username", "enc", "message", "description", "wd", "pass", "database", "pattern", "content", " passwords", "params", "Password", "email", "cache", "PASS", "connection", "sword", "data", "text", "channel", "object", "p", "device", "name", "array", "word", "prefix", "secret", "padding", "words", "attribute", "crypt", "phrase", "definition"], "encryptedPassword": ["ryptedPassword", "protectedpassword", "encryptedCode", "encryptedpassword", "ryptedpassword", "protectedPass", "protectedPassword", " encryptedString", "ryptedString", "lockedPass", "encryptedPass", "protectedCode", "ryptedPass", "ryptedCode", " encryptedCode", "protectedString", "encryptedString", " encryptedPass", "lockedpassword", "lockedPassword", "lockedString", " encryptedpassword"], "md5": ["dig3", "md6", "md45", " mddown", " MD512", "amd6", "digdown", "md4", " md4", " md3", "dig4", "amd5", "dig5", "md2", "MD6", " MD3", " md6", "MDdown", "MD5", "dig2", "MD3", "MD512", "amd2", "MD2", "MD45", "md3", " md2", "MD4", "md512", " MD2", "amd4", " md512", " MD5", " md45", "mddown", "dig45"], "digest": ["digment", "mdash", "digher", "Digester", "mdher", "signester", " digace", "signest", "mdace", "signests", "signested", "mdest", "Digests", "mdested", " digenge", "encash", "digester", "digests", "mdester", "digested", "encment", "Digher", "encester", "Digenge", "digace", " digher", "Digest", "mdenge", "encest", "mdests", " digash", "digenge", " digester", "digash", " digests", "Digace", "Digested", " digment", "mdment"], "i": ["index", "id", "uri", "pi", "ie", "c", "j", "ri", "o", "l", "length", "s", "si", "ui", "ii", "qi", "ti", "d", "phi", "r", "li", "ip", "x", "p", "h", "bi", "u", "ai", "oi", "ci", "I", "e", "t", "io", "zi", "it", "xi", "gi", "di", "hi", "k", "v", "b", "multi", "f", "ix"], "hex": ["zip", "string", "letter", "sex", "temp", "ex", "id", "num", "closure", "enc", "oct", "slice", "length", "bin", "digit", "shift", "char", "alpha", "pattern", "comp", "utf", "rh", "binary", "buff", "serial", "ctr", "str", "mix", "none", "data", "text", "check", "rex", "ip", "pex", "null", "lit", "bit", "exp", "pack", "prefix", "di", "ext", "pixel", "coord", "sign", "nexus", "stick", "bits", "hash", "ix"]}}
{"id1": "8932510", "id2": "16557837", "code1": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "code2": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "label": 1, "substitutes": {"doPost": ["DoGet", "sendPut", " doGet", " doPOST", "DoPOST", "sendPost", " doPut", "doPut", "DoPut", "sendGet", "doPOST", "sendPOST", "doGet", "DoPost"], "request": ["resource", "rf", "http", "document", "condition", "req", "rate", "q", "model", "get", "context", "hello", "frame", "url", "xml", "remove", "info", "buffer", "server", "self", "report", "subject", "result", "query", "next", "post", "connection", "parent", "object", "requ", "complete", "attribute", "list", "event", "remote", "path", "head", "uri", "message", "queue", "allow", "session", "reader", "writer", "image", "create", "question", "method", "enter", "view", "input", "Request", "user", "have", "current", "project", "join", "instance", "child", "save", "form", "client", "type", "application", "config", "data", "QUEST", "port", "call", "stream", "right", "command", "this", "re"], "response": ["respons", "server", "output", "resource", "report", "res", "site", "message", "document", "description", "json", "onse", "result", "host", "next", "client", "resp", "connection", "application", "data", "object", "reply", "status", "writer", "image", "service", "Response", " Response", "respond", "stream", "xml", "error", "re", "view"], "is": ["info", "address", "bis", "i", "iss", "lis", "uri", "pi", "IS", "isa", "ini", "alis", "http", "ie", "Is", "as", "ri", "bs", "si", "ois", "ui", "in", "ori", "isl", "isp", "ais", "isc", "ir", "out", "ist", "nis", "web", "ip", "p", "iso", "ai", "ris", "vs", "ci", "rss", "eni", "it", "iri", "iris", "isin", "ios", "ib", "us", "url", "isi", "sis", "are", "was", "api", "mis"], "page": ["article", "path", "root", "order", "node", "handler", "server", "ko", "list", "user", "pages", "wp", "site", "message", "per", "end", "result", "wiki", "html", "child", "account", "pool", "code", "line", "pl", "office", "button", "record", "next", "filter", "session", "so", "cache", "cover", "pp", "browser", "pm", "plane", "Page", "parent", "channel", "phone", "web", "flash", "p", "ip", "object", "po", "change", "image", "blog", "area", "bad", "sea", "url", "www", "photo", "pe", "can", "sp", "f", "error", "pg", "menu", "view"], "os": ["oto", "op", "oa", "mo", "socket", "OS", "o", "ms", "oo", "so", "ros", "bos", "ops", "object", "oid", "p", "po", "ls", "oss", "io", "pos", "ot", " bos", "ios", "obj", "ps"], "rootUrl": ["rootPage", "randomUrl", "webURL", "remoteurl", "weburl", "remoteUrl", "randomPage", "randomURL", "rootURL", "remotePage", " rootURL", "rooturl", " rootPage", "randomurl", "remoteURL", " rooturl", "webPage"], "isMultipart": ["isMultiseArt", "isMultiteart", "isMultitepart", "isMultiipArt", "isMultumpart", "isMultumparts", "isMultypart", "isMultipoint", "isMultippoint", "isMultiiseArt", "isMultiippoint", "isMultiparts", "isMultipppart", "isMultypArt", "isMultiseart", "isMultipArt", "isMultiipppart", "isMultiiseart", "isMultyparts", "isMultumpArt", "isMultitearts", "isMultiipart", "isMultiisepart", "isMultiipoint", "isMultisearts", "isMultumppart", "isMultipparts", "isMultiippart", "isMultiiparts", "isMultippart", "isMultiteoint", "isMultiisearts", "isMultiipparts", "isMultyppart", "isMultisepart"], "rd": ["lt", "rw", "dra", "wr", "rf", "bd", "od", "wid", "dj", "ind", "ru", "rg", "fr", "rt", "dr", "func", "ld", "aa", "RD", "std", "rs", "fl", "rb", "dh", "xd", "rh", "rolog", "ra", "rn", "rid", "ird", "ren", "director", "cd", "hh", "rr", "dig", "rss", "rx", "cr", "rob", "db", "fd", "rl", "respond", "td", "ds", "pt", "pd", "dd", "loc"], "upload": ["zip", "audio", "pkg", "input", "server", "user", "http", "project", "instance", "driver", "util", "pload", " uploaded", "form", " archive", "post", "uploads", "load", "up", "parser", "file", " uploading", "out", "Upload", "archive", "object", "control", "or", "folder", " instance", "image", "io", " submission", "sup", "url", "stream", "create", " Upload", "container", "command", "f", "transfer", "dd", "install"], "webUrl": ["rootPage", "webPath", "webURL", "webLine", " webUr", "WebUr", "wwwURL", "WebPage", "WebPath", "wwwUr", "WebURL", "rootUr", "rootURL", " webURL", " webLine", "wwwLine", " webPath", "WebUrl", "webPage", "webUr", "wwwUrl", "rootPath", "WebLine", " webPage"], "iter": ["ite", "order", "info", "itter", "outer", "feed", "http", "inse", "inter", "oper", "end", "inner", "slice", "iv", "walker", "set", "ter", "gener", "keeper", "in", "er", "collect", "izer", "its", "Iterator", "reader", "ner", "inc", "ignore", "file", "ir", "li", "vis", "ator", "Iter", "iterator", "keep", "init", "or", "coll", "exec", "iner", "eni", "it", "cher", "ver", "ser", "over", "err", "apper", "liter", "former", " iterator", "list", "enter", "loc"], "item": ["zip", "info", "order", "temp", "input", "atom", "feed", "user", "op", "entry", "site", "inner", "end", "result", "instance", "record", "el", "extra", "in", "queue", "er", "items", "part", "bar", "stat", "source", "up", "value", "q", "r", "other", "g", "data", "file", "li", "entity", "object", "ip", "p", "get", "row", "rec", "or", "hop", "coll", "e", "m", "image", "plugin", "it", "link", "area", "layer", "app", "this", "update", "unit", "xml", " Item", "ar", "custom", "element", "Item", "api"], "name": ["string", "info", "NAME", "path", "non", "i", "id", "n", "orig", "on", "inner", "end", "col", "am", "child", "ame", "time", "in", "key", "part", "type", "one", "no", "member", "connection", "not", "common", "old", "none", "data", "names", "parent", "nam", "x", "size", "Name", "e", "m", "label", "word", "call", "prefix", "nm", "na", "layer", "ni", "block", "f", "field", "named", "term"], "baos": ["Bais", "BAos", "baOs", " baios", "pais", "cao", "baios", "caOS", "BAOS", "naos", "bais", "baoes", "caOs", "paOs", "BAios", "BAis", " baoes", "abaos", "BAo", " bais", "abaios", "abaOS", "saOS", "Bao", "cais", "abao", "sao", "sais", "nao", "bao", "Baios", " baOS", "paos", "BaOs", " bao", "nais", "saos", "caos", "naOs", "paoes", "Baos", "baOS", "BAoes", "pao"], "wpIs": ["phpis", "wxis", "wxIs", "phpIS", "ipIs", "wpI", "wxIS", "cpIs", "wpOs", "wordpressAs", "wordpressis", "WPIS", "cpIS", "xpIs", "WPIs", "xpAs", "fwIS", "gpIns", "wordpressIs", "ipIS", "ipI", "phpIns", "phpIs", "wordpressOs", "wpIS", "cpis", "fwI", "fwAs", "wxIns", "cpIns", "gpOs", "wpAs", "WPIns", "fwIs", "fpIns", "WPAs", "fpOs", "WPOs", "gpIs", "ipAs", "fpis", "wpIns", "xpis", "xpOs", "WPI", "WPis", "fpIs", "wpis", "gpis"], "u": ["U", "cu", "ou", "mu", "i", "lu", "uri", "input", "Lu", "uv", "c", "ru", "uid", "o", "l", "s", "ui", "su", "util", "uu", "bu", "fu", "tu", "file", "web", "p", "uni", "hu", "uci", "us", "Url", "url", "ur", "b", "ul", "iu", "nu", "f", "una", "api"]}}
{"id1": "13563706", "id2": "11032546", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"doGet": ["handlePut", "didGet", "didGET", "didPut", "didget", "doget", " doPut", "doGET", "handleGET", "doPut", "handleget", " doget", "handleGet", " doGET"], "request": ["event", "remote", "info", "string", "buffer", "input", "Request", "server", "resource", "user", "report", "message", "document", "current", "result", "instance", "query", "queue", "req", "client", "type", "connection", "model", "application", "config", "data", "object", "p", "complete", "QUEST", "image", "frame", "url", "Response", "create", "xml", "attribute", "method", "view"], "response": ["index", "reason", "server", "output", "resource", "feed", "report", "http", "res", "message", "results", "site", "document", "onse", "subject", "result", "json", "description", "location", "pool", "query", "client", "resp", "connection", "model", "application", "collection", "body", "object", "reply", "header", "status", "writer", "image", "re", "Response", "respond", " Response", "wa", "error", "service", "api", "view"], "selectedPage": ["lectedButton", "selectionpage", "selectedButton", " selectedAction", "namedpage", "lectedpage", "electedLine", "namedFile", "lectedSite", "selectionHour", "selectionLine", "selectionFile", " selectedItem", "selectionItem", "selectedLine", "selectedSite", "selectedpage", "lectedFile", "namedLine", "selectedFile", " selectedHour", " selectedFile", "electedPage", "selectionButton", "lectedPage", "namedPage", "lectedItem", " selectedButton", "selectionPage", "selectedAction", "electedpage", " selectedpage", "selectedHour", "selectionAction", "lectedAction", "lectedLine", " selectedSite", "lectedHour", "electedButton", "namedSite", " selectedLine", "selectedItem"], "page": ["handler", "resource", "document", "number", "rule", "model", "phone", "row", "url", "sp", "office", "module", "menu", "point", "address", "server", "site", "result", "account", "location", "html", "pl", "cache", "pp", "proxy", "connection", "section", "parent", "channel", "route", "ip", "plugin", " Page", "unit", "peer", "article", "node", "message", "per", "ge", "record", "queue", "Page", "ice", "p", "language", "change", "image", "position", "photo", "display", "pg", "view", "fe", "user", "profile", "project", "instance", "child", "pool", "layout", "client", "type", "item", "je", "po", "port", "me", "age", "block", "f"], "portalRequest": ["portialQuery", "portALUser", "portailResponse", "PortortalOrder", "PortortalEvent", "portpalAccess", "portailRequest", "portALResponse", "PortortalAccess", "portialRequest", "portalQuery", "portortalResponse", "portelRequest", " portialQuery", "PortortalUser", "portortalPage", "portortalUser", "portugalResponse", "portallingPage", "portalPage", "PortortalResponse", "portugalRequest", " portalQuery", "PortortalPage", "portortalOrder", "PortalEvent", " portialPage", "portugalOrder", "portalAccess", "portpalRequest", " portalResponse", " portialResponse", "PortalUser", "portALRequest", "portallServer", "portortalAccess", "portortalEvent", "PortalAccess", "portallUser", "portallingRequest", "portugalUser", "portialPage", "portbalQuery", "portortalServer", "portelCommand", "portelPage", "PortalPage", "PortalOrder", "PortortalServer", "portalUser", "PortalCommand", "portallRequest", "portpalResponse", "PortalServer", "portelResponse", "portailUser", "PortalResponse", "portallResponse", "portortalRequest", "portialResponse", "portpalPage", "portbalPage", "portallingAccess", " portalPage", "portailOrder", "portallingResponse", "portalServer", "PortortalRequest", " portialRequest", "portugalEvent", "portalResponse", "portugalServer", "portALEvent", "portbalResponse", "portelQuery", "PortortalCommand", "portalCommand", "portalOrder", "portallingCommand", "PortalRequest", "portalEvent", "portbalRequest", "portortalCommand"], "pageProp": ["PageProp", "agePro", "resourceProperty", "projectPro", "pageprop", "pluginPro", "Pageprop", "peerStr", "resourceProp", "ageProp", "pageObj", "pageProperty", " pageStr", "parentObj", "PageProperty", "PageStr", "pageStr", "pluginprop", "PagePro", "parentProperty", "PageObj", "peerProperty", " pageProperty", "ageProperty", "peerPro", "resourceprop", "projectprop", "pagePro", " pagePro", "projectProp", "projectProperty", "parentProp", "ageprop", "pluginProperty", " pageObj", "resourcePro", "peerProp", "parentPro", "pluginProp"], "possiblePage": ["possiblePages", "pablePages", "possiblepage", "puredPage", "possibilityLine", "Possibilitypage", "possiblyPages", "PossiblyGroup", "PossibilityLine", "possibleLine", "permanentLine", "possibleOrder", "PossiblyPage", "pablepage", "PossibleOrder", "possibleItem", "PossiblyItem", "Possiblepage", "puredpage", "PossibleGroup", "possiblyItem", "permanentpage", "puredItem", "PossiblyOrder", "PossibleItem", "patchingpage", "patchingItem", "possiblypage", "patchedOrder", "patchedpage", "PossiblyLine", "pableLine", "PossiblePage", "permanentPage", "PossibilityPage", "PossiblePages", "possibilityPage", "possibleGroup", "PossibleLine", "PossibilityPages", "patchingPage", "possiblyLine", "possiblyOrder", "patchingGroup", "Possiblypage", "permanentOrder", "possiblyGroup", "pablePage", "patchedLine", "possibilityPages", "puredGroup", "possiblyPage", "patchedPage", "possibilitypage"], "property": ["integer", "string", "address", "class", "uration", "duration", "resource", "perties", "character", "profile", "maximum", "table", "project", "result", "number", "set", "key", " Property", "expression", "Property", "type", "binary", "value", "feature", "section", "config", "data", "entity", "object", "p", "variable", "language", "name", "header", "notation", "t", "function", "operator", "label", "prefix", "layer", "prop", "future", "binding", "properties", "attribute", "f", "term"], "referer": ["rere", "redber", "reiner", "Referers", "refender", "Referer", "affere", "referen", " refre", " refber", "reerer", "diffender", "differer", "rederer", "Refre", "defere", "defber", "Refber", " refender", "afferer", "diffrer", "Refeline", "afferen", "Refrer", "rerer", "refiner", " referen", " refere", "refber", "Refiner", "redrer", "redeline", "refeline", "defender", " refeline", "Refender", "diffiner", "Referen", "refrer", "ferers", " referers", " refiner", "frer", " refrer", "ferer", "fere", "reere", "refre", "deferer", "referers", "affrer", "refere", "Refere", "defrer"], "e": ["event", "fe", "i", "ee", "ie", "message", "o", "se", "ception", "ele", "er", "type", "one", "d", "see", "ea", "de", "exc", "p", "es", "ae", "null", "or", "E", "a", "ed", "this", "me", "err", "f", "error", "eme", "element", "esi"]}}
{"id1": "62362", "id2": "11477906", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["CONverting", "subverting", "Conversion", "oconversion", "oconverting", "Converting", "CONversion", "unversion", "CONvert", "conversion", "CONception", "oconverted", " deconverted", "converting", "CONverted", "subvert", "oconvert", "Conception", "unvert", "converted", " deconverting", "subversion", "Converted", "unception", "unverted", "subverted", " deconversion", "conception", "Convert", " deconvert"], "src": ["impl", "string", "path", "sel", "ssl", "sin", "input", "sc", "uri", "resource", "sys", "spec", "rc", "Source", "video", "cmp", "username", "filename", "ref", "slice", "cb", "fp", "fn", "s", "prot", "code", "inst", "feat", "cpp", "req", "gb", "back", "source", "reader", "load", "proc", "sb", "rb", "sit", "buf", "component", "dist", "upload", "SourceFile", "config", "file", "tmp", "Dest", "supp", "attr", "img", "href", "storage", "name", "sth", "gz", "RC", "rl", "ctx", "secure", "url", "scene", "stream", "obj", "st", "stage", "sn", "ource", "download", "loc"], "dest": ["path", "class", "temp", " dst", "cont", "fn", "bin", "dc", "std", "txt", "source", "dir", "lib", "target", "dist", "tmp", "Dest", "null", "test", "home", "di", "obj", " destination", "dat", "disk", "orig", "img"], "in": ["IN", "val", "pin", "i", "input", "ex", "n", "inas", "ini", "as", "ins", "bin", "pass", "is", "reader", "d", "source", "doc", "up", "login", "r", "inc", "data", "file", "io", "t", "isin", "In", "a", "stream", "err", "inn", "ps", "f", "inf", "win", "din"], "p": ["P", "i", "pi", "op", "wp", "pre", "lp", "per", "py", "c", "j", "fp", "o", "l", "s", "pb", "cop", "part", "cp", "d", "pr", "pp", "pm", "r", "g", "parser", "h", "np", "po", "tp", "m", "e", "t", "pc", "jp", "pa", "bp", "pe", "b", "sp", "v", "ps", "f", "pd", "pg"], "ds": ["services", "uds", "ays", "docs", "ants", "dos", "s", "ins", "dp", " DS", "parts", "points", "gs", "els", " props", "des", "ts", "js", "utils", "ths", "ys", "gd", "sys", "df", "lp", "bs", "dc", " ps", "dt", "sync", "lines", "eps", "vs", "ges", "amps", "ipes", "pd", "dd", "sts", "DS", "cons", "ks", "ns", "qs", "ld", "hs", "d", "dist", "ans", "ads", "xs", "models", "plugins", "groups", "tests", "ss", "di", "os", "posts", "styles", "rs", "dl", "tools", "ded", "ups", "data", "vals", "scripts", "Ds", "ls", "obs", "dm", "db", "ils", "nas", "dates", "da", "cs", "words", "dds", "ps", "dat", "icks", " sd"], "format": ["letter", "string", "path", "class", "handler", "spec", "filename", "act", "version", "table", "fp", "fn", "host", "tag", "record", "layout", "feat", "magic", "Format", "pattern", "form", "filter", "at", "type", "source", "part", "model", "parser", "config", "data", "file", "sche", "struct", "ant", "language", "style", "plugin", "template", "name", "frame", "t", "function", "prefix", "fd", "nat", "url", "unit", "atter", "f", "scale", "api"], "hasPixelData": ["hasPixeldata", "showsPixelDATA", "hasPixelDATA", "hasPicturedata", "hasByteSize", "hasByteDATA", "hasByteData", "haspixelData", "hasPixelStyle", " hasPixelSize", "showsByteDATA", "hasPictureSize", " hasPixeldata", "haspixeldata", "showsBytedata", "hasPictureData", "haspixelSize", "showsByteData", "showsPixelData", "showsByteStyle", "hasPixelSize", "hasByteStyle", "showsPixelStyle", "hasBytedata", "showsPixeldata"], "inflate": ["inadequating", "insflode", "insvenating", "inffated", "Inflation", "InFlation", "inflating", "Inflated", "inflATE", "InFlace", "insvenate", "inadequode", "InFlated", "insflate", "infolATE", "infface", "invenode", "InFlate", "inffation", "inflated", "inFlation", "infolode", "infloace", "insvenATE", "infloate", "invenATE", "inFlate", "inadequATE", "insflATE", "infloation", "invenating", "inffate", "insvenode", "inadequate", "Inflace", "inflation", "inflode", "inFlated", "Inflate", "infolate", "inFlace", "infloated", "invenate", "infolating", "inflace", "insflating"], "pxlen": ["pxdata", "xpsize", "pxlin", "pngcount", "mxsize", "campos", "fxlen", "pxl", "pgLen", "axlen", "ppLen", "mxcount", "fxln", "pxlon", "pxln", "pcln", "pglen", "ppl", "pxlength", "ppden", "camln", "txln", "pngsize", "pxpos", "pclon", "camlen", "mxdata", "axln", "axlon", "mxlength", "mxpos", "mxlen", "xplen", "txlin", "pxden", "pxcount", "fxpos", "txlon", "pclin", "pxsize", "fxdata", "pxLen", "mxln", "xpcount", "pgl", "fxLen", "axlin", "pnglen", "xplength", "fxl", "pgden", "fxden", "pclen", "pnglength", "txlen", "pplen", "camdata"], "out": ["step", "server", "output", "copy", "sys", "user", "lock", "OUT", "inter", "outs", "line", "co", "query", "post", "session", "cache", "lib", "up", "group", "store", "parent", "work", "page", "log", "gen", "conn", "again", "Out", "io", "dump", "obj", "v", "err", "state", "pad", "cli", "error", "re", "list", "point"]}}
{"id1": "19113613", "id2": "18974466", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"copy": ["zip", "ssh", "Copy", "replace", "move", "clip", "write", "save", "clone", "split", "sync", "cop", "type", "load", "cp", "cat", "upload", " cp", "share", "Cop", "archive", "get", "put", "p", "delete", "change", "update", "create", "paste", "process", "rm", "opy", "transfer", "download"], "in": ["IN", "index", "pin", "base", "i", "input", "id", "n", "sin", "token", "ini", "on", "ic", "c", "inner", "as", "project", "ins", "bin", "client", "part", "reader", "thin", "login", "min", "old", "inside", "diff", "connection", "inc", "work", "data", "config", "get", "init", "plugin", "name", "again", "image", "In", "kin", "a", "url", "update", "lin", "cin", "inn", "f", "win", "this", "din"], "out": ["remote", "goal", "base", "path", "root", "input", "ex", "output", "n", "self", "outer", "user", "resource", "option", "net", "version", "c", "OUT", "project", "o", "outs", "off", "line", "bin", "outside", "client", "part", "at", "one", "cache", "no", "dot", "up", "connection", "other", "group", "inc", "parent", "work", "page", "object", "x", "p", "null", "conn", "init", "again", "name", "exec", "Out", "io", "image", "call", "app", "ext", "v", "b", "err", "obj", "with", "block", "vert", "this", "external", "point"], "source": ["base", "sin", "class", "id", "resource", "uri", "username", "Source", "site", "subject", "project", "dest", "origin", "SOURCE", "iter", "type", "use", "ce", "proxy", "scope", "component", "alt", "feature", "parent", "src", "route", "size", "format", "name", "internal", "force", "status", "family", "prefix", "secure", "position", "url", "pe", "unit", "secret", "reference", "missing", "attribute", "ource", "service", "from", "view", "direction"], "target": ["path", "tail", "base", "address", "root", "goal", "resource", "output", "token", "master", "site", "project", "current", "wrong", "Target", "dest", "origin", "host", "detail", "pattern", "next", "value", "component", "cat", "alt", "arget", "parent", "config", "route", "src", "alias", "null", "format", "about", "template", "name", "force", "home", "prefix", "url", "top", "reference", "service", "point", "direction"], "files": ["keys", "fs", "pages", "results", "resources", "docs", "filename", "features", "assets", "apps", "ins", "Files", "s", "items", "tools", "links", "iles", "lines", "flows", "users", "blocks", "children", "ports", "names", "classes", "data", "images", "objects", "models", "plugins", "groups", "ls", "obs", "jobs", "cells", "ions", "sections", "f"], "file": ["directory", "string", "letter", "base", "path", "fe", "id", "resource", "feed", "ile", "uri", "entry", "filename", "per", "current", "fp", "l", "child", "line", "el", "File", "part", "load", "binary", "dir", "live", "item", "lib", "FILE", " File", "parent", "data", "entity", "local", "page", "object", "le", "single", "name", "folder", "e", "function", "it", "layer", "url", "unit", "b", "future", "f"], "inCh": ["InCh", "outCH", " inCH", "Inch", " inChannel", "InChan", "inChannel", "INChan", " inch", "outChan", "inChan", "InChannel", "INCH", "outch", "inCH", "InCH", "INChannel", "INCh", "inch", " inChan", "outChannel"], "outCh": ["outputCh", " outCH", "outCH", "outputch", "OutChannel", " outChannel", "OutChan", "Outch", "inChannel", "outChan", "inChan", "outch", "inCH", "outputCH", "OutCh", "inch", "outputChan", "OutCH", "outChannel", " outch"]}}
{"id1": "16232202", "id2": "8064604", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"doPost": ["doingPut", "didPost", "doingPOST", "didPOST", "didPut", " doPOST", " doPut", "doSend", "doPut", "didSend", " doSend", "doPOST", "doingPost", "doingSend"], "request": ["event", "remote", "info", "order", "error", "input", "Request", "server", "resource", "self", "user", "list", "register", "report", "enter", "rf", "subject", "message", "current", "project", "result", "join", "instance", "child", "press", "query", "save", "condition", "req", "queue", "post", "next", "er", "client", "select", "rate", "session", "reader", "type", "use", "q", "load", "application", "upload", "store", "parent", "data", "route", "web", "object", "page", "get", "context", "row", "hello", "complete", "submit", "e", "QUEST", "image", "url", "create", "you", "parse", "xml", "state", "method", "re", "external", "view", "initial"], "response": ["index", "server", "output", "resource", "feed", "serv", "uri", "http", "report", "res", "message", "document", "subject", "site", "onse", "fire", "result", "forward", "shell", "pool", "query", "su", "ception", "en", "next", "exit", "session", "resp", "model", "application", "parent", "de", "body", "page", "environment", "object", "web", "ae", "reply", "complete", "tree", "e", "status", "writer", "image", "re", "Response", " Response", "respond", "we", "wa", "error", "esi", "service", "api", "view"], "cu": ["U", "ou", "tc", "cc", "lu", "cf", "rc", "aca", "ue", "c", "ru", "CU", "co", "du", "su", "ui", "agu", "Cu", "ku", "uu", "VC", "cus", "chu", "vc", "asu", "ce", "lc", "uc", "cy", "tu", "ca", "xc", "usa", "CA", "u", "eu", "uni", "hu", "ci", "coll", "uci", "ucc", "mc", "cum", "cci", "cul", "ac", "CI", "gu", "ul", "UC", "cin", "nu", "cli", "cur", "cca", "loc"], "ud": ["uds", "ou", "um", "uri", "lu", "user", "df", "rc", "od", "ck", "ue", "uv", "ru", "uid", "pub", "du", "su", "ui", "usr", "util", "ku", "uu", "ad", "cus", "uf", "gb", "chu", "asu", "uc", "uda", "ug", "UD", "ut", "upload", "au", "tu", "li", "utils", "udi", "ub", "usa", "usc", "u", "uli", "eu", "ci", "db", "us", "bug", "auth", "ur", "wik", "vd", "gu", "ada", "da", "cli", "pd", "stri", "dd", "storage"], "returnTo": ["exitFrom", "exitTo", "accessFrom", "ReturnFrom", "accessTO", "backto", "outputto", "exitTO", "outputTo", "outputTO", "returnFrom", "backTO", "backTo", "ReturnTo", "Returnto", "backFrom", "returnTO", "exitto", "replyto", "replyTo", "ReturnTO", "outputFrom", "replyFrom", "accessto", "returnto", "accessTo", "replyTO"], "password": ["string", "address", "sum", "mask", "username", "token", "user", "message", "confirmed", "account", "patch", "wd", "key", "params", "Password", "email", "mac", "PASS", "sha", "diff", "login", "sword", "data", "encrypted", "null", "name", "ass", "word", "wallet", "pa", "auth", "secret", "pad", "padding", "crypt", "phrase", "pg", "code"], "md": ["mag", "bd", "df", "managed", "od", "amd", "mo", "ma", "am", "meta", "wd", "MD", "dc", " MD", "rpm", "sm", "ms", "mb", "mt", "mac", "d", "mp", "hd", "sha", "diff", "mm", "cd", " Md", "dig", "m", "dm", "db", "mand", "mc", "mn", "vd", "rm", "mg", "mad", "f", "cmd", "dd", "pg"], "hash": ["total", "base", "sum", "her", "user", "version", "ref", "kh", "confirmed", "hex", "Hash", "number", "tag", "ash", "key", "char", "raw", "no", "mac", "cache", "dot", "rh", "sha", "diff", "h", "row", "dig", "ass", "hed", "array", "db", "url", "sh", "auth", "secret", "block", "code"], "pass": ["push", "string", "sum", "mess", "id", " mess", "user", " mac", "act", "ref", "wd", "key", "fail", " passed", " auth", "mac", "PASS", "phrase", "login", "diff", "r", "ask", "text", "Pass", " def", "gen", "row", "conn", "ass", " login", "pos", "az", "ss", "db", "sl", "strip", "pa", "secret", "auth", " Pass", "conf", "sign", "def", " secret"], "vis": ["class", "att", "qa", "cross", "id", "ex", "spot", "travel", "act", "c", "lab", "miss", "ref", "rib", "host", "press", "mit", "su", "dc", "san", "feat", "visible", "type", "stat", "see", "acc", "nav", "ip", "keep", "style", "lit", "tri", "name", "coll", "nic", "vest", "status", "VIS", "exp", "ravis", "access", "circ", "virt", "vid", "na", "skip", "nat", "secret", "shape", "design", "gu", "sign", "Vis", "wa", "state", "vert", "fac", "view", "mis"]}}
{"id1": "3958807", "id2": "18748516", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadBatchStream", "loadFbinaryFile", "loadBInputContent", "loadBbinaryInput", "loadBbinaryContent", "loadBinaryInput", "loadBinaryContent", "loadFbinaryStream", "loadBinaryFile", "loadBatchInput", "loadFinaryContent", "loadBbinaryFile", "loadFbinaryContent", "loadBatchFile", "loadFinaryStream", "loadFinaryInput", "loadBInputFile", "loadBInputStream", "loadFbinaryInput", "loadBInputInput", "loadBatchContent", "loadFinaryFile", "loadBbinaryStream"], "streamName": ["resourceName", "filename", "StreamName", "streamType", "channelName", "filePath", "resourceType", "channelPath", " streamPath", "fileType", "fileKey", "resourcename", " streamname", "Streamname", "fileName", "StreamPath", " streamKey", "streamPath", "channelKey", "streamKey", "streamname", " streamType", "resourcePath"], "streamToLoad": [" streamtoRead", "objectToUse", "streamtoLoad", " streamtoLoad", "channelToLoad", "streamWillRead", "streamWillLoad", "objectTOUse", "streamToload", "channeltoLoad", "streamWillUse", " streamToUse", "streamTOload", "streamToUpload", "streamTOAdd", "streamtoRead", " streamtoAdd", "objectTOUpload", "streamWithAdd", "streamTOUse", "objectToRead", "channeltoload", "objectTORead", "streamToUse", " streamToAdd", "streamtoload", "streamWithUse", "streamWillUpload", "streamWithLoad", "objectToLoad", "streamWillAdd", "objectToUpload", "objectTOLoad", "streamToRead", "streamtoAdd", "streamtoUse", "streamTOUpload", "channelToload", "streamtoUpload", "streamTOLoad", "streamTORead", "streamToAdd", " streamToRead", "channelToAdd", "channeltoAdd", "streamWithRead", " streamtoUse"], "sz": ["psze", "wsz", "siz", " szi", "wszip", "ssz", "imszes", "imsz", "imsiz", "pszip", "sze", " siz", "wsze", "imsze", "pszi", "szip", " szip", " sze", "ssiz", "sszes", "psz", "wszi", " szes", "szi", "ssze", "szes"], "req": ["qt", "rw", "pkg", "input", "Request", "serv", "response", "sem", "ok", "http", "res", "report", "ref", "cb", "inv", "fr", "client", "rh", "Resp", "q", "proc", "r", "src", "require", "request", "requ", "conn", "rec", "rr", "rss", "exec", "rx", "ctx", "respond", "err", "obj", "def", "progress", "f", "wx", "download"], "resp": ["zip", "remote", "server", "serv", "response", "output", "cmp", "df", "report", "res", "http", "wp", "ref", "rel", "fp", "html", "api", "ret", "rem", "wx", "client", "rh", "Resp", "proc", "wb", "par", "body", "rep", "request", "bb", "page", "reply", "conn", "rec", "rss", "e", "exec", "esp", "jp", "rev", "circ", "ctx", "cook", "respond", "Response", "comm", "rup", "obj", "err", "sp", "prev", "re", "download"], "out": ["zip", "base", "buffer", "i", "output", "copy", "response", "serv", "op", "res", "OUT", "outs", "o", "fn", "s", "pool", "co", "bin", "in", "ws", "cache", "binary", "ops", "buf", "default", "data", "tmp", "object", "p", "log", "null", "conn", "again", "aos", "gz", "Out", "io", "exec", "b", "os", "boot", "auto", "img"], "bos": ["bis", "lo", "ko", "fits", "bh", "zos", "biz", "obb", "bs", "bo", "obos", "bin", "oos", "obo", "bro", "bes", "flo", "ros", "bps", "ob", "bas", "ubis", "bott", "las", "bb", "bi", "zb", "aos", "obs", "rob", "cro", "bare", "ios", "bc", "bot", "pins", "osa", "lol", "los", "zo", "abi", "oops", "os", "osi", "boot", "mis"]}}
{"id1": "949327", "id2": "6403868", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"f": ["path", "fun", "fe", "sf", "n", "fs", "feed", "cf", "df", "fa", "lf", "bf", "rf", "filename", "c", "ref", "j", "fc", "fp", "fi", "l", "s", "fn", "fr", "ff", "form", "fold", "d", "r", "g", "w", "file", "flat", "h", "x", "p", "name", "folder", "e", "m", "io", "t", "fo", "fm", "function", "F", "fd", "self", "a", "fen", "of", "v", "b", "tf", "inf", "this", "fx"], "in": ["IN", "pin", "ssl", "fa", "token", "ini", "ic", "ins", "bin", "thin", "vin", "get", "gen", "it", "a", "with", "din", "ex", "serv", "lock", "part", "source", "up", "connection", "min", "r", "str", "g", "w", "rin", "again", "exec", "isin", "In", "lin", "b", "v", "inn", "win", "n", "gin", "con", "inner", "socket", "session", "reader", "d", "diff", "p", "init", "or", "m", "image", "nin", "ac", "cin", "fe", "input", "c", "l", "pass", "is", "login", "inc", "config", "data", "rec", "t", "err"], "cbuf": ["cbux", "dbuf", "zbuff", "bbuff", "fbbuf", "cfbuf", "rbuff", "bbull", "cbul", "bcul", "CBuc", "bcuc", "bcull", "CBuf", "CBuff", "zbuu", "cfuf", "fbuc", "bcurs", "dbuc", "rbuc", "cbutf", "rbuu", "cbbuf", "cburs", "CBul", "bault", "bux", "buff", "ebuu", "buf", "cfuc", "rbutf", "rbbuf", "rbull", "bcuf", "bcuff", "bcault", "ebuf", "fbuff", "rbux", "zbuf", "bcur", "ebutf", "cbuff", "rbuf", "rburs", "rbul", "cbull", "cbuc", "bbuf", "cbuu", "cfuff", "fbuf", "zbutf", "dbuff", "ebuff", "bburs", "bcux", "dbur", "cfur", "rbault", "cbur", "cbault"], "read": ["index", "Read", "each", "hex", "run", "ride", "en", "raw", "only", "q", "build", "open", "used", "get", "lex", "it", "readable", "ed", "print", "know", "buffer", "num", "id", "feed", "rc", "add", "report", "oct", "ack", "ind", "end", "find", "sync", "use", "load", "r", "g", "work", "w", "level", "un", " READ", "fill", "name", "bit", "ing", "full", "skip", "connect", " reading", "val", "play", "close", "reading", "ok", "socket", "se", "length", "write", "record", "iter", "sleep", "loop", "er", "allow", "reader", "d", "old", " Read", "bind", "insert", "start", "change", "io", "update", "create", "y", "wait", "repeat", " write", "ink", "error", "view", "valid", "ak", "input", "child", "draw", "reads", "pass", "key", "last", "select", "type", "want", "seek", "inc", "data", "text", "config", "check", "x", "size", "log", "put", "cel", "send", "call", "pe", "k", "parse", "stream", "ize", "count", "READ", "re", "orig"], "totRead": ["octotoLength", "tottedWrite", "TotGet", "tcotClose", "tcotRead", "dottLoad", "octotWrite", " totalBuild", "tottedGet", "tntReader", "tottUse", "octotoRead", "totLink", "totBuild", "towLength", "dottReader", "totoLength", "tazonClose", "tetReading", "toyDraw", "totClose", "totiBuild", " totWrite", "notLoad", "notWrite", "intottBuild", "tottLength", "tottAccept", "totalLoad", "towLoad", "totalLink", " totalWrite", "nottAccept", "towWrite", "nottRead", "totoSearch", "tochRead", "intotLoad", "tottReading", "tottWrite", "toyWrite", "tollRead", "tottedRead", "tottLoad", "octotLength", "TotConnect", "ntotWrite", "tetRead", "TotLoad", "totoUse", "tntRead", "dottUse", "octotReading", "TottConnect", "ntottLoad", "TotSearch", "TotaRead", "totoLoad", "tntLoad", "TotaLoad", "tottClose", "totDraw", "totLength", "towAccept", "TottReading", "tobyRead", "intotClose", "towReading", "totingSearch", "totaDraw", "totoWrite", "TotDraw", "nottLoad", "toyRead", "tcotBuild", "totReading", "totConnect", "octotRead", "ntottWrite", "totalAccept", "totalRead", "totLoad", "tazonBuild", "totalBuild", "tntWrite", "totoRead", "dotRead", "ntotRead", "totingWrite", "ntotLoad", "totReader", "notAccept", "totaRead", " totBuild", "tottSearch", "ntottReader", "notRead", "totingRead", "totWrite", "tazonLoad", "totingGet", "dotLoad", "dotReader", "dotUse", "dottFind", "tobyFind", "TotaWrite", "tochLoad", "tottedFollow", "ntotReader", "intotRead", "intottLoad", "totUse", "totaReading", "totaLoad", "totaWrite", "tcotLoad", "TottReader", "tottReader", "totiRead", "tatRead", "totiWrite", "dottWrite", "toyLoad", "TottFollow", "tottFollow", "tatLoad", "totingConnect", "dotFind", "tochReader", "tottConnect", "dottReading", "intotBuild", "TotReader", "totoFind", "tollLoad", "tochWrite", "tobyUse", "tottDraw", "dottRead", "totaLink", "tobyLoad", "totoConnect", " totalRead", "totingFollow", "TottLoad", "TottWrite", "TotaDraw", "tottRead", "tetWrite", "totFind", "nottWrite", "towRead", "TotReading", "totalWrite", "octotoReading", "tollReading", "tatReader", "tollWrite", "dotReading", "tottFind", "ntottRead", "intottRead", "totiLink", "totFollow", "tetLoad", " totalLink", "tazonRead", "totSearch", "TotFollow", "totGet", "octotoWrite", "TottRead", "TotRead", "totaBuild", "TottGet", " totLink", "intottClose", "totoReading", "tottGet", "TottSearch", "totaReader", "dotWrite", "totAccept", "tottBuild", "tatWrite", "TotWrite"], "out": ["ex", "output", "n", "plus", "outer", "net", "c", "OUT", "socket", "o", "outs", "l", "fn", "s", "off", "bin", "client", "sync", "part", "d", "up", "connection", "r", "g", "w", "inc", "parent", "file", "h", "x", "p", "conn", "init", "again", "exec", "Out", "io", "t", "exp", "writer", "In", "a", "ext", "conf", "v", "b", "err", "obj", "ac"], "i": ["index", "ini", "ic", "ii", "q", "chi", "ci", "I", "eni", "zi", "it", "hi", "iu", "multi", "info", "buffer", "id", "ind", "z", "ui", "ori", "ti", "source", "r", "g", "ip", "mi", "ai", "name", "oi", "e", "b", "v", "ik", "uri", "ei", "yi", "slice", "o", "length", "qi", "one", "ji", "d", "phi", "h", "p", "bi", "u", "init", "start", "m", "io", "di", "y", "ni", "api", "ix", "input", "pi", "ie", "c", "current", "j", "fi", "ri", "l", "si", "is", "key", "my", "data", "li", "x", "xi", "gi", "k", "me", "abi"]}}
{"id1": "21921000", "id2": "7872659", "code1": "    @Override\n    public void parse() throws IOException {\n        URL url = new URL((new DataUrlResolver()).getDataUrl(DomainName.CROATIA));\n        URLConnection con = url.openConnection();\n        BufferedReader bStream = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String str;\n        bStream.readLine();\n        while ((str = bStream.readLine()) != null) {\n            String[] tokens = str.split(\"(\\\\s+)\");\n            String charCode = tokens[0].replaceAll(\"([0-9+])\", \"\");\n            Float value = Float.parseFloat(tokens[2].trim().replace(\",\", \".\"));\n            CurrencyUnit unit = new CurrencyUnit(charCode, value, DEFAULT_MULTIPLIER);\n            this.set.add(unit);\n        }\n    }\n", "code2": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["execute", "add", " convert", "end", " analyse", "run", " parser", " parsing", " parsed", "next", " init", "construct", "load", "build", "parser", " feed", "init", " analyze", " setup", "ize", " load", "print", "process", " discover", "Parser"], "url": ["zip", "string", "path", "ssl", "base", "address", "server", "uri", "resource", "user", "http", "l", "host", "URL", "client", "source", "connection", "open", "data", "file", "web", "bb", "log", "conn", "ls", "sl", "service", "Url", "www", "ur", "b", "f", "this", "org"], "con": ["Connection", "close", "Conn", "fa", "n", "resource", "CON", "cons", "http", "plain", "c", "socket", "fc", "pub", "Con", " conn", "func", "in", "client", "sync", "connection", "login", "r", "open", "un", "conv", "file", "out", "channel", "ca", "log", "conn", "coll", "exec", "ann", "cr", "pc", "ctx", "bc", "com", "can", "conf", "b", "cn", "connect", "f"], "bStream": ["aFile", " bstream", "rbstream", "aReader", "bReader", "bbstream", "bW", "rbReader", "bRead", "bsstream", "aRead", "aStream", "bbRead", "bsW", "bsStream", " bConnection", "bFile", "rbStream", " bFile", "bbW", "bbReader", "rbFile", " bReader", "bsConnection", "bbStream", " bRead", "astream", "bConnection", "bbConnection", "bstream", " bW"], "str": ["string", "i", "input", "id", "n", "spec", "cur", "enc", "res", "c", "result", "l", "s", "line", "fr", "pass", "in", "char", "key", "arr", "er", "Str", "part", "doc", "pr", "r", "div", "STR", "data", "text", "p", "name", "coll", "status", "cr", "dec", "sl", "tr", "strip", "obj", "sp", "br", "err", "st", "kr", "f", "step", "stri", "sr"], "tokens": ["takets", "tokicks", "tractos", "topents", "pokenents", "Tokos", "Tokens", "takents", "token", "Takents", "tokos", "toksens", "Tokets", "tarsen", "Tokicks", "toksets", "tractens", "tarses", "Takens", "toksos", "Token", "topets", "tokenen", "poks", "Taken", "Takets", "tops", "takens", "takicks", "pokets", "pokenets", "Takos", "Tokes", "taks", "tokents", "tarsicks", "tokenents", "topens", "takes", "tractents", "tokenets", "Takes", "pokenens", "tokets", "toksents", "tarsens", "tractets", "Tokents", "tokenens", "taken", "tokenes", "Takicks", "tokes", "toks", "tokenicks", "pokens", "pokents", "takos"], "charCode": ["charcode", "CharType", "charactercode", "characterName", "characterCount", " charCount", " charNumber", "charType", " charType", "charNumber", "Charcode", "CharCount", "CharCode", "charName", "CharNumber", "characterNumber", "charCount", " charName", "characterCode", " charcode", "CharName", "characterType"], "value": ["val", "string", "base", "price", "num", "fe", "entry", "version", "current", "number", "volume", "result", "amount", "flow", "grade", "key", "weight", "flo", "Value", "rate", "type", "money", "default", "data", "VALUE", "object", "size", "format", "name", "dollar", "function", "values", "v", "range", "count", "scale", "element"], "unit": ["letter", "string", "base", "class", "num", "category", "output", "factor", "option", "version", "number", "Unit", "instance", "flow", "currency", "split", "union", "rate", "type", "item", "target", "component", "un", "data", "out", "size", "u", "format", "uni", "it", "position", "units", "scale", "element", "term", "point"]}}
{"id1": "6457199", "id2": "13595251", "code1": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 1, "substitutes": {"doRequest": ["runResponse", "DoRequest", "doCall", "DoCall", "doResponse", "runCall", " doCall", " doProxy", "doProxy", "runProxy", "runRequest", "DoProxy", " doResponse", "DoResponse"], "request": ["event", "string", "error", "buffer", "Request", "server", "uri", "user", "http", "report", "message", "json", "result", "instance", "query", "queue", "req", "client", "session", "reader", "application", "route", "object", "context", "complete", "hello", "name", "call", "url", "right", "reference", "xml", "method", "re", "view"], "response": ["index", "respons", "server", "output", "feed", "more", "report", "results", "http", "message", "document", "json", "site", "onse", "result", "host", "client", "resp", "connection", "model", "application", "parent", "out", "route", "body", "page", "object", "reply", "template", "status", "writer", "re", "success", "Response", "respond", " Response", "v", "reference", "error", "service", "api", "view"], "path": ["anc", "index", "string", "base", "info", "self", "uri", "id", "token", "http", "relative", "message", "slice", "Path", "inner", "end", "patch", "location", "child", "host", "api", "key", "pattern", "content", "part", "type", "source", "dir", "ath", "alias", "work", "data", "text", "route", "object", "p", "context", "name", "template", "arc", "image", "port", "pointer", "walk", "full", "prefix", "url", "PATH", "ith", "partial", "right", "left", "method", "code"], "internal": ["impl", "remote", "string", "base", "personal", "original", "absolute", "uri", "rc", "http", "relative", "intern", "primary", "system", "Internal", "inner", "join", "standard", "origin", "api", "ident", "outside", "source", "central", "binary", "exclusive", "international", "inside", "shared", "alias", "parent", "attr", "route", "regular", "local", "background", "x", "inline", "context", "storage", "name", "rx", "normal", "re", "prefix", "special", "url", "foreign", "custom", "actual", "external", "single", "initial"], "resource": ["string", "rest", "base", "address", "buffer", "server", "uri", "rc", "http", "resources", "res", "result", "rera", "api", "relation", "record", "manager", "client", "source", "rule", "use", "connection", "sr", "media", "r", "real", "file", "route", "ruby", "src", "context", "image", "pointer", "url", "this", "Resource", "stream", "resolution", "reference", "range", "ource", "re", "external"], "mimeType": [" mileInfo", "mimeInfo", "mimePath", "maxtype", "modName", "mimeTypes", " mimeInfo", " mileType", "mimesInfo", " mimePath", "smIMEType", "mipType", "mpeType", "monsePath", "mIMEInfo", "mileTypes", "mIMEName", "pimePath", "mpePath", "pipPath", "mpeTypes", "smIMEtype", "smIMEInfo", " mileTypes", "manceType", "pimetype", "manceTypes", "mancePath", "monsetype", "smimetype", "monseType", "smimeType", "smIMEName", "mimetype", "milePath", "pipType", "pimeTypes", "maxName", "smimeInfo", "maxType", "pipTypes", "pimeType", "mileInfo", "modType", "mipPath", "piptype", "mileType", "modInfo", "mpeInfo", "maxInfo", "mIMEType", "monseTypes", "mancetype", "mipTypes", "modtype", "mimesTypes", "mimesPath", "miptype", "mIMEtype", " mimeTypes", "mimeName", "mimesType", " milePath", "smimeName"], "is": ["info", "bis", "i", "iss", "lis", "uri", "serv", "IS", "fs", "isa", "http", "res", "Is", "as", "ri", "api", "ois", "ui", "in", "ori", "its", "ops", "ais", "isc", "ir", "nis", "ras", "ip", "or", "vs", "ris", "iris", "ios", "us", "isi", "sis", "are", "ps", "was", "im", "iso"], "os": ["oses", "acs", "Os", "opens", "res", "ols", "dos", "as", "OS", "o", "outs", "s", "bs", "ori", "ies", "so", "ros", "bos", "ops", "ais", "nos", "ows", "oes", "ose", "vs", "aos", "oss", "io", "ios", "oS", "us", "cs", "los", "ps", "osi", "iso", "cos"]}}
{"id1": "19335986", "id2": "12766394", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["CaughtException", "uncachedexc", "uncatchedexc", "uncaughtEvent", "CatchedEvent", "Catchedexc", "Caughtexc", "uncaughtexc", "uncachedEvent", "uncachedException", "uncatchedException", "unchandledException", "unchandledexc", "CatchedException", "uncatchedEvent", "CaughtEvent", "unchandledEvent"], "t": ["n", "c", "l", "s", "te", " T", "ty", "type", "d", "r", "g", "w", "out", "p", "ts", "let", "title", "m", "tree", "ing", "it", " td", "T", "tr", "ed", "f", "tx"], "e": ["event", "fe", "i", "ace", "ee", "be", "ie", "eb", "c", "ge", "j", "se", "o", "s", "el", "ception", "ele", "en", "ec", "er", "d", "ce", "diff", "r", "data", "de", "exc", "ep", "p", "es", "ae", "environment", "ne", "eu", "example", "m", "E", "ev", "ed", "pe", "me", "err", "f", "error", "oe", "Exception", "element", "code", "enter", "esi"], "display": ["play", "fe", "console", "panel", "report", "profile", "description", "window", "host", "layout", "content", "monitor", "scroll", "d", "hide", "show", "default", "config", "de", "body", "page", "object", "p", "style", "dis", "status", "image", "screen", "Display", "position", "app", "me", "summary", "design", "container", "process", "this", "view", "platform"], "shell": ["hell", "buffer", "console", "server", "copy", "lock", "mail", "system", "echo", "l", "child", "host", "el", "clone", "loop", "tools", "sb", "live", " Shell", "machine", "math", "body", "cl", "launch", "h", "environment", "log", "bash", "m", "exec", "image", "status", "Shell", "ml", "kernel", "sym", "app", "sh", "sound", "b", "poll", "container", "process", "xml", "help", "gui", "cli", "tool"], "message": ["event", " exception", "address", "buffer", "translation", "mess", "console", "server", "output", "copy", "response", "report", "mail", "document", "description", "result", "management", "queue", "content", "monitor", "email", "member", "value", "media", "model", "application", "data", "body", "page", "object", "request", "flash", "Message", "log", "msg", "header", "m", "meter", "status", "image", " messenger", "update", "summary", "xml", "essage", "error", "view"], "e1": [" e3", "e3", "exc2", "e8", " e2", "E1", "e2", "E3", "E2", " e8", "E8", "exc3", "exc8", "exc1"]}}
{"id1": "8515891", "id2": "17729554", "code1": "    protected String readUrl(String svnUrl) throws IOException {\n        URL url = new URL(svnUrl);\n        URLConnection uc = url.openConnection();\n        if (url.getProtocol().equals(\"https\")) {\n            String userPassword = user + \":\" + password;\n            String encoding = new sun.misc.BASE64Encoder().encode(userPassword.getBytes());\n            uc.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        InputStream is = null;\n        String in = null;\n        try {\n            is = uc.getInputStream();\n            in = read(is);\n        } finally {\n            try {\n                is.close();\n            } catch (Exception e) {\n            }\n        }\n        return in;\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 0, "substitutes": {"readUrl": ["ReadQuery", "getUrl", "processURL", "getQuery", "processPage", "readPage", "getURL", "ReadURL", "getPage", "processUrl", "readQuery", "readURL", "processQuery", "ReadPage", "ReadUrl"], "svnUrl": ["svlURL", " svnURL", " svNEl", "svbUrl", "svbUr", " svNUr", "svNUrl", "svnEl", " svnFile", "svcnStr", "svNStr", "svbFile", " svNFile", "svpnFile", " svNURL", " svnStr", "svnStr", " svnEl", "svnUr", "svlEl", "svnFile", "svbURL", "svcnURL", "svNFile", "svNEl", "svpnUrl", " svnUr", "svlUrl", "svcnUrl", "svNUr", "svlStr", "svnURL", " svNStr", "svcnEl", "svpnURL", "svpnUr", " svNUrl", "svNURL"], "url": ["path", "ssl", "server", "uri", "resource", "feed", "user", "http", "c", "fc", "l", "URL", "util", "client", "up", "connection", "r", "ob", "open", "config", "cl", "web", "page", "bb", "log", "context", "conn", "blog", "sl", "pull", "Url", "bc", "www", "stream", "bug", "ur", "b", "ul", "f", "plug", "cur", "this", "org", "loc"], "uc": ["anc", "cu", "ssl", "tc", "cc", "sc", "uri", "cf", "rc", "http", "con", "c", "fc", "co", "ec", "client", "cp", "cas", "up", "auc", "connection", "ocr", "lc", "oc", "roc", "uca", "cl", "ub", "usc", "conn", "coll", "exec", "uci", "userc", "ucc", "pc", "mc", "us", "soc", "bc", "cci", "bug", "ac", "connect", "UC", "ul", "hub", "cur", "loc"], "userPassword": ["userSecret", "currentSecret", " userSecret", "currentPassword", " userpassword", "usePass", " userAuth", "userPass", "currentpassword", "userpassword", " userPass", "usepassword", "UserPassword", "UserPass", "userAuth", "useAuth", "Userpassword", "UserAuth", "useSecret", "usePassword", "currentPass"], "encoding": ["encording", "enoder", "Encoded", "Encoder", " encoder", "Encording", "enasing", "Encoding", "engoded", "enoded", "enoding", "engasing", " encoded", "engoding", " encording", "Encasing", "encoder", "enording", "encasing", "encoded", "engoder"], "is": ["info", "bis", "i", "iss", "id", "uri", "fs", "IS", "lis", "isa", "serv", "ie", "Is", "as", "ri", "irc", "ins", "s", "abs", "si", "ois", "ui", "ms", "ori", "isl", "its", "ws", "ais", "isc", "ir", "out", "src", "nis", "ip", "es", "has", "iso", "init", "vs", "ls", "ris", "ci", "it", "iris", "ios", "us", "ib", "isi", "are", "cs", "os", "was", "api"], "in": ["IN", "string", "pin", "edIn", "i", "id", "inas", "input", "reading", "ini", "gin", "into", "con", "inner", "atin", "ins", "arin", "line", "bin", "read", "raw", "source", "reader", "login", "inside", "inc", "rin", "out", "oin", "vin", "rec", "again", "m", "re", "isin", "In", "nin", "pc", "kin", "cin", "inn", "f", "tin", "din"]}}
{"id1": "13886238", "id2": "4461350", "code1": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 0, "substitutes": {"init": ["rest", "info", "setup", "reset", " reload", "activate", "construct", "load", "art", "build", "open", "strap", "config", "check", "launch", " Init", "destruct", "initialized", "test", "start", "it", "update", "parse", " discover", "Init", "error"], "backupFile": ["backupsFile", "backrapFiles", "backupFILE", "backrapDir", "backrapFile", "BackupStream", "BackdownStream", "lookupfile", "backacyFILE", "backupDir", "backupStream", "lookupFILE", "backbookF", "backoutFolder", "backupsDir", "lookoutFILE", "lookupFile", "backupfile", "BackupSourceFile", "backUPStream", "lookoutFile", "BackupDir", "BackureFile", "backupFiles", "backoutFILE", "backupsSourceFile", "BackureFiles", "backbackFolder", "backUPF", "backbookStream", "backureFile", "backureDir", "BackdownF", "backbookFile", "backupsFiles", "backUPFiles", "backupSourceFile", "backdownFile", "BackdownFile", "backbackfile", "backureSourceFile", "backupF", "lookoutFolder", "backdownFiles", "BackupFiles", "backrapSourceFile", "backoutFile", "backacyFolder", "lookupFolder", "BackdownFiles", "backUPFile", "backacyfile", "BackupFile", "backbackFILE", "BackureSourceFile", "BackupF", "backbackFile", "backureFiles", "lookoutfile", "backdownF", "backdownStream", "backupFolder", "backoutfile", "backbookFiles", "backacyFile", "BackureDir"], "buff": ["zip", "uff", "buffer", "fe", "bf", "feed", "oct", "now", "slice", "cb", "grab", "length", "gg", "ff", "ffff", "pb", "char", "uf", "bg", "txt", "gb", "comp", "mb", "utf", "cp", "rb", "comb", "load", "pp", "sb", "back", "buf", "cond", "ch", "ob", "build", "bind", "fb", "cast", "bb", "gz", "font", "Buff", "flush", "app", "shape", "comment", "b", "bound", "ph", "fab", "cod", "pad", "cmd", "boot"], "in": ["IN", "pin", "ssl", "i", "input", "id", "n", "serv", "ini", "gin", "con", "c", "inner", "socket", "slice", "l", "ins", "s", "el", "bin", "pass", "part", "reader", "up", "login", "min", "diff", "connection", "r", "inside", "old", "inc", "data", "get", "or", "again", "e", "exec", "image", "isin", "In", "nin", "url", "stream", "lin", "b", "ac", "cin", "inn", "f", "win", "din"], "out": ["IN", "ex", "output", "copy", "n", "serv", "user", "net", "OUT", "inner", "socket", "o", "outs", "ins", "line", "co", "bin", "pass", "client", "sync", "part", "one", "reader", "doc", "lib", "up", "inc", "file", "gen", "conn", "again", "exec", "Out", "io", "writer", "exp", "ax", "prefix", "ext", "conf", "err", "b", "win"], "read": ["index", "roll", "max", "Read", "run", "ride", "en", "raw", "build", "open", "get", "row", "lex", "readable", "buffer", "id", "feed", "lock", "add", "ind", "end", "find", "next", "sync", "use", "load", "r", "work", "level", "ip", "search", "fill", "exec", "skip", "reach", "b", "connect", "play", "close", "i", "n", "reading", "ok", "se", "length", "write", "ad", "sleep", "iter", "reader", "d", " Read", "bind", "start", "wait", "ink", "view", "input", "copy", "current", "child", "reads", "pass", "last", "select", "ask", "seek", "data", "text", "check", "x", "size", "log", "send", "k", "parse", "count", "READ", "block"], "reportWriter": [" reportReader", "reportHelper", "summaryJournal", "reportReader", "reportedTime", " reportDriver", "commentWrite", "exportJournal", "reportedWriter", "reviewWrite", "ReportWs", "reportWs", "reportWalker", "commentStream", "exportWrite", "resultStream", " reportHelper", "reportedDriver", "summaryWriter", "exportWriter", "ReportWriting", "exportHelper", "ReportReader", "reviewTime", "exportApplication", "reportApplication", " reportWriting", "summaryStream", "reportedReader", "reportedWriting", "exportPublisher", "reviewWriter", " reportWalker", "exportWalker", "commentWriter", " reportPublisher", "reportWrite", " reportTime", "reviewEditor", "reportedWs", "ReportWrite", "reportedEngine", "reportWriting", "resultWriter", "ReportWriter", "reportedHelper", "ReportApplication", " reportWrite", "reportJournal", " reportJournal", "reportTime", "reportedWalker", " reportEngine", "reportEditor", "reportStream", "reportPublisher", "reviewEngine", " reportApplication", "summaryWrite", "reportEngine", "reportedEditor", " reportWs", "resultPage", "summaryPublisher", "resultWrite", "summaryPage", "reviewDriver", " reportEditor", "reportPage", "exportReader", "reportDriver", "reportedWrite", "commentPage"], "restarting": ["restrupted", "restarmING", "restarmed", "restartting", "Restriting", "Restrited", "restarted", "restritating", "restartsing", "Restarting", "restarsing", "restartable", "restartING", "Restritating", "restritING", "Restartting", "Restarted", "RestartING", "restrited", "Restritable", "restriting", "restarsING", "restartsting", "restarmable", "Restartating", "restartating", "restritting", "Restartable", "restruptING", "restartsating", "restruptable", "restarming", "restarsting", "RestritING", "restritable", "restartsING", "restarsating", "Restritting", "restrupting"]}}
{"id1": "4056444", "id2": "7761195", "code1": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"hashPassword": ["printPassword", " hashSecret", " hashpassword", "updateWord", "printSecret", "hashWord", "printWord", "printpassword", "updateSecret", "hashpassword", " hashWord", "updatePassword", "updatepassword", "hashSecret"], "password": [" Password", "string", "path", "address", "input", "token", "username", "user", "message", "confirmed", "account", "pool", "param", "wd", "pass", "database", " passwords", "security", "Password", "email", "cache", "PASS", "sha", "login", "sword", "data", "text", "out", "p", "null", "name", "word", "prefix", "secret", "auth", "SHA", "create", "random", "words", "padding", "attribute", "crypt", "phrase", "code"], "md": ["sum", "bf", "mag", "bd", "od", "amd", "mo", "ma", "am", "wd", "MD", " MD", "sm", "ad", "mb", "mt", "dh", "mac", "d", "mp", "sha", "hd", "pm", "rod", "pd", "mm", "nd", "metadata", "dig", "m", "hm", "dm", "grad", "mand", "mc", "di", "mod", "rm", "mg", "mad", "f", "cmd", "dd"], "hash": ["string", "address", "sum", "her", "id", "username", "user", "version", "kh", "hex", "Hash", "html", "number", "match", "length", " hashing", "pass", "ash", "key", "mac", "rh", "cache", "dot", "sha", "value", "build", "data", "file", "body", "check", "h", "log", "search", "dig", "style", "format", "header", "ho", "image", "hed", "ha", "array", "db", "dump", "full", "url", "sh", "secret", "SHA", "shadow", "block", "code"]}}
{"id1": "21979714", "id2": "16623181", "code1": "    @ActionMethod\n    public void list() throws IOException {\n        final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/list?version=1000\");\n        final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n        con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n        final InputStream in = con.getInputStream();\n        final byte[] buf = new byte[4096];\n        textArea.setText(\"\");\n        for (int bytesRead; (bytesRead = in.read(buf)) != -1; ) {\n            textArea.append(new String(buf, 0, bytesRead));\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"list": ["index", "info", "find", "query", "read", "sort", "split", "sync", "LIST", "load", "show", "export", "check", "request", "get", "search", "delete", "test", "start", "ls", "ping", "pull", "parse", "print", "download", "stop"], "url": ["string", "path", "ssl", "base", "server", "uri", "resource", "lock", "entry", "http", "l", "host", "URL", "fl", "client", "connection", "build", "ob", "config", "file", "cl", "web", "page", "bb", "ll", "log", "conn", "ls", " URL", "blog", "sl", "rl", "pull", "Url", "www", "bug", "ur", "ul", "f", "org", "api"], "con": ["close", "Conn", "ex", "fa", "CON", "cf", "rc", "cons", "ran", "on", "http", "c", "fc", "ctrl", "sub", "run", "fn", "Con", "co", "func", "en", "ec", "client", "cm", "part", "cp", "an", "lc", "uc", "connection", "login", "ch", "open", "conv", "un", "ca", "cl", "xc", "fac", "conn", "exec", "ann", "pc", "ln", "ver", "bc", "com", "can", "ctx", "conf", "connect", "cn", "f", "cur"], "in": ["IN", "i", "input", "ex", "n", "ini", "c", "inner", "as", "socket", "sub", "ins", "bin", "is", "client", "reader", "login", "min", "r", "inc", "data", "vin", "out", "rin", "file", "conn", "rec", "again", "m", "In", "a", "stream", "lin", "b", "conf", "inn", "f", "win", "this", "re"], "buf": ["base", "buffer", "Buffer", "bf", "bd", "bh", "rc", "cb", "grab", "abs", "bin", "ff", "func", "pb", "uf", "la", "bag", "utf", "bu", "cv", "rb", "ab", "cas", "wb", "uc", "buff", "sb", "aka", "data", "conv", "tmp", "src", "fb", "exc", "bb", "vec", "db", "bytes", "bc", "Buff", "bp", "seq", "b", "br", "fab", "batch", "cur", "orig"], "bytesRead": ["byteLength", "tesLength", "wordsLength", " bytesWritten", "bytesFound", "wordsFound", "bytesFind", "BytesRead", "BytesWrite", "byteRead", "stringsLoad", "wordsRead", "tesRead", "bytesLength", "bytesWritten", "bytesread", " bytesLoad", " bytesFound", "BytesLoad", "bytesLoad", "BytesLength", " bytesFind", " bytesread", "tesFound", "stringsFind", "byteWritten", "BytesFind", "byteWrite", "BytesWritten", "stringsRead", " bytesWrite", " bytesLength", "bytesWrite", "tesread", "wordsread", "stringsWritten"]}}
{"id1": "4223002", "id2": "16549995", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"getPasswordMD5": ["getPasswordMac5", "getPasswordSHA512", "getpasswordMD5", "getpasswordMD512", "getpasswordSHA5", "getpasswordSHA1", "getpasswordSHA256", "getpasswordMD1", "getPasswordMD256", "getPasswordMAC512", "getPasswordSHA1", "getPasswordMD512", "getPasswordSHA256", "getPasswordMD1", "getpasswordSHA512", "getPasswordMac256", "getPasswordMAC1", "getPasswordSHA5", "getPasswordMAC256", "getPasswordMac512", "getpasswordMD256", "getPasswordMAC5", "getPasswordMac1"], "algorithm": ["alm", " algo", "alger", "Alignment", "omalphabet", "agignment", "fgebra", " alignment", "omalgorithm", " algorith", "Alm", "geger", "aggorithm", "algo", "algorith", " alm", "fgo", " alger", "alrator", "calgebra", "Alger", "calgorith", "Alest", "alphabet", "aggo", "Algo", "Alphabet", "omalgorith", "gegorithm", "calgo", "algebra", "alignment", "gem", "Algebra", "Algorithm", " alrator", "fgorith", "fgorithm", " alphabet", "geest", "omalgo", "calgorithm", "Alrator", "agrator", " alest", "Algorith", "alest"], "messageDigest": ["messageModested", "MessageDigester", "messageMDest", " messagedigEST", "messagedigString", "messageDested", " messagedigString", "messageMDester", "messagedigest", " messagedigest", "messageDigString", "MessageDigEST", "phrasedigester", "messagedigester", "messageDigester", "MessageModEST", "messagedigEST", " messageDigester", "messageDEST", "MessageDigested", "phrasedigest", "phraseDigested", "messageModester", "messageDest", "messageModest", "messageModString", "MessageModester", "messageDester", "messageDigested", "messageDigEST", "messageModEST", "MessageModested", "messageMDEST", "messagedigested", "phraseDigester", "phraseDigEST", "MessageModest", "phrasedigested", "phrasedigEST", "MessageDigest", " messagedigester", "phraseDigest", " messageDigString", " messageDigEST", "messageMDString"], "hexString": ["checkString", "hexBuffer", "textstring", "hexArray", "hexLine", "hashStr", "hexstring", "shortString", " hexStr", "textStream", " hexBuffer", "checkFunction", " hexArray", "hashBuffer", " hexFunction", "hexStream", "textArray", "byteStream", "textString", "byteString", "hashFunction", "shortArray", "textLine", "hexStr", "hashString", " hexStream", "checkBuffer", "hexFunction", "shortBuffer", " hexstring", "textBuffer", "byteLine", "shortstring", "byteArray", "checkStr", " hexLine"], "i": ["index", "info", "id", "n", "pi", "uri", "mu", "slice", "c", "j", "end", "ri", "o", "volume", "l", "s", "fi", "si", "ui", "ii", "in", "key", "type", "ti", "d", "phi", "r", "chi", "li", "h", "x", "p", "mi", "bi", "u", "ai", "oi", "e", "I", "ci", "t", "m", "io", "zi", "xi", "di", "gi", "a", "hi", "v", "b", "abi", "multi", "f", "ix"]}}
{"id1": "22503685", "id2": "350482", "code1": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"readGeoParserResult": ["readGeoWalkerResult", "readGeoparserReport", "readGeoReaderResult", "readGeoReaderReport", "readGeoParserOutput", "readGeOReaderReport", "readGeoWalkerReport", "readGeOParserReport", "readGeoReaderOutput", "readGeOParserOutput", "readGeoparserResult", "readGeoparserResults", "readGeoWalkerOutput", "readGeoReaderResults", "readGeOReaderResults", "readGeoWalkerResults", "readGeoParserReport", "readGeOReaderResult", "readGeOReaderOutput", "readGeoparserOutput", "readGeoParserResults", "readGeOParserResults", "readGeOParserResult"], "recordContent": ["resourceContents", " recordText", "recordText", "reportContent", "recordMessage", "RecordText", "resourceContent", "resourceText", "reportText", "recordBody", "RecordContent", "RecordMessage", "reportMessage", "RecordFile", "resourceFile", " recordBody", " recordMessage", "RecordBody", " recordFile", "recordFile", "reportBody", " recordContents", "recordContents", "RecordContents"], "getGazeteerIds": ["getGazeteerHostes", "getGazeteersIdes", "getGazeteerConfigxs", "getGazeteerNeedes", "getGazeteerNeeders", "getGazeteerLogls", "getGazeteersLogings", "getGazeteersIds", "getGazeteerHostings", "getGazeteersLogxs", "getGazeteerLogs", "getGazeteerIders", "getGazeteerTextings", "getGazeteerConfigings", "getGazeteerIdings", "getGazeteersLogls", "getGazeteersLogers", "getGazeteerNeeds", "getGazeteerHosts", "getGazeteerLogxs", "getGazeteersIdls", "getGazeteerHosters", "getGazeteerIdes", "getGazeteersIders", "getGazeteerTextls", "getGazeteerIdxs", "getGazeteerConfigs", "getGazeteersIdxs", "getGazeteerIdls", "getGazeteersLogs", "getGazeteerLogings", "getGazeteerNeedings", "getGazeteerLogers", "getGazeteerTextxs", "getGazeteersLoges", "getGazeteerConfigls", "getGazeteerTexts", "getGazeteerLoges", "getGazeteersIdings"], "ret": ["gt", "info", "fun", "Ret", "att", "bf", "replace", "mem", "sys", "results", "res", "ref", "vet", "result", "rg", "match", "arg", "rt", "feat", "ft", "usr", "iter", "arr", "part", "nt", "resp", "Return", "len", "str", "alt", "ut", "group", "default", "rets", "data", "out", "g", "r", "get", "ll", "reply", "hash", "dict", "t", "status", "array", "opt", "ext", "obj", "reg", "det", "Result", "RET", "repl", "f", "re", "list"], "retries": ["Retries", "altrys", "altrying", "RETrying", " retrying", "altries", "retry", "RETried", "RETries", "retrys", "altried", " retrys", "trys", "tried", "RETrys", "Retrys", "retrying", " retry", "Retry", "trying", "tries", "Retrying", "retried"], "reqPre": ["reqpre", "resppre", "refPost", "reqPost", "respPre", "refPlan", " requestPref", " reqPref", "requestPre", " reqPost", "respPost", " requestPost", "requestPost", "requestPref", " requestpre", "requestpre", "refpre", "reqPlan", " requestPre", "reqPref", "respPlan", " reqpre", "requestPlan", "refPre"], "outputFormat": ["OutputVersion", "OutputType", "outputType", "outputVersion", "inputSettings", "reportVersion", "reportFormat", "inputVersion", "reportType", "reportSettings", "inputType", "OutputSettings", "inputFormat", "OutputFormat", "outputSettings"], "doc": ["event", "info", "resource", "response", "Doc", "df", "http", "docs", "document", "DOC", "project", "result", "html", "record", "dr", "dc", "part", "git", "up", "date", "str", "feature", "md", "data", "file", "text", "body", "div", "page", "h", "style", "msg", "desc", "coll", "m", "e", "po", "home", "pos", "db", "di", "mc", "bc", "bug", "parse", "b", "xml", "f", "Document", "tx", "api"], "url": ["string", "path", "base", "info", "address", "buffer", "ssl", "server", "uri", "resource", "response", "id", "entry", "http", "document", "ref", "result", "html", "l", "location", "URL", "orb", "source", "connection", "browser", "str", "r", "data", "file", "channel", "page", "request", "web", "name", "e", "sl", "Url", "b", "f", "element", "org", "api"], "reader": ["info", "handler", "buffer", "input", "uri", "resource", "feed", "rc", "http", " parser", "instance", "read", "tx", "iter", "er", "oder", " readers", "r", "parser", "data", "file", "rr", "or", "writer", "io", "stream", "Reader"]}}
{"id1": "5274228", "id2": "15445861", "code1": "    public String put(String resourceID, Map<String, String> headersMap) {\n        HttpClient httpClient = new DefaultHttpClient();\n        httpClient.getParams().setParameter(\"http.useragent\", \"sla@soi OCCI Client v0.2\");\n        HttpPut httpPut = new HttpPut(resourceID);\n        List<Header> headersList = this.convert2Headers(headersMap);\n        for (Iterator<Header> iterator = headersList.iterator(); iterator.hasNext(); ) {\n            httpPut.addHeader(iterator.next());\n        }\n        logger.info(httpPut.getRequestLine());\n        logger.info(httpPut.getAllHeaders());\n        Header[] headersArray = httpPut.getAllHeaders();\n        String[] fields = { Response.Location };\n        HashMap<String, String> occiHeaders = new HashMap<String, String>();\n        for (int H = 0; H < headersArray.length; H++) {\n            Header header = headersArray[H];\n            logger.info(\"header - request  -\" + header.toString());\n            logger.info(\"\theaderName - \" + header.getName());\n            logger.info(\"\theaderValue - \" + header.getValue());\n        }\n        String statusLine = null;\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpPut);\n            statusLine = httpResponse.getStatusLine().toString();\n            int statusCode = httpResponse.getStatusLine().getStatusCode();\n            logger.info(\"----------------------------------------\");\n            logger.info(\"StatusLine - (full) - \" + httpResponse.getStatusLine());\n            logger.info(\"\tStatusCode - \" + statusCode);\n            logger.info(\"\tReason - \" + httpResponse.getStatusLine().getReasonPhrase());\n            logger.info(\"\tProtocol - \" + httpResponse.getStatusLine().getProtocolVersion().toString());\n            logger.info(\"----------------------------------------\");\n            if (StatusCode.validate(statusCode)) {\n                logger.info(\"Response Validated\");\n            } else {\n                logger.error(\"Response NOT Validated\");\n                return null;\n            }\n            Header[] headers = httpResponse.getAllHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                Header header = headers[i];\n                logger.info(\"header - response - \" + header.toString());\n                logger.info(\"\theaderName - \" + header.getName());\n                logger.info(\"\theaderValue - \" + header.getValue());\n                for (int h = 0; h < fields.length; h++) {\n                    logger.info(\"\tLooking for  - \" + fields[h]);\n                    if (fields[h].equals(header.getName().toString())) {\n                        logger.info(\"\tFound an OCCI Header - \" + header.getName());\n                        occiHeaders.put(header.getName(), header.getValue());\n                    }\n                }\n            }\n        } catch (org.apache.http.conn.HttpHostConnectException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } finally {\n            httpClient.getConnectionManager().shutdown();\n        }\n        logger.info(\"occiHeaders - \" + occiHeaders);\n        if (occiHeaders.containsKey(Response.Location)) {\n            logger.info(\"Valid Provision\" + statusLine);\n            return occiHeaders.get(Response.Location).toString().replaceAll(Response.jobs, \"\");\n        }\n        logger.info(\"NOT a Valid Provision - \" + statusLine);\n        return statusLine;\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 0, "substitutes": {"put": ["string", "output", "resource", "replace", "add", "patch", "UT", "write", "post", "client", "cache", "operation", "build", "data", "file", "get", "submit", "format", "PUT", "Put", "pull", "update", "create", "parse", "st", "transfer", "transform"], "resourceID": ["Resourceid", "serviceIDs", "requestURL", "resourceURL", "objectIDs", "ResourceID", "responseKey", "serviceid", "resourceId", "requestId", "objectId", "responseId", "serviceId", "serviceID", "requestID", "resourceid", "ResourceURL", "resourceKey", "objectID", "responseURL", "responseID", "objectid", "resourceIDs", "requestKey", "ResourceKey", "ResourceId", "ResourceIDs"], "headersMap": ["ersList", "headersSet", "httpMap", "ersFile", "headerSet", "httpList", "httpArray", "ersArray", "ersMap", "headerFile", " headersSet", "httpSet", "headerList", "headerMap", "headerArray", "headersFile", " headersFile"], "httpClient": ["HttpCase", "ttpConnection", "HttpContext", "httpServer", " httpConnection", " httpCase", "httpContext", "HttpPut", "httpsConnection", "ttpBase", "ttpPut", "httpConnection", "HttpServer", "httpsContext", " httpCall", "phpPut", "httpsServer", "ttpClient", "phpCall", " httpContext", "httpsClient", "httpCall", "HttpClient", " httpBase", "httpCase", "phpCase", "httpsPut", "HttpCall", "httpBase", "httpsBase", " httpServer", "phpClient"], "httpPut": ["httpGet", "phpPush", "httpsDo", " httpDo", "HttpPut", "HttpPUT", "httpput", "httpAdd", "internalPush", "httpsput", "phpAdd", "internalWrite", "httpDo", "httpPush", "webPut", "httpSplit", " httpSplit", " httpAdd", "httpsSplit", "webPush", " httpWrite", "httpsPush", "phpWrite", "viewPush", "HttpPush", "viewPut", "viewPUT", "httpWrite", "Httpput", "phpPut", " httpGet", " httpPUT", "httpsPUT", "HttpDo", "httpsClient", "webGet", "phpSplit", "httpPUT", "httpsAdd", "HttpClient", "phpGet", "httpsPut", "httpsGet", "HttpGet", " httpPush", "internalGet", "webPUT", "internalPut", "viewput"], "headersList": ["ersList", "driversArray", " headersL", "headersSet", "driversL", "ersSet", "headersL", "headerSet", "driversList", "ersArray", "driversMap", "headerL", " headersSet", "ersL", "headerList", "headerMap", "headerArray"], "iterator": ["handler", "loader", "outer", "starter", "division", "entry", "vector", "ie", "sequence", "slice", "started", "oper", "inner", "inter", "end", "walker", "driver", "ter", "set", "later", "gener", "done", "instance", "iter", "next", "loop", "interstitial", "adder", "Iterator", "reader", "collection", "parser", "kick", "li", "append", "ator", "size", "Iter", "init", "creator", "basic", "start", "writer", "eni", "runner", "pointer", "ski", "operator", "stream", "processor", "random", "finder", "multi", "step", "former", "engine"], "headersArray": ["filesAr", "filesHash", "headersAr", "headsLength", "filesMap", "filesArray", "headersLength", "headsAr", "headersHash", "ersAr", " headersAr", "hersLength", "ersArray", "ersMap", "hersAr", " headersLength", "headsList", "hersArray", "hersList", "ersHash", " headersHash", "headsArray"], "fields": ["keys", "zip", "json", "comments", "errors", "pattern", "content", "params", "FIELD", "lines", "dir", "region", "Field", "data", "body", "format", "types", "rows", "details", "prefix", "files", "values", "dates", "properties", "field", "codes"], "occiHeaders": ["ocsiHeadlers", "ocsiBuffer", "occiBuffers", "occiBuilderers", "occiBufferers", "occiBuildlers", "occiHeadlers", "occiHosters", "occiHostlers", "occiBufflers", "ocsiHeaderers", "ocsiBufferers", "occiBuilder", "occiHosterers", "ocsiHeader", "occiHoster", "ocsiHeaders", "ocsiBuffers", "occiBuilders", "occiBuffer", "occiHeader", "occiHeaderers", "ocsiBufflers"], "H": ["R", "P", "OH", "U", "Head", "CH", "M", "HTTP", "D", "HR", "EH", "X", "S", "HH", "Index", "HM", "TH", "K", "HT", "Handler", "N", "HB", "MH", "rh", "HS", "W", "Length", "Q", "C", "DH", "Header", "J", "SH", "I", "G", "F", "HI", "T", "B", "HE", "ID", "HC", "V", "Hop", "L", "Y", "NH"], "header": ["string", "head", "info", "handler", "event", "her", "buffer", "outer", "response", "server", "ker", "token", "builder", "entry", "http", "holder", "message", "document", "per", "inner", "bridge", "result", "later", "driver", "ter", "dr", "manager", "detail", "extra", "key", "ler", "er", "back", "reader", "rule", "player", "cover", "value", "feature", "file", "liner", "request", "metadata", "row", "Header", "frame", "writer", "second", "layer", "cher", "service", "comment", "consumer", "block", " request", "f", "former", "definition"], "statusLine": ["StatusLine", "errorString", "statusText", "statusBody", " statusBody", "StatusBody", "StatusText", "errorCode", " statusFile", "responseCode", "responseFile", "errorBody", "StatusCode", "StatusString", " statusText", "statusFile", "responseText", " statusString", "errorLine", "responseLine", "StatusFile", "statusString"], "httpResponse": ["httpsResult", "HttpRequest", "HttpEnvironment", " httpEnvironment", "templateLine", "httpsBody", "HttpPage", "statusResponse", " httpLine", "ttpResp", "statusBody", "actualresponse", "HttpLine", "HttpResp", "HttpStatus", "ttpResponse", " httpresponse", "statusResult", " httpResp", "httpResp", "actualResponse", "templateResp", "httpsEnvironment", " httpBlock", "HttpBody", "ttpRequest", "actualLine", "actualRequest", "templateResponse", "HttpResult", "httpEnvironment", "httpsResponse", "statusBlock", "httpRequest", " httpRequest", "HttpBlock", "httpStatus", "httpsRequest", "templateStatus", "Httpresponse", "ttpResult", "HttpResponse", "httpPage", "httpLine", " httpResult", "httpResult", "httpBody", " httpStatus", " httpPage", " httpBody", "httpresponse", "httpBlock", "httpsPage"], "statusCode": ["resultCount", "StatusLine", "statusText", "StatusData", "statusCount", "resultcode", " StatusType", " statusType", "resultCode", "statusType", "statuscode", "errorCode", "StatusText", " StatusLine", "responseCode", "resultLine", " StatusCode", "StatusType", " StatusData", " statuscode", " statusData", "errorText", "StatusCode", "Statuscode", "StatusCount", "errorType", "statusData", "responseText", "errorLine", "responseLine", "responseType", " statusCount"]}}
{"id1": "7149578", "id2": "13516684", "code1": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"parseContent": [" parseContents", "parserDescription", "parseContents", "seContents", "parserData", " parseData", "parserContent", "seContent", " parseDescription", "seDescription", "parserContents", "parseDescription", "seData", "parseData"], "streamLimiter": [" streamLimizer", "urlLimite", "streamGrabiser", "streamGrabiler", "streamVisitter", "urlLimitation", " streamLimititer", "streamLimitite", " streamLimiser", "streamGrabiter", "streamLimitor", "urllimite", "urlLimiter", "streamLimititation", " streamLimititter", "streamlimitation", "urllimiter", "streamLimititer", "streamlimited", " streamLimite", " streamLimer", " streamLimitor", "streamLimititter", "urllimited", "streamLimititor", " streamLimitter", "urllimitation", "streamGrabitter", "streamlimitter", "streamLimiler", "streamLimiser", "streamLimer", "streamVisiter", "streamLimited", "streamlimite", "streamlimitor", "streamLimizer", "streamlimer", "streamLimite", " streamLimititor", "streamLimitited", "streamlimizer", "streamlimiter", "streamLimitter", "streamLimitation", "streamViser", "urlLimited", " streamLimiler", "streamVisizer", " streamLimitite"], "forcedLang": [" requestedFlang", " sourceFliang", " requestedFliang", " sourceFlang", " sourceSamp", " sourceLevelph", " sourceLevelang", " requestedFlamp", " sourceLang", " sourceLph", " sourceLevelamp", " sourceLeveliang", " sourceFlamp", " requestedFlph", " sourceLiang", " sourceSiang", " sourceFlph", " requestedLph", " sourceSph", " requestedLamp", " requestedLang", " sourceSang", " requestedLiang", " sourceLamp"], "charset": ["chararsset", "chacterseter", "chARSpace", "chapterset", "chardset", "cheARSet", "chactersET", "chapseter", "charsett", "chARSset", " Chansett", "chasett", "chararseter", "chardsetting", "chaptersett", "ChARSets", " ChansET", "cheasets", "charsset", "harsets", "cheARSets", "chaspace", "charansET", "charansetting", "Charsett", "chanspace", "hasesets", "charARSetting", "charARSET", "charsets", "chARSets", "chaseter", "cheasetting", "chARSet", "harset", "ChARSett", "Chanset", "chararset", "chasespace", "chacterset", "chARSeter", "chaptersET", "Charsetter", "cheaset", "hasespace", "chARSett", "chaptersetting", "chararsets", "Chaspace", "chARSET", "cheARSett", "charARSett", "chactersetting", "ChasET", "chasET", "Charspace", "chanset", "chardsET", "chansET", "chapsets", "chardsset", "chARSetter", "hasesET", "cheARSetter", "chasesets", "cheARSetting", "chasetting", "chasesET", "charseter", "chararsetting", "Chansets", "chearsett", " Chansets", "ChARSetting", "chansset", " Chanset", "Charsetting", "chearsetter", "chapset", "CharsET", "chansets", "charansett", "harsET", "chaseset", "chARSetting", "ChansET", "chapsetting", "chararsET", " Charset", "Chasets", "chearsets", "Chaset", "cheaseter", "Charset", "chansett", "chaptersets", "charARSets", "Charsets", " CharsET", "charARSet", "charanset", "chararsett", "chearsetting", "chaset", "harspace", "charsetter", "chearset", " Charsett", " Charsets", "haseset", "charARSeter", "chasetter", "Chansetter", "chansetting", "chearseter", "charspace", "charsetting", "chanseter", "chasets", "charsET", "charARSset", "chansetter", "ChARSet"], "sourceDocument": ["SourceContent", "siteContent", "inputContent", " sourceFile", "sourcedocument", "SourceDocument", "siteDirectory", "siteDocuments", "srcContent", "SourceDocuments", "srcDocument", "searchDocuments", " sourceContent", "SourceDoc", "siteDoc", " sourcedocument", "sourceFile", "Sourcedocument", "inputdocument", " sourceDocuments", "sourceContent", "inputDocument", "SourceFile", "sourceDocuments", "searchdocument", "searchFile", " sourceDirectory", " sourceDoc", "srcdocument", "searchDocument", "sourceDirectory", "siteDocument", "sourceDoc", "inputDirectory", "srcDirectory"], "fieldValueItem": ["fieldKeyItem", "fieldTextitem", " fieldName2", "fieldTypeAct", " fieldValueElement", "FieldValueParser", "memberValueitem", " fieldNameItems", "memberProcessitem", "fieldFamilyPart", "FieldValueItem", "fieldItemPart", "fieldvalueitem", "fieldProcessFile", "fieldTypeItems", "fieldValueItems", "fieldItemItem", "fieldNamePart", "fieldPathitem", "fieldNameitem", "stringValueItem", "memberValueItem", "fieldTextItem", "stringValue1", "FieldValueSource", "FieldNameSource", "fieldValueSource", "fieldProcessElement", "fieldTypeSource", "fieldValue1", "fieldValueIt", "fieldKeySource", "serverValueAct", " fieldNameItem", "fieldPathIt", "stringValueItems", "fieldvalueElement", "fieldFamilyItems", "fieldTypeIt", "fieldProcessitem", "fieldValueFile", "fieldNameSource", "fieldType2", " fieldValueItems", "fieldvalueIt", "fieldTypeItem", "memberValueFile", "fieldItemItems", "fieldTypeitem", "serverValueItem", "memberProcessFile", "FieldValuePart", "fieldContentItem", "fieldFamilyItem", "fieldvalueItems", "fieldType1", "FieldNameItem", "servervalueItem", "fieldValue2", "FieldFamilyItems", "fieldPathAct", "fieldvalueAct", "fieldProcessItem", "fieldValueitem", "stringName1", "fieldValueParser", "fieldTypeElement", " fieldValue2", "serverValueIt", "memberProcessElement", "FieldNameItems", "fieldNameItem", "servervalueitem", "fieldPathItem", "serverValueitem", "fieldKeyItems", "fieldNameParser", "fieldName2", "fieldContentElement", "fieldValueAct", "fieldTextElement", "FieldFamilyPart", "servervalueIt", "fieldNameItems", "memberValueElement", "servervalueAct", "fieldValuePart", "fieldvalueItem", " fieldNameElement", "fieldName1", "stringValueElement", "stringNameItem", "fieldTextFile", "fieldNameElement", "fieldContentItems", "FieldFamilyItem", "FieldValueItems", "fieldvalue2", "memberProcessItem", "stringNameItems", "FieldFamilyParser", "stringNameElement", "fieldContent1", "fieldNameFile", "fieldItemParser", "fieldValueElement", "fieldFamilyParser"], "charsetWasNull": ["charsettingWasNone", "charsetwasNULL", "charsettingIsnull", "charsettingIsNull", "charsettingWasNull", "charsetsWasNULL", "charsettingWasnull", "charsetwasEmpty", "charsetISnull", "charsettingWasEmpty", "charsetPreviouslyConstruct", "charsettingIsConstruct", "charsetsWasNull", "charsetIsNone", "charsetIsConstruct", "charsetWasNone", "charsetWasEmpty", "charsetPreviouslyNone", "charsetPreviouslyNULL", "charsetwasNull", "charsettingIsNone", "charsetWereNULL", "charsettWasFound", "charsettingWasNULL", "charsetPreviouslyNull", "charsettingWasConstruct", "charsetWasnull", "charsetISNull", "charsetIsNULL", "charsetISEmpty", "charsettingIsEmpty", "charsetIsNull", "charsettWasNULL", "charsetWereFound", "charsetIsEmpty", "charsetsWasnull", "charsetWasNULL", "charsettWasNull", "charsetIsFound", "charsetISNULL", "charsetWereNull", "charsetwasnull", "charsetIsnull", "charsettingIsNULL", "charsetWasFound", "charsetWasConstruct"], "writer": ["string", "writing", "handler", "buffer", "temp", "editor", "rw", "output", "wr", "outer", "loader", "builder", "rew", "document", "author", "writers", "walker", "driver", "WR", "later", "write", "written", "ler", "wrap", "Writer", "type", "reader", "source", "ws", "wb", "value", "r", "build", "w", "parser", "data", "text", "out", "director", "former", "widget", "format", "creator", "pointer", "word", "worker", "riter", "wrapper", "wire", "wa", "xml", "words", "wrote", "writ", "office", "engine", "external"], "htmlProvider": ["HTMLProv", "contentProv", "phpManager", "browserPool", " htmlContext", "tmlReader", "tmlider", " htmlider", "tmlContext", "tmlProvider", "HTMLContext", " htmlFactory", "HTMLReader", "htmlContext", "phpProvider", "htmlManager", " htmlPool", "tmlPool", "contentReader", "httpProvider", "httpProv", "htmlLocation", "tmlFactory", " htmlReader", "phpProv", "htmlPool", "HTMLManager", "tmlManager", "htmlReader", "browserProvider", "htmlFactory", "contentManager", "apiReader", "HTMLLocation", "apiProvider", " htmlManager", "tmlLocation", "phpFactory", " htmlProv", "htmlProv", " htmlLocation", "contentProvider", "apiProv", "externalProvider", "browserider", "HTMLProvider", "htmlider", "externalider", "tmlProv", "httpider"], "contentType": ["contentTime", " contentBody", "ContentType", " contenttype", "characterTypes", " contentTypes", "characterName", " contentTy", "modeltype", " contentTime", "changeTyp", "ContentTypes", "ContentBody", "nextName", "changetype", "modelType", "changeType", "Contenttype", "contentBody", "contentTypes", "modelTime", "characterTy", "contentName", "ContentTy", "contentTyp", "modelTyp", "contenttype", "nextBody", " contentName", "nexttype", "contentTy", " contentTyp", "nextType", "ContentName", "changeTime", "characterType"], "contentTypeCharset": ["contentTypeEarsET", "contentTypeCasets", "contentTypeCharsett", "contentTypeChardsant", "contentTypeChARSets", "contentTypeChasetting", "contentTypeChaset", "contentTypeChansets", "contentTypeChansET", "contentTypeCasetter", "contentTypeChARSetter", "contentTypeChangSet", "contentTypeEarsant", "contentTypeCaset", "contentTypeCharsets", "contentTypeChapesets", "contentTypeChardset", "contentTypeCarsets", "contentTypeChARSett", "contentTypeChARSSet", "contentTypeEARSET", "contentTypeCangetter", "contentTypeEARSets", "contentTypeCharsetting", "contentTypeCurarsetting", "contentTypeChasET", "contentTypeCarsSet", "contentTypeCharsetter", "contentTypeChasant", "contentTypeCharsant", "contentTypeChansett", "contentTypeCasett", "contentTypeChardsetting", "contentTypeChARSant", "contentTypeCharsette", "contentTypeChapesET", "contentTypeChapeset", "contentTypeChapesant", "contentTypeCharsET", "contentTypeChapesetting", "contentTypeEarsets", "contentTypeChardsets", "contentTypeChasett", "contentTypeClarset", "contentTypeCurarsets", "contentTypeCurarsET", "contentTypeCurARSets", "contentTypeCangets", "contentTypeChanget", "contentTypeChARSet", "contentTypeClarsets", "contentTypeChansant", "contentTypeCangSet", "contentTypeChasette", "contentTypeCurARSet", "contentTypeCarsett", "contentTypeClarsette", "contentTypeChARSetting", "contentTypeChasets", "contentTypeCharsSet", "contentTypeChaptersetter", "contentTypeCurARSetting", "contentTypeCarsetter", "contentTypeChasetter", "contentTypeChARSET", "contentTypeEARSet", "contentTypeChangets", "contentTypeClarsetting", "contentTypeCurARSET", "contentTypeChangetter", "contentTypeEarset", "contentTypeChaptersSet", "contentTypeChapesette", "contentTypeChanset", "contentTypeChaptersets", "contentTypeCarset", "contentTypeChansetting", "contentTypeChapterset", "contentTypeEARSant", "contentTypeChangett", "contentTypeCanget", "contentTypeCurarset"]}}
{"id1": "9272325", "id2": "16760971", "code1": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "code2": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"sendPost": ["postpost", "doPost", "SendPOST", "postPOST", "sendpost", "dopost", "doMethod", "postMethod", "Sendpost", "doPOST", "sendPOST", "SendMethod", "SendPost", "postPost", "sendMethod"], "reqUrl": ["requEmail", "requestURL", "requestUr", "requestUrl", "requLine", "reqUr", "reqURL", "reqLine", "requestLine", "requestRoute", "requestEmail", "downloadLine", "requRoute", "requURL", " reqURL", " reqUr", "reqRoute", " reqRoute", "reqEmail", "requUrl", "downloadUrl", "downloadEmail", "downloadURL", "requUr"], "parameters": ["parameter", "arameter", "mandeter", "paramsations", "paramseters", "parParameters", "pareters", "mandations", "paramsams", "paramations", "paramsParameters", "mandParameters", "pareter", "parations", "paramParameters", "mandeters", "paramseter", "paramams", "arameters", "aramams"], "urlConn": ["buildConnector", " urlCon", "bbCon", "buildConn", "urlConnection", "httpReg", "buildConnection", "httpconn", "bbConn", "baseConnect", "userConn", "buildCon", "elConn", "blogContainer", "webCon", "logConnection", "reqConn", " urlSync", " urlconn", "urlConnect", "lconn", " urlContainer", "httpCon", "httpExec", "webSync", "elConnect", "urlReg", "logCon", "urlconn", "webContainer", "urlComm", "returnConnection", "httpConnect", "httpSync", " urlInfo", "blogCon", "httpInfo", "httpConnection", "baseConnection", "lConnection", "obConn", " urlConnect", "baseConn", "lConn", "urlContainer", "URLConn", " urlConnection", "returnConn", "userConnect", "webConnection", "bbConnection", "webExec", "logConn", "webConnect", " urlReg", "elCon", "urlInfo", "urlExec", "obReg", "httpConn", "obConnection", "URLConnect", "elConnection", "userConnection", "urlConnector", "webConn", "bbConnector", "URLClose", "blogConnection", "webconn", "userInfo", "urlClose", "logConnect", "webClose", " urlClose", " urlExec", "urlSync", "httpComm", "baseCon", "reqconn", "obConnect", "reqConnection", "urlCon", "returnCon", "URLconn", "reqComm", "httpConnector", "lComm", "returnConnect", "blogConn"], "params": ["string", "Par", "uri", "response", "settings", "http", "res", "pages", "resources", "json", "posts", "l", "s", "apps", "URL", "query", "manager", "database", "req", "parts", "lines", "ams", "bps", "par", "Parameters", "tags", "points", "data", "names", "tmp", "body", "config", "options", "request", "array", "prefix", "bytes", "Url", "_", "rules", "ps", "properties", "Param", "param", "api"], "url": ["string", "path", "base", "ssl", "job", "i", "server", "n", "uri", "resource", "http", "c", "lr", "l", "host", "URL", "orb", "source", "lc", "connection", "r", "ob", "config", "data", "page", "web", "ll", "bel", "log", "conn", "ls", " URL", "Config", "blog", "sl", "rl", "layer", "Url", "www", "ur", "obj", "f", "gl", "api", "loc"], "b": ["buffer", "base", "i", "bf", "emb", "bd", "lb", "c", "l", "bs", "bin", "pb", "gb", "mb", "bar", "rb", "ab", "binary", "wb", "sb", "buff", "buf", "r", "ob", "data", "body", "fb", "bb", "null", "e", "nb", "db", "a", "bytes", "B", "v", "obj", "br", "bl", "ba", "f", "boot"]}}
{"id1": "8468859", "id2": "22611968", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"connect": ["close", "add", "on", "con", "connected", "socket", "find", "run", "patch", "Connect", "host", "write", " connection", "read", " reconnect", "en", " disconnect", "select", "client", "stat", "nect", "construct", "login", "connection", "build", "open", "bind", "config", "log", "conn", "init", "start", "exec", "port", "establish", "create", "sign", "download", "boot", "stop"], "status": ["index", "temp", "id", "output", "response", "server", "user", "continue", "site", "version", "current", "result", "standard", "si", "ui", "active", "content", "Status", "fail", "sync", "session", "source", "use", "stat", "type", "login", "min", "str", "parent", "log", "style", "complete", "edit", "success", "full", "skip", "update", "unit", "summary", "wait", "stage", "count", "progress", "state", "step", "speed", "code"], "reply": ["reason", "info", "address", "fee", "dy", "base", "server", "response", " response", "message", "py", "result", "answer", "query", "ret", "next", "post", "sync", "resp", "connection", "Reply", "data", "request", "vote", "action", "send", "call", "link", "prefix", "second", "ping", "bot", "respond", "update", "comment", "random", "state", "count", "repl", "error", "code"], "isConnected": ["isNECTalled", "isaAdapting", "isaConnectified", "IsConnected", "isConnectaged", "isFinalled", "IsConnections", "isConnectionp", "IsConnectionp", "isAcceptted", "isConnects", "isConnectioning", "isConnectted", "isAcceptaged", " isAcceptted", "IsConnectioning", " isConnectioned", "isFinaged", " isConnectable", " isAcceptaged", "isNECTing", "IsConnectp", "isAdapting", "isconnecteded", "isConnectionified", "isConnectified", "isaConnecting", " isConnectted", "isAdaptified", "IsConnects", " isConnecting", "isConnectished", "IsConnectioned", "isconnecteding", "isAdapteded", "isFinished", "isConnectioneded", "isConnectp", "isaAdaptified", "isConnections", " isAcceptable", "isNECTished", "isaAdapteded", "isAdapted", "isaAdapted", " isAccepted", "isAcceptable", " isConnectionished", "isconnectedp", " isConnectalled", " isConnectaged", "isFined", "isConnectionished", "isFinted", "isConnecteded", "isConnectioned", "isConnectionalled", " isConnectionalled", " isConnectioning", "isNECTed", "IsConnecting", "isFinable", " isConnectished", "isAccepted", "isaConnecteded", "isaConnected", "isFining", "isconnecteds", "isConnectalled", "isConnecting", "isConnectable"]}}
{"id1": "21979714", "id2": "22114133", "code1": "    @ActionMethod\n    public void list() throws IOException {\n        final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/list?version=1000\");\n        final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n        con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n        final InputStream in = con.getInputStream();\n        final byte[] buf = new byte[4096];\n        textArea.setText(\"\");\n        for (int bytesRead; (bytesRead = in.read(buf)) != -1; ) {\n            textArea.append(new String(buf, 0, bytesRead));\n        }\n    }\n", "code2": "    @Override\n    public void actionPerformed(ActionEvent e) {\n        String cmd = e.getActionCommand();\n        boolean askRestart = false;\n        if (cmd == null) return;\n        if (cmd.equals(\"GRAPHVIZ\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"GRAPHVIZ\", filename);\n            graphVizPath.setText(filename);\n            owner.mToolsAuxGraphviz.setEnabled(true);\n        }\n        if (cmd.equals(\"IMAGEMAGICK\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", filename);\n            imageMagickPath.setText(filename);\n        }\n        if (cmd.equals(\"FINFAMILY.XLS\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"xls\"));\n            chooser.setDialogTitle(\"Open xls file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", filename);\n            excelPath.setText(filename);\n            missingKeys = checkForMissingNames(filename);\n        }\n        if (cmd.equals(Resurses.OK)) {\n            String newPath = Suku.kontroller.getPref(owner, \"FINFAMILY.XLS\", \"\");\n            if (!newPath.equals(exPath)) {\n                askRestart = true;\n                Suku.setFinFamilyXls(newPath);\n            }\n            String input = (String) serverUrl.getSelectedItem();\n            if (input == null) {\n                input = \"\";\n            }\n            if (input.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"SERVERURL\", \"\");\n                if (!originUrl.isEmpty()) {\n                    askRestart = true;\n                }\n            } else {\n                URL url;\n                String resp = null;\n                try {\n                    url = new URL(input + \"SukuServlet\");\n                    HttpURLConnection uc = (HttpURLConnection) url.openConnection();\n                    int resu = uc.getResponseCode();\n                    if (resu == 200) {\n                        byte buff[] = new byte[1024];\n                        InputStream in = uc.getInputStream();\n                        int len = in.read(buff);\n                        resp = new String(buff, 0, len);\n                        uc.disconnect();\n                    }\n                } catch (Exception e1) {\n                    e1.printStackTrace();\n                }\n                if (resp != null && resp.toLowerCase().startsWith(\"finfamily\")) {\n                    Suku.kontroller.putPref(owner, \"SERVERURL\", input);\n                    if (!input.equals(originUrl)) {\n                        askRestart = true;\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(this, Resurses.getString(\"SERVER_ERROR\"), Resurses.getString(Resurses.SUKU), JOptionPane.ERROR_MESSAGE);\n                }\n            }\n            int newLoca = loca.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.LOCALE, locas[newLoca]);\n            if (!originLanguage.equals(locas[newLoca])) {\n                askRestart = true;\n            }\n            int newLang = repolang.getSelectedIndex();\n            if (newLang >= 0) {\n                Suku.kontroller.putPref(owner, Resurses.REPOLANG, Suku.getRepoLanguage(newLang, true));\n                Resurses.setLanguage(Suku.getRepoLanguage(newLang, true));\n            }\n            int imageScaler = imageScaling.getSelectedIndex();\n            Suku.kontroller.putPref(owner, \"SCALE_IMAGE\", \"\" + imageScaler);\n            owner.setImageScalerIndex(imageScaler);\n            int seleId = defaultCountryCode.getSelectedIndex();\n            if (seleId >= 0) {\n                selectedCc = ccodes[seleId];\n            }\n            try {\n                Resurses.setDefaultCountry(selectedCc);\n            } catch (SukuException e1) {\n                owner.setStatus(e1.getMessage());\n            }\n            int newDateIndex = dateFormat.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.DATEFORMAT, dateCodes[newDateIndex]);\n            Resurses.setDateFormat(dateCodes[newDateIndex]);\n            Utils.resetSukuModel();\n            boolean openStreetMap = useOpenStreetMap.isSelected();\n            Suku.kontroller.putPref(owner, \"USE_OPEN_STREETMAP\", \"\" + openStreetMap);\n            String fntSize = dbFontSize.getText();\n            Suku.kontroller.putPref(owner, \"DB_VIEW_FONTSIZE\", fntSize);\n            String lf = lfNames[lookAndFeel.getSelectedIndex()];\n            Suku.kontroller.putPref(owner, \"LOOK_AND_FEEL\", lf);\n            int lfIdx = -1;\n            for (int i = 0; i < lafInfo.length; i++) {\n                if (lafInfo[i].getName().equalsIgnoreCase(lf)) {\n                    lfIdx = i;\n                    break;\n                }\n            }\n            try {\n                if (lfIdx < 0) {\n                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n                } else {\n                    UIManager.setLookAndFeel(lafInfo[lfIdx].getClassName());\n                }\n                SwingUtilities.updateComponentTreeUI(owner);\n            } catch (Exception e1) {\n                logger.log(Level.WARNING, \"look_and_feel\", e1);\n            }\n            setVisible(false);\n            if (askRestart) {\n                if (missingKeys != null && !missingKeys.isEmpty()) {\n                    SukuPad pad = new SukuPad(this, missingKeys);\n                    pad.setVisible(true);\n                }\n                JOptionPane.showMessageDialog(this, Resurses.getString(\"RESTART_FINFAMILY\"), Resurses.getString(Resurses.SUKU), JOptionPane.INFORMATION_MESSAGE);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"list": ["index", "info", "find", "query", "read", "sort", "split", "sync", "LIST", "load", "show", "export", "check", "request", "get", "search", "delete", "test", "start", "ls", "ping", "pull", "parse", "print", "download", "stop"], "url": ["string", "path", "ssl", "base", "server", "uri", "resource", "lock", "entry", "http", "l", "host", "URL", "fl", "client", "connection", "build", "ob", "config", "file", "cl", "web", "page", "bb", "ll", "log", "conn", "ls", " URL", "blog", "sl", "rl", "pull", "Url", "www", "bug", "ur", "ul", "f", "org", "api"], "con": ["close", "Conn", "ex", "fa", "CON", "cf", "rc", "cons", "ran", "on", "http", "c", "fc", "ctrl", "sub", "run", "fn", "Con", "co", "func", "en", "ec", "client", "cm", "part", "cp", "an", "lc", "uc", "connection", "login", "ch", "open", "conv", "un", "ca", "cl", "xc", "fac", "conn", "exec", "ann", "pc", "ln", "ver", "bc", "com", "can", "ctx", "conf", "connect", "cn", "f", "cur"], "in": ["IN", "i", "input", "ex", "n", "ini", "c", "inner", "as", "socket", "sub", "ins", "bin", "is", "client", "reader", "login", "min", "r", "inc", "data", "vin", "out", "rin", "file", "conn", "rec", "again", "m", "In", "a", "stream", "lin", "b", "conf", "inn", "f", "win", "this", "re"], "buf": ["base", "buffer", "Buffer", "bf", "bd", "bh", "rc", "cb", "grab", "abs", "bin", "ff", "func", "pb", "uf", "la", "bag", "utf", "bu", "cv", "rb", "ab", "cas", "wb", "uc", "buff", "sb", "aka", "data", "conv", "tmp", "src", "fb", "exc", "bb", "vec", "db", "bytes", "bc", "Buff", "bp", "seq", "b", "br", "fab", "batch", "cur", "orig"], "bytesRead": ["byteLength", "tesLength", "wordsLength", " bytesWritten", "bytesFound", "wordsFound", "bytesFind", "BytesRead", "BytesWrite", "byteRead", "stringsLoad", "wordsRead", "tesRead", "bytesLength", "bytesWritten", "bytesread", " bytesLoad", " bytesFound", "BytesLoad", "bytesLoad", "BytesLength", " bytesFind", " bytesread", "tesFound", "stringsFind", "byteWritten", "BytesFind", "byteWrite", "BytesWritten", "stringsRead", " bytesWrite", " bytesLength", "bytesWrite", "tesread", "wordsread", "stringsWritten"]}}
{"id1": "6371607", "id2": "4164833", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 0, "substitutes": {"removeRealm": ["removeLocalM", "removeLocalam", "removeRealme", "removeRelms", "removerealme", "removeRealM", "removeBroadm", "removeLocalms", "delRealm", "removeRelam", "delBroadM", "delRealM", "deleteRealam", "delRealms", "removeScheme", "deleterealM", "removeRelm", "deleteRealm", "removerealM", "removeBroadms", "removeSchem", "removeBroadme", "deleteRealms", "removeLocalm", "deleterealms", "removeRealam", "removerealms", "delBroadms", "removeBroadM", "removeRelM", "removeRealms", "removerealam", "deleterealam", "deleterealm", "removerealm", "removeSchems", "delBroadme", "delRealme", "delBroadm", "removeScheM", "deleteRealM"], "realmIds": ["realmRefs", "realMPathids", "realMIds", "realmIDls", "realMIdls", "realmIDList", "realmRefids", "realmInts", "realmRefls", "realmRefList", "realMPathes", "realmIdos", "realMIdList", "realmIntids", "realmIdList", "realMByIdls", "realmByIds", "realmByIdList", "realMIdes", "realmByIdls", "realmRefes", "realmPathids", "realmByIdes", "realMByIdes", "realmIntes", "realMPathos", "realmIdes", "realMByIdList", "realmPathes", "realMByIds", "realmIDs", "realmIdls", "realmPaths", "realmIntos", "realMPaths", "realmRefos", "realmIDes", "realMIdos", "realmPathos", "realmIdids", "realMIdids"], "psImpl": ["csImpl", " psIter", "epsIter", "cssImpl", "qsimpl", "csimpl", " psimpl", "epsHelper", "dsImpl", " psHelper", "cssExpl", "dsHelper", "psHelper", "psimpl", "dsimpl", "qsHelper", "qsImpl", "psIter", " psExpl", "epsimpl", "cssimpl", "epsImpl", "cssIter", "epsExpl", "csHelper", "psExpl"], "iter": ["ite", "index", "upper", "i", "itter", "outer", "cer", "entry", "ie", "inter", "inner", "end", "limit", "walker", "ter", "gener", "el", "line", "sort", "in", "ler", "next", "loop", "er", "izer", "reader", "ner", "inc", "ir", "page", "ator", "iterator", "Iter", "init", "coll", "e", "it", "cher", "parse", "err", "apper", "finder", "former", "list", "enter", "loc"], "realmId": [" realmnHash", "realmOffset", "realmnOffset", "RealmsID", " realmHash", "realmcId", "realmnId", "realmePath", "ironmaId", "RealmName", "realmrId", "realmName", "realdmConfig", "realmInt", "realmPath", "realmsName", "workmNum", "realmeId", "realmid", "ironmRef", "realmConfig", "ironmID", " realmOffset", "realmID", "realdmId", "workmId", "workfID", "realmNum", " realmnConfig", "workfid", "realmnHash", "RealmID", "realmeName", "realrmId", "realmsId", " realmnId", "ironmId", "ironmaRef", "realmHash", "realmrid", "realrmID", "ironmaInt", "workfNum", "realarmPath", "realamid", "RealmPath", "RealmId", "realmRef", "realmcID", "ironmaID", "realfid", "realmrOffset", "workfId", "realfId", "realarmID", "workmid", "realmsPath", "realrmInt", "realmrID", "realmsID", "realmcRef", "realmeID", "realmaID", "realarmId", "realmrHash", "realmaInt", "realdmOffset", "RealmsId", "realarmName", "realmrNum", "realdmHash", "realmaRef", "ironmInt", "realamNum", " realmConfig", "RealmsName", "realfNum", "realmcInt", "workmID", " realmnOffset", "realfID", "RealmsPath", "realrmRef", "realmnConfig", "realamId", "realmaId", "realmrConfig", "realamID"]}}
{"id1": "20011285", "id2": "22135199", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 1, "substitutes": {"copy": ["zip", "Copy", "replace", "move", "py", "clip", "write", "save", "clone", "split", "sync", "cop", "cp", "type", "load", "cat", "upload", " cp", "file", "share", "get", "log", "delete", "change", "apply", "link", "update", "create", "paste", "rm", "opy", "transfer", "download"], "sourceFile": ["targetFolder", "ourcePage", " sourcePlace", " sourceFILE", "SourceDir", "ourceFolder", "ourceSourceFile", "targetPage", "sourceTime", "sourceDir", "ourceBook", "siteFILE", "sourceFILE", "sampleFILE", "SourceDirectory", " sourceDir", " sourceFiles", " sourcePage", "SourceTime", "ourceTime", "sourcePage", "ourceFile", "sourceFolder", "ourcePlace", "siteFilename", "targetFiles", "apiFiles", "slaveFile", " sourceBook", "slaveFILE", "SourcePlace", "ourcefile", "sourceFiles", "ourceFiles", "apiFile", "SourceBook", "SourceFile", "targetDir", "sourceFilename", "apiFilename", "slaveFiles", "siteFiles", "slaveFilename", " sourceDirectory", "sourcefile", " sourceFilename", "ourceDirectory", "sourceSourceFile", "sampleFilename", "sourcePlace", "sourceDirectory", "targetDirectory", "apiFILE", " sourcefile", "Sourcefile", "sourceBook", "SourceSourceFile", "SourceFiles", "sampleFile", " sourceSourceFile", " sourceFolder", "sampleFiles", "siteFile", " sourceTime", "targetFile"], "destinationFile": ["DestinationFile", "destinatorFILE", "destinatorDirectory", "dominatorPath", " destinationfile", "destinatingSourceFile", "destinatorFolder", "destructionfile", "destinatedfile", "destinatingFiles", "destinatorPath", "destinatorFile", "DestinatingDirectory", "DestinatingFiles", "destinateFile", "destructionFILE", "targetinationFile", " destinatingFile", "targetinatedFolder", "destinatingDirectory", "destructionFolder", "destinatingfile", "distructionFolder", "distructionFILE", " destinationFiles", "targetinatedFiles", "targetinationFolder", "destinatePath", "desturationFiles", "destinatorSourceFile", "destwayFiles", "destinatedFile", "targetinationfile", "destinationFILE", "destinatedFolder", "destinatingFolder", "dominationPath", "desturationDirectory", "destinatingFile", "distructionFile", "desturationFile", "dominationfile", "distinationFile", "destinatorFiles", "distinationFolder", " destinatingFiles", "destwayFile", "DestinationDirectory", "distinationfile", "destwayFILE", "destinatingFILE", "destinatingPath", "destinationDirectory", "DestinationSourceFile", "destinationSourceFile", "DestinatingSourceFile", " destinatingfile", "destuationFILE", "targetinatedFile", "dominationFiles", "distructionfile", "desturationSourceFile", "dominatorFILE", "destinationFolder", "destinationFiles", "destinatorfile", "targetinationFiles", "destuationFolder", "distinationFILE", " destinatingFolder", "destructionFile", "destuationFile", "targetinatedfile", "dominationFILE", " destinationFolder", "destinationPath", "DestinatingFile", "dominatorFiles", "dominatorfile", "destinatedFiles", "dominatorFile", "destuationfile", "destinateFolder", "destwayfile", "destinatefile", "dominationFile", "DestinationFiles", "destinateFiles", "destinationfile"], "tmp": ["zip", "handler", "temp", "stuff", "cmp", "vm", "mo", "py", "current", "slice", "dest", "apps", "api", "pty", "meta", "split", "csv", "txt", "params", "mb", "part", "rb", "cache", "tab", "pp", "dir", "mp", "buf", "diff", "media", "upload", "data", "flat", "mm", "fb", "amp", "page", "ip", "img", "p", "np", "bb", "po", "folder", "tp", "e", "t", "pos", "nb", "array", "db", "sup", "area", "files", "obj", "sp", "v", "st", "rm", "dat", "ppa", "list", "storage"], "f": ["info", "handler", "fe", "fa", "bf", "fs", "rf", "cf", "df", "lf", "xf", "c", "fc", "fi", "fp", "o", "l", "fn", "j", "fr", "ff", "uf", "fl", "d", "r", "g", "file", "fb", "x", "p", "u", "m", "e", "io", "t", "fo", "af", "F", "full", "fd", "conf", "v", "b", "tf", "inf", "this", "fx"], "i": ["index", "info", "id", "n", "pi", "uri", "ij", "ie", "c", "j", "fi", "ri", "o", "l", "s", "si", "ui", "ii", "in", "key", "qi", "vi", "ti", "ji", "d", "lc", "li", "ip", "h", "p", "x", "bi", "u", "ai", "start", "oi", "ci", "I", "e", "m", "io", "name", "xi", "gi", "di", "hi", "v", "b", "y", "iu", "multi", "ix"], "source": ["base", "core", "input", "id", "resource", "uri", "server", "Source", "site", "ie", "slice", "slave", "current", "ge", "result", "si", "grade", "SOURCE", "client", "back", "ce", "use", "reader", "proxy", "cache", "connection", "target", "scope", "diff", "component", "parent", "src", "get", "null", "start", "e", "force", "io", "sl", "secure", "this", "stream", "wrapper", "ource", "service", "from", "view", "storage"], "destination": ["partination", "destinating", "generinate", "estination", "combinated", "Destinate", "Destinating", "destation", "estinate", "combinator", "partinated", "combinate", " destinated", "generinator", "estinating", "destinated", "partinator", " destinator", "Destination", "Destinated", "Destinator", " destation", "generinated", "estinator", "generination", "partation", "destinate", "destinator", "combination", "combinating", "Destation"]}}
{"id1": "659316", "id2": "12055086", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"argv": ["argver", "ArgV", "paramv", " argl", "Argver", "argV", " argf", "argb", "argumentc", "Argb", "argsc", "argve", "argumentver", "Argv", "Argve", "paramV", "Argf", "argumentv", " argve", " argV", " argver", "argc", "Argl", "argf", "argsv", "paramb", "argsf", " argb", "argumentve", "paraml", "interv", " argc", "interl", "Argc", "interc", "interV", "argsl", "argl"], "sources": ["issource", "psresources", "issors", "issides", "sesences", "issources", "sesigs", "fresources", "tides", "sresources", "sigs", "tresources", "statources", "statences", "sides", "psource", " sides", "sors", " sors", "tource", "vesores", "psides", "vesences", "psources", "fource", "tources", "vesources", "sences", "fides", "fors", "sores", "statores", "sesources", "sesores", "statigs", "fources", "vesigs"], "targets": ["tigets", "tangencies", " targencies", "toket", " toket", " targends", "Tangets", "Tangels", "tanges", "taxends", "targels", "tagnens", "targens", "tangets", "tigens", " taxends", " tokens", "tokencies", "tokens", "tagnets", "taxes", " targens", "Targels", "tiges", "tamplets", "tanget", "targends", " taxes", "tangels", "Tangens", "taxlets", "Tanglets", "tigends", "taxets", "tampens", "taxens", "taxels", "tokets", " tokencies", "tampets", " taxens", "tangens", "Targets", "tagnet", "targes", "tanglets", " targes", "targencies", "targlets", "Targens", "tagnencies", "tangends", "tampels", " taxets", "Targlets", " tokets"], "srclen": ["rsclen", "srseln", "srceln", " srplen", "srcteno", " srcleno", "rscln", "srplen", " srploen", "srclEN", "srClens", "rscelEN", " srclength", " srplength", "srCLen", "srploen", "srpleno", "srcleno", "rscelen", "srcten", " srpleno", "srClen", "srcelen", "srCLeno", "srctoen", "srClEN", "srCLoen", "srCln", "srclens", "srcelEN", " srcloen", "srclength", "srplength", "srcln", "rsclEN", "srselEN", "srcelens", "rscelens", "srselens", "srcloen", "srselen", "srctength", "srCLength", "rsceln", "rsclens"], "source": ["event", "path", "remote", "ssl", "input", "self", "resource", "uri", "copy", "id", "Source", "rc", "slice", "current", "dest", "driver", "s", "ources", "in", "SOURCE", "client", "type", "use", "reader", "cache", "proxy", "seed", "scope", "component", "model", "parent", "config", "channel", "src", "out", "size", "get", "view", "start", "force", "image", "link", "sl", "secure", "url", "stream", "unit", "create", "ource", "service", "single"], "tgt": ["ptnt", " tgz", "tbuster", "lnt", "ticket", "Targ", "Tgt", "rgt", "lgt", "lgz", "targ", "tret", "hgz", "Tgh", " tkt", " tnt", "biticket", "tgh", " tch", "rkt", "ptarg", "tnt", " tgh", "lret", "Tkt", " targ", " tret", "hret", " ticket", "lbuster", "ptbuster", "ptgt", "tkt", "tgs", "Tch", "rch", " tbuster", "larg", "tch", " tgs", "bitgh", "bitgt", "Ticket", "bitarg", "Tgs", "hgt", "rgs", "hnt", "tgz"], "target": ["event", "path", "goal", "base", "tail", "core", "cross", "remote", "handler", "output", "resource", "master", "slave", "project", "rel", "current", "result", "dest", "Target", "driver", "match", "child", "manager", "next", "client", "nt", "session", "member", "connection", "component", "arget", "parent", "open", "channel", "out", "route", "director", "archive", "object", "null", "conn", "plugin", "view", "force", "io", "port", "image", "to", "it", "mount", "url", "unit", "external", "service", "download", "point"], "deletes": ["downlete", "downgrades", "desires", " deises", "Deletes", " degrades", "disletes", "disists", " delete", "exgrades", "desletes", "deists", "delleted", "dedates", "kesleted", "kesletes", "deleted", "exdates", "downdates", "delletes", "exlete", "kesouts", "Deists", "exletes", " deleted", "delete", " dedates", "downletes", "deouts", " deouts", "degrades", "Deires", "delises", "delouts", "kesises", "desists", "disles", "deles", "Deles", "deises", "deires", "desles", "disires"], "del": ["remove", "base", "sel", "id", "copy", "clean", "lock", "add", "rel", "se", " delete", "el", "fail", "fl", "dl", "syn", " Del", "d", "dir", "up", "delay", "diff", "model", "down", "data", "file", "de", "Delete", "nl", "local", "get", "ll", "null", "delete", "neg", "name", "coll", "change", "Del", "dec", "skip", "pull", "update", "err", "bl", "ul", "def", "download", "install"]}}
{"id1": "3330944", "id2": "9347451", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"extractImage": ["extressFile", "extractFile", "extrateLayer", "compractImage", "compractText", "extressText", "compressLayer", "extressLayer", "extvertText", "extrateImage", "extressImage", "extractLayer", "extrateFile", "extvertImage", "compressImage", "compractLayer", "extvertFile", "compressFile", "extractText", "compractFile", "extvertLayer", "extrateText", "compressText"], "input": ["IN", "string", "path", "audio", "sin", "i", "qa", "id", "base", "temp", "ini", "rc", "ink", "OUT", "current", "inner", "RAW", "standard", "bin", "dc", "SOURCE", "API", "picture", "raw", "form", "type", "source", "reader", "Input", "inc", "inf", "media", "inside", "DATA", "work", "config", "data", "file", "text", "out", "parent", "src", "tmp", "request", "empty", "amp", "null", "init", "image", "PUT", "prefix", "In", "pull", "url", "address", "include", "command", "xml", "view", "img"], "output": ["string", "path", "address", "temp", "response", "resource", "Output", "filename", "version", "current", "message", "document", "result", "write", "password", "exit", "source", "dir", "target", "config", "parent", "file", "out", "text", "page", "format", "name", "generated", "image", "prefix", "unit", "secret", "STDOUT", "external"], "params": ["services", "base", "bis", "mos", "i", "Par", "server", "spec", "pi", "lis", "settings", "results", "http", "resources", "json", "lp", "py", "features", "styles", "s", "si", "manager", "parts", "reader", "fps", "proc", "lc", "ams", "par", "Parameters", "config", "pro", "attr", "data", "mm", "names", "options", "models", "plugins", "las", "p", "ras", "afi", "dis", "vs", "details", "theme", "ctx", "photos", "pins", "processor", "conf", "obj", "pixel", "batch", "rules", "xml", "words", "ps", "properties", "Param", "phrase", "param", "api", "phys"], "w": ["nw", "wi", "rw", "temp", "wp", "wl", "fw", "wt", "write", "wm", "wd", "ws", "reader", "wb", "W", "wh", "wic", "wave", "work", "pipe", "war", "out", "web", "widget", "wal", "wcs", "p", "aw", "m", "writer", "kw", "worker", "we", "wa", "sw", "xml", "world", "hw", "ow", "wx", "f"], "in": ["IN", "index", "pin", "ssl", "i", "ex", "n", "fa", "qa", "temp", "id", "ini", "gin", "inas", "con", "socket", "ins", "arin", "bin", "part", "source", "thin", "binary", "login", "min", "connection", "inside", "r", "inc", "config", "data", "file", "out", "vin", "rin", "src", "p", "null", "conn", "init", "ai", "again", "cgi", "m", "image", "isin", "ani", "In", "nin", "kin", "mc", "lin", "b", "include", "ac", "err", "cin", "inn", "f", "cli", "win", "din", "img"], "dest": ["path", "rest", "remote", "temp", "beta", "id", "resource", "cont", "project", "loc", "destroy", "done", "wd", "dc", " Dest", "exit", "txt", "die", "comb", "source", "d", "doc", "wb", "dir", "target", "dist", "default", "config", "parent", "flat", "src", "de", "Dest", "tmp", "nam", "route", "null", "style", "delete", "dis", "test", "desc", "name", "folder", "home", "decl", "di", "sup", "dep", "prop", "coord", "st", "dom", "gui", "dat", "din", "img"], "bi": ["info", "wi", "pin", "bis", "i", "mu", "fa", "cu", "pi", "ini", "bh", "fi", "bs", "si", "bin", "ii", "ori", "obi", "qi", " bio", "wei", "vi", "gb", "ji", "ti", "sb", "phi", "chi", "bas", "li", "bank", "BI", "ai", "oi", "ci", "eni", "oci", "zi", "nb", "xi", "di", "gi", "ib", "bc", "umi", "ki", "isi", "b", "ga", "ni", "abi", "ba", "bm", "Bi", "agi", "dat", "mini", "cli", "bid"], "os": ["ou", "i", "oses", "fs", "Os", "fits", "ks", "oa", "ns", "as", "dos", "OS", "o", "outs", "bs", "s", "co", "is", "oos", "so", "ws", "bos", "ops", "nos", "ob", "out", "xs", "ors", "es", "des", "oes", "vs", "aos", "obs", "io", "oss", "pos", "ot", " bos", "ios", "oS", "us", "ds", "los", "cs", "osi", "cos"]}}
{"id1": "10266116", "id2": "15904772", "code1": "    public InputStream retrieveStream(String url) {\n        HttpGet getRequest = new HttpGet(url);\n        try {\n            HttpResponse getResponse = getClient().execute(getRequest);\n            final int statusCode = getResponse.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n                Log.w(getClass().getSimpleName(), \"Error \" + statusCode + \" for URL \" + url);\n                return null;\n            }\n            HttpEntity getResponseEntity = getResponse.getEntity();\n            return getResponseEntity.getContent();\n        } catch (Exception e) {\n            getRequest.abort();\n            Log.w(getClass().getSimpleName(), \"Error for URL \" + url, e);\n        }\n        return null;\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 0, "substitutes": {"retrieveStream": ["retriveContent", "retrieveContent", "retrievedObject", "retriveStream", "retriveSteam", "retrievedSteam", "retrievedStream", "RetrievedObject", "RetrievedSteam", "retrieveObject", "retrievingContent", "RetrieveObject", "RetrieveSteam", "RetrievedContent", "RetrieveStream", "RetrieveContent", "retrievedContent", "retriveObject", "retrievingStream", "retrieveSteam", "RetrievedStream", "retrievingSteam", "retrievingObject"], "url": ["path", "string", "address", "ssl", "base", "server", "uri", "resource", "id", "username", "feed", "http", "filename", "ref", "location", "l", "host", "URL", "el", "fr", "email", "source", "connection", "ug", "str", "config", "file", "src", "route", "li", "request", "ll", "log", "href", "style", "ls", "name", "image", "full", "sl", "rl", "layer", "Url", "ur", "f", "gl", "service", "download", "loc"], "getRequest": ["showResp", "GetResponse", " getResp", "checkRequest", "getResp", " getSession", "checkSession", "findResponse", "findRequest", "checkResult", "getResult", "Getrequest", "httpRequest", "findResp", " getUrl", "getrequest", "getSession", " getResult", "showRequest", "showUrl", "GetRequest", "getUrl", "findUrl", "httpResult", "httpResponse", "GetSession", "checkResponse", "showResponse", "checkrequest", " getrequest"], "getResponse": [" getReply", " getView", "initresponse", "gotView", " getResp", "findReply", "gotRequest", "getResp", " getresponse", "findResponse", "getStatus", "findRequest", "initResponse", "updateResponse", "httpResp", "gotReply", "getResult", "updateResult", "getReply", "findView", "getView", "updateResp", "httpRequest", "gotResponse", "httpStatus", " getResult", "initResp", "updateresponse", "initStatus", " getStatus", "httpResponse", "getresponse", "initRequest", "initResult"], "statusCode": ["resourceCode", "StatusInfo", "servicecode", "statcode", "statusInfo", "statType", "serviceInfo", "resourceType", " statusType", "statusType", "statuscode", "contentType", "contentInfo", "serviceCode", "statusStatus", "statStatus", "StatusType", "resourcecode", "contentCode", "statCode", " statuscode", "StatusCode", "Statuscode", "contentcode", "resourceStatus", "StatusStatus", "serviceType"], "getResponseEntity": ["getResponseContent", "apiResponseUrl", "getRespentity", "getResponseentity", "apiresponseContent", "initResponseContent", "initStatusentity", "getStatusBody", "getRespUrl", "initStatusBody", "getResponseUrl", "getRespUnit", "getStatusUnit", "getResponseUnit", "getStatusEntity", "apiResponseContent", "apiresponseUnit", "getResponseBody", "getresponseUrl", "getRespEntity", "getresponseUnit", "getStatusentity", "initResponseEntity", "getresponseEntity", "getStatusUrl", "apiresponseUrl", "apiresponseEntity", "apiResponseEntity", "initStatusEntity", "getresponseentity", "getStatusContent", "initStatusContent", "getRespContent", "getRespBody", "initResponseentity", "initResponseBody", "getresponseContent", "getresponseBody", "apiResponseUnit"]}}
{"id1": "23035537", "id2": "8588992", "code1": "    public boolean getContent(String userId, String latestMsgId) {\n        try {\n            String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId;\n            URL url = new URL(targetUrl);\n            InputStream in = url.openStream();\n            ArrayList<MessageObj> list;\n            if (in != null) {\n                MessageListDOMParser parser = new MessageListDOMParser();\n                list = (ArrayList<MessageObj>) parser.parseXML(in);\n                TransactionDAO dao = new TransactionDAO();\n                dao.insert(list);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    public ActionForward perform(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String status = null;\n        HttpSession session = request.getSession();\n        ReportingBean reportingBean = null;\n        NewConceptBean conceptBean = null;\n        String conceptName = null;\n        String primitive = null;\n        MessageResources errorMessages = MessageResources.getMessageResources(\"com.apelon.apps.dts.treebrowser.resources.error_messages\");\n        LogonUtilities logonUtilities = new LogonUtilities();\n        if (logonUtilities.checkSession(session, status, reportingBean, errorMessages)) {\n            reportingBean = (ReportingBean) session.getAttribute(\"reportingBean\");\n            if ((reportingBean.getMessageHtml().indexOf(\"Classify\")) == -1) {\n                reportingBean.setReportingHtml(\"\");\n            }\n            conceptBean = (NewConceptBean) session.getAttribute(\"newConceptEntity\");\n            conceptName = request.getParameter(\"conceptName\");\n            primitive = request.getParameter(\"primitive\");\n            if (primitive == null) {\n                primitive = \"false\";\n            }\n            conceptBean.setConceptName(conceptName);\n            conceptBean.setPrimitive(primitive);\n            String namespace = conceptBean.getConceptNamespace();\n            if (namespace == null) {\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_3\"));\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n                return (mapping.findForward(status));\n            }\n            String[] roleMods = request.getParameterValues(\"some_or_all\");\n            String[] roleGrps = request.getParameterValues(\"role_group\");\n            Vector roles = conceptBean.getRoles();\n            RoleBean[] roleCons = new RoleBean[roles.size()];\n            roles.copyInto(roleCons);\n            if (roleMods != null && roleGrps != null && roleCons != null) {\n                if (roleCons.length == roleMods.length && roleCons.length == roleGrps.length) {\n                    for (int i = 0; i < roleCons.length; i++) {\n                        roleCons[i].setSomeOrAll(roleMods[i]);\n                        roleCons[i].setRoleGroup(roleGrps[i]);\n                    }\n                }\n            }\n            session.setAttribute(\"newConceptEntity\", conceptBean);\n            NewConceptXMLDisplayBean xmlBean = new NewConceptXMLDisplayBean();\n            xmlBean.setNewConceptXml(conceptBean);\n            String data = BrowserUtilities.encodeUrl(\"conceptXml\") + \"=\" + BrowserUtilities.encodeUrl(xmlBean.getNewConceptXml()) + \"&\" + BrowserUtilities.encodeUrl(\"nameSpace\") + \"=\" + BrowserUtilities.encodeUrl(namespace);\n            XMLPropertyHandler configPh = new XMLPropertyHandler(\"dtsbrowserclassify.xml\");\n            Properties configProps = configPh.getProps();\n            String urlString = configProps.getProperty(\"url\");\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuffer buf = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                buf.append(line);\n            }\n            String resultXml = buf.toString();\n            wr.close();\n            rd.close();\n            ClassifiedConceptBean ccBean = new ClassifiedConceptBean();\n            ClassifyResultParser parser = new ClassifyResultParser(resultXml);\n            ResultBuilder rbuilder = new ResultBuilder();\n            rbuilder.setConceptBean(ccBean);\n            rbuilder.setParser(parser);\n            rbuilder.setNamespace(namespace);\n            try {\n                rbuilder.buildResult();\n                ccBean = rbuilder.getConceptBean();\n                ClassifiedConceptDisplayBean displayBean = new ClassifiedConceptDisplayBean();\n                displayBean.setNewConceptHtml(ccBean);\n                session.setAttribute(\"classifyResult\", ccBean);\n                session.setAttribute(\"classifyDisplayResult\", displayBean);\n                status = \"success\";\n            } catch (Exception e) {\n                Categories.dataServer().error(StackTracePrinter.getStackTrace(e));\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_1\") + e.getMessage());\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n            }\n        }\n        return (mapping.findForward(status));\n    }\n", "label": 0, "substitutes": {"getContent": ["readBody", "postContents", "postcontent", "createContent", "readContent", "postBody", "createBody", "getBody", "postContent", "createContents", "readContents", "createcontent", "readcontent", "getContents", "getcontent"], "userId": ["USEROr", "userName", "userID", " userOr", "userPath", "messageName", " userID", "UserPath", "messageId", " userName", " userPath", "USERName", "messageID", "UserOr", "UserName", "userOr", "USERPath", "UserID", "USERId", "UserId"], "latestMsgId": ["latestMsgTime", "lastMsgId", " latestmsgid", "latestChanID", " latestmsgTime", "latestMessageId", "latestMsgID", "latestMessageTime", "lastMsgid", " latestmsgID", "latestMessageid", "latestmsgTime", "latestUserID", "latestChanId", "latestmsgID", "latestmsgid", "latestChanTime", "lastMessageid", "latestMessageID", "lastMsgID", "latestUserid", "latestMsgid", " latestmsgId", "latestUserId", "lastMessageID", " latestMsgid", "lastMessageId", " latestMsgTime", "latestmsgId", "latestChanid", " latestMsgID"], "targetUrl": ["targeturl", "targetPage", "sourceURL", "TargetUrl", " targetPage", "sourcePage", "Targeturl", " targetURL", "sourceUrl", " targeturl", "targetUr", "TargetUr", "targetURL", "sourceurl", "TargetURL", " targetUr", "TargetPage", "sourceUr"], "url": ["string", "path", "base", "address", "ssl", "i", "id", "uri", "resource", "server", "feed", "user", "http", "window", "l", "location", "host", "URL", "client", "source", "browser", "connection", "r", "data", "file", "channel", "page", "image", "link", "sl", "Url", "www", "stream", "b", "download", "f", "api"], "in": ["IN", "string", "i", "input", "inas", "resource", "serv", "ini", "gin", "inner", "as", "socket", "ins", "s", "arin", "record", "bin", "query", "is", "pass", "raw", "source", "reader", "load", "login", "r", "wave", "inc", "data", "file", "out", "get", "again", "m", "ax", "image", "isin", "In", "nin", "kin", "a", "stream", "b", "err", "xml", "inn", "din"], "list": ["string", "info", "i", "server", "id", "entry", "sequence", "lp", "table", "document", "json", "result", "join", "l", "set", "pool", "all", "record", "detail", "queue", "la", "LIST", "lc", "live", "item", "group", "collection", "listed", "section", "data", "li", "parent", "cl", "language", "cli", "test", "lists", "coll", "tree", "dict", "chain", "array", "parse", "xml", "batch", "tx", "view"], "parser": ["info", "handler", "class", "arser", "loader", "builder", "http", "document", "lp", "per", "json", "system", "jack", "api", "php", "util", "ler", "er", "paragraph", "reader", "player", "collection", "parent", "data", "director", "p", "language", "plugin", "rss", "writer", "worker", "a", "layer", "parse", "processor", "command", "xml", "Parser"], "dao": ["idaba", " dosa", " daos", "idosa", "datao", "datala", "adosa", "Daos", "adala", "Dao", "Daba", "Dosa", "adaos", "daba", "dala", "daos", "idao", "dataos", "adao", "idaos", "datosa", " daba", "dosa", " dala"]}}
{"id1": "15445861", "id2": "17557289", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "transferDirectory", "CopyFile", "copyfile", "transferfile", "transferFiles", " copyDirectory", " copyFiles", "CopyDirectory", "Copyfile", "copyDirectory", "CopyFiles", "copyFiles", "transferFile"], "srcFile": [" srcfile", "srcPlace", " srcTime", "destDirectory", "rcPlace", "sourceDir", "rcFile", "supFile", " srcDir", "srcFiles", "ourcePath", "ourceTime", "srcStream", "ourceFile", "rcfile", "sourcePath", "ourcePlace", "rcStream", "rcPath", "rcTime", "sourceFile", "srcTime", "destTime", "supPath", "rcFiles", "sourceFiles", "supStream", " srcFiles", "srcPath", "supfile", "destDir", " srcDirectory", "sourcefile", "srcDir", " srcPlace", "sourceDirectory", "rcDir", " srcPath", "srcfile", "rcDirectory", "srcDirectory", " srcStream"], "destFile": ["destFilename", "inationFilename", "stdfile", "destDirectory", " destTime", "sourceTime", "stdFile", " destDirectory", "endTime", "endPath", "DestPath", "destfile", "vertFilename", "DestFilename", "inationPath", "DestFile", "tempPath", " destFiles", "sourceFile", " destFilename", "destTime", "destFiles", "inationFiles", "stdTime", "DestFiles", "inationFile", "targetPath", " destfile", "stdDirectory", " destPath", "endFile", "sourcefile", "destPath", "vertFile", "Destfile", "vertPath", "sourceDirectory", "targetTime", "tempfile", "tempFile", "tempFiles", "vertFiles", "targetFilename", "endFilename", "targetFile"], "in": ["IN", "base", "pin", "i", "input", "id", "ex", "serv", "ini", "gin", "con", "socket", "inner", "as", "ins", "bin", "is", "read", "source", "reader", "up", "login", "min", "inside", "r", "inc", "rin", "h", "get", "init", "or", "again", "m", "io", "image", "isin", "In", "nin", "kin", "a", "pull", "url", "b", "ac", "cin", "inn", "f", "win", "din"], "out": ["base", "ex", "n", "output", "user", "by", "gin", "net", "OUT", "socket", "inner", "outs", "o", "off", "line", "bin", "pass", "sync", "client", "one", "cache", "up", "other", "inc", "w", "parent", "file", "work", "conn", "again", "exec", "Out", "io", "writer", "exp", "to", "ext", "err", "obj"], "buffer": ["base", "border", "Buffer", "input", "uffer", "address", "server", "feed", "pause", "document", "slice", "limit", "result", "length", "memory", "read", "queue", "offset", "iter", "reader", "source", "binary", "buff", "buf", "wave", "data", "channel", "variable", "size", "null", "header", "bytes", "position", "layer", "flush", "url", "b", "reference", "padding", "block", "transfer", "batch", "phrase"], "no": ["index", "info", "lo", "i", "num", " NO", " lo", "id", "ko", "nr", "mo", "yes", "number", "o", "off", "co", " mo", "No", "ino", "only", "nothing", "nt", "nor", "type", "so", "was", " none", "which", "nos", "none", "data", "eno", "maybe", "go", "x", "size", "po", "io", "pos", "to", "na", " number", "wa", "os", "zero", "NO", "error", "from", "auto"]}}
{"id1": "2381663", "id2": "22320592", "code1": "    @Test(expected = GadgetException.class)\n    public void malformedGadgetSpecIsCachedAndThrows() throws Exception {\n        HttpRequest request = createCacheableRequest();\n        expect(pipeline.execute(request)).andReturn(new HttpResponse(\"malformed junk\")).once();\n        replay(pipeline);\n        try {\n            specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n            fail(\"No exception thrown on bad parse\");\n        } catch (GadgetException e) {\n        }\n        specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n    }\n", "code2": "    private static void loadDefaultPreferences() {\n        try {\n            URL url = ClassLoader.getSystemResource(\"OpenDarkRoom.defaults.properties\");\n            preferences.load(url.openStream());\n        } catch (FileNotFoundException e) {\n            log.error(\"Default preferences file not found\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"malformedGadgetSpecIsCachedAndThrows": ["malformedGadgetSpecIsCachedandthrown", "malformedGadgetSpecIsCachedAndethrows", "malformedGadgetSpecIsCachedandthrows", "malformedGadgetSpecIsCachedAndthrows", "malformedGadgetSpecIsCachedAndThrown", "malformedGadgetSpecIsCachedAndthceptions", "malformedGadgetSpecIsCachedandthceptions", "malformedGadgetSpecIsCachedAndThceptions", "malformedGadgetSpecIsCachedandThrown", "malformedGadgetSpecIsCachedandThrows", "malformedGadgetSpecIsCachedAndethceptions", "malformedGadgetSpecIsCachedAndthrown", "malformedGadgetSpecIsCachedandThceptions", "malformedGadgetSpecIsCachedAndethrown"], "request": ["event", "job", "temp", "input", "Request", "output", "response", "resource", "server", "claim", "http", "report", "message", "result", "instance", "press", "query", "condition", "req", "queue", "er", "client", "q", "proxy", "r", "application", "config", "data", "parent", "p", "context", "complete", "test", "e", "QUEST", "call", "pe", "create", "pair", "trip", "method", "re", "enter"]}}
{"id1": "13644374", "id2": "13152325", "code1": "    public byte[] getBytesFromUrl(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toByteArray(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"getBytesFromUrl": ["getBytesfromString", "getbytesFormURL", "getbytesFromRoute", "getBytesFormRoute", "getBytesfromRoute", "getBytesfromURL", "getBytesfromUrl", "getbytesFromUrl", "getBytesViaURL", "getbytesFormRoute", "getBytesFromString", "getBytesFromURL", "getbytesFromString", "getBytesViaString", "getbytesFormUrl", "getbytesFromURL", "getBytesFormString", "getbytesFormString", "getBytesFormURL", "getBytesViaUrl", "getBytesViaRoute", "getBytesFormUrl", "getBytesFromRoute"], "url": ["path", "string", "address", "buffer", "base", "i", "server", "uri", "resource", "http", "json", "ref", "result", "l", "location", "host", "URL", "key", "email", "source", "connection", "str", "data", "route", "page", "request", "href", "name", "sl", "Url", "ur", "xml", "download", "method", "service", "api", "loc"], "get": ["i", "execute", "resource", "http", "gets", "json", "find", "set", "query", "read", "client", "handle", "like", "use", "load", "build", "open", "body", "request", "put", "GET", "start", "Get", "e", "exec", "send", "call", "pull", "update", "create", "parse", "cli", "method", "service", "api"], "response": ["error", "server", "output", "resource", "feed", "http", "report", "json", "message", "document", "onse", "result", "content", "resp", "connection", "application", "wave", "data", "body", "out", "page", "request", "object", "reply", "e", "tree", "status", "success", "full", "received", "Response", "respond", "f", "method", "api"], "entity": ["event", "info", "translation", "node", "server", "resource", "Entity", "output", "element", "entry", "http", "json", "document", "message", "result", "instance", "el", "content", "security", "ent", "ale", "resp", "connection", "model", "collection", "data", "file", "body", "page", "object", "metadata", "environment", "null", "e", "image", "action", "person", "pe", "xml", "this", "api"]}}
{"id1": "15510198", "id2": "11716816", "code1": "    protected static Parser buildParser(URL url) throws IOException, ParserException {\n        Parser parser;\n        URLConnection connection = openConnection(url);\n        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {\n            parser = new Parser(connection);\n        } else {\n            parser = null;\n        }\n        return parser;\n    }\n", "code2": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "label": 0, "substitutes": {"buildParser": ["constructParser", "constructReader", "makeReader", "makeWriter", "buildWriter", "newHandler", "makeParser", "newReader", "newParser", "constructHandler", "buildHandler", "newWriter", "constructWriter", "buildReader", "makeHandler"], "url": ["path", "address", "base", "loader", "class", "ssl", "server", "uri", "resource", "http", "c", "location", "l", "host", "URL", "source", "proxy", "str", "open", "config", "data", "file", "channel", "page", "object", "null", "name", " URL", "image", "io", "link", "sl", "Url", "bug", "www", "obj", "this", "service", "loc"], "ParserException": ["IOError", "IOExc", "SSLError", " IOExc", "SSLException", "SSLExc", " IOException", " IOError", "ParserError", "ParserExc", "IOException"], "parser": ["root", "handler", "class", "arser", "loader", "server", "builder", "master", "http", "slave", "result", "se", "instance", "library", "api", "pool", "php", "fp", "manager", "ler", "pard", "er", "type", "reader", "cache", "seed", "parent", "data", "au", "config", "object", "x", "p", "null", "style", "plugin", "test", "fruit", "writer", "worker", "jp", "pc", "angler", "pe", "parse", "processor", "xml", "Parser", "pd", "this", "jack"], "connection": ["directory", "Connection", "event", "handler", "class", "server", "resource", "response", "uri", "http", "document", "con", "c", "communication", "connected", "socket", "message", "character", "instance", "j", "relation", "database", "condition", "client", "session", "reader", "lc", "proxy", "ion", "application", "collection", "open", "config", "section", "channel", "object", "context", "conn", "image", "io", "function", "pointer", "link", "db", "service", "position", "bc", "connect", "reference", "this", " Connection", "loc"]}}
{"id1": "1954410", "id2": "2511579", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitExecute", "doExecApply", "submitexecuteApply", "doexecuteute", "doSendRun", "doexecuteRun", "submitexecuteRun", "doSendute", "doexecuteutes", "submitExecApply", "doSendutes", "submitExecutes", "doExecutes", "submitexecuteutes", "submitexecuteute", "doExecRun", "doexecuteApply", "doSendApply", "submitExecRun"], "mapping": [" mapper", " matching", "aminding", "matching", "minding", " minding", "finding", "fatching", "amapping", "fapping", "fapper", "mapper", "amatching", "amapper"], "form": ["feed", "builder", "Form", "formation", "flow", "owner", "pattern", "post", "component", "FORM", "config", "page", "object", "forms", " forms", "control", "format", "submit", "template", "transform", "url", "app", "command", "xml", "dom", "method", "field", "definition"], "request": ["path", "address", "input", "Request", "resource", "server", "self", "user", "uri", "add", "report", "message", "json", "HTTP", "current", "result", "instance", "s", "query", "ware", "queue", "req", "client", "Accept", "session", "reader", "type", "use", "q", "model", "application", "parent", "Reply", "data", "route", "Upload", "object", "requ", "context", "hello", "complete", "submit", "name", "format", "QUEST", "frame", "Bytes", "worker", "call", "pull", "url", "Response", "create", "_", "xml", "method", "this", "re", "view"], "response": ["handler", "server", "resource", "output", "report", "res", "message", "json", "result", "req", "client", "resp", "Resp", "model", "application", "data", "page", "object", "reply", "status", "Response", " Response", "v", "xml", " responses", "view"], "errors": ["mess", " messaging", " mess", " messages", " acc", " managers", " commands", " streams", " payload", " status", " session", " management", " problems", " events", " replies", " Messages", " flashes", " updates", " changes", " error", " messenger", " warnings", " calls", " translations", " this", " logger", " failures", " responses", " logs"], "isMultipart": ["isMultompart", "isMultippedart", "isMultompost", "isMultipage", "isMultiipPart", "isMultipound", "isMultipated", "isMultitart", "isMultipPart", "isMultiart", "isMultippedPart", "isMultIPart", "isMultippedost", "isMultiparts", "isMultiIPPart", "isMultompound", "isMultippage", "isMultIPound", "isMultompPart", "isMultiipart", "isMultIPost", "isMultiipound", "isMultitage", "isMultippated", "isMultiIPart", "isMultippedound", "isMultiage", "isMultIPPart", "isMultipparts", "isMultipost", "isMultippart", "isMultiIPound", "isMultiated", "isMultitated", "isMultiipost", "isMultitarts", "isMultiIPost", "isMultiarts"], "mailInstance": [" mailInst", " mailUsage", "mailinstance", " mailManager", "mailInst", " emailInst", "emailInst", " emailinstance", "fileUsage", "emailManager", "emailInstance", " emailUsage", "fileinstance", " emailInstance", "fileInst", " mailinstance", "emailinstance", "fileInstance", "mailManager", "mailUsage", "fileManager"], "fields": ["keys", "services", "maps", "headers", "input", "locks", "checks", "archives", "forces", "pages", "gets", "comments", "features", "holders", "posts", "qs", "s", "packs", "ids", "params", "parts", "changes", "states", "links", "uploads", "lines", "boxes", "flows", "strings", "loads", "ments", "users", "members", "tags", "data", "classes", "facts", "utils", "objects", "models", "plugins", "groups", "forms", "lists", "atts", "types", "cells", "rows", "details", "files", "dates", "acks", "rules", "words", "events", "properties", "views", "field"], "attachments": ["payments", "achresses", "achment", "attachment", "Attachps", "atters", "attps", "attachlements", "attachresses", "attments", "payresses", "suppees", "achparts", "attions", "extments", "Attachlements", "exters", "Attachions", "attachions", "payment", "Attachers", "achments", "attachers", "suppments", "Attachment", "attachparts", " attachment", "suppment", "attachees", "extions", "attlements", " attachresses", "Attachments", "supplements", "extps", "payparts", "attachps", "attment", "Attachees", "attees", " attachparts"], "items": ["keys", "locks", "pages", "results", "ers", "apps", "ins", "qs", "reports", "ids", "apters", "parts", "its", "links", "lines", "ops", "children", "Items", "orders", "data", "names", "objects", "plugins", "ips", "models", "es", "groups", "phones", "lists", "alls", "types", "rows", "files", "events", "list"], "iter": ["ite", "upper", "zip", "order", "event", "i", "itter", "outer", "master", "http", "slice", "inter", "inner", "oper", "end", "walker", "ter", "gener", "el", "loop", "er", "izer", "Iterator", "reader", "ner", "inc", "file", "ir", "li", "page", "ip", "ator", "iterator", "Iter", "keep", "edit", "coll", "chain", "exp", "it", "skip", "cher", "ver", "ser", "err", "ul", "finder", "former", "altern", "list", "enter", "loc"], "item": ["index", "original", "base", "handler", "temp", "resource", "token", "volume", "art", "file", "get", "example", "coll", "it", "url", "obj", "container", "custom", "element", "info", "server", "site", "result", "all", "next", "post", "source", "load", "up", "section", "page", "object", "ip", "plugin", "complete", "hop", "name", "full", "missing", "attribute", "service", "Item", "storage", "val", "event", "order", "i", "atom", "more", "entry", "slice", "inner", "anything", "er", "reader", "other", "or", "issue", "image", "app", "update", "api", "album", "user", "current", "instance", "extra", "type", "data", "li", "entity", "widget", "folder", "area", "layer"], "aux": ["anc", "ou", "pkg", "lang", "cmp", "axe", "ants", "ru", "sub", "abs", "off", "extra", "uf", "union", "ux", "except", "lc", "uc", "cas", "strings", "auc", "buf", "aff", "alias", " auxiliary", "au", "ups", "data", "etc", "ras", "amp", " Aux", "des", "aw", "aos", "offs", "asc", "af", "packages", "array", "frac", "sup", "prefix", "ox", "fax", "abc", "ext", "imp", "aus"], "part": ["val", "base", "class", "info", "id", "pi", "Part", "user", "add", "pre", "on", " Part", "act", "per", "ref", "join", "html", "l", "patch", "instance", "co", "PART", "joined", "key", "parts", "comp", "fact", "type", "back", "one", "player", "no", "art", "connection", "component", "diff", "ch", "group", "section", "parent", "data", "file", "object", "p", "format", "plugin", "po", "start", "change", "name", "but", "action", "pos", "word", "full", "area", "layer", "pair", "partial", "obj", "b", "and", "block", "f", "step", "error", "field", "element", "list", "point"], "baos": ["Bais", "BAos", "bois", "baOs", "pais", "Baosi", "boo", "bais", "hao", "baot", "boOS", "paOS", "haoss", "BAis", "abaos", "BAo", "hais", " bais", "paot", "BAoS", "BAOs", "Bao", "haos", " baoS", "BAoss", "bao", "baosh", " baot", " baOS", "BaoS", "paos", "BaOs", " bao", "baosi", "BAosh", "baoS", "abais", "BAosi", "Baos", "baOS", "abaosi", "boosh", "paosh", " baoss", "baoss", "abaOs", "boos", "pao", "boot"], "body": ["zip", "string", "translation", "fee", "headers", "output", "resource", "message", "description", "document", "json", "end", "html", "length", "shell", "query", "pass", "content", "parts", "params", "type", "source", "binary", "connection", "value", "media", "common", "data", "text", "options", "object", "size", "flash", "null", "Body", "reply", "name", "header", "template", "tree", "port", "full", "url", "comment", "b", "summary", "state"], "preferencesInstance": ["prefirmsClient", "prefeesInstance", "preferencesinstance", "preffeesClient", "prefferencesInstance", "prefirmsInstance", "prefeesinstance", "preferencesClient", "prefferencesClient", "prefeesClient", "prefirmsinstance", "prefferencesinstance", "prefiesClient", "prefiesinstance", "preffeesinstance", "prefiesInstance", "preffeesInstance"]}}
{"id1": "15051083", "id2": "7633336", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    private JSONObject executeHttpGet(String uri) throws Exception {\n        HttpGet req = new HttpGet(uri);\n        HttpClient client = new DefaultHttpClient();\n        HttpResponse resLogin = client.execute(req);\n        BufferedReader r = new BufferedReader(new InputStreamReader(resLogin.getEntity().getContent()));\n        StringBuilder sb = new StringBuilder();\n        String s = null;\n        while ((s = r.readLine()) != null) {\n            sb.append(s);\n        }\n        return new JSONObject(sb.toString());\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getmessageDigests", "getmessageDigature", "getmessageDigest", "getmessagedigest", "getMessagedigester", "getMessageDesignature", "getMessageHashature", "getmessageDigester", "getMessageDigester", "getMessageDesignester", "getmessagedigature", "getMessageHashester", "getMessagedigature", "getMessageHashests", "getMessageDigature", "getMessagedigests", "getMessageDesignests", "getMessagedigest", "getMessageHashest", "getmessagedigester", "getmessagedigests", "getMessageDigests", "getMessageDesignest"], "digest": ["Digester", "signester", "hexex", "hexests", "DigEST", "Diger", "sandesting", " Digeter", " Dighed", " digeter", " Diger", " Digester", "signest", "Digex", " digested", " diger", "dighed", "hexEST", "Dighed", "signiter", "digex", " digEST", "signested", "Digests", " digger", "feedested", "digester", "signesting", "greatiter", "Digeter", " Digest", "digested", "digests", "sandest", "digger", "greatester", "sandester", "Digesting", "Digest", " digex", " dighed", "digeter", "sandested", "diger", " Digger", "Digger", " digester", "Digiter", "greatest", "greatested", "feedester", "hexest", " digests", "Digested", "feedest", "digiter", "digEST", "digesting"], "node": ["event", "remote", " Node", "root", "address", "index", "path", "self", "n", "resource", "server", "uri", "document", " nodes", "Node", "instance", "location", "child", "global", "one", "source", " parent", "connection", "module", "component", "config", "parent", "route", "entity", "local", "object", "name", "internal", " child", "ode", " namespace", " source", "network", " annotation", "odes", "element", "point"], "external": ["remote", "ex", "n", "resource", "outer", "secondary", "intern", "ternal", "instance", "account", "global", " External", "outside", "client", "source", "binary", "target", "international", "out", "export", "https", "local", "object", "environment", " remote", "multiple", " global", "External", "internal", "name", "e", "tern", "Intern", "reference", "network", " foreign", "foreign", "element"], "messageDigest": ["messageModested", " messageDigger", "messageMarkest", " messageDigesting", " messageHashest", "messageDigger", "MessageDigester", "messageDigenge", "messageDesignested", "messageDesignger", "messageDested", "messageHashesting", "messagedigest", "messagedigester", "messageDigester", "MessageSignenge", "messageHashester", " messageHashesting", "messageHashested", " messageDigester", "MessageSignested", "messageMarkested", "MessageDigested", "messageSignenge", "messageDigesting", " messageDesignested", "MessageSignest", "messageModester", "messageDest", "messageModest", "messageMarkester", " messageHashested", "messageDigested", " messageDesignester", " messageDigested", "messageSignester", "messageDester", "messagedigger", "messagedigested", "MessageSignester", "messageMarkenge", " messageHashester", "messageSignested", "messageModesting", "messageDenge", "MessageDigest", " messageDesignger", "messageDesignester", "messageDesignest", "messageSignest", "messageDesignesting", "MessageDigenge", "messageHashest", " messageDesignest"]}}
{"id1": "7143591", "id2": "13414771", "code1": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "code2": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"getWebByUrl": ["getWebbyurl", "getWebFromurl", "getWebbyLocation", "getWebByurl", "getWebFromURL", "getwebByLocation", "getWebFromLocation", "getwebbyurl", "getWebByIdURL", "getwebByurl", "getwebbyURL", "getWebbyUrl", "getWebByLocation", "getWebbyURL", "getWebByIdurl", "getWebByURL", "getwebByUrl", "getwebbyLocation", "getWebByIdUrl", "getwebByURL", "getWebFromUrl", "getWebByIdLocation", "getwebbyUrl"], "strUrl": ["strUr", "StrURL", "wrUr", "arrPath", "stUrl", "STRFile", "arrRoute", "wrUrl", "StrUr", "stURL", "STRUr", "srURL", "slUr", "objUrl", " strURL", "StrLink", "objFile", "stFile", "wrURL", " strFile", "strPath", "strRoute", "arrurl", " strLink", " strurl", " strUr", "arrUrl", "StrFile", "sturl", "arrUr", "slUrl", "arrURL", "Strurl", "StrPath", "slURL", "StrEmail", "StrBase", "strFile", " strPath", " strBase", "wrEmail", "strurl", "objURL", "srUrl", "STRUrl", "strEmail", "StrUrl", "strLink", "srurl", "srLink", "strBase", "strURL", "objUr", "stUr", "slBase", "stEmail", "StrRoute", "STRURL", " strRoute"], "charset": ["charsec", "chARSec", "chasetting", "chARSet", " ChARSetting", "chactersET", " ChARSET", "chactersec", "chacterset", " CharsET", "chasec", "chaset", " ChARSet", " Charsetting", " Charsec", "chARSET", "chARSetting", "chactersetting", "chasET", "charsetting", " ChARSec", " Charset", "charsET"], "fileIndex": ["webIndex", "FilePath", "fullIndex", "fileindex", "FileIndex", "fullPath", "fullindex", "fullNumber", " fileindex", " fileVersion", " fileName", "fileVersion", "webVersion", "fileName", "webName", "Fileindex", " fileNumber", "webindex", "FileName", "fileNumber", "FileVersion", "FileNumber"], "url": ["zip", "path", "string", "ssl", "base", "address", "loader", "server", "uri", "resource", "serv", "id", "http", "l", "host", "URL", "fl", "client", "source", "proxy", "connection", "str", "r", "open", "config", "file", "web", "bel", "ll", "bb", "page", "ls", "image", "blog", "link", "sl", "ib", "Url", "service", "www", "ur", "b", "download", "f", "org", "api"], "conn": ["Connection", "ssl", "Conn", "server", "n", "serv", "enc", "http", "con", "c", "cb", "l", "nc", "client", "sync", "nt", "cp", "connection", "r", "ch", "w", "conv", "open", "ca", "config", "ci", "exec", "ann", "ctx", "Url", "conf", "b", "connect", "cn", "ac", "sn", "f", "cli", "api", "loc"], "is": ["info", "bis", "ssl", "i", "iss", "lis", "serv", "fs", "IS", "isa", "http", "ie", "Is", "as", "ri", "ins", "s", "il", "si", "ui", "in", "ii", "iter", "its", "ab", "jar", "ais", "browser", "internet", "ob", "isc", "ir", "out", "li", "src", "h", "ip", "x", "es", "init", "ai", "ls", "ris", "oss", "io", "it", "iris", "ios", "us", "ib", "isi", "are", "err", "b", "os", "ps", "was", "ar", "im", "iso", "mis"], "filePath": ["FilePath", "baseLocation", "fileUrl", "outputHome", "cacheLocation", "basePath", "FileUrl", "outputPath", "cachepath", " fileBase", "pagepath", "fileHome", "pageLocation", "FileHome", "baseIndex", " fileHome", "cachePath", " fileUrl", "filepath", "outputUrl", "cacheIndex", "pageIndex", "fileBase", "fileLocation", "pagePath", "basepath", "FileBase", "outputBase"], "pw": ["ppb", "cpwa", " pW", "spv", "ppw", " pwb", "psw", "pb", "ppws", "PW", "pwa", "Pw", " pwr", "cpW", "Pb", "pow", "cpw", "ppsw", " psw", "Psw", "Pws", " pb", "pws", "ppW", "cpwr", "spwb", "pW", "pwb", " pwa", "spow", " pow", "Pwa", " pws", "Pv", "ppwa", "spws", "spw", "Pwb", "Pwr", "pwr", "ppow", " pv", "Pow", "spW", "pv"], "fos": ["fops", " faos", "pOS", " fops", "fsos", "FOS", "fsaos", " fOS", "Fis", "Fos", " fis", "pops", "fsis", "pos", "Fops", "fOS", "faos", "Faos", "fsops", "fis"], "writer": ["writing", "buffer", "rw", "handler", "editor", "output", "wr", "ee", "builder", "writers", "walker", "driver", "wt", "write", "er", "wrap", "Writer", "reader", "ws", "wb", "r", "wave", "w", "store", "file", "out", "war", "wer", "director", "null", "format", "io", "worker", "fd", "angler", "riter", "wire", "wa", "xml", "writ"], "bReader": [" bWriter", "rRead", "rbRead", "bCh", " bCh", "rbReader", "bRead", "rbCh", "bResource", "bbRead", "rWriter", "bWriter", "bbWriter", "rReader", "bbReader", "BRead", "bbResource", "BResource", " bRead", "BReader", "rCh", "BWriter", " bResource", "rbWriter"], "sb": ["ssl", "usb", "sf", "bf", "wp", "sg", "lb", "lp", "lab", "cb", "obb", "kb", "si", "pb", "sm", "bg", "gb", "mb", "abb", "rb", "sa", "ab", "wb", "erb", "bps", "tmp", "src", "fb", "bb", "sq", "zb", "stab", "sth", "rob", "nb", "db", "ib", "bp", "b", "xb", "bm", "bsp", "SB"], "rLine": ["rrLin", "rUrl", "rline", " rline", "rRange", "lrLin", "rtLo", "srLine", "arWr", "srBlock", "lrRange", " rWr", "rtWr", "rLin", "srLin", "rrBlock", "rrLine", "rtLine", " rLin", "prLin", " rRange", "arline", "lrBlock", "rBlock", "rLo", " rUrl", " rLo", "srUrl", "prRange", "rWr", "arLo", "arLine", " rBlock", "rrUrl", "prLine", "lrLine", "prBlock", "rtline"], "tmp_rLine": ["tmp_rValue", "tmp_RLetter", "tmp_rFile", "tmp_lPage", "tmp_roLine", "tmp_rItem", "tmp_rLink", "tmp_prFile", "tmp_errLine", "tmp_vrline", "tmp_RLine", "tmp_rtItem", "tmp_nrBlock", "tmp_prSe", "tmp_rSe", "tmp_rBlock", "tmp_rnLink", "tmp_rbLine", "tmp_vrLine", "tmp_brFile", "tmp_errCopy", "tmp_rbBlock", "tmp_rline", "tmp_nrLine", "tmp_RSe", "tmp_brLetter", "tmp_roSe", "tmp_errLink", "tmp_roValue", "tmp_roBlock", "tmp_RValue", "tmp_lBlock", "tmp_roPage", "tmp_lLetter", "tmp_RBlock", "tmp_rbline", "tmp_lRecord", "tmp_rtLine", "tmp_prLine", "tmp_nrline", "tmp_rnCopy", "tmp_roFile", "tmp_RRecord", "tmp_RPage", "tmp_prValue", "tmp_errline", "tmp_rLetter", "tmp_rbItem", "tmp_rPage", "tmp_lFile", "tmp_rnline", "tmp_brLine", "tmp_Rline", "tmp_rtBlock", "tmp_vrCopy", "tmp_rtline", "tmp_RFile", "tmp_roRecord", "tmp_rnLine", "tmp_nrFile", "tmp_lLine", "tmp_vrLink", "tmp_rRecord", "tmp_RItem", "tmp_rCopy"], "str_len": ["dr_length", "str_ln", "stri_ler", "str5pos", "dr_ln", "str5len", "str64len", "str2ler", "str64pos", "dr_Len", "stri5ler", "dr_len", "stri5len", "stri_lin", "str2pos", "stri_pos", "stri5pos", "str_Len", "str64ler", "str2lin", "stri_len", "str2len", "str5ler", "str5lin", "str_ler", "stri5lin", "str64lin", "str_pos", "str_length", "str_lin"]}}
{"id1": "12246545", "id2": "9996334", "code1": "    public void load(String url) throws IOException {\n        this.url = url;\n        int col = url.indexOf(':');\n        if (col > 1 && col < 5) {\n            load(new URL(url).openStream());\n        } else {\n            if (new File(url).exists()) {\n                System.out.println(\"Loading JAD from file : \" + url);\n                FileInputStream fin = new FileInputStream(url);\n                try {\n                    load(fin);\n                } finally {\n                    fin.close();\n                }\n            } else {\n                InputStream in = getClass().getResourceAsStream(url);\n                if (in != null) {\n                    System.out.println(\"Loading JAD from classpath : \" + url);\n                    load(in);\n                } else {\n                    throw new IOException(\"\\\"\" + url + \"\\\" was found in file system or classpath\");\n                }\n            }\n        }\n    }\n", "code2": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "label": 0, "substitutes": {"load": ["play", "zip", "Load", "loader", "replace", "lock", "add", "loaded", "run", "set", "query", "save", "read", "loop", "use", "cache", "up", "loads", "show", "upload", "open", "build", "config", "file", "LOAD", "work", "check", "loading", "get", "init", "test", "start", "pack", "call", "link", "dump", "update", "create", "parse", "include", "process", "transform", "download", "view"], "url": ["sel", "string", "path", "address", "class", "buffer", "input", "id", "uri", "resource", "feed", "base", "course", "username", "entry", "http", "server", "filename", "html", "l", "location", "host", "URL", "lr", "fr", "el", "il", "key", "content", "fl", "dl", "email", "source", "rule", "lc", "connection", "str", "data", "file", "text", "route", "src", "ssl", "page", "ll", "log", "href", "style", "name", "coll", "job", "image", "word", "link", "sl", "rl", "layer", "Url", "pull", "www", "ur", "xml", "f", "error", "gl", "element", "service", "download", "view", "loc"], "col": ["val", "index", "sel", "max", "num", "id", "column", "year", "ind", "c", "act", "ail", "fc", "ref", "fn", "patch", "il", "line", "Col", "COL", "co", "cal", "key", "char", "offset", "flo", "fact", "lc", "cond", "ct", "cat", "row", "conn", "coll", "box", "pos", "th", "seq", "count", " COL", "ol", "con", "cur", "icol", "code", "loc"], "fin": ["close", "info", "fun", "fat", "fa", "n", "skin", "ini", "ran", "res", "rip", "fi", "fp", "run", "fn", "il", "fr", "bin", "Fin", "ret", "rt", "ori", "done", "en", "syn", "len", "data", "file", "out", "rin", "li", "fb", "focus", "keep", "init", "rec", "conn", "ris", "ann", "FIN", "kin", "fd", "ln", "pen", "fen", "lin", "br", "raf", "os", "f"], "in": ["IN", "index", "pin", "i", "input", "resource", "n", "serv", "fa", "id", "ini", "by", "on", "ind", "socket", "wrong", "o", "ins", "arin", "all", "bin", "is", "en", "part", "reader", "lib", "the", "login", "min", "not", "inside", "r", "inc", "un", "file", "out", "rin", "src", "vin", "init", "rec", "conn", "again", "m", "isin", "it", "In", "nin", "kin", "a", "between", "hel", "lin", "b", "include", "err", "inn", "win", "din", "from"]}}
{"id1": "7891509", "id2": "12744653", "code1": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"pageAddress": ["resourceUrl", "resourceLocation", "pageName", " pageLocation", " pageName", "resourceaddress", "PageName", "siteAddress", "urladdress", "siteUrl", "urlLocation", "urlUrl", "Pageaddress", "pageLocation", "pageUrl", "siteName", "siteLocation", "resourceAddress", " pageUrl", "urlAddress", "pageaddress", "PageUrl", "PageLocation", "PageAddress"], "url": ["string", "address", "base", "loader", "i", "ssl", "server", "uri", "resource", "feed", "user", "http", "socket", "l", "host", "URL", "client", "reader", "source", "browser", "connection", "r", "open", "data", "file", "out", "channel", "page", "object", "bb", "web", "plugin", "ls", "image", "sl", "Url", "this", "stream", "b", "f", "element", "service"], "in": ["IN", "impl", "ssl", "buffer", "i", "input", "resource", "id", "token", "ini", "gin", "into", "c", "inner", "socket", "as", "l", "s", "ins", "line", "bin", "read", "client", "reader", "source", "login", "min", "inside", "r", "inc", "data", "file", "out", "init", "rec", "conn", "again", "isin", "In", "kin", "nin", "stream", "b", "err", "inn", "f", "win", "din"], "inputLine": ["selectPage", "rawFile", "inputContent", " inputFile", " inputCell", " inputUrl", "pageLine", "imageFile", "imageLine", "inputUrl", "inputFile", "imageL", "pageline", "InputLine", "rawLine", " inputContent", "InputFile", "selectLine", "selectContent", "rawUrl", "pageUrl", "pageString", "inputL", " inputPage", "rawPage", "selectFile", " inputline", "InputL", "inputCell", " inputString", "imageCell", "inputline", "rawString", "InputCell", "rawContent", "inputPage", " inputL", "inputString", "rawline"]}}
{"id1": "18504192", "id2": "22479286", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "info", "base", "buffer", "i", "input", "id", "copy", "ini", "c", "inner", "ins", "bin", "part", "at", "reader", "d", "login", "min", "old", "diff", "inc", "parent", "data", "file", "src", "or", "again", "name", "m", "image", "io", "In", "url", "b", "ac", "inn"], "out": ["string", "base", "temp", "ex", "output", "n", "copy", "c", "OUT", "outs", "o", "dest", "line", "password", "client", "part", "cache", "connection", "target", "w", "inc", "data", "file", "object", "p", "conn", "name", "again", "exec", "Out", "writer", "io", "call", "prefix", "b", "obj", "err", "external", "point"], "source": ["sin", "ssl", "core", "i", "input", "self", "server", "copy", "Source", "settings", "ie", "slice", "slave", "project", "se", "dest", "origin", "ources", "clone", "SOURCE", "iter", "client", "sync", "use", "reader", "proxy", "connection", "target", "scope", "component", "parent", "channel", "src", "size", "get", "null", "start", "writer", "sl", "secure", "stream", "unit", "ource", "service", "from", "view", "storage"], "destination": ["declinated", "dependination", "contining", "declination", "testination", "testinated", " destinations", "dependinator", "declification", "destining", "continator", " destinated", "destinated", "testinator", " destinator", "Destination", "Destinated", "dependification", "Destification", "Destinator", "destification", "contination", "dependinated", "Destining", "declinator", "destinator", "testinations", "continated", "Destinations", "destinations", " destining"]}}
{"id1": "16378239", "id2": "20735941", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"byReference": ["orref", "orExternal", "toExternal", "ByExternal", "ByLink", "orLink", "ByReference", "ofLink", "ofref", "toref", "toLink", "ofReference", "toReference", "orReference", "Byref", "ofExternal"], "inputStream": ["inSteam", "InputObject", "inStream", "outputSteam", "inputSteam", "outputString", "InputReader", "inputFile", "InputString", " inputstream", "tempStream", "outputObject", "InputFile", "outputstream", "inReader", "outputStream", "inputObject", " inputObject", " inputString", "instream", "tempReader", "tempSteam", "Inputstream", "tempstream", "inputReader", "outputFile", "inputstream", "InputSteam", "inputString", "InputStream"], "tempFile": ["fakeDir", "fakeStream", " tempfile", "tmpFile", " tempFiles", "tmpfile", "TempContent", "Tempfile", "TempFile", "tempStream", "tempF", "TempFiles", "fakePage", "tmpF", " tempContent", "tempContent", " tempDir", "tempDir", "tmpStream", " tempStream", "fakeFile", "tmpFiles", "tmpDir", "tmpPage", "tempPage", "tempfile", " tempPage", "tempFiles", "fakefile", "fakeFiles", "tmpContent", " tempF", "fakeF"], "out": ["path", "base", " in", "temp", "ex", "output", "copy", "resource", "server", "user", "outer", "plain", "OUT", "result", "o", "outs", "instance", "later", "pool", "line", "write", "extra", "in", "sync", "client", "part", "source", "connection", "data", "file", "object", "null", "conn", "init", "again", "exec", "Out", "io", "writer", "image", "to", "array", "a", "flush", "ext", "url", "obj", "err", "f", "this"]}}
{"id1": "1362", "id2": "18748516", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubblesSort", "bubblerSort", "bubblerOrder", "bubblingSort", "bubblingOrder", "ubbleCompare", "ubblesort", "bubblesort", "bubblersort", "bubblingsort", "ubblingOrder", "bubblingCompare", "bubblesOrder", "ubbleSort", "ubblingsort", "bubbleOrder", "bubbleCompare", "bubblessort", "ubblingSort", "bubblerCompare", "ubbleOrder", "bubblesCompare", "ubblingCompare"], "a": ["index", "address", "something", "A", "aux", "ack", "oa", "c", "as", "ma", "o", "result", "am", "l", "all", "abs", "s", "any", "apps", "active", "aa", "alpha", "aj", "ad", "la", "an", "at", "sa", "ab", "d", "va", "ans", "au", "data", "work", "empty", "p", "ae", "u", "aw", "e", "m", "ata", "array", "another", "area", "sup", "na", "access", "aaa", "b", "ga", "tta", "ac", "ba", "ama", "f", "list", "auto", "img"], "swapped": ["rewapped", "rewoped", "rewaps", "swap", "swaped", "wapped", "swoped", "waped", "rewap", "flap", "Swoped", " swap", "swaps", "Swapping", "wapping", "swapping", " swapping", "floped", "flapping", "rewapping", "waps", " swaped", "wap", "flapped", "Swapped", " swaps", "Swaped", "Swap", "rewaped"], "i": ["index", "info", "id", "uri", "pi", "ini", "ie", "ind", "j", "fi", "ri", "l", "si", "ui", "ii", "in", "key", "ori", "next", "qi", "ti", "d", "adi", "ami", "li", "ip", "mi", "x", "p", "h", "u", "bi", "init", "ai", "oi", "start", "ci", "I", "e", "m", "io", "eni", "uni", "it", "xi", "gi", "di", "hi", "sup", "k", "ki", "v", "b", "y", "ni", "iu", "multi", "f", "mini", "anti", "iv", "module", "api", "ix"], "tmp": ["foo", "tc", "temp", "stuff", "cmp", "pre", "ie", "j", "opp", "dest", "yy", "vt", "alpha", "xxx", "txt", "part", "angle", "pp", "kk", "mp", "mmm", "qq", "amp", "append", "x", "p", "bb", "test", "m", "addr", "front", "t", "nb", "sup", "area", "tt", "v", "b", "obj", "tv", "st", "pad", " ff", "f", "prev", "emp"]}}
{"id1": "22410173", "id2": "22135199", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "source": ["path", "base", "sin", "input", "id", "resource", "copy", "Source", "ie", "site", "slice", "inner", "ins", "ources", "SOURCE", "iter", "use", "reader", "up", "connection", "target", "down", "parent", "file", "src", "route", "size", "start", "name", "internal", "image", "url", "stream", "unit", "ource", "from"], "dest": ["path", "temp", "output", "project", "later", "destroy", "done", "bin", "exit", "die", "comb", "thin", "true", "wb", "connection", "target", "dist", "down", "file", "src", "Dest", "de", "flat", "tmp", "delete", "test", "desc", "folder", "name", "home", " destination", "transfer", "this", "orig", "img"], "in": ["IN", "info", "pin", "i", "input", "id", "n", "resource", "ini", "lock", "gin", "by", "ie", "con", "c", "inner", "socket", "as", "ins", "s", "bin", "client", "reader", "up", "login", "min", "inside", "r", "inc", "work", "data", "file", "src", "init", "conn", "plugin", "again", "start", "m", "name", "image", "re", "In", "nin", "a", "pull", "url", "err", "b", "cin", "inn", "f", "win", "this", "din"], "out": ["index", "ou", "i", "temp", "ex", "output", "n", "self", "outer", "id", "timeout", "option", "net", "plain", "OUT", "socket", "c", "inner", "o", "outs", "pool", "off", "write", "bin", "extra", "password", "client", "sync", "at", "no", "lib", "up", "not", "connection", "our", "cat", "w", "inc", "data", "file", "channel", "parent", "log", "init", "conn", "again", "name", "exec", "Out", "io", "writer", "exp", "to", "call", "url", "ext", "err", "obj", "with", "vert", "this", "img"]}}
{"id1": "884867", "id2": "2642914", "code1": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"zipname": ["clipno", "zfile", "zname", "zipName", "zipno", "filename", "gzname", "projectcache", " zipfile", "zipfile", "gzName", "zipsize", "clipName", "fileName", "ziproot", "zsize", " zipName", "filefile", " zipsize", "projectname", "lockno", "zroot", "clipcache", " ziproot", "clipname", "projectName", "lockName", "fileroot", "gzsize", "projectno", "zipcache", "zName", "gzfile", "lockcache", "lockname"], "zipout": ["zipcontainer", "zfile", "zname", "zout", "zenin", "clipout", "zipgen", " zipfile", "zipfile", "copout", "copname", "clipoutput", " zipserver", " zipcache", "copin", "foldercontainer", "zipin", "clipin", "foldername", "zgen", "zserver", "zengen", "folderout", "copfile", "zipserver", "zcontainer", "zenout", "zoutput", "clipcache", " zipoutput", "zipoutput", "zin", "zcache", " zipcontainer", "zenserver", " zipgen", "zipcache", "folderin", " zipin"], "out": ["base", "plus", "output", "copy", "n", "ex", "user", "lock", "outer", "pre", "OUT", "project", "outs", "o", "window", "pool", "code", "line", "co", "query", "bin", "write", "key", "post", "raw", "client", "doc", "cache", "dot", "up", "lib", "diff", "group", "inc", "w", "parent", "file", "term", "page", "p", "log", "gen", "conn", "msg", "name", "again", "exec", "Out", "io", "image", "writer", "exp", "word", "dump", "prefix", "flush", "url", "b", "err", "obj", "print", "f", "error", "list", "point"], "buffer": ["base", "border", "Buffer", "input", "uffer", "resource", "feed", "sequence", "slice", "limit", "number", "result", "read", "queue", "offset", "iter", "source", "cache", "reader", "binary", "seed", "buff", "buf", "wave", "data", "file", "channel", "size", "bb", "null", "row", "header", "image", "array", "layer", "position", "url", "bytes", "shape", "comment", "b", "reference", "stack", "padding", "block", "transfer", "batch"], "in": ["IN", "pin", "i", "input", "id", "serv", "ex", "ini", "gin", "ic", "con", "c", "inner", "as", "l", "ins", "fr", "bin", "pass", "is", "reader", "up", "login", "diff", "r", "inc", "rin", "conn", "rec", "init", "again", "image", "re", "In", "nin", "a", "url", "lin", "b", "err", "inn", "f", "win", "din"], "length": ["index", "string", "tail", "total", "class", "core", "duration", "id", "feed", "ok", "lock", "sequence", "slice", "character", "end", "number", "present", "join", "l", "limit", "line", "key", "last", "offset", "part", "type", "angle", "load", "component", "len", "Length", "old", "ob", "section", "build", "level", "body", "append", "size", "row", "style", "view", "force", "full", "pull", "position", "url", "pe", "shape", "partial", "left", "range", "ength", "ph", "count", "width", "f", "code", "point", "loc"]}}
{"id1": "1357662", "id2": "19739421", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copyChannelTO", "copyFilesTO", " copyFileFrom", "copyfileFrom", "copyChannelFile", " copyfileFile", "copyfileTO", "copyFileTO", "copyFilesFile", "copyFileFile", " copyfileFrom", " copyFileFile", " copyFileTO", "copyFileFrom", "copyFilesFrom", " copyfileTO", "copyFilesTo", "copyfileTo", "copyChannelFrom", "copyfileFile", "copyChannelTo", " copyfileTo"], "destination": ["distination", "separinator", "configinations", " Destribution", " destribution", "separination", "configination", "Destined", " destinations", "sourceination", "distined", "separinated", " destinate", "configinated", "targetinations", " destruction", "sourceinator", "destinated", "configinator", "distruction", " destinator", "Destribution", "Destination", "distinator", "distinations", " destined", "destined", "Destinator", "targetruction", "destribution", "destinate", "destinator", "separinations", "destruction", "sourceinated", "sourceinations", "targetination", " Destinator", "Destinations", "destinations", "distinate", "targetinate", " Destination"], "srcChannel": ["sourceContext", "srcConnection", "rcchannel", "srcchannel", "sourcechannel", "sourceChannel", "destChan", " srcConnection", " srcContext", "sourceChan", "sourceConnection", "destchannel", " srcchannel", "srcContext", "rcChan", " srcChan", "rcChannel", "srcChan", "destConnection", "rcContext", "rcConnection"], "destChannel": ["srcConnection", "descButton", "srcchannel", "Destchannel", "sourcechannel", "DestConnection", "sourceChannel", "destChan", " destConnection", "descChannel", "descchannel", "DestChannel", "restchannel", "sourceChan", "sourceConnection", "destchannel", "restChannel", "restChan", " destChan", " destButton", " destchannel", "destButton", "destConnection", "srcChan", "DestChan", "srcButton"]}}
{"id1": "2808955", "id2": "19296519", "code1": "    @Override\n    public EntrySet read(EntrySet set) throws ReadFailedException {\n        if (!SourceCache.contains(url)) {\n            SSL.certify(url);\n            try {\n                super.setParser(Parser.detectParser(url.openStream()));\n                final PipedInputStream in = new PipedInputStream();\n                final PipedOutputStream forParser = new PipedOutputStream(in);\n                new Thread(new Runnable() {\n\n                    public void run() {\n                        try {\n                            OutputStream out = SourceCache.startCaching(url);\n                            InputStream is = url.openStream();\n                            byte[] buffer = new byte[100000];\n                            while (true) {\n                                int amountRead = is.read(buffer);\n                                if (amountRead == -1) {\n                                    break;\n                                }\n                                forParser.write(buffer, 0, amountRead);\n                                out.write(buffer, 0, amountRead);\n                            }\n                            forParser.close();\n                            out.close();\n                            SourceCache.finish(url);\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }).start();\n                super.setIos(in);\n            } catch (Exception e) {\n                throw new ReadFailedException(e);\n            }\n            return super.read(set);\n        } else {\n            try {\n                return SourceCache.get(url).read(set);\n            } catch (IOException e) {\n                throw new ReadFailedException(e);\n            }\n        }\n    }\n", "code2": "        private long getSize(String url) throws ClientProtocolException, IOException {\n            url = normalizeUrl(url);\n            Log.i(LOG_TAG, \"Head \" + url);\n            HttpHead httpGet = new HttpHead(url);\n            HttpResponse response = mHttpClient.execute(httpGet);\n            if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {\n                throw new IOException(\"Unexpected Http status code \" + response.getStatusLine().getStatusCode());\n            }\n            Header[] clHeaders = response.getHeaders(\"Content-Length\");\n            if (clHeaders.length > 0) {\n                Header header = clHeaders[0];\n                return Long.parseLong(header.getValue());\n            }\n            return -1;\n        }\n", "label": 0, "substitutes": {"read": ["play", "index", "close", "ry", "input", "Read", "feed", "copy", "resource", "reading", "add", "http", "ic", "current", "socket", "find", "run", "weak", "write", "reads", "query", "iter", "content", "next", "select", "reader", "load", "build", "open", "work", "data", "check", "request", "get", "search", "es", "fill", "start", "exec", "send", "skip", "readable", "ping", "update", "stream", "create", "parse", "wait", "print", "process", "scan", "READ", "block", "view"], "set": ["ssl", "base", "server", "id", "setup", "resource", "reset", "spec", "entry", "settings", "site", "et", "end", "sync", "type", "source", "load", "session", "use", "seed", "cache", "rule", "ut", "store", "config", "src", "object", "size", "get", "context", "init", "or", "test", "name", "start", "SET", "sets", "send", "url", "update", "parse", "state", "setting"], "in": ["IN", "pin", "ssl", "i", "input", "id", "resource", "ini", "gin", "on", "ic", "con", "socket", "inner", "ins", "bin", "client", "reader", "cache", "source", "login", "min", "inc", "data", "file", "src", "p", "init", "again", "io", "image", "it", "In", "spin", "pull", "url", "inn", "f", "win"], "forParser": ["forReader", "ofListener", "foreMaster", "forMaster", "ofReader", "ForFile", "withparser", "ForMaster", "ForJar", "ForParser", "forparser", "ofParser", "Forparser", " forJar", " forReader", "foreReader", "ForReader", "withJar", " forListener", " forMaster", "forListener", "withParser", " forparser", " forFile", "ofJar", "foreParser", "foreparser", "ForListener", "forJar", "withFile", "forFile"], "out": ["ssl", "i", "outer", "output", "copy", "ex", "http", "net", "OUT", "socket", "inner", "outs", "o", "co", "bin", "sync", "client", "source", "cache", "up", "inc", "parent", "file", "page", "log", "null", "init", "conn", "again", "exec", "Out", "writer", "io", "image", "to", "url", "app", "ext", "can", "err", "os", "cli"], "is": ["bis", "sin", "i", "iss", "lis", "id", "fs", "IS", "isa", "Is", "as", "ri", "ins", "bs", "s", "does", "ois", "ui", "isl", "its", "ais", "ir", "ip", "has", "or", "ai", "vs", "ris", "ci", "isin", "iris", "ios", "us", "ib", "url", "isi", "are", "os", "ps", "was", "im", "api"], "buffer": ["info", "base", "address", "Buffer", "border", "uffer", "feed", "server", "uri", "sequence", "slice", "slave", "limit", "length", "bin", "memory", "queue", "offset", "iter", "reader", "cache", "source", "binary", "seed", "buff", "delay", "buf", "counter", "data", "channel", "page", "size", "null", "layer", "bytes", "url", "reference", "repeat", "count", "padding", "transfer", "batch", "phrase"], "amountRead": ["amountReader", "weightBuild", "amountLoad", "lengthLoad", " numberWrite", "enoughRead", "enoughStart", "AmountWrite", "weightLoad", "AmountRead", "poolReader", " amountBuild", "numberLoad", "amountHandle", "lengthRead", "numberReader", "numberWrite", "AmountLoad", "poolWrite", "AmountBuild", " amountStart", " numberLoad", " numberHandle", "amountStart", " numberRead", "lengthHandle", " amountWrite", "lengthWrite", "enoughReader", " amountLoad", "weightRead", "weightReader", "poolLoad", "AmountReader", "enoughWrite", "numberRead", "poolRead", "amountBuild", "amountWrite", " amountReader", "AmountHandle", "AmountStart"]}}
{"id1": "16550855", "id2": "11704429", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    public void run() {\n        RandomAccessFile file = null;\n        InputStream stream = null;\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=\" + downloaded + \"-\");\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                error();\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                error();\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            }\n            file = new RandomAccessFile(destination, \"rw\");\n            file.seek(downloaded);\n            stream = connection.getInputStream();\n            while (status == DOWNLOADING) {\n                byte buffer[];\n                if (size - downloaded > MAX_BUFFER_SIZE) {\n                    buffer = new byte[MAX_BUFFER_SIZE];\n                } else {\n                    buffer = new byte[size - downloaded];\n                }\n                int read = stream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                status = COMPLETE;\n                stateChanged();\n            }\n        } catch (Exception e) {\n            error();\n        } finally {\n            if (file != null) {\n                try {\n                    file.close();\n                } catch (Exception e) {\n                }\n            }\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"readPage": ["readPages", "openpage", "readFile", "openPages", "getFile", "findPage", "getPages", "getPage", "readpage", "findPages", "openFile", "getpage", "findFile", "openPage", "findpage"], "ignoreComments": ["useComments", "includeTags", "includeComments", " ignoreTags", "oreComment", "ignorecomments", "orecomments", "ignoreComment", "oreQuotes", "useTags", " ignoreComment", "useQuotes", "ignoreQuotes", "usecomments", "includeComment", "oreComments", " ignorecomments", "oreTags", "includecomments", " ignoreQuotes", "ignoreTags"], "in": ["IN", "index", "ssl", "buffer", "i", "input", "id", "token", "loader", "user", "ini", "gin", "on", "http", "into", "con", "c", "inner", "socket", "version", "as", "ins", "s", "bin", "is", "client", "reader", "source", "login", "connection", "min", "inside", "r", "inc", "data", "file", "out", "h", "init", "rec", "again", "e", "m", "image", "t", "re", "isin", "it", "In", "nin", "kin", "url", "stream", "lin", "b", "err", "inn", "f", "win", "din"], "inputLine": ["InputText", "incLook", "incL", "InputLook", "requestRow", "inputName", "requestline", "pullLine", "installline", "inputRow", " inputRow", "requestLink", " inputCell", "incLine", "ifLook", "ifline", "InputName", "pullline", "installLook", "imageLine", " inputText", " inputLook", "imageL", "InputLine", "rawLine", "Inputline", "pullLink", "requestLine", "InputLink", "incline", "rawL", "ifLine", " inputName", "ifCo", " inputCo", "inputL", " inputPage", "imageline", "commentline", " inputline", "rawName", "requestLook", "installL", "pullRow", "InputL", "inputCo", "commentLine", "inputCell", "inputText", "inputline", "rawLink", "InputCell", "requestCo", "inputPage", "rawText", "inputLook", " inputL", "commentCell", " inputLink", "installLine", "imageLook", "inputLink", "rawline", "InputPage", "commentPage"], "html": ["article", "base", "temp", "css", "HTML", "output", "bf", "atom", "embed", "gh", "http", "message", "json", "plain", "ht", "result", "hot", "ui", "detail", "strong", "high", "htm", "content", "part", "wrap", "links", "doc", "tml", "source", "live", "show", "str", "data", "attr", "body", "flat", "amp", "war", "web", "h", "page", "flash", "inline", "format", "msg", "title", "template", "rss", "header", "js", "text", "home", "blog", "link", "details", "dump", "url", "tt", "www", "summary", "xml", "tf", "bsp", "f", "hard", "api", "view", "img"]}}
{"id1": "8430178", "id2": "293167", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyPath", " copyfile", "CopyFile", "copyfile", "transferfile", "transferFiles", "transferPath", " copyFiles", "CopyPath", "Copyfile", "copyPath", "CopyFiles", "copyFiles", "transferFile"], "source_name": ["src_file", "source_type", "Source_file", "sourceNalias", "src_type", "sourceCname", "src_size", "source_data", "source_uri", " source_path", "sourceNtype", "sourceCalias", "source_size", " source_Name", "source_Name", "source_key", " source_key", "src_uri", " source_names", "source_names", "sourceCtype", "sourceCfile", "source_alias", "source_path", "sourceNfile", "src_name", "sourceNname", "Source_data", "src_alias", "Source_name"], "dest_name": ["destFpath", "destappnames", "destFilefile", " destination_name", "destPmodel", "Dest_name", " destinationFpath", "dest_model", "destappmodel", "destPName", " destinationFname", "target_type", "destFname", "destPpath", "Dest_id", "destRname", "dest_path", "dest_named", "dest_none", " dest_none", "destapptype", "dest_id", " destination_path", "dest_resource", "destPtype", " dest_names", "destJName", "dest_info", "destappname", "destFilelabel", " dest_Name", " dest_type", "dest_Name", "destFresource", "Dest_path", "dest_names", "destRName", "destRpath", "source_Name", "target_names", "dest_word", "destRdefinition", "destFilenamed", " destination_info", "destPnames", "dest_type", "destJword", "source_names", "source_path", " dest_word", "destffile", " destinationFresource", "destfname", " dest_definition", " dest_path", "destFilename", "destFinfo", "destPname", " destination_resource", "destfnamed", "target_name", "dest_file", "destPword", " dest_label", "destJnames", "dest_definition", "Dest_Name", "target_model", " destinationFinfo", "destJname", " dest_named", "dest_label", "destflabel", " dest_file"], "source_file": ["src_file", "source_File", " source_class", "src_stream", "source__file", "ource_file", " source_base", "ource_line", "ource_files", " source_url", "source_base", "sourceffile", "ource_name", "sourcefname", "source__class", "source_cache", " source_cache", " source_File", "source__name", "source_class", "src_files", " source_files", "source_files", "sourcefFile", "sourcefurl", "src_name", "source__base", "source_url", "source_line", "source_stream"], "destination_file": ["destation_folder", "destination4path", "destination_base", "destinationablefiles", "destinate_page", "destination2path", "destination_path", "destination_function", "destination2file", "destination2source", "destention4name", "destation_file", "destention_name", "destination_folder", "destinationablepage", "destention_path", "destention4path", "destation_name", "destination2name", "destination4name", "destination4file", "destination_files", "destinate_file", "destention4file", "destention_source", "destention_file", "destation_files", "destinationablebase", "destination_source", "destinationablefile", "destention4source", "destinate_base", "destination4source", "destation_function", "destination_name", "destination_page", "destinate_files"], "source": ["ite", "index", "remote", "class", "core", "input", "server", "resource", "uri", "copy", "output", "Source", "spec", "master", "resources", "site", "slave", "current", "inner", "result", "dest", "slice", "ources", "via", "SOURCE", "client", "reader", "cache", "load", "proxy", "connection", "target", "diff", "scope", "open", "parent", "config", "file", "src", "local", "object", "get", "search", "view", "name", "start", "image", "secure", "stream", "unit", "ize", "reference", "ource", "service", "from", "single", "storage"], "destination": ["Destina", "testribution", "dependination", "coordension", "coordination", "descinated", "targetinator", "identribution", " destribution", "descination", " destining", "testination", "testinated", "dependinator", "constination", "Destension", "destining", "destension", "coordinated", "variinated", "constribution", "validinated", "identination", "targetinated", " destinated", "constinator", "destinated", "variinate", " destinator", "Destribution", "Destination", "Destinated", " destina", "foreigninator", "testinator", "descinator", "Destinator", "destina", "identina", "variinator", "validination", "dependinated", "validinate", "destinate", "destinator", "foreigninate", "destribution", "Destining", "descension", "targetination", "foreigninated", "coordinator", "identinated", "constining", "foreignination", "variination", "targetinate", "validinator", "dependinate"], "buffer": ["temp", "Buffer", "input", "uffer", "timeout", "sequence", "limit", "window", "pool", "memory", "bin", "queue", "iter", "reader", "cache", "binary", "buff", "buf", "channel", "text", "header", "image", "writer", "flush", "padding", "block", "transfer", "batch"], "bytes_read": ["bytesUnRead", "bytes_Read", "bytesUnset", "Bytes_read", "bytesUnfound", "Bytes_set", "bytesUnread", "Bytes_found", "bytes_set", "Bytes_Read", "bytes_found"], "in": ["IN", "val", "path", "ssl", "input", "fe", "n", "serv", "temp", "resource", "id", "ini", "lock", "token", "con", "inner", "as", "current", "l", "s", "ins", "line", "bin", "is", "read", "session", "reader", "doc", "connection", "login", "min", "r", "inc", "data", "file", "out", "h", "request", "p", "log", "get", "rec", "or", "again", "image", "re", "In", "nin", "a", "url", "stream", "b", "container", "inn", "f", "din"], "response": ["reason", "string", "respons", "server", "output", "uri", "resource", "feed", "reset", "res", "report", "message", "description", "json", "sequence", "onse", "version", "result", "answer", "location", "line", "su", "next", "true", "resp", "value", "model", "r", "application", "data", "text", "body", "object", "request", "offer", "reply", "example", "header", "dict", "status", "image", "success", "received", "update", "Response", "respond", "question", "error", "re", "api", "view"], "parentdir": ["parentdirectory", "parentdiff", "rootlib", "Parentdirectory", "hostdir", "parentlib", "homediff", "hostdirectory", "homefile", "homedir", "parentsfile", " parentDir", "parentsDir", "rootdir", " parentlib", " parentdict", "rootdirectory", "Parentdict", "hostdict", " parentdiff", "Parentdir", "rootfile", "parentfile", "parentDir", "parentsdiff", "homeDir", "partdirectory", "partlib", "parentdict", "parentsdir", "partdir", " parentfile", " parentdirectory", "partfile"]}}
{"id1": "3401153", "id2": "10547671", "code1": "    private String getHTML(String pageURL, String encoding, String dirPath) throws IOException {\n        StringBuilder pageHTML = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(pageURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"MSIE 7.0\");\n            connection.connect();\n            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), encoding));\n            String line = null;\n            while ((line = br.readLine()) != null) {\n                pageHTML.append(line);\n                pageHTML.append(\"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            connection.disconnect();\n        }\n        if (dirPath != null) {\n            File file = new File(dirPath);\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file));\n            bufferedWriter.write(pageHTML.toString());\n            bufferedWriter.close();\n        }\n        return pageHTML.toString();\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 1, "substitutes": {"getHTML": ["updateHTML", "loadJSON", "createHTML", "createJSON", "loadPage", "getJSON", "getURL", "loadURL", "updateJSON", "updateURL", "updatePage", "getPage", "createPage", "loadHTML", "createURL"], "pageURL": ["baseURL", "baseUrl", "Pageurl", " pageurl", " pageURI", "pageURI", "basePath", "PageURL", "PagePath", "pageUrl", "badurl", "badURL", "badUrl", " pageUrl", "pageurl", "PageURI", "PageUrl", "pagePath", "baseURI", " pagePath", "badURI"], "encoding": ["encension", "decoder", "Encoded", "Encoder", "encaging", "caging", "decasing", "coding", "enaging", "contoder", "decoding", "enasing", "Encoding", "contoding", "casing", "Encaging", "coded", "enoded", "enoding", "Encasing", "contension", "encoder", "decension", "contasing", "encasing", "encoded", "Encension"], "dirPath": ["zipPath", "zippath", "buildPath", "DirPath", "buildFile", "directoryLocation", "dirDir", "zipPoint", "dirLocation", "folderPath", " dirDir", "DirFile", "folderpath", "dirPoint", "Dirpath", "directoryPath", "directorypath", "dirpath", "dirFile", "folderFile", "DirLocation", "directoryPoint", " dirLocation", " dirpath", "DirDir", "directoryDir", "DirLog", "directoryFile", "directoryLog", "zipFile", "dirLog", "folderPoint", "buildLog"], "pageHTML": ["pageHTTP", "sectionURL", " pageHTTP", "siteURL", "pagehtml", "codeHTML", "rowHTML", "resultHTML", " pagehtml", " pageURI", "pageURI", "PageURL", "resulthtml", "PageHTML", "codeWriter", "siteHTML", "siteURI", "PageJSON", "siteUrl", "pageBody", "codehtml", "pageUrl", "rowhtml", "codeUrl", "resultWriter", " pageJSON", "resultURL", "PageHTTP", "pageJSON", "resultJSON", " pageUrl", "Pagehtml", "PageBody", "pageWriter", " pageBody", "sectionBody", "PageURI", "resultUrl", "sectionHTML", "rowJSON", "rowURL", "PageUrl", " pageWriter", "sectionHTTP"], "connection": ["directory", "Connection", "string", "handler", "server", "uri", "response", "resource", "user", "builder", "timeout", "http", "character", "con", "c", "socket", "connected", "number", "o", "cb", "pool", "relation", "manager", "database", "condition", "password", "union", "client", "session", "reader", "cache", "uc", "proxy", "ion", "application", "collection", "section", "config", "bec", "text", "body", "open", "org", "director", "channel", "log", "context", "conn", "or", "ci", "io", "function", "db", "ctx", "position", "bc", "b", "connect", "wrapper", "communication", "loc"], "url": ["Connection", "string", "path", "address", "base", "ssl", "server", "uri", "feed", "user", "builder", "http", "l", "location", "URL", "client", "browser", "build", "channel", "page", "web", "log", "conn", "coll", "image", "function", "link", "sl", "Url", "update", "stream", "connect", "contact", "f", "plug", "loc"], "br": ["bh", "bridge", "result", "cb", "lr", "fr", "dr", "keeper", "mr", "ori", "bro", "ler", "arr", "BR", "rb", "reader", "pr", "ctr", "ocr", "buf", "ner", "sr", "r", "ch", "Br", "str", "ob", "src", "body", " reader", "io", "cr", "cro", "tr", "bc", "stream", "hr", "b", "bl", "err", "Reader"], "line": ["letter", "string", "base", "lf", "response", "column", "entry", "message", "character", "c", "ge", "LINE", "end", "l", "el", "pass", "ine", "char", "key", "sync", "lines", "lc", "up", "r", "str", "data", "text", "li", "cl", "page", "object", "le", "inline", "row", "style", "name", "frame", "word", "link", "sl", "pe", "unit", "comment", "Line", "lin", "b", "block", "code", "cell"], "e": ["ise", "fe", "i", "ace", "ee", "be", "ie", "ue", "c", "se", "o", "te", "ception", "en", "die", "ec", "er", "type", "one", "ce", "je", "r", "ea", "exc", "x", "p", "es", "ae", "or", "E", "force", "ze", "ev", "pe", "ve", "err", "f", "error", "oe", "Exception", "esi", "re"], "file": ["zip", "path", "base", "buffer", "handler", "output", "feed", "ile", "resource", "lock", "http", "filename", "per", "socket", "result", "fp", "l", "File", "angle", "reader", "source", "dir", "book", "FILE", "data", "body", "page", "h", "le", "log", "null", "name", "folder", "io", "writer", "db", "files", "pe", "b", "f"], "bufferedWriter": ["buffilledWriter", "ufaredWriting", "uferedWriter", "buffaredWriting", "bufferedFile", "BuffererWriter", "buffererReader", "BufferedWriter", "buffedWriting", "bufferingFile", "uferedWriting", "BufferedWrite", "BuffererFile", "BuffererWrite", "bufferedWrite", "ufaredwriter", " bufferingW", "buffinedReader", "BufferedFile", " bufferingFile", "buffenedWriter", "bufferedWriting", "buffererWrite", "buffererFile", " bufferedW", "buffilledWriting", "buffererWriter", "buffenedW", "buffaredwriter", " bufferingReader", "buffinedWriter", "BufferedReader", "buffedWriter", "buffaredWriter", "bufferedReader", " bufferingWriter", "ufaredWriter", "buffilledwriter", "bufferingReader", "buffinedFile", "uferedwriter", "buffenedFile", "buffenedReader", "BuffererReader", "bufferedW", "bufferingWrite", " bufferedReader", " bufferedFile", "bufferedwriter", "buffedwriter", "buffinedWrite", "bufferingWriter", "bufferingW", "buffererW"]}}
{"id1": "20247400", "id2": "310182", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"in": ["IN", "i", "input", "n", "token", "gin", "con", "c", "socket", "inner", "l", "ins", "s", "bin", "pass", "client", "part", "reader", "source", "login", "diff", "connection", "r", "inc", "config", "data", "parent", "h", "p", "again", "image", "isin", "In", "nin", "a", "stream", "b", "inn", "f", "win", "this", "din"], "out": ["i", "console", "ex", "output", "sys", "server", "temp", "user", "lock", "outer", "OUT", "socket", "inner", "o", "window", "pool", "write", "line", "flow", "off", "client", "source", "cache", "up", "connection", "debug", "str", "group", "r", "inc", "w", "file", "channel", "page", "log", "style", "conn", "msg", "name", "again", "exec", "Out", "io", "image", "writer", "exp", "word", "dump", "prefix", "call", "ext", "comment", "err", "obj", "v", "print", "error", "list"], "buffer": ["border", "base", "Buffer", "input", "output", "uffer", "server", "feed", "loader", "document", "slave", "slice", "limit", "result", "window", "length", "flow", "bin", "read", "queue", "offset", "iter", "bar", "reader", "cache", "binary", "source", "buff", "buf", "wave", "config", "data", "channel", "batch", "fb", "pause", "size", "null", "context", "header", "writer", "layer", "flush", "b", "reference", "abi", "count", "pad", "f", "transfer"]}}
{"id1": "16760971", "id2": "18005010", "code1": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private void setProfile(String loginName, SimpleUserProfile profile) throws MM4UCannotStoreUserProfileException {\n        try {\n            OutputStream outStream = null;\n            URL url = new URL(this.profileURI + profile.getID() + FILE_SUFFIX);\n            if (url.getProtocol().equals(\"file\")) {\n                File file = new File(url.getFile());\n                outStream = new FileOutputStream(file);\n            } else {\n                URLConnection connection = url.openConnection();\n                connection.setDoOutput(true);\n                outStream = connection.getOutputStream();\n            }\n            OutputStreamWriter writer = new OutputStreamWriter(outStream);\n            Enumeration myEnum = profile.keys();\n            while (myEnum.hasMoreElements()) {\n                String key = myEnum.nextElement().toString();\n                if (key != \"id\") writer.write(key + \"=\" + profile.getStringValue(key) + System.getProperty(\"line.separator\"));\n            }\n            writer.flush();\n            writer.close();\n        } catch (Exception e) {\n            throw new MM4UCannotStoreUserProfileException(this, \"setProfile\", e.toString());\n        }\n    }\n", "label": 0, "substitutes": {"generateHash": ["generateKey", "generatedMac", " GeneratedSalt", "generateMac", "generateSalt", "generatedSalt", "generoseMac", "generatedHash", "generatesMac", " GeneratedKey", " GenerateHash", " GenerateSalt", "generatesHash", "generatedKey", " GenerateMac", "generatesSalt", "generatesKey", " GeneratedHash", " GeneratedMac", "generoseSalt", " GenerateKey", "generoseKey", "generoseHash"], "key": ["keys", "path", "string", "address", "fee", "base", "ace", "id", "self", "token", "user", "proof", "message", "hex", "char", "password", "type", "rule", "mac", "ce", "seed", "date", "connection", "KEY", "str", "cy", "work", "data", "file", "Key", "text", "body", "msg", "name", "word", "full", "prefix", "url", "k", "pe", "secret", "pair", "point", "sign", "block", "crypt", "cert", "hash", "code", "trust"], "md": ["editor", "mem", "mag", "df", "bd", "od", "Cmd", "amd", "clean", "mail", "message", "mo", "ma", "am", "dr", "wd", "MD", "dc", " MD", "ms", "sm", "ld", "ad", "rpm", "cm", "mage", "mt", "mb", "d", "mac", "dh", "mp", "hd", "pm", "pd", "mm", "nd", "metadata", "cd", " Md", "dig", "po", "m", "hm", "dm", "mand", "mc", "nm", "di", "mod", "me", "ds", "bm", "rm", "mg", "mad", "cmd", "dd", "hash"], "bytes": ["keys", "zip", "bis", "bles", "pages", "pieces", "les", "outs", "s", "bs", "errors", " bits", "parts", "gb", "items", "lines", "binary", "blocks", "bps", "ops", "strings", "data", "vals", "objects", "fb", "ips", "es", "Bytes", "ls", "vs", "ones", "seconds", "cells", "rows", "files", "values", "pins", "b", "words", "os", "bits", "codes", "boot", "letters"], "buff": ["uff", "buffer", "bis", "Buffer", "bf", "bd", "eb", "py", "cb", "html", "obb", "bo", "fw", "kb", "ff", "pb", "cpp", "uf", "txt", "bag", "gb", "mb", "abb", "cp", "sb", "pp", "buf", "diff", "ob", "amp", "flat", "tmp", "fb", "cast", "append", "bb", "agg", "nb", "ctx", "hack", "Buff", "app", "tt", "bug", "b", "ph", "bm", "tf", "f", "batch", "fx"], "l": ["i", "lu", "n", "kl", "lb", "lp", "c", "j", "z", "o", "col", "il", "length", "ly", "jl", "el", "pl", "dl", "fl", "la", "d", "lc", "ell", "li", "al", " L", "cl", "h", "p", "ll", "x", "u", "nl", "le", "ls", "e", "t", "sl", "rl", "ln", "v", "b", "bl", "ul", "lv", "ol", "f", "L"], "hx": ["hmx", "hmxa", "dhc", "Hy", " hrx", " hy", "hex", "Hwx", "Hex", "Hrx", " hxa", "hsxc", "hxa", " hxs", " hc", "dhex", "hwx", "hsrx", "hxc", "hmy", "hxs", "Hc", " hxc", "dhxc", "hsx", " hwx", "hmxs", "Hxa", "hc", " hex", "hy", "hswx", "Hx", "dhx", "Hxc", "hrx", "Hxs"]}}
{"id1": "8087001", "id2": "13414771", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"generateStackHashKey": ["generateStackHashString", "generatestackHashkey", "generatestackhashKeys", "generateStackhashkey", "generatestackHashString", "generateStackHashKeys", "generatestackhashString", "generateStackhashKey", "generateStackHeaderKeys", "generateStackHashkey", "generatestackHashKey", "generatestackHashKeys", "generateStackhashKeys", "generateStackHeaderKey", "generateStackHeaderkey", "generatestackhashKey", "generateStackhashString", "generateStackHeaderString", "generatestackhashkey"], "e": ["event", "fe", "ace", "ex", "ee", "n", "est", "element", "ie", "c", "et", "o", "se", "el", "ception", "ele", "en", "ec", "er", "d", "r", "he", "ea", "body", "exc", "h", "x", "p", "es", "ae", "ef", "E", "m", "t", "ze", "exec", "a", "ev", "ed", "pe", "me", "err", "b", "f", "error", "oe", "Exception", "this", "enter", "esi"], "digest": ["Digester", "digher", "Diger", "decature", " Digested", " digator", " Digester", "Signature", "mdature", " digested", "digge", " diger", "decest", " digusher", "mdusher", "logester", "Signate", "mdest", "mdested", "logge", " digenge", " digge", "digester", " Digator", "mdate", " Digest", "digested", "mdester", "Digher", "Digge", "Digenge", "logher", "decester", "Digest", " digher", "digator", "mdenge", "Signest", "Digusher", "Signester", "digusher", "decate", "diger", "digate", "Digator", "digenge", "mder", " digester", "Digested", "logest", "digature"], "hash": ["string", "total", "base", "sum", "her", "bh", "ashes", "message", "kh", "hex", "Hash", "result", "ash", "key", "rh", "mac", "dot", "sha", "value", "build", "data", "text", "body", "h", "dig", "header", "image", "hed", "array", "ha", "sh", "v", "b", "ph", "history", "f", "code"], "rtn": ["RTnin", "RTnn", "rtN", "txn", "ortN", "rtnin", "rtns", "txnin", "rdb", "rtpn", "rtb", "vrns", "rdN", "ortn", "retn", "vrnn", "RTn", "ntn", "latne", "RTne", "vrN", "ntc", "latN", "rdn", "gtn", "rtnn", "latn", "ntN", "latns", "rtne", "ortnn", "vrn", "ntb", "RTns", "vrne", "gtb", "rtc", "RTc", "txc", "retb", "ntnin", "RTb", "ortne", "ntpn", "RTN", "gtN", "gtpn", "RTpn", "txN", "rdns", "retN", "retns"]}}
{"id1": "19147281", "id2": "16621503", "code1": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public static ArrayList<String> loadURLToStrings(URL url, int maxLines, String userAgent, int timeout) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (userAgent != null && userAgent.trim().length() > 0) {\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n        } else {\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (compatible; astrominer/1.0;)\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n        }\n        connection.connect();\n        return loadURLToStrings(connection, maxLines);\n    }\n", "label": 0, "substitutes": {"actualizarDatosPrevia": [" actualizarDatdosPrefil", " actualizarDatosCalvia", " actualizarDatos_via", " actualizarDatosRfil", " actualizarDatosCalregular", " actualizarDatos_regular", " actualizarDatosRpar", " actualizarDatos_fil", " actualizarDatosRregular", " actualizarDatdosPrepar", " actualizarDatosPreregular", " actualizarDatdosCalregular", " actualizarDatosCalpar", " actualizarDatos_par", " actualizarDatdosCalpar", " actualizarDatosPrefil", " actualizarDatdosPrevia", " actualizarDatdosCalfil", " actualizarDatosPrepar", " actualizarDatosCalfil", " actualizarDatosRvia", " actualizarDatdosCalvia", " actualizarDatdosPreregular"], "idJugadorDiv": ["idJugadorDec", "idJugadeDiv", "idJuggadorDiv", "idJuggardodiv", "idJugardodiv", "idJuggardoDiv", "idJugadorDIV", "idJuggadorDec", "idJugadorCode", "idJugbertoDIV", "idJuggrarCode", "idJugadediv", "idJuggadordiv", "idJugrarRev", "idJugrarDiv", "idJugbertodiv", "idJuggadorCode", "idJugrarDIV", "idJugardoDIV", "idJugadeDIV", "idJugoderCode", "idJugbertoDec", "idJugardoDiv", "idJuggadorDIV", "idJugadorRev", "idJugadordiv", "idJugoderRev", "idJuggrarDIV", "idJuggrarDiv", "idJuggrarRev", "idJugaderCode", "idJugaderDIV", "idJugrarCode", "idJugaderRev", "idJuggadorRev", "idJugoderDIV", "idJugbertoDiv", "idJuggardoDIV", "idJugadeDec", "idJuggardoDec", "idJugaderDiv", "idJugardoDec", "idJugoderDiv"], "idRonda": ["idRhora", "idTrola", "idBrona", "IdRonda", "idRaba", "idRhaba", "idTrarta", "IdRora", "idsRhonda", "idRhola", "IdRharta", "idTronda", "idRhonda", "idRora", "idsRhaba", "idsRharta", "IdRhonda", "idsRonda", "idTrora", "idronda", "IdRola", "idRona", "idrarta", "idBrarta", "IdRhola", "idraba", "idrona", "idsRaba", "idBronda", "idsRona", "IdRhora", "idsRhona", "idsRarta", "idRola", "idRarta", "idBraba", "idRhona", "IdRarta", "idRharta"], "idPareoRival": ["idPareosRiv", "idPareosRoval", "idPareoRaval", "idPareoLivalent", "idPareoRhive", "idPareoroval", "idPareoRaiv", "idParelloBrival", "idPareoRRiv", "idPareosRaival", "idPareosRaiv", "idPareosRaval", "idPareoRhoval", "idPareoRaaval", "idPareioRiv", "idPareoRiv", "idPareoRive", "idPareioRival", "idPareoRhaval", "idPareoBroval", "idParelloRiv", "idPareoRoval", "idParelloBrive", "idPareosRaoval", "idPareoBrivalent", "idPareoriv", "idPareoLiv", "idParelloRival", "idPareoBrival", "idPareorival", "idPareioRive", "idPareioBrive", "idPareioBrivalent", "idPareosRival", "idPareoraval", "idPareoRaival", "idPareioBrival", "idPareoRivalent", "idPareoRRive", "idPareosRaaval", "idPareoRRival", "idPareoRhiv", "idPareoLival", "idPareoBrive", "idPareoRhival", "idPareioRivalent", "idPareoRRoval", "idPareoLive", "idParelloRive", "idPareoRaoval", "idPareioBriv", "idPareoBriv", "idParelloBriv", "idParelloRoval", "idParelloBroval"], "color": ["index", "Color", "border", "pal", "colored", "uri", "resource", "id", "token", "author", "power", "number", "col", "stroke", "length", "ori", "key", "olor", "white", "alpha", "bg", "orange", "type", "source", "date", "opal", "silver", "our", "level", "background", "size", "style", "fill", "COLOR", "or", "name", "blue", "theme", "yellow", "position", "url", "shape", "comment", "black", "shadow", "colour", "gray", "green", "red", "state", "count", "winner", "depth"], "flotante": [" flottanto", "flontante", "flrotantes", "flowante", " flOTance", "floyaque", " flotaque", " flOTaque", " flotanto", "FLottaser", "floyator", "flottant", "flOTance", "flotantes", "flottante", "FLottantine", "flotaque", "flotance", " flottant", "flottaser", "flrotant", "flrotante", "floteraser", "flowance", "FLotator", "floterator", "flotator", "flotaser", "florant", "flontantine", "FLottante", "flrotanto", "flontaser", "flottator", "FLotaser", "flOTante", "florante", "flowator", " flottantes", " flotance", "floyance", "flottantes", "flowaque", "flOTaque", " flOTator", "flotanto", "flottantine", "flontator", " flotant", "flOTator", "FLotantine", "floterantine", " flotantes", "floterante", " flOTante", "flotant", " flottante", "florantes", "floyante", " flotator", "FLottator", "floranto", "FLotante", "flottanto", "flotantine"], "intResult": ["floatError", "IntGr", "INTGr", "intGr", "intError", "INTReturn", "ntResponse", "retResponse", " intResponse", "IntResponse", "INTResult", " intSuccess", "INTResponse", "INTSuccess", "intSuccess", "IntSuccess", "IntReturn", "intRes", "INTRes", " intRes", "IntRes", "floatRes", "floatResult", "retError", "ntError", "intReturn", "ntResult", "retRes", "floatResponse", "ntRes", "retResult", "IntResult", "intResponse", " intReturn", " intGr"], "sql": ["zip", "string", "ssl", "job", "json", "socket", "limit", "fn", " SQL", "shell", "query", "database", "dl", "params", "select", "sync", "expression", "mt", "pr", "sb", "str", "eps", "ql", "section", "log", "sq", "conn", "ls", "db", "sl", "QL", "url", "plan", "SQL", "printf", "xml", "statement", "cmd", "dd", "pg"], "connection": ["Connection", "index", "handler", "server", "character", "con", "c", "connected", "socket", "table", "document", "jc", "pool", "relation", "manager", "database", "dc", "condition", "client", "session", "reader", "lc", "proxy", "ion", "application", "collection", "section", "config", "environment", "log", "context", "conn", "writer", "function", "db", "mc", "ctx", "position", "bc", "BC", "connect", "container", "statement", "communication", "loc"], "ps": ["pps", "pi", "pse", "Ps", "ns", "ks", "posts", "qs", "bs", "ins", "pl", "ms", "hs", "pb", "rs", "changes", "syn", "cp", "pr", "pp", "proxy", "mp", "pers", "ops", "par", "eps", "ups", "gs", "ips", "p", "conn", "po", "ls", "pos", "pc", "ping", "jp", "relations", "pe", "pa", "sp", "cs", "ds", "os", "pt", "ppa", "pd", "pg", "PS"]}}
{"id1": "19687456", "id2": "8788371", "code1": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testReadPerMemberSixSmall": [" testReadPerMemberFourSquare", " testReadPermembersixsmall", " testReadPermembersixSquare", " testReadPermemberSixSmall", " testReadPerMemberFoursmall", " testReadPerMembersixsmall", " testReadPerMemberFourSmall", " testReadPermemberSixsmall", " testReadPerMemberSixsmall", " testReadPerMembersixSmall", " testReadPerMemberSixSquare", " testReadPermembersixSmall", " testReadPermemberSixSquare", " testReadPerMembersixSquare"], "gzin": ["zzin", "zigwith", "zipout", "cigin", "cgiin", "cfginn", "sslin", "cginin", "zlin", "ssldin", "cigIN", "qqdin", "zin", "zzIN", "zlIn", "qqins", "zdin", "zini", "gzout", "gzarin", "znin", "cfgIn", "ziparin", "zigIn", "zzinas", "zins", "gzIn", "ezinas", "syncout", "gtout", "wxarin", "zIN", "cigarin", "zout", "gtnin", "qqIN", "zzdin", "sslinn", "wxIN", "cfgwith", "wxin", "gzdin", "zipin", "cfgin", "cgiinas", "gcIn", "sslIN", "eznin", "zznin", "cgiIN", "ezIN", "gzIN", "zzini", "gtini", "gtin", "zlwith", "ziginn", "gzini", "gzins", "qqin", "qqIn", "wxout", "syncdin", "zzout", "zIn", "zlinn", "zzinn", "zigdin", "ezin", "zipIN", "zigIN", "gznin", "qqout", "cigout", "gzinn", "gcIN", "gcout", "gzinas", "gcin", "syncin", "zigin", "gzwith", "syncins"], "i": ["index", "info", "mu", "n", "pi", "uri", "ie", "c", "j", "fi", "o", "si", "ui", "ii", "ti", "ji", "d", "phi", "chi", "li", "ip", "h", "p", "bi", "u", "ai", "oi", "ci", "I", "m", "e", "io", "zi", "xi", "di", "gi", "hi", "v", "b", "ni", "count", "iu", "multi", "f", "mini", "api"], "count2": ["Count2", "count4", "CountTwo", "count5", "sum1", "name2", "name1", "Count02", " count5", "Count5", "sum2", "countTwo", "Count4", "sum4", "count02", "sumTwo", "Count1", " count4", " countTwo", "name02", " count1", " count02", "name5", "count1"], "count3": ["sum3", "sum5", "cache2", "size3", "count83", "count5", "sum1", "err3", " count5", "count303", "size2", "size83", "size303", " count15", " count83", "cache83", "cache303", "cache3", " count1", "sum15", "err15", "count15", "count1", "err5", " count303", "err1"], "countEnd": ["sizeStart", "refEND", "sizeEnd", "CountStart", "sizeend", "Countend", "lenEnd", "CountEnd", "countend", "refStart", "CountBegin", "countEND", " countEND", "lenend", " countBegin", " countend", "lenBegin", "sizeEND", "countBegin", "refend", "lenEND", "refEnd", "CountEND", "countStart"]}}
{"id1": "19322941", "id2": "7927042", "code1": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "code2": "    private void loadDynamically(File result, String extraPath) {\n        URL url = null;\n        InputStream is = null;\n        FileOutputStream fos = null;\n        try {\n            url = new URL(homeServerUrl + extraPath);\n            is = url.openStream();\n            fos = new FileOutputStream(result);\n            byte[] buff = new byte[8192];\n            int nbRead;\n            while ((nbRead = is.read(buff)) > 0) fos.write(buff, 0, nbRead);\n        } catch (IOException e) {\n            throw new StellariumException(\"Cannot dynamically load \" + result + \" from \" + url);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"test_lookupResourceType_FullSearch_TwoWordsInMiddle": ["test_lookupResourceType_FullSearch_FourWords", "test_lookupResourceType_FullSearch_Threewords", "test_lookupResourceType_FullSearchWithtwowords", "test_lookupResourceType_FullSearch_TwoWord", "test_lookupResourceType_FullSearchWithtwoWord", "test_lookupResourceType_FullSearch_ThreeWords", "test_lookupResourceType_FullSearch_ThreeW", "test_lookupResourceType_FullSearchWithTwoWord", "test_lookupResourceType_FullSearch_twoWords", "test_lookupResourceType_FullSearchWithtwoWords", "test_lookupResourceType_FullSearch_ThreeWord", "test_lookupResourceType_FullSearchWithTwoW", "test_lookupResourceType_FullSearch_TwoW", "test_lookupResourceType_FullSearchWithTwoWords", "test_lookupResourceType_FullSearch_TwoWords", "test_lookupResourceType_FullSearch_FourW", "test_lookupResourceType_FullSearch_Fourwords", "test_lookupResourceType_FullSearch_twoWord", "test_lookupResourceType_FullSearch_twowords", "test_lookupResourceType_FullSearch_twoW", "test_lookupResourceType_FullSearch_FourWord", "test_lookupResourceType_FullSearchWithTwowords", "test_lookupResourceType_FullSearch_Twowords", "test_lookupResourceType_FullSearchWithtwoW"], "url": ["string", "path", "base", "address", "ssl", "server", "uri", "resource", "feed", "user", "entry", "http", "document", "c", "system", "location", "l", "URL", "client", "config", "file", "channel", "https", "page", "object", "web", "log", "conn", "image", "link", "sl", "Url", "position", "bug", "b", "contact", "f", "method", "org"], "connection": ["Connection", "event", "translation", "handler", "server", "resource", "response", "uri", "entry", "http", "document", "character", "c", "connected", "j", "communication", "result", "number", "version", "l", "con", "location", "relation", "database", "established", "condition", "password", "client", "expression", "session", "use", "cache", "proxy", "ion", "which", "operation", "application", "section", "config", "channel", "body", "object", "context", "conn", "image", "io", "function", "link", "db", "position", "bc", "bug", "b", "connect", "wrapper", "contact", "method", "service", "loc"]}}
{"id1": "9371421", "id2": "8665649", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private BufferedImage _getImage(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.connect();\n        InputStream in = null;\n        try {\n            in = conn.getInputStream();\n            return ImageIO.read(in);\n        } finally {\n            IOUtilities.close(in);\n        }\n    }\n", "label": 0, "substitutes": {"eventHash": ["bytehash", "eventKey", "byteHash", "byteKey", "messagehash", "eventhash", " eventDig", "messageDig", " eventKey", " eventhash", "eventDig", "messageHash", "messageKey", "byteDig"], "eventstr": ["Eventstring", "eventStr", "errorstr", "exdict", "EventStr", " eventstring", " eventdict", "exstr", "errorStr", "eventdict", "Eventdict", "errorstring", "exStr", "eventstring", "errorsource", "exstring", "Eventstr", "eventsource", " eventsource", "Eventsource", " eventStr"], "md": ["mu", "id", "mag", "mem", "ke", "bd", "od", "amd", "map", "mo", "ma", "meta", "dr", "wd", "MD", "ms", "ld", "sm", "key", "ad", " MD", "rpm", "cm", "mb", "mt", "dh", "mac", "doc", "d", "mp", "hd", "sha", "pm", "cmd", "data", "mm", "metadata", "dig", "m", "hm", "dm", "mand", "mc", "di", "mn", "em", "vd", "mg", "ng", "mod", "dd", "hash"], "theDigest": ["TheDigester", "theDigEST", "theHashEST", " theSignEST", "Thedigester", " theDigEST", "TheDigest", " theDighest", "theDighest", "thedigEST", "theSignester", "TheDigEST", "thedigest", "theSignhest", "Thedigest", "theSignest", " theSignest", " theDigester", "thedighest", "theHashest", " theSignester", "theHashester", "theDigester", "theSignEST", "ThedigEST", "thedigester", " theSignhest"]}}
{"id1": "1133123", "id2": "18613870", "code1": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"openConnection": ["openChannel", "closeConnect", "closeConnection", "OpenConnect", "createConnector", "createConn", "closeConnector", "OpenConnection", "openConnect", "createConnection", "OpenConnector", "OpenChannel", "closeChannel", "closeConn", "OpenConn", "openConn", "openConnector", "createChannel", "createConnect"], "url": ["path", "address", "buffer", "ssl", "base", "server", "uri", "resource", "id", "http", "limit", "l", "host", "location", "URL", "el", "iter", "source", "proxy", "connection", "str", "config", "data", "file", "channel", "options", "bel", "ll", "object", "log", "null", "name", "image", "link", "sl", "Url", "f", "this", "service", "loc"]}}
{"id1": "947406", "id2": "3053403", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "label": 1, "substitutes": {"copy": ["zip", "Copy", "cmp", "replace", "clip", "write", "clone", "split", " transfer", "csv", "sync", "cop", "cp", "cat", " cp", "file", "Cop", "get", "p", "log", "put", "it", "dump", " Copy", "paste", "transfer", "download"], "src": ["string", "sin", "sel", "input", "id", "uri", "resource", "sc", "rc", "bh", "filename", "loc", "sub", "fn", "ins", "s", "inst", "rs", "txt", "gb", "rb", "source", "sit", "use", "sb", "dist", "config", "data", "href", "sq", "js", "stab", "name", "rob", "sl", "files", "url", "stream", "cur", "ource", "img"], "dest": ["rest", "class", "temp", "output", "replace", "result", "later", "destroy", "done", "bin", "wd", " Dest", "txt", "die", "comb", "thin", "d", "source", "wb", "dir", "target", "dist", "flat", "Dest", "tmp", "de", "des", "delete", "test", "desc", "folder", "name", "home", "opt", "sup", "const", "prop", "obj", "st", "dat", "orig", "img"], "in": ["IN", "info", "base", "pin", "i", "input", "id", "cf", "ini", "lock", "gin", "con", "socket", "inner", "as", "ins", "s", "trans", "bin", "pass", "is", "source", "reader", "thin", "lib", "up", "login", "diff", "r", "inc", "work", "data", "rin", "vin", "conn", "init", "issue", "again", "m", "isin", "it", "In", "nin", "kin", "a", "pull", "url", "lin", "err", "b", "cin", "inn", "win", "this", "din", "download"], "out": ["index", "ou", "ex", "output", "outer", "user", "timeout", "id", "net", "plain", "OUT", "socket", "inner", "o", "outs", "pool", "off", "write", "bin", "exit", "sync", "client", "part", "at", "one", "no", "cache", "source", "lib", "up", "our", "w", "inc", "data", "file", "x", "log", "conn", "init", "or", "again", "aos", "exec", "Out", "io", "writer", "exp", "image", "call", "nin", "app", "ext", "err", "obj", "os", "vert", "this", "img"], "buf": ["buffer", "num", "bf", "bd", "rc", "bh", "cap", "ref", "c", "cb", "result", "off", "bin", "ff", "feat", "queue", "uf", "raw", "bag", "fl", "cv", "rb", "ab", "uc", "buff", "len", "data", "fb", "p", "bn", "box", "pos", "nb", "fd", "bytes", "ctx", "bc", "bp", "seq", "b", "v", "br", "fab", "count", "pad", "block", "f", "batch", "cur", "orig", "loc"], "n": ["index", "max", "i", "num", "nr", "ns", "ind", "c", "j", "z", "number", "o", "l", "length", "write", "nn", "N", "en", "nc", "nt", "no", "d", "rn", "len", "w", "un", "nd", "x", "p", "size", "u", "ne", "m", "dn", "t", "nb", "nin", "na", "k", "v", "b", "count", "ng", "sn", "f"]}}
{"id1": "15018553", "id2": "18631594", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "label": 1, "substitutes": {"encrypt": ["Encrypt", "Enccrypt", "encryption", "secipher", "decryption", "seccrypt", "Encryption", "secryption", "decipher", "Encipher", "encipher", "secrypt", "enccrypt", "deccrypt", "decrypt"], "text": ["letter", "string", "path", "address", "buffer", "class", "input", "output", "token", "Text", "message", "TEXT", "sequence", "hex", "number", "length", "key", "pattern", "content", "password", "txt", "source", "binary", "seed", "connection", "str", "config", "data", "object", "struct", "test", "name", "template", "image", "font", "word", "bytes", "ext", "secret", "contract", " Text", "transfer", "method", "code"], "md": ["mk", "pkg", "cmp", "mag", "bd", "od", "df", "Cmd", "amd", "message", "mo", "ma", "am", "meta", "dr", "wd", "MD", " MD", "ms", "ld", "sm", "ad", "gb", "cm", "mb", "mt", "mac", "d", "mp", "hd", "sha", "pm", "pd", "data", "cmd", "mm", "metadata", "mi", "dig", "pg", "m", "hm", "dm", "db", "mand", "mc", "mn", "me", "em", "rm", "mg", "mod", "dd", "hash"], "md5hash": [" md5Hash", " md4log", "md512hash", "md4block", "md6hash", " md5log", "MD5key", "md4log", "md6hex", " md5block", " md4block", "md5Hash", "md6Hash", "md6log", " md4Hash", "md256key", "md5hex", "md4sum", "md4Hash", "md2Hash", "MD5hex", " md5sum", "md7Hash", "md25hash", "md5sum", "md256hex", "md5log", "md25sum", "MD512hash", "md2block", "md25Hash", "md5block", "md7hash", "md512hex", " md4hash", "md7block", "md7sum", "MD512hex", "md5key", "md256hash", "md6sum", "md25log", "MD512key", "md2sum", "MD5hash", "md6key", "md4hash", " md4sum", "md2hash", "md512key"]}}
{"id1": "17296916", "id2": "19147281", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"logging": ["logger", "blogting", "Loging", "loging", "blogger", " logger", "Logting", " logting", "Logger", " loging", "bloging", "blogging", "logting", "Logging"], "wrap": ["nw", "handler", "rap", "self", " wrapped", "lock", "wp", "now", "message", "run", "util", "ad", "bag", "wra", "ws", "use", "cover", "wb", "cache", "binary", "default", "div", "w", "build", "pipe", "war", "work", "web", "h", "get", "p", "widget", "flash", "init", "format", "or", "force", "frame", "image", "box", "word", "stream", "parse", "create", "b", "wire", "wrapper", "we", " Wrap", "sw", "wa", "process", "f", "ow", "handle", "transform", "api"], "buffer": ["base", "loader", "pause", "Buffer", "server", " receive", "copy", "response", "uffer", "feed", "builder", "report", "bridge", "ref", "message", "board", "table", "document", "cb", "result", "shell", "bin", "manager", "pb", "queue", "iter", "uf", "bar", "reader", "cache", "player", "cover", "binary", "buff", "source", "buf", "ob", "surface", " buf", "batch", "BU", "fb", "flash", "bb", "log", "null", "reply", "msg", "template", "header", "frame", "writer", "image", "nb", "layer", "bc", "url", "comment", "b", "reference", "wrapper", "bm", "print", "transfer", " buffers", "code", "view"], "encoding": ["Encet", "decoded", "packoder", "ecoded", "decoder", "enoder", "Encoded", "Encoder", "coder", "Encryption", "coding", "unicode", "encode", "unicoded", "ecryption", "decoding", "encet", "Encoding", "encryption", "packet", "packoding", "coded", "enoded", "enoding", "unicoding", "enode", "ecoder", "cet", "packoded", "decryption", "unicoder", "encoder", "decode", "ecoding", "encoded"], "getEncoding": [" getEncasing", " getEncoded", "getCoded", "getEncoder", "getencoding", " getEncocol", "getEnoding", " getEnoding", "getEnoder", "getEnoded", " getEnoded", "getencocol", "getEnocol", "getCoder", "getencasing", "getencoder", "getCasing", "getCoding", " getEnocol", " getEnasing", "getEncocol", "getEncasing", "getEnasing", "getEncoded", " getEnoder", " getEncoder", "getCocol", "getencoded"], "headers": ["keys", "head", "settings", "http", "ers", "features", "writers", "s", "host", "caps", "rs", "ids", "workers", "content", "ings", "parts", "params", "links", "lines", "strings", "blocks", "ports", "str", "names", "body", "vals", "objects", "options", "h", "plugins", "groups", "breaks", "frames", "header", "dict", "ters", "ppers", "ints", "types", "details", "files", "values", "relations", "fields", "wrapper", "heads", "padding", "properties", "bits"], "is": ["bis", "i", "iss", "lis", "fs", "IS", "isa", "http", "Is", "as", "tis", "api", "bs", "s", "abs", "ins", "ois", "ui", "in", "ms", "ori", "isl", "cms", "its", "ws", "so", "ops", "ais", "bas", "nis", "out", "las", "\u00eds", "es", "has", "or", "js", "ris", "obs", "ists", "io", "oss", "aos", "iris", "ios", "us", "ses", "isi", "sis", "are", "isol", "os", "was", "iso", "mis"], "bos": ["uds", "bis", "base", "mos", "ko", "oses", "fs", "fits", "bh", "zos", "tis", "bones", "outs", "bs", "bo", "obos", "ois", "bin", "oos", "obo", "mobi", "obi", "bes", "flo", "cms", "so", "ws", "ros", "ops", "org", "ubis", "bas", "ob", "bott", "las", "ubs", "bi", "oes", "opus", "aos", "obs", "bots", "home", "oks", "lins", "beans", "ios", "bc", "ses", "osa", "pins", "bot", "shadow", "los", "zo", "abi", "oops", "os", "osi", "bits", "cos", "mis"], "e": ["ite", "ise", "fe", "i", "ee", "ke", "be", "ie", "c", "o", "se", "l", "ception", "ec", "er", "type", "one", "d", "ce", "ale", "je", "ea", "de", "exc", "x", "p", "ae", "E", "ze", "a", "ev", "pe", "me", "err", "f", "error", "oe", "esi", "re"]}}
{"id1": "3731077", "id2": "3801655", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 1, "substitutes": {"copyFile": ["importSourceFile", " copyfile", "copyfile", "transferfile", "transferFile", " copySourceFile", "importFiles", " copyFiles", "copyFiles", "transferFiles", "importfile", "importFile", "copySourceFile", "transferSourceFile"], "from": ["path", "original", "base", "address", "remote", "id", "resource", "user", "by", "add", " form", "c", "as", "o", "origin", "se", "form", "client", "part", "at", "back", "source", "d", "ce", "without", "before", "old", "config", "data", "file", "src", "ca", "or", "about", "name", "start", "io", "a", "url", "of", "left", "range", "with", "From", "f", "this", "front"], "to": ["root", "base", "temp", "output", "until", "copy", "token", "eto", "by", "into", "site", "socket", "as", "o", "dest", "api", "location", "database", "TO", "two", "client", "at", "so", "one", "type", "source", "target", "parent", "file", "To", "object", "size", "p", "null", "or", "about", "po", "name", "again", "io", "t", "toc", "of", "too", "point", "top", "b", "with", "os", "f", "office", "this", "auto", "storage"], "parentDir": ["parentdir", "currentdir", "outDir", " parentFolder", "rootFolder", "outFolder", "parentDirectory", "outFile", "ParentDirectory", " parentdir", "currentFolder", "parentFolder", "rootDirectory", "ParentFolder", "rootDir", "rootFile", "Parentdir", "currentDir", "outDirectory", "parentFile", " parentDirectory", "ParentFile", "currentFile", " parentFile", "ParentDir"], "in": ["IN", "pin", "trial", "i", "input", "id", "rc", "ini", "pre", "on", "gin", "ie", "con", "inner", "fc", "o", "l", "ins", "arin", "bin", "form", "sync", "part", "source", "reader", "login", "diff", "min", "inside", "r", "inc", "work", "vin", "rin", "init", "rec", "or", "conn", "again", "plugin", "m", "exec", "io", "image", "it", "isin", "In", "pc", "nin", "kin", "url", "lin", "err", "ac", "with", "cin", "inn", "win", "din"], "out": ["ou", "input", "outer", "output", "ex", "user", "op", "gin", "on", "option", "net", "OUT", "c", "inner", "o", "outs", "off", "co", "bin", "sync", "client", "at", "other", "cy", "w", "inc", "channel", "p", "conn", "init", "or", "about", "again", "plugin", "exec", "Out", "io", "writer", "ot", "call", "ico", "app", "can", "ac", "cin", "vert", "win", "org", "auto"], "ic": ["anc", "aic", "cu", "cc", "i", "ex", "input", "acs", "enc", "op", "rc", "auto", "c", "IC", "fc", "o", "irc", "co", "dc", "cus", "ec", "sync", "vc", "lc", "uc", "ct", "voc", "inc", "ig", "cl", "xc", "pic", "icc", "conn", "or", "ai", "nic", "ci", "ics", "io", "pc", "ix", "mc", "ico", "bc", "iac", "ac", "cs", "cin", "ik", "loc"], "oc": ["anc", "aco", "aic", "cc", "i", "sc", "alloc", "acs", "enc", "op", "OC", "ocol", "ack", "c", "fc", "o", "mic", "co", "dc", "cus", "ec", "vc", "ocon", "uc", "voc", "wic", "roc", "cy", "ob", "oco", "ca", "inc", "xc", "or", "oca", "nic", "ci", "io", "oci", "toc", "pc", "og", "mc", "circ", "soc", "bc", "AC", "can", "ac", "cur", "org", "loc"]}}
{"id1": "15799935", "id2": "5299276", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttPartBody", "saveAttachmentPart", "saveAttPartbody", "saveAttachedBody", "saveAppensionbody", "saveAppachmentPart", "saveAppachmentFile", "saveAppensionBody", "saveAttensionFile", "saveAttPartFile", "saveAttensionBody", "saveAppensionPart", "saveAppensionFile", "saveAttensionPart", "saveAttachmentFile", "saveAppachmentBody", "saveAttachmentbody", "saveAppachmentbody", "saveAttachedPart", "saveAttPartPart", "saveAttachedFile", "saveAttachedbody", "saveAttensionbody"], "context": ["event", "translation", "input", "resource", "definition", "cf", "subject", "document", "message", "c", "version", "concept", "system", "present", "current", "driver", "host", "project", "manager", "center", "queue", "content", "client", "cms", "support", "ce", "reader", "cache", "connection", "component", "media", "Context", "collection", "config", "parent", "ca", "text", "channel", "request", "environment", "template", "coll", "kernel", "mc", "ctx", "community", "processor", "container", "contact", "state", "network", "cca", "service", "view", "front"], "part": ["event", "base", "translation", "Part", "pre", " Part", "message", "per", "place", "phase", "patch", "html", "mission", "PART", "chapter", "parts", "type", "source", "art", "connection", "Parts", "component", "media", "upload", "section", "parent", "file", "body", "channel", "pod", "object", "p", "or", "po", "name", "start", "image", "to", "area", "position", "app", "partial", "plan", "comment", " parts", "state", "block", "service", "from", "point"], "localAttachment": [" localAttment", "localAvention", "localExtacher", "LocalAttail", "LocalAttention", "localArtail", "localInstention", " localAttacement", "localAddail", "LocalAssail", " localExtacement", " localPartension", "localArtment", "LocalAttachment", "localattachment", "localAddachment", " localExtacher", "localInstension", " localExtention", "LocalAssention", " localAttrollment", "localAttachrollment", " localAttention", "localArtention", "localExtachment", "localPartachment", "localPartribution", " localAttribution", "localPartention", "localAttachribution", "localAvacement", "localInstribution", "localAssachment", "localExtention", "localAttention", "localAttacement", "localAttachacher", " localAttacher", "localAttacher", "localattment", " localAttachachment", "localAddrollment", "localattrollment", "localattention", "localAttension", "localAttachacement", " localPartribution", "localAvacher", "localAttribution", "localArtachment", "LocalAssment", "localAttail", "localAssail", "localPartension", " localPartachment", "LocalAssachment", " localAttachrollment", "localAttrollment", " localAttension", "localAttachension", "localAddention", "localAttment", " localExtachment", "localAddment", "localAttachention", "localAvachment", "localAssment", "localAttachachment", "localExtacement", " localPartention", " localAttachention", "localAssention", "LocalAttment", "localInstachment"], "accountId": ["accID", "contractid", "accountInfo", "jobId", "accId", " accountInfo", "AccountID", "contractId", "feedId", "AccountName", "feedid", "jobid", "feedID", "contactId", " accountID", "accInfo", "accid", "contractName", "contactid", " accountName", "accountID", "accountid", "jobID", "AccountId", "Accountid", "feedName", "contactName", "jobName", " accountid", "accountName", "appInfo", "appID", "appId", "appid"], "attachmentId": ["adachmentID", "attentionUrl", "attentionId", "attmissionID", "attociationID", "extachmentSource", "attachmentid", "attensionSource", "atachmentReference", "attlementId", "attmentName", "attociationUrl", "atachmentName", "attmissionId", "addachmentUrl", "attachmentReference", "attensionid", "attptionId", "attptionIndex", "addentionUrl", "attentionInfo", "extensionID", "attentionSource", "adentionID", "atociationId", "attagramId", "attachmentSource", "attptionID", "attlementName", "attentionID", "addentionID", "attachedType", "atociationID", "addachmentId", "attentionType", "attachmentName", "attachedUrl", "attptionInfo", "addachmentID", "adachmentInfo", "extensionId", "attensionID", "addentionId", "extensionid", "addachmentType", "attociationReference", "adentionId", "extensionSource", "attmissionid", "attlementReference", "adachmentIndex", "attmissionSource", "attentionIndex", "atachmentID", "attociationType", "extachmentID", "adachmentId", "attachedId", "extachmentId", "attmentReference", "atachmentId", "addentionType", "attociationName", "attachmentInfo", "adentionInfo", "attensionId", "atociationReference", "attachedID", "attachmentType", "attmentID", "attociationId", "attmentId", "extachmentid", "attlementID", "attachmentUrl", "attachmentID", "attentionid", "attagramIndex", "attagramInfo", "adentionIndex", "attagramID", "atociationName", "attachmentIndex"], "in": ["IN", "info", "pin", "i", "input", "id", "plus", "copy", "ini", "gin", "con", "slice", "inner", "as", "socket", "ins", "bin", "pass", "is", "source", "reader", "load", "up", "login", "inside", "inc", "data", "file", "p", "init", "conn", "or", "again", "image", "it", "In", "nin", "a", "pull", "url", "err", "ac", "cin", "inn", "f", "din"], "saveIn": ["savIn", "writeIN", "saveIN", "savin", "SaveIn", "saveIns", "savAs", "stageAs", "savOut", " saveIN", "aveIn", "writeIn", "stageIns", "writein", "avein", "aveOut", "stageIn", " savein", "writeOut", "savein", "SaveAs", " saveIns", "SaveIns", "SaveOut", "aveIN", " saveOut", "aveAs", "saveOut", "stageOut"], "saveAs": ["copyAs", "writeAs", "SaveIn", "Saveas", "saveas", " saveFile", "createAs", "saveFile", "openAs", "saveAS", "openAt", "writeIn", "copyIn", "writeAS", "createAS", "writeOut", "SaveAs", "copyAS", "SaveAS", "copyas", "SaveOut", "saveAt", " saveAS", " saveas", "createFile", " saveOut", "createAt", "openAS", " saveAt", "openFile", "saveOut"], "out": ["string", "path", "temp", "ex", "output", "copy", "outer", "plus", "OUT", "c", "as", "inner", "o", "outs", "s", "line", "flow", "bin", "off", "client", "sync", "at", "source", "cache", "up", "other", "default", "inc", "data", "file", "page", "null", "conn", "init", "again", "name", "exec", "Out", "io", "writer", "image", "to", "a", "ext", "err", "v", "this"], "copySize": ["openSIZE", "savesize", "saveAddress", "byteLength", "CopySize", "openSize", "opensize", "lesize", "byteAddress", "copysize", "copyTime", "leSize", "openLength", "CopyTime", "saveLength", "bytesize", " copyLength", "copyAddress", " copysize", " copyAddress", " copySIZE", "leLength", "leSIZE", "byteTime", "CopyLength", "copySIZE", "copyLength", "saveSize", " copyTime", "byteSize", "Copysize"], "contentUriString": ["contentUpiStr", "contentIristring", "contentIrisInt", "contentUiniStr", "contentUiniNumber", "contentUrisstring", "contentUuriStr", "contentUuriByte", "contentIrisStr", "contentIriByte", "contentIiString", "contentUriStr", "contentUriUnit", "contentUiniByte", "contentIrisString", "contentIriStr", "contentUridString", "contentIrisUnit", "contentIriString", "contentUrisStr", "contentUrisUnit", "contentUiByte", "contentUriNumber", "contentUridStr", "contentUuriString", "contentUpistring", "contentUristring", "contentUioInt", "contentIiByte", "contentIriNumber", "contentUioStr", "contentUrisInt", "contentUiNumber", "contentUriByte", "contentUiUnit", "contentUuriNumber", "contentUiostring", "contentIrisstring", "contentIriInt", "contentUpiInt", "contentUiStr", "contentUridUnit", "contentIiStr", "contentIiNumber", "contentUioString", "contentIriUnit", "contentUiString", "contentUpiString", "contentUriInt", "contentUrisString", "contentUiniString"], "mSize": ["mName", "cName", "pLength", "iSize", "iLength", "iName", "pName", "cSize", "pCount", "mCount", "cCount", "pSize", "iCount", "mLength", "cLength"], "mContentUri": ["mContentIric", "mContentOUris", "mResourceIric", "mResourceIri", "mContentIris", "mContentUci", "mResourceUris", "mContentUrri", "mContentOUric", "mResourceUric", "mContentUrric", "mContentUric", "mContentOUci", "mContentIci", "mResourceUci", "mContentUrris", "mResourceIris", "mResourceIci", "mContentUrci", "mResourceUri", "mContentOUri", "mContentIri", "mContentUris"], "cv": ["iq", "cu", "core", "cc", "sc", "um", "cf", "rc", "enc", "vm", "uv", "cap", "vr", "c", "fc", "ctrl", "cb", "fp", "co", "pb", "VC", "csv", "nc", "content", "vc", "cm", "cp", "lc", "cover", "auc", "uc", "buf", "sv", "conv", "ca", "xc", "av", "cd", "keep", "vs", "coll", "cr", "CV", "mc", "ctx", "bc", "nv", "v", "ov", "cs", "GV", "vp", "lv", "que", "iv", "vv", "loc"], "uri": ["string", "path", "base", "address", "i", "id", "resource", "pi", "username", "http", "uid", "ri", " URI", "location", " Uri", "query", "ui", "universal", " ur", "qi", "gb", " url", "proxy", " scheme", "data", "route", "oid", "mi", "metadata", "environment", "href", "format", "uni", "ci", "iri", "prefix", "url", "range", "attribute", "cli", "iv", "URI", "api", "point", "storage"]}}
{"id1": "22418839", "id2": "6987642", "code1": "    public void handleHandshake(Packet2Handshake par1Packet2Handshake) {\n        boolean flag = true;\n        String s = par1Packet2Handshake.username;\n        if (s == null || s.trim().length() == 0) {\n            flag = false;\n        } else if (!s.equals(\"-\")) {\n            try {\n                Long.parseLong(s, 16);\n            } catch (NumberFormatException numberformatexception) {\n                flag = false;\n            }\n        }\n        if (!flag) {\n            netManager.networkShutdown(\"disconnect.genericReason\", new Object[] { \"The server responded with an invalid server key\" });\n        } else if (par1Packet2Handshake.username.equals(\"-\")) {\n            addToSendQueue(new Packet1Login(mc.session.username, 29));\n        } else {\n            try {\n                URL url = new URL((new StringBuilder()).append(\"http://session.minecraft.net/game/joinserver.jsp?user=\").append(mc.session.username).append(\"&sessionId=\").append(mc.session.sessionId).append(\"&serverId=\").append(par1Packet2Handshake.username).toString());\n                BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s1 = bufferedreader.readLine();\n                bufferedreader.close();\n                if (s1.equalsIgnoreCase(\"ok\")) {\n                    addToSendQueue(new Packet1Login(mc.session.username, 29));\n                } else {\n                    netManager.networkShutdown(\"disconnect.loginFailedInfo\", new Object[] { s1 });\n                }\n            } catch (Exception exception) {\n                exception.printStackTrace();\n                netManager.networkShutdown(\"disconnect.genericReason\", new Object[] { (new StringBuilder()).append(\"Internal client error: \").append(exception.toString()).toString() });\n            }\n        }\n    }\n", "code2": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"handleHandshake": [" handleHandlerled", " handlehandling", " processHandshake", " handleHandlershake", " handleHandling", " handleHandled", " handlehandled", " processHandled", " processhandled", " handleHeadshake", " handleHeadling", " handlehandshake", " processhandling", " handleHandlerling", " processhandshake", " handleHeadled", " processHandling"], "par1Packet2Handshake": ["par1Packet1Handpair", "par1Packet2handling", "par1Packet2Hostshake", "par1Packet1Handla", "par1Packet2Chshake", "par1PacketTranslationHandling", "par1PacketTranslationHandword", "par1Packet2Shpair", "par1Packet2handle", "par1Packet2Hanshake", "par1Packet2Handla", "par1Packet2HandMessage", "par1Packet2Chling", "par1Packet2Chle", "par1PacketTranslationhandle", "par1Packet2HanMessage", "par1Packet2Shshake", "par1Packet2Handword", "par1Packet2Hostle", "par1Packet2Handling", "par1Packet1Handling", "par1PacketTranslationhandword", "par1Packet2Shle", "par1Packet2Handle", "par1Packet2handshake", "par1Packet2HostMessage", "par1Packet2Hanle", "par1Packet2handword", "par1Packet2Marshling", "par1Packet1HandMessage", "par1PacketTranslationhandshake", "par1Packet2Hostword", "par1Packet2Marshshake", "par1Packet2Hanpair", "par1Packet2MarshMessage", "par1Packet2Hanla", "par1PacketTranslationHandle", "par1Packet1Handle", "par1Packet2Shla", "par1Packet2Marshle", "par1PacketTranslationHandshake", "par1Packet2ChMessage", "par1Packet1Handshake", "par1PacketTranslationhandling", "par1Packet2Hostling", "par1Packet2Handpair", "par1Packet2Hanling"], "s": ["services", "string", "ssl", "sum", "i", "input", "sf", "n", "fs", "username", "spec", "sg", "site", "ns", "comments", "c", "S", "o", "l", "abs", "si", "su", "is", "rs", "hs", "sync", "session", "ws", "d", "lines", "sb", "strings", "r", "str", "sv", "w", "g", "data", "gs", "suff", "h", "p", "es", "u", "ts", "submit", "aws", "ls", "e", "m", "ss", "sl", "sym", "a", "ses", "v", "b", "ds", "words", "os", "ps", "f", "units", "service"], "flag": ["val", "zip", "string", "lag", "fun", "id", "mask", "year", " bit", "FLAG", "tag", "arg", "ret", "func", "sort", "char", " flags", "fail", "flags", "key", "ad", "util", "type", "debug", "kind", "len", "cat", "wave", "store", "ask", "file", "agg", "ag", "log", "cloud", "name", "start", "force", "bit", "status", "af", "fortune", "leaf", "fd", "bug", "bool", "sign", "wait", "enable", "count", "and", "age", "f", "Flag", "field", "win", "code", "valid"], "url": ["string", "path", "address", "ssl", "base", "buffer", "job", "server", "uri", "resource", "feed", "id", "user", "http", "l", "URL", "queue", "source", "connection", "browser", "r", "org", "data", "file", "channel", "page", "object", "web", "name", "image", "blog", "sl", "Url", "www", "stream", "b", "f", "hub", "service", "api"], "bufferedreader": [" buffendedwriter", "bufferedparser", " buffendedreader", "buffedreader", "buffererReader", " bufferedwriter", " bufferedparser", "Bufferedwriter", "buffererreader", "buffererparser", "bufferingwriter", "buffendedReader", "buffedhandler", " buffererreader", " buffererReader", "buffereder", "buffleder", "buffaredwriter", "buffaredreader", "buffledReader", "Bufferedhandler", " buffererparser", "buffledwriter", "Bufferedreader", "buffendedreader", "BufferedReader", "Buffererreader", "bufferedhandler", "buffledreader", "bufferingreader", " buffendedReader", "bufferedReader", "buffererer", "Buffererhandler", "bufferinghandler", "buffaredparser", "buffendeder", "Buffererwriter", "bufferingReader", "buffaredReader", "buffendedwriter", "buffererwriter", " buffendeder", " buffererwriter", "bufferedwriter", "BuffererReader", "buffedwriter", " bufferedReader", " buffereder", "bufferingparser", "buffererhandler", "buffedReader"], "s1": ["qsFirst", "S3", " s4", "qsfirst", "pOne", " sfirst", "ments2", "sOne", "ments3", "sFirst", " s0", "S0", "Sasso", "S1", "ments1", " sOne", "mentsasso", " s3", "S2", "hsFirst", "p0", " sasso", "s0", "s2", " sFirst", "p1", "qs1", "sasso", "s3", "qs4", "hsfirst", "s4", "sfirst", "SOne", "hs1", "p2", " s2", "hs4"]}}
{"id1": "23517481", "id2": "8667872", "code1": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"md5": [" md2", "md8", "md2", "sha2", "md512", "sha5", " md8", " md512", "MD5", "sha8", "sha512", "MD8", "MD512", "MD2"], "uri": ["directory", "path", "string", "address", "base", "i", "id", "resource", "token", "absolute", "pi", "message", "filename", "ri", " URI", "location", "origin", "URL", "query", "ui", "database", " ur", "source", "connection", "data", "file", "text", "object", "request", "format", "name", "io", "iri", "prefix", "Url", "url", "reference", "abi", "attribute", "URI", "api"], "messageDigest": ["MessageDiger", "MessageDester", "messageDigger", "MessageDigum", "MessageDigester", "messageUploadested", "messageMixusher", "messageDesignested", "MessageDesignum", "messagedigest", "messagediger", "MessageDigEST", "messagedigester", "messageDer", "MessageMixEST", "messageDigester", "MessageDest", "messageMixEST", "messagedigEST", "MessageDigger", "messageDEST", "MessageDigested", "messageUploadum", "MessageDesignest", "messageDiger", "messageMixest", "messageMixger", "messageDusher", "messageDest", "messageDesignum", "MessageDger", "messageUploadest", "messageDester", "messageDigested", "MessageDesignester", "messagedigum", "messageMixer", "messagedigger", "messageDigEST", "MessageDigusher", "messagedigested", "messageUploadester", "MessageDesignested", "messageDger", "MessageMixusher", "messageDigum", "messageMixester", "messagedigusher", "MessageDigest", "MessageMixester", "MessageDer", "messageDigusher", "messageDesignester", "MessageMixest", "messageDesignest"], "bytes": ["services", "keys", "buffer", "bles", "address", "pieces", "resources", "tes", "slice", "sequence", "outs", "steps", "bs", "s", "errors", "params", "parts", "lines", "binary", "blocks", "strings", "data", "classes", "objects", "ips", "es", "Bytes", "seconds", "acters", "files", "values", "ions", "seq", "units", "events", "words", "bits", "letters"], "stringBuffer": ["doubleBuilder", "doubleText", "intText", "stringHelper", "stringBuilder", "externalBuffer", "StringHelper", "objectFrame", "objectBuff", "objectString", "objectHelper", " stringLength", "externalBar", "stringString", "StringString", "StringBar", " stringFrame", "objectBuffer", "objectBB", "StringLength", "stringBuff", " stringHelper", "StringBuff", "stringBar", " stringBuff", "externalLength", "intBuffer", "doubleBuffer", "StringFrame", " stringString", "stringLength", "externalBuff", "stringText", "StringText", " stringBar", "intBuff", " stringBB", "stringFrame", "stringBB", "StringBB", "doubleBuff", "intBuilder"], "b": ["letter", "string", "base", "buffer", "i", "id", "bf", "be", "c", "number", "l", "s", "length", " B", "rb", "d", "sb", "value", "r", "ob", "body", "fb", "object", "bb", "p", "x", "bi", "bit", "e", " a", "a", "B", "k", "v", "abi", "block", "f", "code"], "hex": ["letter", "string", "buffer", "i", "ex", "bits", "oct", "character", "c", "number", "length", "bin", "digit", "alph", "char", "alpha", "iter", "pattern", "raw", "comp", "utf", "rh", "cache", "binary", "buff", "serial", "str", "he", "text", "check", "h", "x", "ip", "bb", "null", "lit", "bit", "header", "a", "url", "f", "hash", "code", "loc"]}}
{"id1": "149935", "id2": "11933797", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"convert": ["CONverting", "subverting", "Conversion", "oconversion", "oconverting", "Converting", "CONversion", "unversion", "CONvert", "conversion", "CONception", "oconverted", " deconverted", "converting", "CONverted", "subvert", "oconvert", "Conception", "unvert", "converted", " deconverting", "subversion", "Converted", "unception", "unverted", "subverted", " deconversion", "conception", "Convert", " deconvert"], "src": ["impl", "string", "path", "sel", "ssl", "sin", "input", "sc", "uri", "resource", "sys", "spec", "rc", "Source", "video", "cmp", "username", "filename", "ref", "slice", "cb", "fp", "fn", "s", "prot", "code", "inst", "feat", "cpp", "req", "gb", "back", "source", "reader", "load", "proc", "sb", "rb", "sit", "buf", "component", "dist", "upload", "SourceFile", "config", "file", "tmp", "Dest", "supp", "attr", "img", "href", "storage", "name", "sth", "gz", "RC", "rl", "ctx", "secure", "url", "scene", "stream", "obj", "st", "stage", "sn", "ource", "download", "loc"], "dest": ["path", "class", "temp", " dst", "cont", "fn", "bin", "dc", "std", "txt", "source", "dir", "lib", "target", "dist", "tmp", "Dest", "null", "test", "home", "di", "obj", " destination", "dat", "disk", "orig", "img"], "in": ["IN", "val", "pin", "i", "input", "ex", "n", "inas", "ini", "as", "ins", "bin", "pass", "is", "reader", "d", "source", "doc", "up", "login", "r", "inc", "data", "file", "io", "t", "isin", "In", "a", "stream", "err", "inn", "ps", "f", "inf", "win", "din"], "p": ["P", "i", "pi", "op", "wp", "pre", "lp", "per", "py", "c", "j", "fp", "o", "l", "s", "pb", "cop", "part", "cp", "d", "pr", "pp", "pm", "r", "g", "parser", "h", "np", "po", "tp", "m", "e", "t", "pc", "jp", "pa", "bp", "pe", "b", "sp", "v", "ps", "f", "pd", "pg"], "ds": ["services", "uds", "ays", "docs", "ants", "dos", "s", "ins", "dp", " DS", "parts", "points", "gs", "els", " props", "des", "ts", "js", "utils", "ths", "ys", "gd", "sys", "df", "lp", "bs", "dc", " ps", "dt", "sync", "lines", "eps", "vs", "ges", "amps", "ipes", "pd", "dd", "sts", "DS", "cons", "ks", "ns", "qs", "ld", "hs", "d", "dist", "ans", "ads", "xs", "models", "plugins", "groups", "tests", "ss", "di", "os", "posts", "styles", "rs", "dl", "tools", "ded", "ups", "data", "vals", "scripts", "Ds", "ls", "obs", "dm", "db", "ils", "nas", "dates", "da", "cs", "words", "dds", "ps", "dat", "icks", " sd"], "format": ["letter", "string", "path", "class", "handler", "spec", "filename", "act", "version", "table", "fp", "fn", "host", "tag", "record", "layout", "feat", "magic", "Format", "pattern", "form", "filter", "at", "type", "source", "part", "model", "parser", "config", "data", "file", "sche", "struct", "ant", "language", "style", "plugin", "template", "name", "frame", "t", "function", "prefix", "fd", "nat", "url", "unit", "atter", "f", "scale", "api"], "hasPixelData": ["hasPixeldata", "showsPixelDATA", "hasPixelDATA", "hasPicturedata", "hasByteSize", "hasByteDATA", "hasByteData", "haspixelData", "hasPixelStyle", " hasPixelSize", "showsByteDATA", "hasPictureSize", " hasPixeldata", "haspixeldata", "showsBytedata", "hasPictureData", "haspixelSize", "showsByteData", "showsPixelData", "showsByteStyle", "hasPixelSize", "hasByteStyle", "showsPixelStyle", "hasBytedata", "showsPixeldata"], "inflate": ["inadequating", "insflode", "insvenating", "inffated", "Inflation", "InFlation", "inflating", "Inflated", "inflATE", "InFlace", "insvenate", "inadequode", "InFlated", "insflate", "infolATE", "infface", "invenode", "InFlate", "inffation", "inflated", "inFlation", "infolode", "infloace", "insvenATE", "infloate", "invenATE", "inFlate", "inadequATE", "insflATE", "infloation", "invenating", "inffate", "insvenode", "inadequate", "Inflace", "inflation", "inflode", "inFlated", "Inflate", "infolate", "inFlace", "infloated", "invenate", "infolating", "inflace", "insflating"], "pxlen": ["pxdata", "xpsize", "pxlin", "pngcount", "mxsize", "campos", "fxlen", "pxl", "pgLen", "axlen", "ppLen", "mxcount", "fxln", "pxlon", "pxln", "pcln", "pglen", "ppl", "pxlength", "ppden", "camln", "txln", "pngsize", "pxpos", "pclon", "camlen", "mxdata", "axln", "axlon", "mxlength", "mxpos", "mxlen", "xplen", "txlin", "pxden", "pxcount", "fxpos", "txlon", "pclin", "pxsize", "fxdata", "pxLen", "mxln", "xpcount", "pgl", "fxLen", "axlin", "pnglen", "xplength", "fxl", "pgden", "fxden", "pclen", "pnglength", "txlen", "pplen", "camdata"], "out": ["step", "server", "output", "copy", "sys", "user", "lock", "OUT", "inter", "outs", "line", "co", "query", "post", "session", "cache", "lib", "up", "group", "store", "parent", "work", "page", "log", "gen", "conn", "again", "Out", "io", "dump", "obj", "v", "err", "state", "pad", "cli", "error", "re", "list", "point"]}}
{"id1": "17999474", "id2": "364438", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipAsDir", "getTempAsDir", "getTempAsPlace", "getZipAtfile", "getZipasFile", "getZipAsPlace", "getZipasPlace", "getZipAtPlace", "getTempAsFile", "getZipAsfile", "getZipAtDir", "getTempAsfile", "getZipasDir", "getZipasfile", "getZipAtFile"], "digOb": ["ditOB", "digOB", " digob", "DigObj", " digOl", "signOB", "Digob", "signObject", "digob", "dimOb", "dimOl", "signObj", "digObject", "DigObject", "ditob", "DigOb", "signOb", "digOl", "DigOl", "ditOb", " digObject", "dimObj", "dimObject", "signob", "digObj", " digOB", "ditObject", " digObj"], "folderName": ["FolderPath", "filename", "filePath", "folderPath", "FolderName", "fileInfo", "foldPath", " folderPath", "Foldername", "foldername", "fileName", "packageName", "foldName", "FolderInfo", "folderInfo", "FolderDir", " folderDir", "folderDir", "foldInfo", "foldname", "packageDir", " foldername", "packagename", "packagePath"], "tmpFolder": ["tmpManager", "tempfolder", " tmpfolder", "mpfolder", " temporaryFolder", " tmpDir", "mpFolder", " temporaryManager", "tempDirectory", "mpDir", " temporaryDirectory", "tempManager", "mpDirectory", "tempDir", " tmpManager", "tmpDir", " temporaryfolder", "tempFolder", " tmpDirectory", "tmpDirectory", "tmpfolder"], "zip": ["pkg", "temp", "job", "feed", "copy", "cf", "lock", "ie", "json", "slice", "py", "z", "clip", "fp", "flow", "zone", "Zip", "bag", "cop", "wrap", "source", "ce", "jar", "proxy", "seed", "lib", "ress", "upload", "ulp", "pipe", "file", "archive", "ignore", "flat", "tmp", "ip", "p", "folder", " zipper", "gz", "io", "lex", "ze", "pack", " ZIP", "ipped", "sl", "url", "xml", "f", "download", "install"], "out": ["path", "info", "base", "loader", "temp", "ex", "output", "copy", "user", "plain", "OUT", "socket", "z", "result", "outs", "o", "child", "line", "flow", "write", "is", "in", "sync", "client", "source", "cache", "connection", "upload", "parent", "file", "page", "object", "log", "null", "gen", "conn", "again", "gz", "box", "Out", "io", "writer", "a", "url", "flush", "obj", "err", "os", "f", "cli", "this", "download"]}}
{"id1": "19307120", "id2": "22801734", "code1": "    public static String sendPost(String url, String param) {\n        String result = \"\";\n        try {\n            URL httpurl = new URL(url);\n            HttpURLConnection httpConn = (HttpURLConnection) httpurl.openConnection();\n            httpConn.setRequestProperty(\"Accept-Language\", \"zh-CN\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            PrintWriter out = new PrintWriter(httpConn.getOutputStream());\n            out.print(param);\n            out.flush();\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n            in.close();\n        } catch (Exception e) {\n            MsgPrint.showMsg(e.getMessage());\n        }\n        return result;\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 0, "substitutes": {"sendPost": ["postpost", "executeSub", "doPost", "executePost", "executePOST", "sendpost", "postPOST", "postSub", "dopost", "executepost", "doSub", "doPOST", "sendPOST", "sendSub", "postPost"], "url": ["string", "path", "ssl", "address", "base", "remote", "server", "uri", "resource", "feed", "http", "html", "l", "host", "location", "URL", "source", "connection", "file", "route", "page", "ll", "ls", "name", "link", "full", "sl", "Url", "bug", "www", "ur", "hub", "service", "api", "loc"], "param": ["string", "path", "address", "base", "info", "temp", "input", "resource", "output", "arm", "Parameter", "patch", "arg", "query", "extra", "password", "params", "ram", "part", "source", "proc", "connection", "prom", "par", "config", "data", "channel", "page", "object", "p", "name", "meter", "comment", "question", "Param", "error", "phrase"], "result": ["reason", "string", "buffer", "output", "response", "resource", "user", "results", "report", "res", "message", "json", "description", "current", "answer", "match", "ret", "grade", "extra", "params", "true", "load", "expected", "date", "value", "our", "default", "feature", "work", "data", "request", "msg", "test", "status", "home", "runner", "success", "array", "function", "comment", "err", "Result", "found", "error", "valid"], "httpurl": ["baseURL", "baseUrl", "workconn", "httpcf", "workurl", "httpconn", "phpconn", "workcf", " httpconfig", " httpcf", "baseconfig", "phpconfig", " httpconn", "phpURL", "workURL", "baseurl", "phpcf", "httpURL", "phpUrl", "httpUrl", "phpurl", " httpUrl", "httpconfig", " httpURL"], "httpConn": ["urlConnection", " httpConnection", "perConn", "httpsConnection", " httpCon", "webConnect", "perConnect", "httpsCon", "HttpExec", "httpconn", "httpConnection", "phpConnection", "HttpCon", "Httpconn", "phpconn", "webCon", "perExec", "urlConnect", " httpExec", "urlCon", " httpconn", "httpConnect", "httpsconn", "httpsConn", "httpCon", "httpExec", "HttpConnection", "phpConn", "webConnection", "phpConnect", "webConn", "urlConn", "HttpConn", "urlconn", " httpConnect", "webconn", "HttpConnect", "perconn"], "out": ["temp", "ex", "output", "n", "copy", "plus", "outer", "user", "net", "plain", "OUT", "inner", "socket", "outs", "o", "write", "flow", "pass", "extra", "key", "password", "connection", "r", "w", "inc", "parent", "file", "h", "p", "log", "null", "conn", "init", "again", "Out", "io", "writer", "exp", "word", "dump", "prefix", "In", "flush", "b", "err", "f", "cli"], "in": ["IN", "pin", "i", "input", "id", "serv", "ini", "gin", "into", "ic", "con", "inner", "as", "ins", "s", "bin", "read", "is", "reader", "login", "min", "r", "inc", "rin", "conn", "rec", "init", "again", "re", "isin", "In", "kin", "nin", "stream", "lin", "b", "err", "ac", "cin", "inn", "f", "win", "din"], "line": ["letter", "string", "pin", "job", "i", "sel", "id", "lf", "response", "user", "entry", "continue", "message", "LINE", "character", "ge", "end", "l", "record", "key", "char", "source", "reader", "lines", "lc", "model", "str", "r", "data", "file", "text", "cl", "page", "ip", "le", "log", "row", "inline", "name", "e", "cr", "word", "link", "sl", "pe", "unit", "comment", "Line", "lin", "me", "block", "code", "cell"]}}
{"id1": "4937535", "id2": "15472181", "code1": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private InputStream getInputStream(String item) {\n        InputStream is = null;\n        URLConnection urlc = null;\n        try {\n            URL url = new URL(item);\n            urlc = url.openConnection();\n            is = urlc.getInputStream();\n            current_source = url.getProtocol() + \"://\" + url.getHost() + \":\" + url.getPort() + url.getFile();\n        } catch (Exception ee) {\n            System.err.println(ee);\n        }\n        int i = 0;\n        udp_port = -1;\n        udp_baddress = null;\n        while (urlc != null) {\n            String s = urlc.getHeaderField(i);\n            String t = urlc.getHeaderFieldKey(i);\n            if (s == null) {\n                break;\n            }\n            i++;\n            if (\"udp-port\".equals(t)) {\n                try {\n                    udp_port = Integer.parseInt(s);\n                } catch (Exception e) {\n                }\n            } else if (\"udp-broadcast-address\".equals(t)) {\n                udp_baddress = s;\n            }\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"loadProperties": ["getproproperties", "loadprops", "loadPperties", "getProperties", "loadPropertyperties", "loadPropertyproperty", "loadProproperty", "getProps", "loadproperties", "loadproproperty", "getproperties", "loadPps", "getproproperty", "loadproproperties", "getProproperties", "loadPproperty", "loadProps", "loadPropertyps", "loadProproperties", "loadPropertyproperties", "getProproperty", "getprops", "loadPproperties"], "properties": ["info", "address", "pps", "limits", "settings", "results", "perties", "resources", "gets", "table", "features", "posts", "styles", "reports", "pb", "fixes", "parts", "params", "fps", "lines", "bugs", "ports", "pro", "objects", "options", "plugins", "ips", "object", "groups", "prototype", "style", "ls", "tests", "types", "details", "notes", "values", "ils", "prop", "obj", "rules", "events", "ps", "utils", "beans", "os", "property"], "url": ["article", "path", "string", "base", "class", "loader", "i", "event", "server", "resource", "uri", "buffer", "address", "user", "entry", "http", "instance", "l", "URL", "in", "client", "source", "reader", "connection", "not", "r", "data", "file", "channel", "page", "object", "bel", "ls", "name", "image", "sl", "Url", "b", "xml", "f", "gl", "element", "org", "api"]}}
{"id1": "7276377", "id2": "14783950", "code1": "    public static String checksum(URL url, String algorithm) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(algorithm);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex);\n        }\n        byte[] bytes = new byte[4 * 1024];\n        try {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                int nBytesRead = 0;\n                while ((nBytesRead = in.read(bytes)) > 0) {\n                    messageDigest.update(bytes, 0, nBytesRead);\n                }\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm);\n        }\n        byte[] checksumValue = messageDigest.digest();\n        return digestAsString(checksumValue);\n    }\n", "code2": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "label": 0, "substitutes": {"checksum": ["decums", " checksums", " checksumb", "checksums", "ckssum", "decum", "cksumb", "decsum", "checksumb", "decumb", " checkssum", "cksum", "cksums", "checkssum"], "url": ["string", "path", "address", "ssl", "loader", "base", "server", "uri", "feed", "username", "resource", "user", "id", "http", "filename", "location", "host", "l", "URL", "fr", "manager", "email", "rule", "source", "proxy", "connection", "str", "config", "file", "text", "src", "ll", "href", "or", "name", "image", "sl", "Url", "stream", "ur", "gl", "f", "cert", "service", "download", "loc"], "algorithm": [" algo", "malgebra", "Alignment", "ALgo", " alignment", "allgorithm", " algorith", "malgorith", "exgebra", "malgorithm", "allgo", "exgo", "algo", "algorith", "ALgorith", "allgebra", "exgorithm", "Algo", "exgorith", "ALgebra", "algebra", "malgo", "alignment", "Algebra", " algebra", "Algorithm", "ALgorithm", "allgorith", "Algorith", "malignment"], "messageDigest": ["MessageDigpe", "messageSignse", "MessageMixpe", "MessageDiger", "MessageDester", "MessageDade", "MessageDigester", "MessageDigade", "messageDigpe", "messageRegator", "messagedigess", "MessageDigse", "MessageDigge", "messageDigse", "messagedigest", "MessageDesignator", "messagediger", "MessageDigator", "messagedigester", "messageDer", "messageDse", "messageDigester", "MessageSignge", "MessageDest", "messagedigse", "messageDigade", "messageDpe", "messagedigge", "messageDigess", "MessageDesignest", "MessageMixer", "MessageSignse", "messageRegester", "messageDiger", "messageMixest", "MessageSignest", "messagedigpe", "messageDest", "messageRegess", "messageDester", "messageDesigness", "messageSignester", "MessageDesignester", "messagedigator", "messageMixer", "messageMixpe", "MessageSignester", "messageDge", "messageDigator", "messageMixester", "MessageDigess", "MessageDigest", "MessageMixester", "MessageDesigness", "messageDesignator", "messageDigge", "messageRegest", "messagedigade", "MessageMixest", "messageSignge", "messageDesignester", "messageDesignest", "MessageDse", "messageSignest", "messageDade"], "bytes": ["zip", "buffer", "bles", "limits", "pages", "pieces", "gets", "tes", "resources", "outs", "steps", "bs", "reads", "errors", "items", "parts", "lines", "blocks", "bps", "loads", "eps", "classes", "vals", "objects", "ips", "size", "es", "frames", "Bytes", "resses", "ls", "ones", "vs", "seconds", "cells", "rows", "files", "values", "ipes", "words", "units", "os", "bits", "boot"], "in": ["IN", "impl", "ssl", "i", "input", "ex", "n", "fe", "token", "serv", "ini", "id", "gin", "con", "c", "socket", "as", "inner", "version", "l", "ins", "s", "fr", "bin", "is", "client", "reader", "source", "login", "min", "r", "inc", "data", "file", "out", "rin", "gen", "init", "conn", "again", "m", "isin", "In", "nin", "kin", "a", "stream", "b", "ac", "err", "inn", "f", "win", "din"], "nBytesRead": ["nPartsLoad", "nByteLength", "nFramesRead", " nBytesLoad", "nBytesLength", "nFramesLength", " nBytesWritten", "nPagesLength", "nPagesWritten", "nBytesWritten", "nWordsCount", "nPagesRead", "nByteWritten", "nWordsWritten", "nByteFound", "nByteRead", "nWordsRead", " nByteLoad", "nCharactersRead", " nByteWritten", "nWordsLength", " nByteFound", " nBytesCount", "nCharactersCount", "nPartsRead", "nByteCount", "nCharactersWritten", "nBytesFound", " nByteRead", "nFramesWritten", "nPagesFound", "nBytesCount", "nPartsWritten", " nByteLength", "nByteLoad", " nByteCount", " nBytesLength", "nBytesLoad", "nCharactersLength", "nFramesFound", " nBytesFound"], "checksumValue": ["checksumPath", "checksupString", "checksumberValue", " checksumText", " checkssumPath", "checksummPath", "checkssumText", "checksupData", "checksumberText", " checkssumValue", " checkssumText", "checksramVal", " checkssumArray", " checkssumVal", "checksumString", "checkssumData", "checksumberString", "checksumVal", " checksumVal", "checksummVal", "checksummValue", " checksumString", " checksumPath", "checksupValue", "checksumberData", " checksumArray", "checksumData", "checksupText", " checkssumString", "checksummArray", "checkssumArray", " checkssumData", "checkssumValue", " checksumData", "checksramPath", "checkssumVal", "checksumText", "checksumArray", "checksramValue", "checksramArray", "checkssumString", "checkssumPath"]}}
{"id1": "7468827", "id2": "21016435", "code1": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "code2": "    private String getFullScreenUrl() {\n        progressDown.setIndeterminate(true);\n        System.out.println(\"Har: \" + ytUrl);\n        String u = ytUrl;\n        URLConnection conn = null;\n        String line = null;\n        String data = \"\";\n        String fullUrl = \"\";\n        try {\n            URL url = new URL(u);\n            conn = url.openConnection();\n            conn.setDoOutput(true);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            while ((line = rd.readLine()) != null) {\n                if (line.contains(\"fullscreenUrl\")) {\n                    data = line.trim();\n                }\n            }\n            rd.close();\n            System.out.println(data);\n            int start = 0;\n            String[] lines = data.split(\"&\");\n            String[] tmp = null;\n            String video_id = null;\n            String t = null;\n            String title = null;\n            for (int i = 0; i < lines.length; i++) {\n                if (lines[i].startsWith(\"video_id=\")) {\n                    tmp = lines[i].split(\"=\");\n                    video_id = tmp[1];\n                }\n                if (lines[i].startsWith(\"t=\")) {\n                    tmp = lines[i].split(\"=\");\n                    t = tmp[1];\n                }\n                if (lines[i].startsWith(\"title=\")) {\n                    tmp = lines[i].split(\"=\");\n                    title = tmp[1].substring(0, (tmp[1].length() - 2));\n                }\n                System.out.println(lines[i]);\n            }\n            System.out.println(\"So we got...\");\n            System.out.println(\"video_id: \" + video_id);\n            System.out.println(\"t: \" + t);\n            System.out.println(\"title: \" + title);\n            ytTitle = title;\n            fullUrl = \"http://www.youtube.com/get_video.php?video_id=\" + video_id + \"&t=\" + t;\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getLocalizedMessage());\n        }\n        progressDown.setIndeterminate(false);\n        return fullUrl;\n    }\n", "label": 0, "substitutes": {"run": ["close", "execute", "server", "resource", "loop", "running", "login", "build", "work", "open", "check", "web", "get", "submit", "test", "start", "exec", "runner", "call", "url", "update", "create", "Run", "process", "download", "stop"], "con": ["close", "fun", "Conn", "fe", "ex", "fa", "CON", "cf", "rc", "clean", "cons", "http", "ran", "on", "plain", "c", "socket", "fc", "ctrl", "sub", "Con", "co", "en", "client", "cp", "ocon", "uc", "connection", "login", "ob", "open", "conv", "un", "ca", "out", "file", "cl", "web", "conn", "init", "exec", "don", "pc", "ver", "bc", "url", "com", "can", "conf", "cn", "connect", "cur", "re"], "encodedPassword": ["enoderpassword", "encoderPass", "encapedData", "EncodedPassword", "enodedData", "encoderData", "enodedPassword", "encryptedpassword", "encodedData", "EncodedPass", "EncryptedSecret", "encodedPass", "encryptedPassword", "EncryptedPass", "enccodedPass", "enoderPassword", "enccodedPassword", "encodedSecret", "encodedpassword", "encapedPassword", "encryptedPass", "encoderSecret", "EncodedSecret", "Encryptedpassword", "encapedPass", "enodedPass", "encryptedSecret", "encapedpassword", "encryptedData", "enoderPass", "EncryptedPassword", "enoderData", "enodedpassword", "enccodedpassword", "encoderPassword", "enccodedSecret", "Encodedpassword", "encoderpassword"], "encoder": ["decoded", "decoder", "enoder", "Encoded", "Encoder", " encoding", " encode", "encode", "decoding", "Encoding", "enoded", "enoding", "enode", " encoded", "decode", "Encode", "encoded", "encoding"], "in": ["IN", "pin", "i", "input", "ini", "gin", "c", "socket", "inner", "as", "ins", "bin", "pass", "is", "reader", "source", "login", "inc", "vin", "out", "rin", "file", "conn", "init", "again", "cgi", "io", "isin", "In", "nin", "kin", "url", "lin", "b", "cin", "inn", "f", "win", "din"], "fos": [" faos", "bis", " foos", "infoses", "infoos", "lfOS", "dos", "boes", "foos", "doss", "lfis", "lfoes", " foses", "infos", "infOS", "FOS", "Foos", "foss", " foss", "bos", " fose", " fOS", "Foss", "lfos", "foses", "Fos", "doses", " foes", "bOS", "infose", "fose", " fis", "daos", "Fose", "Foses", "fOS", "faos", "foes", "Faos", "fis", "infoss"], "bout": ["bOut", " b4", "b4", "bbout", "bbouter", " bin", "bin", "f4", " bouts", "bouter", "fin", " bio", "Bin", "Bout", "bouts", "bio", "fouter", " bcache", " bouter", "bbouts", "bb4", "fio", "bbOut", "bcache", "bbcache", "fouts", "bbio", "BOut", "Bio", "fout", "Bcache", "bbin", " bOut"], "data": ["zip", "string", "xxxx", "buffer", "address", "input", "i", "feed", "response", "info", "video", "message", "number", "result", "length", "memory", "read", "key", "alpha", "content", "xxx", "raw", "next", "part", "one", "reader", "d", "cache", "value", "media", "DATA", "div", "sample", "batch", "body", "size", "start", "image", "bytes", "partial", "pad", "block", "zero", "dat"], "x": ["val", "index", "max", "i", "num", "id", "n", "ex", "xx", "c", "z", "X", "number", "wx", "en", "xxx", "xp", "no", "d", "w", "my", "xs", "xc", "p", "size", "u", "m", "rx", "t", "pos", "xy", "lex", "xi", "pe", "v", "y", "b", "wa", "dx", "f", "width", "tx", "fx", "code", "ix", "ww"], "lastIteraction": ["prevGenerATION", "prevGenerate", "lastIterAction", "lastGenerAction", "lastExecation", "lastExecATION", "lastGenerate", "lastGenerATION", "prevGenerAction", "lastIteration", "prevIteration", "lastExecAction", "prevIterAction", "lastGeneration", "prevGeneration", "prevIterate", "lastExecate", "lastIterate", "lastIterATION", "prevIterATION"], "e": ["ise", "event", "ite", "i", "fe", "ee", "n", "element", "ke", "be", "ure", "ie", "c", "ge", "o", "se", "s", "ception", "er", "edge", "type", "no", "d", "one", "r", "g", "exc", "p", "es", "ae", "u", "or", "ne", "E", "t", "ze", "it", "a", "pe", "me", "b", "f", "error", "oe", "this", "re", "esi"]}}
{"id1": "13657527", "id2": "742465", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"getDatasetsList": ["getDatasenciesSearch", "getDatAsetlist", "getDatAsetList", "getDatasuresSearch", "getDatasetsSearch", "getDatasetslist", "getDatasencieslist", "getDatAsetSearch", "getDatasetSearch", "getDatasetList", "getDatasuresList", "getDatAsetslist", "getDatasureslist", "getDatasenciesList", "getDatAsetsList", "getDatasetlist", "getDatAsetsSearch"], "surl": ["slrule", "ssl", "slog", "ssuri", "slayer", "wslayer", "suri", "slurl", "sinlog", "sfeed", "osuri", "SUrl", "sURL", "shttp", "Srule", "Shttp", "ossl", "turi", " sURL", "sesfile", "turl", "sUrl", "dlayer", "osfile", "wsuri", "Slog", "ssfile", "osurl", " sUrl", "Sfeed", "srule", "Surl", "sinurl", "wssl", "sesurl", "jsuri", "jssl", "sinrule", "nsjob", "SURL", "lsURL", " shttp", "sesjob", "sesuri", "duri", "lsUrl", "lshttp", "durl", "dsuri", "sinfeed", "wsurl", "nsuri", "lsurl", "slfeed", "sjob", "dsurl", "dssl", "jsurl", "nsurl", "tsl", "ssurl", "sllog", "jslayer", "nsfile", "dsfile", "ssjob", "dsl", "sfile", "tfile"], "datasetsList": ["datastersString", "dataselineslist", "datasetsString", "datrasETSList", "datastersList", "datascencesString", "datasitesMap", "datrasetslist", "datascetsString", "datasETSTable", "datasetList", "datasencesCollection", "datascetsCollection", "datrasuresMap", "datasencesList", "datassetsL", "dataselinesMap", "datasETSList", "datassetsPool", "datetetsList", "datasETSL", "datassetsCollection", "dataschesMap", "dataselinesTable", "datasencesMap", "dataschesList", "datrasureslist", "datassETSList", "datasitesList", "datasetslist", "datrasetsTable", "datasitesL", "datasagesMap", "datascetsMap", "datascheslist", "datasuresL", "datasuresCollection", "datassETSMap", "datassetsList", "datasureslist", "datrasETSTable", "datassETSCollection", "dataselinesList", "datrasetsL", "datasETSPool", "datetsetsMap", "datascencesList", "datrasetsMap", "datascencesCollection", "datastersMap", "datasagesPool", "datetetslist", "datasiteslist", "datasetsMap", "datrasetsList", "datetetsL", "datasuresMap", "datasETSlist", "datasetsCollection", "datasetL", "datasagesList", "datetsetsL", "datetsetsList", "datassetsMap", "datasetsL", "datascencesMap", "datasetsTable", "datetetsMap", "dataschesTable", "datasetsPool", "datascetsList", "datastersCollection", "datasagesCollection", "datrasETSlist", "datassetslist", "datasuresList", "datassETSPool", "datasETSCollection", "datrasuresList", "datasETSMap", "datasetlist", "datetsetslist", "datrasuresL", "datasencesString", "datasuresString", "datasetMap", "datrasETSMap"], "result": ["event", "info", "resource", "response", "rc", "user", "entry", "report", "res", "results", "message", "ge", "inner", "end", "instance", "match", "record", "fr", "ret", "part", "load", "rule", "ner", "r", "default", "page", "request", "rar", "row", "test", "status", "card", "runner", "success", "comment", "Result", "found", "repl", "re", "valid"], "reader": ["ssl", "handler", "loader", "i", "input", "server", "buffer", "feed", "editor", "reading", "her", "builder", "entry", "http", "resource", "slice", "per", "inner", "older", "lr", "l", "driver", "dr", "keeper", "read", "iter", "ler", "er", "oder", "ner", "r", "ger", "parser", "file", "rar", "row", "rr", "rer", "io", "writer", "rx", "runner", "worker", "layer", "cher", "ser", "stream", "roller", "over", "err", "upper", "Reader"], "url": ["string", "ssl", "buffer", "loader", "base", "address", "server", "uri", "resource", "feed", "user", "entry", "http", "socket", "lr", "l", "driver", "URL", "iter", "client", "source", "rule", "connection", "browser", "str", "file", "page", "bel", "ll", "log", "io", "image", "sl", "Url", "stream", "ur", "b", "f", "hub", "element", "service"], "s": ["services", "string", "ssl", "i", "server", "spec", "n", "site", "ns", "comments", "S", "o", "l", "ins", "abs", "line", "si", "su", "is", " lines", "rs", "ings", "sync", "less", "ws", "source", "lines", "sb", "strings", "ops", "r", "str", "p", "es", "search", "u", "ls", "js", "e", "sets", "t", "ss", "details", "sl", "ses", "b", "ds", "words", "os", "ps", "f"], "list": ["val", "letter", "string", "base", "server", "entry", "table", "join", "l", "set", "all", "record", "pl", "el", "key", "queue", "la", "LIST", "type", "load", "lc", "str", "default", "listed", "collection", "data", "li", "cl", "ll", "null", "lists", "test", "ls", "coll", "chain", "array", "ml", "bl", "left", "ul", "and", "batch", "view"]}}
{"id1": "20181656", "id2": "21092340", "code1": "    private int[] sortRows(int[] rows) {\n        for (int i = 0; i < rows.length; i++) {\n            for (int j = 0; j < rows.length - 1; j++) {\n                if (rows[j] > rows[j + 1]) {\n                    int temp = rows[j];\n                    rows[j] = rows[j + 1];\n                    rows[j + 1] = temp;\n                }\n            }\n        }\n        return rows;\n    }\n", "code2": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "label": 0, "substitutes": {"sortRows": ["sortLRow", "ortLows", "sortSlows", "sortPows", "sortSlOWS", "ortRrows", "sortLOWS", "sortProws", "sortPRow", "ortROWS", "sortSlrows", "sortLows", "ortRRow", "sortLrows", "ortLOWS", "ortLRow", "sortPOWS", "sortROWS", "ortLrows", "sortRrows", "sortSlRow", "sortRRow", "ortRows"], "rows": ["keys", "tracks", "maps", "uds", "index", "headers", "checks", "results", "pages", "docs", "ks", "vers", "slice", "posts", "result", "grid", "roads", "rank", "errors", "cases", "shows", "rs", "ids", "raw", "items", "projects", "users", "flows", "ros", "blocks", "lines", "builders", "diff", "ports", "runs", "members", "orders", "points", "roots", "ows", "grades", "ends", "models", "ips", "breaks", "row", "forms", "boards", "groups", "frames", "rss", "tests", "cells", "holes", "ss", "rooms", "array", "types", "values", "files", "relations", "fields", "rates", "right", "acks", "rules", "heads", "multi", "views", "times"], "i": ["index", "id", "pi", "ij", "ind", "c", "z", "ri", "l", "si", "ui", "ii", "ji", "phi", "li", "ip", "x", "p", "mi", "bi", "u", "ai", "ci", "I", "m", "io", "xi", "ix", "a", "ki", "b", "v", "y", "iu", "f", "ik"], "j": ["index", "job", "uj", "n", "ij", "dj", "json", "jc", "ind", "z", "o", "jl", "l", "jo", "fr", "ui", "ii", "key", "aj", "next", "qi", "ja", "ji", " dj", "d", "jan", "q", "li", "h", "x", "p", "u", "jj", "J", "js", "e", "jp", "ix", "k", "b", "y", "v", "jit", "obj", "br", "oj", "adj", "f", "ik"], "temp": ["index", " tmp", "max", "tc", "id", "n", "input", "pre", "tem", "z", "col", "Temp", "flow", "shift", "extra", "iter", "offset", "except", "cache", "diff", " Temp", "parent", "needed", "flat", "tmp", "fake", "emp", "ip", "empty", "get", "null", "test", "dev", "stable", "area", "circ", "k", "unit", "partial", "v", "err", "this", "orig", "cell"]}}
{"id1": "804637", "id2": "9846843", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRebwrite", "readAndRebrap", "readAndRewwrite", "readAndSwrap", "readAndrewwrite", "readAndRebrite", "readandRewrap", "readandRewrites", "readAndSwwrite", "readandrewrap", "readAndRewrap", "readAndSwrite", "readandrewrites", "readandrewwrite", "readAndRebrites", "readAndRewrites", "readAndrewrite", "readAndSwrites", "readandrewrite", "readAndrewrites", "readAndrewrap", "readandRewwrite", "readandRewrite"], "inFile": [" inSourceFile", "InSourceFile", "oldfile", "outSourceFile", "inputfile", "outfile", " inFiles", "inputFilename", "InFiles", " infile", "infile", "inputFile", "outFiles", "oldFile", "loginFile", " inFilename", "Infile", "inFiles", "inputFiles", "oldFiles", "loginFilename", "loginfile", "loginFiles", "InFile", "oldFilename", "outFilename", "inFilename", "inSourceFile"], "outFile": ["newfile", "outDir", "OutStream", "processFile", "outputFilename", "exFilename", "outputfile", " outfile", "outPlace", "outFILE", "outputFILE", "outfile", "processFilename", "offFILE", "outputPlace", "thisFilename", "outStream", "thisFile", "processPlace", "exfile", "thisFILE", "newDir", "exFILE", "OutDir", "exFile", "processFILE", "newStream", "offPlace", "OutFile", " outStream", "outFilename", "offFilename", "Outfile", " outDir", "outputFile", "newFile", "thisfile", "offFile"], "iis": ["iIS", "Iais", "iIs", "iiris", "iniIs", "iiiss", "iais", "Iis", "ciis", "iiis", " iIs", " iIS", " iais", "ciiss", "Iiss", "ciais", " iiss", "iiss", "iiIS", "iniiss", " iris", "iniis", "ciris", "iniIS", "iniris", "IIS", "iris", "iiIs", "ciIS", "ciIs"], "dcmParser": ["dbmPolicy", "dbmParser", "dmmLoader", "dmissionParser", "dcmInstallation", "dmoduleJar", "dpmLoader", "dmoduleparser", "dhemReader", "dkmParser", "dmissionLanguage", "dCMPlugin", " dpmparser", " dcrParser", "fpmparser", "dhemJar", " dpmPolicy", "dkmPolicy", "dpmParser", "dcmPolicy", "dmissionPlugin", " dcmarser", "dmmPlugin", " dcrPlugin", "DcmInstallation", " dcmLanguage", "dpmHandler", "dmcJar", "dkmPlugin", " dpmParser", "dmoduleReader", " dcrLoader", "fcmReader", "dmissionReader", "dcrParser", "dmcarser", "dbmHelper", "dmLoader", "fpmHandler", "dcrarser", "dhemInstallation", "dmcParser", "dmmparser", "dpmLanguage", "dmodulePlugin", " dcmPolicy", "dpmarser", "dpmReader", "dcmPar", "dpmPar", "dmReader", "dcmparser", "dcrLoader", "dmParser", " dcmLoader", " dcmReader", "fcmparser", "dpmPolicy", "dcrJar", "dcmPlugin", "dpmparser", "fpmReader", "dcmarser", " dpmPlugin", "dbmPlugin", "dpmPlugin", " dpmHelper", "dCMLoader", " dpmLoader", " dpmJar", "dmoduleParser", " dcrReader", "dcmLoader", "fcmParser", "dpmHelper", "dcmReader", " dpmPar", "dCMHandler", "dmPlugin", "dcmJar", "dcrPlugin", "dpmJar", " dcmJar", "fcmHandler", " dcmHelper", "dCMparser", "dcrPar", "DcmParser", " dcmPar", "dcrReader", "fpmParser", " dpmReader", " dcmparser", "dmcPar", " dpmLanguage", "dcmHelper", "dpmInstallation", "dcmHandler", "dCMParser", "dcmLanguage", "dmmParser", "DcmReader", "dCMReader", "dkmHelper", " dcmPlugin", "DcmJar", "dhemParser", " dpmarser"], "ds": ["services", "ys", "uds", "ays", "DS", "iss", "gd", "sys", "Os", "df", "ants", "ns", "tes", "ks", "drivers", "qs", "bs", "s", "ins", "dr", "is", "dc", "rs", "ld", "dt", "parts", "cdn", "sync", "session", "ws", "d", "ros", "eps", "points", "icks", "ads", "data", "gs", "src", "xs", "utils", "vals", "ras", "Ds", "des", "ts", "conn", "vs", "ls", "js", "ss", "db", "ils", "di", "nas", "details", "amps", "Db", "da", "asi", "cs", "dds", "ps", "os", "dat", "pd", "dd", "tx"], "pdReader": ["hdRunner", "pbRunner", "pcReader", "pdRunner", "xdreader", "dsReader", "dsreader", "pbLoader", "hdReader", "hdreader", "dsLoader", "pcLoader", "pbStream", "hdStream", "ddStream", "pcRead", "xdWriter", "ddLoader", "pdLoader", "pdStream", "ddRunner", "pbReader", "hdWriter", "dsRead", "dsWriter", "xdRead", "pcWriter", "xdReader", "hdRead", "hdLoader", "ddReader", "pdreader", "pdRead"], "out": ["ssl", "base", "temp", "output", "net", "as", "s", "in", "at", "lib", "model", "default", "file", "gen", "conn", "Out", "url", "obj", "with", "external", "point", " in", "outer", "ex", "sys", "lock", "builder", "result", "later", "sync", "part", "cache", "up", "oder", "connection", "w", "parent", "store", "page", "object", "device", "again", "name", "exec", "exp", "array", "full", "over", "list", "order", "inner", "outs", "o", "line", "flow", "co", "write", "password", "session", "doc", "diff", "group", "director", "null", "dev", "io", "writer", "image", "to", "word", "cli", "term", "auto", "her", "copy", "user", "OUT", "child", "manager", "pass", "key", "client", "dot", "login", "inc", "down", "data", "db", "layer", "ext", "err", "code", "img"], "dcmEncParam": ["dcmEnParam", "dcmEstParam", "dcmDecParam", "dcmEnParameter", "dcmSecPart", "dcmDecType", "dcmDecPar", "dcmEncType", "dcmEncParameter", "dcmArchParam", "dcmEncPart", "dcmElParameter", "dcmEnPar", "dcmEnPart", "dcmDecArg", "dcmArchArg", "dcmArchParameter", "dcmSecPar", "dcmEnArg", "dcmDecParameter", "dcmDecPart", "dcmSecType", "dcmElParam", "dcmEstPar", "dcmEncPar", "dcmSecParam", "dcmElPar", "dcmEncArg", "dcmElType", "dcmEnType", "dcmEstType", "dcmEstParameter"], "pdWriter": ["dpWrite", "pdOutput", "ddWrite", "pdWriting", "htWriter", "dpReader", "dsReader", "hdReader", "pdWrite", "htWriting", "dpWriting", "PDWrite", "dpWriter", "hdWriter", "dsOutput", "dsWriter", "hdWrite", "htWrite", "PDWriter", "dsWrite", "ddOutput", "PDReader", "ddReader", "htReader", "PDWriting", "ddWriter", "hdOutput"]}}
{"id1": "8942491", "id2": "17773263", "code1": "    public static URLConnection openProxiedConnection(URL url) throws IOException {\n        if (proxyHost != null) {\n            System.getProperties().put(\"proxySet\", \"true\");\n            System.getProperties().put(\"proxyHost\", proxyHost);\n            System.getProperties().put(\"proxyPort\", proxyPort);\n        }\n        URLConnection cnx = url.openConnection();\n        if (proxyUsername != null) {\n            cnx.setRequestProperty(\"Proxy-Authorization\", proxyEncodedPassword);\n        }\n        return cnx;\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 0, "substitutes": {"openProxiedConnection": ["openProXifiedConnection", "openProxifiedConnection", "openProxiesConnection", "openProxiedconnection", "openProxifiedApplication", "openProxedApplication", "openProXiedconnection", "openProxiedConn", "openProxifiedconnection", "openProxifiedConn", "openProXiedConn", "openProxedConnection", "openProxedConn", "openProXiedConnection", "openProXifiedApplication", "openProxiesApplication", "openProxiedApplication", "openProXifiedconnection", "openProXifiedConn", "openProxiesconnection", "openProxiesConn", "openProXiedApplication", "openProxedconnection"], "url": ["string", "base", "address", "ssl", "class", "i", "server", "uri", "resource", "loader", "user", "http", "socket", "system", "lr", "l", "host", "URL", "client", "source", "proxy", "connection", "browser", "str", "config", "file", "page", "object", "web", "u", "io", "sl", "Url", "www", "obj", "b", "f", "gl", "this", "service", "api"], "cnx": ["nw", "lcex", "cnn", "CNw", "CNx", "cdnx", "connx", "nn", "CNNw", "cdnc", "gnex", "cnxes", "cnw", "cnX", "cnf", "gnx", "connex", "lcn", "gnn", "connX", "CNNb", "CNNn", "lcxes", "gnX", "nx", "lcx", "nb", "lcX", "CNn", "CNNx", "cdnf", "connxes", "CNb", "gnxes", "gnc", "cnex", "cnb", "cdnn", "lcf", "cnc", "gnf", "lcc"]}}
{"id1": "1133123", "id2": "2982747", "code1": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "code2": "    public FileParse(String fileStr, String type) throws MalformedURLException, IOException {\n        this.inFile = fileStr;\n        this.type = type;\n        System.out.println(\"File str \" + fileStr);\n        if (fileStr.indexOf(\"http://\") == 0) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"File\")) {\n            File inFile = new File(fileStr);\n            size = inFile.length();\n            inStream = new FileInputStream(inFile);\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URL\")) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URLZip\")) {\n            URL url = new URL(fileStr);\n            inStream = new GZIPInputStream(url.openStream(), 16384);\n            InputStreamReader zis = new InputStreamReader(inStream);\n            bufReader = new BufferedReader(zis, 16384);\n        } else {\n            System.out.println(\"Unknown FileParse inType \" + type);\n        }\n    }\n", "label": 0, "substitutes": {"openConnection": ["openChannel", "closeConnect", "closeConnection", "OpenConnect", "createConnector", "createConn", "closeConnector", "OpenConnection", "openConnect", "createConnection", "OpenConnector", "OpenChannel", "closeChannel", "closeConn", "OpenConn", "openConn", "openConnector", "createChannel", "createConnect"], "url": ["path", "address", "buffer", "ssl", "base", "server", "uri", "resource", "id", "http", "limit", "l", "host", "location", "URL", "el", "iter", "source", "proxy", "connection", "str", "config", "data", "file", "channel", "options", "bel", "ll", "object", "log", "null", "name", "image", "link", "sl", "Url", "f", "this", "service", "loc"]}}
{"id1": "2936678", "id2": "15500892", "code1": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"getUniqueKey": ["getStringLink", "getuniqueLink", "makeUniqueLink", "makeuniquekey", "makeuniqueLink", "getUniqueHash", "getuniqueKey", "getUniquekey", "getPrimarykey", "getUniqueLink", "getStringHash", "getStringKey", "getPrimaryLink", "makeUniquekey", "makeuniqueKey", "makeuniqueHash", "getPrimaryHash", "getuniqueHash", "makeUniqueHash", "getuniquekey", "makeUniqueKey", "getStringkey", "getPrimaryKey"], "digest": ["longested", "Digester", "DigEST", "dested", "genit", "dest", " digested", "longEST", "digit", "dests", "uuester", "Digests", "Digid", "genEST", "digester", "digests", "digested", "Digit", "dester", "Digest", "uuest", "longest", "uuid", "uuEST", "digid", " digEST", " digester", "genest", " digests", "Digested", "longester", " digit", " digid", "digEST"], "md": ["ud", "gd", "mag", "bd", "df", "od", "Cmd", "amd", "mo", "med", "ma", "meta", "wd", "MD", "dc", " MD", "ld", "sm", "ad", "rpm", "gb", "mb", "mt", "dh", "mac", "d", "mp", "hd", "pm", "pd", "sd", "de", "mm", " dd", "nd", "metadata", "cd", "gen", "dig", "m", "hm", "km", "dm", "grad", "mand", "mc", "nm", "alg", "mn", "v", "vd", "mg", "mad", "cmd", "dd", "hash"], "timeVal": ["rateValue", "rateVal", "TimeBu", "rateBu", "TimeVal", "timeBu", "timeSeries", "TIMEVal", "timeValue", "TimeValue", " timeValue", "timeval", " timeSeries", "rateLen", "TIMEValue", "timeLen", "TimeLen", "TimeSeries", "TIMESeries", "TIMEval", " timeLen", " timeval", " timeBu", "Timeval"], "localHost": ["remotehost", "LocalAddress", "remotePort", "LocalHost", " localMac", " localPort", "remoteMac", " localhost", "LocalPort", "privateAddress", "privatePort", "localAddress", "remoteAddress", "localMac", "remoteHost", "Localhost", "localPort", "localhost", "LocalMac", " localAddress", "privateHost", "privatehost"], "randVal": ["RandBu", "randomStr", " randLen", "randomval", "randStr", "RandomLen", "randval", "randValue", "RandStr", "randomLen", " randValue", " randStr", "Randomval", "RandomValue", "randomVal", "RandomVal", "RandValue", "randomValue", "RandVal", "randLen", "randomBu", " randBu", "randBu", " randval"], "val": ["string", "base", "sel", "temp", "id", "vol", "enc", "res", "ind", "ref", "result", "el", "ret", "key", "gb", "valid", "pr", "live", "value", "buf", "pm", "data", "vals", "x", "format", "test", "msg", "dev", "addr", "az", "grad", "db", "sl", "rev", "values", "update", "abc", "unit", "seq", "v", "reg", "range", "bl", "Val", "pt", "VAL", "eval", "loc"]}}
{"id1": "8069594", "id2": "665420", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"copyFile": ["transferFolder", " copyfile", " copiedFile", " copiedFolder", " copiedFiles", "copyfile", " copiedfile", "transferfile", "copyFolder", " copyFiles", " copyFolder", "transferFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "base", "pin", "i", "input", "id", "ex", "lock", "ic", "inner", "as", "ins", "bin", "part", "at", "reader", "source", "up", "login", "min", "old", "diff", "inc", "work", "data", "file", "config", "x", "null", "or", "name", "again", "m", "exec", "image", "io", "it", "In", "a", "url", "err", "inn", "win", "this", "din"], "out": ["base", "ex", "output", "n", "server", "outer", "user", "plus", "plain", "version", "OUT", "c", "outs", "o", "all", "off", "write", "bin", "line", "outside", "at", "one", "source", "up", "not", "target", "old", "inc", "file", "object", "x", "p", "null", "conn", "about", "name", "again", "exec", "Out", "io", "writer", "image", "to", "ext", "update", "v", "err", "b", "vert", "this", "external"], "inChannel": ["binStream", "inputChannel", "INchannel", "inStream", "inputchannel", " inClient", "binClient", "inchannel", "binChan", "outContext", "InChan", "loginChannel", "inputChan", "Inchannel", "INChan", "INClient", "outStream", "inContext", "outchannel", "inputConnection", "outChan", "inChan", "InChannel", "loginContext", "InStream", "InConnection", "inputStream", "binChannel", "INStream", " inConnection", "INChannel", " inStream", "inputContext", "inConnection", "inClient", " inChan", "loginchannel", "loginStream", "INConnection"], "outChannel": ["innerStream", "OutStream", "outputConnection", "inStream", "againChannel", "oChannel", "OutChannel", "inchannel", "oChan", "outContext", " outConnection", "againChan", "oStream", "againContext", "againConnection", "OutChan", "outStream", "inContext", "outchannel", "innerChannel", "againStream", "outChan", "inChan", "ochannel", "outputStream", "outputChannel", "innerChan", "outConnection", "Outchannel", "againchannel", "outputChan", "inConnection", " outStream", "innerContext", " outchannel", " outChan"]}}
{"id1": "10385815", "id2": "4750967", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"copy": ["zip", "Copy", "replace", "cmp", "move", "write", "clone", "split", "sync", "upload", "open", "file", "Cop", "get", "put", "delete", "exec", "change", "send", "update", " Copy", "create", "Transfer", "paste", "process", "transfer", "download"], "fileFrom": ["FileStart", "ioFrom", "FileTo", "ioSource", "FileSource", "mailFrom", "FileIn", "ioTo", "fileIn", "FileAs", " fileStart", " fileAs", "fileStart", "mailAs", " fileSource", "mailIn", "ioStart", "mailTo", "fileSource", "fileAs", "FileFrom", " fileIn"], "fileTo": [" fileFile", "fpTo", "fileTO", "FileTo", "FileFile", "fpTO", "FileTO", " fileTarget", "resourceTo", "resourceFile", "fpto", "Fileto", "FileTarget", "fileFile", "resourceTarget", "fileTarget", "fpFrom", " fileTO", "fileto", "resourceFrom", " fileto", "FileFrom"], "inputStream": ["InputContext", " inputFile", "outputSteam", "InputSync", "inputSteam", "inputSync", "inputFile", " inputSync", " inputstream", "InputFile", "outputstream", " inputSteam", "InputChannel", "outputContext", " inputContext", "inputContext", "outputSync", "Inputstream", "outputFile", "inputstream", "InputSteam", "InputStream"], "outputStream": ["inputSocket", "OutputChannel", "outputSteam", "inputSteam", "fourStreamer", "outputSocket", "fourStream", "OutputStreamer", "outputPath", "inputChan", "referenceSteam", "inputPath", "OutputSteam", "referenceSocket", "outputStreamer", "OutputStream", " outputPath", " outputStreamer", "writeChannel", "referenceChannel", "fourChannel", " outputChan", "writeSteam", "writeSocket", "writeStream", "outputChan", "OutputChan", " outputSteam", "referenceStream", "OutputPath", "fourSteam"], "inputChannel": ["parentStream", "butChan", "InputContext", "audioChannel", "inputSocket", "inputPassword", " inputCam", "outputSocket", "butContext", " inputSocket", "InputSocket", "inputChan", "butCommand", "outputPassword", "audioCam", "outputCam", " inputPassword", " inputClient", "inputClient", "InputChannel", "inputCam", "audioClient", "inputCommand", "parentPassword", "parentChannel", "butChannel", "outputClient", " inputChan", "outputCommand", "outputContext", " inputContext", "parentChan", "outputChan", "inputContext", "audioStream", "InputChan", " inputCommand", "InputStream"], "outputChannel": ["Outputchannel", "inputchannel", " outputchannel", "OutputQueue", " outputQueue", "OutputChannel", "outContext", "OutputContext", "outputQueue", "inputChan", "outStream", "outChan", "OutputStream", " outputContext", "outputchannel", " outputChan", "outputContext", "inputContext", "outputChan", "OutputChan", "inputQueue", "outChannel"]}}
{"id1": "19549577", "id2": "20073619", "code1": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "code2": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "label": 1, "substitutes": {"callApiPost": ["callAipost", "callApiPOST", "callAAPIPut", "callAiPOST", "callUiPOST", "callUpiPut", "callUpiPost", "callUiPut", "callAapiPost", "callUpiPOST", "callAAPIPost", "callAapipost", "callApipost", "callAapiPOST", "callAAPIpost", "callApiPut", "callAAPIPOST", "callUpipost", "callUiPost", "callAiPut", "callUipost", "callAapiPut", "callAiPost"], "apiUrl": ["baseURL", "APIUr", " apiUr", "baseUrl", "baseUr", "piUrl", "APIURL", "piURL", " apiPath", "apiUr", "piUr", " apiURL", "APIUrl", "apiURL", "apiPath", "piPath", "baseName", "APIPath", "apiName", "APIName", "piName"], "parameters": ["parameter", "paramsements", "ramements", "paramements", "rameters", "mandeter", "promams", "argers", "params", "paramseters", "ramels", "paramsels", "argeters", "pareters", "mandements", "pareter", "argeter", "argams", "mandels", "paramels", "rameter", "prometers", "mandeters", "paramseter", "paramams", "promers", "paramers", "prometer", "parers"], "expected": ["event", "forced", "pects", "pecting", "confirmed", "pect", "current", " unexpected", "code", "done", "failed", "reported", "ce", "after", " expect", "default", "anticipated", "needed", "fake", " expectation", "due", "seen", "style", "pretty", "example", "force", "e", " expecting", "pected", "received", "ed", "required", "err", "future", "found", "handled", "error", "actual"], "url": ["event", "string", "ssl", "address", "base", "buffer", "job", "server", "uri", "response", "resource", "user", "http", "result", "l", "host", "URL", "client", "source", "jar", "connection", "browser", "config", "file", "web", "page", "object", "log", "sl", "Url", "www", "ur", "ul", "xml", "f", "service", "api"], "request": ["base", "resource", "http", "large", "condition", "req", "friend", "rate", "q", "build", "open", "get", "hello", "worker", "xml", "external", "string", "buffer", "server", "builder", "report", "result", "driver", "press", "query", "next", "post", "use", "up", "connection", "work", "complete", "received", "pair", "over", "wheel", "service", "event", "remote", "order", "path", "rest", "job", "claim", "response", "message", "json", "per", "queue", "er", "bar", "allow", "jar", "upload", "p", "issue", "access", "create", "method", "error", "api", "enter", "view", "input", "Request", "copy", "user", "have", "project", "current", "join", "instance", "child", "client", "config", "require", "call", "pull", "pe", "right", "command", "re"], "headerName": ["headerKey", "requestString", "versionString", "headerValue", "headerString", "versionName", "headname", " headerLine", "versionname", "HeaderString", " headername", "requestLine", "headString", "HeaderName", "versionValue", "headername", "cookieLine", "headerLine", "headValue", " headerString", "cookiename", "cookieKey", "HeaderValue", "headersKey", "Headername", "headName", "requestKey", "headersLine", "requestName", "headersString", "requestname", "cookieName", "headersName", " headerKey"], "out": ["string", "info", "buffer", "temp", "console", "outer", "output", "response", "copy", "input", "builder", "report", "plain", "OUT", "inner", "socket", "result", "o", "outs", "s", "line", "write", "flow", "extra", "in", "key", "password", "raw", "client", "sync", "part", "group", "w", "data", "file", "page", "log", "null", "again", "name", "exec", "Out", "writer", "io", "dump", "flush", "stream", "err", "obj", "print", "f", "error", "external"]}}
{"id1": "6517139", "id2": "15351863", "code1": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"getPrefsKey": ["getPrefixedSecret", "getPubixedSecret", "getPubixedKey", "getPubsSecret", "getPrefixKey", "getPrefesValue", "getPubsValue", "getPrefixSecret", "getPrefesKey", "getPrefsValue", "getPrefixKeys", "getPrefixValue", "getPrefixedKey", "getPrefesKeys", "getPubixedValue", "getPubsKey", "getPrefixedValue", "getPrefesSecret", "getPrefsKeys", "getPrefixedKeys", "getPrefsSecret", "getPubsKeys", "getPubixedKeys"], "key": ["keys", "string", "reason", "address", "base", "fee", "core", "temp", "id", "ace", "token", "original", "enc", "entry", "path", "message", "json", "result", "hex", "char", "password", "part", "type", "source", "cache", "seed", "value", "KEY", "connection", "str", "data", "text", "Key", "export", "empty", "msg", "name", "word", "ring", "prefix", "k", "secret", "pair", "wire", "sign", "block", "crypt", "cert", "phrase", "hash", "code"], "MD5": ["md6", "MT55", "AMD2", "MET2", "AMD5", "MET5", "SHA6", "SHA5", "DER2", "MET11", " MDse", "md5", "SHA3", "MD85", "MT5", "md4", "md55", "AMD4", "MET85", "mdse", "MD11", "SHA4", "MT4", "md2", "MD6", " MD3", " MD6", " MD4", "DER11", "Dse", "D1", " MD1", "D5", "md85", "MD3", "MDse", "MD2", "DER85", "md3", "MT6", "DER5", "MD4", "MD55", " MD55", " MD2", "MD1", "md11", "D4", "md1"], "resultBytes": [" resultBitcoin", "keyBytes", "responseBytes", "Resultbytes", "keybytes", " resultByte", "ResultBytes", "resultByte", "responsebytes", " resultbytes", "ResultByte", "responseBitcoin", "keyByte", "resultbytes", "resultBitcoin", "ResultBitcoin"]}}
{"id1": "12678045", "id2": "14691829", "code1": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 0, "substitutes": {"addQDInformation": ["addQDSinformation", "addKdinformation", "addQdDirectory", "addQDinformation", "addQDSInfo", "addQdInformation", "addQDSInformation", "addQDMDirectory", "addQDMInfo", "addQDMInformation", "addKDDirectory", "addQDInfo", "addKdDirectory", "addKdInformation", "addKDInfo", "addQDMinformation", "addKDInformation", "addQDDirectory", "addKDinformation", "addKdInfo", "addQdinformation", "addQdInfo", "addQDSDirectory"], "qdDate": ["sqdName", "qdModule", "qpDate", "qdAge", "qsModule", "qdxVal", "qdyTime", "qdatDay", "qdTime", "qfData", " qtTime", "qidType", "qtAge", " qsTime", "qdxType", "qfStatus", "qcAge", " qfDate", "sqpName", "qidVal", "qsName", "qtDay", "qdVal", "qdStatus", "qidName", "qdyStatus", " qtAge", "qdName", "qdyDate", "qpName", "qdType", "sqdDate", " qfFile", "sqpVal", "qsTime", " qtDay", " qdStatus", "qtTime", " qdDay", " qdModule", "qtData", "qtStatus", "qdyName", "sqdVal", " qdName", "qdyModule", "qdtName", "qdxName", " qsName", "qtDate", "qcTime", " qfStatus", "qidDate", "qdtTime", "qdDay", " qfData", "qdxDate", " qsModule", "qcDay", "qdatTime", "qfDate", "qdyFile", "qdatAge", "qfFile", "qdatDate", " qdData", "qpVal", "qcDate", " qtDate", " qdTime", "qdtModule", "qdtDate", "sqdType", " qsDate", "qdyData", "qpType", "qdData", "sqpType", "qsDate", "sqpDate", " qdAge", "qtFile"], "qdFile": ["qfFile", "qdaFile", "qdsLog", " qdsFile", "qdxReader", "qdaFolder", "qdBuffer", "qsFile", " qdFolder", "sqdfile", "qdsInfo", "qdsBuffer", "sqdsReader", " qfDir", "qdDir", "qdsFolder", "qdFolder", "qdLog", "qddFile", "qdxFile", "qsReader", " qdsFiles", "qdReader", "qdsDir", " qfInfo", "qdsReader", " qdsFolder", "sqdsDir", "qdfile", " qdFiles", "qdxfile", " qdLog", " qdsLog", "qdsFiles", " qfBuffer", " qdInfo", "qdsfile", "qdsFile", "qfFolder", "qdFiles", "qfBuffer", "qdInfo", " qdBuffer", "qdxDir", "sqdsFile", "qfFiles", "qfInfo", "qdaFiles", "qddBuffer", "qsfile", " qfFile", "sqdFile", "sqdDir", "sqdReader", " qdDir", "qfLog", "qddDir", "sqdsfile", "qfDir", "qdaLog", "qsDir", "qddInfo"], "_qdFileDate": ["_qndFileDesign", "_qdFileName", "_qdfiledate", "_qdfileDesign", "_qdcfileStatus", "_qndFileDate", "_qdBaseName", "_qndTimedate", "_qdcfileDate", "_qdDirectoryDesign", "_qdcFileName", "_qdTimeDesign", "_qdcFileStatus", "_qdBaseUpdate", "_qdDirectoryStatus", "_qndFiledate", "_qdMinStatus", "_qndTimeDate", "_qdFileUpdate", "_qdTimedate", "_qndTimeStatus", "_qdMinDate", "_qdfileName", "_qdMinUpdate", "_qdfileUpdate", "_qdMinName", "_qndTimeDesign", "_qndFileStatus", "_qdFileStatus", "_qdcfileName", "_qdfileDate", "_qdBaseDate", "_qdDirectorydate", "_qdcfileUpdate", "_qdcFileDate", "_qdTimeDate", "_qdfileStatus", "_qdDirectoryDate", "_qdBaseStatus", "_qdFiledate", "_qdTimeStatus", "_qdcFileUpdate", "_qdFileDesign"], "ii": ["index", "ou", "i", "qa", "id", "uri", "ei", "pi", "lu", "ini", "ie", "yi", "ind", "fi", "si", "ui", "ih", "ori", "qi", "vi", "ti", "ji", "chi", "li", "ice", " i", "iii", "II", "bi", "ai", "oi", "uni", "ci", "image", "eni", "zi", "iri", "xi", "di", "gi", "vid", "hi", "jp", "ni", "abi", " iii", "iu", "que", "mini", "inf", "oe", "ix"], "info": ["information", "error", "handler", "job", "i", "qa", "id", "feed", "op", "entry", "ref", "py", "end", "child", "fw", "off", "ui", "extra", "fam", "txt", "part", "buff", "kid", "alias", "data", "li", "ignore", "archive", "h", "object", "init", "INFO", "name", "fo", "af", "home", "opt", "link", "di", "gi", "hi", "ext", "bug", "comment", "conf", "b", "obj", "Info", "abi", "def", "f", "prev", "inf", "api"], "_qdValue": ["_sqdData", "_qdcInfo", "_qdName", "_qdsInfo", "_sqdName", "_qDName", "_qDInfo", "_sqdcData", "_qdData", "_qdsValue", "_sqdValue", "_qdcData", "_qdcValue", "_qdcName", "_qdInfo", "_qdsName", "_sqdcName", "_qdsData", "_sqdcInfo", "_sqdcValue", "_sqdInfo", "_qDValue", "_qDData"], "reader": ["buffer", "loader", "handler", "input", "server", "resource", "uri", "feed", "reading", "rc", "entry", "report", "http", "author", "per", "inner", "library", "ri", "result", "driver", "dr", "manager", "read", "iter", "ler", "er", "client", "source", "player", "r", "ger", "parser", "data", "rar", "row", "rr", "or", "rer", "writer", "io", "worker", "fd", "service", "f", "Reader", "re"], "urlName": ["URLname", "urlArea", "URLKey", " urlInfo", "UrlKey", "URLName", " urlString", "webInfo", "uriInfo", " urlFamily", "URLArea", "UrlFile", "uriFamily", " urlPart", "urlname", "urlInfo", " urlname", "urlFile", "webFamily", " urlKey", "urlString", "UrlArea", "URLString", "URLInfo", "UrlInfo", "UrlName", "urlKey", "UrlPart", "uriName", "urlPart", "webName", " urlArea", " urlFile", "UrlString", "URLPart", "Urlname", "urlFamily", "URLFile"], "url": ["string", "path", "address", "buffer", "ssl", "base", "server", "uri", "resource", "feed", "user", "http", "socket", "l", "large", "host", "URL", "source", "connection", "browser", "r", "open", "data", "channel", "director", "web", "page", "bel", "name", "ball", " URL", "sl", "pull", "Url", "www", "f", "gl"], "stream": ["zip", "handler", "buffer", "input", "resource", "response", "feed", "user", "http", "draft", "per", "socket", "oper", "driver", "s", "trans", "in", "raw", "form", "client", "source", "r", "Stream", "open", "data", "channel", "out", "flash", "row", "control", "coll", "io", "writer", "sl", "v", "ream", "f", "download", "view"], "file": ["buffer", "handler", "loader", "server", "feed", "resource", "ile", "user", "lock", "report", "http", "socket", "fp", "l", "File", "part", "source", "use", "book", "r", " File", "data", "body", "page", "object", "log", "folder", "io", "writer", "db", "files", "parse", "b", "f", "handle"], "line": ["pin", "base", "rule", "row", "style", "force", "frame", "comment", "Line", "string", "buffer", "LINE", " Line", "phase", "band", "shell", "sync", "part", "lines", "lc", "connection", "str", "section", "cl", "page", "le", "nl", "name", "header", "cr", "link", "strip", "lin", "letter", "job", "lf", "response", "entry", "message", "ge", "limit", "se", "look", "day", "el", "split", "one", "no", "body", "inline", "side", "word", "error", "column", "single", "cell", "lo", "user", "l", "pass", "key", "item", "data", "text", "log", "status", "home", "cle", "pe", "parse", "range", "block", "definition"], "_qdDate": ["_sqdData", "_qcdYear", "_qdDay", "_qfData", "_sqdTime", "_qdNumber", "_qndDate", "_qcdData", "_qdsMonth", "_qndDat", "_qfDay", "_qndMonth", "_sqdNumber", "_qndNumber", "_qndData", "_qdsDat", "_qdcTime", "_qdTime", "_QdDat", "_qdDat", "_QdsMonth", "_QdTime", "_qdsNumber", "_qndTime", "_sqdsDate", "_qdcDate", "_sqdsNumber", "_sqdcDate", "_sqdDate", "_qfTime", "_sqdcData", "_sqdsData", "_qcdDate", "_qdData", "_sqdsYear", "_qdsDay", "_qdcData", "_qdsYear", "_QdDate", "_qdsDate", "_qfDate", "_qndYear", "_qdMonth", "_sqdcTime", "_qdcDat", "_qdcDay", "_sqdYear", "_qcdNumber", "_qdsTime", "_qdYear", "_QdsTime", "_QdsDate", "_sqdcDay", "_QdsDat", "_QdMonth", "_sqdDay", "_qdsData", "_qdcMonth"], "pos": ["push", "index", "val", "i", "pres", "n", "spec", "pose", " position", "act", "Pos", "j", "end", "limit", "o", "rel", "length", "col", "all", "off", "pl", "pass", "sort", "in", "offset", "next", "post", "part", "type", "no", "doc", "pr", "min", "len", "nos", "open", "down", "x", "p", "size", "neg", "po", "start", "dev", "port", "pid", "pull", "position", "unit", "POS", "prop", "sp", "os", "mid", "pt", "ps", "block", "axis", "point", "loc"], "projectNum": ["projectHash", "componentFamily", "taskLen", " projectLen", " projectHash", "componentHash", "taskNumber", "projectLen", "projectFamily", "taskName", " projectNumber", "componentNumber", "ProjectNum", "ProjectName", "productNum", "projectName", "taskNum", "productNumber", "ProjectLen", " projectName", " projectFamily", "productHash", "projectNumber", "productFamily", "componentNum", "ProjectNumber"], "value": ["val", "trial", "price", "resource", "response", "vector", "message", "version", "profile", "project", "description", "number", "result", "amount", "key", "Value", "type", "target", "group", "feature", "data", "object", "name", "values", "v", "range", "scale"]}}
{"id1": "12537270", "id2": "9033639", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["report", "ge", " analyse", "se", "patch", "match", "read", "split", "raw", "load", "see", "build", "parser", "open", "format", "ract", "apply", "pack", "update", "ize", "arse", "process", "scan", "xml", "Parser", "eval"], "link": ["path", "string", "info", "base", "address", "lang", "uri", "id", "lock", "Link", "http", "add", "message", "rel", "html", "l", "match", "location", "URL", "line", "tag", "linked", "like", "type", "links", "source", "load", "connection", "data", "file", "text", "route", "li", "local", "page", "inline", "href", "style", "msg", "name", "e", "image", "word", "ln", "bug", "xml", "ink", "loc"], "conn": ["Connection", "ssl", "Conn", "cc", "n", "enc", "rc", "con", "c", "socket", "ctrl", "act", "col", "dr", "rt", "dc", "nc", "er", "client", "nt", "cp", "ct", "connection", "rn", "r", "ch", "open", "config", "ca", "out", "p", "rec", "ai", "ci", "Config", "io", "cr", "ann", "db", "pc", "mc", "ctx", "apt", "err", "connect", "cn", "ac", "pt", "cmd", "pg", "loc"], "rd": ["rw", "dra", "bd", "rc", "RR", "RS", "ru", "rg", "lr", "dr", "rt", "fr", "wd", "dc", "rs", "ld", "RD", "rb", "reader", "rh", "xd", "ra", "rn", "rid", "r", "nd", "RM", "rr", "rss", "rx", "rog", "adr", "fd", "rl", "hr", "ds", "rm", "dd", "sr"], "kit": ["qt", "info", "base", "loader", "Kit", "sci", "feed", "spec", "site", "net", "fit", "py", "et", "pot", "wt", "rt", "ui", "kat", "util", "ku", "rot", "nt", "tools", "sit", "reader", "tk", "lib", "ct", "browser", "cat", "kt", "w", "ut", "config", "h", "p", "plugin", "init", "format", "io", "t", "cr", "kin", "bot", "k", "ki", "bug", "b", "pit", "os", "f", "tool", "api", "auto"], "doc": ["val", "root", "info", "base", "Doc", "http", "docs", "document", "ref", "DOC", "pub", "html", "tag", "dr", "fr", "dc", "in", "config", "d", "dir", "div", "md", "data", "file", "text", "out", "de", "open", "mm", "body", "page", "msg", "po", "desc", "m", "coll", "pos", "dec", "db", "pc", "di", "mc", "tt", "bc", "bug", "ac", "xml", "dom", "f", "tx", "api", "loc"], "url": ["path", "address", "base", "ssl", "server", "uri", "resource", "feed", "http", "lr", "l", "location", "host", "URL", "html", "el", "util", "cdn", "source", "connection", "config", "github", "file", "src", "page", "ll", "log", "href", "name", "image", "blog", "sl", "rl", "pull", "Url", "service", "www", "bug", "ur", "xml", "f", "hub", "gl", "org", "download", "loc"], "it": ["ite", "info", "dit", "id", "ic", "IT", "et", "end", "se", "l", "mit", "in", "iter", "split", "nt", "its", "sit", "stat", "r", "ip", "iterator", "p", "init", "lit", "or", "edit", "ci", "iti", "t", "ait", "you", "v", "st", "It", " It", "pit", "iz"], "elem": [" Eade", "oelem", "eject", " neade", "pelev", "eelements", " nelem", "oelev", "Element", "Elev", " Element", " Eler", "peler", "eler", "oeler", "seject", "Eler", "Elem", "pelem", "Elements", "selem", "eade", "pelement", " nelement", " neler", "Eade", "eeject", "elev", "eelement", "Eject", "eelem", "selement", "elements", "oelement", "selements", " Elem", "element"], "s": ["services", "string", "ssl", "sf", "server", "n", "fs", "spec", "ns", "c", "S", "sch", "se", "o", "set", "si", "rs", "params", "parts", "sync", "session", "ws", "d", "sb", "strings", "ops", "scope", "r", "sv", "g", "attr", "gs", "xs", "h", "p", "es", "u", "ts", "submit", "ls", "js", "e", "m", "sets", "t", "ss", "details", "sl", "sym", "a", "ses", "v", "b", "ds", "os", "f", "ps", "service"], "lnk": ["nlks", "olnkr", "lnok", "dlf", "dlk", "linf", "lenky", "lnku", "knkh", "olnk", "lenke", "dlok", "dnkr", "gnky", "dnf", "lenk", "olnf", "lnke", "dnky", "lnkh", "nlK", "nnky", "lnky", "lnK", "olnK", "dnke", "lnkr", "dlks", "nlkh", "linky", "gnk", "nlke", "nnke", "olnke", "nlok", "linke", "lenku", "gnke", "nlky", "nlk", "nnku", "dnku", "dlky", "lnf", "dnk", "knK", "nnk", "knke", "lenks", "lnks", "gnok", "knk", "olnkh", "dlke", "nlf", "dlkr"], "j": ["index", "info", "job", "uj", "n", "ij", "note", "dj", "ie", "jc", "ind", "z", "o", "jl", "jo", "si", "fr", "ii", "key", "aj", "qi", "syn", "part", "ja", "ji", "pr", "ch", "g", "li", "x", "p", "jj", "ne", "J", "js", "name", "m", "kj", "pos", "jp", "a", "obj", "adj", "ni", "br", "y", "oj", "im"], "urlLink": ["fileHub", "resourceConnect", "urlHub", "urlLine", "fileUrl", "resourceLine", "URLLink", "strlink", " urlPath", "resourceLink", " urlUrl", "URLUrl", "filePath", "UrlPath", " urllink", " urlConnect", " urlLine", "resourcelink", "urlUrl", "urlPath", "urlConnect", "fileLink", "urlPage", "urlRel", " urlPage", "UrlLink", "strLine", " urlRel", "UrlRel", "strLink", "URLRel", "UrlPage", "UrlUrl", "urllink", " urlHub", "URLPage", "strConnect", "UrlHub"], "str": ["sta", "string", "n", "wr", "enc", "res", "inner", "spr", "l", "line", "fr", "dr", "inst", "pass", "char", "arr", "elt", "txt", "Str", "pr", "ctr", "r", "div", "STR", "data", "text", "js", "name", "coll", "t", "cr", "dec", "sl", "tr", "strip", "ext", "hr", "b", "sp", "br", "kr", "st", "err", "obj", "f", "stri", "sr"], "i": ["index", "info", "mu", "id", "n", "pi", "uri", "ini", "yi", "slice", "c", "fi", "ri", "o", "l", "si", "ui", "ii", "in", "ori", "en", "qi", "vi", "ti", "ji", "phi", "chi", "li", "ip", "x", "p", "mi", "bi", "u", "init", "uli", "ai", "oi", "e", "I", "ci", "io", "eni", "zi", "m", "xi", "di", "gi", "hi", "v", "b", "ni", "y", "abi", "iu", "multi", "f", "ix"], "skip": [" bypass", " scan", "cmp", "copy", "replace", "add", "jump", " exclude", "active", "Skip", " skipping", "iter", "loop", " dup", "append", "ips", "empty", " duplicate", "complete", " repeat", "special", " skipped", "sp", "scan", "error", "fast", "stop"]}}
{"id1": "3024987", "id2": "20619879", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamForencoded", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_Coding", "testCopy_readerToOutputStream_Coder", "testCopy_readerToOutputStream_encode", "testCopy_readerToOutputStream_Integoder", "testCopy_readerToOutputStream_Coded", "testCopy_readerToOutputStreamForEncode", "testCopy_readerToOutputStream_Integode", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStreamForencode", "testCopy_readerToOutputStream_Encode", "testCopy_readerToOutputStreamForencoder", "testCopy_readerToOutputStream_Code", "testCopy_readerToOutputStreamForEncoder", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStream_Integoded", "testCopy_readerToOutputStreamForEncoded", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStreamForencoding", "testCopy_readerToOutputStreamForEncoding", "testCopy_readerToOutputStream_Integoding", "testCopy_readerToOutputStream_Encoder"], "in": ["IN", "buffer", "i", "input", "n", "inas", "id", "reading", "ini", "entry", "slice", "inner", "ins", "arin", "bin", "pass", "read", "is", "source", "login", "min", "inside", "r", "inc", "data", "rin", "file", "init", "rec", "or", "again", "m", "image", "io", "re", "In", "a", "url", "include", "err", "with", "inn", "win", "Reader", "din"], "reader": ["buffer", "loader", "i", "input", "her", "handler", "feed", "reading", "per", "inner", "driver", "read", "iter", "ler", "er", "source", "ra", "oder", "ner", "r", "parser", "file", "rar", "x", "rr", "or", "rer", "io", "writer", "iner", "rx", "pointer", "worker", "stream", "b", "ink", "Reader"], "baout": ["Baout", "daout", "baparent", "vain", "waOut", "dain", "BaOut", "waout", "aain", "vaOut", "waoutput", "vaout", "vaparent", "BAin", "daOut", "abaOUT", "daOUT", "aaOut", "Baparent", "baoutput", "BAparent", "BAOUT", "BAOut", "baOut", "aaoutput", "bain", "Bain", "wain", "abain", "aaout", "abaout", "abaOut", "baOUT", "BAoutput", "BAout"], "out": ["base", "buffer", "inas", "server", "output", "user", "builder", "ref", "OUT", "inner", "outs", "o", "pool", "line", "write", "arr", "client", "cache", "lib", "up", "inc", "parent", "file", "object", "null", "again", "exec", "Out", "image", "writer", "io", "to", "array", "ext", "obj", "err", "with"], "bytes": ["zip", "string", "css", "output", "pages", "pieces", "tes", "ns", "comments", "android", "les", "outs", "bs", "reads", "content", "parts", "items", "ies", "its", "binary", "lines", "blocks", "strings", "bps", "data", "classes", "body", "text", "objects", "ips", "size", "es", "null", "Bytes", "ls", "ones", "seconds", "cells", "rows", "values", "files", "ipes", "units", "os", "bits", "odes", "codes"]}}
{"id1": "3558512", "id2": "16232202", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "label": 0, "substitutes": {"serialize": ["erialize", "serialze", "serializable", " serialization", "Serialize", "finalify", "finalize", "serialization", " serializable", "finalized", "normalized", "erialze", "normalify", "erialization", "Serialized", "serialify", "erializable", " serialze", "serialized", "normalize", "normalze", "Serialze", "Serialization", "finalze", "Serialify", "Serializable"], "out": ["string", "buffer", "loader", "temp", "i", "ex", "output", "copy", "server", "report", "filename", "OUT", "o", "outs", "pool", "bin", "content", "raw", "client", "source", "cache", "up", "w", "data", "file", "archive", "parent", "page", "gen", "conn", "name", "exec", "Out", "io", "writer", "image", "dump", "a", "err", "obj", "png"], "parser": ["pillar", "base", "class", "pkg", "arser", "loader", "handler", "server", "copy", "builder", "master", "lp", "per", "as", "system", "instance", "php", "manager", "txt", "er", "cp", "reader", "cache", "pp", "up", "seed", "upload", "parent", "file", "rar", "p", "plugin", "test", "writer", "ss", "worker", "tt", "pe", "parse", "processor", "wrapper", "xml", "Parser"], "on_disk": ["onbootdrive", "onJdrive", "onJdisk", "onbootlock", "onjdrive", "onbootstorage", "on_demand", "onjdisk", "on_drive", "off_disk", "onnetfile", "off_drive", "onbootdisk", "on_storage", "onbookdelete", "on_lock", "onJdemand", "off_lock", "on_space", "onnetdemand", "onbookdisk", "off_storage", "onJlock", "on_delete", "onnetdisk", "onnetspace", "off_delete", "onbookdrive", "onjfile", "off_demand", "onnetdrive", "onjspace", "off_file", "on_file", "off_space"], "in": ["IN", "info", "pin", "i", "input", "inas", "copy", "ini", "con", "c", "socket", "inner", "as", "o", "ins", "bin", "pass", "reader", "thin", "source", "connection", "min", "login", "r", "inc", "data", "file", "rin", "conn", "again", "ax", "In", "kin", "stream", "lin", "ac", "inn", "f", "win", "din"]}}
{"id1": "62362", "id2": "23677147", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 0, "substitutes": {"convert": ["CONverting", "subverting", "Conversion", "oconversion", "oconverting", "Converting", "CONversion", "unversion", "CONvert", "conversion", "CONception", "oconverted", " deconverted", "converting", "CONverted", "subvert", "oconvert", "Conception", "unvert", "converted", " deconverting", "subversion", "Converted", "unception", "unverted", "subverted", " deconversion", "conception", "Convert", " deconvert"], "src": ["impl", "string", "path", "sel", "ssl", "sin", "input", "sc", "uri", "resource", "sys", "spec", "rc", "Source", "video", "cmp", "username", "filename", "ref", "slice", "cb", "fp", "fn", "s", "prot", "code", "inst", "feat", "cpp", "req", "gb", "back", "source", "reader", "load", "proc", "sb", "rb", "sit", "buf", "component", "dist", "upload", "SourceFile", "config", "file", "tmp", "Dest", "supp", "attr", "img", "href", "storage", "name", "sth", "gz", "RC", "rl", "ctx", "secure", "url", "scene", "stream", "obj", "st", "stage", "sn", "ource", "download", "loc"], "dest": ["path", "class", "temp", " dst", "cont", "fn", "bin", "dc", "std", "txt", "source", "dir", "lib", "target", "dist", "tmp", "Dest", "null", "test", "home", "di", "obj", " destination", "dat", "disk", "orig", "img"], "in": ["IN", "val", "pin", "i", "input", "ex", "n", "inas", "ini", "as", "ins", "bin", "pass", "is", "reader", "d", "source", "doc", "up", "login", "r", "inc", "data", "file", "io", "t", "isin", "In", "a", "stream", "err", "inn", "ps", "f", "inf", "win", "din"], "p": ["P", "i", "pi", "op", "wp", "pre", "lp", "per", "py", "c", "j", "fp", "o", "l", "s", "pb", "cop", "part", "cp", "d", "pr", "pp", "pm", "r", "g", "parser", "h", "np", "po", "tp", "m", "e", "t", "pc", "jp", "pa", "bp", "pe", "b", "sp", "v", "ps", "f", "pd", "pg"], "ds": ["services", "uds", "ays", "docs", "ants", "dos", "s", "ins", "dp", " DS", "parts", "points", "gs", "els", " props", "des", "ts", "js", "utils", "ths", "ys", "gd", "sys", "df", "lp", "bs", "dc", " ps", "dt", "sync", "lines", "eps", "vs", "ges", "amps", "ipes", "pd", "dd", "sts", "DS", "cons", "ks", "ns", "qs", "ld", "hs", "d", "dist", "ans", "ads", "xs", "models", "plugins", "groups", "tests", "ss", "di", "os", "posts", "styles", "rs", "dl", "tools", "ded", "ups", "data", "vals", "scripts", "Ds", "ls", "obs", "dm", "db", "ils", "nas", "dates", "da", "cs", "words", "dds", "ps", "dat", "icks", " sd"], "format": ["letter", "string", "path", "class", "handler", "spec", "filename", "act", "version", "table", "fp", "fn", "host", "tag", "record", "layout", "feat", "magic", "Format", "pattern", "form", "filter", "at", "type", "source", "part", "model", "parser", "config", "data", "file", "sche", "struct", "ant", "language", "style", "plugin", "template", "name", "frame", "t", "function", "prefix", "fd", "nat", "url", "unit", "atter", "f", "scale", "api"], "hasPixelData": ["hasPixeldata", "showsPixelDATA", "hasPixelDATA", "hasPicturedata", "hasByteSize", "hasByteDATA", "hasByteData", "haspixelData", "hasPixelStyle", " hasPixelSize", "showsByteDATA", "hasPictureSize", " hasPixeldata", "haspixeldata", "showsBytedata", "hasPictureData", "haspixelSize", "showsByteData", "showsPixelData", "showsByteStyle", "hasPixelSize", "hasByteStyle", "showsPixelStyle", "hasBytedata", "showsPixeldata"], "inflate": ["inadequating", "insflode", "insvenating", "inffated", "Inflation", "InFlation", "inflating", "Inflated", "inflATE", "InFlace", "insvenate", "inadequode", "InFlated", "insflate", "infolATE", "infface", "invenode", "InFlate", "inffation", "inflated", "inFlation", "infolode", "infloace", "insvenATE", "infloate", "invenATE", "inFlate", "inadequATE", "insflATE", "infloation", "invenating", "inffate", "insvenode", "inadequate", "Inflace", "inflation", "inflode", "inFlated", "Inflate", "infolate", "inFlace", "infloated", "invenate", "infolating", "inflace", "insflating"], "pxlen": ["pxdata", "xpsize", "pxlin", "pngcount", "mxsize", "campos", "fxlen", "pxl", "pgLen", "axlen", "ppLen", "mxcount", "fxln", "pxlon", "pxln", "pcln", "pglen", "ppl", "pxlength", "ppden", "camln", "txln", "pngsize", "pxpos", "pclon", "camlen", "mxdata", "axln", "axlon", "mxlength", "mxpos", "mxlen", "xplen", "txlin", "pxden", "pxcount", "fxpos", "txlon", "pclin", "pxsize", "fxdata", "pxLen", "mxln", "xpcount", "pgl", "fxLen", "axlin", "pnglen", "xplength", "fxl", "pgden", "fxden", "pclen", "pnglength", "txlen", "pplen", "camdata"], "out": ["step", "server", "output", "copy", "sys", "user", "lock", "OUT", "inter", "outs", "line", "co", "query", "post", "session", "cache", "lib", "up", "group", "store", "parent", "work", "page", "log", "gen", "conn", "again", "Out", "io", "dump", "obj", "v", "err", "state", "pad", "cli", "error", "re", "list", "point"]}}
{"id1": "8164056", "id2": "4921631", "code1": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 0, "substitutes": {"encode": ["unode", "Enode", "enccod", "Encod", "encod", "uncod", "Encode", "encquote", "enquote", "enode", "unquote", "enccode", "Enquote", "uncode"], "str": ["string", "buffer", "input", "temp", "cur", "enc", "orig", "inner", "hex", "result", "fr", "in", "char", "iter", "txt", "arr", "er", "Str", "strings", "ctr", "r", "div", "STR", "data", "text", "p", "e", "exp", "rev", "hr", "obj", "sp", "err", "br", "st", "f", "stri", "this", "code"], "buf": ["buffer", "pkg", "Buffer", "bf", "bd", "bh", "cf", "aux", "cb", "fp", "result", "ff", "pb", "queue", "uf", "bag", "bu", "cv", "rb", "ab", "proc", "wb", "sb", "buff", "uc", "cas", "binary", "conv", "data", "tmp", "src", "fb", "bb", "agg", "coll", "box", "vec", "af", "array", "db", "fd", "ctx", "Buff", "bc", "bp", "b", "br", "obj", "err", "f", "cur"], "md5": ["md4", "dig512", " md4", "sha512", "MD11", "dig11", "dig4", " md3", "dig5", "md2", "sha2", "MD5", "MD3", "MD512", "MD2", "md3", " md2", "MD4", "md512", "sha5", " md512", "md11", " md11", "sha3"], "bytes": ["string", "bis", "bles", "quarters", "pages", "pieces", "tes", "sequence", "ns", "slice", "outs", "steps", "bs", " strings", "errors", "content", "ings", "items", "parts", "binary", "lines", "bps", "data", "text", "body", "classes", "objects", "ips", "es", "Bytes", "ls", "vs", "seconds", "cells", "rows", "files", " elements", "values", "pins", "seq", "b", "rules", "units", "words", "bits", "codes", "boot", "letters"], "i": ["val", "index", "info", "id", "n", "pi", "uri", "mu", "slice", "c", "inner", "j", "ri", "o", "l", "length", "si", "ui", "ii", "in", "key", "ori", "qi", "part", "ti", "ji", "d", "phi", "chi", "li", "h", "x", "p", "bi", "u", "ai", "oi", "ci", "I", "e", "t", "io", "m", "xi", "gi", "di", "hi", "b", "v", "abi", "multi", "f"], "s": ["string", "ex", "n", "fs", "spec", "sg", "ns", "c", "S", "o", "l", "abs", "si", "su", "in", "hs", "signed", "its", "ws", "d", "sb", "strings", "h", "p", "es", "u", "aws", "js", "e", "ls", "m", "t", "ss", "sl", "a", "secret", "b", "v", "ds", "cs", "os", "f", "service"]}}
{"id1": "3809087", "id2": "4168534", "code1": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "label": 0, "substitutes": {"getWave": ["newWire", "getwave", " getWire", "readWave", "readwave", "newSound", " getSound", "getSound", "readSound", "getWire", "newwave", "readWire", " getwave", "newWave"], "url": ["string", "path", "address", "base", "fe", "sf", "feed", "uri", "resource", "http", "filename", "ref", "fp", "lr", "l", "fn", "Feed", "URL", "host", "fr", "ff", "File", "fl", "source", "r", "wave", "file", "web", "page", "name", "image", "F", "word", "Url", "fax", "b", "Ur", "f", "inf", "field", "loc"], "Word": ["Term", "string", "Class", "Win", "Part", "Hack", "Text", "Words", "Path", "Letter", "Feature", "Wave", "Language", "Eng", "Code", "wd", "Work", "Token", "File", "Content", " word", "Str", "Writer", "Frame", "Dir", "W", "Length", "Stream", "Rule", "Weight", "Field", "Key", "Message", "Name", "Time", "F", "word", "Function", "World", "Url", "Line", "Folder", "Wire", "Gender", "words", "Tag", "Msg"], "FF": ["P", "FM", "BB", "feed", "DF", "FA", "FE", "fp", "FH", "Feed", "URL", "ff", "AF", "LL", "TF", "FL", "FB", "FD", "Fi", "FILE", "IF", "Field", "FS", "DC", "IP", "F", "SF", "ELF", "fd", "CC", "IFF", "Fax", "Client", "Folder", "FW", " ff", "FC", "FP", "RC"], "url2": ["URL1", " url3", "f1", "url3", "f3", "pathTwo", "path2", "f4", "path1", "urlDB", "l2", "urlTwo", "l3", "url4", "f2", " urlDB", "URLDB", " urlTwo", "URL2", " url4", "URLTwo", "pathDB", "l4", "url1", "l1", " url1"], "stream": ["impl", "string", "path", "ssl", "handler", "roll", "temp", "input", "server", "output", "feed", "response", "loader", "video", "http", "draft", "ack", "slice", "socket", "forward", "driver", "host", "fr", "thread", "ff", "flow", "in", "raw", "form", "client", "loop", "reader", "source", "live", "Stream", "wave", "w", "pipe", "file", "channel", "src", "flash", "row", "context", "coll", "io", "writer", "fd", "sl", "steam", "v", "stack", "sw", "f", "field", "transform", "view"], "Fdel": ["Fidestroy", " Fdelete", " Ffin", "fdel", "fDel", " Fdestroy", "ffin", "Fidelete", "fdelete", "Fidel", " FDel", "Fdestroy", "FDel", "FiDel", "fdestroy", "Fifin", "Ffin", "Fdelete"], "outstream": ["OutStream", "inStream", "inreader", "inputchannel", "outputfile", "outwriter", " outfile", "inlog", "inchannel", "inputlog", "outfile", " outreader", "outlog", "outStream", "outchannel", "outputwriter", "outputreader", "outputstream", "inmodel", "outputform", "outreader", "inputstream", "outputStream", "outputchannel", "inputStream", "outputmodel", " outmodel", "outform", "Outstream", "outmodel", " outwriter", "Outform", " outStream", "instream", "inwriter", "Outfile", "outputlog", " outform"], "bwriter": ["bwriting", " bWriter", "bwriters", "fbwrite", "outwriter", "bwrite", "bbwrite", "outwr", "fbwriter", "Bwrite", " bwriting", " breader", "bbwriters", "fbuilder", "fwriter", "freader", "bbwriter", " bwr", "bWriter", "bbreader", "bbwr", "bbwriting", " bwriters", "bbWriter", "outwriting", "bbuilder", "outreader", "fbWriter", "breader", "fbwriters", "Bbuilder", "fwrite", "Bwriter", " bbuilder", " bwrite", "Breader", "bwr"], "binput": ["byteput", "biset", "libput", "bitwrite", "bitput", "binstart", "output", "sincut", "sinlog", "bitset", "binset", "outstart", "bistop", "binarycut", "binaryput", " binset", " binsplit", "winput", " binstart", "libset", "sinset", "binarylog", "bisplit", " binstop", "binsell", " binpos", "sinput", "biwrite", " binwrite", "binaryset", "bytestop", "binwrite", "libcut", "bitpos", "binsplit", "binstop", "binpos", "bytesplit", "winstart", "binlog", "winsell", " binsell", "liblog", "winwrite", "bipos", "outsell", "byteset", "bincut", "outwrite", "biput"], "len": ["val", "lt", "base", "fun", "num", "id", "n", "lf", "enc", "pre", "Len", "cap", "ie", "end", "limit", "l", "length", "line", "el", "bin", "lan", "en", "iter", "hl", "fl", "fin", "elt", "dl", "part", "split", "la", "lc", "data", "li", "lim", "le", "size", "ls", "coll", "pos", "ann", "label", "sl", "rev", " lang", "ln", "low", "lin", "seq", "count", "lon"]}}
{"id1": "22401746", "id2": "1005108", "code1": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "code2": "    public void googleImageSearch(String search, String start) {\n        try {\n            String u = \"http://images.google.com/images?q=\" + search + start;\n            if (u.contains(\" \")) {\n                u = u.replace(\" \", \"+\");\n            }\n            URL url = new URL(u);\n            HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();\n            httpcon.addRequestProperty(\"User-Agent\", \"Mozilla/4.76\");\n            BufferedReader readIn = new BufferedReader(new InputStreamReader(httpcon.getInputStream()));\n            googleImages.clear();\n            String text = \"\";\n            String lin = \"\";\n            while ((lin = readIn.readLine()) != null) {\n                text += lin;\n            }\n            readIn.close();\n            if (text.contains(\"\\n\")) {\n                text = text.replace(\"\\n\", \"\");\n            }\n            String[] array = text.split(\"\\\\Qhref=\\\"/imgres?imgurl=\\\\E\");\n            for (String s : array) {\n                if (s.startsWith(\"http://\") || s.startsWith(\"https://\") && s.contains(\"&amp;\")) {\n                    String s1 = s.substring(0, s.indexOf(\"&amp;\"));\n                    googleImages.add(s1);\n                }\n            }\n        } catch (Exception ex4) {\n            MusicBoxView.showErrorDialog(ex4);\n        }\n        MusicBoxView.jButton7.setEnabled(true);\n        ImageIcon icon;\n        try {\n            icon = new ImageIcon(new URL(googleImages.elementAt(MusicBoxView.googleImageLocation)));\n            ImageIcon ico = new ImageIcon(icon.getImage().getScaledInstance(100, 100, Image.SCALE_SMOOTH));\n            MusicBoxView.albumArtLabel.setIcon(ico);\n        } catch (MalformedURLException ex1) {\n            MusicBoxView.showErrorDialog(ex1);\n        }\n    }\n", "label": 0, "substitutes": {"sendRequest": ["processRequest", "processObject", " sendObject", "sendResponse", " sendResponse", "sendrequest", "submitRequest", "sendObject", "submitObject", "processrequest", "submitrequest", "submitResponse", " sendrequest", "processResponse"], "servletName": ["servlename", "servLETname", "servletsname", "servletsUrl", " servletPath", " servleNames", "servLETNames", "servletname", "servletPath", "servletsNames", "servleVersion", "servletonName", "servleUrl", " servletVersion", "servletsPath", "servletNames", "servletonPath", " servleUrl", " servletname", "servLETPath", "servletUrl", "servletVersion", " servletNames", " servlename", "servLETName", "servletsVersion", " servleName", "servLETVersion", "servletonVersion", "servleName", " servlePath", "servleNames", " servleVersion", " servletUrl", "servletonNames", "servLETUrl", "servletsName", "servlePath"], "request": ["string", "path", "info", "buffer", "address", "input", "Request", "resource", "response", "server", "uri", "report", "message", "json", "document", "python", "result", "query", "queue", "req", "content", "type", "q", "application", "config", "data", "text", "object", "hello", "complete", "name", "header", "frame", "create", "xml", "method"], "reqxml": ["reqdoc", "requestdoc", "requestdocument", "Requestdocument", "Requestdoc", " reqdocument", " reqdoc", "reqdocument", "Requestxml", "requestxml"], "retdoc": [" retdata", " retconf", " resultxml", " resultconf", "retconf", "retxml", " resultdoc", "retdata", " backdata", " resultdata", " retxml", " backxml", " backdoc", " backconf"], "myurl": [" myURL", "MyUrl", "yourUrl", "myUrl", "Myurl", "yourURL", " myhost", "myaddress", "yoururl", "Myhost", "yourhost", "Myaddress", " myaddress", "myURL", " myUrl", "serverhost", "serveraddress", "MyURL", "youraddress", "myhost", "serverurl"], "myport": ["MYurl", "memberurl", "serverurl", "myPORT", " myort", "Myport", "memberPort", "somehost", "someip", "Myurl", "somePort", "yourip", "serverport", "someurl", " myhost", "Myort", "someport", "yoururl", "MyPORT", "Myhost", " myPORT", "yourPort", "serverphone", "myort", "memberport", "memberip", "MyPort", " myphone", "myPort", "MYPort", "MYPORT", "somePORT", "MYhost", "yourphone", "serverPort", "myip", " myPort", "MYport", "myhost", "myphone", "yourport", "someort"], "codebase": [" codebas", "Codebas", "codBase", "forebase", " codeurl", "foreb", "foreurl", "Codeurl", "foreBase", "CodeBase", " codeBase", "codebas", "Codeb", "Codebase", "codeurl", "codeBase", " codeb", "codb", "codeb", "forebas", "codbase"], "serverURL": ["myUrl", "slaveAddress", "siteDirectory", "slaveUrl", "testUrl", " serverURI", " serverID", "serverFolder", "hostUrl", "slaveURL", " serverurl", "databaseUrl", "erverUrl", "myURL", "myJSON", "testURL", "testURI", "databaseURI", "serverLevel", "serverBUG", "testLocation", "siteURL", "serverDirectory", "erverPage", "siteAddress", "erverurl", "siteLocation", "localhostUrl", "siteFolder", "databaseURL", " serverUrl", "erverFolder", " serverLevel", "serverURI", "sitePage", "siteID", " serverJSON", "hostURI", "slaveFolder", "serverLocation", "localhostURL", "remoteBUG", "serverID", "erverAddress", "hosturl", "localhostDirectory", " serverLocation", "erverURL", "remoteURL", "serverUrl", "hostURL", "erverBUG", "myLevel", "erverLevel", "myID", "serverJSON", "serverPage", "remoteurl", "siteURI", "siteUrl", "remoteUrl", "erverJSON", "siteurl", " serverBUG", "erverDirectory", "localhostPage", "remoteURI", "serverAddress", "myURI", "testurl", "serverurl"], "ipdig": ["ppDig", "idDig", "opdiff", "ppplug", "IPdig", "ipgen", " ipDig", "IPdiff", "IPcr", "ipcr", "ipdb", "ipsDig", "ipdiff", "opdig", "ipcomb", "ipsdig", "ppdig", "ipsdb", "ppcr", "IPdone", "idplug", "IPplug", " ipcomb", "IPDig", " ipplug", "IPgen", "opcomb", "ipplug", "IPdb", "ipDig", " ipdb", "iddig", "ipsgen", "ipdone", " ipgen", "iddone", "opDig", " ipdiff", "IPcomb", " ipdone", " ipcr"], "url": ["event", "path", "ssl", "class", "server", "resource", "uri", "user", "http", "rel", "l", "host", "URL", "util", "key", "req", "fl", "client", "twitter", "connection", "browser", "str", "config", "file", "cl", "web", "page", "object", "ll", "log", "conn", "name", "ls", "coll", "sl", " http", "pull", "Url", "update", "www", " curl", "f", "gl", "org"], "urlconn": ["httpconnection", "urlclient", " urlclient", "urlcon", "urlcn", " urlcon", "slconv", "llConn", " urlconf", "llcon", "httpconn", " urlConn", " urlconnection", "httpcon", "sslconf", "webcon", "llconn", "flconnection", "httpConn", " urlcn", "flconn", "sslConn", "sslcon", "urlconnection", "slcon", "flcon", "httpcn", "sslconn", "slclient", "webconv", "flConn", "llconnection", "flcn", "urlConn", "urlconf", "webclient", "urlconv", "webconn", "slconn", "httpconf", " urlconv"], "os": ["fs", "Os", "op", "res", "ns", "as", "OS", "o", "bs", "is", "ms", "rs", "so", "ops", "ips", "es", "or", "vs", "ls", "io", "oss", "ot", "pos", "us", "obj", "ds", "ps"], "req1xml": ["req1request", "req0xml", "req0request", "req_request", "request2x", "request1x", "req0x", "request1xml", "req2txt", "req_txt", "request2xml", "req_xml", "request1request", "req_x", "req0txt", "req2x", "req1txt", "request1txt", "req2request", "request2request", "request2txt", "req2xml", "req1x"], "cos": [" tar", " ze", " compress", " rc", " pos", "outs", " temp", "is", " contents", " enc", " ro", " iss", " outs", " dd", " ss", " bytes", " zipper", " po", "pos", " bos", " downloads", " cs", " repo", " fo", " socks", "cs", " compression", " cc"]}}
{"id1": "20310134", "id2": "3184073", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyChannel", "copyChannel", "CopyFile", "copyfile", "transferfile", "transferFiles", "transferChannel", " copyFiles", "Copyfile", " copyChannel", "CopyFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "base", "buffer", "i", "input", "id", "ex", "lock", "ic", "c", "inner", "as", "l", "ins", "bin", "query", "reader", "source", "login", "min", "diff", "inc", "work", "config", "file", "data", "again", "name", "m", "image", "io", "In", "url", "lin", "inn"], "out": ["string", "base", "server", "output", "n", "ex", "resource", "user", "plain", "c", "OUT", "outs", "o", "write", "off", "cache", "dot", "connection", "default", "w", "file", "page", "x", "p", "conn", "again", "name", "exec", "Out", "io", "writer", "image", "call", "prefix", "ext", "v", "b", "external", "point", "img"], "inChannel": ["binStream", "inputChannel", "INchannel", "iniChannel", "binchannel", "inStream", "insConnection", " inchannel", "inchannel", "binChan", "InQueue", "InChan", "loginChan", "loginChannel", "Inchannel", "iniStream", "INChan", "outStream", "inputChan", "iniChan", "outchannel", "outQueue", "inputConnection", "outChan", "inChan", "InGate", "InChannel", "InStream", "inputStream", "insStream", "inQueue", "binChannel", "INStream", "insChannel", "INChannel", " inQueue", "inConnection", " inChan", "insChan", "loginchannel", "binGate", "loginStream", "INConnection", "iniGate", "inGate"], "outChannel": ["netChan", "ouChan", "inStream", "netGate", "netChannel", "outputGate", "OutConnection", "OutChannel", "ouChannel", "inchannel", " outChar", " outConnection", "ouchannel", "OutChan", "ouGate", "outStream", "outChar", "outchannel", "outChan", "inChan", "outputStream", "netStream", "outputchannel", "outputChannel", "outConnection", "Outchannel", " outGate", "inGate", "outputChan", "inConnection", " outStream", "outputChar", "outGate", "inChar", " outchannel", " outChan"]}}
{"id1": "12128591", "id2": "18202328", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "label": 1, "substitutes": {"hash": ["sum", "copy", "add", " Hash", "hex", " hashing", "Hash", "component", "str", "build", "text", "check", "h", "get", "log", "pack", "dump", "update", "parse", "SHA", " hashes", "print", " fingerprint", "crypt", "code"], "data": ["string", "info", "address", "buffer", "class", "input", "base", "output", "response", "message", "result", "hex", "s", "length", "memory", "database", "in", "alpha", "content", "source", "cache", "value", "media", "connection", "str", "DATA", "text", "body", "p", "style", "format", "name", "template", "image", "bytes", "a", "missing", "padding", "pad", "dat", "api"], "digest": ["Digester", "signester", "DigEST", "Diger", "mdast", "signEST", "signest", "signusher", "bigest", "peder", "generester", "decest", " diger", "decit", "digit", " digusher", "generests", "logenge", "logester", " dige", "mdest", " digger", "pede", "digester", "digests", "mdester", "Digenge", "digger", "decester", "Digest", "decests", "mdenge", "bigusher", "Digusher", "digusher", "diger", "digenge", "pedester", " digEST", " digester", "bigester", "Digger", " digests", "Digast", "dige", "generit", "generest", "pedest", "digast", " digit", "logest", "logast", "Dige", "digEST", "bigger"]}}
{"id1": "6963063", "id2": "15822137", "code1": "    public static void main(String args[]) {\n        int[] mas = { 3, 5, 6, 9, 1, -3, -4, -88 };\n        int sort = 0;\n        for (int j = 0; j < (mas.length); j++) {\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    sort = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = sort;\n                }\n            }\n        }\n        for (int i = 0; i < mas.length; i++) {\n            System.out.print(\" \" + mas[i]);\n        }\n    }\n", "code2": "    public TableDirectory(RandomAccessFile raf) throws IOException {\n        version = raf.readInt();\n        numTables = raf.readShort();\n        searchRange = raf.readShort();\n        entrySelector = raf.readShort();\n        rangeShift = raf.readShort();\n        entries = new DirectoryEntry[numTables];\n        for (int i = 0; i < numTables; i++) {\n            entries[i] = new DirectoryEntry(raf);\n        }\n        boolean modified = true;\n        while (modified) {\n            modified = false;\n            for (int i = 0; i < numTables - 1; i++) {\n                if (entries[i].getOffset() > entries[i + 1].getOffset()) {\n                    DirectoryEntry temp = entries[i];\n                    entries[i] = entries[i + 1];\n                    entries[i + 1] = temp;\n                    modified = true;\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"mas": [" ma", "astics", "mos", "inas", "ages", "fa", "MA", "spec", "ta", "cats", "mag", "marks", "features", "as", "ma", "ins", "meta", "ima", "ms", "alpha", "la", "params", "parts", "ias", "asm", "sa", "asia", "mis", "central", "ams", "ra", "sha", "phi", "cas", "bas", "ums", "data", "names", "las", "mm", "ras", "xs", "mes", "images", "lam", "forms", "ia", "afi", "months", "lambda", "ls", "faces", "pos", "amas", "nas", "mc", "a", "mast", "amps", "pa", "Las", "ga", "rules", "cs", "missing", "os", "ama", "mad", "asa", "space", "mat", "phas"], "sort": ["index", "order", "num", "ort", "cmp", "replace", "id", "lower", "master", "pre", "Sort", "slice", "place", "ind", "o", "l", "s", "ii", "alpha", "split", "offset", "filter", "part", "type", "use", "ji", "lib", "min", "diff", "hide", "par", "alt", "g", "alias", "parent", "default", "ist", "size", "search", "init", "style", "start", "edit", "orient", "adjust", "pos", "label", "position", "update", "parse", "seq", "err", "sign", "ul", "scale", "vert", "axis", "list", "loc"], "j": ["num", "n", "pi", "ij", "ie", "ind", "jc", "z", "o", "l", "si", "ui", "is", "ii", "ji", "d", "q", "li", "h", "x", "p", "bi", "u", "J", "js", "oi", "m", "ci", "I", "it", "jp", "xi", "a", "k", "b", "v", "y", "f"], "i": ["index", "info", "id", "uri", "pi", "ij", "mu", "temp", "ini", "ie", "yi", "slice", "c", "inner", "fi", "z", "o", "ri", "si", "ui", "ii", "in", "ori", "qi", "ji", "ti", "lc", "phi", "data", "li", "ip", "mi", "x", "h", "bi", "u", "init", "uli", "ai", "oi", "ci", "I", "io", "e", "m", "it", "xi", "gi", "jp", "ix", "di", "hi", "a", "k", "v", "b", "ni", "abi", "iu", "multi", "f", "cli", "api", "ik"]}}
{"id1": "21063400", "id2": "822452", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"doImageProcess": ["doThumbnailProcess", "doFileFile", "doThumbnailprocess", "doimageFile", " doimageProcess", " doimageFile", "doimageprocess", " doImageprocess", " doImageFile", "doImageFile", "doFileProcess", "doFileprocess", " doimageprocess", "doImageprocess", "doimageProcess", "doThumbnailFile"], "request": ["path", "input", "Request", "resource", "server", "report", "message", "result", "instance", "query", "req", "client", "type", "reader", "model", "application", "config", "data", "object", "name", "header", "writer", "image", "url", "stream", "xml", "method"], "response": ["index", "server", "output", "resource", "feed", "video", "more", "report", "http", "results", "message", "document", "site", "description", "onse", "json", "result", "version", "location", "host", "pool", "ception", "queue", "next", "client", "session", "cache", "resp", "connection", "model", "application", "collection", "default", "wave", "out", "body", "page", "object", "reply", "complete", "example", "image", "status", "writer", "success", "full", "Response", "respond", " Response", "error", "service", "api", "view"], "imgSize": ["refSize", "hrC", "ifsize", "dimLength", "imgsize", "imgScale", "hrType", "bgLen", "dimSize", "ifSize", " imgsize", "imgLength", "augWidth", "imageName", "bgLength", "imSize", "imagsize", "refLength", "imagType", "imgType", "hrSize", "bgScale", "imagC", "imHeight", "imageLength", "imLength", "imagesize", "augFamily", "bgSize", "imagSize", "imageScale", " imgLen", "imgHeight", "imgWidth", "augLen", " imgScale", "largeSize", "hrsize", "imsize", "augSize", " imgWidth", "ifName", "refHeight", "imageSize", "imgFamily", " imgFamily", "imgName", "refsize", "imageLen", " imgName", "ifLen", "largeType", "largesize", " imgLength", "imgC", "bgWidth", "imgLen", "bgFamily", "dimHeight", "largeC", "dimsize"], "imageInputStream": ["pictureInputstream", "imageReadstream", "fileInputStream", " imageOutputView", "imageInputstream", "imageStreamStream", "photoInputStream", "fileReadstream", "fileInputLength", "imageFileString", "photoReadFile", "imageUploadstream", "pictureUploadstream", "fileReadLength", " imageInputFile", "imageInputString", "imageReadString", "pictureUploadFile", "imageInputSteam", " imageInputView", "pictureUploadSteam", "fileReadString", "imageOutputstream", "pictureUploadStream", "imageReadLength", "imageUploadSteam", "imageContentSteam", "imageOutputFile", "photoInputFile", "pictureInputStream", "pictureInputFile", "imageInLength", "imageStreamFile", "fileReadStream", "imageUploadStream", "imageOutputSteam", "imageUploadFile", "pictureInputSteam", "imageInstream", " imageOutputSteam", "imageFileLength", " imageOutputFile", "imageInputFile", "imageUploadView", "photoReadstream", "imageFilestream", "imageContentStream", "imageFileStream", " imageOutputStream", "imageReadStream", "photoInputSteam", "imageContentFile", "imageStreamSteam", "photoReadStream", " imageInputSteam", "imageReadFile", "photoReadSteam", "imageInStream", "imageReadSteam", "fileInputString", "fileInputstream", "imageInputLength", "imageInString", "imageOutputView", "imageContentView", "photoInputstream", "imageOutputStream", "imageStreamstream", "imageInputView"], "imageBytes": [" imageData", "imageByte", "imgByte", "audioByte", "filebytes", "ImageData", "imageBuffer", "imgBytes", "Imagebytes", "audiobytes", " imageBuffer", " imageUrl", " imagebytes", "viewData", "picturebytes", " imageByte", "imgData", "fileBlocks", "viewbytes", "pictureBlocks", "imagebytes", "audioBuffer", "viewUrl", "imageData", "pictureData", "imageUrl", "imgbytes", "viewBytes", "audioBytes", "ImageBlocks", "imageBlocks", "imgBuffer", "fileBytes", "pictureBytes", "fileData", "ImageBytes", "imgUrl"]}}
{"id1": "15262411", "id2": "949327", "code1": "    String fetch_pls(String pls) {\n        InputStream pstream = null;\n        if (pls.startsWith(\"http://\")) {\n            try {\n                URL url = null;\n                if (running_as_applet) {\n                    url = new URL(getCodeBase(), pls);\n                } else {\n                    url = new URL(pls);\n                }\n                URLConnection urlc = url.openConnection();\n                pstream = urlc.getInputStream();\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        if (pstream == null && !running_as_applet) {\n            try {\n                pstream = new FileInputStream(System.getProperty(\"user.dir\") + System.getProperty(\"file.separator\") + pls);\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        String line = null;\n        while (true) {\n            try {\n                line = readline(pstream);\n            } catch (Exception e) {\n            }\n            if (line == null) {\n                break;\n            }\n            if (line.startsWith(\"File1=\")) {\n                byte[] foo = line.getBytes();\n                int i = 6;\n                for (; i < foo.length; i++) {\n                    if (foo[i] == 0x0d) {\n                        break;\n                    }\n                }\n                return line.substring(6, i);\n            }\n        }\n        return null;\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"fetch_pls": ["fetch_plp", "fetch_pullp", "fetch_Plp", "fetch_Plss", "fetch_pulls", "fetch_Pls", "fetch_pulla", "fetch_pullss", "fetch_pla", "fetch_plss", "fetch_Pla"], "pls": [" plss", "splss", "ptss", "Plf", " Pls", " Plgs", "replb", "bls", "pli", "bli", "splts", " plb", "plses", "ylf", "splses", "splS", "plS", "yls", "replS", "PLS", "PLs", "plts", "Plp", "plb", "ylses", "spls", " plts", "ptS", "Plses", "blgs", "splp", " plp", "replss", "plgs", "splf", "PLss", "plss", " Pli", "ylp", "repls", " pli", "plf", "plp", "pts", "Pls", " plS", "splb", " plgs", "ylts"], "pstream": ["tchannel", "spStream", "parstring", "fengine", "pengine", "pstring", "fstring", " ppath", "PStream", "fstream", "ppstring", "parstream", "Pstream", "ipstream", "tstream", "pschannel", "ppfeed", "ipsource", "prow", "psengine", "spstream", "perstream", "perbody", "psw", "perchannel", "ppstream", "fchannel", "fStream", "tsource", " pchannel", "psstream", " pfeed", "ppsource", "psource", "pchannel", " pStream", "frow", " psource", "Pengine", "ipstring", "Pchannel", "parpath", " psw", "Psw", " punk", "Punk", " prow", "spunk", "pStream", "pfeed", "ppath", "ipfeed", "persource", "psStream", "spsw", "pbody", "fpath", "punk", "tbody", " pbody", " pstring", "parrow"], "url": ["impl", "string", "path", "base", "ssl", "address", "server", "feed", "uri", "resource", "http", "c", "rel", "l", "host", "URL", "fl", "client", "source", "connection", "org", "ob", "build", "open", "file", "web", "page", "ll", "bel", "log", "control", "conn", "ls", "coll", "image", "blog", "link", "sl", "rl", "pull", "Url", "bug", "www", "ur", "b", "ul", "f", "hub", "gl", "service", "api", "loc"], "urlc": ["urll", "urln", "URLp", "Urlc", "URLc", "Urlconn", "URLl", "bbf", "bbci", " urll", " urlconn", "bbn", "Urlp", " urlp", "webn", " urlci", "urlp", "bbc", "URLconn", " urln", "webf", "webc", "urlconn", "urlf", "webci", "urlci", " urlf", "Urll"], "line": ["val", "string", "base", "lo", "lf", "response", "lock", "entry", "message", "LINE", "end", "l", "look", "co", "day", "el", "write", "pass", "ine", "key", "next", "sync", "one", "source", "rule", "lines", "no", "load", "lc", "value", "data", "file", "body", "text", "page", "le", "object", "nl", "log", "row", "inline", "style", "name", "header", "e", "frame", "home", "word", "link", "sl", "strip", "pe", "comment", "lin", "Line", "parse", "b", "block", "error", "definition", "code", "cell"], "foo": ["string", "info", "fun", "fe", "qa", "stuff", "xxxx", "token", "something", "dirty", "oa", "py", "bo", "day", "done", "key", "company", "oo", "la", "flo", "bar", "type", "nice", "value", "buf", "date", "goo", "data", "file", "fb", "page", "floor", "little", "hello", "name", "header", "po", "home", "pos", "prefix", "bug", "que", "f", "office", "field", "code", "front"], "i": ["index", "info", "id", "uri", "pi", "mu", "ini", "c", "j", "fi", "ri", "o", "limit", "l", "end", "si", "ui", "is", "ii", "in", "qi", "vi", "ti", "d", "li", "ip", "x", "p", "mi", "bi", "u", "ai", "oi", "start", "ci", "I", "io", "e", "eni", "xi", "di", "gi", "hi", "ki", "k", "b", "v", "ni", "abi", "multi", "f", "ix"]}}
{"id1": "9267602", "id2": "539195", "code1": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"urltext": ["feedbr", "urlfeed", "URLtext", "urlTEXT", "filename", "URLTEXT", "lltext", "urlname", "feedtext", "feedfeed", "llTEXT", " urlname", "feedname", " urlfeed", "llobject", " urlobject", "filebr", "URLobject", " urlTEXT", "urlobject", " urlbr", "filetext", "filefeed", "urlbr"], "url": ["zip", "string", "base", "buffer", "address", "i", "ssl", "id", "uri", "resource", "server", "feed", "user", "http", "ref", "socket", "l", "URL", "queue", "source", "lib", "jar", "connection", "r", "open", "data", "file", "out", "web", "bel", "page", "log", "name", "ball", "image", "blog", "db", "sl", "Url", "b", "f", "plug", "this", "service"], "in": ["IN", "ssl", "buffer", "i", "input", "id", "loader", "ini", "gin", "into", "inner", "as", "l", "s", "ins", "line", "bin", "read", "is", "client", "cms", "reader", "source", "login", "min", "inside", "r", "inc", "data", "file", "out", "init", "isin", "In", "nin", "kin", "stream", "lin", "b", "err", "inn", "f", "din"], "inputLine": ["outputByte", "outputL", "execStream", " inputData", " inputBlock", "outputData", "outputline", "outputBlock", "InputString", "InputLine", "rawLine", "InputByte", "Inputline", "inputBlock", "rawL", "InputBlock", " inputStream", "inputL", "inputByte", "outputStream", "inputStream", " inputline", "InputL", "execLine", "execData", " inputByte", " inputString", "outputLine", "inputline", "execline", "rawString", " inputL", "inputData", "inputString", "rawline"]}}
{"id1": "701029", "id2": "20568568", "code1": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n", "code2": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"loadSourceCode": ["loadsourcecode", "loadCodeCode", "loadSourcecode", "loadSourceFile", "loadCodeFile", "getSourceCode", "loadsourceFile", "getSourceFile", "getSourcecode", "loadCodecode", "loadsourceCode"], "length": ["zip", "string", "total", "base", "address", "path", "capacity", "buffer", "duration", "class", "id", "lock", "filename", "version", "library", "limit", "number", "end", "l", "read", "time", "key", "weight", "content", "part", "type", "angle", "load", "delay", "value", "len", "Length", "build", "work", "open", "data", "text", "page", "size", "style", "name", "full", "position", "ext", "th", "shape", "ph", "count", "block", "width", "L", "code", "depth"], "file": ["play", "path", "base", "buffer", "loader", "class", "fe", "self", "resource", "fs", "feed", "http", "filename", "fp", "l", "il", "flow", "File", "source", "use", "book", "connection", "FILE", "data", "check", "page", "object", "get", "log", "name", "folder", "e", "force", "io", "image", "db", "full", "files", "pe", "b", "f"], "buff": ["buffer", "Buffer", " text", " arr", " buffer", "uf", "txt", " char", "comp", "utf", " Buffer", " style", "buf", " rest", "ch", " buf", " chars", "text", "bb", " ch", " background", "Buff", " chunk", " buffers"], "is": ["bis", "address", "i", "iss", "resource", "uri", "IS", "serv", "isa", "http", "res", "ie", "Is", "as", "ri", "l", "s", "il", "abs", "fr", "ui", "in", "isl", "ais", "r", "ob", "isc", "ir", "out", "src", "web", "ip", "get", "p", "es", "or", "ris", "io", "it", "ib", "isi", "ur", "err", "are", "os", "ar", "iv", "sr", "api", "loc"], "isr": [" isri", "issrb", "bsrt", "Isrb", "servr", "bsrr", "israr", " islr", "bsr", "isrc", " isrc", "arsrr", "bsrar", "arsrar", "issrc", " isrb", "arsr", "aslr", " isrs", "issri", "ISrc", "asrb", "Isr", "Islr", "isrb", "Isrs", "ISr", "servrar", "isri", "servrt", "asr", "issr", "isrt", "isrr", "islr", "ISri", "arsrt", "isrs", "asrs", "servrr", "ISrb"], "cv": ["cu", "tc", "cc", "sc", "cf", "rc", "vm", "uv", "vr", "c", "fc", "ctrl", "cb", "cam", "gg", "cpp", "VC", "vc", "cm", "cp", "lc", "ctr", "sv", "conv", "vs", "CV", "mc", "ctx", "bc", "nv", "v", "b", "hw", "lv", "vp", "vert", "cur", "vv", "view"], "url": ["string", "path", "base", "ssl", "loader", "address", "server", "resource", "uri", "feed", "id", "http", "lr", "l", "location", "il", "URL", "host", "fr", "el", "fl", "source", "r", "str", "ob", "web", "page", "log", "name", "image", "blog", "link", "sl", "rl", "Url", "stream", "ur", "err", "download", "f", "re", "api", "view", "loc"], "reader": ["ry", "buffer", "handler", "i", "loader", "server", "resource", "editor", "reading", "rc", "builder", "http", "holder", "inner", "ri", "l", "read", "in", "iter", "ler", "er", "source", "player", "bird", "oder", " readers", "ner", "r", "ger", "parser", "war", "ir", "rar", "row", "rr", "or", "rer", "writer", "io", "rx", "worker", "cher", "ser", "stream", "roller", "Reader", "re"], "sourceCode": ["SourceContent", "proxycode", " sourceFile", "parentText", "parentCode", "bytecode", " sourcecode", " sourceLine", "proxyCode", "ourceFile", " sourceContent", "sourceLine", " sourceScript", "parentcode", "sourceFile", "proxyFile", "ourceCode", "sourceContent", "ourceText", "ourceContent", "sourceScript", "sourcecode", "SourceScript", "ourceScript", "SourceLine", "ourcecode", "Sourcecode", "byteLine", " sourceText", "SourceCode", "sourceText", "byteCode"], "line": ["letter", "string", "base", "non", "id", "lf", "entry", "pre", "on", "LINE", "message", "character", "c", "end", "number", "office", "l", "write", "day", "record", "in", "key", "content", "next", "sync", "part", "one", "source", "no", "lines", "lc", "hide", "str", "model", "none", "data", "text", "body", "li", "liner", "page", "ip", "le", "object", "inline", "row", "frame", "word", "link", "sl", "position", "unit", "comment", "lin", "Line", "parse", "error", "element", "code", "auto", "cell"]}}
{"id1": "6371580", "id2": "14464131", "code1": "    public void insertDomain(final List<String> domains) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"domain.add\"));\n                    Iterator<String> iter = domains.iterator();\n                    String domain;\n                    while (iter.hasNext()) {\n                        domain = iter.next();\n                        psImpl.setString(1, domain);\n                        psImpl.setString(2, domain.toLowerCase(locale));\n                        psImpl.executeUpdate();\n                    }\n                }\n            });\n            connection.commit();\n            cmDB.updateDomains(null, null);\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                    log.error(ex);\n                }\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://hostname:80\");\n            URLConnection conn = url.openConnection();\n            for (int i = 0; ; i++) {\n                String headerName = conn.getHeaderFieldKey(i);\n                String headerValue = conn.getHeaderField(i);\n                if (headerName == null && headerValue == null) {\n                    break;\n                }\n                if (headerName == null) {\n                }\n            }\n        } catch (Exception e) {\n        }\n    }\n", "label": 0, "substitutes": {"insertDomain": [" insertdomain", "adddomain", "updatedomain", "addDomain", " insertHost", "updateDomain", "addDom", " insertDom", "addHost", "updateDom", "insertdomain", "insertDom", "insertHost", "updateHost"], "domains": ["Domales", "domages", "demages", "dimains", "demales", "demains", "commains", "Domains", "Domages", "domales", "messands", "messain", "Domands", "commain", "dimands", "dimages", "domances", "commands", "dimales", "messances", "demands", "commances", "demain", "demances", "messains", "domands"], "psImpl": ["osimpl", "qsimpl", "ipsManager", "ipsInstance", "PSFactory", "psFactory", "psInstance", "psUl", " psInterface", " psimpl", " psOrg", "psInterface", "PSImpl", "osEl", "upsImpl", "PSEl", "PSUl", "ipsOrg", "PSOrg", "paramsInterface", "ipsInterface", " psFactory", "psEl", "PSimpl", "ipsImpl", "paramsImpl", "psimpl", "ipsEl", "paramsInstance", "psManager", "qsImpl", "psOrg", "paramsManager", "upsimpl", " psEl", "upsUl", "qsUl", "osImpl", " psInstance", " psManager", "ipsimpl", "osFactory"], "iter": ["ite", "index", "upper", "order", "i", "itter", "cer", "feed", "entry", "inse", "inter", "oper", "inner", "end", "walker", "ter", "set", "gener", "el", "is", "sort", "in", "ider", "next", "loop", "er", "izer", "Iterator", "reader", "ner", "inc", "ir", "page", "ip", "ator", "iterator", "Iter", "coll", "e", "chain", "it", "cher", "parse", "over", "err", "finder", "apper", "former", "enter"], "domain": ["index", "string", "remote", "address", "base", "root", "agent", "node", "id", "division", "site", "message", "version", "description", "result", "origin", "host", "query", "zone", "key", "company", "pattern", "country", "type", "rule", "Domain", "value", "model", "str", "brand", "feature", "data", "file", "route", "region", "page", "product", "format", "name", "folder", "example", "prefix", "role", "url", "unit", "range", "command", "dom", "module"]}}
{"id1": "620855", "id2": "12417893", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doFeatureScan", "doFeatureUpdate", "doversionScan", " doversioncheck", "doFeaturecheck", "doVersionUpdate", "doVersionScan", " doVersionUpdate", "doChangecheck", " doVersionScan", " doversionUpdate", "doChangeUpdate", "doChangeScan", "doversionUpdate", "doFeatureCheck", " doVersioncheck", " doversionScan", "doversionCheck", "doChangeCheck", "doVersioncheck", "doversioncheck", " doversionCheck"], "view": ["index", "base", "vol", "http", "window", "fail", "model", "row", "style", "comment", "container", "server", "self", "lock", "by", "html", "query", "ui", "VIEW", "use", "cache", "up", "value", "View", "vis", "page", "object", "edit", "e", "full", "screen", "link", "review", "can", "v", "views", "list", "event", "head", "video", "el", "session", "see", "show", "group", "div", "body", "box", "change", "image", "update", "im", "display", "cell", "sel", "ou", "input", "user", "pool", "layout", "manager", "form", "client", "config", "out", "check", "widget", "port", "ve", "gu", "block", "this"], "url": ["impl", "zip", "string", "path", "base", "buffer", "loader", "ssl", "address", "server", "uri", "resource", "id", "builder", "http", "socket", "rel", "l", "host", "location", "URL", "fr", "length", "email", "source", "browser", "ob", "open", "file", "web", "bb", "ll", "log", "null", "ls", "name", "image", "blog", "link", "sl", "Url", "www", "stream", "bug", "b", "ul", "f", "hub", "gl", "download", "loc"], "in": ["IN", "sin", "buffer", "pin", "input", "bis", "resource", "ini", "con", "socket", "as", "inner", "s", "ins", "is", "reader", "source", "binary", "doc", "login", "inc", "data", "file", "out", "rin", "init", "again", "m", "isin", "In", "nin", "stream", "lin", "b", "err", "ac", "cin", "inn", "win", "din"], "bin": ["IN", "sin", "buffer", "pin", "loader", "input", "border", "ban", "ini", "lock", "gin", "con", "socket", "inner", "run", "arin", "record", "is", "fin", "reader", "binary", "lib", "browser", "login", "ruby", "body", "file", "out", "vin", "oin", "bb", "bi", "init", "bn", "nb", "spin", "bot", "lin", "b", "abi", "cin", "inn", "win", "din"], "line": ["val", "zip", "string", "letter", "pin", "base", "job", "id", "lf", "user", "entry", "LINE", "ge", "end", "l", "look", "jo", "el", "write", "ine", "key", "part", "type", "one", "lines", "lc", "up", "str", "data", "file", "text", "out", "cl", "page", "le", "nl", "ip", "log", "row", "inline", "object", "name", "e", "word", "link", "sl", "pe", "unit", "comment", "Line", "lin", "b", "range", "parse", "block", "definition", "code", "cell"], "version": ["string", "release", "beta", "server", "video", "id", "user", "option", "author", "project", "python", "patch", "driver", "host", "versions", "code", "type", "support", "cover", "date", "value", "model", "feature", "section", "VERSION", "null", "device", "plugin", "format", "name", "dev", "image", "latest", "pull", "ver", "update", "bug", "unit", "position", "secret", "v", "download", "vert", "Version", "vision", "license", "install"], "build": ["info", "release", "job", "feed", "clean", "builder", "lock", "add", "building", "http", "rel", "run", "patch", "lease", "Build", "tag", "follow", "post", "use", "load", "show", "work", "get", "log", "row", "built", "style", "image", "home", "how", "hold", "link", "mount", "pull", "update", "uild", "unit", "bug", "ver", "print", "make", "help", "block", "boot", "install", "valid"]}}
{"id1": "15745420", "id2": "15362793", "code1": "    private void download(String address, String localFileName) throws UrlNotFoundException, Exception {\n        String ext = G_File.getExtensao(address);\n        if (ext.equals(\"jsp\")) {\n            throw new Exception(\"Erro ao baixar pagina JSP, tipo negado.\" + address);\n        }\n        File temp = new File(localFileName + \".tmp\");\n        if (temp.exists()) temp.delete();\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            try {\n                URL url = new URL(address);\n                conn = url.openConnection();\n                in = conn.getInputStream();\n            } catch (FileNotFoundException e2) {\n                throw new UrlNotFoundException();\n            }\n            out = new BufferedOutputStream(new FileOutputStream(temp));\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n        } catch (UrlNotFoundException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        File oldArq = new File(localFileName);\n        if (oldArq.exists()) {\n            oldArq.delete();\n        }\n        oldArq = null;\n        File nomeFinal = new File(localFileName);\n        temp.renameTo(nomeFinal);\n    }\n", "code2": "    public static String ReadURL(URL url, boolean textonly) {\n        try {\n            URLConnection uconn = url.openConnection();\n            Object ucont = uconn.getContent();\n            if (ucont instanceof InputStream) return ReadInputStream((java.io.InputStream) ucont, textonly); else return \"\" + ucont;\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"download": ["zip", "release", "output", "copy", "register", " downloading", "Download", "save", " transfer", "source", "load", "binary", "upload", "open", "data", "archive", " upload", " Download", "append", "gz", "exec", "dump", "update", "process", "transfer", "handle"], "address": ["index", "string", "path", "base", "remote", "order", "ace", "server", "uri", "output", "resource", "message", "mode", "number", "location", "host", "key", "content", "email", "Address", "type", "source", "target", "ress", "config", "data", "region", "route", "page", "ip", "object", "request", "name", "addr", "image", "port", "array", "pointer", "prefix", "position", "localhost", "point", "reference", "attribute", "service", "enter"], "localFileName": [" localPageName", "localSourceFileType", "globalSourceFileName", "localPageName", "localSourceFileAddress", "localImageSize", "localFilePath", "localFilenameName", "LocalSourceFileType", "LocalFileType", " localFileType", "localSourceFileLocation", "localDirPath", " localFilename", " localPageInfo", "localFilesPath", " localFileSize", "globalSourceFilePath", "localPagePath", "localPageSize", "localfileType", "localPlaceLocation", "localPlaceName", "localImageInfo", "localFilesAddress", "localFileInfo", "globalFilePath", "localPlacePath", "localStreamname", "LocalFileName", "LocalSourceFileNames", "globalFileName", "localImageName", "localSourceFileName", "LocalSourceFileName", "localFileNames", "LocalFileLocation", "globalSourceFileInfo", " localPageSize", "localStreamPath", "localImageType", "localFileAddress", "localFilenameNames", "localFilesName", "localDirInfo", "localFilenameLocation", "globalSourceFileAddress", " localPlaceLocation", "localFilesInfo", "localFileLocation", "LocalFileNames", " localFileLocation", "localFileType", "localfileName", "localfileLocation", " localPageType", "localStreamName", "localSourceFileSize", " localPlacePath", "localSourceFileInfo", "localFilename", "localfileNames", "localPlacename", "localPageLocation", "localDirName", "LocalSourceFileLocation", "globalFileInfo", " localFilePath", "localFileSize", "globalFileAddress", "localSourceFilePath", "localPageType", "localPageInfo", "localFilenameType", " localPlaceName", "localSourceFileNames", " localFileInfo", "localStreamLocation", " localPlacename", "localDirAddress", "localPagename"], "ext": ["zip", "xt", "EXT", "string", "info", "ex", "path", "expl", "enc", "prot", "extra", "content", "req", "txt", "xp", "type", "ect", "dist", "str", "alt", "config", "data", "file", "text", "x", "qt", "Ext", "format", "test", "name", "addr", "exp", "word", "app", "err", "f", "fort", "fx"], "temp": ["zip", "original", "base", "input", "server", "output", "ex", "clean", "lock", "wp", "now", "w", "tem", "wl", "ht", "c", "loc", "Temp", "memory", "iter", "txt", "form", "er", "wrap", "cp", "source", "cache", "valid", "session", "Tem", "old", "store", "parent", "data", "file", "tmp", "flat", "local", "fake", "empty", "pipe", "p", "null", "test", "template", "folder", "tp", "stable", "home", "t", "it", "full", "mount", "unit", " temporary", "v", "f", "porary", "this", "api", "emp"], "out": ["ssl", "i", "outer", "output", "copy", "ex", "server", "lock", "on", "Output", "net", "OUT", "socket", "inner", "con", "plain", "outs", "o", "s", "line", "write", "bin", "off", "key", "password", "sync", "client", "part", "lib", "up", "connection", "login", "not", "other", "inc", "w", "parent", "file", "log", "null", "init", "or", "again", "name", "exec", "Out", "io", "writer", "exp", "image", "call", "In", "prefix", "b", "obj", "err", "and", "cli", "this"], "conn": ["impl", "Connection", "close", "ssl", "Conn", "server", "n", "enc", "con", "c", "socket", "act", "fp", "l", "URL", "fr", "nn", "func", "nc", "client", "sync", "nt", "cm", "cp", "cache", "uc", "ct", "connection", "ch", "inc", "conv", "open", "config", "ll", "init", "ai", "coll", "ci", "exec", "Url", "b", "connect", "cn", "ac", "obj", "cli", "cmd"], "in": ["IN", "index", "pin", "i", "input", "id", "n", "ini", "lock", "by", "con", "inner", "socket", "l", "ins", "s", "bin", "is", "client", "sync", "part", "reader", "source", "lib", "up", "connection", "min", "login", "diff", "r", "inc", "data", "get", "init", "or", "again", "exec", "image", "isin", "it", "In", "nin", "kin", "pull", "lin", "ac", "cin", "inn", "f", "cli", "win", "din"], "url": ["impl", "string", "path", "ssl", "base", "i", "server", "n", "uri", "http", "socket", "l", "host", "URL", "client", "cdn", "source", "connection", "r", "ob", "open", "file", "channel", "web", "bel", "ll", "ls", "image", "blog", "db", "sl", "rl", "layer", "Url", "www", "b", "f", "loc"], "buffer": ["border", "Buffer", "input", "uffer", "feed", "sequence", "slice", "slave", "message", "limit", "result", "number", "length", "bin", "memory", "read", "iter", "queue", "offset", "uf", "reader", "cache", "binary", "buff", "value", "buf", "wave", "data", "bb", "null", "row", "FFER", "bytes", "layer", "position", "flush", "comment", "b", "reference", "padding", "pad", "block", "transfer", "batch"], "numRead": ["Numread", "NumRead", "NumWritten", "commonReader", "numberread", "numberWritten", "NumReader", "numReader", "nread", "commonRead", " numBuild", " numWrite", "numWrite", "umWrite", "nWritten", "nBuild", " numReader", "nRead", "numberBuild", "numBuild", "numread", "nWrite", "commonWrite", "NumWrite", "umWritten", "commonWritten", "numberRead", "umRead", " numread"], "numWritten": ["multiWritten", "NumRead", "multiWrite", "NumWritten", "NumWrit", " numWrit", "Numwritten", "numberWritten", "numberWrite", "numwritten", " numWrite", "numWrite", " numOutput", " numwritten", "numOutput", "multiWrit", "numberOutput", "numWrit", "NumWrite", "multiwritten", "numberRead", "NumOutput"], "oldArq": ["oldArquest", "oldarch", "oldarg", "oldAcqs", "oldParque", "oldarQ", "oldARqu", "oldarq", " oldParque", "OldAcq", "oldArp", "oldARqs", "oldArg", "OldAcquest", "oldArtq", "OldArquest", "OldARq", "OldARch", "oldArtque", "OldArque", " oldArg", "OldARqu", "oldAcq", "oldARQ", "oldParg", "oldArqs", "OldArqs", " oldParq", "oldArtquest", "oldArtqs", "oldArque", "oldDarch", "oldarque", "oldParq", "OldARque", "oldParQ", " oldParg", "oldARque", "oldArtQ", "oldARch", "oldarqu", "oldARquest", "oldAcque", "OldArq", "oldArtp", "oldDarq", "OldArp", "OldArQ", "oldAcQ", "OldAcQ", "OldArch", "oldDarqu", "oldARq", " oldArque", "oldArch", "OldArqu", "OldAcqs", "OldARp", "oldArQ", "oldARg", "oldArqu", " oldParQ", "oldDarque", "oldARp", "OldARQ", "oldAcp", "oldAcquest", " oldArQ"], "nomeFinal": ["navefinal", "nukeFin", "NomeFinal", "noefinal", "nukefinal", " nomesfinal", " nomeFin", "nomenfinal", "nomesFin", "nomefinal", "nomeFin", "NomesFinal", "nomesfinal", "nomesFinal", "Nomefinal", "nukeFinal", "nomenFinal", "noeFinal", "nomenFin", "Nomesfinal", " nomesFinal", " nomefinal", " nomesFin", "naveFinal"]}}
{"id1": "11673907", "id2": "19134229", "code1": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"_checkLanguagesFiles": ["_checkLocations2", "_checklangsFile", "_checkLanesFiles", "_checkLanguagesFile", "_checkLangsFiles", "_checkLangs2", "_checkLangsFile", "_checklangsfiles", "_checkLanguagesfiles", "_checklanguages2", "_checkLanguages2", "_checkLanes2", "_checkLanesfiles", "_checklanguagesfiles", "_checkLangsfiles", "_checkLocationsfiles", "_checklanguagesFiles", "_checkLanesFile", "_checklangs2", "_checklanguagesFile", "_checkLocationsFiles", "_checkLocationsFile", "_checklangsFiles"], "req": ["qt", "info", "base", "Request", "resource", "response", "sem", "rf", "http", "ref", "ctrl", "cb", "fr", "query", "rt", "rou", "proc", "resp", "q", "r", "ch", "request", "requ", "e", "exec", "gr", "Requ", "jp", "ctx", "tr", "app", "err", "obj", "reg", "def", "xml", "f", "this"], "res": ["rest", "RES", "resource", "rc", "results", "resources", "rel", "onse", "ro", "mr", "Res", "ret", "rs", "rem", "params", "proc", "Resp", "resp", "r", "RE", "reply", "rec", "conf", "obj", "err", "def", "ps", "re"], "config": ["rc", "settings", "fig", "Configuration", "project", "admin", "ctrl", "cb", "txt", "client", "Conf", "component", "cl", "conn", "plugin", "Config", "controller", "service", "ctx", "app", "ext", "conf", "obj", "state", "xml", "cfg", "param", " Config"], "form": [" Form", "temp", "Form", "admin", "html", "post", "session", " parent", " act", "FORM", "page", "forms", " forms", "submit", "template", "change", "app", "reg", "obj", "process", "xml", "state", " transform", "mod", "fac", "transform", "view"], "list": ["string", "lang", "id", "lock", "map", "lp", "json", "table", "result", "l", "set", "all", "key", "en", "queue", "la", "LIST", "part", "type", "load", "lc", "live", "not", "diff", "default", "collection", "listed", "data", "ist", "li", "cl", "page", "ll", "p", "language", "null", "lists", "test", "ls", "name", "e", "chain", "array", "err", "bl", "left", "state", "and", "batch", "L", "module"], "i": ["index", "info", "id", "n", "pi", "uri", "ini", "ie", "c", "j", "fi", "ri", "end", "z", "l", "si", "ui", "is", "ii", "in", "key", "ori", "qi", "part", "ti", "type", "ji", "li", "ip", "x", "p", "h", "bi", "u", "ai", "oi", "start", "ci", "I", "e", "io", "m", "zi", "eni", "xi", "di", "gi", "hi", "k", "v", "count", "iu", "multi", "f", "ix"], "langId": ["angDef", " languageInfo", "languageId", "languageInfo", "langCode", "angId", "libid", "libId", "lcId", "blockInt", " langID", "languageDef", " languageDef", "langInt", "blockID", "libID", "blockId", "languageID", "angID", " languageCode", " languageInt", "langid", "langID", "langInfo", "lcID", " languageID", "angInfo", "blockCode", " langid", " langInt", "lcid", " langCode", " languageId", "langDef"], "filePath": ["FilePath", "keyName", "fileUrl", " fileLocation", "FileAbs", " fileName", "FileUrl", "keySet", "fileInfo", "keyPath", "FileSet", "fileAbs", "fileName", "fileSet", " fileSet", " fileInfo", "contentInfo", "contentPath", " fileUrl", "keyLocation", "FileInfo", "contentAbs", " fileAbs", "fileLocation", "FileName", "contentUrl", "FileLocation"], "from": ["path", "base", "ou", "class", "address", "self", "id", "resource", "vol", "user", "by", "add", "on", "se", "code", "via", "in", "client", "part", "one", "source", "back", "ce", "without", "before", "connection", "old", "component", "module", "parent", "data", "file", "out", "object", "log", "or", "about", "start", "name", "normal", "a", "url", "of", "create", "left", "with", "From", "f", "this", "view", "front"], "tmpFilePath": ["tmpFilesPath", "tmpPlaceName", "mpFilePath", "mpfilepath", "tmpPlacepath", "tmpfileLocation", "tmpSourceFileUrl", "tmpfileFile", "tmpSourceFilePath", "mpFileLocation", "mpfileLocation", "tmpfilePath", " tmpDirUrl", "mpfileName", "mpfilePath", "tmpDirId", "tmpFileFile", "tmpFilepath", " tmpFileId", "mpFileName", " tmpFileUrl", "tmpPlaceLocation", " tmpDirId", " tmpDirFile", "tmpSourceFileId", "tmpfileId", "tmpFilespath", "tmpFilesName", "tmpFilesLocation", "tmpFileId", " tmpDirPath", "tmpfileName", "tmpFileLocation", " tmpFileFile", "tmpSourceFileFile", "tmpfileUrl", "tmpDirFile", "tmpDirUrl", "tmpDirPath", "mpFilepath", "tmpfilepath", "tmpFileName", "tmpPlacePath", "tmpFileUrl"], "to": ["remove", "tom", "base", "until", "token", "eto", "by", "op", "on", "auto", "dest", "o", "co", "will", "TO", "two", "client", "part", "at", "so", "one", "source", "type", "not", "target", "store", "file", "To", "out", "tmp", "page", "size", "style", "or", "about", "po", "name", "io", "t", "toc", "too", "top", "with", "office", "oe", "this", "point"], "copy": ["zip", "core", "cross", "Copy", "replace", "move", "ge", "clip", "match", "write", "save", "clone", "quote", "sync", "cop", "like", "one", "type", "load", "cover", "use", "cp", "media", "hide", "shared", "license", "store", "cat", "ignore", "open", "share", "archive", "check", "same", "size", "null", "delete", "coll", "force", "change", "image", "skip", "compatible", "create", "opy", "transfer", "download", "protect", "code"], "srcChannel": ["sourceContext", "srcConnection", "rcchannel", "inputChannel", "rcCamera", "srcchannel", "inputchannel", "sourcechannel", " srcCamera", "sourceChannel", "sourceHandler", "rcHandler", " srcHandler", "destChan", " srcConnection", "inputHandler", " srcContext", "srcHandler", "destHandler", "srcCamera", "inputConnection", " srcButton", "sourceConnection", "destchannel", " srcchannel", "srcContext", "rcChan", "inputCamera", "rcButton", " srcChan", "rcChannel", "destChannel", "srcChan", "sourceButton", "rcContext", "rcConnection", "srcButton"], "dstChannel": ["drestConnection", "drcchannel", "Destchannel", "dsrcChannel", "drestStream", "dstStream", "DestConnection", "drcChannel", "drdChannel", "dstsStream", "DstConnection", "Dndchannel", " destConnection", "ddestButton", " dstchannel", "dstsConnection", "drestChannel", "dstButton", "DestChannel", "dstConnection", "dndChannel", "dsrcConnection", "dndchannel", "drcConnection", "ddestConnection", "drdConnection", "destStream", "drestchannel", "DstButton", "DndConnection", " destChannel", "dstschannel", "destchannel", "dndConnection", "dsrcchannel", " dstConnection", "dstsChannel", " destchannel", "destButton", "DndChannel", " destStream", "DestButton", "Dstchannel", "ddestChannel", "destConnection", "destChannel", "drcButton", "ddestchannel", "dstchannel", "drdchannel", " dstStream", "DstChannel"]}}
{"id1": "4468255", "id2": "20128728", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["zip", "info", "ssh", "Copy", "replace", "move", "clip", "write", "save", "clone", "split", "sync", "cop", "cp", "load", "cat", " cp", "file", "share", "ignore", "get", "put", "log", "delete", "link", "dump", "update", "create", "parse", "paste", "rm", "process", "opy", "transfer", "download"], "from": [" the", "path", "original", "base", "zip", "string", "id", "resource", "vol", "user", "by", "add", "http", "entry", " form", "c", "o", "html", "se", "code", "ate", "form", "er", "part", "client", "one", "source", "ce", "at", "without", "dir", "connection", "old", "before", "the", "open", "parent", "data", "file", "config", "empty", "log", "context", "or", "name", "start", "e", "io", "normal", "back", "link", "url", "of", "stream", "left", "range", "with", "From", "missing", "os", "f", "so", "this", " file"], "to": ["root", "base", "temp", "output", "resource", "token", "eto", "http", "on", "as", "jo", "database", "son", "not", "file", "dis", "toc", "termin", "sp", "office", "plus", "by", "site", "all", "sync", "so", "source", "cache", "load", "dir", "connection", "parent", "about", "name", "process", "disk", "storage", "path", "tom", "system", "socket", "o", "se", "line", "tto", "TO", "two", "flo", "comp", "one", "stat", "back", "no", "To", "p", "null", "or", "template", "io", "yet", "os", "auto", "front", "user", "client", "target", "data", "de", "x", "size", "po", "but", "t", "db", "pe", "too", "me", "top"], "result": ["val", "event", "info", "method", "sum", "accept", "plus", "replace", "mask", "ult", "rc", "lock", "continue", "results", "res", "ure", "entry", "report", "var", "ok", "current", "match", "length", "pass", "ret", "follow", "fail", "die", "arr", "part", "allow", "true", "cache", "use", "source", "up", "diff", "member", "date", "r", "default", "work", "data", "math", "search", "test", "effect", "force", "status", "card", "function", "success", "ver", "url", "comment", "mer", "err", "compl", "future", "br", "sign", "Result", "found", "count", "error", "cur", "term", "valid"], "subFiles": ["Subfiles", "ubFiles", " subParents", " subFile", "partfiles", " subPages", "ubDir", "singfiles", "singFs", "ubfiles", "partParents", "newFiles", "partFiles", "subPages", "subContents", "subDir", " subFs", "ubPages", "subParents", "SubContents", "SubFiles", "newfiles", "newPages", " subDir", "subTokens", "newParts", " subParts", "singFiles", "SubPages", " subTokens", " subContents", "newsFiles", "subFile", "ubContents", "SubFile", "SubTokens", "newsParts", "subParts", "subFs", "newsfiles", "singParents", "ubFile", "newsTokens", "newFile", "subfiles", "partFs", "SubParts", " subfiles"], "i": ["index", "id", "n", "pi", "uri", "ini", "ie", "slice", "c", "inner", "j", "ri", "o", "l", "s", "si", "ui", "is", "ii", "ori", "key", "ti", "d", "phi", "q", "li", "ip", "x", "p", "h", "mi", "u", "bi", "ai", "name", "oi", "ci", "I", "e", "io", "it", "xi", "di", "gi", "hi", "a", "k", "b", "v", "y", "iu", "multi", "f", "iv", "ix"], "newDir": [" newD", "NewDirectory", "nowDIR", "nowDirectory", "nextQu", "oldDir", "NewD", "nextFile", "nextFolder", "subDir", "oldFile", "subFolder", "newJar", "newQu", "newDirectory", "newDIR", "NewJar", "subD", "NewFile", "nextDirectory", "newFolder", " newDIR", " newFile", "newD", "subFile", " newJar", " newFolder", "nextDir", "subDirectory", "nowDir", "subJar", "NewFolder", " newDirectory", "oldFolder", "oldDirectory", "subQu", "NewDir", "oldDIR", "newFile", " newQu", "nowFolder"], "in": ["IN", "index", "pin", "input", "ex", "id", "serv", "ini", "lock", "gin", "on", "ie", "con", "c", "inner", "socket", "o", "l", "ins", "bin", "is", "part", "reader", "thin", "source", "up", "login", "min", "diff", "r", "inc", "data", "file", "init", "conn", "again", "e", "m", "image", "re", "isin", "it", "In", "nin", "a", "pull", "url", "lin", "b", "err", "cin", "inn", "f", "win", "this", "din"], "out": ["base", "ou", "sum", "ex", "output", "n", "serv", "op", "lock", "on", "net", "OUT", "socket", "inner", "c", "outs", "o", "all", "off", "write", "line", "bin", "co", "post", "sync", "client", "at", "one", "lib", "up", "cat", "cy", "w", "ch", "inc", "file", "log", "conn", "again", "name", "exec", "Out", "writer", "io", "exp", "call", "word", "ext", "can", "b", "err", "obj", "with", "img"], "fileLength": ["lineLength", " fileSize", "FileSize", "fileSize", "Filelength", " fileLen", "pageName", "baseSize", "fileLen", " fileName", "filelength", "pageLength", "FileLength", " filelength", "fileName", "baseLen", "pagelength", "linelength", "FileLen", "pageSize", "lineSize", "baselength", "lineName", "baseLength"], "charBuff": ["stringMatrix", " charBuffer", " charMatrix", "stringBuffer", "pairMatrix", "charBuffer", "pairBuff", "pairBuffer", "stringBuff", "charMatrix"], "len": ["val", "id", "lf", "cmp", "n", "Len", " pos", "l", "line", "bin", "en", "iter", "split", "fl", "fin", "nt", "part", "li", "lit", "start", " split", "name", "pos", "rev", "ln", " Len", "ni"], "oneChar": [" oneCor", " oneCh", " onechar", "fourCor", " oneCharacter", "singleCar", "singlechar", "singleCharacter", "zeroCharacter", "nextChar", "zerochar", "onechar", "singleCh", "zeroChar", "singleChar", "zeroCor", " oneCar", "nextCh", "oneCar", "fourchar", "eachCharacter", "singleCor", "fourChar", "nextCor", "eachchar", "eachChar", "oneCharacter", "oneCh", "eachCor", "fourCharacter", "oneCor", "nextCar"]}}
{"id1": "22401746", "id2": "8047989", "code1": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"sendRequest": ["processRequest", "processObject", " sendObject", "sendResponse", " sendResponse", "sendrequest", "submitRequest", "sendObject", "submitObject", "processrequest", "submitrequest", "submitResponse", " sendrequest", "processResponse"], "servletName": ["servlename", "servLETname", "servletsname", "servletsUrl", " servletPath", " servleNames", "servLETNames", "servletname", "servletPath", "servletsNames", "servleVersion", "servletonName", "servleUrl", " servletVersion", "servletsPath", "servletNames", "servletonPath", " servleUrl", " servletname", "servLETPath", "servletUrl", "servletVersion", " servletNames", " servlename", "servLETName", "servletsVersion", " servleName", "servLETVersion", "servletonVersion", "servleName", " servlePath", "servleNames", " servleVersion", " servletUrl", "servletonNames", "servLETUrl", "servletsName", "servlePath"], "request": ["string", "path", "info", "buffer", "address", "input", "Request", "resource", "response", "server", "uri", "report", "message", "json", "document", "python", "result", "query", "queue", "req", "content", "type", "q", "application", "config", "data", "text", "object", "hello", "complete", "name", "header", "frame", "create", "xml", "method"], "reqxml": ["reqdoc", "requestdoc", "requestdocument", "Requestdocument", "Requestdoc", " reqdocument", " reqdoc", "reqdocument", "Requestxml", "requestxml"], "retdoc": [" retdata", " retconf", " resultxml", " resultconf", "retconf", "retxml", " resultdoc", "retdata", " backdata", " resultdata", " retxml", " backxml", " backdoc", " backconf"], "myurl": [" myURL", "MyUrl", "yourUrl", "myUrl", "Myurl", "yourURL", " myhost", "myaddress", "yoururl", "Myhost", "yourhost", "Myaddress", " myaddress", "myURL", " myUrl", "serverhost", "serveraddress", "MyURL", "youraddress", "myhost", "serverurl"], "myport": ["MYurl", "memberurl", "serverurl", "myPORT", " myort", "Myport", "memberPort", "somehost", "someip", "Myurl", "somePort", "yourip", "serverport", "someurl", " myhost", "Myort", "someport", "yoururl", "MyPORT", "Myhost", " myPORT", "yourPort", "serverphone", "myort", "memberport", "memberip", "MyPort", " myphone", "myPort", "MYPort", "MYPORT", "somePORT", "MYhost", "yourphone", "serverPort", "myip", " myPort", "MYport", "myhost", "myphone", "yourport", "someort"], "codebase": [" codebas", "Codebas", "codBase", "forebase", " codeurl", "foreb", "foreurl", "Codeurl", "foreBase", "CodeBase", " codeBase", "codebas", "Codeb", "Codebase", "codeurl", "codeBase", " codeb", "codb", "codeb", "forebas", "codbase"], "serverURL": ["myUrl", "slaveAddress", "siteDirectory", "slaveUrl", "testUrl", " serverURI", " serverID", "serverFolder", "hostUrl", "slaveURL", " serverurl", "databaseUrl", "erverUrl", "myURL", "myJSON", "testURL", "testURI", "databaseURI", "serverLevel", "serverBUG", "testLocation", "siteURL", "serverDirectory", "erverPage", "siteAddress", "erverurl", "siteLocation", "localhostUrl", "siteFolder", "databaseURL", " serverUrl", "erverFolder", " serverLevel", "serverURI", "sitePage", "siteID", " serverJSON", "hostURI", "slaveFolder", "serverLocation", "localhostURL", "remoteBUG", "serverID", "erverAddress", "hosturl", "localhostDirectory", " serverLocation", "erverURL", "remoteURL", "serverUrl", "hostURL", "erverBUG", "myLevel", "erverLevel", "myID", "serverJSON", "serverPage", "remoteurl", "siteURI", "siteUrl", "remoteUrl", "erverJSON", "siteurl", " serverBUG", "erverDirectory", "localhostPage", "remoteURI", "serverAddress", "myURI", "testurl", "serverurl"], "ipdig": ["ppDig", "idDig", "opdiff", "ppplug", "IPdig", "ipgen", " ipDig", "IPdiff", "IPcr", "ipcr", "ipdb", "ipsDig", "ipdiff", "opdig", "ipcomb", "ipsdig", "ppdig", "ipsdb", "ppcr", "IPdone", "idplug", "IPplug", " ipcomb", "IPDig", " ipplug", "IPgen", "opcomb", "ipplug", "IPdb", "ipDig", " ipdb", "iddig", "ipsgen", "ipdone", " ipgen", "iddone", "opDig", " ipdiff", "IPcomb", " ipdone", " ipcr"], "url": ["event", "path", "ssl", "class", "server", "resource", "uri", "user", "http", "rel", "l", "host", "URL", "util", "key", "req", "fl", "client", "twitter", "connection", "browser", "str", "config", "file", "cl", "web", "page", "object", "ll", "log", "conn", "name", "ls", "coll", "sl", " http", "pull", "Url", "update", "www", " curl", "f", "gl", "org"], "urlconn": ["httpconnection", "urlclient", " urlclient", "urlcon", "urlcn", " urlcon", "slconv", "llConn", " urlconf", "llcon", "httpconn", " urlConn", " urlconnection", "httpcon", "sslconf", "webcon", "llconn", "flconnection", "httpConn", " urlcn", "flconn", "sslConn", "sslcon", "urlconnection", "slcon", "flcon", "httpcn", "sslconn", "slclient", "webconv", "flConn", "llconnection", "flcn", "urlConn", "urlconf", "webclient", "urlconv", "webconn", "slconn", "httpconf", " urlconv"], "os": ["fs", "Os", "op", "res", "ns", "as", "OS", "o", "bs", "is", "ms", "rs", "so", "ops", "ips", "es", "or", "vs", "ls", "io", "oss", "ot", "pos", "us", "obj", "ds", "ps"], "req1xml": ["req1request", "req0xml", "req0request", "req_request", "request2x", "request1x", "req0x", "request1xml", "req2txt", "req_txt", "request2xml", "req_xml", "request1request", "req_x", "req0txt", "req2x", "req1txt", "request1txt", "req2request", "request2request", "request2txt", "req2xml", "req1x"], "cos": [" tar", " ze", " compress", " rc", " pos", "outs", " temp", "is", " contents", " enc", " ro", " iss", " outs", " dd", " ss", " bytes", " zipper", " po", "pos", " bos", " downloads", " cs", " repo", " fo", " socks", "cs", " compression", " cc"]}}
{"id1": "5760649", "id2": "14390569", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "label": 1, "substitutes": {"createFile": ["saveFolder", "createFolder", "saveResource", " createResource", "createContent", "createResource", "saveContent", "CreateContent", "CreateFile", " createFolder", "CreateResource", "saveFile", "CreateFolder", " createContent"], "src": ["string", "path", "sel", "ssl", "input", "sc", "resource", "uri", "username", "rc", "Source", "resources", "slice", "cb", "fp", "dest", "fn", "s", "content", "txt", "gb", "sit", "source", "load", "rb", "sb", "proc", "buf", "r", "upload", "SourceFile", "data", "file", "ruby", "img", "href", "name", "rss", "rob", "sl", "secure", "files", "url", "stream", "obj", "loc"], "filename": ["directory", "string", "path", "loader", "sf", "uri", "output", "username", "resource", "dll", "ames", "fp", "fn", "location", "length", "l", "ame", "s", "feat", "txt", "utf", "source", "Filename", "wb", "which", "FILE", "SourceFile", "acl", "file", "route", "metadata", "nil", "title", "name", "fil", "prefix", "rl", "files", "url", "f", "ename"], "fis": ["Fris", "fais", "fIS", "sfis", " fais", " fris", "cfais", "cfis", "Fbs", " fiss", "fris", "FIS", "sfiss", "Fais", " fIS", "cfos", "Fis", "Fos", "cfIS", "sfos", "fbs", "cfris", "fiss", " fbs", "Fiss", "sfris", "cfbs"], "fos": ["fops", "bis", "sfis", "forOS", "affbos", "foris", " fops", "foros", "affis", "FOS", "bos", " fOS", "affos", "Fis", "Fos", "Fas", "affios", "bios", "fios", " fas", "sfios", "foras", "sfos", "sfops", "Fops", "fas", "Fbos", "Fios", "fOS", "bbos", " fios", "fbos"]}}
{"id1": "12197169", "id2": "2465747", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 1, "substitutes": {"read": ["Read", "replace", "reading", "continue", "report", "end", "run", "write", "ready", "loop", "reader", "load", "open", "work", "check", "request", "get", "init", "start", "readable", "stream", "parse", "create", "println", "print", "process", "download"], "in": ["IN", "path", "info", "ssl", "buffer", "input", "server", "id", "n", "token", "ex", "ini", "by", "on", "con", "c", "inner", "o", "l", "ins", "s", "fr", "bin", "is", "er", "cms", "at", "reader", "source", "doc", "login", "min", "connection", "r", "inc", "data", "file", "out", "log", "conn", "again", "e", "io", "image", "ing", "isin", "it", "In", "nin", "a", "url", "index", "of", "stream", "b", "err", "scan", "inn", "f", "error", "din", "from"], "line": ["val", "string", "buffer", "id", "lf", "entry", "LINE", "message", "ge", "end", "se", "col", "l", "el", "record", "ine", "key", "source", "reader", "lines", "lc", "value", "str", "data", "file", "text", "page", "le", "object", "log", "row", "inline", "ne", "name", "e", "frame", "status", "link", "sl", "url", "unit", "comment", "lin", "Line", "b", "parse", "block", "f", "L", "code", "cell"], "i": ["index", "info", "n", "pi", "ini", "ie", "slice", "j", "fi", "ri", "o", "l", "si", "ui", "is", "ii", "ori", "qi", "ti", "phi", "li", "ip", "x", "p", "bi", "u", "oi", "ai", "uni", "ci", "I", "io", "e", "eni", "zi", "ski", "xi", "gi", "di", "b", "ni", "abi", "f", "ix"], "logDatum": ["exDData", "logdum", "logDictionary", "logDum", "exDictionary", "Logdict", "logDatatum", "logDsatum", "logFam", "exDDam", "Logdata", "LogData", "exData", "logFatum", "Logdatum", "logDData", "logData", "logdict", "logdatum", "logDsict", "LogDatum", "Logdum", "logDict", "logDam", "logdata", "logDatictionary", "LogDict", "logDsata", "logDDam", "exDam", "logDDictionary", "exDDictionary", "logFictionary", "LogDum", "logDDatum", "logDatata", "logDatict", "logDsum", "logFata", "exDDatum", "logDatam", "exDatum"]}}
{"id1": "12085127", "id2": "18370075", "code1": "    public final void navigate(final URL url) {\n        try {\n            EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url);\n            final URLConnection connection = url.openConnection();\n            final InputStream is = connection.getInputStream();\n            navigate(url, is);\n            is.close();\n        } catch (final IOException e) {\n            EncogLogging.log(EncogLogging.LEVEL_ERROR, e);\n            throw new BrowseError(e);\n        }\n    }\n", "code2": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "label": 0, "substitutes": {"navigate": [" Navig", "ajigating", "ajigate", "ivigate", " Navigation", "navigated", "Navigating", "avigating", "ajig", "ivigation", "avigation", "navigating", "ivigated", " Navigating", "Navigate", "Navig", "Navigation", "avigate", " Navigate", "navig", "ajigation", "ivigating", "navigation", "avigated", "Navigated"], "url": ["article", "address", "base", "job", "ssl", "i", "server", "uri", "resource", "feed", "id", "user", "entry", "http", "c", "html", "l", "host", "location", "URL", "account", "fr", "follow", "client", "source", "rule", "str", "r", "org", "build", "config", "file", "route", "page", "object", "ll", "web", "plugin", "e", "image", "blog", "link", "sl", "Url", "position", "www", "bug", "obj", "f", "gl", "element", "service", "api"], "connection": ["Connection", "handler", "i", "server", "resource", "response", "uri", "cf", "http", "ie", "character", "con", "c", "socket", "connected", "l", "database", "condition", "client", "session", "lc", "proxy", "which", "application", "open", "channel", "page", "context", "conn", "or", "coll", "ci", "io", "link", "position", "bc", "unit", "b", "connect", "wrapper", "communication", "loc"], "is": ["info", "bis", "i", "iss", "lis", "serv", "fs", "IS", "isa", "gets", "Is", "as", "api", "ins", "bs", "abs", "il", "s", "ui", "ii", "in", "isl", "its", "was", "ops", "ais", "isc", "ir", "ip", "es", "ai", "ris", "ci", "io", "iris", "ils", "ios", "us", "ib", "isi", "cs", "os", "isu", "im", "iso", "mis"]}}
{"id1": "21754659", "id2": "21092340", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "label": 1, "substitutes": {"getButtonSonido": ["getbuttonSenira", "getbuttonSonido", "getbuttonSonico", "getButtonSenira", "getbuttonSenido", "getButtonSenico", "getButtonSonico", "getButtonSonendo", "getbuttonSonendo", "getbuttonSenico", "getButtonSonira", "getButtonJonira", "getButtonSenendo", "getButtonJonendo", "getButtonJonico", "getButtonJonido", "getButtonSenido", "getbuttonSonira", "getbuttonSenendo"], "buttonSonido": ["buttonDonido", "buttonSenado", "buttonsonini", "btnDonigo", "buttonSenigo", "buttonDonino", "buttonSenino", "buttonTanido", " buttonSonino", "buttonSenardo", "buttonSonini", "btnSonigo", "ButtonSonardo", "ButtonSonini", "buttonHonino", "ButtonDonado", "btnSonado", "buttonSenini", "btnDonardo", "buttonTanida", " buttonSonardo", " buttonSonado", "ButtonDonardo", " buttonSenado", "btnSonini", "buttonDonida", "buttonsonido", "buttonSenida", " buttonSenida", "buttonHomido", "buttonHonardo", "btnSonardo", "btnSonido", "buttonTanado", " buttonSenardo", "buttonSonardo", "buttonSonino", "buttonHonido", "buttonHonado", " buttonSenido", "buttonSonado", "buttonHomado", " buttonSenino", "btnDonado", " buttonSonida", "ButtonSonado", "buttonDonado", "buttonsonardo", "buttonsonado", "buttonHomardo", "buttonsonigo", "ButtonDonini", "buttonTanardo", "ButtonSonido", "btnDonido", "buttonSonigo", "buttonDonini", "buttonSenido", "ButtonDonida", "buttonHomida", "buttonDonardo", "buttonSonida", "ButtonSonida", "buttonDonigo", "ButtonDonido"], "e": ["event", " exception", "ee", " exc", " ignored", " en", " other", " caught", " inst", " pe", " ace", " te", " events", " exp", " E", " je", " ate", " invoked", "E", " ev", "t", " fe", " cause", " ie", "ed", " Event", "Event"], "fc": ["tc", "fe", "xf", "bf", "fa", "fs", "lf", "cf", "enc", "WF", "con", "GF", "c", "wk", "fi", "fp", "FE", "fn", "il", "wt", "fw", "irc", "fr", "dc", "nc", "fl", "ec", "flo", "PF", "lc", "ct", "wic", "roc", "isc", "fed", "WC", "fb", "xc", "FS", "DC", "fm", "af", "LC", "F", "pc", "fd", "mc", "bc", "CF", "Factory", "FC", "f", " FC", "fx"], "returnVal": ["ReturnVal", " returnVAL", "ReturnValue", "returnValue", "returnVAL", "backval", " returnNum", "continueValue", "ReturnVAL", "backVAL", "continueVal", "backValue", "returnNum", "returnval", "continueval", " returnValue", "Returnval", "ReturnNum", " returnval", "continueNum", "backVal"], "file": ["directory", "zip", "path", "info", "base", "class", "handler", "fe", "sf", "input", "resource", "uri", "ile", "cf", "user", "lock", "feed", "http", "document", "filename", "per", "message", "socket", "fp", "l", "global", "php", "File", "part", "type", "use", "source", "binary", "dir", "lib", "up", "connection", "FILE", "data", "out", "local", "page", "object", "get", "log", "single", "name", "folder", "image", "io", "to", "function", "db", "full", "files", "url", "b", "f"], "rutaGlobal": ["rutaReal", "srottaLocal", "rottaLocal", "srutaGlobal", "rutiCore", "srettaReal", "rutoCore", "rutaGeneral", "rutaLocal", "srottaCore", "rutiReal", "srettaInternational", "rundaGlobal", " rutaGeneral", "rucaGlobal", "rucaInternational", "rutoInternational", "srutaReal", " rutoGlobal", "rugaInternational", "rutiGlobal", "rottaGlobal", "srottaGeneral", "rettaReal", " rutoInternational", "rutaCore", "srutaGeneral", "rutiGeneral", " rutoGeneral", "rottaGeneral", "rugaGlobal", "rutoLocal", "rettaLocal", "srutaLocal", "srettaLocal", "srottaGlobal", "rundaGeneral", "rettaGlobal", "srutaInternational", "srutaCore", "rutiInternational", "rottaCore", " rutaInternational", "rugaLocal", "rutoGlobal", "rutaInternational", "srettaGlobal", "rucaGeneral", "rugaReal", "rettaInternational", "rutiLocal", "rundaInternational", "rutoGeneral"], "rutaRelativa": ["rutaRelattiv", "rutaRelariva", "rutaRelativ", "rutaMalarivo", "rutaRelateiva", "rutaRelATiva", "rutaRelateivo", "rutaRelarivism", "rutaMalativism", "rutaRelarativ", "rutaRelariv", "rutaRelarativas", "rutaRelarivo", "rutaRelATiv", "rutaRelATivo", "rutaRelarativo", "rutaRelattiva", "rutaRelATivas", "rutaRelattivism", "rutaRelateivism", "rutaRelarativa", "rutaMalativo", "rutaRelativo", "rutaRelattivo", "rutaRelativas", "rutaMalarivas", "rutaMalativa", "rutaMalarivism", "rutaRelativism", "rutaRelarivas", "rutaMalariva", "rutaRelateiv", "rutaMalativas", "rutaRelarativism", "rutaRelattivas"], "fis": ["Fris", "Fys", "xys", "vos", "frir", "fros", " fir", " fris", "viss", " fiss", "fris", "xis", "xiss", "fys", " fys", " fIs", "FIs", "vIs", "vis", "Fis", "Fos", "xris", "friss", "Fir", "fIs", "fiss", "fir", "Fiss"], "fos": ["fops", "fileocks", "tfOS", "focks", "tfos", " fops", "tfops", "infis", "infos", "infOS", "FOS", "infios", "fileo", "Focks", "tfo", " fOS", "Fos", "Fis", "fileops", "fios", "fo", "Fops", "Fo", " fo", "Fios", "fOS", " fios", "fileos", " focks"], "canalFuente": ["canalKuence", "canalsFuent", "canalBuence", "canulFuence", "canalsFuento", "canalsFuente", "canalBuante", "canalJuencer", "canulFience", "canalMuent", "canalJuent", "canalMuente", "canalfuence", "canalFUante", "canulFiencer", "canalfugent", "canalMuencer", "canallBuence", "canalFience", "canulFuent", "canulFient", "canalFugent", "canallBuenza", "canalFuent", "canalsBuento", "canalFUente", "canulFiente", "canalsBuente", "canalJuence", "canalBugent", "canalFuencer", "canalMuence", "canalFuenza", "canulFuencer", "canalfuente", "canalKuente", "canalsBuent", "canalBuenza", "canalBuent", "canalBuente", "canalJuente", "canalsBuante", "canalFuence", "canalJuento", "canallFuente", "canalfuenza", "canulFuente", "canallBuente", "canalFiencer", "canalFuento", "canallFuence", "canalKugent", "canalFUento", "canalFUent", "canalsFuante", "canalFient", "canalBuento", "canalJuante", "canalFuante", "canalFiente", "canallFugent", "canalKuenza", "canallFuenza", "canallBugent"], "canalDestino": ["canallDestania", "canelDestina", "canallDestina", "canalNegino", "canaldestania", "canalCampina", "canelDestino", "canalCampino", "canalldestinos", "canelDestania", "canalDestina", "canalCampination", "canalldestina", "canallDestinos", "canaldestinos", "canelDestination", "canalNegania", "canaldestination", "canalNegina", "canallDestino", "canelCampania", "canalCampania", "canalDestination", "canelCampino", "canalCampinos", "canalDestania", "canelCampination", "canalldestania", "canalNegination", "canalDestinos", "canaldestino", "canaldestina", "canalldestino", "canelCampina"]}}
{"id1": "10759917", "id2": "17116123", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 1, "substitutes": {"delete": ["remove", "execute", "id", "drop", "register", " deleting", "destroy", "write", "save", "database", "post", "sync", "load", "connection", "de", "Delete", "get", "exec", " deletion", "del", "dump", "link", "flush", "update", "create", " Delete", " destroy"], "name": ["NAME", "string", "path", "info", "class", "address", "space", "id", "n", "resource", "base", "on", "now", "filename", "version", "table", "ame", "pass", "time", "database", "active", "key", "client", "part", "like", "type", "no", "true", "one", "value", "old", "model", "default", "alias", "parent", "names", "data", "none", "object", "size", "null", "style", "Name", "e", "action", "label", "word", "link", "prefix", "false", "url", "comment", "create", "missing", "named", "definition", "code"], "CannotDeleteSystemLinkException": ["CannotDeleteSystemLinksException", "CannotDeleteSystemReferenceError", "CannotDeleteSystemLinkEx", "CannotDeleteClassLinkException", "CannotDeleteSystemLinkError", "CannotDeleteClassLinkApplication", "CannotDeleteSystemRelException", "CannotDeleteSystemReferenceEx", "CannotDeleteSysLinkException", "CannotDeleteSystemReferenceception", "CannotDeleteSystemlinkException", "CannotDeleteSystemLinksInformation", "CannotDeleteSystemLinksception", "CannotDeleteSystemRelception", "CannotDeleteSystemReferenceException", "CannotDeleteSystemLinkApplication", "CannotDeleteClassLinkception", "CannotDeleteSysLinkError", "CannotDeleteSystemRelError", "CannotDeleteSystemLinkInformation", "CannotDeleteSystemRelEx", "CannotDeleteSysLinkception", "CannotDeleteClassLinkInformation", "CannotDeleteSysLinkEx", "CannotDeleteSystemLinksApplication", "CannotDeleteSystemlinkception", "CannotDeleteSystemlinkInformation", "CannotDeleteSystemlinkApplication", "CannotDeleteSystemLinkception"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeNotfoundError", "ClassLinkTypeNotSourceError", "ClassLinkTypeNotfoundRequest", "ClassLinkTypeNotfoundException", "ClassLinkTypeNotFoundRequest", "ClassLinkTypeNotFoundError", "ClassLinkTypeNotSourceRequest", "ClassLinkTypeNotSourceException"], "conn": ["Connection", "close", "ssl", "ou", "core", "Conn", "cc", "server", "n", "serv", "enc", "lock", "ns", "con", "c", "act", "pub", "cb", "co", "rt", "query", "dc", "util", "nc", "ec", "client", "sync", "nt", "cm", "session", "cp", "cache", "pr", "cond", "uc", "ct", "connection", "lc", "ch", "cat", "ob", "config", "open", "ca", "h", "bb", "p", "po", "coll", "ci", "exec", "oss", "dn", "ann", "oci", "db", "pc", "mc", "ctx", "ver", "orp", "conf", "connect", "cn", "ac", "cli", "error", "cur", "pg", "org", "loc"], "stmt": ["ctm", "strlt", "istnt", "strm", "Stmn", "strmp", " stnt", "Stmm", " stmb", "STsql", "Stob", "strnt", "sthdb", " stm", "Stdb", "stdd", "estdd", " stmp", "istmt", " stdd", " stsql", "stlt", " stmm", "strmt", "stsql", "strob", "strdd", " stob", "rdsql", " stmd", "stmp", "STdd", "rdmd", "istmd", "stm", "istdt", "strmd", "stob", "Stdt", "STmt", "strsql", "Stmp", "ctmd", "estsql", "estmt", "playdt", "rddd", "Stnt", "ctmb", "estlt", "Stmd", "ctmt", "sthmn", "STlt", "playmd", " stdb", "strmb", "Stm", "Stmb", "stmm", "strmm", "rdmt", "playmt", " stmn", "stmb", "sthmt", "stmn", "sthmd", "stdb", "Stmt", "stdt", "playnt", "stmd", "stnt"], "prepTable": ["PrepTable", "inittable", " prepCol", "initCol", "supType", "prepCol", "Preptable", "prepable", "parTable", " preptable", "supTable", "PrepType", "initTable", " prepType", "Prepable", "preptable", "supable", "initType", "parCol", "prepType", "partable", "parType", " prepable", "suptable"], "objectLinkTable": ["objectTypeTab", "objectLinkSource", "ObjectLinkSource", "objectLinkType", "objectSyncChain", "objectTypeSource", "objectRelChain", "objectlinkChain", "objectSyncStore", "ObjectLinkTable", "objectSyncType", "objectLinkStore", "objectRelTable", "objectLineTab", "ObjectLineSource", "objLinkTable", "objLinkChain", "objectLinkFile", "objLinkStore", "ObjectLineFile", "objectlinkTable", "objectlinkType", "objLinkType", "objectSyncTable", "objectRelType", "ObjectLinkTab", "ObjectLineTab", "objectlinkFile", "objectLineSource", "objectRelStore", "ObjectLineTable", "objlinkTable", "objectLineFile", "objectlinkStore", "objlinkStore", "objectLinkChain", "objlinkType", "objectTypeFile", "ObjectLinkFile", "objectlinkTab", "objlinkChain", "objectTypeTable", "objectlinkSource", "objectLineTable", "objectLinkTab"], "sql": ["zip", "string", "ssl", "sf", "id", "spec", "sg", "description", "result", "join", " SQL", "s", "shell", "query", "su", "csv", "dl", "params", "select", "expression", "pr", "sb", "str", "sv", "ql", "log", "sq", "insert", "ls", "function", "db", "sl", "url", "update", "comment", "SQL", "summary", "general", "statement", "cmd", "term"]}}
{"id1": "16511008", "id2": "7761195", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"createNewProfilingMessageSymbol": ["createNewProfilingMsgSymmb", "createNewProfilingMessageSymmbol", "createNewProfilingMsgSyletter", "createNewProfilingMessageSymmb", "createNewProfilingMessageSymletter", "createNewProfilingMessageSyletter", "createNewProfilingMsgSymletter", "createNewProfilingMessageYmbol", "createNewProfilingMessageCymb", "createNewProfilingMsgSymmbol", "createNewProfilingMsgSymbol", "createNewProfilingMessageCymbol", "createNewProfilingMessageYmb", "createNewProfilingMessageCyletter", "createNewProfilingMessageSymb", "createNewProfilingMsgSymb", "createNewProfilingMessageYletter"], "configID": ["ConfigURL", " configId", "ConfigID", " configURL", "ConfigUID", "projectURL", "ConfigId", " configION", "projectId", "configId", "configION", " configUID", "projectION", "configUID", "ConfigION", "projectUID", "projectID", "configURL"], "programMessageSymbolID": ["programMessageSyncmbolID", "programMessageSyncmbolId", "programMessageSyntaxID", "programMessageSymbId", "programMessageSychid", "programMessageSyncmbid", "programMessageSyncmbolIP", "programMessageSyntaxName", "programMessageSyncmbId", "programMessageSymbolid", "programMessageSyncmbolid", "programMessageSyymID", "programMessageSyklName", "programMessageSymbolId", "programMessageSyncmbID", "programMessageSyymName", "programMessageSymbName", "programMessageSymbolName", "programMessageSyncmbIP", "programMessageSyklID", "programMessageSyncmbolName", "programMessageSyntaxId", "programMessageSymbIP", "programMessageSyymId", "programMessageSymbid", "programMessageSyncmbName", "programMessageSyklId", "programMessageSymbID", "programMessageSychId", "programMessageSyntaxid", "programMessageSychID", "programMessageSyymIP", "programMessageSymbolIP"], "profilingMessageSymbol": ["profilingMessageSynPart", "profilingFileSymmbol", "profilingMessageTyPart", "profilingMessageYletter", "profilingFileSymb", "profilingMessageSymb", "profilingMessageSymmb", "profilingFileSymbol", "profilingFileSymmb", "profilingFileSyletter", "profilingMessageCymb", "profilingMessageYmbol", "profilingMessageSymletter", "profilingMessageCyletter", "profilingMessageSynmb", "profilingMessageSymPart", "profilingApplicationSyletter", "profilingApplicationSymmb", "profilingMessageSyletter", "profilingApplicationSymbol", "profilingApplicationSymb", "profilingMessageSyPart", "profilingFileSymletter", "profilingMessageCymbol", "profilingApplicationSymletter", "profilingFileSymPart", "profilingMessageSymmbol", "profilingMessageTymbol", "profilingApplicationSymmbol", "profilingMessageSynmbol", "profilingFileSyPart", "profilingMessageTymb", "profilingMessageYmb"], "connection": ["directory", "Connection", "index", "server", "response", "lock", "document", "con", "c", "connected", "communication", "table", "result", "socket", "driver", "pool", "relation", "si", "manager", "database", "condition", "password", "client", "session", "use", "cache", "cond", "ion", "application", "collection", "section", "config", "machine", "channel", "environment", "log", "context", "conn", "image", "function", "db", "ctx", "sql", "bc", "position", "unit", "connect", "command", "state", "error", "engine", " Connection", "ongo"], "statement": ["directory", "Connection", "string", "agent", "execute", "response", "timeout", "lock", "report", "usage", "message", "document", "table", "library", "result", "ma", "se", "volume", "relation", "si", "pass", "database", "joined", "condition", "ment", "expression", "part", "session", "stat", "mt", "use", "str", "collection", "section", "parser", "out", "study", "conn", "Query", "Statement", "Session", "writer", "function", "commit", "db", "sql", "position", "unit", "comment", "parse", "summary", "connect", "command", "state", "error", "storage"], "resultSet": ["ResultGen", "ResultS", "resultSplit", "resultsSet", "resultsGen", "resultsSource", "dataSet", "resultS", "replySet", " resultS", "resultList", " resultSource", "resultType", " resultType", "resultLine", "resultSource", "replySplit", "ResultLine", "responseRow", " resultGen", "dataList", "dataLine", "responseSet", "ResultSplit", " resultLine", "dataSource", "rowS", "rowSource", "dataRow", "ResultType", "responseList", " resultSplit", "replyList", "rowSet", "rowType", "resultRow", "ResultSource", "resultGen", " resultList", "replyLine", "dataGen", "ResultList", "ResultRow", "ResultSet"], "query": ["index", "reason", "string", "root", "execute", "id", "uri", "lock", "timeout", "report", "message", "description", "table", "result", "join", "qu", "qs", " Query", "eries", "o", "database", "key", "condition", "select", "expression", "filter", "type", "rule", "q", "value", "str", "feature", "ql", "work", "go", "request", "search", "sq", "style", "Query", "name", "send", "function", "call", "sql", "update", "comment", "parse", "question", "command", "scan", "script", "error", "module", "code"], "msg": ["rag", "reason", "pkg", "id", "cmp", "lang", "rr", "op", "var", "sg", "map", "message", "cap", "ge", "ma", "html", "tag", "dr", "mr", "ms", "bg", "bag", "cm", "mt", "doc", "fg", "ug", "str", "g", "md", "ger", "cmd", "text", "gs", "sim", "exc", "agg", "log", "ag", "gen", "Message", "format", "title", "desc", "name", "m", "gr", "status", "e", "gor", "db", "og", "nm", "mn", "comm", "err", "mg", "gm", "error", "phrase", "tool", "cfg", "Msg", "loc"]}}
{"id1": "8087001", "id2": "8320469", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 1, "substitutes": {"generateStackHashKey": ["generateStackHashString", "generatestackHashkey", "generatestackhashKeys", "generateStackhashkey", "generatestackHashString", "generateStackHashKeys", "generatestackhashString", "generateStackhashKey", "generateStackHeaderKeys", "generateStackHashkey", "generatestackHashKey", "generatestackHashKeys", "generateStackhashKeys", "generateStackHeaderKey", "generateStackHeaderkey", "generatestackhashKey", "generateStackhashString", "generateStackHeaderString", "generatestackhashkey"], "e": ["event", "fe", "ace", "ex", "ee", "n", "est", "element", "ie", "c", "et", "o", "se", "el", "ception", "ele", "en", "ec", "er", "d", "r", "he", "ea", "body", "exc", "h", "x", "p", "es", "ae", "ef", "E", "m", "t", "ze", "exec", "a", "ev", "ed", "pe", "me", "err", "b", "f", "error", "oe", "Exception", "this", "enter", "esi"], "digest": ["Digester", "digher", "Diger", "decature", " Digested", " digator", " Digester", "Signature", "mdature", " digested", "digge", " diger", "decest", " digusher", "mdusher", "logester", "Signate", "mdest", "mdested", "logge", " digenge", " digge", "digester", " Digator", "mdate", " Digest", "digested", "mdester", "Digher", "Digge", "Digenge", "logher", "decester", "Digest", " digher", "digator", "mdenge", "Signest", "Digusher", "Signester", "digusher", "decate", "diger", "digate", "Digator", "digenge", "mder", " digester", "Digested", "logest", "digature"], "hash": ["string", "total", "base", "sum", "her", "bh", "ashes", "message", "kh", "hex", "Hash", "result", "ash", "key", "rh", "mac", "dot", "sha", "value", "build", "data", "text", "body", "h", "dig", "header", "image", "hed", "array", "ha", "sh", "v", "b", "ph", "history", "f", "code"], "rtn": ["RTnin", "RTnn", "rtN", "txn", "ortN", "rtnin", "rtns", "txnin", "rdb", "rtpn", "rtb", "vrns", "rdN", "ortn", "retn", "vrnn", "RTn", "ntn", "latne", "RTne", "vrN", "ntc", "latN", "rdn", "gtn", "rtnn", "latn", "ntN", "latns", "rtne", "ortnn", "vrn", "ntb", "RTns", "vrne", "gtb", "rtc", "RTc", "txc", "retb", "ntnin", "RTb", "ortne", "ntpn", "RTN", "gtN", "gtpn", "RTpn", "txN", "rdns", "retN", "retns"]}}
{"id1": "6966398", "id2": "1508930", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "label": 0, "substitutes": {"reader": ["ry", "rw", "loader", "handler", "her", "cer", "resource", "feed", "buffer", "reading", "rc", "builder", "input", "df", "server", "per", "ri", "se", "instance", "driver", "o", "reads", "dr", "keeper", "manager", "read", "iter", "ler", "rake", "er", "client", "cms", "load", "source", "pp", "oder", "book", "ner", "connection", "r", "parser", "config", "file", "rar", "p", "row", "rr", "context", "or", "io", "writer", "k", "pe", "stream", "raf", "Reader"], "ks": ["keys", "works", "orks", "DS", "sk", "ko", "fs", "checks", "acs", "ke", "inks", "ck", "gets", "ns", "kies", "se", "qs", "bs", "kb", "reads", "co", "ms", "rs", "ku", "hs", "ops", "akes", "ans", "cks", "ips", "es", "CS", "acts", "ls", "vs", "ges", "ics", "rows", "ss", "books", "powers", "ctx", "kes", "ches", "k", "ki", "acks", "ds", "cs", "ps", "opens", "icks", "KS"], "key": ["keys", "base", "ssl", "server", "ee", "ke", "user", "lock", "c", "co", "read", "char", "client", "type", "cache", "ce", "seed", "value", "file", "Key", "ca", "p", "io", "ring", "k", "pe", "ki", "secret", "pair", "sign", "trust", "state", "court", "transfer", "pg", "service", "code", "point"], "chain": ["path", "root", "base", "enc", "lock", "sequence", "slice", "table", "c", "set", "code", "crypt", "wrap", "rule", "cache", "circle", "collection", "store", "config", "none", "file", "chains", "object", "coll", "box", "Chain", "image", "cr", "family", "mc", "pair", "secret", "range", "stack", "container", "network", "block", "scale", "wheel", "list"], "os": ["ou", "oses", "fs", "Os", "op", "opens", "res", "OS", "o", "outs", "s", "is", "ms", "rs", " o", "ros", "bos", "ops", "ob", "options", "oid", "object", "p", "es", "aos", "rss", "oss", "io", "pos", "ot", " bos", "ios", "ds", "los", "ps", "ol", "osi", "iso", "cos"], "stamper": ["starmper", "stammer", "spammer", "path", "stAMmer", " nostampper", "stameper", " nostamler", "streamler", " nostample", "s", "starmler", "stAMper", "stampe", " nostameler", "streammer", "stammper", "stAMpe", "spAMpe", "spampe", "spAMmer", "spAMler", "stampper", " nostameple", " nostamepper", "spamler", "stamepper", "stammmer", "stamler", "g", "streamper", "data", "spamper", " nostamper", "stammpe", "spAMper", "function", "stample", "stameler", "starmpper", "stameple", "streampe", "_", "starmple", " nostameper", "stAMler", "stammple", "stammpper", "stammler", "this"], "appearance": ["Appears", " appearing", "formearance", "feedearance", " appismo", "appear", "signear", "installear", "installasion", "feedfacing", "appearing", "byear", "suppfacing", "byearance", "byismo", "askearance", "signfacing", "installearance", " appears", "ppaser", "suppointment", "Appearing", " appeared", "applier", "signearance", "formearing", "suppearing", "feedear", "signointment", "byearing", "atteared", "appasion", "Appearance", "appfacing", "attfacing", " appfacing", "suppearance", "attearance", "formear", "askeared", " appear", "appaser", "appointment", "appismo", "signearing", "appears", "appence", "appeared", "signears", "ppasion", "feedointment", "formaser", "formismo", "ppear", "installearing", "attence", "suppear", "askence", "askfacing", "signlier", "suppasion", " appence", "Applier", " applier", "ppearance", " appaser", "ppearing"]}}
{"id1": "13362846", "id2": "15445861", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"setContenu": ["setTenuit", "setTonenu", "setContenues", "setContineues", "setContineuer", "setTonenues", "setTenu", "setContennues", "setContineuit", "setTonenuer", "setContonenuer", "setContenuer", "setTenuer", "setContineu", "setContonenuit", "setContennu", "setContennuit", "setContonenues", "setTonenuit", "setContenuit", "setContonenu", "setTenues", "setContennuer"], "contenuFichier": ["contenuPrefichiers", "contenuFocher", "contenuPFochier", "contenuFrenchier", "contenuMichier", "contenuFaffier", "contenuTichiere", "contenuMrenchiere", "contenuMaffiere", "contenuFrenchiers", "contenuMichiers", "contenuFochiere", "contenuPFicher", "contenuMaffie", "contenuMaffieri", "contenuFchery", "contenuPrefaffie", "contenuFicheiere", "contenuPrefichier", "contenuFochie", "contenuPrefaffier", "contenuTicheery", "contenuMrenchique", "contenuFaffie", "contenuFichery", "contenuFicherer", "contenuFicoyer", "contenuFrenchery", "contenuFactoryiere", "contenuFicier", "contenuFaffiers", "contenuFicheique", "contenuFicheer", "contenuPFichique", "contenuPhichiere", "contenuFichtique", "contenuFichtiere", "contenuPrefaffiere", "contenuFichiers", "contenuFrenchoyer", "contenuFrenchie", "contenuPhichoyer", "contenuTicheiere", "contenuPrefichiere", "contenuTichery", "contenuFicher", "contenuPhactoryiere", "contenuPFochiere", "contenuPrefaffiers", "contenuFrenchique", "contenuFichtier", "contenuFaffieri", "contenuFrencherer", "contenuMaffier", "contenuFichoyer", "contenuTicheier", "contenuPhichier", "contenuPFichier", "contenuFiciere", "contenuFactoryie", "contenuFochiers", "contenuTicheerer", "contenuMichiere", "contenuFicheerer", "contenuFcherer", "contenuMichie", "contenuFichique", "contenuPhactoryoyer", "contenuFichie", "contenuMaffiers", "contenuTichier", "contenuMrenchie", "contenuFichtie", "contenuFaffiere", "contenuFaffer", "contenuFchier", "contenuMrenchier", "contenuFochier", "contenuFicie", "contenuFchiere", "contenuFaffique", "contenuMichieri", "contenuFichieri", "contenuFichiere", "contenuFrenchiere", "contenuFicheie", "contenuFicheieri", "contenuPhichie", "contenuTicherer", "contenuFicheery", "contenuFactoryoyer", "contenuMichique", "contenuPhactoryie", "contenuFactoryier", "contenuPhactoryier", "contenuPrefichie", "contenuFicheier", "contenuFichtieri", "contenuPFocher", "contenuPFochique", "contenuPFichiere", "contenuFochique"], "fichierElectronique": ["fichierAustrolique", "fichierCentornier", "fichierAdministronistic", "fichierElectron\u00e9e", "fichierElectromical", "fichierElectroneiques", "fichierElectronistic", "fichierElectronsique", "fichierElectaronique", "fichierElectonlique", "fichierElectronsie", "fichierAustroniere", "fichierElectoloniques", "fichierElectrolique", "fichierAdministronsie", "fichierElectronsiques", "fichierElectolonique", "fichierElectronsiere", "fichierElectroneie", "fichierElectpronique", "fichierElectronlique", "fichierAdministronical", "fichierElectaronier", "fichierAdministronique", "fichierElectornier", "fichierElectromique", "fichierElectrolier", "fichierElectromiques", "fichierElectronelique", "fichierElectonique", "fichierAdministronie", "fichierElectronslique", "fichierElectornique", "fichierAustronique", "fichierElectroniques", "fichierElectronica", "fichierAustroliere", "fichierAdministronlique", "fichierCentornique", "fichierAdministronslique", "fichierElectronsica", "fichierAdministronsique", "fichierAustrolier", "fichierElectronsical", "fichierElectolonica", "fichierCentronier", "fichierElectoloniere", "fichierAdministronier", "fichierAdministronsier", "fichierAdministronsical", "fichierElectromistic", "fichierAustroliques", "fichierElectronier", "fichierElectronical", "fichierElectpronistic", "fichierElectroneique", "fichierCentronique", "fichierElectrolie", "fichierCentornlique", "fichierElectorniques", "fichierAdministronsistic", "fichierElectrol\u00e9e", "fichierElectpronical", "fichierElectproniques", "fichierElectonier", "fichierCentroniques", "fichierElectornlique", "fichierElectronsistic", "fichierElectrons\u00e9e", "fichierAdministron\u00e9e", "fichierAdministroniques", "fichierElectaronie", "fichierElectaron\u00e9e", "fichierElectroneiere", "fichierElectronsier", "fichierAustronier", "fichierAdministrons\u00e9e", "fichierCentronlique", "fichierAdministronsiques", "fichierElectroniere", "fichierElectrolica", "fichierElectronie", "fichierCentorniques", "fichierAustroniques", "fichierElectroliques", "fichierElectroliere", "fichierElectonie", "fichierElectroneier"], "utilisateurCourant": ["utilisateurParticipants", "utilisationApplicants", "utilisateurParticipante", "utilisationCourante", "utilisationApplicateur", "utilisateurApplicant", "utilisateurParticipant", "utilisationCourateur", "utilisateurApplicante", "utilisateurGovernant", "utilisationApplicant", "utilisationCourant", "utilisateurCourateur", "utilisateurCourante", "utilisateurGovernateur", "utilisateurGovernante", "utilisateurCourants", "utilisationCourants", "utilisateurParticipateur", "utilisationApplicante", "utilisateurApplicants", "utilisateurApplicateur", "utilisateurGovernants"], "support": ["services", "push", "Support", "info", "know", "accept", "Library", "settings", " Support", "document", "system", "library", "concept", "util", "client", "friend", "allow", "protection", "respect", "cover", "proxy", "facebook", "media", "feature", "evidence", "config", "best", "share", "supp", "bank", "control", "plugin", "format", "knowledge", "force", "ann", "compatible", "supported", "pull", "review", "summary", "contact", "help", "utils", "pport", "service", "storage"], "ficheDocument": ["friquedocument", "FcheContent", "ficheDoc", "inficheDocument", "fchadocument", "enfoiceDocument", "fchaDocument", "enficheCompany", "fcheMatrix", "fraudDocument", "afficheDoc", "inficheNumber", "infraudDoc", "friqueDoc", "fraudCatalog", "inficheDoc", "fcheDocuments", "infraudDocument", "fraudCompany", "fcheDocument", " fcheMatrix", " ficheDocuments", "foiceDirectory", "fagueDirectory", "financeNumber", "fielCompany", "fielDirectory", "affineFeature", "foinedocument", "affichedocument", "affinedocument", "fruitNumber", "afficheDocument", "infraudNumber", "facheMatrix", "friqueDocument", "FcheDoc", "foineFeature", "ficheNumber", "afficheFeature", "enfoiceCatalog", "ficheFeature", "fetchDoc", "FicheContent", "fetchFeature", "fchaContent", " ficheMatrix", "friqueContent", "ficheCompany", "fielCatalog", "facheDocument", "fcheDirectory", "enfoiceDirectory", "fetchdocument", "fineDocument", "fagueDocuments", "facheDocuments", "fichedocument", "enficheDocument", "fagueMatrix", "affineDoc", "financedocument", "fielDocument", "fchaDoc", "infichedocument", "facheDirectory", "Fichedocument", "finedocument", "fineDoc", "foiceDocument", "FicheDoc", "ficheCatalog", " ficheDirectory", "foiceCompany", "ficheDirectory", " fcheDocument", "financeDocument", "ficheContent", "fraudDirectory", "enficheDirectory", "fruitdocument", "FcheDocument", "fraudDoc", "infrauddocument", "fruitDocument", "fineFeature", "foiceCatalog", "fcheContent", "foineDocument", "fchedocument", " fcheDirectory", "Fchedocument", "fruitDoc", "FicheDocument", "ficheMatrix", "frauddocument", " fcheDocuments", "foineDoc", "fetchDocument", "fagueDocument", "enficheCatalog", "enfoiceCompany", "fraudNumber", "fcheDoc", "ficheDocuments", "financeDoc", "affineDocument"], "nomFichier": ["nomFchy", "nomVichieri", "nomPichier", "nomVich\u00e8re", "nomFichtier", "nomFichtiller", "nomFachire", "nomFrench\u00e8re", "nomNicher", "nomWichery", "nomNichier", "nomFichiner", "nomFachiere", "nomFiqurier", "nomFrenchier", "nomFchien", "nomWichier", "nomFichtieri", "nomFochier", "nomPhichiere", "nomFichterer", "nomPchy", "nomFichery", "nomPhichieri", "nomVchieri", "nomWichire", "nomFiquier", "nomFachiller", "nomFchieri", "nomFch\u00e8re", "nomFitherer", "nomVicher", "nomNichter", "nomF\u00e9tier", "nomFachieri", "nomFichy", "nomPrefichier", "nomFichtiner", "nomFiquire", "nomFisciller", "nomF\u00e9tery", "nomPhichier", "nomPrefichieri", "nomPhachieri", "nomPrefichire", "nomPrefchieri", "nomFachier", "nomFicher", "nomPchier", "nomNichtier", "nomFichire", "nomPichy", "nomFiscier", "nomFisciner", "nomFicherer", "nomPchien", "nomFochire", "nomFichrier", "nomVch\u00e8re", "nomFiscer", "nomVcher", "nomFich\u00e8re", "nomFichien", "nomPhacherer", "nomFachiner", "nomFacher", "nomF\u00e9ty", "nomNichiller", "nomPichery", "nomPhachiere", "nomFichieri", "nomWchiere", "nomVichier", "nomPrefchrier", "nomWchire", "nomNichtiner", "nomFchery", "nomF\u00e9tien", "nomFachrier", "nomPhachier", "nomFrencher", "nomVchier", "nomFichtery", "nomFichter", "nomWichiere", "nomFcher", "nomWchery", "nomPchery", "nomFchiere", "nomPrefchier", "nomFichiller", "nomNichtiller", "nomWchier", "nomFach\u00e8re", "nomPrefchire", "nomPhicherer", "nomFiscien", "nomFithier", "nomFithiere", "nomNichiner", "nomPichien", "nomFochery", "nomFiquieri", "nomFichtiere", "nomFithieri", "nomFichiere", "nomFiscy", "nomPrefichrier", "nomFchier", "nomFchire", "nomFchrier", "nomFacherer", "nomFochiere", "nomFichtire", "nomFiscery", "nomFrenchieri"], "extension": ["encension", "extion", "Extception", "exion", "encception", "anchensions", "encression", "exression", "EXTime", "anchension", "Extression", "encion", "exception", "extception", "EXTensions", "exension", "EXTension", "Extension", "extime", "Extensions", "extensions", "Extime", "extression", "Extion", "anchime"], "fichierElectroniqueExistant": ["fichierElectroniquesXclusive", "fichierElectroniqueXivist", "fichierElectroniqueExplists", "fichierElectroniqueXistance", "fichierElectroniqueexistant", "fichierElectroniquesXistent", "fichierElectroniqueExistance", "fichierElectroniqueexists", "fichierElectroniqueexclusive", "fichierElectroniquesExistant", "fichierElectroniquesXivist", "fichierElectroniqueSistent", "fichierElectroniqueSistant", "fichierElectroniqueExists", "fichierElectroniqueXistant", "fichierElectroniquesExilingual", "fichierElectroniquesExistent", "fichierElectroniqueexistance", "fichierElectroniquesXistant", "fichierElectroniqueexist", "fichierElectroniqueExplist", "fichierElectroniqueSilingual", "fichierElectroniqueExistent", "fichierElectroniqueXists", "fichierElectroniqueXistent", "fichierElectroniquesXists", "fichierElectroniquesExivist", "fichierElectroniqueXilingual", "fichierElectroniquesExclusive", "fichierElectroniquesXilingual", "fichierElectroniqueSistance", "fichierElectroniquesExist", "fichierElectroniquesExists", "fichierElectroniquesXistance", "fichierElectroniqueexivist", "fichierElectroniqueexilingual", "fichierElectroniquesExistance", "fichierElectroniqueExist", "fichierElectroniqueExplistance", "fichierElectroniqueExilingual", "fichierElectroniqueExplivist", "fichierElectroniqueXist", "fichierElectroniqueexistent", "fichierElectroniqueExclusive", "fichierElectroniqueXclusive", "fichierElectroniqueExplistant", "fichierElectroniqueExplclusive", "fichierElectroniqueExivist", "fichierElectroniquesXist"], "idIgid": ["idIogids", "idUgid", "idIogbit", "idIgudid", "idIgmids", "idIgmname", "idIgdid", "idIgubit", "idIgenname", "idUguids", "idIguname", "idIogdid", "idIgenid", "idIgnids", "idIGid", "idIguID", "idIgnid", "idEGid", "idIguod", "idUguname", "idIggid", "idEgid", "idIgenids", "idIgids", "idIggod", "idEGids", "idIggID", "idUgname", "idUgID", "idIgID", "idIgbit", "idEGbit", "idIgname", "idIgnID", "idIGdid", "idEgbit", "idIGbit", "idIgenID", "idUguid", "idIgod", "idUguID", "idIguid", "idIogid", "idIgmID", "idIggids", "idEGdid", "idUgids", "idIGids", "idIgnod", "idEgids", "idIgmid", "idEgdid", "idIguids"], "inputStream": ["eventSteam", "InputThread", "eventstream", "inputStreamer", "outputLength", "InputStreamer", "outputSteam", "InputLength", "inputSteam", " inputThread", "eventStreamer", "inputThread", " inputstream", "inputLength", "outputstream", " inputSteam", "outputStreamer", "outputThread", " inputLength", "Inputstream", "inputstream", "InputSteam", "InputStream", "eventStream"], "outputStream": ["inputStreamer", "entityStream", "officeStream", "outputSteam", "inputSteam", "OutputContext", "OutputStreamer", "Outputstream", "entitySteam", " outputstream", "officeSteam", "OutputSteam", "outputstream", "outputStreamer", "OutputStream", " outputContext", "officestream", "outputContext", "inputContext", "officeStreamer", "entitystream", "entityStreamer", " outputSteam", "inputstream"], "typeMime": ["TypeMide", "TypeSmimes", "typeMangle", "TypeSmangle", "typeSmangle", "typeMatimes", "typeSmimes", "TypeMime", "typeMatime", "typeMimes", "TypeSmide", "TypeMangle", "typeMide", "typeMatangle", "typeSmide", "typeMetime", "typeMetimes", "TypeMimes", "typeMetide", "TypeSmime", "typeMetangle", "typeMatide", "typeSmime"], "tailleFichier": [" tailleFichiers", " tailleFigner", " taillefichie", " tailleFicheiers", " tailleFocher", " tailleFicheer", " tailleFignier", " tailleFicheie", " tailleFignie", " tailleFochie", " taillefochier", " taillefochiers", " taillefichiers", " tailleFochier", " tailleFigniers", " tailleFichie", " tailleficher", " taillefochie", " tailleFochiers", " tailleFicheier", " tailleFicher", " taillefichier", " taillefocher"]}}
{"id1": "3187685", "id2": "11933797", "code1": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copyJar": ["copyZip", "zipZip", "CopyJam", "CopySocket", "zipJam", "copySocket", "CopyZip", " copyingJam", "zipSocket", " copyingSocket", "CopyJar", " copyingJar", "copyJam", " copyingZip", "zipJar"], "src": ["path", "sel", "core", "ssl", "input", "sc", "uri", "resource", "rc", "filename", "sub", "dest", "l", "s", "host", "inst", "rs", "rb", "source", "sit", "sb", "uc", "buf", "dist", "upload", "config", "file", "archive", "img", "sq", "storage", "ls", "image", "sl", "files", "url", "stream", "b", "obj", "st", "download", "loc"], "dst": [" ddr", " dsts", "dset", "odst", "edput", "ddr", "ldput", "fsts", "odsts", "dput", "edsts", " dset", "dsts", " dput", "eddr", "ldst", "ldsts", "lddr", "odset", "edst", "fput", "odput", "fst", "fset"], "srcChannel": ["srcPage", "srcConnection", "rcchannel", "sourceContext", "sslChan", "srcchannel", "sourcechannel", "sourceChannel", "sslContext", "sourcePage", "destChan", " srcConnection", "rcSocket", " srcContext", "instConnection", "sslSocket", " srcSocket", "instChan", "sourceChan", " srcClient", "destClient", "sourceConnection", " srcchannel", "srcSocket", "instChannel", "srcClient", "srcContext", "rcClient", "rcChan", " srcPage", " srcChan", "rcChannel", "sslChannel", "destConnection", "srcChan", "destChannel", "instPage", "rcContext", "rcConnection"], "dstChannel": ["dostChannel", "DdestChan", "DstChan", "Destchannel", "dostchannel", "drdStream", "DdestChannel", "drestChan", "drdChannel", "dspConnection", "DestConnection", "drestStream", "dstStream", " drdchannel", "DstConnection", "dstsStream", "destChan", " dstchannel", "dstsConnection", "ddestChan", "DdestConnection", "drestChannel", "DestChannel", "dstConnection", "dspchannel", " drdStream", "ddestConnection", "drestchannel", " drdChannel", "dspChan", "dstschannel", "destchannel", "dstsChan", "dostChan", " drdChan", "dstsChannel", " dstChan", "drdChan", "Dstchannel", "ddestChannel", "dspChannel", "destConnection", "destChannel", "ddestchannel", "dstChan", "dstchannel", "drdchannel", " dstStream", "Ddestchannel", "DestChan", "DstChannel"]}}
{"id1": "12579075", "id2": "350482", "code1": "    public static XMLConfigurator loadFromSystemProperty(String propertyName) throws IOException {\n        String urlStr = System.getProperty(propertyName);\n        if (urlStr == null || urlStr.length() == 0) {\n            return null;\n        }\n        InputStream in = null;\n        DOMRetriever xmlDoc = null;\n        try {\n            URL url = new URL(urlStr);\n            xmlDoc = new DOMRetriever(in = url.openStream());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (in != null) in.close();\n        }\n        return newInstance(xmlDoc);\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"loadFromSystemProperty": ["loadFromsystemProperty", "loadFromLocalproperty", "loadFromSysperties", "loadFormsystemproperty", "loadFormSystemString", "loadFromSystemString", "loadFromLocalperties", "loadFormSystemProperty", "loadFromsystemString", "loadFromLocalProperty", "loadFromSystemperties", "loadFromLocalString", "loadFromsystemperties", "loadFormsystemperties", "loadFromSystemproperty", "loadFormsystemString", "loadFormsystemProperty", "loadFromSysString", "loadFromSysProperty", "loadFromSysproperty", "loadFromsystemproperty", "loadFormSystemproperty", "loadFormSystemperties"], "propertyName": ["propertyValue", "fileNames", " propertyValue", "propPart", "propPath", "PropertyStr", "propertyPart", "propNames", " propertyPath", "filePart", "propertyPath", "propertyStr", "propStr", "PropertyPath", "propertyNames", "fileName", " propertyStr", " propertyPart", "PropertyValue", "PropertyName", "propName", "propString", " propertyString", " propertyNames", "propertyString", "propValue", "fileString"], "urlStr": ["URLstr", "httpText", "UrlSt", "urlWr", "URLName", " urlString", "UrlStr", "URLStr", "httpName", "URLSt", "UrlWr", " urlstr", "httpstr", " urlName", "uriStr", "urlSt", "urlName", "uristr", " urlSt", "urlString", "Urlstr", "URLString", "URLWr", "UrlName", "resourceSt", " urlWr", "uriName", "urlstr", "urlText", "httpStr", "uriWr", "resourceString", " urlText", "UrlString", "resourceStr", "UrlText"], "in": ["IN", "ssl", "i", "input", "id", "n", "resource", "serv", "cf", "ini", "gin", "ic", "con", "c", "inner", "as", "socket", "l", "ins", "bin", "is", "client", "part", "session", "reader", "doc", "source", "login", "min", "r", "inc", "data", "file", "out", "src", "p", "conn", "init", "again", "m", "image", "isin", "In", "nin", "a", "stream", "err", "ac", "cin", "inn", "f", "fac", "din"], "xmlDoc": ["xmlUrl", "externalStr", "mlDocument", "externalDocument", "jsonDocument", "domUrl", " xmlDom", " xmlStr", "mlUrl", "xmlStr", "mlStr", "webDoc", "domStr", "jsonDom", "xmlDocument", "xmlDom", "mlDoc", " xmlDocument", "officeDocument", " xmlConfig", "domDocument", "xmlConfig", "webDocument", "webStr", "externalDoc", "webUrl", "mlConfig", "domDoc", "officeDoc", "officeDom", "externalConfig", "jsonDoc", "officeStr", "jsonStr"], "url": ["string", "ssl", "base", "buffer", "input", "server", "uri", "feed", "id", "resource", "user", "http", "socket", "instance", "l", "URL", "el", "fr", "inst", "client", "reader", "source", "browser", "connection", "str", "open", "config", "data", "file", "src", "web", "bel", "ll", "ls", "image", "io", "sl", "Url", "www", "stream", "b", "f", "inf", "gl", "download"]}}
{"id1": "19849797", "id2": "15797402", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "clonefile", "transferSource", "copySource", "cloneFiles", "copyfile", "transferfile", "cloneFile", " copyFiles", "copyFiles", "transferFiles", "cloneSource", " copySource", "transferFile"], "sourceFile": ["SourceDir", "destDirectory", "sourceDir", "SourceDirectory", " sourceDir", "destfile", "srcFile", "ourceFile", "SourceFolder", "sourceUrl", "ourcefile", "SourceFile", "SourceUrl", "ourceUrl", "sourcefile", "srcDir", "ourceDirectory", "srcFolder", "sourceDirectory", " sourcefile", "Sourcefile", "destUrl", "srcfile", " sourceFolder", "sourceFolder"], "destFile": [" destPoint", "destDirectory", "sourceDir", " destDirectory", "foreignPath", "DestPath", "destfile", "srcFiles", "srcFile", "destPoint", "targetFile", "resultfile", "DestFile", "targetFiles", " destFiles", "DestPoint", " destDir", "targetfile", "resultLine", "resultDir", "destFiles", "sourceFiles", "srcLine", "targetDir", "DestFiles", "targetPath", "foreignfile", " destfile", "foreignFiles", "destDir", "DestDir", "destPath", "srcDir", "Destfile", "DestDirectory", "foreignFile", "targetLine", "destLine", "sourcePoint", "srcfile", "resultFile", "srcDirectory"], "source": ["index", "root", "from", "remote", "core", "sin", "input", "id", "resource", "uri", "output", "server", "Source", "ie", "site", "slice", "slave", "inner", "current", "table", "result", "dest", "si", "manager", "SOURCE", "iter", "client", "session", "ce", "use", "reader", "proxy", "cache", "connection", "target", "scope", "component", "seed", "parent", "config", "channel", "src", "file", "route", "object", "size", "get", "context", "null", "start", "image", "status", "secure", "url", "scene", "stream", "ource", "unit", "reference", "wrapper", "this", "service", "api", "view", "storage"], "destination": ["Destruction", "distination", " destion", "Destion", " destribution", "Destinate", "participinate", "destation", "constribution", "construction", "identination", "dominated", " destinated", "generinator", " destruction", "constinator", "destinated", "distinated", "distruction", "destion", " destinator", "Destribution", "Destination", "Destinated", "distinator", "Destinator", "identinator", " destation", "distion", "generinated", "generination", "domination", "identinate", "destruction", "destribution", "destinator", "destinate", "generruction", "participination", "identinated", "domation", "Destation", "participinated", "constination", "dominator", "participinator"]}}
{"id1": "18891988", "id2": "6457199", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "label": 1, "substitutes": {"getFile": ["downloadString", "getfile", "Getfile", "loadfile", "loadString", "loadFilename", "downloadFilename", "loadFile", "getFilename", "GetString", "GetFile", "downloadfile", "GetFilename", "downloadFile", "getString"], "serviceName": [" servicePath", "serviceUrl", "Servicename", "projectPath", "ServiceName", "servicename", "packageUrl", " servicename", "ServicePath", "projectType", "packageName", "ServiceUrl", "projectUrl", "projectName", "ServiceType", " serviceType", " serviceUrl", "packagename", "servicePath", "packagePath", "serviceType"], "wsdlLocation": ["wllAddress", "wsdlFolder", "wssdAddress", "wdlFile", "wslFolder", "wsDLUrl", "wslFile", "wllLocation", "wsslFolder", "wsslLocation", "wsdlDirectory", "wsDLFile", "wllFolder", "wdlFolder", "wsllAddress", "wslpLocation", "awsdlUrl", "wsslFile", "wslDirectory", "wddlFolder", "wsslAddress", "wslLocation", "wdlLocation", "wsDLDirectory", "wssdFile", "wsllUrl", "wslpFile", "wdlDirectory", "wslpFolder", "wsllFile", "wllFile", "awslLocation", "wddlLocation", "wssdFolder", "awslDirectory", "awsdlFile", "awslUrl", "wslUrl", "awsdlLocation", "awsdlDirectory", "wsdlUrl", "wsDLLocation", "wsdlAddress", "wsllLocation", "awslFile", "wsdlFile", "wddlDirectory", "wslpDirectory", "wsllDirectory", "wddlFile", "wdlAddress", "wssdLocation", "wsllFolder"], "endpoint": ["endaddress", "endsocol", "enpointer", "Endocol", "startPoint", " endword", "Endpoints", "enaddress", " endPoint", " endpo", "ENDpoint", " endpointer", "enpoints", "EndPoint", " endocol", "ENDPoint", "endpoints", "startpointer", "Endpo", "Endword", "enination", "enPoint", "endword", "ENDination", "endpo", " endaddress", "endpointer", "startpoint", "endocol", "Endpoint", "endspoint", "endination", "endsword", "endspo", "Endination", "endPoint", "startaddress", "ENDpoints", "enpoint"], "fileLocation": ["fileDirectory", "FileDirectory", "fileURI", "FILELocation", "FILEUrl", "FileUrl", "fileUrl", "FILEURI", " fileUrl", "FileURI", " fileDirectory", "FILEDirectory", " fileURI", "FileLocation"], "tempDir": ["TempDirectory", " tempDirectory", " tempVer", " tempPath", "tmpVer", "tmpdir", "tempPath", "TempDir", "tempDirectory", "Tempdir", "TempPath", " tempdir", " temporaryDirectory", " temporaryDir", " temporaryPath", "tmpDir", "tempVer", " temporaryVer", "tempdir", "tmpDirectory", "tmpPath"], "url": ["string", "path", "ssl", "address", "base", "server", "uri", "http", "socket", "l", "host", "URL", "el", "fl", "client", "source", "connection", "open", "config", "file", "channel", "web", "ll", "log", "conn", "ls", "coll", "image", "io", "sl", "pull", "Url", "www", "stream", "ur", "ul", "contact", "f", "service", "download"], "WSDLFile": ["WDDLFolder", "WINDLFile", "WSDLBase", "WSDLLfile", "WDDLBase", "WSDlPath", "WDDLfile", "WINDELPath", "WDDlBase", "WSDLLBase", "WSDLLSourceFile", "WSDDLSourceFile", "WSDDLFile", "WSDLfile", "WSDlFile", "WSDDLPath", "WSDLFolder", "WSDELFiles", "WSDDLfile", "WSDLLFolder", "WSDDLBase", "WSDLFiles", "WSDDLFolder", "WINDELFile", "WSDLSourceFile", "WDDlfile", "WSDLPath", "WSDlFolder", "WINDLFiles", "WINDLPath", "WSDlBase", "WSDlfile", "WSDLLFiles", "WDDLFile", "WSDELFolder", "WSDLLPath", "WSDDLFiles", "WINDELFiles", "WSDELPath", "WINDELFolder", "WDDLPath", "WDDlFolder", "WDDlFile", "WSDLLFile", "WSDlSourceFile", "WDDlPath", "WINDLFolder", "WDDlSourceFile", "WSDELFile", "WDDLSourceFile"], "tmpWSDLFile": ["tmpWSDlFiles", "tmpWSDLLFiles", "tmpWSDELFile", "tmpWSDlLocation", "tmpWSDlFolder", "tmpWSDLFolder", "tmpWDDLFile", "tmpWSDlUrl", "tmpWDDELLocation", "tmpWSDELLocation", "tmpWDDLFiles", "tmpWDDLUrl", "tmpWDDlFiles", "tmpWDDELUrl", "tmpWSDDLLocation", "tmpWDDlFolder", "tmpWSDLLUrl", "tmpWDDELFile", "tmpWSDDLFile", "tmpWDDELFiles", "tmpWSDLLFolder", "tmpWDDLLocation", "tmpWSDLFiles", "tmpWSDLUrl", "tmpWSDELUrl", "tmpWSDELFiles", "tmpWSDlFile", "tmpWDDlFile", "tmpWSDLLFile", "tmpWDDLFolder", "tmpWDDlUrl", "tmpWSDDLFiles", "tmpWSDELFolder", "tmpWSDLLocation", "tmpWSDDLUrl"], "inputFile": ["inputPlace", " inputDir", " inputBuffer", "tempPlace", "InputDir", "outputfile", "inFile", "InputBuffer", "inputBase", " inputPlace", "tempBase", " inputUrl", "inputfile", "tempUrl", "InputUrl", "inputFactory", " inputfile", "inputUrl", "infile", " inputFactory", "InputBase", "inputBuffer", "InputFile", "InputFactory", " inputStream", "inputDir", "requestFile", "requestfile", "inDir", " inputPage", " inputBase", "inputStream", "inputFiles", "requestFiles", "outputFiles", "requestStream", "InputPlace", "tempPage", "tempfile", "tempFile", "outputDir", "tempFactory", "InputFiles", "tempBuffer", "inputPage", "outputFile", " inputFiles", "inPage", "InputStream", "InputPage", "Inputfile"], "tmpFile": ["TempDirectory", " tmpFiles", "tempDocument", "uploadStream", "uploadDocument", "TempFile", "uploadFiles", "tempStream", "tempDirectory", "TempFiles", "inputDocument", "TempPage", "tmpStream", "inputStream", "inputFiles", "tmpFiles", "tmpPage", "tempPage", "tempFile", "tempFiles", " tmpDirectory", "tmpDirectory", "uploadFile", " tmpPage"], "in": ["IN", "impl", "pin", "ssl", "input", "id", "lock", "gin", "on", "c", "inner", "socket", "l", "ins", "bin", "is", "client", "reader", "source", "up", "connection", "login", "r", "inc", "data", "file", "p", "conn", "init", "again", "m", "image", "In", "lin", "inn", "f", "win", "din"], "out": ["IN", "input", "outer", "output", "copy", "server", "timeout", "on", "net", "OUT", "inner", "socket", "c", "outs", "o", "line", "co", "bin", "client", "sync", "part", "source", "cache", "up", "connection", "ch", "group", "inc", "conv", "parent", "file", "channel", "log", "conn", "again", "name", "Out", "image", "io", "writer", "to", "In", "can", "conf", "err", "error"], "con": ["IN", "close", "ssl", "Conn", "CON", "rc", "gin", "ran", "plain", "c", "inner", "socket", "fc", "ctrl", "Con", "ins", "co", "en", "nc", "sync", "client", "cm", "thin", "uc", "connection", "ch", "inc", "conv", "un", "channel", "open", "conn", "rec", "kin", "bc", "com", "can", "conf", "connect", "cn", "win"], "fileLength": ["contentLength", "channelLength", "channelLen", " fileSize", "FileSize", "fileSize", "Filelength", " fileLen", "fileLen", "contentSize", "filelength", "contentlength", "FileLength", " fileWidth", " filelength", "FileWidth", "channelSize", "FileLen", "fileWidth", "channelWidth", "contentLen"], "channelIn": ["characterIN", " channelIN", "ChannelIN", "connectionin", "connectionOut", "Channelin", "channelIN", "characterin", "channelConn", "connectionIn", "resourceIn", "channelin", "ChannelOut", " channelConn", "resourceOut", "ChannelIn", "resourcein", "ChannelConn", "resourceIN", "characterOut", "characterIn", "connectionConn", " channelin"], "channelOut": ["chanOutside", "canOutside", "ChannelOutside", "chanOut", "connectionOut", "Channelout", "canIn", " channelOutput", "channelOutside", "connectionIn", "channelOutput", "chanOUT", "channelOUT", "ChannelOut", "chanout", "chanIn", "connectionout", "ChannelIn", "connectionOutput", "channelout", "connectionOutside", "ChannelOUT", "ChannelOutput", "canOut", " channelout", "canOUT"], "tmpDocument": [" tmpContent", " tmpdocument", "mpFile", "tempDoc", "tmpNode", "tmdocument", "mpNode", "tmpDoc", "tempNode", "mpDocument", "tempDocument", "tmNode", "tmpdocument", "newContent", "tmDocument", "newDocument", "newdocument", "mpDoc", "tempdocument", "tempContent", "tmFile", " tmpDoc", " tmpNode", "tempFile", "tmpContent", "newFile"], "nl1": ["ln2", "nlone", "ln1", "nl2", "NL1", "NL11", "nn11", "arlone", "dl2", "kl5", "kl1", "NL2", "dl1", "nlFirst", "ln11", "klFirst", "klone", "arl5", "NL0", "nn1", "nn6", "jlone", "ln6", "arl1", "nl6", "jl1", "NL6", "nn0", "jl5", "nn2", "nl5", "nl11", "dl0", "nl0", "jlFirst", "arlFirst"], "i": ["index", "info", "mu", "id", "uri", "pi", "n", "ini", "ie", "yi", "slice", "j", "fi", "ri", "o", "z", "l", "si", "ui", "ii", "qi", "part", "ti", "ji", "d", "phi", "chi", "li", "ip", "mi", "p", "bi", "u", "uli", "oi", "ai", "ci", "I", "e", "m", "io", "eni", "it", "xi", "di", "gi", "hi", "v", "b", "ni", "y", "abi", "iu", "multi", "f", "ix"], "node1": ["nOne", " nodeone", "shape1", "package91", "Node2", "layer2", "n2", "node91", "Node91", "Node0", "shapeone", " node2", " node91", "Node1", "nodeOne", "packageOne", " nodeOne", "layer1", " node0", "packageone", "nodeone", "n0", "layer91", "node0", "NodeOne", "package1", "shapeOne", "n1", "shape91", "layerOne", "node2"], "tmpOut": ["ptyIn", "cacheOut", "tmpOUT", "tmpout", "tempOUT", "vmOUT", "tempWriter", " tmpIn", "vmout", "tempout", "cacheIn", " tmpOUT", " tmpWriter", "vmOut", "ptyOut", "tmpIn", "cacheOUT", "ptyout", "tempOut", "cacheFile", "tempIn", "tmpOutput", " tmpout", "ptyOutput", "vmIn", "tempFile", "tempOutput", " tmpOutput", "txtWriter", "txtOut", "txtOutput", "txtout", "tmpWriter"], "retVal": ["RETval", "valObj", " retObj", " retval", "RETVal", "valval", "valVal", "retRet", "valRet", "RETRet", "retObj", " retRet", "retval", "RETObj"]}}
{"id1": "19335986", "id2": "8166767", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public Object invoke(MethodInvocation invocation, int retryTimes) throws Throwable {\n        retryTimes--;\n        try {\n            String url = getServiceUrl() + \"/\" + invocation.getMethod().getName();\n            HttpPost postMethod = new HttpPost(url);\n            if (invocation.getMethod().getParameterTypes().length > 0) postMethod.setEntity(new StringEntity(JsonUtils.toJson(invocation.getArguments())));\n            HttpResponse rsp = HttpClientUtils.getDefaultInstance().execute(postMethod);\n            StatusLine sl = rsp.getStatusLine();\n            if (sl.getStatusCode() >= 300) {\n                throw new RuntimeException(\"Did not receive successful HTTP response: status code = \" + sl.getStatusCode() + \", status message = [\" + sl.getReasonPhrase() + \"]\");\n            }\n            HttpEntity entity = rsp.getEntity();\n            StringBuilder sb = new StringBuilder();\n            InputStream is = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n            String line;\n            while ((line = reader.readLine()) != null) sb.append(line).append(\"\\n\");\n            reader.close();\n            is.close();\n            String responseBody = null;\n            if (sb.length() > 0) {\n                sb.deleteCharAt(sb.length() - 1);\n                responseBody = sb.toString();\n            }\n            Type t = invocation.getMethod().getGenericReturnType();\n            if (t.equals(Void.class) || responseBody == null) return null;\n            return JsonUtils.fromJson(responseBody, t);\n        } catch (ConnectTimeoutException e) {\n            if (retryTimes < 0) throw e;\n            if (urlFromDiscovery) {\n                String serviceUrl = discoverServiceUrl(getServiceInterface().getName());\n                if (!serviceUrl.equals(getServiceUrl())) {\n                    setServiceUrl(serviceUrl);\n                    log.info(\"relocate service url:\" + serviceUrl);\n                }\n            }\n            return invoke(invocation, retryTimes);\n        }\n    }\n", "label": 0, "substitutes": {"uncaughtException": ["CaughtException", "uncachedexc", "uncatchedexc", "uncaughtEvent", "CatchedEvent", "Catchedexc", "Caughtexc", "uncaughtexc", "uncachedEvent", "uncachedException", "uncatchedException", "unchandledException", "unchandledexc", "CatchedException", "uncatchedEvent", "CaughtEvent", "unchandledEvent"], "t": ["n", "c", "l", "s", "te", " T", "ty", "type", "d", "r", "g", "w", "out", "p", "ts", "let", "title", "m", "tree", "ing", "it", " td", "T", "tr", "ed", "f", "tx"], "e": ["event", "fe", "i", "ace", "ee", "be", "ie", "eb", "c", "ge", "j", "se", "o", "s", "el", "ception", "ele", "en", "ec", "er", "d", "ce", "diff", "r", "data", "de", "exc", "ep", "p", "es", "ae", "environment", "ne", "eu", "example", "m", "E", "ev", "ed", "pe", "me", "err", "f", "error", "oe", "Exception", "element", "code", "enter", "esi"], "display": ["play", "fe", "console", "panel", "report", "profile", "description", "window", "host", "layout", "content", "monitor", "scroll", "d", "hide", "show", "default", "config", "de", "body", "page", "object", "p", "style", "dis", "status", "image", "screen", "Display", "position", "app", "me", "summary", "design", "container", "process", "this", "view", "platform"], "shell": ["hell", "buffer", "console", "server", "copy", "lock", "mail", "system", "echo", "l", "child", "host", "el", "clone", "loop", "tools", "sb", "live", " Shell", "machine", "math", "body", "cl", "launch", "h", "environment", "log", "bash", "m", "exec", "image", "status", "Shell", "ml", "kernel", "sym", "app", "sh", "sound", "b", "poll", "container", "process", "xml", "help", "gui", "cli", "tool"], "message": ["event", " exception", "address", "buffer", "translation", "mess", "console", "server", "output", "copy", "response", "report", "mail", "document", "description", "result", "management", "queue", "content", "monitor", "email", "member", "value", "media", "model", "application", "data", "body", "page", "object", "request", "flash", "Message", "log", "msg", "header", "m", "meter", "status", "image", " messenger", "update", "summary", "xml", "essage", "error", "view"], "e1": [" e3", "e3", "exc2", "e8", " e2", "E1", "e2", "E3", "E2", " e8", "E8", "exc3", "exc8", "exc1"]}}
{"id1": "19322941", "id2": "1985677", "code1": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "code2": "    public SRWGuiClient(String initialURL) {\n        super(\"Simple Swing Browser\");\n        this.initialURL = initialURL;\n        addWindowListener(new ExitListener());\n        WindowUtilities.setNativeLookAndFeel();\n        JPanel topPanel = new JPanel();\n        topPanel.setBackground(Color.lightGray);\n        homeButton = new JIconButton(\"home.gif\");\n        homeButton.addActionListener(this);\n        JLabel urlLabel = new JLabel(\"URL:\");\n        urlField = new JTextField(30);\n        urlField.setText(initialURL);\n        urlField.addActionListener(this);\n        topPanel.add(homeButton);\n        topPanel.add(urlLabel);\n        topPanel.add(urlField);\n        getContentPane().add(topPanel, BorderLayout.NORTH);\n        try {\n            URL url = new URL(initialURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            boolean xml = true;\n            String inputLine;\n            StringBuffer content = new StringBuffer(), stylesheet = null;\n            Transformer transformer = null;\n            inputLine = in.readLine();\n            if (inputLine == null) {\n                System.out.println(\"No input read from URL: \" + initialURL);\n                return;\n            }\n            if (!inputLine.startsWith(\"<?xml \")) {\n                xml = false;\n                content.append(inputLine);\n            }\n            if (xml) {\n                inputLine = in.readLine();\n                if (inputLine.startsWith(\"<?xml-stylesheet \")) {\n                    int offset = inputLine.indexOf(\"href=\");\n                    String href = (inputLine.substring(inputLine.indexOf(\"href=\") + 6));\n                    href = href.substring(0, href.indexOf('\"'));\n                    System.out.println(\"href=\" + href);\n                    url = new URL(url, href);\n                    String stylesheetURL = url.toString();\n                    System.out.println(\"stylesheet URL=\" + url.toString());\n                    transformer = (Transformer) transformers.get(stylesheetURL);\n                    if (transformer == null) {\n                        BufferedReader sheetIn = new BufferedReader(new InputStreamReader(url.openStream()));\n                        sheetIn.readLine();\n                        stylesheet = new StringBuffer();\n                        while ((inputLine = sheetIn.readLine()) != null) stylesheet.append(inputLine).append('\\n');\n                        System.out.println(stylesheet.toString());\n                        TransformerFactory tFactory = TransformerFactory.newInstance();\n                        StreamSource xslSource = new StreamSource(new StringReader(stylesheet.toString()));\n                        transformer = tFactory.newTransformer(xslSource);\n                        transformers.put(stylesheetURL, transformer);\n                    }\n                }\n            }\n            while ((inputLine = in.readLine()) != null) content.append(inputLine).append('\\n');\n            htmlPane = new JEditorPane();\n            if (transformer != null) {\n                StringReader stringRecordReader = new StringReader(content.toString());\n                StringWriter xmlRecordWriter = new StringWriter();\n                StreamSource streamXMLRecord = new StreamSource(stringRecordReader);\n                transformer.transform(streamXMLRecord, new StreamResult(xmlRecordWriter));\n                String html = xmlRecordWriter.toString();\n                int i = html.indexOf('>');\n                html = \"<html>\" + html.substring(html.indexOf('>') + 1);\n                System.out.println(html);\n                htmlPane.setContentType(\"text/html\");\n                htmlPane.setText(\"<html><head><META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"><title>GSAFD Thesaurus</title></head><body><center><h2>GSAFD Thesaurus</h2></center><p>A thesaurus of genre terms to support the \\\"Guidelines on Subject Access to Individual Works of Fiction , Drama\\\" (GSAFD)</p><table cellspacing=\\\"5\\\" width=\\\"100%\\\"><tr><td><h3>Search</h3><p></p></td><td valign=\\\"top\\\"><h3>Browse</h3></td></tr></table></body></html>\");\n            } else htmlPane.setText(content.toString());\n            htmlPane.setEditable(false);\n            htmlPane.addHyperlinkListener(this);\n            JScrollPane scrollPane = new JScrollPane(htmlPane);\n            getContentPane().add(scrollPane, BorderLayout.CENTER);\n        } catch (IOException ioe) {\n            warnUser(\"Can't build HTML pane for \" + initialURL + \": \" + ioe);\n        } catch (TransformerException e) {\n        }\n        Dimension screenSize = getToolkit().getScreenSize();\n        int width = screenSize.width * 8 / 10;\n        int height = screenSize.height * 8 / 10;\n        setBounds(width / 8, height / 8, width, height);\n        setVisible(true);\n    }\n", "label": 0, "substitutes": {"test_lookupResourceType_FullSearch_TwoWordsInMiddle": ["test_lookupResourceType_FullSearch_FourWords", "test_lookupResourceType_FullSearch_Threewords", "test_lookupResourceType_FullSearchWithtwowords", "test_lookupResourceType_FullSearch_TwoWord", "test_lookupResourceType_FullSearchWithtwoWord", "test_lookupResourceType_FullSearch_ThreeWords", "test_lookupResourceType_FullSearch_ThreeW", "test_lookupResourceType_FullSearchWithTwoWord", "test_lookupResourceType_FullSearch_twoWords", "test_lookupResourceType_FullSearchWithtwoWords", "test_lookupResourceType_FullSearch_ThreeWord", "test_lookupResourceType_FullSearchWithTwoW", "test_lookupResourceType_FullSearch_TwoW", "test_lookupResourceType_FullSearchWithTwoWords", "test_lookupResourceType_FullSearch_TwoWords", "test_lookupResourceType_FullSearch_FourW", "test_lookupResourceType_FullSearch_Fourwords", "test_lookupResourceType_FullSearch_twoWord", "test_lookupResourceType_FullSearch_twowords", "test_lookupResourceType_FullSearch_twoW", "test_lookupResourceType_FullSearch_FourWord", "test_lookupResourceType_FullSearchWithTwowords", "test_lookupResourceType_FullSearch_Twowords", "test_lookupResourceType_FullSearchWithtwoW"], "url": ["string", "path", "base", "address", "ssl", "server", "uri", "resource", "feed", "user", "entry", "http", "document", "c", "system", "location", "l", "URL", "client", "config", "file", "channel", "https", "page", "object", "web", "log", "conn", "image", "link", "sl", "Url", "position", "bug", "b", "contact", "f", "method", "org"], "connection": ["Connection", "event", "translation", "handler", "server", "resource", "response", "uri", "entry", "http", "document", "character", "c", "connected", "j", "communication", "result", "number", "version", "l", "con", "location", "relation", "database", "established", "condition", "password", "client", "expression", "session", "use", "cache", "proxy", "ion", "which", "operation", "application", "section", "config", "channel", "body", "object", "context", "conn", "image", "io", "function", "link", "db", "position", "bc", "bug", "b", "connect", "wrapper", "contact", "method", "service", "loc"]}}
{"id1": "22057083", "id2": "16798376", "code1": "    private void Connect() throws NpsException {\n        try {\n            client = new FTPClient();\n            client.connect(host.hostname, host.remoteport);\n            int reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                client.disconnect();\n                client = null;\n                com.microfly.util.DefaultLog.error_noexception(\"FTP Server:\" + host.hostname + \"refused connection.\");\n                return;\n            }\n            client.login(host.uname, host.upasswd);\n            client.enterLocalPassiveMode();\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            client.changeWorkingDirectory(host.remotedir);\n        } catch (Exception e) {\n            com.microfly.util.DefaultLog.error(e);\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            FTPClient ftp = new FTPClient();\n            try {\n                ftp.connect(\"localhost\", 21);\n                ftp.login(\"ftpuser\", \"ftpuser123\");\n                System.out.println(\"Current: \" + ftp.printWorkingDirectory());\n                System.out.println(\"Dir status: \" + ftp.makeDirectory(DIR));\n                ftp.changeWorkingDirectory(DIR);\n                System.out.println(\"File status: \" + ftp.storeFile(FILE_PREFIX + this.getName(), getByteInputStream()));\n            } finally {\n                ftp.disconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"Connect": ["Process", "Connection", "Load", "Conn", "Sync", "Dial", "connected", "Close", "Build", "Subscribe", "Remote", "Socket", "Open", " Close", "Connector", "Construct", "Login", "Fail", "Config", "Host", "Run", "Client", "connect", "New", "Setup", "Create", "Init", " Connection"], "client": ["remote", "close", "core", "ssl", "cc", "ace", "server", "resource", "console", "handler", "clean", "user", "http", "con", "per", "socket", "c", "end", "project", "grid", "child", "host", "pool", "code", "co", "manager", "util", "friend", "cm", "cp", "session", "cache", "lib", "ce", "proxy", "connection", "default", "open", "config", "parent", "channel", "cl", "local", "request", "get", "cloud", "conn", "plugin", "name", "force", "ci", "port", "call", "pc", "secure", "Client", "connect", "cn", "cod", "command", "cli", "service", "api", "cell"], "reply": ["reason", "info", "address", "dy", "buffer", "response", "replace", "rc", "continue", " response", "message", "result", "echo", "answer", "query", "ret", "ply", "read", "next", "post", "sync", "part", "resp", "connection", "Reply", " replies", "request", "related", "status", "send", "call", "link", "prefix", "ping", "bot", "respond", "comment", "err", "state", "repl", "error", "code"]}}
{"id1": "21998571", "id2": "22734545", "code1": "    private String readTwitterFead() {\n        StringBuilder builder = new StringBuilder();\n        HttpClient client = new DefaultHttpClient();\n        HttpGet httpGet = new HttpGet(\"http://twitter.com/statuses/user_timeline/vogella.json\");\n        try {\n            HttpResponse response = client.execute(httpGet);\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n            if (statusCode == 200) {\n                HttpEntity entity = response.getEntity();\n                InputStream content = entity.getContent();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(content));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    builder.append(line);\n                }\n            } else {\n                Log.e(AndroidJsonTestingActivity.class.getName(), \"Failed to download file\");\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return builder.toString();\n    }\n", "code2": "    public void generate(String urlString, String target) throws Exception {\n        URL url = new URL(urlString);\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream());\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target));\n        byte[] buf = new byte[10 * 1024];\n        int len;\n        while ((len = inputStream.read(buf, 0, buf.length)) != -1) {\n            outputStream.write(buf, 0, len);\n        }\n        inputStream.close();\n        outputStream.close();\n        urlConnection.disconnect();\n    }\n", "label": 0, "substitutes": {"readTwitterFead": ["downloadFacebookFee", "downloadTwitterFFrequency", "downloadTwitterJrequency", "downloadFacebookFees", "downloadTwitterFlerequency", "downloadTwitterFee", "downloadTwitterFleee", "downloadTwitterFFees", "downloadTwitterFFead", "downloadTwitterFleead", "downloadFacebookJee", "downloadTwitterFead", "downloadFacebookJees", "downloadTwitterFees", "downloadTwitterFleees", "downloadFacebookFead", "downloadTwitterFFee", "downloadFacebookFrequency", "downloadTwitterJees", "downloadTwitterJee", "downloadTwitterJead", "downloadFacebookJrequency", "downloadTwitterFrequency", "downloadFacebookJead"], "builder": ["letter", "string", "base", "Builder", "buffer", "loader", "sf", "editor", "address", "server", "entry", "http", "building", "holder", "message", "board", "result", "instance", "driver", "keeper", "database", "iter", "er", "builders", "sb", "oder", "r", "build", "parser", "store", "object", "row", "null", "built", "writer", "image", "runner", "array", "worker", "db", "layer", "url", "we", "b", "wrapper", "atter", "trace", "container", "block", "f", "bean", "upper"], "client": ["class", "tc", "i", "handler", "server", "resource", "http", "con", "c", "per", "socket", "project", "host", "queue", "session", "ce", "bird", "proxy", "connection", "application", "config", "google", "channel", "https", "request", "get", "cloud", "conn", "plugin", "force", "io", "app", "url", "Client", "connect", "contact", "cli", "method", "service", "api"], "httpGet": [" httpPut", "urlFind", " httpDo", "HttpPut", "ttpPut", "ttpGet", "HTTPSend", "httpDo", "urlget", "httpSplit", " httpSplit", "HTTPGet", "httpPut", "HTTPFind", "urlGet", "ttpDo", " httpFind", " httpget", " httpSend", "HttpDo", "httpFind", "httpget", "HttpSplit", "HTTPget", "HttpGet", "urlSend", "ttpSplit", "httpSend"], "response": ["event", "handler", "server", "resource", "output", "http", "report", "message", "json", "document", "onse", "result", "ception", "session", "resp", "connection", "application", "collection", "wave", "data", "body", "page", "request", "object", "reply", "writer", "status", "success", "full", "received", "Response", "stream", "respond", "successful", "error", "service", "api"], "statusLine": ["StatusLine", "responseResponse", "statusResponse", "statResponse", "statEntry", "contentEntry", "contentLine", "responseEntry", "responseCode", " statusResponse", "contentBlock", "statusBlock", "StatusEntry", "httpStatus", "statLine", "statusStatus", "httpEntry", "statCode", "httpLine", " statusEntry", "StatusStatus", "contentStatus", "responseLine", "StatusBlock", "httpBlock", "statusEntry"], "statusCode": ["StatusLine", "contentCount", "stateType", "statusCount", "contentLine", " statusType", "statusType", "contentType", "statusStatus", "stateStatus", "contentCode", "StatusType", "stateCode", "StatusCode", "StatusCount", "StatusStatus", " statusStatus", " statusCount"], "entity": ["event", "article", "agent", "server", "resource", "Entity", "enc", "entry", "http", "json", "document", "et", "result", "el", "er", "ent", "type", "source", "activity", "connection", "media", "model", "application", "collection", "data", "file", "body", "page", "object", "coll", "e", "status", "writer", "person", "stream", "xml", "element", "code"], "content": ["handler", "buffer", "input", "loader", "resource", "output", "feed", "server", "entry", "json", "message", "cont", "result", "child", "driver", "read", "Content", "raw", "source", "load", "activity", "media", "collection", "data", "file", "text", "body", "channel", "page", "object", "conn", "status", "writer", "image", "pointer", "layer", "stream", "xml"], "reader": ["buffer", "loader", "i", "input", "handler", "resource", "server", "editor", "reading", "per", "ri", "read", "in", "iter", "ler", "er", "bird", "oder", "ner", "r", "parser", "data", "rar", "row", "rr", "or", "rer", "io", "writer", "worker", "ser", "stream", "Reader"], "line": ["letter", "string", "base", "buffer", "i", "id", "lf", "feed", "entry", "message", "LINE", "character", "end", "l", "write", "sheet", "pass", "char", "iter", "key", "sync", "part", "one", "source", "lines", "lc", "connection", "str", "r", "data", "file", "text", "body", "liner", "page", "ip", "le", "object", "inline", "row", "style", "name", "e", "link", "sl", "url", "pe", "comment", "lin", "Line", "block", "code", "point", "cell"]}}
{"id1": "6966398", "id2": "23215235", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void readFile(URL url) throws PedroException, IOException, ParserConfigurationException, SAXException {\n        this.zipFileName = url.toString();\n        URLConnection urlConnection = url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n        unzipNativeFormatFile(inputStream);\n        parseAlertFiles();\n        deleteAlertFiles();\n    }\n", "label": 0, "substitutes": {"reader": ["ry", "rw", "loader", "handler", "her", "cer", "resource", "feed", "buffer", "reading", "rc", "builder", "input", "df", "server", "per", "ri", "se", "instance", "driver", "o", "reads", "dr", "keeper", "manager", "read", "iter", "ler", "rake", "er", "client", "cms", "load", "source", "pp", "oder", "book", "ner", "connection", "r", "parser", "config", "file", "rar", "p", "row", "rr", "context", "or", "io", "writer", "k", "pe", "stream", "raf", "Reader"], "ks": ["keys", "works", "orks", "DS", "sk", "ko", "fs", "checks", "acs", "ke", "inks", "ck", "gets", "ns", "kies", "se", "qs", "bs", "kb", "reads", "co", "ms", "rs", "ku", "hs", "ops", "akes", "ans", "cks", "ips", "es", "CS", "acts", "ls", "vs", "ges", "ics", "rows", "ss", "books", "powers", "ctx", "kes", "ches", "k", "ki", "acks", "ds", "cs", "ps", "opens", "icks", "KS"], "key": ["keys", "base", "ssl", "server", "ee", "ke", "user", "lock", "c", "co", "read", "char", "client", "type", "cache", "ce", "seed", "value", "file", "Key", "ca", "p", "io", "ring", "k", "pe", "ki", "secret", "pair", "sign", "trust", "state", "court", "transfer", "pg", "service", "code", "point"], "chain": ["path", "root", "base", "enc", "lock", "sequence", "slice", "table", "c", "set", "code", "crypt", "wrap", "rule", "cache", "circle", "collection", "store", "config", "none", "file", "chains", "object", "coll", "box", "Chain", "image", "cr", "family", "mc", "pair", "secret", "range", "stack", "container", "network", "block", "scale", "wheel", "list"], "os": ["ou", "oses", "fs", "Os", "op", "opens", "res", "OS", "o", "outs", "s", "is", "ms", "rs", " o", "ros", "bos", "ops", "ob", "options", "oid", "object", "p", "es", "aos", "rss", "oss", "io", "pos", "ot", " bos", "ios", "ds", "los", "ps", "ol", "osi", "iso", "cos"], "stamper": ["starmper", "stammer", "spammer", "path", "stAMmer", " nostampper", "stameper", " nostamler", "streamler", " nostample", "s", "starmler", "stAMper", "stampe", " nostameler", "streammer", "stammper", "stAMpe", "spAMpe", "spampe", "spAMmer", "spAMler", "stampper", " nostameple", " nostamepper", "spamler", "stamepper", "stammmer", "stamler", "g", "streamper", "data", "spamper", " nostamper", "stammpe", "spAMper", "function", "stample", "stameler", "starmpper", "stameple", "streampe", "_", "starmple", " nostameper", "stAMler", "stammple", "stammpper", "stammler", "this"], "appearance": ["Appears", " appearing", "formearance", "feedearance", " appismo", "appear", "signear", "installear", "installasion", "feedfacing", "appearing", "byear", "suppfacing", "byearance", "byismo", "askearance", "signfacing", "installearance", " appears", "ppaser", "suppointment", "Appearing", " appeared", "applier", "signearance", "formearing", "suppearing", "feedear", "signointment", "byearing", "atteared", "appasion", "Appearance", "appfacing", "attfacing", " appfacing", "suppearance", "attearance", "formear", "askeared", " appear", "appaser", "appointment", "appismo", "signearing", "appears", "appence", "appeared", "signears", "ppasion", "feedointment", "formaser", "formismo", "ppear", "installearing", "attence", "suppear", "askence", "askfacing", "signlier", "suppasion", " appence", "Applier", " applier", "ppearance", " appaser", "ppearing"]}}
{"id1": "8328527", "id2": "15500892", "code1": "    public void insertJobLog(String userId, String[] checkId, String checkType, String objType) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preStm = null;\n        String sql = \"insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)\";\n        String cleanSql = \"delete from COFFICE_JOBLOG_CHECKAUTH where \" + \"user_id = '\" + userId + \"' and check_type = '\" + checkType + \"' and obj_type = '\" + objType + \"'\";\n        try {\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            preStm = connection.prepareStatement(cleanSql);\n            int dCount = preStm.executeUpdate();\n            String sHaveIns = \",\";\n            preStm = connection.prepareStatement(sql);\n            for (int j = 0; j < checkId.length; j++) {\n                if (sHaveIns.indexOf(\",\" + checkId[j] + \",\") < 0) {\n                    preStm.setInt(1, Integer.parseInt(userId));\n                    preStm.setInt(2, Integer.parseInt(checkId[j]));\n                    preStm.setInt(3, Integer.parseInt(checkType));\n                    preStm.setInt(4, Integer.parseInt(objType));\n                    preStm.executeUpdate();\n                    sHaveIns += checkId[j] + \",\";\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            log.debug((new Date().toString()) + \" \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0228\ufffd\ufffd\u02a7\ufffd\ufffd! \");\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n                throw e;\n            }\n            throw ex;\n        } finally {\n            close(null, null, preStm, connection, dbo);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"insertJobLog": ["insertJLog", "insertWorkLog", "createjoblog", "createjobEntry", "insertJHistory", "insertWorklog", "createjobHistory", "insertjobLog", "createJobEntry", "insertJobHistory", "insertJoblog", "insertJobEntry", "insertWorkHistory", "createjobLog", "createJobHistory", "insertjobEntry", "insertjobHistory", "insertJlog", "insertJEntry", "insertWorkEntry", "createJobLog", "insertjoblog", "createJoblog"], "userId": ["userData", "userName", "userID", "useId", "useID", "customID", "customData", "useType", " userID", "useName", "UserDb", "UserData", " userType", "userType", "UserType", "USERName", "customDb", "UserName", "UserID", "USERId", "UserId", " userDb", "USERID", "userDb", "customId", " userData"], "checkId": ["workerID", "checkID", " checkPoint", "checkPath", "workId", "workType", "pullPoint", "updateID", "jobId", "userID", "pullID", "checkPoint", "workerId", "jobPath", "workerInt", "CheckPath", "userInt", "updateId", "userPoint", "pullType", " checkPath", "pullInt", "workID", "pullId", "CheckID", "CheckInt", "checkInt", "updateInt", "jobPoint", "jobID", " checkID", " checkInt", "CheckId", "workPoint", "CheckPoint", "CheckType", "updatePoint"], "checkType": ["checkID", " checkTypes", "blockTypes", "workId", "workType", "taskType", "checkTyp", " checkLength", "blockLength", "checkLength", "blockType", "taskId", " checkTyp", "CheckTyp", "CHECKTyp", "workInfo", "taskID", "blockId", "taskInfo", "CheckTypes", "CHECKType", "CHECKRole", "workID", "CheckID", "CheckRole", " checkInfo", "checkRole", "checkInfo", " checkID", "CHECKID", "CheckId", "CheckLength", "CheckType", " checkRole", "checkTypes"], "objType": [" objTy", "objId", "ObjId", "checkTyp", "checkName", "ObjTy", "ObjTypes", "objectTyp", "opType", "ObjType", "opName", "ObjName", "objectId", "objectTy", "objectName", "objName", "objTypes", " objName", "objectType", "objTyp", " objId", "opTypes", "objTy", "ObjTyp", "opId", "objectTypes"], "dbo": ["mbu", "dbf", " dbm", "Dbf", "drbm", "jbu", "Dko", " dko", "adbo", "Dbu", "jbf", "dBo", "DBO", "adBO", " dBo", "drko", "Dbl", " dbl", "drbl", "mBo", "jBo", "adbm", "adBo", "Dbm", "Dbo", "dbm", "dbl", "dbu", "drbo", "drBO", "drBo", "mbf", "dBO", "dko", "mbo", "jbo", " dBO", "DBo"], "connection": ["directory", "Connection", "index", "server", "resource", "response", "lock", "subject", "document", "con", "c", "connected", "communication", "socket", "current", "message", "driver", "pool", "relation", "management", "manager", "query", "database", "condition", "union", "client", "session", "cache", "ion", "application", "collection", "section", "config", "channel", "log", "context", "conn", "ci", "io", "graph", "function", "db", "mc", "ctx", "bc", "BC", "position", "unit", "service", "b", "connect", "statement", "engine", " Connection", "loc"], "preStm": ["preShma", "preEstd", "preShms", " preScvm", "synStms", "preInstvm", "preTrmn", "preRms", "preSTms", "cleanStmn", " preRrm", "preStreamms", "prestmr", "preDispm", "prStmr", "preClm", "preSTmd", "preTram", "prestm", " preTrmt", "preScf", "preRM", "preSTm", "preStrms", "preSlmn", "preEstmt", " preShma", "preRestmt", "preTrmt", "preScfm", "preScma", "preRestm", "preConstmt", "prDisf", "preStreamm", "PRERestmn", "preStrm", "preClmn", " preStvm", " preStmn", "preEdrm", "preStmt", "prDispm", "synStm", "preEstvm", "preRm", "preStd", "preTrm", "preClv", "preRestM", "preShmt", "preScvm", "preEdfm", "preShM", "preDisf", "preSTrm", "PRERestmt", "prStm", "preDismr", "preEdms", " preRm", " preShv", "synEstms", "preSlm", "preSlv", "cleanClv", "PRERestm", " preStmd", "PREEstm", " preStms", "preStmd", "preSlma", "preScv", " preRmd", "cleanStv", "preConstmn", "prDismr", "PREStmt", " preTram", "preSlf", "prestms", "preStf", "cleanClm", "prestpm", "cleanClM", " preStM", "preScms", "PREEstms", "preRmn", " preStrm", "preRestms", "PREStm", "preScm", "preRmd", " preShM", "prDism", "PREEstmt", "preStreamvm", "preStvm", "preShmr", "preShm", "preSlmt", "preInstm", " preTrm", "preEstms", "cleanStM", " preRms", " preStv", "preEdmn", " preStf", "preSlam", "preColv", " preShvm", "preStpm", "preColM", "preStma", "preShpm", "preStfm", "PREEstM", "prStpm", "preClM", " preScms", " preShf", "preEstM", "preRestfm", "preRestd", "PREStmn", "cleanClmn", "preColm", "prStf", "PRERestfm", "preStmn", "preColmn", "synEstM", "preStms", "prestf", "synStd", "prestfm", "preEdmt", "preStmr", " preShms", "preConstm", "preStrd", " preScm", "preRrm", " preShm", "prestvm", "PREStM", "preInstms", "preStrM", "preRestmn", "preShf", "preStM", "preShvm", "preEdm", "preStreamM", "synEstd", "cleanStm", "synEstm", " preStam", "preStam", " preStmt", "PREStms", "preConstam", "preEdmd", " preTrmn", "preRv", " preStfm", "PREStfm", "preDism", "preShv", "preEstm", "preSlfm", " preScfm", "preInstfm", "synStM", "preStv", " preStma"], "sql": ["where", "zip", "string", "ssl", "job", "join", "limit", "html", "l", "fn", "shell", "sol", "query", "database", "dl", "params", "select", "sync", "q", "seed", "str", "eps", "ql", "body", "nl", "log", "sq", "conn", "msg", "ls", "function", "db", "sl", "url", "plan", "SQL", "printf", "statement", "sn", "expr", "pg"], "cleanSql": ["cleanCwl", " cleanCql", "cleanPsprintf", "cleanPsq", "cleanSprintf", "cleanCQL", " cleanAssql", " cleanSwl", "cleanStsql", "cleanSQL", " cleanAsprintf", "cleanEsprintf", " cleanCQL", "cleanAsprintf", "cleanAsq", "cleanPsql", "cleanStQL", "cleanCsql", "cleanPssql", "cleanAssql", "cleanAsql", " cleanCsql", " cleanAsql", " cleanSprintf", " cleanSq", "cleanAsQL", "cleanCql", "cleanEsq", "cleanStwl", " cleanSQL", "cleanSsql", "cleanStql", "cleanAswl", "cleanEssql", " cleanSsql", " cleanCwl", "cleanSwl", "cleanSq", " cleanAsq", "cleanEsql"], "dCount": [" dcount", "DCount", " dCounter", "Dcount", " dNumber", "DCounter", "dhcount", "dcount", "dCounter", "dhCounter", "dhNumber", "DNumber", "dNumber", "dhCount"], "sHaveIns": ["sHavingIns", "sAreContents", "sHasContents", "phaveINS", "sHaveContents", "shaveINS", "pHaveins", " sHaveContents", " sWithNoContents", "sHasIns", " shaveIns", "shaveins", "sHaveWs", "shaveIn", "sHadIn", " sHaveins", "sWithNoins", " shaveIn", "sHavingins", " sHaveIn", "sWithNoINS", "sHavingWs", "sHaveINS", "sHaveIn", "sWithNoContents", "pHaveWs", " sWithNoINS", "phaveins", "sWithNoIn", " shaveins", "sHadIns", "pHaveINS", "shaveWs", " sHaveINS", "sWithNoIns", "sAreWs", "sAreins", "shaveIns", "pHaveIns", "sHavingINS", "phaveWs", "sHadins", "sAreIns", "phaveIns", " sWithNoIns", "sHaveins", "sHasINS", "sAreINS"], "j": ["job", "i", "num", "uj", "n", "ij", "jet", "vol", "lock", "ie", "dj", "jc", "ind", "z", "jl", "l", "jo", "off", "fr", "el", "key", "aj", "syn", "part", "ja", "ji", "pr", "ch", "g", "bj", "section", "li", "h", "journal", "p", "x", "u", "jj", "J", "js", "kj", "jp", "k", "b", "v", "obj", "y", "jit", "adj", "oj", "br", "f"]}}
{"id1": "18793482", "id2": "4164833", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"modifyApplicationMessage": ["modifyAppMessage", "modifyApplicationContent", "modifyExternalMsg", "modifyExternalMessage", "modifiedapplicationmessage", "modifyapplicationmessage", "modifiedApplicationMessage", "modifyapplicationMsg", "modifiedapplicationContent", "modifyApplicationMsg", "modifiedApplicationMsg", "modifyapplicationContent", "modifiedapplicationMsg", "modifiedApplicationmessage", "modifyAppmessage", "modifyAppMsg", "modifiedApplicationContent", "modifyExternalContent", "modifiedapplicationMessage", "modifyApplicationmessage", "modifyExternalmessage", "modifyapplicationMessage", "modifyAppContent"], "locale": ["localALE", "locationue", "locales", "locationale", "locALE", "Locator", "locator", " locame", "locationALE", "localales", "Locame", "LocALE", "placeame", "placeALE", "localame", "localator", "locame", "Locue", "locationales", " locator", "Locales", "Locale", "localue", "localale", " locales", "locue", "placeale", "placeales"], "messageName": ["phraseName", "reasonname", "reasonName", "MessageKey", "reasonValue", "msgKey", "msgType", "msgName", " messageType", "Messagename", "reasonType", "phraseValue", "MessageValue", "phraseKey", "messageType", "MessageType", "msgValue", " messagename", " messageKey", "messagename", "phraseType", "messageKey", "MessageName"], "messageValue": ["responseName", "MessageName", "msgVal", "msgType", "msgName", "MessageVal", " messageType", "responseVal", "MessageValue", " messageVal", "messageType", "MessageType", "messageVal", "responseValue", "msgValue", "responseType"], "properties": ["settings", "perties", "resources", "json", "py", "pb", "txt", "params", "Property", "ops", "stats", "config", "data", "pro", "tmp", "options", "metadata", "ips", " props", "prop", "obj", "conf", "xml", "ps", "Pro", "property", "api", " Properties"], "i18nPath": ["i18ninPath", "i18nsLocation", "i16nStr", "i18bpath", "i16nsPart", "i16nspath", "i18neCorp", "i18fpath", "i18fUrl", "i18onPath", "i18naStr", "i11fCorp", "i32nPath", "i32ninFile", "i18nePath", "i11nUrl", "i18nStr", "i18nsFile", "i32ninPath", "i18fCorp", "i18nsPart", "i18napath", "i11nCorp", "i18nsUrl", "i11npath", "i18nUrl", "i32ninUrl", "i18ninUrl", "i18nspath", "i18neUrl", "i18nLocation", "i18onFile", "i18naPart", "i18nepath", "i32nLocation", "i18ninFile", "i18nsPath", "i11fPath", "i11fpath", "i18fPath", "i16nsPath", "i11fUrl", "i32nFile", "i18onLocation", "i18nsStr", "i18nCorp", "i18nPart", "i16nPath", "i18bPart", "i16nsStr", "i18nFile", "i16nPart", "i18onUrl", "i11nPath", "i32nUrl", "i18bStr", "i18naPath", "i18npath", "i18ninLocation", "i18bPath", "i32ninLocation", "i16npath", "i18nsCorp"], "englishFile": ["englishPath", "ianaJar", "Englishfile", "englishJar", "EnglishFiles", "examplePath", "ianaPath", " englishFiles", " englishPath", "ianaFile", "propertiesFile", " englishJar", "englishfile", "englishFiles", "ianaDir", "propertiesPath", "propertiesfile", "EnglishPath", "languagefile", "languageDir", "languagePath", " englishfile", "englishFolder", "exampleFolder", "englishDir", "languageFile", "EnglishFile", "exampleFile", "languageJar", "examplefile", "EnglishFolder", "languageFiles", "propertiesFolder", " englishDir"], "propertiesFilePath": ["pertiesfileURL", "propertiesfileUrl", "propertiesfilePath", "propertiesDirUrl", "pertiesFileURL", "propertiesSourceFileURL", "propertiesFileURL", "propertiesFilesPath", "propertiesfilepath", "pertiesFileUrl", "pertiesfilepath", "pertiesFilePath", "propertiesDirName", "propertiesFilepath", "pertiesDirPath", "propertiesFileName", "propertiesSourceFilePath", "pertiesFilepath", "pertiesfileName", "propertiesDirPath", "propertiesSourceFilepath", "pertiesDirName", "propertiesFilesUrl", "propertiesFilespath", "propertiesFileUrl", "pertiesfilePath", "propertiesFilesName", "pertiesFileName", "pertiesDirUrl", "pertiesDirpath", "propertiesDirpath", "propertiesFilesURL", "propertiesSourceFileName", "propertiesfileName", "propertiesfileURL"], "file": ["zip", "base", "class", "handler", "resource", "http", "content", "die", "model", "format", "force", "it", "files", "url", "module", "string", "buffer", "lock", "part", "source", "use", "binary", "up", "connection", "parent", "page", "object", "le", "name", "full", "unit", "b", "play", "letter", "path", "directory", "ile", "message", "socket", "php", "File", "one", "reader", "book", "show", "h", "language", "p", "or", "function", "word", "future", "field", "property", "single", "fe", "filename", "fp", "l", "child", "media", "application", "FILE", "data", "text", "entity", "log", "folder", "pe", "stream", "f"], "in": ["IN", "sin", "pin", "i", "input", "n", "plus", "ini", "into", "gin", "ic", "con", "inner", "ri", "l", "s", "ins", "bin", "er", "reader", "d", "login", "inside", "r", "inc", "rin", "p", "init", "or", "again", "io", "image", "isin", "it", "In", "nin", "kin", "lin", "b", "err", "cin", "inn", "f", "win", "din"], "out": ["string", "ou", "i", "outer", "output", "ex", "n", "builder", "by", "net", "plain", "OUT", "inner", "socket", "end", "outs", "o", "s", "write", "bin", "co", "sync", "part", "one", "lib", "up", "r", "w", "inc", "work", "p", "again", "exec", "Out", "io", "image", "home", "to", "exp", "word", "full", "ext", "b", "v", "err", "and", "f", "cli", "error"], "c": ["cu", "i", "cc", "sc", "n", "cf", "rc", "enc", "character", "con", "cont", "o", "col", "l", "dc", "char", "ec", "d", "ce", "uc", "ct", "lc", "r", "ch", "cy", "w", "ice", "cl", "xc", "h", "x", "size", "p", "C", "arc", "ci", "t", "cr", "pointer", "esc", "dec", "pc", "a", "bc", "abc", "k", "v", "b", "ac", "f", "cur", "code"], "is": ["info", "bis", "i", "iss", "id", "serv", "IS", "isa", "res", "Is", "as", "ri", "ins", "s", "does", "si", "ui", "iter", "its", "ais", "str", "ir", "get", "es", "has", "iso", "ris", "it", "ios", "us", "ib", "stream", "are", "os", "ps", "isu", "re", "api"], "breader": ["breadamer", " cakeler", " breadER", "breadr", " cakeers", "brewer", "feedamer", " cakeer", " Breader", "brewr", "weber", " Breaders", "webr", "webamer", " cakeER", "feedr", " BreadER", "breadler", "breadER", "webiter", " breaders", "brewamer", " breadler", "feediter", "feeder", "breaditer", "brewiter", "breaders", " Breadler"], "line": ["letter", "string", "base", "lo", "feed", "response", "lf", "entry", "message", "LINE", "character", "end", "band", "l", "look", "el", "write", "pass", "day", "liner", "key", "split", "next", "sync", "part", "one", "rule", "no", "lines", "lc", "item", "value", "model", "str", "section", "data", "text", "body", "li", "page", "ip", "le", "nl", "log", "row", "inline", "style", "side", "plugin", "name", "header", "frame", "status", "word", "link", "sl", "strip", "url", "lined", "comment", "Line", "lin", "parse", "block", "error", "phrase", "definition", "code", "cell"], "strBuilder": ["strbuilder", " strbuilder", "stringBuilder", "StrBlock", "StrBuilding", " strBuild", "brBlock", "brBuilding", "StrBuild", "strBlock", "Strbuilder", " strBlock", "stringbuilder", "brBuffer", "StrBuffer", "stringBuilding", "stringBuild", "brBuild", "strBuffer", "stringBuffer", " strBuilding", "brbuilder", "StrBuilder", " strBuffer", "strBuilding", "brBuilder", "strBuild"], "pieces": ["keys", "services", "pages", "tips", "features", "bones", "steps", "styles", "letters", "apps", "packs", "split", "parts", "items", "nets", "pots", "lines", "tops", "ops", "strings", "blocks", "circle", "boxes", "flows", "names", "vals", "objects", "cards", "ips", "groups", "planes", "phones", "forms", "lists", "seconds", "cells", "values", "bytes", "files", "pins", "places", "rings", "piece", "cuts", "words", "sections", "bits", "marks"], "found": ["changed", "val", "letter", "temp", "defined", "Found", "broken", "loaded", "confirmed", "result", "find", "l", "all", "created", "failed", " Found", "fall", "updated", "fl", "filled", "true", "lost", "expected", "not", "old", "based", "printed", "used", "fixed", "got", "finding", "search", "null", "built", "sent", "still", "given", "identified", "normal", "full", "required", "err", "left", "missing", "successful", "successfully", "count", "matched", "f", "made", "first", "valid"]}}
{"id1": "7006052", "id2": "19667000", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static Reader getReader(String url) throws MalformedURLException, IOException {\n        if (url.startsWith(\"file:\")) return new FileReader(url.substring(5)); else if (url.startsWith(\"http:\")) return new InputStreamReader(new URL(url).openStream());\n        throw new MalformedURLException(\"Invalid URI schema, file: or http: expected.\");\n    }\n", "label": 0, "substitutes": {"copyFileTo": [" copyFilesTo", " copyFilesFile", "copyfileInfo", " copyFileInfo", " copyFileFrom", "copySourceFileFrom", "copyfileFrom", "copySourceFileFile", "copySourceFileInfo", "copyFilesFile", "copyFileFile", "copyFilesInfo", " copyFileFile", "copyFileFrom", "copyFilesFrom", "copyFilesTo", "copySourceFileTo", "copyfileTo", "copyFileInfo", " copyFilesFrom", "copyfileFile", " copyFilesInfo"], "src": ["string", "remote", "sel", "sin", "path", "sc", "uri", "resource", "rc", "filename", "slice", "sub", "loc", "fn", "s", "rs", "txt", "sync", "rb", "source", "sb", "old", "upload", "config", "data", "file", "archive", "href", "js", "image", "sup", "sl", "url", "stream", "b", "inf", "code", "img"], "dest": ["temp", "output", "filename", "project", "sub", "later", "result", "done", "bin", " Dest", "txt", "die", "comb", "source", "wb", "dir", "target", "dist", "default", "data", "flat", "tmp", "Dest", "route", "img", "des", "delete", "test", "folder", "desc", "name", "home", "opt", "sup", "const", "secure", "b", " destination", "orig", "loc"], "destFile": [" destinationFiles", "destfile", "targetFile", "DestFile", "targetFiles", " destFiles", " destDir", "targetfile", "destFiles", " destinationDir", " destF", "targetDir", "DestFiles", "destF", " destinationF", " destfile", "destDir", "DestDir", "Destfile", " destinationFile", "DestF"], "in": ["IN", "impl", "pin", "i", "input", "n", "id", "ini", "gin", "con", "inner", "socket", "l", "ins", "s", "trans", "bin", "pass", "is", "source", "reader", "thin", "up", "login", "diff", "inside", "r", "inc", "data", "rin", "init", "again", "image", "In", "nin", "kin", "ln", "url", "stream", "lin", "err", "cin", "inn", "f", "win", "din"], "out": ["ex", "n", "output", "outer", "copy", "user", "net", "plain", "OUT", "inner", "o", "pool", "off", "bin", "extra", "post", "sync", "client", "part", "one", "cache", "up", "other", "inc", "work", "data", "file", "parent", "w", "log", "null", "conn", "again", "exec", "Out", "io", "writer", "exp", "image", "ext", "err", "obj", "ac", "this", "cos"], "buf": ["path", "buffer", "Buffer", "bf", "bd", "bh", "rc", "map", "cap", "c", "cb", "result", "length", "pool", "off", "bin", "ff", "queue", "uf", "raw", "bag", "cv", "rb", "cache", "cas", "uc", "blocks", "buff", "data", "tmp", "fb", "box", "vec", "bytes", "ctx", "bc", "seq", "v", "b", "br", "bl", "pad", "block", "batch", "orig", "loc"], "len": ["val", "base", "num", "id", "n", "lf", "pre", "Len", "cap", "ind", "c", "ie", "end", "l", "length", "all", "line", "off", "el", "en", "split", "iter", "fl", "fin", "nt", "part", "no", "lc", "min", "data", "li", "body", "lim", "size", "coll", "pos", "rev", "fd", "ln", "bytes", "url", "count", "f"]}}
{"id1": "1769771", "id2": "13563706", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyChannel", "copyChannel", "CopyFile", "copyfile", "transferfile", "transferFiles", "transferChannel", " copyFiles", "Copyfile", " copyChannel", "CopyFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "base", "pin", "i", "input", "id", "ex", "lock", "c", "inner", "l", "ins", "bin", "query", "source", "reader", "login", "min", "diff", "inc", "work", "config", "file", "data", "again", "name", "m", "image", "io", "In", "url", "lin", "inn", "f", "win"], "out": ["string", "base", "ex", "n", "output", "server", "resource", "user", "plain", "OUT", "c", "o", "outs", "off", "write", "extra", "cache", "dot", "up", "target", "default", "w", "file", "x", "p", "conn", "name", "again", "exec", "Out", "io", "writer", "image", "call", "prefix", "ext", "v", "b", "external", "point"], "inChannel": ["binStream", "inputChannel", "INchannel", "binchannel", "inStream", " inchannel", "inputchannel", " inClient", "winChan", "binClient", "inchannel", "binChan", "InChan", "Inchannel", "inputChan", "INChan", "outStream", "outchannel", "outChan", "inChan", "InChannel", "insClient", "outClient", "insStream", "InStream", "inputStream", "insChannel", "binChannel", "INStream", "winChannel", "winchannel", "INChannel", " inStream", "InClient", "inClient", " inChan", "insChan", "winStream"], "outChannel": ["outputCh", "inputChannel", "inStream", "inputchannel", "OutConnection", "OutChannel", "inchannel", " outConnection", "nManager", "nChan", "OutChan", "inCh", "inputChan", "outStream", "outchannel", "nChannel", "outChan", "inChan", "inputController", "outputStream", "outputChannel", "outputchannel", "outputController", " outCh", "outConnection", "Outchannel", "nStream", "outCh", " outManager", "inConnection", "outputChan", " outStream", "inManager", "outController", "outManager", "inController", " outchannel", " outChan"]}}
{"id1": "21979717", "id2": "17158020", "code1": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"upload": ["accept", "execute", "add", " submit", "run", "save", " transfer", "post", "select", "load", "up", "open", "archive", " download", "Upload", "request", "init", "submit", "start", "Submit", "create", " Upload", "paste", "process", "transfer", "download"], "fileResult": ["FileResults", "downloadRes", "filesResult", "fpRank", "filesresult", "fileRank", "fileResults", "FileRes", "fpRes", " fileResults", " fileRes", "fpResults", "FileRank", "downloadRank", "downloadResult", "filesResults", "fpResult", "downloadResults", "Fileresult", " fileresult", "fileRes", "fileresult", "FileResult", "filesRes"], "in": ["IN", "info", "pin", "i", "input", "ini", "gin", "on", "into", "c", "inner", "socket", "ins", "arin", "bin", "source", "cache", "up", "login", "min", "inside", "inc", "data", "file", "rin", "vin", "p", "init", "conn", "again", "image", "isin", "In", "kin", "conf", "lin", "cin", "inn", "f", "tin", "win"], "url": ["impl", "path", "ssl", "address", "server", "uri", "http", "c", "socket", "l", "host", "URL", "pl", "fl", "client", "connection", "ob", "file", "channel", "cl", "web", "bel", "log", "conn", "ls", "coll", "image", "sl", "pull", "Url", "www", "ur", "b", "ul", "f", "gl", "org", "api"], "con": ["remote", "close", "ssl", "fun", "non", "Conn", "pin", "fa", "CON", "cf", "rc", "cons", "http", "ran", "on", "plain", "c", "per", "fc", "ctrl", "sub", "run", "socket", "Con", "co", " conn", "func", "en", "ec", "client", "sync", "cm", "syn", "cp", "ocon", "part", "rou", "uc", "connection", "login", "min", "ch", "open", "conv", "un", "ca", "cl", "request", "log", "gen", "conn", "exec", "pc", "pen", "bc", "ver", "can", "conf", "connect", "cn", "cur", "re"], "out": ["base", "ssl", "input", "ex", "output", "copy", "outer", "resource", "server", "on", "c", "socket", "OUT", "as", "outs", "o", "pool", "line", "bin", "client", "at", "cache", "connection", "login", "ch", "inc", "parent", "file", "object", "conn", "again", "Out", "image", "io", "can", "conf", "b", "obj", "v", "err", "win", "this", "external"], "in2": ["in02", "inTwo", "In4", " in4", "errTwo", "InTwo", "IN4", "intwo", " inTwo", "INTwo", " intwo", "IN02", "input2", " in02", "in4", "outtwo", "out2", "input4", " in1", "out1", "errtwo", "input02", "out4", "In2", "in1", "outTwo", "err2", "inputTwo", "IN2", "In1", "err1"], "buf": ["base", "buffer", "Buffer", "bf", "bd", "bh", "rc", "cf", "cap", "lb", "cb", "pool", "done", "bin", "ff", "feat", "uf", "la", "bag", "utf", "cv", "rb", "cas", "uc", "buff", "cat", "data", "text", "fb", "av", "box", "vec", "home", "font", "ha", "dec", "db", "fd", "bytes", "bc", "Buff", "seq", "b", "br", "fab", "ba", "block", "batch"], "bytesRead": ["byteLength", "bytesRun", "linesRun", "rowsRead", " bytesWritten", "rowsread", "rowsUse", "BytesRead", "BytesWrite", " bytesRun", "byteRead", "linesRead", "tesRead", " bytesUse", "bytesLength", "bytesWritten", "bytesread", " bytesLoad", "BytesLoad", "tesRun", "blocksread", "bytesLoad", "blocksWrite", "BytesLength", " bytesread", "tesWritten", "byteLoad", "blocksRead", "byteWrite", "linesWritten", "rowsWrite", " bytesWrite", " bytesLength", "bytesWrite", "linesWrite", "bytesUse", "tesWrite", "blocksUse"]}}
{"id1": "11616716", "id2": "1188100", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResponseasFile", "getCMSResultInReader", "getCMSResponseAsFile", "getCMSResultInStream", "getCMSResponseAsReader", "getCMSResponseasReader", "getCMSResultasStream", "getCMSResultAsSteam", "getCMSResultWithSteam", "getCMSResultInSteam", "getCMSResultasFile", "getCMSResultAsReader", "getCMSResultInFile", "getCMSResponseAsStream", "getCMSResponseasStream", "getCMSResponseAsSteam", "getCMSResultWithReader", "getCMSResultWithStream", "getCMSResultWithFile", "getCMSResultasSteam", "getCMSResultasReader", "getCMSResultAsFile", "getCMSResponseasSteam"], "rqlQuery": ["srQLQ", "srQLQu", "srqlquery", "rqlquery", "rQLQ", "rQLQuery", "rQLQu", "srqlQuery", " rsqlquery", "rQLquery", "rSQLquery", "riliquery", " rqlquery", "riliQuery", " rsqlQu", " rsqlQuery", " rqlMethod", "rsqlMethod", "srQLquery", "rqlQ", "rqlMethod", "rqlQu", " rqlQu", "rsqlQuery", "srqlQu", "rSQLQuery", "rSQLMethod", "riliQu", "rsqlQu", "srQLQuery", " rsqlMethod", "rSQLQu", "srqlQ", "rsqlquery", "rsqlQ", "riliQ", "rQLMethod"], "osr": ["osrw", "opsR", "osR", "otsr", " osrr", "ysr", "bosr", "usrs", "ossrt", "ossrm", "osrs", "iosrs", " ossr", " oscr", "obsrar", "ossrar", "boswer", "usr", "usrw", "ysrar", "otssr", "losfr", "yscr", "osspr", "OSrr", "OSrt", " ospr", " osrar", "ossrr", " osrt", "iosrw", "ossrw", "opswer", "cosrt", "iospr", "ysrt", "losrt", "oswer", "otsrm", "obswer", "usrt", "ossrs", "osrt", "oscr", " osfr", "obsR", "iosr", "bosR", "osrr", "OSr", "osserr", "oserr", "usrr", "otspr", "ossr", " osrm", "OSerr", "osssr", "losrr", "uspr", "opsr", "userr", "opsrar", "osrm", "obsr", "osscr", "cosfr", "cosr", "bosrar", "ospr", "osrar", "losr", "cosrr", "osfr"], "url": ["string", "path", "ssl", "base", "server", "uri", "resource", "http", "socket", "l", "host", "URL", "fl", "client", "source", "lc", "connection", "r", "ob", "open", "config", "file", "channel", "fb", "web", "nl", "ll", "page", "ls", "blog", "sl", "rl", "Url", "www", "b", "f", "org"], "conn": ["Connection", "ssl", "Conn", "server", "n", "rc", "enc", "http", "net", "con", "c", "act", "cb", "col", "l", "fn", "rt", "dc", "en", "nc", "ec", "client", "sync", "nt", "cp", "pr", "lc", "ct", "connection", "rn", "ch", "open", "conv", "ca", "attr", "h", "p", "coll", "ci", "exec", "oss", "ann", "cr", "db", "pc", "ctx", "err", "connect", "cn", "wrapper", "reg", "f", "cur", "org", "loc"]}}
{"id1": "7169984", "id2": "19307120", "code1": "    public static String connRemote(JSONObject jsonObject, String OPCode) {\n        String retSrc = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(AZConstants.validateURL);\n            HttpParams httpParams = new BasicHttpParams();\n            List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>();\n            nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode));\n            nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString()));\n            httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair));\n            httpPost.setParams(httpParams);\n            HttpResponse response = httpClient.execute(httpPost);\n            retSrc = EntityUtils.toString(response.getEntity());\n        } catch (Exception e) {\n            Log.e(TAG, e.toString());\n        }\n        return retSrc;\n    }\n", "code2": "    public static String sendPost(String url, String param) {\n        String result = \"\";\n        try {\n            URL httpurl = new URL(url);\n            HttpURLConnection httpConn = (HttpURLConnection) httpurl.openConnection();\n            httpConn.setRequestProperty(\"Accept-Language\", \"zh-CN\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            PrintWriter out = new PrintWriter(httpConn.getOutputStream());\n            out.print(param);\n            out.flush();\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n            in.close();\n        } catch (Exception e) {\n            MsgPrint.showMsg(e.getMessage());\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"connRemote": ["execURL", " executeLocal", " executeRemote", " executeIP", " execURL", "invokeLocal", "execLocal", "invokeURL", "execRemote", " execLocal", " execRemote", "execIP", " executeURL", "invokeRemote", "invokeIP", " execIP"], "jsonObject": [" jsonString", "JSONString", "httpObj", "jsonString", "JSONObj", "JSONOperation", "JSONArray", " jsonBody", "customObj", "httpObject", "httpArray", "JSONObject", "javaOb", "jsonOperation", "javaString", "customArray", "jsonBody", " jsonOb", "customObject", "jsonObj", "javaObject", "javaBody", "jsonOb", "JSONOb", "httpOperation", "jsonArray", "customOperation", "JSONBody"], "OPCode": ["OPERcode", "OpName", " OPAction", "OpAction", " OPcode", " OPName", "opCode", "Opcode", "opName", "OPERCode", "opcode", "OPcode", "OpCode", "OPERName", "OPName", "opAction", "OPAction"], "retSrc": ["retNsrc", "retNrc", "RetAsrc", "retInRC", "retSsrc", "RetSrc", "retAsRC", "retSvc", "retNvc", "RetSuc", "retPRC", "RetAsuc", "retOsRC", "retNRC", "retOssrc", "retDRC", "retOsrc", "retInck", "retSRC", "retSck", "retPsrc", "retSuc", "retPrc", " retDrc", " retSvc", "RetSck", "retSrt", "retAsck", "retPvc", "RetAsck", "RetAsRC", "retNrt", " retDrt", " retDRC", "RetSRC", "retAsrc", "retInuc", " retSrt", "retDrt", "retInrc", "retDrc", "retAsuc", " retSRC", " retSsrc", " retDsrc", "retDsrc", "retDck", "retDuc", "retOsrt"], "httpClient": ["HttpCase", "xmlClient", "apiClient", " httpConnection", " httpCase", "httpsCall", "httpConnection", "xmlCase", "apiclient", "xmlConnection", " httpProxy", "phpclient", "httpProxy", "apiPost", "httpsPost", "phpCall", "httpsClient", "phpPost", "httpCall", "HttpClient", "HttpConnection", "httpclient", "httpsclient", "httpCase", "HttpProxy", "xmlProxy", "apiCall", "phpClient"], "httpPost": ["httpPOST", "htmlDo", "HttpRequest", "phpDo", " httppost", "webpost", "workpost", "HttpPost", "workPre", "workPost", " httpDo", "phpPOST", "HttpPOST", "webPost", "httpPre", "httpDo", "HttpCopy", "autoPost", "workDo", "httpsCopy", " httpCopy", "htmlPost", " httpPre", "httpRequest", " httpRequest", "HttpPre", "httpsPost", "HttpDo", "webPre", "httpsPOST", "httpCopy", "autoCopy", "autoPre", "phpPost", "htmlPOST", " httpPOST", "httpsPre", "httppost", "webDo", "autoPOST", "phpRequest", "htmlCopy"], "httpParams": ["httpVariars", "hrPars", "hrPams", "httpVariam", "hrPms", "httpCatars", "httpPerams", "hrParms", " httpParam", "httpPums", "httpPerums", " httpPars", "httpPam", "httpCatam", "hrParams", "httpVariums", " httpPam", "httpPars", "httpPerars", "hrParam", "httpPeram", "httpParms", "httpParums", "httpPms", " httpParums", "hrParars", "httpArgams", "httpParars", " httpPums", "hrPam", "httpCatams", " httpParars", "httpPams", "httpVariams", "httpParam", "httpArgars", " httpPams", "httpCatms", "httpArgms", "httpArgam"], "nameValuePair": ["nameValueParait", "nameValueFortion", "nameValuePore", "nameValuePiece", "nameValueProtenter", "nameNamePiece", "nameValueppair", "nameValuePerair", "nameNamePortion", "nameValuePpair", "nameNamepair", "nameValuePhiece", "nameValueCair", "nameValueProtore", "nameValuePointair", "nameVCpair", "nameValuePait", "nameNameLair", "nameValuePointenter", "nameValuePerolder", "nameValuePenter", "nameVPair", "nameNameProtore", "nameValuePointore", "nameValueCait", "nameNamePenter", "nameNameProtenter", "nameValuePhair", "nameValuePortion", "nameValueLolder", "nameValuePatch", "nameValuePointpair", "nameValueportion", "nameVPait", "nameValuepait", "nameValueParair", "nameValueSenter", "nameNameProtair", "nameValueLatch", "nameValuePeratch", "nameValuePolder", "nameNamePpair", "nameValueLair", "nameValuepair", "nameNameProtpair", "nameValueFair", "nameNamePair", "nameValueProtair", "nameValuepiece", "nameValueFiece", "nameNamePatch", "nameValueSair", "nameNameportion", "nameValueCpair", "nameNameLatch", "nameValuepolder", "nameValuePhortion", "nameValueProtpair", "nameNamePore", "nameVCair", "nameValueSore", "nameValueSpair", "nameNameLolder", "nameNamePolder", "nameVCait", "nameValueParpair", "nameValuepatch", "nameVPpair", "nameNamepiece"], "response": ["i", "server", "resource", "output", "jet", "feed", "http", "res", "site", "json", "message", "result", "throw", "session", "resp", "connection", "application", "wave", "data", "channel", "body", "entity", "page", "request", "object", "environment", "reply", "e", "tree", "status", "success", "full", "Response", " Response", "respond", "v", "block", "f", "method", "api", "view"]}}
{"id1": "20623709", "id2": "6840241", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 1, "substitutes": {"split": ["execute", "cmp", "copy", "add", "join", "run", "set", "match", "sort", "sync", "part", "diff", "build", "open", "share", "archive", "append", "delete", "format", "init", "start", "exec", "update", "parse", "Split", "process", "transfer"], "targetDirectory": ["baseFolder", "targetFolder", " targetFolder", "TargetDirectory", "destDirectory", "outputFolder", "masterPath", "basePath", "currentFolder", "TargetPath", "TargetFolder", "masterDir", " targetDir", "currentPath", "currentRoot", "TargetDir", "targetDatabase", "destFolder", "currentDirectory", "targetDir", "baseFile", "baseDirectory", "targetPath", "destFile", " targetRoot", "destDir", "masterDirectory", "TargetRoot", "currentDir", "TargetFile", " targetFile", "targetRoot", "baseDatabase", "baseDir", "outputDirectory", "masterDatabase", "outputDir", "outputFile", "TargetDatabase", " targetPath", "targetFile"], "prefix": ["directory", "index", "path", "string", "base", "root", "temp", "uri", "resource", "username", "timeout", "pre", "sequence", "filename", "fix", "number", "fp", "patch", "prot", "domain", "pattern", "queue", "offset", "txt", "type", "cache", "config", "fixed", "append", "format", "name", "folder", "template", "FIX", " suffix", "resolution", "unit", "Pref", "padding", "first", "ix"], "maxUnitBases": ["maxUnitPlaches", "maxUnitQueases", "maxUnitPlases", "maxunitBaches", "maxunitBases", "maxunitAliails", "maxUnitAliasing", "maxUnitBues", "maxUnitAliase", "maxUnitEaches", "maxUnitBase", "maxUnitBails", "maxUnitAliases", "maxunitBase", "maxUnitAliails", "maxunitBasing", "maxUnitPlails", "maxUnitAliues", "maxunitAliases", "maxUnitQuease", "maxunitAliaches", "maxUnitEases", "maxunitAliase", "maxUnitEails", "maxUnitBasing", "maxUnitEase", "maxunitBues", "maxunitAliues", "maxUnitChasing", "maxunitBails", "maxUnitChase", "maxUnitBaches", "maxunitAliasing", "maxUnitPlase", "maxUnitChases", "maxUnitAliaches", "maxUnitQueasing", "maxUnitChues", "maxUnitQueues"], "maxUnitEntries": ["maxUnitOrdresses", "maxUnitEntryrys", "maxUnitEntryries", "maxUnitErines", "maxUnitErry", "maxUnitCountines", "maxUnitEnties", "maxUnitOrdies", "maxUnitCountries", "maxUnitEntry", "maxUnitAddures", "maxUnitErrations", "maxunitEntries", "maxunitEntrys", "maxLineEntry", "maxLineEntries", "maxUnitAddresses", "maxLineOrdry", "maxUnitIntries", "maxunitEntryresses", "maxUnitOrdines", "maxUnitEntrations", "maxUnitCountry", "maxunitEnties", "maxUnitOrdrations", "maxUnitEntures", "maxUnitCountrations", "maxUnitAddry", "maxUnitIntrys", "maxUnitOrdries", "maxUnitInties", "maxLineEntines", "maxUnitEntrys", "maxunitEntryies", "maxLineEntrations", "maxLineOrdines", "maxunitEntryries", "maxUnitEntines", "maxUnitAddries", "maxUnitErries", "maxLineOrdries", "maxUnitEntryies", "maxunitEntresses", "maxUnitOrdrys", "maxUnitOrdry", "maxUnitIntresses", "maxunitEntryrys", "maxLineOrdrations", "maxUnitEntresses", "maxUnitEntryry", "maxUnitEntryresses", "maxUnitEntryures"], "fis": [" fai", "Fris", " fris", "vai", "forai", "foris", " fiss", "fai", "fris", "forisc", "visa", "fisc", " fIs", "forisa", "forIs", "Fisc", "vIs", " fisc", "fisa", "vis", "Fis", " fisa", "foriss", "fIs", "fiss", "Fiss", "forris"], "fci": [" fai", "bis", "dii", "vcos", "hai", "hco", "efco", "vai", "bco", "dci", "fai", "hci", "Fci", "doci", "Foci", "Fai", "foci", "efci", "Fis", "fcos", "Fii", "efcos", "vco", "dco", "bai", "Fco", " fii", "vci", "efai", "hcos", " foci", "fii", "bci"], "fos": ["tis", "fsos", "fsios", "infis", "infos", "infoes", "fscos", "Foes", "ifios", "foss", " fcos", "Foss", "ifos", "tos", "Fis", "Fos", "toss", "fcos", "fios", "fo", "infoss", " fo", "toes", " fios", "foes", "ifcos", "fso", "ifo"], "fco": ["Fico", " fico", "hco", " fgo", "fro", "dci", "hci", "lco", "fgo", "Fci", "dro", "hgo", "fileico", " fro", "Fbo", " fcos", "lcos", "fico", "fcos", "dcos", " fbo", "fileci", "dco", "Fco", "hcos", "filebo", "fileco", "fbo", "lro", "lgo", "lci"], "buffer": ["info", "base", "border", "Buffer", "server", "resource", "uffer", "copy", "response", "pause", "loader", "entry", "timeout", "feed", "message", "document", "result", "window", "length", "capacity", "memory", "bin", "read", "queue", "offset", "iter", "bar", "rate", "expression", "reader", "cache", "binary", "translation", "source", "buff", "buf", "counter", "data", "channel", "input", "request", "size", "context", "device", "texture", "null", "header", "writer", "image", "layer", "position", "bc", "flush", "comment", "reference", "pad", "block", "transfer", "batch", "zero", "scale", "callback", "view"], "currentBasesCount": ["currentBatchesCounter", "currentBatchesNum", "currentChaseCounter", "currentBasescount", "currentBasesNum", "currentBasesCounter", "currentBasingCounter", "currentChaseCount", "currentBaseNum", "currentChasesCounter", "currentChaseNum", "currentBatchescount", "currentBasecount", "currentBasingCount", "currentChasecount", "currentChasesNum", "currentBasingcount", "currentChasescount", "currentBatchesCount", "currentBaseCount", "currentChasesCount", "currentBasingNum", "currentBaseCounter"], "currentEntriesCount": ["currentAddriesOffset", "currentEnturesSize", "currentEnturesOffset", "currentEntriesOffset", "currentEntursOffset", "currentAdduresLimit", "currentEntrasLimit", "currentEnturesCount", "currentEntrasOffset", "currentEnturesLimit", "currentAddriesSize", "currentAddriesLimit", "currentEntursLimit", "currentEntrasSize", "currentEntursSize", "currentEntriesLimit", "currentEntrasCount", "currentAdduresOffset", "currentAddriesCount", "currentAdduresCount", "currentEntursCount", "currentEntriesSize", "currentAdduresSize"], "targetCount": ["patternSum", "TargetCount", "patterncount", "targetcount", "targetSize", "argetcount", "argetCount", "patternCount", "Targetcount", "targetSum", "patternSize", "TargetSum", "argetSum", "TargetSize", "argetSize"], "fastaChannel": [" fastAContainer", " fastaColumn", "fastAContext", "fastABuffer", " fastAChannel", "fastaqColumn", " fastABuffer", "fastaContainer", "fastAConnection", "fastasBuffer", "fastaqBuffer", " fastAConnection", "fastaConnection", " fastaConnection", "fastanContext", " fastAContext", "fastaqChannel", "fastasChannel", " fastAColumn", "fastanBuffer", "fastanContainer", " fastaContext", "fastasConnection", "fastanChannel", "fastaContext", "fastAColumn", "fastAContainer", "fastaColumn", "fastAChannel", "fastasContainer", "fastaqConnection", "fastasContext", " fastaContainer", "fastasColumn"], "totalSeqCount": ["totalQueQCounter", "totalSeQNum", "totalSeQcount", "totalSeqsCounter", "totalSeqCounter", "totalSeqscount", "totalSeuxNum", "totalSeuxCount", "totalSeqsNum", "totalQueqcount", "totalQueqCounter", "totalSeQCounter", "totalSeuxcount", "totalQueqCount", "totalSeqsCount", "totalSeQCount", "totalQueQNum", "totalSeqcount", "totalQueQcount", "totalSeqNum", "totalSeuxCounter", "totalQueQCount", "totalQueqNum"], "totalResiduesCount": ["totalResqueuresNum", "totalResiduingNum", "totalResqueuresSize", "totalResqueurescount", "totalResiduresNum", "totalResqueuesCount", "totalResiduingcount", "totalResiduingSize", "totalResiduationCount", "totalResiduescount", "totalResqueuescount", "totalResqueuesNum", "totalResqueuresCount", "totalResidurescount", "totalResiduresSize", "totalResiduingCount", "totalResiduresCount", "totalResiduesSize", "totalResqueuesSize", "totalResiduationcount", "totalResiduationSize", "totalResiduesNum", "totalResiduationNum"], "prevTime": ["prevFile", " prevSize", "PrevSize", "commitFile", " prevValue", "PrevTime", "PrevFile", "commitTime", "prevSize", " prevFile", "prevValue", "commitValue", "commitSize", "PrevValue"], "fastaFileSize": ["fastaFilesSize", "fastaHeaderLength", "fastaHeaderName", "fastasFileName", "fastaHeaderAddress", "fastABufferCount", "fastaFilesName", "fastaBlockSize", "fastaBufferLength", "fastaBufferSize", "fastaLineCount", "fastaPageName", "fastAFileLength", "fastaPageAddress", "fastaLineSize", "fastAFileAddress", "fastasFileLength", "fastasFileAddress", "fastABufferLength", "fastAFileSize", "fastaPageLength", "fastaPageSize", "fastaBlockCount", "fastABufferAddress", "fastasHeaderName", "fastaFileAddress", "fastaFilesAddress", "fastaHeaderSize", "fastAFileCount", "fastasFileSize", "fastasHeaderAddress", "fastasHeaderLength", "fastaFileName", "fastaFileCount", "fastaLineAddress", "fastaBufferCount", "fastaFilesLength", "fastABufferSize", "fastaBlockAddress", "fastaFileLength", "fastaBufferAddress", "fastaBlockLength", "fastasHeaderSize", "fastaLineLength"], "fastaFileReadOffset": ["fastaFileLoadAmount", "fastaFileStartEntry", "fastaFileWriteOffset", "fastaFilereadOff", "fastaDirectoryWriteEntry", "fastaBufferWriteAmount", "fastaFilesWriteOffset", "fastaFileLengthoffset", "fastaFileWriteEntry", "fastaDirectoryWriteOffset", "fastaFileLoadOffset", "fastaFileLoadoffset", "fastaFileReadEntry", "fastaBufferReadAmount", "fastaDirectoryWriteOff", "fastaFileLengthOff", "fastaFileWriteoffset", "fastaFileLengthLength", "fastaBufferReadoffset", "fastaBufferWriteoffset", "fastaFilesReadoffset", "fastaFileWriteLength", "fastaDirectoryReadEntry", "fastaBufferReadLength", "fastaFilesReadLength", "fastaFileRunOffset", "fastaFilesWriteoffset", "fastaFileReadAmount", "fastaFileStartoffset", "fastaFileRunEntry", "fastaFileReadOff", "fastaFilereadOffset", "fastaFileWriteAmount", "fastaFileRunOff", "fastaDirectoryReadOff", "fastaFilesWriteLength", "fastaFileReadoffset", "fastaFileLengthAmount", "fastaFileStartOff", "fastaFilesWriteOff", "fastaDirectoryReadOffset", "fastaFilereadLength", "fastaFileRunoffset", "fastaFileWriteOff", "fastaBufferWriteOffset", "fastaFilesReadOffset", "fastaFileReadLength", "fastaFileLoadLength", "fastaFileStartOffset", "fastaFileLengthOffset", "fastaBufferReadOffset", "fastaFilesReadOff", "fastaFilereadoffset", "fastaBufferWriteLength", "fastaDirectoryReadoffset", "fastaDirectoryWriteoffset"], "partitionStartOffset": ["partitionBufferOffset", "partitionStartOff", "partitionsEndOrder", "partitionBufferRange", "partitionEndOff", "partitionsStartOrder", "partitionBufferOrder", "partitionStopRange", "partitionBufferOff", "partitionsEndOffset", "partitionStopOffset", "partitionsStartOff", "partitionStartRange", "partitionsStartOffset", "partitionStartOrder", "partitionsEndOff", "partitionsEndRange", "partitionsStartRange", "partitionEndRange", "partitionStopOrder", "partitionEndOrder", "partitionStopOff"], "bufferSize": ["bufferType", "BufferType", "processC", "bufferC", "bufferSIZE", "BufferSize", "queueSize", "queueCount", " bufferType", " bufferC", "BufferCount", "BufferSIZE", "processType", "BufferC", "bufferCount", "processSIZE", " bufferSIZE", " bufferCount", "processSize"], "fastaBuffer": [" fastABuff", " fastasChannel", "fastaPtr", "fastaBuff", " fastAQueue", "fastanBuff", "fastaStream", "FastasChannel", "fastABuffer", " fastAChannel", "fastasBuff", "fastaContainer", " fastABuffer", "fastasQueue", "fastaceChannel", "fastanFile", " fastaBuff", "fastAQueue", "fastasBuffer", "FastaBuffer", "fastaaPtr", "fastasStream", "FastaPtr", "FastasBuff", "fastaaBuff", "fastanQueue", "fastasChannel", " fastaFile", "fastanStream", "fastasFile", "fastanBuffer", "fastanContainer", "FastasPtr", " fastasFile", "fastAPtr", "FastasStream", "fastaceBuffer", "fastanChannel", "FastaStream", " fastasContainer", "fastanPtr", "fastaaBuffer", "FastasBuffer", "fastasPtr", "fastaaStream", "fastAContainer", "fastAFile", " fastAFile", "FastaChannel", "fastaFile", " fastasBuffer", "fastABuff", "fastAChannel", "fastasContainer", "FastaBuff", "fastacePtr", " fastaContainer", "fastaQueue", " fastaQueue", "fastaceBuff"], "fastaReadState": ["fastasReadState", "fastasReaderMode", "fastasReaderType", "fastaReadingMode", "fastaReaderstate", "fastaReadType", "fastaReaderMode", "fastasReadstate", "fastaFilestate", "fastaReadingState", "fastaReaderType", "fastaReaderState", "fastaReadMode", "fastaReadstate", "fastaFileState", "fastasReaderState", "fastasReadType", "fastasReaderstate", "fastaReadingstate", "fastaFileType", "fastaFileMode", "fastasReadMode", "fastaReadingType"], "nBytes": ["nFrames", "nByte", "pbytes", " nParts", "nParts", "lenFrames", "numFrames", "NBytes", "nbytes", "oFiles", " nByte", "NByte", "lenbytes", "NParts", "oParts", " nFiles", "Nbytes", " nbytes", "numFiles", "pByte", "numBytes", "pParts", "numbytes", "pBytes", "nFiles", "lenBytes", "lenFiles", "oBytes", "obytes", " nFrames", "NFiles"]}}
{"id1": "21555906", "id2": "20685385", "code1": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private Long getNextPkValueForEntityIncreaseBy(String entityName, int count, int increasePkBy) {\n        if (increasePkBy < 1) increasePkBy = 1;\n        String where = \"where eoentity_name = '\" + entityName + \"'\";\n        if (false) {\n            EOEditingContext ec = ERXEC.newEditingContext();\n            ec.lock();\n            try {\n                EODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n                dbc.lock();\n                try {\n                    EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n                    EOAdaptorChannel channel = (EOAdaptorChannel) dbc.adaptorContext().channels().lastObject();\n                    NSArray result = channel.primaryKeysForNewRowsWithEntity(increasePkBy, entity);\n                    return (Long) ((NSDictionary) result.lastObject()).allValues().lastObject();\n                } finally {\n                    dbc.unlock();\n                }\n            } finally {\n                ec.unlock();\n            }\n        } else {\n            ERXJDBCConnectionBroker broker = ERXJDBCConnectionBroker.connectionBrokerForEntityNamed(entityName);\n            Connection con = broker.getConnection();\n            try {\n                try {\n                    con.setAutoCommit(false);\n                    con.setReadOnly(false);\n                } catch (SQLException e) {\n                    log.error(e, e);\n                }\n                for (int tries = 0; tries < count; tries++) {\n                    try {\n                        ResultSet resultSet = con.createStatement().executeQuery(\"select pk_value from pk_table \" + where);\n                        con.commit();\n                        boolean hasNext = resultSet.next();\n                        long pk = 1;\n                        if (hasNext) {\n                            pk = resultSet.getLong(\"pk_value\");\n                            con.createStatement().executeUpdate(\"update pk_table set pk_value = \" + (pk + increasePkBy) + \" \" + where);\n                        } else {\n                            pk = maxIdFromTable(entityName);\n                            con.createStatement().executeUpdate(\"insert into pk_table (eoentity_name, pk_value) values ('\" + entityName + \"', \" + (pk + increasePkBy) + \")\");\n                        }\n                        con.commit();\n                        return new Long(pk);\n                    } catch (SQLException ex) {\n                        String s = ex.getMessage().toLowerCase();\n                        boolean creationError = (s.indexOf(\"error code 116\") != -1);\n                        creationError |= (s.indexOf(\"pk_table\") != -1 && s.indexOf(\"does not exist\") != -1);\n                        creationError |= s.indexOf(\"ora-00942\") != -1;\n                        if (creationError) {\n                            try {\n                                con.rollback();\n                                log.info(\"creating pk table\");\n                                con.createStatement().executeUpdate(\"create table pk_table (eoentity_name varchar(100) not null, pk_value integer)\");\n                                con.createStatement().executeUpdate(\"alter table pk_table add primary key (eoentity_name)\");\n                                con.commit();\n                            } catch (SQLException ee) {\n                                throw new NSForwardException(ee, \"could not create pk table\");\n                            }\n                        } else {\n                            throw new NSForwardException(ex, \"Error fetching PK\");\n                        }\n                    }\n                }\n            } finally {\n                broker.freeConnection(con);\n            }\n        }\n        throw new IllegalStateException(\"Couldn't get PK\");\n    }\n", "label": 0, "substitutes": {"actionPerformed": ["actionConceived", "actionExecuted", "actionExecceived", "actionConformed", "actionOccuted", "actionOccformed", "actionConressed", "actionPeruted", "actionExecformed", "actionExecressed", "eventExecceived", "eventPerressed", "actionPerceived", "actionOccceived", "actionConuted", "eventExecressed", "eventExecuted", "actionOccressed", "eventExecformed", "eventPeruted", "eventPerceived", "eventPerformed", "actionPerressed"], "ae": ["event", "Events", "fe", "ace", "fa", "ee", "sem", "c", " ec", "ade", " inst", " pe", "dc", " ace", " te", "ec", " fa", "cm", "gae", " ge", "ce", " event", "je", " ce", "au", "ea", " events", "ca", "de", "exc", " je", "x", "es", "ai", "E", "e", "change", "t", " ev", " a", " error", "a", "bc", "ava", "AE", "pe", "ga", "Event", "oe"], "toservlet": ["topserverlets", "toserverlets", "toservelete", "toseservlete", "tosServlete", "toseserveet", "toseservelete", "tosServlet", "tosvurl", "toservlete", "toserverlet", "toservler", "tosservlets", "topservle", "tosvet", "topservlet", "topserverler", "topservler", "topserverlet", "toserveet", "toseservelet", "tosServurl", "tosvlet", "tosourcelet", "toseserveurl", "toservle", "toservelet", "toseservurl", "toservlets", "tosourcele", "tosservler", "toserverle", "toservet", "tosourceler", "toseservlet", "tosservle", "topserverle", "tosourcelets", "tosvlete", "toserverler", "topservlets", "toseservet", "tosservlet", "toserveurl", "tosServet", "toservurl"], "servleturl": [" servleurl", "servletsurl", "servletfile", "servleurl", "servletturl", "servleturi", "ervletsserver", "servlettserver", "ervletsuri", "servletsserver", "servjecturl", "servleconnection", "servletturi", "ervletconnection", "servlconnection", "servlettconnection", "servjectconnection", "ervletsconnection", "servlefile", " servleserver", "ervletsurl", "servletsuri", "servjectserver", "ervleturi", " servlefile", " servletserver", "servletserver", "servjectfile", " servletfile", "ervletserver", "servluri", "servlserver", " servleconnection", "servlurl", "ervleturl", "servleserver", "servletsfile", "servletsconnection"], "servletconnection": ["ervletsconn", "servletscommunication", "servletscon", "servlettconn", "servletsconn", "serverletconnect", "servlettConnection", "servbleurl", "servlessconnection", "servletsurl", " servetconn", "servleconn", "serverletsConnection", "servserverurl", "servletpassword", "servletconn", "servleConnection", "servserverconn", "servlexconnection", "serverletsconnection", "servleconnect", " servetconnection", "servlesspassword", "servleconnection", "servletspassword", "servletsconnect", "serverletConnection", "ervletconnection", " servetconnect", "servletConnection", " servletconnect", "servetConnection", "servlexpassword", "servlexcommunication", "ervletsconnection", "servblecon", " servletconn", "serverletsconnect", " servletConnection", "servletsConnection", " servleConnection", "ervletsurl", "serverletconnection", "serverletsconn", "servlexconn", "serverletcommunication", "serverletconn", "servserverconnection", "servlettconnect", " servleconn", "ervletscon", "servetconn", "servlessconn", "servlesscommunication", "servletcommunication", " servleconnect", "servetconnection", "serverletscommunication", "serverletpassword", "servletcon", "servletconnect", " servleconnection", "servbleconn", "servservercon", "ervletcon", "servbleconnection", "servetconnect", "ervleturl", "servletsconnection", "servlettconnection", "serverletspassword", " servetConnection", "ervletconn"], "inputFromClient": ["InputFromConnection", "inputFromclient", "outputfromURL", "inputFromURL", "inputFormClient", "requestFromClient", "InputFromStream", "InputFormClient", "inputfromServer", "inputOrServer", "outputFromURL", "inputViaURL", "inputFormConnection", "inputOrCL", "inputFromRemote", "requestFromServer", "inputFromConnection", "outputfromClient", "inputViaCL", "outputfromCL", "requestFromclient", "inputfromConnection", "inputToRemote", "inputOrURL", "inputViaClient", "InputFromclient", "InputFormStream", "InputFromClient", "inputfromclient", "inputToServer", "inputToClient", "inputfromClient", "inputToclient", "inputfromURL", "inputfromStream", "inputOrClient", "inputFromStream", "inputFormStream", "inputFromServer", "outputfromServer", "outputFromServer", "inputFormclient", "requestFromConnection", "InputFormConnection", "inputfromCL", "inputFromCL", "InputFormclient", "inputViaServer", "inputToConnection", "outputFromClient", "outputFromCL", "requestFromRemote"], "fos": [" faos", " foos", "affbos", "affoos", " fbos", "foos", "ifoses", " foses", "affis", "ifaos", "Foos", "ifols", "affos", "ifos", "foses", " fols", "Fos", "Fis", "Fols", " fis", "Foses", "Fbos", "faos", "fols", "Faos", "fbos", "fis"], "buf": ["buffer", "bf", "bd", "bh", "uint", "cap", "lb", "cb", "pool", "off", "bin", "ff", "feat", "queue", "uf", "la", "bag", "comb", "cv", "bu", "rb", "cas", "wb", "uc", "buff", "data", "tmp", "fb", "bb", "box", "vec", "font", "ha", "bytes", "bc", "Buff", "bp", "shape", "seq", "b", "br", "bound", "bl", "ba", "pad", "block", "batch", "loc"], "bytesread": ["Bytesread", "filesread", "rowsRead", "Byteswrite", "rowsrun", "filesrun", "rowsread", "bytesrun", "BytesRead", " bytesRead", "lineswrite", "tesload", "linesRead", "fileswrite", "rowswrite", "teswrite", "Bytesload", "linesrun", " bytesload", "linesread", "tesrun", "filesRead", "byteswrite", "tesread", "bytesRead", "bytesload", " bytesrun", " byteswrite", "linesload"]}}
{"id1": "9275622", "id2": "6966398", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFolder", "moveFile", " copyfile", "moveFolder", "copyfile", "transferfile", "moveFiles", "copyFolder", " copyFiles", " copyFolder", "transferFiles", "movefile", "copyFiles", "transferFile"], "_file1": ["_f1", "_mail2", "_resource1", "_mail1", "_fileone", "_zip1", "_mail0", "_resourceFirst", "_zipFirst", "_fFirst", "_file0", "_fOne", "_files2", "_files1", "_File0", "_resourceone", "_files01", "_fileFirst", "_zipOne", "_mail01", "_zipone", "_fone", "_File1", "_files0", "_File2", "_File01", "_file01", "_fileOne", "_resourceOne"], "_file2": [" _files3", "_playsecond", " _files2", " _filesTwo", "_filesecond", "_playTwo", " _files4", "jmodel2", "_model5", " _fileTwo", "_files3", "jmodelsecond", "_files2", "_play1", "jmodel1", "jmodel5", "_Filesecond", "_modelsecond", " _file4", "_files4", "jfilesecond", "jfile1", "_model1", "jfile2", "_filesTwo", "_file5", "_play2", "_model2", "_play4", "_file4", "_File2", "_File1", "_file3", "_fileTwo", "jfile5", "_play5", " _file3", "_File5", "_play3"], "fis": ["Fris", "fais", " fais", " fris", "cfas", "cfis", "fi", " fiss", "fris", "Fils", "lfis", "infis", "infiss", "lfiss", "infos", "lfi", "afis", "afais", "cfos", "lfais", " fi", "Fis", "Fos", "Fas", "afi", "infils", " fas", "fas", "cfiss", "cfris", " fils", "fiss", "afiss", "Fiss", "fils"], "fos": ["gis", " faos", "pOS", "info", " fros", " foos", "lis", "flos", "poes", "infaos", "fros", "infoos", "infus", "feis", "Fus", "foos", "loes", "floes", "feus", "fus", "infos", "infros", " fus", "infios", "pis", "Foos", "gos", "flis", "goses", "foses", "Fis", "Fos", "Fros", "fios", "fo", "pos", "gus", "flOS", "feoses", "lOS", "Fo", "Foses", " fo", "Fios", "los", "feos", "faos", " fios", "foes", "Faos", "fOS"], "canalFuente": ["canalKuence", "canalBuje", "canalBuence", "canalFuje", "canalsFuento", "canalsBuence", "canalsFuente", "canalBuestro", "canalKuencia", "canallBuze", "canalFUje", "canallFuencia", "canalSuente", "canalFUencia", "canaledFuestro", "canallBuence", "canalBuze", "canalsBuencia", "canalFuze", "canalsBuento", "canalFUente", "canalKuento", "canallBuencia", "canalsBuente", "canaledFuze", "canalSuze", "canalCraente", "canalFuestro", "canalFUze", "canalKuze", "canalsFuence", "canalFUestro", "canaledFuje", "canalKuente", "canalBuente", "canaledBuestro", "canalFuence", "canalSuestro", "canaledFuente", "canallFuente", "canaledBuente", "canallBuente", "canalFuento", "canalsFuencia", "canalCraencia", "canaledBuze", "canallFuence", "canalBuencia", "canalCraento", "canalFuencia", "canalBuento", "canalFUence", "canaledBuje", "canallFuze", "canalSuje", "canalCraence"]}}
{"id1": "1357662", "id2": "9109613", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copyChannelTO", "copyFilesTO", " copyFileFrom", "copyfileFrom", "copyChannelFile", " copyfileFile", "copyfileTO", "copyFileTO", "copyFilesFile", "copyFileFile", " copyfileFrom", " copyFileFile", " copyFileTO", "copyFileFrom", "copyFilesFrom", " copyfileTO", "copyFilesTo", "copyfileTo", "copyChannelFrom", "copyfileFile", "copyChannelTo", " copyfileTo"], "destination": ["distination", "separinator", "configinations", " Destribution", " destribution", "separination", "configination", "Destined", " destinations", "sourceination", "distined", "separinated", " destinate", "configinated", "targetinations", " destruction", "sourceinator", "destinated", "configinator", "distruction", " destinator", "Destribution", "Destination", "distinator", "distinations", " destined", "destined", "Destinator", "targetruction", "destribution", "destinate", "destinator", "separinations", "destruction", "sourceinated", "sourceinations", "targetination", " Destinator", "Destinations", "destinations", "distinate", "targetinate", " Destination"], "srcChannel": ["sourceContext", "srcConnection", "rcchannel", "srcchannel", "sourcechannel", "sourceChannel", "destChan", " srcConnection", " srcContext", "sourceChan", "sourceConnection", "destchannel", " srcchannel", "srcContext", "rcChan", " srcChan", "rcChannel", "srcChan", "destConnection", "rcContext", "rcConnection"], "destChannel": ["srcConnection", "descButton", "srcchannel", "Destchannel", "sourcechannel", "DestConnection", "sourceChannel", "destChan", " destConnection", "descChannel", "descchannel", "DestChannel", "restchannel", "sourceChan", "sourceConnection", "destchannel", "restChannel", "restChan", " destChan", " destButton", " destchannel", "destButton", "destConnection", "srcChan", "DestChan", "srcButton"]}}
{"id1": "13657103", "id2": "4389475", "code1": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "code2": "    @Override\n    public URLConnection openConnection(URL url) throws IOException {\n        if (!url.getProtocol().equals(\"file\")) {\n            String name = url.getFile();\n            File f = new File(cacheFolder, ((name.charAt(0) == '/') ? name.substring(1) : name).replace('/', File.separatorChar));\n            if (!f.exists()) {\n                File f2 = new File(f.getParentFile(), f.getName() + \"-not_found\");\n                if (!f2.exists()) {\n                    try {\n                        f.getParentFile().mkdirs();\n                        downloadFile(url, f);\n                    } catch (IOException e) {\n                        f.delete();\n                        throw e;\n                    }\n                }\n            }\n            return f.toURI().toURL().openConnection();\n        }\n        return super.openConnection(url);\n    }\n", "label": 0, "substitutes": {"forBundle": ["forFixture", "getBale", "getBixture", "forBale", "getFale", "forLixture", "getBuddy", "getFixture", "forMuddy", "forBixture", "forLundle", "forMundle", "forFundle", "forMixture", "forBuddy", "forMale", "getFuddy", "forFuddy", "forFale", "forLuddy", "getBundle", "forLale", "getFundle"], "manip": [" manIP", "dami", "damip", "emanIP", "manic", "Manipp", "emani", "ManIP", "Manip", "Manic", " mani", "damIP", "emanim", "multip", "managerip", "manageri", "manIP", "manim", "damim", "manipp", "manageric", "mani", " manipp", "emanip", "multIP", "Mani", "emanipp", "managerIP", "multic", "multi", "Manim"], "bout": ["bOut", "baseash", "bbout", " bin", "bin", "basedump", " bouts", "ferr", "nout", "Bin", "bbOUT", "bdump", "sbagain", "Bout", "berr", "Bash", "sbin", "sberr", " bOUT", "fOUT", "bouts", "Berr", "bOUT", "BOUT", "sbouts", "bash", "Bouts", "ndump", "fagain", "baseOut", "bbouts", "zin", "zouts", "nOut", "BOut", "baseout", "nash", "zOUT", "fout", "sbOUT", "sbout", "bbin", "Bagain", "Bdump", "bagain"], "zout": ["zipcontainer", "zipOut", "azOUT", "zipout", "zhOut", "ZOut", " zagain", "ezraw", "zOut", "zenin", "zhstore", "zyout", "wio", "zipio", "ezquery", "zhraw", "ezout", "zyin", " zconn", "azerr", "zagain", "zraw", " zOUT", "zconn", "zstore", "azconn", "zencontainer", "zenagain", "zipin", "azouts", "azOut", "win", "wout", "azin", "zipraw", " zbox", "Zin", "zcontainer", " zerr", "ezOUT", "zenout", "ezOut", "zipbox", " zcontainer", "zipstore", "zquery", " zOut", "zipquery", "Zio", "zipagain", "zin", " zouts", "zbox", "zouts", "zerr", "zystore", "zio", "zOUT", "ezouts", "azstore", " zstore", "zhout", "ezconn", "zherr", "Zout", "azout", "azbox", "wOut", "zyOut", " zin", "zhquery"], "bundle": ["lorer", "bunch", "sbiler", "fuddy", " borer", "nuni", "liler", "eixture", "abundle", "fund", "foodle", "fixture", "nunch", "nundle", "fundle", " bund", "abider", "sborer", "euni", "sbuddy", "buration", "biler", "funi", "sbundle", " biler", "boodle", "aboodle", "bixture", "bider", "abuddy", " buddy", "bulp", "funch", " boodle", " bider", "eundle", "abund", "fider", "aburation", "furation", "lundle", "luddy", "abulp", "nixture", " buration", "buddy", " bulp", "eunch", "bund", "fulp", "borer", "buni"], "files": ["keys", "feed", "fs", "leases", "pages", "http", "resources", "results", "features", "apps", "qs", "Files", "reports", "errors", "ids", "workers", "fl", "items", "links", "iles", "users", "lines", "bugs", "blocks", "boxes", "children", "flows", "members", "names", "file", "classes", "data", "images", "objects", "models", "plugins", "ips", "issues", "groups", "web", "ls", "obs", "thumbnails", "fires", "books", "bytes", "fields", "rules", "xml", "events", "f", "download"], "url": ["string", "path", "address", "job", "id", "uri", "resource", "feed", "server", "user", "entry", "http", "filename", "rel", "html", "l", "location", "host", "URL", "el", "fr", "pattern", "fl", "source", "dir", "not", "browser", "ob", "config", "data", "file", "out", "channel", "page", "web", "ball", "coll", "image", "link", "sl", "Url", "layer", "pull", "b", "f", "element", "download", "loc"], "name": ["string", "path", "base", "info", "NAME", "address", "job", "id", "n", "resource", "uri", "filename", "end", "number", "child", "large", "ame", "api", "host", "el", "pass", "time", "key", "part", "type", "source", "no", "one", "up", "member", "connection", "old", "value", "common", "str", "default", "model", "alias", "parent", "data", "file", "names", "work", "object", "x", "size", "search", "Name", "e", "image", "action", "home", "label", "word", "full", "comment", "b", "block", "wheel", "error", "named", "definition", "orig"], "mf": ["smfs", "smdf", "lf", "fmc", "gfs", " mcf", "smfc", "Mc", "smf", "mcf", "fmtf", " mc", "Mtf", "gfc", "mdf", "fmf", "lfc", "gf", "Mcf", "Mf", "mc", "mtf", " mtf", "gdf", "mfc", "lfs", "fmcf", "ldf", "mfs"], "tmpFile": ["tempChannel", "poraryFile", " temporaryFiles", "tmpChannel", "tmpUrl", " temporaryFile", "tmpFunction", " tmpFiles", "poraryChannel", " tmpGlobal", " tmpDir", "tempEntry", "tempPath", "poraryUrl", "poraryFiles", "tempGlobal", "TempEntry", "TempFile", "TempPath", "tmpGlobal", "TempFiles", "TempChannel", "tempDir", " temporaryDir", " tmpFunction", "tmpEntry", "tmpFiles", "tmpDir", "poraryEntry", "TempUrl", "tempFile", "tempFiles", "poraryFunction", "TempFunction", "tmpPath", " temporaryGlobal", " tmpUrl", "poraryPath"], "ref": ["val", "fe", " binding", "id", " reference", "cmp", "bf", "lf", " nav", "rel", "loc", "instance", "col", "req", " comp", "comp", " cache", "Ref", "part", "type", "cache", "resp", " resp", "lib", "old", "aff", "ob", "config", " index", "Reference", "ef", " remote", "re", "eval", "ctx", "REF", "conf", "obj", "reference", "reg", "def", " req", "f", "service", " Ref"]}}
{"id1": "10385815", "id2": "9846843", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"copy": ["zip", "Copy", "replace", "cmp", "move", "write", "clone", "split", "sync", "upload", "open", "file", "Cop", "get", "put", "delete", "exec", "change", "send", "update", " Copy", "create", "Transfer", "paste", "process", "transfer", "download"], "fileFrom": ["FileStart", "ioFrom", "FileTo", "ioSource", "FileSource", "mailFrom", "FileIn", "ioTo", "fileIn", "FileAs", " fileStart", " fileAs", "fileStart", "mailAs", " fileSource", "mailIn", "ioStart", "mailTo", "fileSource", "fileAs", "FileFrom", " fileIn"], "fileTo": [" fileFile", "fpTo", "fileTO", "FileTo", "FileFile", "fpTO", "FileTO", " fileTarget", "resourceTo", "resourceFile", "fpto", "Fileto", "FileTarget", "fileFile", "resourceTarget", "fileTarget", "fpFrom", " fileTO", "fileto", "resourceFrom", " fileto", "FileFrom"], "inputStream": ["InputContext", " inputFile", "outputSteam", "InputSync", "inputSteam", "inputSync", "inputFile", " inputSync", " inputstream", "InputFile", "outputstream", " inputSteam", "InputChannel", "outputContext", " inputContext", "inputContext", "outputSync", "Inputstream", "outputFile", "inputstream", "InputSteam", "InputStream"], "outputStream": ["inputSocket", "OutputChannel", "outputSteam", "inputSteam", "fourStreamer", "outputSocket", "fourStream", "OutputStreamer", "outputPath", "inputChan", "referenceSteam", "inputPath", "OutputSteam", "referenceSocket", "outputStreamer", "OutputStream", " outputPath", " outputStreamer", "writeChannel", "referenceChannel", "fourChannel", " outputChan", "writeSteam", "writeSocket", "writeStream", "outputChan", "OutputChan", " outputSteam", "referenceStream", "OutputPath", "fourSteam"], "inputChannel": ["parentStream", "butChan", "InputContext", "audioChannel", "inputSocket", "inputPassword", " inputCam", "outputSocket", "butContext", " inputSocket", "InputSocket", "inputChan", "butCommand", "outputPassword", "audioCam", "outputCam", " inputPassword", " inputClient", "inputClient", "InputChannel", "inputCam", "audioClient", "inputCommand", "parentPassword", "parentChannel", "butChannel", "outputClient", " inputChan", "outputCommand", "outputContext", " inputContext", "parentChan", "outputChan", "inputContext", "audioStream", "InputChan", " inputCommand", "InputStream"], "outputChannel": ["Outputchannel", "inputchannel", " outputchannel", "OutputQueue", " outputQueue", "OutputChannel", "outContext", "OutputContext", "outputQueue", "inputChan", "outStream", "outChan", "OutputStream", " outputContext", "outputchannel", " outputChan", "outputContext", "inputContext", "outputChan", "OutputChan", "inputQueue", "outChannel"]}}
{"id1": "4973095", "id2": "2736184", "code1": "    public Wget2(URL url, File f) throws IOException {\n        System.out.println(\"bajando: \" + url);\n        if (f == null) {\n            by = new ByteArrayOutputStream();\n        } else {\n            by = new FileOutputStream(f);\n        }\n        URLConnection uc = url.openConnection();\n        if (uc instanceof HttpURLConnection) {\n            leerHttp((HttpURLConnection) uc);\n        } else {\n            throw new IOException(\"solo se pueden descargar url http\");\n        }\n    }\n", "code2": "    public static String getURLContent(String urlPath, String requestData, String charset) {\n        BufferedReader reader = null;\n        HttpURLConnection conn = null;\n        StringBuffer buffer = new StringBuffer();\n        OutputStreamWriter out = null;\n        try {\n            URL url = new URL(urlPath);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            conn.setDefaultUseCaches(false);\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(60000);\n            out = new OutputStreamWriter(conn.getOutputStream(), charset);\n            out.write(requestData);\n            out.flush();\n            int repCode = conn.getResponseCode();\n            if (repCode == 200) {\n                int count = 0;\n                char[] chBuffer = new char[1024];\n                BufferedReader input = new BufferedReader(new InputStreamReader(conn.getInputStream(), charset));\n                while ((count = input.read(chBuffer)) != -1) {\n                    buffer.append(chBuffer, 0, count);\n                }\n            }\n        } catch (Exception ex) {\n            logger.error(\"\", ex);\n        } finally {\n            try {\n                if (out != null) {\n                    out.close();\n                }\n                if (reader != null) {\n                    reader.close();\n                }\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            } catch (Exception ex) {\n            }\n        }\n        return buffer.toString();\n    }\n", "label": 0, "substitutes": {"url": ["string", "path", "base", "buffer", "address", "ssl", "rest", "server", "uri", "resource", "feed", "ado", "user", "http", "c", " web", "lr", "l", "host", "api", "URL", "all", "client", "source", "use", "lib", "connection", "not", "r", "str", "open", "config", "file", "web", "ll", "null", "u", "conn", "e", " URL", "image", "link", "bad", "sl", " http", "full", "Url", "www", "ur", "b", "xml", "gl", "service", "download", "loc"], "f": ["info", "buffer", "fat", "fe", "sf", "i", "fa", "fs", "rf", "bf", "df", "ref", "c", "filename", "fc", "fi", "fp", "l", "fn", "fr", "d", "aff", "g", "w", "fed", "file", "flat", "fb", "x", "p", "u", "fo", "e", "io", "t", "m", "F", "fd", "files", "fen", "b", "v", "tf", "inf"], "by": ["ssl", "buffer", "server", "serv", "feed", "report", "as", "j", "html", "BY", "via", "in", "content", "source", "reader", "browser", "r", "open", "body", "out", "web", "log", "or", "re", "to", "it", "By", "v", "with", "acc", "service", "from"], "uc": ["cu", "tc", "cc", "sc", "ud", "cf", "rc", "http", "con", "c", "ru", "fc", "su", "dc", "uu", "cus", "ec", "client", "cv", "ws", "lc", "cas", "ct", "connection", "auc", "uh", "acc", "https", "xc", "ub", "usc", "u", "conn", "coll", "ci", "uci", "ucc", "pc", "mc", "us", "soc", "bc", "BC", "cci", "contract", "ac", "UC", "ul", "SC", "FC", "unc", "cur", "cca", "loc"]}}
{"id1": "2936678", "id2": "21438069", "code1": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "code2": "    public ProjectDeploymentConfiguration createNewProjectDeploymentConfig(int projectID, String name, String description) throws AdaptationException {\n        ProjectDeploymentConfiguration config = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            config = getProjectDeploymentConfiguration(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProjectDeploymentConfig\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return config;\n    }\n", "label": 0, "substitutes": {"getUniqueKey": ["getStringLink", "getuniqueLink", "makeUniqueLink", "makeuniquekey", "makeuniqueLink", "getUniqueHash", "getuniqueKey", "getUniquekey", "getPrimarykey", "getUniqueLink", "getStringHash", "getStringKey", "getPrimaryLink", "makeUniquekey", "makeuniqueKey", "makeuniqueHash", "getPrimaryHash", "getuniqueHash", "makeUniqueHash", "getuniquekey", "makeUniqueKey", "getStringkey", "getPrimaryKey"], "digest": ["longested", "Digester", "DigEST", "dested", "genit", "dest", " digested", "longEST", "digit", "dests", "uuester", "Digests", "Digid", "genEST", "digester", "digests", "digested", "Digit", "dester", "Digest", "uuest", "longest", "uuid", "uuEST", "digid", " digEST", " digester", "genest", " digests", "Digested", "longester", " digit", " digid", "digEST"], "md": ["ud", "gd", "mag", "bd", "df", "od", "Cmd", "amd", "mo", "med", "ma", "meta", "wd", "MD", "dc", " MD", "ld", "sm", "ad", "rpm", "gb", "mb", "mt", "dh", "mac", "d", "mp", "hd", "pm", "pd", "sd", "de", "mm", " dd", "nd", "metadata", "cd", "gen", "dig", "m", "hm", "km", "dm", "grad", "mand", "mc", "nm", "alg", "mn", "v", "vd", "mg", "mad", "cmd", "dd", "hash"], "timeVal": ["rateValue", "rateVal", "TimeBu", "rateBu", "TimeVal", "timeBu", "timeSeries", "TIMEVal", "timeValue", "TimeValue", " timeValue", "timeval", " timeSeries", "rateLen", "TIMEValue", "timeLen", "TimeLen", "TimeSeries", "TIMESeries", "TIMEval", " timeLen", " timeval", " timeBu", "Timeval"], "localHost": ["remotehost", "LocalAddress", "remotePort", "LocalHost", " localMac", " localPort", "remoteMac", " localhost", "LocalPort", "privateAddress", "privatePort", "localAddress", "remoteAddress", "localMac", "remoteHost", "Localhost", "localPort", "localhost", "LocalMac", " localAddress", "privateHost", "privatehost"], "randVal": ["RandBu", "randomStr", " randLen", "randomval", "randStr", "RandomLen", "randval", "randValue", "RandStr", "randomLen", " randValue", " randStr", "Randomval", "RandomValue", "randomVal", "RandomVal", "RandValue", "randomValue", "RandVal", "randLen", "randomBu", " randBu", "randBu", " randval"], "val": ["string", "base", "sel", "temp", "id", "vol", "enc", "res", "ind", "ref", "result", "el", "ret", "key", "gb", "valid", "pr", "live", "value", "buf", "pm", "data", "vals", "x", "format", "test", "msg", "dev", "addr", "az", "grad", "db", "sl", "rev", "values", "update", "abc", "unit", "seq", "v", "reg", "range", "bl", "Val", "pt", "VAL", "eval", "loc"]}}
{"id1": "21555906", "id2": "4716110", "code1": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"actionPerformed": ["actionConceived", "actionExecuted", "actionExecceived", "actionConformed", "actionOccuted", "actionOccformed", "actionConressed", "actionPeruted", "actionExecformed", "actionExecressed", "eventExecceived", "eventPerressed", "actionPerceived", "actionOccceived", "actionConuted", "eventExecressed", "eventExecuted", "actionOccressed", "eventExecformed", "eventPeruted", "eventPerceived", "eventPerformed", "actionPerressed"], "ae": ["event", "Events", "fe", "ace", "fa", "ee", "sem", "c", " ec", "ade", " inst", " pe", "dc", " ace", " te", "ec", " fa", "cm", "gae", " ge", "ce", " event", "je", " ce", "au", "ea", " events", "ca", "de", "exc", " je", "x", "es", "ai", "E", "e", "change", "t", " ev", " a", " error", "a", "bc", "ava", "AE", "pe", "ga", "Event", "oe"], "toservlet": ["topserverlets", "toserverlets", "toservelete", "toseservlete", "tosServlete", "toseserveet", "toseservelete", "tosServlet", "tosvurl", "toservlete", "toserverlet", "toservler", "tosservlets", "topservle", "tosvet", "topservlet", "topserverler", "topservler", "topserverlet", "toserveet", "toseservelet", "tosServurl", "tosvlet", "tosourcelet", "toseserveurl", "toservle", "toservelet", "toseservurl", "toservlets", "tosourcele", "tosservler", "toserverle", "toservet", "tosourceler", "toseservlet", "tosservle", "topserverle", "tosourcelets", "tosvlete", "toserverler", "topservlets", "toseservet", "tosservlet", "toserveurl", "tosServet", "toservurl"], "servleturl": [" servleurl", "servletsurl", "servletfile", "servleurl", "servletturl", "servleturi", "ervletsserver", "servlettserver", "ervletsuri", "servletsserver", "servjecturl", "servleconnection", "servletturi", "ervletconnection", "servlconnection", "servlettconnection", "servjectconnection", "ervletsconnection", "servlefile", " servleserver", "ervletsurl", "servletsuri", "servjectserver", "ervleturi", " servlefile", " servletserver", "servletserver", "servjectfile", " servletfile", "ervletserver", "servluri", "servlserver", " servleconnection", "servlurl", "ervleturl", "servleserver", "servletsfile", "servletsconnection"], "servletconnection": ["ervletsconn", "servletscommunication", "servletscon", "servlettconn", "servletsconn", "serverletconnect", "servlettConnection", "servbleurl", "servlessconnection", "servletsurl", " servetconn", "servleconn", "serverletsConnection", "servserverurl", "servletpassword", "servletconn", "servleConnection", "servserverconn", "servlexconnection", "serverletsconnection", "servleconnect", " servetconnection", "servlesspassword", "servleconnection", "servletspassword", "servletsconnect", "serverletConnection", "ervletconnection", " servetconnect", "servletConnection", " servletconnect", "servetConnection", "servlexpassword", "servlexcommunication", "ervletsconnection", "servblecon", " servletconn", "serverletsconnect", " servletConnection", "servletsConnection", " servleConnection", "ervletsurl", "serverletconnection", "serverletsconn", "servlexconn", "serverletcommunication", "serverletconn", "servserverconnection", "servlettconnect", " servleconn", "ervletscon", "servetconn", "servlessconn", "servlesscommunication", "servletcommunication", " servleconnect", "servetconnection", "serverletscommunication", "serverletpassword", "servletcon", "servletconnect", " servleconnection", "servbleconn", "servservercon", "ervletcon", "servbleconnection", "servetconnect", "ervleturl", "servletsconnection", "servlettconnection", "serverletspassword", " servetConnection", "ervletconn"], "inputFromClient": ["InputFromConnection", "inputFromclient", "outputfromURL", "inputFromURL", "inputFormClient", "requestFromClient", "InputFromStream", "InputFormClient", "inputfromServer", "inputOrServer", "outputFromURL", "inputViaURL", "inputFormConnection", "inputOrCL", "inputFromRemote", "requestFromServer", "inputFromConnection", "outputfromClient", "inputViaCL", "outputfromCL", "requestFromclient", "inputfromConnection", "inputToRemote", "inputOrURL", "inputViaClient", "InputFromclient", "InputFormStream", "InputFromClient", "inputfromclient", "inputToServer", "inputToClient", "inputfromClient", "inputToclient", "inputfromURL", "inputfromStream", "inputOrClient", "inputFromStream", "inputFormStream", "inputFromServer", "outputfromServer", "outputFromServer", "inputFormclient", "requestFromConnection", "InputFormConnection", "inputfromCL", "inputFromCL", "InputFormclient", "inputViaServer", "inputToConnection", "outputFromClient", "outputFromCL", "requestFromRemote"], "fos": [" faos", " foos", "affbos", "affoos", " fbos", "foos", "ifoses", " foses", "affis", "ifaos", "Foos", "ifols", "affos", "ifos", "foses", " fols", "Fos", "Fis", "Fols", " fis", "Foses", "Fbos", "faos", "fols", "Faos", "fbos", "fis"], "buf": ["buffer", "bf", "bd", "bh", "uint", "cap", "lb", "cb", "pool", "off", "bin", "ff", "feat", "queue", "uf", "la", "bag", "comb", "cv", "bu", "rb", "cas", "wb", "uc", "buff", "data", "tmp", "fb", "bb", "box", "vec", "font", "ha", "bytes", "bc", "Buff", "bp", "shape", "seq", "b", "br", "bound", "bl", "ba", "pad", "block", "batch", "loc"], "bytesread": ["Bytesread", "filesread", "rowsRead", "Byteswrite", "rowsrun", "filesrun", "rowsread", "bytesrun", "BytesRead", " bytesRead", "lineswrite", "tesload", "linesRead", "fileswrite", "rowswrite", "teswrite", "Bytesload", "linesrun", " bytesload", "linesread", "tesrun", "filesRead", "byteswrite", "tesread", "bytesRead", "bytesload", " bytesrun", " byteswrite", "linesload"]}}
{"id1": "23666973", "id2": "15745420", "code1": "    private InputStream openStreamRaw(String filename) {\n        InputStream stream = null;\n        if (filename == null) return null;\n        if (filename.length() == 0) {\n            return null;\n        }\n        try {\n            URL url = new URL(filename);\n            stream = url.openStream();\n            return stream;\n        } catch (MalformedURLException mfue) {\n        } catch (FileNotFoundException fnfe) {\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        ClassLoader cl = getClass().getClassLoader();\n        stream = cl.getResourceAsStream(\"data/\" + filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        stream = cl.getResourceAsStream(filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        return stream;\n    }\n", "code2": "    private void download(String address, String localFileName) throws UrlNotFoundException, Exception {\n        String ext = G_File.getExtensao(address);\n        if (ext.equals(\"jsp\")) {\n            throw new Exception(\"Erro ao baixar pagina JSP, tipo negado.\" + address);\n        }\n        File temp = new File(localFileName + \".tmp\");\n        if (temp.exists()) temp.delete();\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            try {\n                URL url = new URL(address);\n                conn = url.openConnection();\n                in = conn.getInputStream();\n            } catch (FileNotFoundException e2) {\n                throw new UrlNotFoundException();\n            }\n            out = new BufferedOutputStream(new FileOutputStream(temp));\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n        } catch (UrlNotFoundException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        File oldArq = new File(localFileName);\n        if (oldArq.exists()) {\n            oldArq.delete();\n        }\n        oldArq = null;\n        File nomeFinal = new File(localFileName);\n        temp.renameTo(nomeFinal);\n    }\n", "label": 0, "substitutes": {"openStreamRaw": ["createStreamSource", "createSteamSource", "openStreamAsync", "openSteamAsync", "createStreamRaw", "openstreamRaw", "openFileRaw", "openFileSource", "openStreamInternal", "createStreamAsync", "openstreamSource", "createSteamAsync", "openFileInternal", "openSteamSource", "openSteamInternal", "createStreamInternal", "createSteamInternal", "createSteamRaw", "openstreamInternal", "openFileAsync", "openstreamAsync", "openStreamSource", "openSteamRaw"], "filename": ["directory", "string", "path", "class", "loader", "sf", "uri", "resource", "n", "username", "dll", "kl", "subject", "wl", "fp", "location", "length", "fn", "l", "lua", "il", "database", "password", "txt", "utf", "source", "Filename", "which", "login", "undle", "FILE", "license", "SourceFile", "acl", "data", "file", "src", "size", "nil", "journal", "href", "ppa", "title", "name", "fil", "word", "prefix", "fd", "rl", "sql", "fax", "sound", "download", "f", "kn", "phrase", "actual", "ename", "jpg"], "stream": ["zip", "ssl", "class", "temp", "resource", "output", "http", "cont", "host", "content", "raw", "uc", "model", "open", "file", "bb", "row", "context", "coll", "sl", "transform", "download", "impl", "string", "buffer", "accept", "server", "feed", "clean", "result", "trans", "sync", "source", "load", "live", "value", "w", "parent", "channel", "through", "hook", "object", "control", "full", "pair", "event", "path", "rest", "core", "video", "response", "message", "slice", "socket", "length", "loop", "session", "reader", "back", "Stream", "upload", "body", "null", "image", "steam", "wrapper", "stack", "stage", "ream", "method", "cur", "callback", "view", "valid", "input", "enc", "continue", "draft", "current", "instance", "child", "pool", "thread", "form", "client", "sample", "size", "log", "port", "pull", "sw", "f", "iv"], "url": ["string", "path", "base", "ssl", "loader", "server", "resource", "uri", "feed", "id", "http", "rel", "l", "URL", "line", "el", "fl", "source", "lib", "data", "file", "channel", "web", "page", "ll", "name", "coll", "e", "image", "sl", "Url", "www", "b", "ul", "f", "plug", "api", "loc"], "cl": ["hell", "sel", "class", "loader", "cc", "sc", "ssl", "Cl", "lock", "kl", "con", "c", "cont", "ctrl", "col", "l", "shell", "pl", "el", "fl", "ec", "comb", "client", "lc", "uc", "lib", "ct", "ocl", "acl", "ll", "cel", "ls", "coll", "cr", "cle", "ml", "decl", "sl", "CL", "ctx", "bc", "pe", " CL", "sh", "bl", "scl", "cli", "gl", "loc"], "cn": ["ains", "core", "cc", "n", "cf", "enc", "gin", "net", "con", "ns", "jc", "act", "cb", "fn", "arn", "hn", "dc", "CW", "nc", "ec", "CN", "cm", "cdn", "icon", "lc", "auc", "uh", "ct", "rn", "cy", "ca", "gn", "nam", "xc", "CA", "wcs", "ae", "conn", "cone", "ain", "bn", "nic", "coll", "dn", "cr", "kin", "mc", "ln", "nat", "abc", "mn", "sn", "kn", "Ns"]}}
{"id1": "14598566", "id2": "1188100", "code1": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"copyFileByNIO": ["copyFileByMIF", "copyFileByFileIO", "copyFileByNIP", "copyFileByNio", "copyFilebynIF", "copyFilebyNIO", "copyFileBynIF", "copyFileByFileIF", "copyFileByMio", "copyFileBynIP", "copyFilebynio", "copyFileByFileIP", "copyFilebyNio", "copyFilebyNIP", "copyFileByMIP", "copyFilebynIO", "copyFileByMIO", "copyFileByNIF", "copyFileBynIO", "copyFileByFileio", "copyFilebynIP", "copyFilebyNIF", "copyFileBynio"], "in": ["IN", "index", "base", "buffer", "i", "input", "id", "ex", "copy", "resource", "ini", "c", "inner", "ins", "bin", "part", "at", "reader", "source", "connection", "min", "diff", "login", "inc", "data", "file", "h", "x", "or", "again", "name", "m", "image", "io", "In", "url", "b", "ac", "inn", "din"], "out": ["path", "string", "buffer", "ex", "n", "output", "copy", "resource", "c", "OUT", "project", "dest", "outs", "o", "client", "part", "at", "source", "cache", "connection", "target", "w", "inc", "data", "file", "object", "p", "conn", "name", "again", "exec", "Out", "writer", "io", "image", "to", "prefix", "ext", "v", "b", "external"], "sourceChannel": [" sourcechannel", "srcConnection", "innerStream", "ourceStream", "sourcechannel", "ourceChan", "srcQueue", "ourceConnection", "sinChannel", "Sourcechannel", "sinChan", "sourceQueue", "targetChan", "targetConnection", "SourceStream", " sourceStream", "innerChannel", " sourceConnection", "sourceChan", " sourceChan", "sinStream", " sourceServer", "ourceQueue", "sinServer", "sourceConnection", "innerChan", "ourcechannel", "srcChannel", "sourceStream", "ourceChannel", "SourceChan", "targetchannel", "targetChannel", "SourceChannel", "innerServer", "srcChan", "SourceConnection", "sourceServer", " sourceQueue"], "destinationChannel": ["destributionChan", "destroyingConnection", "destionClient", "destinatorChannel", "destributionContext", "destinationConnection", "destinateChannel", "destinatedChannel", "destributionClient", "destroyingStream", "destinationChan", "destinateStream", "destinationClient", "destinatedChan", "destinationContext", "DestinatorClient", "DestinationConnection", "destributionChannel", "destinatedContext", "DestinationChan", "DestinatorStream", "DestinationChannel", "DestinationContext", "DestinatorContext", "destionChan", "destinatorConnection", "destinatorClient", "destributionStream", "destinatorContext", "DestinationClient", "destinationStream", "DestinationStream", "DestinatorConnection", "DestinatorChannel", "destroyingChannel", "destinateConnection", "DestinatorChan", "destinatorStream", "destionChannel", "destributionConnection", "destinatorChan", "destinatedStream", "destionConnection"]}}
{"id1": "18114701", "id2": "22411381", "code1": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"resolveEntity": ["resolveEnt", "resolveentity", "reolveentity", "resolvedEnt", "resolvingEntity", "reolveEntity", "resolvedEntity", "reserveEntity", "reolvedEntity", "reserveentity", "resolvedentity", "resolvingEnt", "reserveEnt", "resolvingentity", "reolveEnt", "reolvedEnt", "reolvedentity"], "publicId": ["systemID", "systemData", "systemEntity", "publicEntity", "publicID", "productionUrl", "openId", "openID", "openUrl", "publicUrl", "externalId", "openid", "productionID", " publicData", " publicID", "projectId", "projectKey", " publicUrl", " publicKey", "externalEntity", "systemKey", "ublicEntity", "publicid", "externalMid", "publicMid", "ublicID", "productionId", "ublicId", "externalID", "projectData", "publicData", "systemMid", "ublicMid", "publicKey", "productionid", "projectID", " publicid"], "systemId": ["systemID", "SystemUrl", "systemName", "systemPath", " systemUrl", "SystemPath", "systemid", " systemid", "SystemId", "ystemid", "serverId", " systemName", " systemPath", "Systemid", "serverUrl", "serverName", "serverid", "ystemPath", "systemUrl", "SystemID", "SystemName", "ystemId", " systemID", "ystemID"], "resolved": ["rejected", " resjected", "presolver", "resolve", "presjected", "presolve", "resjected", " resolve", "reolved", "Resolve", " resolver", "presolving", "Resolution", "Resolver", "revolved", "revolver", "revolve", "reolve", "reolver", "reolving", "reolution", " resolution", "resolving", "resolution", "resolver", " resolving", "Resolved", "revolution", "presolution", "revolving", "presolved"], "iSource": ["diSourceFile", " iUrl", " iFactory", "piPoint", "piUrl", "uiStream", "uriStream", "diPoint", "ISource", "diSource", "iuSOURCE", "apiUrl", "piStream", "piFactory", "iuClient", "uiSOURCE", "iUrl", "uriSession", "uriSource", " iSourceFile", "iSession", "piSource", "iuSource", "uriSourceFile", "iSOURCE", " iSession", "diStream", "piSourceFile", "apiStream", "uiSource", "iClient", "apiFactory", " iPoint", "IClient", "uiClient", "iPoint", "piSession", "iuStream", "ISOURCE", "apiSource", "iSourceFile", "IStream", "iFactory"], "url": ["string", "path", "address", "ssl", "id", "uri", "resource", "feed", "server", "user", "http", "rel", "location", "l", "URL", "fr", "fl", "client", "source", "jar", "connection", "browser", "config", "data", "file", "channel", "web", "page", "image", "sl", "rl", "secure", "Url", "www", "stream", "b", "f", "org", "api"], "iStream": ["iiStream", "uPath", "iStreamer", "uFrame", "iiFrame", "uriStream", "lFrame", "lSource", "uriSteam", "iiPath", "uriSource", "uSteam", "lStream", "uStreamer", "iiSource", "lPath", "uriStreamer", "uSource", "iiSteam", "iPath", "iSteam", "iiStreamer", "iFrame", "uStream"]}}
{"id1": "7846688", "id2": "16621503", "code1": "    public void postData(String protocol, String host, String form, String data) throws Exception {\n        if ((protocol == null) || (protocol.equals(\"\"))) {\n            protocol = DEFAULT_PROTOCOL;\n        }\n        if ((host == null) || (host.equals(\"\"))) {\n            host = DEFAULT_HOST;\n        }\n        if (form == null) {\n            form = DEFAULT_FORM;\n        }\n        if (data == null) {\n            throw new IllegalArgumentException(\"Invalid data\");\n        }\n        URL url = new URL(protocol, host, form);\n        URLConnection con = url.openConnection();\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setUseCaches(false);\n        con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"Content-length\", String.valueOf(data.length()));\n        PrintStream out = new PrintStream(con.getOutputStream(), true);\n        out.print(data);\n        out.close();\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        while (in.readLine() != null) {\n        }\n        in.close();\n    }\n", "code2": "    public static ArrayList<String> loadURLToStrings(URL url, int maxLines, String userAgent, int timeout) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (userAgent != null && userAgent.trim().length() > 0) {\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n        } else {\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (compatible; astrominer/1.0;)\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n        }\n        connection.connect();\n        return loadURLToStrings(connection, maxLines);\n    }\n", "label": 0, "substitutes": {"postData": [" postBody", "PostPart", " PostData", " postText", "postBody", "PostBody", "PostData", "postText", " PostPart", "PostText", " PostBody", "postPart", " postPart", " PostText"], "protocol": ["protol", "proose", "cryptport", "Protocol", "intericle", "scheec", "proport", "Proticle", "interocol", "proo", "cryptol", "scheo", "promport", "interport", "hostocol", "scheocol", "pathicle", "iolurl", "promocol", "pathport", "Protol", "proticle", "crypto", "scheotype", "hostort", "protport", "portec", "porto", "proocol", "proec", "iolocol", "portocol", "Protort", "Protport", "protose", "Protose", "Proto", "pathol", "interol", "hosturl", "promol", "protort", "pathocol", "proturl", "prototype", "prootype", "Prototype", "promo", "iolort", "iolport", "proto", "portotype", "theotype", "cryptocol", "theocol", "protec", "theose", "Proturl", "theport", "hostport"], "host": ["string", "path", "address", "root", "node", "base", "server", "uri", "feed", "add", "http", "subject", "site", "project", "account", "database", "domain", "pattern", "key", "part", "type", "source", "arch", "mac", "proxy", "component", "target", "work", "bind", "parent", "topic", "channel", "h", "ip", "object", "format", "hop", "name", "header", "front", "port", "controller", "home", "service", "Host", "localhost", "auth", "ac", "container", "hub", "method", "hard", "view", "loc"], "form": ["zip", "string", "path", "address", "input", "feed", "clean", "Form", "act", "place", "off", "query", "pass", "domain", "pattern", "key", "post", "raw", "filter", "type", "session", "source", "one", "FORM", "str", "model", "config", "text", "body", "parent", "file", "channel", "object", "forms", "format", "test", "name", "template", "port", "action", "function", "stream", "ac", "range", "with", "and", "f", "method", "field", "transform", "term", "view"], "data": ["zip", "string", "info", "buffer", "input", "uri", "response", "resource", "message", "json", "version", "result", "patch", "query", "database", "key", "alpha", "content", "what", "post", "params", "picture", "part", "raw", "type", "source", "cache", "one", "parts", "value", "media", "str", "DATA", "config", "text", "body", "file", "request", "append", "style", "format", "name", "change", "action", "array", "update", "da", "missing", "xml", "dat", "multi", "batch", "view", "valid"], "url": ["impl", "ssl", "base", "server", "uri", "resource", "http", "c", "fc", "l", "URL", "fl", "client", "session", "cache", "proxy", "connection", "open", "file", "channel", "web", "log", "conn", "ls", "sl", "Url", "com", "www", "ur", "b", "connect", "f", "this", "api"], "con": ["Connection", "close", "core", "Conn", "fa", "CON", "enc", "cons", "rc", "http", "ran", "on", "pre", "c", "socket", "fc", "per", "sub", "run", "Con", "co", "en", "client", "sync", "cm", "part", "cp", "ocon", "cache", "uc", "connection", "login", "r", "open", "conv", "un", "ca", "channel", "inc", "xc", "cl", "log", "conn", "coll", "exec", "cr", "pc", "ver", "bc", "com", "can", "pen", "conf", "connect", "cn", "f", "cur", "win", "re", "cos"], "out": ["sum", "temp", "plus", "output", "n", "outer", "ex", "user", "gin", "net", "OUT", "socket", "plain", "sub", "o", "outs", "child", "line", "co", "bin", "pass", "key", "raw", "sync", "cache", "up", "r", "ch", "inc", "w", "file", "web", "p", "log", "conn", "again", "Out", "writer", "io", "conf", "err", "b", "obj", "ac", "f"], "in": ["IN", "impl", "pin", "i", "input", "ex", "id", "ini", "c", "inner", "socket", "inter", "sub", "l", "s", "ins", "line", "bin", "is", "read", "fin", "reader", "login", "min", "inside", "r", "inc", "vin", "rin", "conn", "rec", "init", "again", "rx", "isin", "In", "kin", "nin", "stream", "lin", "b", "err", "cin", "inn", "f", "win", "din"]}}
{"id1": "21555906", "id2": "742465", "code1": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"actionPerformed": ["actionConceived", "actionExecuted", "actionExecceived", "actionConformed", "actionOccuted", "actionOccformed", "actionConressed", "actionPeruted", "actionExecformed", "actionExecressed", "eventExecceived", "eventPerressed", "actionPerceived", "actionOccceived", "actionConuted", "eventExecressed", "eventExecuted", "actionOccressed", "eventExecformed", "eventPeruted", "eventPerceived", "eventPerformed", "actionPerressed"], "ae": ["event", "Events", "fe", "ace", "fa", "ee", "sem", "c", " ec", "ade", " inst", " pe", "dc", " ace", " te", "ec", " fa", "cm", "gae", " ge", "ce", " event", "je", " ce", "au", "ea", " events", "ca", "de", "exc", " je", "x", "es", "ai", "E", "e", "change", "t", " ev", " a", " error", "a", "bc", "ava", "AE", "pe", "ga", "Event", "oe"], "toservlet": ["topserverlets", "toserverlets", "toservelete", "toseservlete", "tosServlete", "toseserveet", "toseservelete", "tosServlet", "tosvurl", "toservlete", "toserverlet", "toservler", "tosservlets", "topservle", "tosvet", "topservlet", "topserverler", "topservler", "topserverlet", "toserveet", "toseservelet", "tosServurl", "tosvlet", "tosourcelet", "toseserveurl", "toservle", "toservelet", "toseservurl", "toservlets", "tosourcele", "tosservler", "toserverle", "toservet", "tosourceler", "toseservlet", "tosservle", "topserverle", "tosourcelets", "tosvlete", "toserverler", "topservlets", "toseservet", "tosservlet", "toserveurl", "tosServet", "toservurl"], "servleturl": [" servleurl", "servletsurl", "servletfile", "servleurl", "servletturl", "servleturi", "ervletsserver", "servlettserver", "ervletsuri", "servletsserver", "servjecturl", "servleconnection", "servletturi", "ervletconnection", "servlconnection", "servlettconnection", "servjectconnection", "ervletsconnection", "servlefile", " servleserver", "ervletsurl", "servletsuri", "servjectserver", "ervleturi", " servlefile", " servletserver", "servletserver", "servjectfile", " servletfile", "ervletserver", "servluri", "servlserver", " servleconnection", "servlurl", "ervleturl", "servleserver", "servletsfile", "servletsconnection"], "servletconnection": ["ervletsconn", "servletscommunication", "servletscon", "servlettconn", "servletsconn", "serverletconnect", "servlettConnection", "servbleurl", "servlessconnection", "servletsurl", " servetconn", "servleconn", "serverletsConnection", "servserverurl", "servletpassword", "servletconn", "servleConnection", "servserverconn", "servlexconnection", "serverletsconnection", "servleconnect", " servetconnection", "servlesspassword", "servleconnection", "servletspassword", "servletsconnect", "serverletConnection", "ervletconnection", " servetconnect", "servletConnection", " servletconnect", "servetConnection", "servlexpassword", "servlexcommunication", "ervletsconnection", "servblecon", " servletconn", "serverletsconnect", " servletConnection", "servletsConnection", " servleConnection", "ervletsurl", "serverletconnection", "serverletsconn", "servlexconn", "serverletcommunication", "serverletconn", "servserverconnection", "servlettconnect", " servleconn", "ervletscon", "servetconn", "servlessconn", "servlesscommunication", "servletcommunication", " servleconnect", "servetconnection", "serverletscommunication", "serverletpassword", "servletcon", "servletconnect", " servleconnection", "servbleconn", "servservercon", "ervletcon", "servbleconnection", "servetconnect", "ervleturl", "servletsconnection", "servlettconnection", "serverletspassword", " servetConnection", "ervletconn"], "inputFromClient": ["InputFromConnection", "inputFromclient", "outputfromURL", "inputFromURL", "inputFormClient", "requestFromClient", "InputFromStream", "InputFormClient", "inputfromServer", "inputOrServer", "outputFromURL", "inputViaURL", "inputFormConnection", "inputOrCL", "inputFromRemote", "requestFromServer", "inputFromConnection", "outputfromClient", "inputViaCL", "outputfromCL", "requestFromclient", "inputfromConnection", "inputToRemote", "inputOrURL", "inputViaClient", "InputFromclient", "InputFormStream", "InputFromClient", "inputfromclient", "inputToServer", "inputToClient", "inputfromClient", "inputToclient", "inputfromURL", "inputfromStream", "inputOrClient", "inputFromStream", "inputFormStream", "inputFromServer", "outputfromServer", "outputFromServer", "inputFormclient", "requestFromConnection", "InputFormConnection", "inputfromCL", "inputFromCL", "InputFormclient", "inputViaServer", "inputToConnection", "outputFromClient", "outputFromCL", "requestFromRemote"], "fos": [" faos", " foos", "affbos", "affoos", " fbos", "foos", "ifoses", " foses", "affis", "ifaos", "Foos", "ifols", "affos", "ifos", "foses", " fols", "Fos", "Fis", "Fols", " fis", "Foses", "Fbos", "faos", "fols", "Faos", "fbos", "fis"], "buf": ["buffer", "bf", "bd", "bh", "uint", "cap", "lb", "cb", "pool", "off", "bin", "ff", "feat", "queue", "uf", "la", "bag", "comb", "cv", "bu", "rb", "cas", "wb", "uc", "buff", "data", "tmp", "fb", "bb", "box", "vec", "font", "ha", "bytes", "bc", "Buff", "bp", "shape", "seq", "b", "br", "bound", "bl", "ba", "pad", "block", "batch", "loc"], "bytesread": ["Bytesread", "filesread", "rowsRead", "Byteswrite", "rowsrun", "filesrun", "rowsread", "bytesrun", "BytesRead", " bytesRead", "lineswrite", "tesload", "linesRead", "fileswrite", "rowswrite", "teswrite", "Bytesload", "linesrun", " bytesload", "linesread", "tesrun", "filesRead", "byteswrite", "tesread", "bytesRead", "bytesload", " bytesrun", " byteswrite", "linesload"]}}
{"id1": "19251426", "id2": "18693224", "code1": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"recurseFiles": [" recursiveItems", "recorderFiles", "reivefiles", "recursiveImages", "recurseImages", "reiveFiles", " recursiveFiles", "reciveFile", " recurseFile", "recursiveFiles", "reciveFiles", "recorderImages", "reiveFile", "recurseChildren", "recivefiles", "recursivefiles", "recursiveItems", "reurseFiles", "reiveImages", "recieveFiles", "recieveItems", "reursefiles", " recursiveFile", " recursiveChildren", "recurseItems", "recieveChildren", "recerveFiles", "recerveItems", "reciveImages", " recurseChildren", "recursiveFile", "recerveChildren", "recursiveChildren", "reurseFile", "recerveFile", "recorderFile", " recurseItems", "recursefiles", "recorderfiles", "recieveFile", "recurseFile", "reurseImages"], "root": ["directory", "zip", "path", "base", "node", "string", "loader", "remote", "server", "output", "resource", "uri", "user", "rew", "project", "result", "ro", "bin", "oot", "back", "reader", "source", "dir", "cover", "rule", "r", "default", "parent", "roots", "archive", "out", "Root", "object", "or", "folder", "name", "tree", "box", "writer", "home", "array", "prefix", "ver", "url", "this", "b", "xml", "f", "module", "ree", "loc"], "file": ["directory", "zip", "path", "base", "class", "info", "letter", "handler", "server", "resource", "uri", "ile", "entry", "http", "auto", "document", "table", "project", "fp", "number", "child", "line", "time", "File", "queue", "content", "type", "source", "cache", "use", "dir", "binary", "model", "FILE", "collection", "work", "parent", "data", "local", "page", "object", "get", "log", "style", "single", "or", "folder", "name", "e", "tree", "image", "force", "function", "leaf", "full", "db", "url", "pe", "comment", "b", "future", "xml", "f", "module", "code"], "zaos": ["zioS", "waoS", "zooss", "zaoS", "ziis", "ziOS", "zioss", "zeoS", "zes", "naos", "zos", "yaos", "zeose", "zeoss", "qaoss", "wao", "zais", "naose", "wais", "zaose", "qaOS", "zeas", "yaes", "zaOS", "zoS", "zeos", "naoss", "zaot", "yaoS", "waoss", "qais", "zeis", "zoose", "zis", "zeo", "naas", "zao", "gaot", "zaoss", "ziot", "gaos", "gaOS", "zaes", "qaoS", "zios", "yao", "zoas", "gaes", "zoos", "qaot", "gao", "qaos", "waOS", "gaoS", "zo", "waos", "zaas"], "absolute": ["total", "base", "physical", "aggressive", "optional", "uri", "relative", "http", "document", "abs", "Abs", "active", "alpha", "offset", "olute", "ative", "use", "exclusive", "international", "based", "atomic", "alias", "al", "able", "fixed", "empty", "append", "encrypted", "multiple", "inline", "reverse", "complete", "negative", "apply", "automatic", "full", "mobile", "always", "compatible", "supported", "required", "positive", "enable", "simple", "attribute", "ical", "external", "auto", "valid"], "files": ["keys", "balls", "fs", "pages", "results", "docs", "ples", "features", "apps", "s", "Files", "qs", "pes", "split", "items", "projects", "links", "iles", "lines", "users", "blocks", "names", "classes", "images", "objects", "models", "plugins", "ips", "sites", "groups", "es", "log", "ls", "alls", "cells", "rows", "books", "events", "f"], "file2": ["filename02", " fileSub", "letter2", "files2", " filetwo", "object1", "filename1", "letter1", "letterSub", "files1", "filenametwo", "filename2", "file1", "filetwo", "objectSub", "filestwo", "object2", "file02", "files02", "fileSub", " file1", " file02"], "filename": ["directory", "letter", "string", "path", "kn", "zip", "uri", "token", "username", "whatever", "kl", "subject", "message", "description", "json", "slice", "fp", "location", "length", "ame", "il", "l", "sheet", "shell", "database", "password", "txt", "utf", "email", "Filename", "binary", "ema", "which", "wb", "connection", "SourceFile", "archive", "append", "metadata", "size", "language", "nil", "title", "name", "folder", "fil", "family", "word", "sl", "url", "summary", "download", "f", "ppa", "phrase", "module", "ename", "loc"], "zae": [" zoda", "zeace", "zaape", "ezcoe", "Zade", "Zae", "ezade", " zanne", "zipoda", " zobe", "zace", "zoe", "zade", "zecoe", "Zoe", "fae", "Zanne", "fade", "zaobe", "zaae", "fanne", " zoe", "foe", "zipobe", " zcoe", "ezae", "zape", "zipae", " zade", " zace", "ezace", "zobe", "zanne", "zeae", "zeade", "zoda", "zipape", "zcoe", " zape", "zaoda"], "fis": ["fais", "lis", " fais", "sfis", " fris", "zwas", "fris", "zais", "fisc", "zisc", " fisc", " fwas", "sfisc", "fisa", "sfwas", "sfais", "cais", "cis", "zis", "lisa", "cris", "lris", "lais", "fwas", " fisa", "cisa"]}}
{"id1": "804637", "id2": "3024992", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRebwrite", "readAndRebrap", "readAndRewwrite", "readAndSwrap", "readAndrewwrite", "readAndRebrite", "readandRewrap", "readandRewrites", "readAndSwwrite", "readandrewrap", "readAndRewrap", "readAndSwrite", "readandrewrites", "readandrewwrite", "readAndRebrites", "readAndRewrites", "readAndrewrite", "readAndSwrites", "readandrewrite", "readAndrewrites", "readAndrewrap", "readandRewwrite", "readandRewrite"], "inFile": [" inSourceFile", "InSourceFile", "oldfile", "outSourceFile", "inputfile", "outfile", " inFiles", "inputFilename", "InFiles", " infile", "infile", "inputFile", "outFiles", "oldFile", "loginFile", " inFilename", "Infile", "inFiles", "inputFiles", "oldFiles", "loginFilename", "loginfile", "loginFiles", "InFile", "oldFilename", "outFilename", "inFilename", "inSourceFile"], "outFile": ["newfile", "outDir", "OutStream", "processFile", "outputFilename", "exFilename", "outputfile", " outfile", "outPlace", "outFILE", "outputFILE", "outfile", "processFilename", "offFILE", "outputPlace", "thisFilename", "outStream", "thisFile", "processPlace", "exfile", "thisFILE", "newDir", "exFILE", "OutDir", "exFile", "processFILE", "newStream", "offPlace", "OutFile", " outStream", "outFilename", "offFilename", "Outfile", " outDir", "outputFile", "newFile", "thisfile", "offFile"], "iis": ["iIS", "Iais", "iIs", "iiris", "iniIs", "iiiss", "iais", "Iis", "ciis", "iiis", " iIs", " iIS", " iais", "ciiss", "Iiss", "ciais", " iiss", "iiss", "iiIS", "iniiss", " iris", "iniis", "ciris", "iniIS", "iniris", "IIS", "iris", "iiIs", "ciIS", "ciIs"], "dcmParser": ["dbmPolicy", "dbmParser", "dmmLoader", "dmissionParser", "dcmInstallation", "dmoduleJar", "dpmLoader", "dmoduleparser", "dhemReader", "dkmParser", "dmissionLanguage", "dCMPlugin", " dpmparser", " dcrParser", "fpmparser", "dhemJar", " dpmPolicy", "dkmPolicy", "dpmParser", "dcmPolicy", "dmissionPlugin", " dcmarser", "dmmPlugin", " dcrPlugin", "DcmInstallation", " dcmLanguage", "dpmHandler", "dmcJar", "dkmPlugin", " dpmParser", "dmoduleReader", " dcrLoader", "fcmReader", "dmissionReader", "dcrParser", "dmcarser", "dbmHelper", "dmLoader", "fpmHandler", "dcrarser", "dhemInstallation", "dmcParser", "dmmparser", "dpmLanguage", "dmodulePlugin", " dcmPolicy", "dpmarser", "dpmReader", "dcmPar", "dpmPar", "dmReader", "dcmparser", "dcrLoader", "dmParser", " dcmLoader", " dcmReader", "fcmparser", "dpmPolicy", "dcrJar", "dcmPlugin", "dpmparser", "fpmReader", "dcmarser", " dpmPlugin", "dbmPlugin", "dpmPlugin", " dpmHelper", "dCMLoader", " dpmLoader", " dpmJar", "dmoduleParser", " dcrReader", "dcmLoader", "fcmParser", "dpmHelper", "dcmReader", " dpmPar", "dCMHandler", "dmPlugin", "dcmJar", "dcrPlugin", "dpmJar", " dcmJar", "fcmHandler", " dcmHelper", "dCMparser", "dcrPar", "DcmParser", " dcmPar", "dcrReader", "fpmParser", " dpmReader", " dcmparser", "dmcPar", " dpmLanguage", "dcmHelper", "dpmInstallation", "dcmHandler", "dCMParser", "dcmLanguage", "dmmParser", "DcmReader", "dCMReader", "dkmHelper", " dcmPlugin", "DcmJar", "dhemParser", " dpmarser"], "ds": ["services", "ys", "uds", "ays", "DS", "iss", "gd", "sys", "Os", "df", "ants", "ns", "tes", "ks", "drivers", "qs", "bs", "s", "ins", "dr", "is", "dc", "rs", "ld", "dt", "parts", "cdn", "sync", "session", "ws", "d", "ros", "eps", "points", "icks", "ads", "data", "gs", "src", "xs", "utils", "vals", "ras", "Ds", "des", "ts", "conn", "vs", "ls", "js", "ss", "db", "ils", "di", "nas", "details", "amps", "Db", "da", "asi", "cs", "dds", "ps", "os", "dat", "pd", "dd", "tx"], "pdReader": ["hdRunner", "pbRunner", "pcReader", "pdRunner", "xdreader", "dsReader", "dsreader", "pbLoader", "hdReader", "hdreader", "dsLoader", "pcLoader", "pbStream", "hdStream", "ddStream", "pcRead", "xdWriter", "ddLoader", "pdLoader", "pdStream", "ddRunner", "pbReader", "hdWriter", "dsRead", "dsWriter", "xdRead", "pcWriter", "xdReader", "hdRead", "hdLoader", "ddReader", "pdreader", "pdRead"], "out": ["ssl", "base", "temp", "output", "net", "as", "s", "in", "at", "lib", "model", "default", "file", "gen", "conn", "Out", "url", "obj", "with", "external", "point", " in", "outer", "ex", "sys", "lock", "builder", "result", "later", "sync", "part", "cache", "up", "oder", "connection", "w", "parent", "store", "page", "object", "device", "again", "name", "exec", "exp", "array", "full", "over", "list", "order", "inner", "outs", "o", "line", "flow", "co", "write", "password", "session", "doc", "diff", "group", "director", "null", "dev", "io", "writer", "image", "to", "word", "cli", "term", "auto", "her", "copy", "user", "OUT", "child", "manager", "pass", "key", "client", "dot", "login", "inc", "down", "data", "db", "layer", "ext", "err", "code", "img"], "dcmEncParam": ["dcmEnParam", "dcmEstParam", "dcmDecParam", "dcmEnParameter", "dcmSecPart", "dcmDecType", "dcmDecPar", "dcmEncType", "dcmEncParameter", "dcmArchParam", "dcmEncPart", "dcmElParameter", "dcmEnPar", "dcmEnPart", "dcmDecArg", "dcmArchArg", "dcmArchParameter", "dcmSecPar", "dcmEnArg", "dcmDecParameter", "dcmDecPart", "dcmSecType", "dcmElParam", "dcmEstPar", "dcmEncPar", "dcmSecParam", "dcmElPar", "dcmEncArg", "dcmElType", "dcmEnType", "dcmEstType", "dcmEstParameter"], "pdWriter": ["dpWrite", "pdOutput", "ddWrite", "pdWriting", "htWriter", "dpReader", "dsReader", "hdReader", "pdWrite", "htWriting", "dpWriting", "PDWrite", "dpWriter", "hdWriter", "dsOutput", "dsWriter", "hdWrite", "htWrite", "PDWriter", "dsWrite", "ddOutput", "PDReader", "ddReader", "htReader", "PDWriting", "ddWriter", "hdOutput"]}}
{"id1": "12847055", "id2": "19667000", "code1": "        public MobileAgentProperties(Class declaringClass, String propertyFile) throws IOException {\n            this.defaults = (MobileAgent) AnnotationElement.getAnyAnnotation(declaringClass, MobileAgent.class);\n            URL url = getClass().getClassLoader().getResource(propertyFile);\n            if (url != null) {\n                props.load(url.openStream());\n                log.info(\"MobileAgent parameters loaded from file \" + url);\n            }\n        }\n", "code2": "    public static Reader getReader(String url) throws MalformedURLException, IOException {\n        if (url.startsWith(\"file:\")) return new FileReader(url.substring(5)); else if (url.startsWith(\"http:\")) return new InputStreamReader(new URL(url).openStream());\n        throw new MalformedURLException(\"Invalid URI schema, file: or http: expected.\");\n    }\n", "label": 0, "substitutes": {"declaringClass": ["decliningPackage", "decliningFile", "declaringPackage", "DecliningPackage", "claredPackage", "claringPackage", "DecliningText", "declosingFile", "decliningText", "declaringLine", "DecliningClass", "DeclaringClass", "declaredFile", "declaredText", "declaredLine", "declacingFile", "declaringFile", "DecliningFile", "declacingPackage", "declaredClass", "claredFile", "declosingPackage", "DeclaringText", "claredClass", "claringClass", "declosingText", "declaredPackage", "claringFile", "declacingLine", "claringLine", "decliningClass", "declaringText", "declosingClass", "claredLine", "declacingClass", "DeclaringPackage", "DeclaringFile", "decliningLine"], "propertyFile": ["PropertyString", "sectionFILE", "sectionFiles", "sectionFile", "PropertyFILE", "propertiesFile", "sectionfile", "propertiesFiles", "Propertyfile", "propertyFiles", " propertyName", " propertyfile", " propertyFILE", " propertyFiles", "PropertyFile", "propertyName", "PropertyFiles", "PropertyName", " propertyString", "propertyFILE", "propertyString", "propertiesString", "propertiesName", "propertyfile"], "defaults": ["preds", "configs", "predp", "predies", "configies", "defaultp", "urlies", "configp", "urlSettings", "defaultSettings", "configSettings", "urls", "urlp", "defaulties", "predSettings"], "url": ["zip", "string", "path", "base", "class", "loader", "buffer", "address", "server", "resource", "uri", "feed", "ssl", "user", "id", "http", "ref", "rel", "html", "location", "l", "URL", "fr", "fl", "source", "connection", "browser", "org", "ob", "config", "file", "src", "cl", "page", "bel", "bb", "ll", "or", "ls", "coll", " URL", "image", "blog", "sl", "rl", "pull", "Url", "www", "stream", "ur", "ource", "b", "xml", "found", "f", "gl", "element", "service", "api", "loc"]}}
{"id1": "771802", "id2": "19147281", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"createOutputStream": ["createInputFile", " createByteStream", " createInputStream", " createByteSteam", " createOutputReader", " createOutputSteam", " createOutputFile", " createInputReader", "createOutputFile", " createIOSteam", " createByteReader", "createInputSteam", " createIOFile", " createInputFile", "createInputReader", "createOutputReader", "createInputStream", " createIOStream", "createOutputSteam", " createByteFile", " createIOReader", " createInputSteam"], "inFile": ["incFile", "inStream", "inputfile", "outfile", "infile", "inputFile", "outFiles", "sourceFile", "incfile", "outStream", "sourceFiles", "incStream", "insFiles", "inFiles", "insStream", "sourcefile", "inputFiles", "insfile", "incFiles", "inputStream", "sourceStream", "insFile"], "outFile": [" outDirectory", "workFile", "outDir", "inTime", " outfile", "inputTime", "inputfile", "outTime", "outfile", "workfile", "infile", "inputFile", "targetfile", "outStream", "inputDir", "workingDirectory", "workingfile", "targetStream", "inDir", "workTime", "outDirectory", "targetDirectory", "workDir", " outStream", "workingFile", "workingStream", "targetFile"], "k_blockSize": ["k_blockCount", "k_byteCount", "k_byteInfo", "k_lockCount", "k_blocksCount", "k_byteLength", "k_bitInfo", "k_blocksLen", "k_byteLen", "k_lockCode", "k_blocksLength", "k_BlockSize", "k_lockLength", "k_BlockCount", "k_byteCode", "k_blockInfo", "k_lineInfo", "k_lockSize", "k_blocksSize", "k_BlockCode", "k_bitCount", "k_byteSize", "k_blockCode", "k_bitSize", "k_BlockLength", "k_blockLength", "k_lineCount", "k_lineSize", "k_blockLen", "k_lockLen"], "byteCount": ["byteLength", "blockLength", "ByteLength", "byteLen", " bytecount", "ByteLen", "ByteSize", " byteSum", "characterLength", "flushcount", "characterCount", "blockCount", "byteSum", "flushCount", "ByteSum", "ByteCount", " byteSize", "blockSize", "flushLength", " byteLength", "Bytecount", "blockSum", "characterSize", "characterLen", " byteLen", "flushSize", "bytecount", "byteSize"], "buf": ["base", "buffer", "border", "Buffer", "bf", "alloc", "feed", "rc", "bh", "cap", "cb", "loc", "result", "feat", "queue", "uf", "la", "bag", "cv", "rb", "cas", "buff", "len", "data", "config", "src", "tmp", "fb", "exc", "append", "background", "brace", "vec", "font", "ucc", "fd", "bytes", "ctx", "flush", "Buff", "seq", "b", "batch", "cmd", "img"], "ofp": ["OFnp", "Ofnp", "afl", "Oft", "ofl", "oft", "OFtp", "oftp", "OFt", "OFp", "ofnp", "OFl", "fortp", "afp", "OFc", "Ofl", "forp", "afc", "fort", "Ofc", "forc", "Oftp", "Ofp", "ofc", "afnp"], "zos": ["zip", "css", "tz", "zyk", "fits", "zy", "bos", "zar", "zers", "zona", "js", "gz", "enos", "zi", "lins", "zin", "zl", "uz", "ZA", "zo", "liquid", "utils", "ogl", "iffs", "dylib", "ZI", "hz", "z", "bs", "modules", "rons", "packs", "za", "bes", "zig", "zx", "nox", "zb", "oS", "lol", "webkit", "nz", "los", "zen", "zag", "cfg", "zn", "cos", "budget", "core", "oses", "zes", "robe", "iframe", "outs", "soon", "zh", "ws", "ossus", "owicz", "forge", "ses", "jas", "ozo", "os", "osi", "kos", "zer", "oda", "obb", "zon", "ros", "ops", "inos", "ls", "obs", "rez", "bitcoin", "zik", "abi"], "osw": ["osnow", "esnow", "osfw", "osssw", "bsw", "ossd", "esfw", "lsws", " osow", "ossfw", "osd", "osy", " osww", "isd", " osfw", "osww", "essw", "ossy", "esd", "iswd", "bsws", "esww", "osow", "bx", "bswo", "lsw", "ossow", "oswo", "oswd", "lswo", "isy", "bwo", "isnow", "ossw", "lsx", "bsx", "ossnow", "issw", "esy", "ossww", "esw", "oshell", "osx", "osshell", "esow", "osswd", "bws", "eswd", "ishell", "osws", "eshell", "isw"], "bw": ["bbew", "bbws", "fbw", "bsw", "owu", "bbwh", " baw", "bbz", "fbwd", "bbw", "lbwh", "lw", "owa", "lbx", "fwh", "lwa", "bwu", "oaw", "bW", "abw", "fw", "bbwa", "fwa", "fr", "bwe", " bew", "Bew", "ebwe", "Bwa", " bz", "ebwd", " bwu", "bx", "lsw", " bws", "bew", " bwa", "Bw", "bbwu", " bwh", "lbr", "Bws", "abwd", "abwe", "lbws", "ebw", "lbwa", "fbW", "bwa", "fsw", "lbsw", "fbwe", "bwd", "bz", "lbw", "lbz", "ebW", "bws", "bwh", "baw", "ow", "bbaw", "abW", "lx", "fx"], "zot": ["Ziot", "jori", "Zor", "azit", " ziot", "zerori", "azita", "jot", "zerot", " zor", "Zot", "zeros", "zerott", "Zott", "azot", "ziot", "azott", "zor", "zerit", "Zit", "zerita", "jit", " zori", "zita", "jos", "zott", "aziot", "Zita", "azor", "zori"], "ifp": [" ifl", " iff", " ifb", "ipp", " ifi", "ifl", "Iff", "ipl", "ifc", "ifb", "IFc", "iff", "ipc", "ipb", "IFi", "IFf", " ifc", "Ifc", "ifi", "Ifp", "IFl", "IFb", "IFp", "Ifi"], "zis": ["jisi", "zip", "zeiss", "jis", "zib", "zipits", "xis", "xit", "zais", "zIS", "Zip", " zib", "xits", "xisi", "jits", "Ziss", "zenis", "Zits", " zIS", "ziss", "zeis", "zenIS", "zipiss", "zipis", "zeip", "xais", " zais", "xib", "zisi", "xIS", "zipip", "zeits", "Zis", "jit", "zenais", " zisi", "zenib", " zits", "zits"], "isr": ["ispr", "rispr", "isrc", "ISsr", "risr", " iscr", " isrs", "irpr", "ISrc", "isssr", "IScr", "isrb", "irrb", "ISr", " issr", "iscr", "isscr", "risrb", "risrc", "ISpr", "issr", "irr", "isrs", "ISrb", "ISrs", "irrc", "issrs"], "br": [" BR", "obl", "bh", "HR", "rib", "ibr", "lr", "fr", " dr", "mr", "rs", "shr", "bro", "obi", "arr", "BR", "bar", " fr", "rb", "ctr", "browser", "ocr", "r", "ch", "Br", "str", "ob", "div", " Br", "body", "ibl", "yr", "gr", "cro", "tr", "bc", "bp", "hr", "b", "kr", "bl", "err", "sp", "bsp", "ber", "sr", "img"], "zit": ["jita", "zip", "jite", "zeIT", "jic", "zite", "jIT", " zi", "zenits", "zipita", "zitter", "zipits", " zite", "xit", "xith", "zIT", "zipite", "zic", " zip", "zeith", "ji", "zenith", "zeitter", "jits", "zith", " zith", "zenitter", "jip", "zeita", "zenit", "zi", "zipitter", "zipip", " zic", "xi", "zipith", "jith", "zipIT", "zeits", "zeit", "jit", "zita", "xic", " zits", "zits", "zipit"]}}
{"id1": "1371265", "id2": "11005804", "code1": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"update": ["index", "info", "resource", "replace", "UPDATE", "add", "report", "json", "table", "run", "set", "write", "save", "query", "updated", "post", "select", "data", "Update", "request", "append", "delete", "insert", "edit", "apply", "create"], "channelPath": ["filepath", " channelMap", "filePath", "downloadPath", "downloadpath", "downloadObject", "fileObject", "resourcepath", "resourceObject", "downloadMap", " channelObject", "resourcePath", "resourceMap", " channelpath", "fileMap"], "dataField": ["DataField", "dataFIELD", "dataArea", "resourceField", "DataTerm", "resourceTerm", " datafield", "alphaTerm", "responseField", "alphaArea", "responseTerm", "alphaTable", "responseFIELD", "datafield", " dataArea", "DataArea", " dataTerm", "alphaField", "dataTerm", " dataTable", "responsefield", "DataTable", "resourcefield", " dataFIELD", "dataTable", "resourceFIELD"], "fatherDocId": ["fatherFileName", "fatherDocumentName", "fatherDocName", "fatherFileid", "motherDocumentName", "motherDocumentId", "fatherDocumentID", "fatherFilePath", "fatherPoid", "fatherdocId", "fatherFileInfo", "motherDocid", "fatherdocInfo", "fatherDocid", "fatherDocumentId", "fatherdocName", "fatherDocumentPath", "fatherDocID", "motherDocInfo", "fatherPoId", "motherDocID", "fatherWriterid", "motherDocumentPath", "motherDocName", "fatherDocInfo", "motherDocumentid", "fatherWriterInfo", "fatherWriterName", "motherDocumentID", "fatherWriterId", "motherDocPath", "motherDocId", "fatherDocumentInfo", "fatherPoID", "fatherWriterID", "fatherdocPath", "fatherPoName", "fatherDocPath", "fatherFileID", "fatherDocumentid", "motherDocumentInfo", "fatherFileId"], "sqlInitial": [" sqlInit", "queryFinal", "sqlFinal", "qlInitial", "SQLInitialized", "qlFinal", "sqlinitial", "SQLInitial", "queryInitial", " sqlinitial", " sqlInitialized", "queryinitial", "SQLinitial", "sqlInitialized", "qlInitialized", "qlinitial", "SQLFinal", "SQLInit", "sqlInit", "qlInit", "queryInit"], "sqlsortURL": ["sqllaltURI", "sqlsORTURI", "sqlsourceURI", "sqlsendUrl", "sqlsourceSSL", "sqlsORTurl", "sqLSorturl", "sqlsaltURI", "sqllortUrl", "sqlsourceUrl", "sqlssortURL", "sqlssortURI", "sqLSortURL", "sqLSORTurl", "sqlsendURL", "sqLSORTURI", "sqlsendSSL", "sqlsortUrl", "sqlsORTUrl", "sqlsourceurl", "sqlsorturl", "sqllaltUrl", "sqllaltSSL", "sqllortSSL", "sqlsortURI", "sqllortURI", "sqlsORTURL", "sqlsaltURL", "sqLSORTURL", "sqlsourceURL", "sqllaltURL", "sqlsaltUrl", "sqlssorturl", "sqlssortUrl", "sqLSortUrl", "sqLSortURI", "sqlsendURI", "sqllortURL", "sqlsortSSL", "sqLSORTUrl", "sqlsaltSSL"], "conn": ["Connection", "core", "Conn", "cc", "n", "rc", "enc", "lock", "res", "net", "con", "c", "act", "ht", "pub", "col", "Connect", "co", "rt", "dc", "en", "nc", "client", "sync", "nt", "syn", "cp", "session", "pr", "ct", "connection", "ch", "cat", "ca", "ens", "p", "coll", "ci", "oss", "dn", "cr", " con", "ann", "oci", "db", "pc", "mc", "ctx", "sql", "orp", "conf", "reg", "connect", "cn", "ds", "cs", "apt", "pt", "pg"], "rs": ["ys", "maps", "DS", "sc", "sels", "rc", "results", "res", "RS", "ks", "ns", "vers", "rg", "qs", "s", "bs", "ins", "rt", "mr", "ms", "hs", "rb", "its", "arch", "pr", "ra", "ros", "pers", "ocr", "lines", "r", "runs", "ans", "ows", "xs", "ras", "src", "asts", "rep", "rys", "ts", "rr", "vs", "ris", "rss", "ges", "obs", "rx", "ats", "ars", "cr", "rors", "rows", "ues", "rl", "hr", "acks", "ds", "cs", "rd", "repl", "icks", "sr", "Rs", "PS"], "ps": ["ys", "pps", "DS", "pres", "fs", "LS", "res", "RS", "pse", "Ps", "ns", "ks", "con", "pre", "ples", "posts", "s", "bs", "ins", "pl", "co", "pass", "ms", "syn", "ws", "pr", "pp", "ros", "ons", "pers", "pm", "ports", "eps", "ans", "ups", "ens", "gs", "ras", "ips", "p", "pex", "aps", "ts", "vs", "po", "ars", "pos", "ss", "jp", "pc", "amps", "pa", "pe", "sp", "ds", "cs", "os", "pt", "pg", "Rs", "PS"], "dbo": ["ldbo", "mdbc", "bpo", "bbo", "dbc", "ldBo", "dBo", "dbi", " dpo", " dba", " dbc", " dBo", "mdbo", "Dbi", "ldba", "bBo", " dbi", "dba", "dpo", "mdba", "Dbo", "ldbc", "mdBo", "Dpo", "bbi", "DBo"], "url": ["string", "path", "ssl", "address", "id", "uri", "resource", "username", "response", "server", "feed", "http", "filename", "rel", "html", "l", "location", "host", "URL", "fr", "hl", "fl", "email", "rule", "source", "q", "date", "r", "str", "data", "file", "text", "route", "src", "nl", "page", "ll", "language", "request", "href", "name", "force", "image", "blog", "sl", "rl", "layer", "Url", "www", "ur", "f", "download", "view", "loc"], "st": ["sta", "stress", "string", "rest", "sc", "ust", "ST", "est", "ast", "l", "s", "fr", "rt", "inst", "ft", "ld", "std", "St", "la", "Str", "pr", "sb", "ste", "ost", "str", "r", "ut", "ist", "src", "nd", "cl", "x", "p", "start", "sth", "t", "cr", "ss", "sl", "const", "th", "sh", "pe", "sp", "bl", "stack", "sw", "sn", "rd", "pt", "stri", "sts", "stop"], "sortDocId": ["sortdocID", "sortdocid", "updateDocumentid", "sortdocId", "sortDepID", "updateDocumentInfo", "sortDocumentPath", "sortDepId", "sortPageId", "sortDocid", "sortDocumentid", "sortDocumentId", "sortDocID", "sortDOCName", "sortDocumentInfo", "sortFileId", " sortFilePath", "sortDOCID", " sortDocName", " sortDocInfo", "sortWriterName", " sortDocumentid", "sortdocName", "updateDocId", " sortDocumentName", "sortDepName", "sortdocPath", "updateDocumentID", "sortPageName", "sortPageID", "sortFileInfo", "updateDocID", "sortFileID", "sortDocInfo", "sortDOCId", " sortDocumentId", "sortWriterID", " sortDocid", "sortDocumentName", "sortDOCid", "sortWriterid", "sortdocInfo", "sortFilePath", "sortDocName", "sortPageid", "updateDocid", "sortFileid", " sortFileId", " sortFileID", " sortDocPath", " sortFileInfo", "sortDocumentID", "sortDocPath", " sortDocID", "sortDepid", " sortDocumentID", "sortDepInfo", "sortWriterId", "updateDocInfo", "updateDocumentId"], "flag": [" Flag", "string", "lag", "fun", "id", "ind", "FLAG", "standard", "child", "match", "tag", "arg", "ret", "func", "char", "key", "offset", "flags", "only", "fl", "sync", "part", "use", "binary", "debug", "kind", "str", "cat", "store", "data", "file", "agg", "ag", "star", "inline", "format", "start", "bit", "force", "status", "blog", "leaf", "ext", "bug", "prop", "bool", "wait", "count", "Flag", "field"], "sqlsort": ["sqlssort", " sqLSsort", " sqlsORT", "sqlessort", " sqlesorter", " sqLSort", "sqlesorter", "sqLSorter", "sqlsorts", "sqsort", "sqllorter", "sqLSsort", " sqlsorted", " sqlsorts", " sqlesort", " sqlesORT", " sqLSorts", " sqlssort", "sqllORT", "sqlesorts", "sqLSorts", "sqLSORT", "sqlsORT", "sqLSort", "sqlsorter", "sqllort", "sqsORT", "sqlesorted", " sqlsorter", "sqllorted", "sqssort", "sqLSorted", "sqlesort", "sqlesORT", " sqLSORT", "sqsorts", "sqlsorted", " sqlesorted"], "sortURL": ["ortUR", "searchUR", " sortUR", "updateURI", "updateURL", " sortURI", "editURL", " sortID", "sorturl", " sortSSL", "altURL", "altSSL", "sortUR", "ortURI", "ortURL", "altUR", "altUrl", "updateUR", "updateSSL", " sortUrl", "ortID", "editurl", "searchURI", "Sorturl", "SortUrl", "editUR", " sorturl", "searchURL", "sortID", "SortUR", "searchUrl", "ortUrl", "sortUrl", "ortSSL", "SortURL", "editUrl", "sortURI", "searchID", "sortSSL"], "sortflag": ["considerflags", "addressfeed", "ortflags", "considerfeed", "sortfeed", "sortlike", "filtertype", "addresslike", "addressflags", "filterFLAG", "considerlike", "ortFLAG", " sortFlag", " sortFLAG", "orttype", " sorttype", "ortlike", "ortflag", "sortFlag", "ortFlag", "sortflags", "SortFLAG", "Sortflag", "addressflag", "filterflag", "sortFLAG", "ortfeed", "SortFlag", "sorttype", "considerflag"]}}
{"id1": "9275622", "id2": "18696387", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFolder", "moveFile", " copyfile", "moveFolder", "copyfile", "transferfile", "moveFiles", "copyFolder", " copyFiles", " copyFolder", "transferFiles", "movefile", "copyFiles", "transferFile"], "_file1": ["_f1", "_mail2", "_resource1", "_mail1", "_fileone", "_zip1", "_mail0", "_resourceFirst", "_zipFirst", "_fFirst", "_file0", "_fOne", "_files2", "_files1", "_File0", "_resourceone", "_files01", "_fileFirst", "_zipOne", "_mail01", "_zipone", "_fone", "_File1", "_files0", "_File2", "_File01", "_file01", "_fileOne", "_resourceOne"], "_file2": [" _files3", "_playsecond", " _files2", " _filesTwo", "_filesecond", "_playTwo", " _files4", "jmodel2", "_model5", " _fileTwo", "_files3", "jmodelsecond", "_files2", "_play1", "jmodel1", "jmodel5", "_Filesecond", "_modelsecond", " _file4", "_files4", "jfilesecond", "jfile1", "_model1", "jfile2", "_filesTwo", "_file5", "_play2", "_model2", "_play4", "_file4", "_File2", "_File1", "_file3", "_fileTwo", "jfile5", "_play5", " _file3", "_File5", "_play3"], "fis": ["Fris", "fais", " fais", " fris", "cfas", "cfis", "fi", " fiss", "fris", "Fils", "lfis", "infis", "infiss", "lfiss", "infos", "lfi", "afis", "afais", "cfos", "lfais", " fi", "Fis", "Fos", "Fas", "afi", "infils", " fas", "fas", "cfiss", "cfris", " fils", "fiss", "afiss", "Fiss", "fils"], "fos": ["gis", " faos", "pOS", "info", " fros", " foos", "lis", "flos", "poes", "infaos", "fros", "infoos", "infus", "feis", "Fus", "foos", "loes", "floes", "feus", "fus", "infos", "infros", " fus", "infios", "pis", "Foos", "gos", "flis", "goses", "foses", "Fis", "Fos", "Fros", "fios", "fo", "pos", "gus", "flOS", "feoses", "lOS", "Fo", "Foses", " fo", "Fios", "los", "feos", "faos", " fios", "foes", "Faos", "fOS"], "canalFuente": ["canalKuence", "canalBuje", "canalBuence", "canalFuje", "canalsFuento", "canalsBuence", "canalsFuente", "canalBuestro", "canalKuencia", "canallBuze", "canalFUje", "canallFuencia", "canalSuente", "canalFUencia", "canaledFuestro", "canallBuence", "canalBuze", "canalsBuencia", "canalFuze", "canalsBuento", "canalFUente", "canalKuento", "canallBuencia", "canalsBuente", "canaledFuze", "canalSuze", "canalCraente", "canalFuestro", "canalFUze", "canalKuze", "canalsFuence", "canalFUestro", "canaledFuje", "canalKuente", "canalBuente", "canaledBuestro", "canalFuence", "canalSuestro", "canaledFuente", "canallFuente", "canaledBuente", "canallBuente", "canalFuento", "canalsFuencia", "canalCraencia", "canaledBuze", "canallFuence", "canalBuencia", "canalCraento", "canalFuencia", "canalBuento", "canalFUence", "canaledBuje", "canallFuze", "canalSuje", "canalCraence"]}}
{"id1": "9796161", "id2": "17901739", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "label": 0, "substitutes": {"getMD5": ["getmd4", " getSHAHash", "getMD512", "getSHA512", "getmdHash", " getSHA5", "getmd512", "getmd5", "getHTML4", "getSHA4", "getHTMLHash", " getMD4", "getMD4", "getSHA5", " getMDHash", " getMD512", " getSHA4", "getMDHash", "getSHAHash", " getSHA512", "getHTML512", "getHTML5"], "s": ["services", "string", "ssl", "i", "input", "self", "n", " ads", "ns", "comments", "c", "S", "l", "styles", "bs", "abs", "si", "is", "ates", "in", "rs", "ms", "ings", "parts", "sync", "its", "ws", "source", "lines", "sb", "strings", "str", "g", " fails", "data", "gs", "ends", "ows", "scripts", "ips", "p", "es", "ts", "js", "e", "ls", "sets", "tests", "ss", "sym", "bytes", "a", "ses", "b", "v", "ds", "cs", "als", "os", "f", "ps"], "m": ["om", "tm", "mu", "um", "i", "arm", "vm", "M", "c", "l", "am", "wm", "mr", "manager", "ms", "sm", "ym", "cm", "mac", "d", "pm", "machine", "md", "mm", "h", "mi", "p", "hm", "fm", "e", "t", "dm", "mut", "nm", "mc", "mand", "me", "em", "v", "bm", "rm", "man", "f", "gm", "im", "module"]}}
{"id1": "8132219", "id2": "5399593", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "inFile": ["inputPlace", " inSourceFile", "InSourceFile", "INfile", "binfile", "outPlace", "inputfile", "outfile", " infile", "infile", "inputFile", "outFiles", "InFilename", " inFilename", "Infile", "inFiles", "inPlace", "inputFiles", "binFiles", "binFile", "INFile", "binPlace", "InFile", "INSourceFile", "inFilename", "inSourceFile", "INFilename"], "outFile": ["againFilename", "outputFilename", "outputfile", "againFile", " outfile", "outPlace", "outfile", "infile", "outFiles", "outputPlace", " outFilename", "inFiles", "againfile", " outFiles", "outputFiles", "againPlace", "outFilename", "inFilename", "outputFile", " outPlace"], "in": ["IN", "index", "pin", "base", "i", "input", "id", "n", "ini", "ic", "c", "inner", "as", "ins", "bin", "is", "part", "like", "reader", "source", "connection", "inc", "work", "data", "file", "config", "rin", "x", "name", "again", "m", "image", "io", "In", "a", "url", "inn", "f", "din"], "out": ["string", "buffer", "ex", "output", "n", "copy", "resource", "user", "Output", "plain", "c", "OUT", "version", "o", "outs", "write", "line", "bin", "client", "part", "cache", "dot", "default", "w", "data", "file", "x", "p", "log", "null", "conn", "name", "exec", "Out", "io", "image", "writer", "to", "call", "prefix", "ext", "v", "b", "obj", "external"], "inChannel": ["sinSocket", "INSocket", "inSocket", "inputChannel", "INchannel", "iniChannel", "inStream", " inFlow", " inchannel", "inputchannel", "inchannel", "INFlow", "sinChannel", "inLanguage", "sinChan", "iniLanguage", "winLanguage", "inputChan", "iniStream", "INChan", "outStream", "outchannel", "outChan", "inChan", "inputStream", "inichannel", "outConnection", "INStream", "winChannel", "winchannel", " inConnection", "INChannel", "inConnection", " inChan", "winStream", "sinFlow", " inSocket", "inFlow", "INConnection", "outLanguage"], "outChannel": [" outContext", "OutStream", "againChannel", "OutConnection", "OutChannel", "inchannel", "outContext", " outConnection", "againPath", "againChan", "OutChan", "outStream", "outchannel", "inPath", "outChan", "inChan", "outPath", "OutContext", "outputchannel", "outputChannel", " outPath", "outConnection", "newStream", "Outchannel", "newChan", "againchannel", "outputChan", "inConnection", " outStream", "newContext", "newChannel", " outchannel", " outChan"]}}
{"id1": "23161545", "id2": "7372311", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 1, "substitutes": {"getRandomGUID": ["getRandomGCuid", "getRandUuid", "getRandGid", "getRandomGID", "getRandomIGuid", "getRandomGuid", "getRandomGid", "getRandUID", "getRandGID", "getRandomUID", "getRandomGCid", "getRandomIGID", "getRandomGCID", "getRandomUUID", "getRandGuid", "getRandomGCUID", "getRandomUid", "getRandomIGUID", "getRandomUuid", "getRandGUID", "getRandUid", "getRandomIGid", "getRandUUID"], "secure": ["zip", "remote", "ssl", "server", "timeout", "secondary", "smart", "confirmed", "weak", "host", "active", "security", "allow", "session", "use", "ce", "seed", "proxy", "debug", "exclusive", "config", "sensitive", "https", "require", "safe", "encrypted", "unsigned", "force", "stable", "pure", "Secure", " insecure", "service", "secret", "random", "deep", "protect", "sr", "sec", "external", "depth"], "md5": ["MD500", "cmdql", " md500", "cmd3", "mdql", " mdql", " md3", "MD11", "md2", " MD3", "MD5", " MD11", "md500", "MD3", "MD512", "MD2", "MDql", "md3", " md2", " MD2", "md512", " md512", "md11", " MD5", "cmd5", " MD500", "cmd512", " md11"], "sbValueBeforeMD5": ["sbValueBeforeDER0", "sbValueBeforeMD75", "sbValueBeforeMC375", "sbValueBeforeMS5", "sbValueAfterMS3", "sbValueGivenmd375", "sbValuebeforeSD005", "sbValuebeforeMD005", "sbValueBeforeSD20", "sbValueAfterMS65", "sbValuebeforeSD20", "sbValueBeforeMI7", "sbValueAfterMP5", "sbValueAfterMD20", "sbValuebeforeMD5", "sbValueBeforeMD7", "sbValueAfterMS5", "sbValueAfterMS20", "sbValueBeforeMR3", "sbValueBeforemd3", "sbValueBeforeMS7", "sbValueGivenmd512", "sbValueBeforeMS95", "sbValueAfterMD95", "sbValueBeforeMR5", "sbValueBeforeSHA005", "sbValuebeforeSD5", "sbValueBeforeMI1", "sbValueBeforeMAC3", "sbValueAfterMP7", "sbValueAfterMS55", "sbValueAfterMS0", "sbValueBeforeMD95", "sbValueBeforeMS512", "sbValueGivenMD3", "sbValueAfterMD75", "sbValueBeforeSHA20", "sbValueBeforeAMD5", "sbValueBeforemd512", "sbValueBeforeDER3", "sbValueBeforeMAC55", "sbValueBeforeMI20", "sbValueBeforeMS55", "sbValueBeforeMS0", "sbValueBeforeMAC0", "sbValuebeforeMD1", "sbValueBeforeSD005", "sbValueBeforemd5", "sbValueBeforeD5", "sbValueBeforemd25", "sbValueAfterMD5", "sbValuebeforeSD1", "sbValueBeforeD65", "sbValueBeforeMR95", "sbValueBeforemd375", "sbValueBeforemd95", "sbValueAfterMD0", "sbValueBeforeSD1", "sbValueBeforeMD0", "sbValueBeforeMP1", "sbValueBeforeMC5", "sbValueAfterMS25", "sbValueGivenMD375", "sbValueAfterMP3", "sbValueAfterMS1", "sbValueAfterMD25", "sbValueBeforeMC512", "sbValueBeforeMS25", "sbValueBeforeMS1", "sbValueBeforeDER005", "sbValueBeforeMD65", "sbValueAfterMD1", "sbValueBeforeAMD20", "sbValueBeforeDER55", "sbValueGivenmd3", "sbValueBeforeMD20", "sbValueBeforeSD5", "sbValueBeforeMD25", "sbValueGivenMD512", "sbValueBeforeDER20", "sbValueBeforeMS65", "sbValueBeforeMS75", "sbValueBeforeMS375", "sbValueBeforeMAC5", "sbValueBeforeMR25", "sbValueAfterMP1", "sbValueGivenMD5", "sbValueBeforeMP7", "sbValueAfterMS75", "sbValueBeforeSHA1", "sbValueBeforeMD1", "sbValueBeforeMI5", "sbValueBeforeMD512", "sbValueBeforemd65", "sbValueBeforeDER1", "sbValueAfterMD65", "sbValueBeforeMS20", "sbValueBeforeMI3", "sbValueBeforeMP5", "sbValueBeforeMP3", "sbValueAfterMD3", "sbValueBeforeAMD1", "sbValueBeforeMD005", "sbValueBeforeMS3", "sbValueBeforeSHA5", "sbValueBeforeAMD3", "sbValueBeforeMD55", "sbValueBeforeMD3", "sbValueAfterMS95", "sbValueBeforeDER5", "sbValueBeforeMC3", "sbValueAfterMD7", "sbValueBeforeMD375", "sbValueBeforemd75", "sbValueGivenmd5", "sbValueBeforeD3", "sbValueAfterMD55", "sbValuebeforeMD20", "sbValueBeforeD75"], "time": ["event", "cost", "error", "tz", "id", "duration", "user", "timeout", "year", "clock", "version", "slice", "ime", "mode", "loc", "length", "host", "offset", "rate", "type", "money", "TIME", "delay", "date", "value", "seed", "counter", "work", "timer", "size", "tim", "name", "start", "race", "Time", "hour", "random", "etime", "count", "times", "speed", "depth"], "rand": ["index", "root", "order", "max", "id", "lang", "round", "clean", "rc", "year", "rol", "res", "version", "rank", "ro", "alpha", "Rand", "rate", "type", "rule", "rh", "chance", "seed", "delay", "q", "serial", "min", "r", "pick", "gen", "rr", "risk", "bit", "raid", "cr", "bot", "reg", "right", "range", "random", "count", "ng", "mid", "error", "win", "rage", "winner", "depth"], "valueBeforeMD5": ["valueAfterAMD2", "valueBeforeMC5", "valueBeforeMC3", "valueBeforeMC2", "valueBeforeMD85", "valueAfterAMD5", "valueBeforeMP53", "valueBeforeMP2", "valueBeforeMD53", "valueBeforeMP5", "valueBeforeAMD2", "valueAfterAMD53", "valueBeforeMD3", "valueBeforemd5", "valueBeforeAMD3", "valueAfterMD3", "valueBeforemd2", "valueInsideMD5", "valueBeforeMC85", "valueBeforemd85", "valueInsideMD3", "valueBeforemd3", "valueAfterMD53", "valueInsideMD85", "valueAfterMD2", "valueBeforeMP3", "valueAfterAMD3", "valueBeforeAMD53", "valueBeforeMD2", "valueBeforeAMD5", "valueInsideMD2"], "array": ["integer", "string", "audio", "address", "list", "vector", "message", "number", "any", "result", "instance", "record", "database", "arr", "expression", "angle", "allow", "cache", "binary", "value", "our", "Array", "collection", "sample", "data", "feature", "archive", "section", "object", "row", "ray", "arrow", "image", "function", "area", "app", "shape", "pair", "range", "air", "batch", "error", "element", "api", "view", "storage"], "sb": ["buffer", "BB", "sf", "usb", "bf", "bh", "sg", "lp", "lb", "eb", "lab", "cb", "lr", "obb", "s", "bs", "kb", "si", "orb", "nn", "pb", "gb", "mb", "abb", "rb", "sa", "ab", "binary", "wb", "buf", "sv", "ob", "bj", "ruby", "src", "fb", "bb", "sq", "zb", "stab", "sth", "rob", "nb", " SB", "sl", "ib", "bt", "bc", "bp", "xb", "bl", "bm", "bsp", "sbm", "SB"], "j": ["index", "dy", "job", "i", "num", "uj", "n", "ij", "ie", "c", "z", "end", "o", "jl", "l", "length", "jo", "ii", "key", "aj", "part", "ja", "ji", "d", "pr", "q", "ch", "g", "bj", "li", "out", "x", "p", "jj", "J", "js", "e", "jp", "k", "y", "br", "v", "obj", "adj", "f", "code"], "b": ["job", "i", "BB", "bf", "n", "be", "eb", "lb", "c", "cb", "l", "bs", "bin", "orb", "pb", "bar", "mb", "rb", "d", "ab", "binary", "ob", "fb", "bb", "x", "p", "bi", "e", "bit", "nb", "db", "ib", "a", "bc", "B", "bug", "k", "y", "br", "f"], "valueAfterMD5": ["valueAfterMP3", "valueAfterAMD2", "valueAfterMP7", "valueAfterMP5", "valueAfterVM7", "valueAfterAMD5", "valueAfterAMD7", "valueBeforeMP2", "valueBeforeMP5", "valueBeforeMD3", "valueAfterMD3", "valueAfterMD7", "valueAfterVM3", "valueAfterVM5", "valueBeforeMD7", "valueAfterMD2", "valueBeforeMP3", "valueAfterAMD3", "valueBeforeMD2", "valueAfterMP2", "valueBeforeMP7", "valueAfterVM2"]}}
{"id1": "19113613", "id2": "310182", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["zip", "ssh", "Copy", "replace", "move", "clip", "write", "save", "clone", "split", "sync", "cop", "type", "load", "cp", "cat", "upload", " cp", "share", "Cop", "archive", "get", "put", "p", "delete", "change", "update", "create", "paste", "process", "rm", "opy", "transfer", "download"], "in": ["IN", "index", "pin", "base", "i", "input", "id", "n", "sin", "token", "ini", "on", "ic", "c", "inner", "as", "project", "ins", "bin", "client", "part", "reader", "thin", "login", "min", "old", "inside", "diff", "connection", "inc", "work", "data", "config", "get", "init", "plugin", "name", "again", "image", "In", "kin", "a", "url", "update", "lin", "cin", "inn", "f", "win", "this", "din"], "out": ["remote", "goal", "base", "path", "root", "input", "ex", "output", "n", "self", "outer", "user", "resource", "option", "net", "version", "c", "OUT", "project", "o", "outs", "off", "line", "bin", "outside", "client", "part", "at", "one", "cache", "no", "dot", "up", "connection", "other", "group", "inc", "parent", "work", "page", "object", "x", "p", "null", "conn", "init", "again", "name", "exec", "Out", "io", "image", "call", "app", "ext", "v", "b", "err", "obj", "with", "block", "vert", "this", "external", "point"], "source": ["base", "sin", "class", "id", "resource", "uri", "username", "Source", "site", "subject", "project", "dest", "origin", "SOURCE", "iter", "type", "use", "ce", "proxy", "scope", "component", "alt", "feature", "parent", "src", "route", "size", "format", "name", "internal", "force", "status", "family", "prefix", "secure", "position", "url", "pe", "unit", "secret", "reference", "missing", "attribute", "ource", "service", "from", "view", "direction"], "target": ["path", "tail", "base", "address", "root", "goal", "resource", "output", "token", "master", "site", "project", "current", "wrong", "Target", "dest", "origin", "host", "detail", "pattern", "next", "value", "component", "cat", "alt", "arget", "parent", "config", "route", "src", "alias", "null", "format", "about", "template", "name", "force", "home", "prefix", "url", "top", "reference", "service", "point", "direction"], "files": ["keys", "fs", "pages", "results", "resources", "docs", "filename", "features", "assets", "apps", "ins", "Files", "s", "items", "tools", "links", "iles", "lines", "flows", "users", "blocks", "children", "ports", "names", "classes", "data", "images", "objects", "models", "plugins", "groups", "ls", "obs", "jobs", "cells", "ions", "sections", "f"], "file": ["directory", "string", "letter", "base", "path", "fe", "id", "resource", "feed", "ile", "uri", "entry", "filename", "per", "current", "fp", "l", "child", "line", "el", "File", "part", "load", "binary", "dir", "live", "item", "lib", "FILE", " File", "parent", "data", "entity", "local", "page", "object", "le", "single", "name", "folder", "e", "function", "it", "layer", "url", "unit", "b", "future", "f"], "inCh": ["InCh", "outCH", " inCH", "Inch", " inChannel", "InChan", "inChannel", "INChan", " inch", "outChan", "inChan", "InChannel", "INCH", "outch", "inCH", "InCH", "INChannel", "INCh", "inch", " inChan", "outChannel"], "outCh": ["outputCh", " outCH", "outCH", "outputch", "OutChannel", " outChannel", "OutChan", "Outch", "inChannel", "outChan", "inChan", "outch", "inCH", "outputCH", "OutCh", "inch", "outputChan", "OutCH", "outChannel", " outch"]}}
{"id1": "20751378", "id2": "13565787", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "label": 1, "substitutes": {"hashPassword": ["signPassword", "cryptPass", "signpassword", "signWord", "hashPass", "cryptWord", "cryptpassword", "signPass", "cryptPassword", "hashWord", " hashPass", "hashpassword", " hashWord", " hashpassword"], "password": [" Password", "string", "path", "address", "input", "token", "username", "user", "message", "plain", "python", "description", "number", "wd", "pass", "database", "key", "pattern", "content", "security", " passwords", "Password", "cache", "PASS", "mac", "seed", "sha", "w", "sword", "data", "text", "p", "encrypted", "name", "word", "prefix", "secret", "auth", "command", "words", "padding", "pad", "crypt", "phrase", "code"], "hash": ["index", "root", "square", "base", "hex", "number", "match", "host", "tag", "ash", "mac", "rh", "build", "math", "dig", "format", "style", "msg", "url", "string", "address", "id", "oh", "proof", "result", "html", "security", "cache", "value", "work", "search", "addr", "hed", "array", "secret", "handle", "phrase", "pkg", "replace", "gh", "ashes", "message", "json", "length", "memory", "sha", "alt", "h", "update", "uild", "height", "error", "sum", "her", "ssh", "copy", "user", "version", "kh", "Hash", "pool", "key", "text", "ruby", "check", "put", "log", "ha", "call", "dump", "sh", "auth", "history", "bolt", "mod", "code"], "md": ["gd", "mag", "bd", "od", "df", "Cmd", "amd", "kg", "ma", "am", "meta", "wd", "MD", "ME", " MD", "ms", "sm", "gb", "mb", "mt", "dh", "d", "mac", "xd", "sha", "hd", "pm", "pd", "sd", "mm", "nd", "metadata", "dig", "m", "km", "hm", "dm", "grad", "mand", "mc", "der", "nm", "mod", "vd", "mg", "mad", "f", "cmd", "dd"]}}
{"id1": "7458833", "id2": "15768167", "code1": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyParseFileToCodeFile": [" copyParseFileToMapFile", " copyParseFileTocodeClass", " copyParseFiletoCodeClass", " copyParseFiletoOutputfile", " copyParseFileTocodefile", " copyParseFileToCodefile", " copyParseFileToCodeFiles", " copyParseFileTocodeFiles", " copyParseFileToOutputfile", " copyParseFiletoCodefile", " copyParseFileToCodeClass", " copyParseFileToMapFiles", " copyParseFiletoCodeFile", " copyParseFileToOutputClass", " copyParseFileToOutputFiles", " copyParseFiletoOutputFiles", " copyParseFileToMapfile", " copyParseFileToMapClass", " copyParseFiletoCodeFiles", " copyParseFiletoOutputFile", " copyParseFileTocodeFile", " copyParseFiletoOutputClass", " copyParseFileToOutputFile"], "in": ["IN", "impl", "pin", "i", "input", "id", "n", "ini", "gin", "ic", "con", "inner", "socket", "as", "ins", "bin", "is", "read", "reader", "up", "login", "min", "inside", "r", "inc", "rin", "oin", "get", "init", "ls", "again", "m", "io", "image", "In", "nin", "kin", "pull", "stream", "lin", "err", "cin", "inn", "f", "win", "din"], "out": ["i", "ex", "output", "n", "outer", "server", "user", "net", "plain", "OUT", "socket", "as", "inner", "o", "outs", "bin", "post", "sync", "client", "one", "source", "cache", "up", "other", "inc", "w", "work", "file", "parent", "log", "conn", "again", "exec", "Out", "io", "writer", "image", "exp", "ext", "err", "this"], "buffer": ["event", "string", "capacity", "address", "total", "Buffer", "input", "uffer", "feed", "server", "duration", "pause", "sequence", "slice", "document", "limit", "number", "result", "read", "queue", "iter", "uf", "raw", "source", "cache", "binary", "buff", "buf", "wave", "data", "channel", "fb", "request", "null", "available", "array", "layer", "position", "base", "shape", "reference", "count", "padding", "pad", "batch"], "length": ["index", "string", "total", "address", "path", "duration", "id", "feed", "lock", "sequence", "character", "slice", "end", "number", "limit", "volume", "l", "match", "line", "time", "weight", "offset", "part", "type", "load", "before", "value", "len", "Length", "ob", "level", "size", "bb", "row", "style", "view", "start", "full", "pull", "position", "url", "partial", "shape", "range", "ength", "distance", "repeat", "count", "block", "width", "code", "point"]}}
{"id1": "15018553", "id2": "18211588", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"encrypt": ["Encrypt", "Enccrypt", "encryption", "secipher", "decryption", "seccrypt", "Encryption", "secryption", "decipher", "Encipher", "encipher", "secrypt", "enccrypt", "deccrypt", "decrypt"], "text": ["letter", "string", "path", "address", "buffer", "class", "input", "output", "token", "Text", "message", "TEXT", "sequence", "hex", "number", "length", "key", "pattern", "content", "password", "txt", "source", "binary", "seed", "connection", "str", "config", "data", "object", "struct", "test", "name", "template", "image", "font", "word", "bytes", "ext", "secret", "contract", " Text", "transfer", "method", "code"], "md": ["mk", "pkg", "cmp", "mag", "bd", "od", "df", "Cmd", "amd", "message", "mo", "ma", "am", "meta", "dr", "wd", "MD", " MD", "ms", "ld", "sm", "ad", "gb", "cm", "mb", "mt", "mac", "d", "mp", "hd", "sha", "pm", "pd", "data", "cmd", "mm", "metadata", "mi", "dig", "pg", "m", "hm", "dm", "db", "mand", "mc", "mn", "me", "em", "rm", "mg", "mod", "dd", "hash"], "md5hash": [" md5Hash", " md4log", "md512hash", "md4block", "md6hash", " md5log", "MD5key", "md4log", "md6hex", " md5block", " md4block", "md5Hash", "md6Hash", "md6log", " md4Hash", "md256key", "md5hex", "md4sum", "md4Hash", "md2Hash", "MD5hex", " md5sum", "md7Hash", "md25hash", "md5sum", "md256hex", "md5log", "md25sum", "MD512hash", "md2block", "md25Hash", "md5block", "md7hash", "md512hex", " md4hash", "md7block", "md7sum", "MD512hex", "md5key", "md256hash", "md6sum", "md25log", "MD512key", "md2sum", "MD5hash", "md6key", "md4hash", " md4sum", "md2hash", "md512key"]}}
{"id1": "19739421", "id2": "16719805", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": [" UnknownOptionception", "UnknownOptionsError", "UnknownOptionsException", "UnknownOptionsception", "UnknownOperationException", "UnknownParameterError", "UnknownOperationError", "UnknownOperationception", "UnknownOptionception", " UnknownOptionsError", "UnknownParameterException", " UnknownOptionError", "UnknownOptionError", " UnknownOptionsException", " UnknownOptionsception", "UnknownParameterception"], "cmdLineParser": ["mdlineBuilder", "mdLRunner", "cmdEntryParser", "cmdEntryMaster", "cmdlineHelper", "cmdServicearser", "commandlineReader", "cmdStringReader", "mdLineRunner", "cmdServiceParser", "cmdLarser", "cmdSiteWriter", "cmdStringparser", "cmdStringBuilder", "mdlinearser", "mdLineBuilder", "cmdBlockparser", "cmdlineBuilder", "cmdBlockarser", "cmdFileReader", "mdLineParser", "cmdLinParser", "cmdByteMaster", "commandLineReader", "cmdFileParser", "mdLarser", "cmdEntryarser", "commandLineParser", "cmdLineReader", " cmdLarser", "cmdLinMaster", "cmdLineHelper", "cmdLMaster", "cmdSiteParser", "mdLinearser", "cmdlineparser", "cmdLineparser", "commandLineMaster", " cmdLParser", "cmdlinearser", "mdLJar", "commandlineJar", "cmdLineRunner", "cmdFilearser", "mdLineWriter", " cmdLJar", "mdLineReader", "mdLineparser", "cmdBlockMaster", "cmdBlockBuilder", "cmdLBuilder", "mdLReader", "cmdStringHelper", "cmdByteParser", "cmdStringMaster", "cmdLinReader", "mdlineWriter", " cmdLinearser", "cmdEntryJar", "mdLParser", "cmdSiteparser", "cmdlineWriter", "cmdlineMaster", "cmdBlockWriter", "cmdStringParser", "cmdLineJar", "commandlineMaster", "cmdLJar", "cmdlineReader", "mdLineJar", "cmdFileJar", "cmdlineParser", "cmdByteWriter", "cmdStringRunner", "cmdlineJar", "mdLineHelper", "mdlineJar", "cmdLRunner", "cmdServiceJar", "cmdSiteJar", "cmdBlockParser", "cmdLinJar", "cmdLineMaster", "commandlineParser", "cmdStringWriter", "mdlineMaster", "cmdStringarser", "mdLHelper", "commandLineJar", " cmdLineMaster", "cmdLparser", "cmdLReader", "cmdLParser", "cmdLineWriter", " cmdLMaster", "cmdStringJar", "cmdFileMaster", "cmdBlockJar", "cmdServiceMaster", "cmdByteJar", "cmdLineBuilder", "cmdFileRunner", "cmdLHelper", "mdLineMaster", "cmdLinearser", "mdlineParser", " cmdLineJar", "mdlineparser"], "formatOption": ["FormatOperation", "typeParameter", "printfOpt", "formatOperation", " formatElement", "FormatOption", " formatVariable", " formatOperation", "FormatElement", "FormatOpt", " formatOpt", "lengthOpt", "formatVariable", "formatOpt", "lengthParameter", "printfOperation", "lengthOption", "formatParameter", "lengthVariable", "printfOption", "typeOption", "printfElement", "typeOpt", "typeVariable", "formatElement", " formatParameter"], "outputEncodingOption": ["outputCasingOptions", "outputCodingOperation", "outputEncodingOptions", "outputEncordingParameter", "outputEncodingParameter", "outputEncordingOpt", "outputEncodingOpt", "outputCasingOption", "outputCodingOptions", "outputCasingOpt", "outputEncoderOperation", "outputEncitingOpt", "outputEncasingOpt", "outputCodingOption", "outputEncitingOperation", "outputEncoderOption", "outputEncordingOperation", "outputEncasingOption", "outputCasingOperation", "outputCasingParameter", "outputCodingOpt", "outputEncordingOptions", "outputEncoderParameter", "outputEncasingParameter", "outputEncitingOption", "outputEncodingOperation", "outputCodingParameter", "outputEncitingOptions", "outputEncoderOpt", "outputEncordingOption", "outputEncasingOptions", "outputEncasingOperation"], "inputEncodingOption": ["inputChodingOpt", "inputEncodedFunction", "inputChasingOption", "inputEncasingFunction", "inputEncodingOpt", "inputEncasingOpt", "inputChodingFunction", "inputEncasingOption", "inputEncodingOperation", "inputEncachingOpt", "inputChasingOperation", "inputEncoderOperation", "inputChachingOption", "inputEncodedOperation", "inputEncachingOperation", "inputEncoderOption", "inputEncoderOpt", "inputChasingFunction", "inputChodingOperation", "inputChachingOperation", "inputChodingOption", "inputEncodingFunction", "inputEncasingOperation", "inputEncoderFunction", "inputEncachingOption", "inputChachingOpt", "inputEncodedOption"], "format": ["letter", "string", "output", "option", "filename", "version", "place", "html", "api", "host", "quality", "layout", "sort", "Format", "pattern", "alpha", "form", "filter", "at", "type", "value", "target", "cat", "feature", "config", "file", "term", "export", "size", "language", "ant", "style", "plugin", "title", "template", "name", "pretty", "writer", "prefix", "service", "unit", "atter", "command", "printf", "attribute", "f", "scale", "transform", "license"], "outputEncoding": ["outputDecoder", "outputEncoring", " outputEngoder", "outputOctoring", "outputDecoding", " outputEngoding", "outputEncining", "outputEngording", "outputOctoder", "outputChaching", " outputEncining", "outputEntaping", "outputEncording", "outputEngaching", "outputEncryption", "outputChording", "outputChoder", "outputEnaping", " outputEngording", "outputSequoder", "outputSequoding", "inputEncoder", "outputCompasing", "inputChoring", "inputEncasing", "outputEnining", "outputEntasing", "outputCompoding", "inputChording", "outputChaping", "outputOctoding", "inputChoder", " outputEncoder", "outputOctasing", "outputencoding", "outputChoding", "outputDecasing", "inputChasing", "outputDecording", "inputEncryption", "outputEncaching", "outputEncaping", " outputEncaching", "outputChasing", "outputChoring", "outputEnasing", "outputEncoder", " outputEntining", "outputCompoder", "outputEncasing", "outputEnoding", "inputEncording", "outputSequasing", "outputencording", " outputEncasing", "outputChryption", " outputEncaping", " outputEntasing", "inputEncoring", "outputencaching", "outputEntryption", "inputChryption", " outputEngaching", "outputencoder", "outputChining", "outputSequryption", "outputEngoder", "outputEntoder", " outputEntaping", "outputEntoding", "inputChoding", "outputEntining", " outputEncording", "outputEngoding", " outputEntoding", "outputCompording"], "inputEncoding": ["inputEnasing", "inputEncapping", "outputEncapping", "inputExplasting", " inputDecording", "inputEncasting", "inputEnode", "inputEncasing", "variableExplode", "variableEncode", "outputChasing", " inputEncacing", "inputChording", "inputEncacing", " inputDecoding", "outputEncoder", "inputEnoding", "inputEngapping", "inputDecording", "inputChapping", "inputChoder", "variableExplasting", "outputEncasing", "inputChasting", "inputChoding", "inputDecacing", "inputExplode", "inputEncording", "variableExploding", "inputChacing", " inputEncording", "inputEnoder", "variableEncasting", "inputEnacing", "inputExploding", "variableEncasing", " inputEncoder", "inputDecoding", "inputEnapping", "inputDecoder", "inputEngasing", "outputChoding", "inputChode", "outputChoder", " inputDecacing", "inputEnording", "inputEngoder", "outputChapping", "inputChasing", "variableEncoding", " inputDecoder", "inputEncode", "inputEnasting", "variableExplasing", "inputEngoding", "inputEncoder", "inputExplasing"], "remainingArgs": ["regainedArgs", "RemangingArg", "RemingParts", "remingGS", "remainingargs", "remangingArgs", "remainGS", "RemingLong", "remendingArg", "RemingGS", "removingLong", "remainArgs", "remainingParameters", "resainingargs", "resainingLong", "resainArgs", "remainLong", "removingParts", "remingParts", "remendingArray", "resainedParts", "remainsArgs", "remainargs", "remainingAr", "RemainingArg", "resainingArray", "regainingGS", "RemingArgs", "remainingArray", "remingLong", "remainingLong", "remingArgs", "resainargs", "regainingArgs", "remendingArgs", "resainArray", "remangingParts", "remainArg", "resainedArg", "RemangingParts", "resainedArgs", "resainingArgs", "RemangingArgs", "regainingParameters", "resainingArg", "remainParameters", "remainAr", "remainsAr", "remainedGS", "resainingParts", "remainArray", "regainedArg", "resainedLong", "RemainingGS", "remangingParameters", "remendingargs", "remangingAr", "regainedGS", "RemainingParts", "remangingLong", "remainsParts", "RemangingAr", "remainingArg", "removingGS", "RemainingLong", "remainingGS", "remangingArg", "RemainingArgs", "remainedargs", "resainArg", "remangingGS", "remainParts", "remainedArray", "remainedParts", "remainingParts", "RemainingAr", "regainingArg", "regainedParameters", "remainedArgs", "remainedArg", "remainsArg", "removingArgs", "remainedLong", "remainedParameters"], "inputFile": [" inputDir", "InputDirectory", "localSourceFile", "InputDir", "sourceDir", "localDirectory", "inputfile", "inputSourceFile", " inputfile", "sourcePath", "sourceLine", " inputSourceFile", "sourceFile", "InputLine", "inputPath", "InputFile", " inputStream", "inputLine", "inputDir", "Inputfile", "localFile", "inputStream", "sourcefile", " inputLine", "InputSourceFile", "localDir", "sourceDirectory", "sourceStream", "InputPath", "inputDirectory", "InputStream", " inputPath", " inputDirectory"], "outputFile": [" outputMessage", "outputfile", "outputFolder", "OutputFile", "OutputHeader", "OutputFolder", " outputFolder", "OutputMessage", "outputMessage", "outputPath", "exampleStream", "productionPath", "operationFile", "operationHeader", "OutputStream", "productionMessage", " outputStream", " outputPath", "exampleFolder", "outputStream", " outputfile", "operationfile", "exampleFile", "Outputfile", "examplefile", "outputHeader", "productionFile", "OutputPath", " outputHeader", "productionfile", "operationFolder"], "out": ["info", "sum", "temp", "outer", "output", "server", "copy", "lock", "builder", "pre", "OUT", "outs", "write", "flow", "manager", "co", "line", "in", "post", "raw", "client", "session", "cache", "up", "debug", "group", "ger", "parent", "page", "log", "gen", "again", "Out", "writer", "io", "word", "dump", "screen", "prefix", "ln", "over", "obj", "err", "println", "history", "error", "list", "auto"]}}
{"id1": "5872038", "id2": "23611215", "code1": "    public void parse() throws ParserConfigurationException, SAXException, IOException {\n        DefaultHttpClient httpclient = initialise();\n        HttpResponse result = httpclient.execute(new HttpGet(urlString));\n        SAXParserFactory spf = SAXParserFactory.newInstance();\n        if (spf != null) {\n            SAXParser sp = spf.newSAXParser();\n            sp.parse(result.getEntity().getContent(), this);\n        }\n    }\n", "code2": "    public String uploadFile(String url, int port, String uname, String upass, InputStream input) {\n        String serverPath = config.getServerPath() + DateUtil.getSysmonth();\n        FTPClient ftp = new FTPClient();\n        try {\n            int replyCode;\n            ftp.connect(url, port);\n            ftp.login(uname, upass);\n            replyCode = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(replyCode)) {\n                ftp.disconnect();\n                return config.getServerPath();\n            }\n            if (!ftp.changeWorkingDirectory(serverPath)) {\n                ftp.makeDirectory(DateUtil.getSysmonth());\n                ftp.changeWorkingDirectory(serverPath);\n            }\n            ftp.storeFile(getFileName(), input);\n            input.close();\n            ftp.logout();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return serverPath;\n    }\n", "label": 0, "substitutes": {"parse": ["execute", "feed", "report", " scrape", " analyse", " parser", "se", "patch", "set", " parsing", "write", "save", "read", " explode", "split", "post", "throw", " assemble", "load", "build", "parser", "request", "delete", "format", " serve", "exec", "send", "apply", "pack", " process", "eval", " load", "create", "arse", "print", "process", "xml", "scan", "Parser", "handle", " service", "transform"], "SAXException": ["IAFXEX", "IAFXException", "SAFXException", "SAXYWarning", "SAXXWarning", "SAFXWarning", "IAXException", "SAFXEX", "SAXXException", "IAFXWarning", "SAXEX", "IAXEX", "SAXYException", "IAXWarning", "SAXYEX", "SAXWarning", "SAXXEX"], "IOException": ["IOExcept", " IOExcept", " IOception", "SecurityException", "APIExcept", "APIception", "APIException", "IOception", "Securityception", "SecurityExcept"], "httpclient": ["Httpserver", " httpapi", "httpserver", "httpconnection", "httpsapi", " httpClient", " httpconnection", "httpClient", "Httpapi", "Httpconnection", "httpsClient", "httpapi", "HttpClient", "Httpclient", "httpsserver", " httpserver", "httpsclient", "httpsconnection"], "result": ["server", "resource", "response", "output", "plus", "rc", "results", "res", "report", "http", "message", "json", "document", "instance", "match", "record", "ret", "client", "session", "source", "r", "default", "data", "out", "page", "request", "product", "status", "success", "url", "this", "err", "obj", "Result", "found", "sr", "api"], "spf": ["prF", "espfc", "spsf", "sccf", "spfs", "Spfp", "Spf", "spcf", " spfp", "spfp", "prcf", "spfc", " spfx", "SPcf", "SpF", " spsf", "espf", " spfs", "prf", "espfs", "SPfx", "SPfp", "scfp", " spfc", "SPsf", "SPfc", "prfp", "scf", "spfx", "SPfs", "scsf", " spcf", " spF", "spF", "Spcf", "espfx", "SPf"], "sp": ["sc", "sf", "serv", "op", "wp", "spl", "se", "html", "Sp", "si", "pl", "inst", "ap", "so", "pr", "pp", "par", "str", "parser", "SP", "gp", "p", "tp", "esp", "ss", "pc", "sl", "app", "sh", "asp", "pe", "bp", "obj", "br", "span", "sw", "bsp", "ps", "f", "pt", "sr", "service"]}}
{"id1": "1954410", "id2": "15797402", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitExecute", "doExecApply", "submitexecuteApply", "doexecuteute", "doSendRun", "doexecuteRun", "submitexecuteRun", "doSendute", "doexecuteutes", "submitExecApply", "doSendutes", "submitExecutes", "doExecutes", "submitexecuteutes", "submitexecuteute", "doExecRun", "doexecuteApply", "doSendApply", "submitExecRun"], "mapping": [" mapper", " matching", "aminding", "matching", "minding", " minding", "finding", "fatching", "amapping", "fapping", "fapper", "mapper", "amatching", "amapper"], "form": ["feed", "builder", "Form", "formation", "flow", "owner", "pattern", "post", "component", "FORM", "config", "page", "object", "forms", " forms", "control", "format", "submit", "template", "transform", "url", "app", "command", "xml", "dom", "method", "field", "definition"], "request": ["path", "address", "input", "Request", "resource", "server", "self", "user", "uri", "add", "report", "message", "json", "HTTP", "current", "result", "instance", "s", "query", "ware", "queue", "req", "client", "Accept", "session", "reader", "type", "use", "q", "model", "application", "parent", "Reply", "data", "route", "Upload", "object", "requ", "context", "hello", "complete", "submit", "name", "format", "QUEST", "frame", "Bytes", "worker", "call", "pull", "url", "Response", "create", "_", "xml", "method", "this", "re", "view"], "response": ["handler", "server", "resource", "output", "report", "res", "message", "json", "result", "req", "client", "resp", "Resp", "model", "application", "data", "page", "object", "reply", "status", "Response", " Response", "v", "xml", " responses", "view"], "errors": ["mess", " messaging", " mess", " messages", " acc", " managers", " commands", " streams", " payload", " status", " session", " management", " problems", " events", " replies", " Messages", " flashes", " updates", " changes", " error", " messenger", " warnings", " calls", " translations", " this", " logger", " failures", " responses", " logs"], "isMultipart": ["isMultompart", "isMultippedart", "isMultompost", "isMultipage", "isMultiipPart", "isMultipound", "isMultipated", "isMultitart", "isMultipPart", "isMultiart", "isMultippedPart", "isMultIPart", "isMultippedost", "isMultiparts", "isMultiIPPart", "isMultompound", "isMultippage", "isMultIPound", "isMultompPart", "isMultiipart", "isMultIPost", "isMultiipound", "isMultitage", "isMultippated", "isMultiIPart", "isMultippedound", "isMultiage", "isMultIPPart", "isMultipparts", "isMultipost", "isMultippart", "isMultiIPound", "isMultiated", "isMultitated", "isMultiipost", "isMultitarts", "isMultiIPost", "isMultiarts"], "mailInstance": [" mailInst", " mailUsage", "mailinstance", " mailManager", "mailInst", " emailInst", "emailInst", " emailinstance", "fileUsage", "emailManager", "emailInstance", " emailUsage", "fileinstance", " emailInstance", "fileInst", " mailinstance", "emailinstance", "fileInstance", "mailManager", "mailUsage", "fileManager"], "fields": ["keys", "services", "maps", "headers", "input", "locks", "checks", "archives", "forces", "pages", "gets", "comments", "features", "holders", "posts", "qs", "s", "packs", "ids", "params", "parts", "changes", "states", "links", "uploads", "lines", "boxes", "flows", "strings", "loads", "ments", "users", "members", "tags", "data", "classes", "facts", "utils", "objects", "models", "plugins", "groups", "forms", "lists", "atts", "types", "cells", "rows", "details", "files", "dates", "acks", "rules", "words", "events", "properties", "views", "field"], "attachments": ["payments", "achresses", "achment", "attachment", "Attachps", "atters", "attps", "attachlements", "attachresses", "attments", "payresses", "suppees", "achparts", "attions", "extments", "Attachlements", "exters", "Attachions", "attachions", "payment", "Attachers", "achments", "attachers", "suppments", "Attachment", "attachparts", " attachment", "suppment", "attachees", "extions", "attlements", " attachresses", "Attachments", "supplements", "extps", "payparts", "attachps", "attment", "Attachees", "attees", " attachparts"], "items": ["keys", "locks", "pages", "results", "ers", "apps", "ins", "qs", "reports", "ids", "apters", "parts", "its", "links", "lines", "ops", "children", "Items", "orders", "data", "names", "objects", "plugins", "ips", "models", "es", "groups", "phones", "lists", "alls", "types", "rows", "files", "events", "list"], "iter": ["ite", "upper", "zip", "order", "event", "i", "itter", "outer", "master", "http", "slice", "inter", "inner", "oper", "end", "walker", "ter", "gener", "el", "loop", "er", "izer", "Iterator", "reader", "ner", "inc", "file", "ir", "li", "page", "ip", "ator", "iterator", "Iter", "keep", "edit", "coll", "chain", "exp", "it", "skip", "cher", "ver", "ser", "err", "ul", "finder", "former", "altern", "list", "enter", "loc"], "item": ["index", "original", "base", "handler", "temp", "resource", "token", "volume", "art", "file", "get", "example", "coll", "it", "url", "obj", "container", "custom", "element", "info", "server", "site", "result", "all", "next", "post", "source", "load", "up", "section", "page", "object", "ip", "plugin", "complete", "hop", "name", "full", "missing", "attribute", "service", "Item", "storage", "val", "event", "order", "i", "atom", "more", "entry", "slice", "inner", "anything", "er", "reader", "other", "or", "issue", "image", "app", "update", "api", "album", "user", "current", "instance", "extra", "type", "data", "li", "entity", "widget", "folder", "area", "layer"], "aux": ["anc", "ou", "pkg", "lang", "cmp", "axe", "ants", "ru", "sub", "abs", "off", "extra", "uf", "union", "ux", "except", "lc", "uc", "cas", "strings", "auc", "buf", "aff", "alias", " auxiliary", "au", "ups", "data", "etc", "ras", "amp", " Aux", "des", "aw", "aos", "offs", "asc", "af", "packages", "array", "frac", "sup", "prefix", "ox", "fax", "abc", "ext", "imp", "aus"], "part": ["val", "base", "class", "info", "id", "pi", "Part", "user", "add", "pre", "on", " Part", "act", "per", "ref", "join", "html", "l", "patch", "instance", "co", "PART", "joined", "key", "parts", "comp", "fact", "type", "back", "one", "player", "no", "art", "connection", "component", "diff", "ch", "group", "section", "parent", "data", "file", "object", "p", "format", "plugin", "po", "start", "change", "name", "but", "action", "pos", "word", "full", "area", "layer", "pair", "partial", "obj", "b", "and", "block", "f", "step", "error", "field", "element", "list", "point"], "baos": ["Bais", "BAos", "bois", "baOs", "pais", "Baosi", "boo", "bais", "hao", "baot", "boOS", "paOS", "haoss", "BAis", "abaos", "BAo", "hais", " bais", "paot", "BAoS", "BAOs", "Bao", "haos", " baoS", "BAoss", "bao", "baosh", " baot", " baOS", "BaoS", "paos", "BaOs", " bao", "baosi", "BAosh", "baoS", "abais", "BAosi", "Baos", "baOS", "abaosi", "boosh", "paosh", " baoss", "baoss", "abaOs", "boos", "pao", "boot"], "body": ["zip", "string", "translation", "fee", "headers", "output", "resource", "message", "description", "document", "json", "end", "html", "length", "shell", "query", "pass", "content", "parts", "params", "type", "source", "binary", "connection", "value", "media", "common", "data", "text", "options", "object", "size", "flash", "null", "Body", "reply", "name", "header", "template", "tree", "port", "full", "url", "comment", "b", "summary", "state"], "preferencesInstance": ["prefirmsClient", "prefeesInstance", "preferencesinstance", "preffeesClient", "prefferencesInstance", "prefirmsInstance", "prefeesinstance", "preferencesClient", "prefferencesClient", "prefeesClient", "prefirmsinstance", "prefferencesinstance", "prefiesClient", "prefiesinstance", "preffeesinstance", "prefiesInstance", "preffeesInstance"]}}
{"id1": "6301863", "id2": "6890417", "code1": "    protected String doRawRequest(String postData) throws IOException {\n        URL url = new URL(SERVICE_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(postData);\n        wr.flush();\n        BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuffer sb = new StringBuffer();\n        String line;\n        while ((line = rd.readLine()) != null) {\n            sb.append(line);\n        }\n        wr.close();\n        rd.close();\n        return sb.toString();\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "label": 1, "substitutes": {"doRawRequest": ["DoDirectResponse", "doPostResponse", "doDirectRequest", "doFullRequest", "DoDirectPost", "DoRawRequest", "doDirectPost", "doRawMessage", "DoRawResponse", "doRawPost", "DoRawMessage", "doDirectResponse", "doFullMessage", "DoDirectRequest", "doDirectMessage", "doPostPost", "DoDirectMessage", "doPostMessage", "doPostRequest", "DoRawPost", "doRawResponse", "doFullResponse", "doFullPost"], "postData": ["POSTPart", "POSTString", " postdata", " postPart", "postString", "POSTData", "POSTBody", "PostData", "postPart", "postdata", "POSTdata", " postString", "postBody", " postBody", "PostPart", "PostBody", "Postdata", "PostString"], "url": ["ssl", "base", "server", "resource", "uri", "user", "http", "c", "lr", "l", "host", "api", "URL", "fl", "client", "nt", "connection", "r", "str", "org", "open", "config", "cl", "web", "page", "ll", "bb", "log", "ls", "blog", "db", "sl", "rl", "Url", "www", "ur", "b", "f", "service", "download"], "conn": ["Connection", "close", "ssl", "Conn", "n", "cf", "enc", "lock", "con", "c", "act", "pub", "cb", "fp", "Connect", "co", "rt", "dc", "nc", "fail", "sync", "client", "nt", "cm", "cp", "session", "wb", "ct", "rn", "connection", "not", "r", "ch", "g", "w", "conv", "open", "ai", "po", "coll", "ci", "exec", "dn", "cr", "ann", "db", "pc", "auth", "contract", "reg", "cn", "connect", "apt", "org", "loc"], "wr": ["nw", "Wr", "rw", "nr", "wp", "vr", "ru", "WR", "wt", "fw", "wm", "dr", "mr", "wd", "write", "rt", "shr", "wrap", "Writer", "rb", "rh", "pr", "wb", "ra", "r", "w", "war", "wer", "rr", "rss", "writer", "rx", "cr", "wn", "fd", "hr", "kr", "wire", "wa", "sw", "RW", "wx", "wy", "raft", "ww"], "rd": ["rw", "dra", "gd", "bd", "rc", "RS", "ru", "rg", "dr", "rt", "fr", "wd", "ld", "RD", "rb", "rowd", "rh", "pr", "reader", "xd", "rod", "rn", "ra", "erd", "ird", "r", "src", "rr", "dig", "rss", "rx", "writer", "cr", "rob", "adr", "db", "fd", "rl", "tr", "hr", "ds", "rm", "wx", "pd", "dd", "sr"], "sb": ["ssl", "buffer", "BB", "sf", "bf", "bd", "bh", "sg", "lp", "lb", "lab", "eb", "cb", "fp", "obb", "bs", "s", "si", "nn", "su", " eb", "pb", "bg", "gb", "mb", "abb", "rb", "sa", "ws", "lines", "wb", "buff", "binary", "buf", "bps", "sv", "bj", "src", "fb", "bb", "zb", "ls", "nb", "db", " SB", "bt", "bc", "bp", "b", "xb", "bsp", "SB"], "line": ["letter", "string", "non", "job", "i", "id", "lf", "user", "message", " Line", "character", "LINE", "end", "l", "pass", "in", "key", "split", "sync", "part", "type", "source", "no", "lines", "lc", "reader", "one", "len", "str", "r", "data", "text", "file", "body", "cl", "page", "ip", "object", "le", "inline", "row", "name", "e", "word", "link", "sl", "unit", "comment", "Line", "lin", "err", "f", "error", "code", "cell"]}}
{"id1": "21979462", "id2": "19096138", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"downloadURLtoString": [" downloadUrlasStr", " downloadURLtoLong", " downloadURL2String", " downloadURLasLong", " downloadURL2Str", " downloadURLintoLong", " downloadURLasStr", " downloadURLasString", " downloadURLtoStr", " downloadURLintoString", " downloadURL2string", " downloadUrltoLong", " downloadUrltoString", " downloadURLasstring", " downloadURLtostring", " downloadURL2Long", " downloadUrltostring", " downloadUrlasLong", " downloadURLintostring", " downloadURLintoStr", " downloadUrlasstring", " downloadUrltoStr", " downloadUrlasString"], "url": ["path", "remote", "address", "buffer", "ssl", "loader", "base", "server", "uri", "resource", "job", "user", "http", "ref", "lr", "l", "URL", "el", "source", "rule", "connection", "config", "data", "file", "page", "bel", "name", "image", "link", "sl", "Url", "b", "f", "gl", "service", "loc"], "in": ["IN", "impl", "ssl", "buffer", "i", "input", "n", "ini", "gin", "into", "ic", "inner", "ilo", "as", "ins", "s", "fr", "bin", "is", "read", "cms", "at", "reader", "source", "login", "min", "r", "inc", "data", "out", "fb", "h", "init", "again", "rx", "af", "re", "isin", "it", "db", "In", "nin", "ln", "lin", "b", "err", "ac", "inn", "f", "din"], "sb": ["buffer", "usb", "sf", "bf", "BB", "bd", "bh", "sg", "lb", "eb", "lab", "cb", "lr", "obb", "s", "bs", "kb", "si", "pb", "gb", "mb", " eb", "rb", "abb", "sa", "Bs", "wb", "buff", "erb", "buf", "sv", "src", "fb", "ub", "bb", "zb", "ls", "sth", "nb", "db", " SB", "ib", "bt", "bc", "bp", "B", "b", "xb", "bm", "bsp", "amb", "SB"], "str": ["string", "i", "cur", "spec", "wr", "n", "enc", "result", "l", "s", "line", "fr", "dr", "pass", "read", "char", "iter", "key", "txt", "arr", "Str", "doc", "pr", "lc", "ct", "r", "div", "STR", "data", "text", "cl", "name", "coll", "cr", "exp", "sl", "tr", "b", "sp", "bl", "br", "st", "err", "obj", "f", "stri", "sr", "list"]}}
{"id1": "21152728", "id2": "1097147", "code1": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"authenticate": ["Authenticate", "authication", " authenticated", "authicating", " authentication", " authenticating", "authicate", "authenticating", "Authentication", "Authenticated", "authentication", "Authenticating", "authenticated", "authicated"], "module": ["method", "class", "base", "address", "input", "server", "course", "element", "resource", "pin", " Module", "entry", "vm", "lock", "site", "message", "project", "table", "py", "mode", "instance", "modules", "mission", "manager", "query", "domain", "Module", "cm", "rule", "member", "connection", "component", "pm", "model", "str", "scope", "config", "data", "file", "require", "object", "mi", "device", "conn", "plugin", "msg", "name", "header", "m", "io", "chain", "prefix", "role", "ctx", " modules", "unit", "script", "mod", "service"], "rand": ["push", "max", "sum", "gd", "round", "token", "rc", "rage", " random", "han", "ro", "in", "pattern", "alpha", "Rand", "gram", "rot", "chance", "bird", "seed", "min", "r", "out", "nd", "rar", "gen", "conn", "init", "raid", "grad", "bot", "auth", "NG", "reg", "range", "random", "right", "ng", "pad", "crypt", "dd", "re", "winner"], "challenge": ["passge", " challge", "chalenge", "challise", "chalise", "passenge", "buckchall", "buckonge", "chge", "challaine", "Challonge", "passise", "schege", " challonge", "chaine", "chalge", "Challise", "scheaine", "chenge", "scheise", "Challchall", "challchall", "buckenge", "scheenge", "challenges", "Challenge", "Challaine", "challonge", "buckge", "Challge", "chise", "passenges", "chalenges", "scheenges", " challchall", "challge"], "b64": [" b4", "mb16", "base62", "bb16", "b4", "mb4", " bbl", "mb64", " b36", "basebl", "base64", "b58", "base36", "base58", "B64", "mb58", "b16", "bb36", "base48", "xb62", "B4", "xb64", "xb48", " b48", " b16", "B16", "bb64", "bb58", " b62", "B58", " b58", "bbl", "b62", "base16", "b36", "b48", "xbbl"], "reply": ["remote", "string", "info", "address", "base", "buffer", "server", "reason", "replace", "uri", "reset", "id", "report", "http", "entry", "message", "py", "result", "answer", "write", "query", "queue", "next", "sync", "part", "back", "resp", "connection", "ridge", "Reply", "data", "body", "text", "out", " replies", "route", "request", "rr", "template", "related", "frame", "link", "prefix", "received", "service", "respond", "Response", "secret", "comment", "parse", "range", "repl", "error", "voice", "notice"], "user": ["string", "address", "pin", "id", "resource", "token", "username", "server", "entry", "lock", "replace", "by", "author", "USER", "character", "project", "uid", "User", "result", "per", "account", "profile", "match", "host", "write", "query", "manager", "pass", "key", "using", "password", "client", "allow", "type", "use", "source", "users", "cover", "proxy", "session", "date", "rule", "login", "open", "parent", "data", "text", "used", "route", "out", "request", "object", "device", "plugin", "creator", "name", "force", "word", "full", "person", "role", "service", "ver", "url", "bug", "secret", "me", "comment", "consumer", "error", "field", "valid"], "response": ["string", "respons", "address", "server", "resource", "uri", "output", "token", "message", "description", "version", "json", "profile", "result", "answer", "account", "host", "password", "session", "resp", "connection", "model", "data", "body", "request", "object", "format", "header", "status", "url", "respond", "Response", "secret", "error", "service", "api"], "secrets": ["secredits", "SECret", "secards", "SECurs", " secredits", "Secards", "regurs", "secures", "securs", "securityures", "regards", "regrets", "SECures", "regret", "Secrets", "SECrets", "subrets", "securityurs", "SECards", "Secredits", "Securs", "subret", "securityret", "subredits", "secret", "Secures", "securityrets", " secret", "Secret"], "md4": ["md6", "mc6", "MDfour", " md44", "mc5", "madfour", "md5", "mad2", "md04", "mad256", "mc4", "sha4", "mcfour", "MD04", " mdfour", "mad04", "shafour", " md256", "md2", "MD6", " MD6", "sha6", " md6", "sha2", " MD4", " md5", "md256", " md04", " MDfour", "MD2", " md2", "MD4", " MD2", "mad4", "sha5", "md44", "MD44", "sha44", "MD256", "mdfour", "sha04"], "line": ["letter", "string", "lo", "server", "lf", "lock", "entry", "message", "profile", "LINE", "end", "l", "shell", "look", "record", "pass", "sync", "part", "rule", "lines", "lc", "value", "model", "str", "data", "file", "body", "text", "out", "cl", "page", "object", "le", "log", "row", "inline", "style", "name", "header", "frame", "status", "link", "strip", "url", "pe", "parse", "lin", "Line", "comment", "range", "block", "error", "definition", "code", "cell"], "passwd": ["passWD", "pWD", "pw", "passpass", "passwordpass", "asswd", "Passwd", "PassWD", "ppass", "passpassword", "assw", "password", "Passpass", "passw", "Password", "Passpassword", " passpass", "passwordpassword", "pwd", "passwordword", "asspass", "passwordwd", " password", "Passw", " passpassword", "assWD"], "hash": ["base", "sum", "her", "id", "server", "version", "kh", "hex", "Hash", "html", "match", "tag", "ash", "key", "cache", "rh", "cover", "sha", "value", "build", "body", "check", "h", "object", "flash", "style", "header", "image", "hed", "array", "ha", "url", "sh", "secret", "shadow", "sign", "block"]}}
{"id1": "3330775", "id2": "21642215", "code1": "    public static JSONObject getJSONData(String url) throws JSONException {\n        JSONObject jObject = null;\n        InputStream data = null;\n        DefaultHttpClient httpClient = new DefaultHttpClient();\n        URI uri;\n        try {\n            uri = new URI(url);\n            HttpGet httpGet = new HttpGet(uri);\n            HttpResponse response = httpClient.execute(httpGet);\n            data = response.getEntity().getContent();\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader;\n            reader = new BufferedReader(new InputStreamReader(data), 8192);\n            while ((line = reader.readLine()) != null) builder.append(line);\n            reader.close();\n            jObject = (JSONObject) new JSONTokener(builder.toString()).nextValue();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return jObject;\n    }\n", "code2": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getJSONData": ["loadJdata", "loadJSONResponse", "getJObject", "getJSdata", "getJSData", "getJSONdata", "loadJSONdata", "loadJObject", "getJData", "getjsonResponse", "getJSResponse", "loadJResponse", "getJResponse", "getJSONResponse", "loadJSONObject", "getjsonObject", "getJSObject", "loadJData", "loadJSONData", "getjsonData", "getJdata", "getJSONObject", "getjsondata"], "url": ["string", "path", "address", "buffer", "ssl", "i", "input", "id", "resource", "server", "feed", "username", "http", "json", "filename", "html", "location", "l", "host", "URL", "like", "source", "proxy", "connection", "str", "file", "route", "request", "ll", "href", "style", "name", "coll", "ls", "image", "full", "sl", "Url", "base", "ur", "xml", "api"], "jObject": [" jObj", "ojObj", "jiObject", "ojObject", "JData", " jData", "jobObj", "Jobject", "jobject", "jiobject", "jObj", "ojJSON", "jobobject", "jobObject", "JObject", "JObj", "jJSON", "ojData", " jJSON", "ojobject", "jiData", "jData", "jobData", "jiJSON", " jobject", "JJSON"], "data": ["zip", "info", "base", "buffer", "handler", "i", "input", "server", "resource", "feed", "entry", "results", "json", "message", "plain", "slice", "as", "result", "html", "api", "record", "memory", "done", "database", "ad", "content", "post", "client", "part", "source", "cache", "load", "media", "DATA", "file", "body", "text", "style", "writer", "image", "to", "bytes", "stream", "partial", "address", "dat", "error", "dd", "download", "storage"], "httpClient": ["HttpCl", "urlclient", " httpCl", "ttpGet", "HttpC", "urlCl", "ttpCall", " httpCall", "urlConnect", "httpC", " httpC", "ttpClient", " httpclient", "httpCall", "HttpClient", "Httpclient", "httpclient", "httpCl", "ttpC", "HttpGet", "HttpCall", " httpConnect", "urlClient", "HttpConnect", "httpConnect"], "uri": ["string", "address", "base", "handler", "i", "server", "resource", "pi", "id", "absolute", "http", "ri", " URI", "location", "si", "query", "ui", "database", "API", "qi", "client", "source", "cache", "connection", "file", "route", "request", "mi", "uni", "folder", "io", "iri", "ur", "reference", "range", "cli", "URI", "service", "api"], "httpGet": [" httpPut", "ttpQuery", "apiClient", " httpReturn", "HttpPut", "ttpPut", "ttpGet", "httpQuery", "jsonGet", "HttpQuery", "httpPut", "jsonget", " httpget", "jsonClient", "apiReturn", "httpReturn", "apiGet", "httpget", "HttpGet", "apiget", "jsonReturn", " httpQuery"], "response": ["server", "resource", "output", "feed", "http", "res", "report", "json", "message", "results", "document", "onse", "result", "query", "next", "client", "resp", "connection", "file", "body", "page", "request", "object", "reply", "e", "status", "writer", "received", "Response", "stream", "respond", "api"], "line": ["val", "letter", "string", "buffer", "base", "i", "id", "lf", "feed", "column", "entry", "LINE", "message", "character", "end", "number", "l", "jo", "el", "pass", "char", "key", "content", "part", "type", "one", "lines", "lc", "len", "str", "file", "text", "li", "liner", "cl", "page", "object", "ip", "le", "inline", "row", "style", "name", "header", "e", "link", "layer", "unit", "comment", "Line", "lin", "code", "point", "cell"], "builder": ["letter", "string", "base", "Builder", "buffer", "handler", "editor", "address", "entry", "building", "inner", "result", "office", "number", "driver", "obb", "length", "keeper", "database", "iter", "er", "type", "ener", "builders", "sb", "up", "oder", "r", "build", "parser", "object", "null", "row", "built", "or", "creator", "writer", "array", "runner", "worker", "db", "layer", "b", "wrapper", "upper"], "reader": ["ry", "buffer", "loader", "i", "input", "handler", "resource", "feed", "reading", "editor", "server", "entry", "per", "ri", "driver", "ro", "keeper", "read", "iter", "ler", "er", "client", "source", "rh", "bird", "ra", "oder", "ner", "r", "parser", "file", "rar", "iterator", "row", "rr", "or", "rer", "io", "writer", "rx", "runner", "worker", "stream", "finder", "Reader"]}}
{"id1": "4602568", "id2": "1421557", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"storeImage": [" transferMedia", " storeMedia", "storeVideo", " storeVideo", "processIcon", " storeIcon", "storeIcon", " transferVideo", " transferImage", "storeMedia", " transferIcon", "processMedia", "processImage", "processVideo"], "inStream": [" inSteam", "inSteam", " inPath", " inReader", "inputVideo", " instream", "inputSteam", "winReader", "inVideo", " inCh", "inCh", "INstream", "winSteam", "inputPath", "inPath", "inReader", "inputStream", " inVideo", "INStream", "INPath", "INCh", "winVideo", "inputCh", "winStream", "instream", "inputReader", "inputstream"], "fileName": ["imagename", "httpPart", "FilePath", "fileNames", "FILEName", "imageNames", "resourceName", "httpName", "resourceInfo", "filename", "FILENode", "filePart", "FILEInfo", "filePath", "FileInstance", " filePart", " fileInstance", "fileInfo", "resourcename", " filename", "Filename", " filePath", " fileInfo", "httpPath", "FILEname", "FILEPath", "FilePart", "resourceNode", "FILEInstance", "FileInfo", "imagePath", "FileNames", " fileNode", " fileNames", "fileInstance", "FileName", "imageName", "fileNode", "httpname"], "resize": ["Resize", "Resizes", "Resizer", " resized", "resizer", "resizes", "Resized", "resized", " resizer", " Resized", " Resize", " Resizer", " resizes", " Resizes"], "rightNow": [" rightNOW", "thirdNow", "rightCurrent", " rightnow", " rightThen", "dayToday", "RightNow", "thirdCurrent", "thirdnow", "rightNOW", "dayNOW", " rightCurrent", "dayCurrent", "rightToday", "thirdNOW", "thirdToday", " rightAccount", "RightToday", "Rightnow", "rightnow", "straightNow", "rightThen", "rightAccount", "straightToday", "thirdThen", " rightToday", "RightNOW", "straightnow", "straightAccount", "RightCurrent", "dayNow", "RightAccount"], "dayNamedFolderName": ["dayNamedAreaSize", "dayNamedFolderKey", "dayNamedFileSize", "dayNnamedFolderInfo", "dayNamedAreaPath", "dayNnamedFolderSize", "dayNnamedFolderName", "dayNamedFolderInfo", "dayNamedFileInfo", "dayNamedDirectorySize", "dayNamedFoldername", "dayNamedDirectoryname", "dayNamedDirSize", "dayNamingFolderKey", "dayNamedDirectoryPath", "dayNamedfolderSize", "dayNestedDirectorySize", "dayNnamedFolderPath", "dayNamedFilePath", "dayNamingFolderName", "dayNamingFolderSize", "dayNamedfolderName", "dayNamedDirInfo", "dayNamedfoldername", "dayNamedDirName", "dayNamedfolderInfo", "dayNestedDirectoryPath", "dayNamedAreaname", "dayNamedFileName", "dayNamedFolderSize", "dayNestedFolderSize", "dayNamedAreaName", "dayNestedFolderName", "dayNamedfolderPath", "dayNamedDirKey", "dayNamedFolderPath", "dayNamingFolderInfo", "dayNamedFileKey", "dayNestedFolderPath", "dayNestedDirectoryname", "dayNestedDirectoryName", "dayNestedFoldername", "dayNamedDirectoryName"], "uploadDirRoot": ["uploadFileHome", "inputDirectoryPath", "uploadDbHome", "uploadDirBase", "inputDirName", "uploadDirectoryHome", "uploadFolderRoot", "UploadFolderPath", "inputDirectoryName", "uploadBasePath", "inputDirRoot", "inputDirHome", "uploadFolderPath", "uploaddirroot", "UploadDirPath", "UploadFolderRoot", "uploaddirHome", "UploadFolderroot", "uploadDirectoryroot", "uploadDirName", "uploadFileRoot", "uploadDbRoot", "uploadDbPath", "uploadDirectoryRoot", "uploadFilePath", "uploaddirRoot", "uploadFileName", " uploadFileroot", "uploadDirroot", "uploadDirectoryName", "uploadDirectoryPath", "inputDirectoryHome", "uploadDirHome", "UploadFolderBase", "uploadDirPath", "uploadDirectoryBase", "UploadDirroot", "uploadFolderBase", "inputDirectoryRoot", "uploadDbName", "UploadDirRoot", "uploadBaseroot", "uploadBaseRoot", " uploadDirroot", " uploadDirHome", "UploadDirBase", "uploadFolderroot", " uploadFileRoot", "uploadFileroot", "uploadBaseBase", "inputDirPath", " uploadFileHome"], "file": ["directory", "zip", "path", "base", "class", "handler", "fe", "ile", "user", "entry", "http", "auto", "document", "per", "fp", "child", "line", "flow", "File", "part", "rule", "lib", "up", "book", "dir", "connection", "model", "FILE", "work", "parent", "out", "local", "page", "object", "p", "log", "view", "folder", "name", "e", "force", "image", "home", "function", "full", "files", "url", "pe", "unit", "comment", "b", "f", "service"], "extension": ["extion", "exion", "extend", "EXTdivision", "exdivision", "EXTversion", "xtION", "intension", "extdivision", "Extend", "xtend", "EXTion", "interdivision", "exension", "extION", "ExtION", "EXTension", "xtension", "exversion", "interension", "intend", "Extension", "xtion", "interversion", "interion", "intION", "intion", "Extion", "extversion"], "outFileName": ["outFolderPath", " outFileAddress", "OutFileName", "outfileLocation", "outFileSystem", "outFieldSystem", " outFileSystem", "outDirName", "outFileKey", "outFullKey", " outPlacePath", "outLineLength", "outPlacename", "outFileAddress", "outFileSize", "outLinePath", " outPlacename", "inFileInfo", "outLineLocation", "outfileLength", " outPlaceSize", "outDirKey", "outPathname", "outFolderAddress", "outFilePart", "outLineSize", "outLineInfo", "inLineInfo", "OutDirLength", "inLineLine", "outfileName", "outDirInfo", "inFileName", "outPlaceType", " outFileLine", " outFilePath", "outfilePath", "outLinename", "outFileLine", "outPlaceName", " outPlaceAddress", "outFilePath", "outPathType", "outFullPath", "outFileInfo", "inLineName", "outDirLine", "outPlaceAddress", "outDirPath", "outPathPath", "outPlacePath", "outFilename", " outPlaceLine", "outPathName", " outFileSize", "outFieldLine", "outDirLength", "outLineType", "outFolderSystem", "OutDirPath", "outFolderLine", "outfileInfo", " outFilename", "outFileLocation", "inFilePath", "inLineKey", "OutDirName", "outFullPart", " outFileType", "outFieldName", "OutFilePath", "outFolderName", " outFileLocation", " outPlaceSystem", "outPlaceSystem", "OutDirInfo", "inFileKey", "outDirPart", "outPlaceSize", "outLineName", "inLinePath", "outPlaceLine", "inFileLine", "outFolderInfo", "OutFileInfo", " outPlaceLocation", "outLineLine", "outFileType", "outFileLength", "outLinePart", " outPlaceName", "outFieldAddress", "OutFileLength", "inFilePart", "outLineKey", " outPlaceType", "outPlaceLocation", "inLinePart", "outfileSize", "outFullName"], "outPathAndName": ["outPathAndAddress", "outNameAndName", "outpathAndPath", "outNameAndAddress", "outpathOrNames", "outPathandPath", "outPathAndRam", "outNameAndPath", "outNameOrPath", "outPathOrname", "outPathOrAddress", "outNameAndRam", "outPathANDTime", "outpathAndTime", "outPathandNames", "outpathOrPath", "outPathANDname", "outNameOrRam", "outPathAndPath", "outpathAndNames", "outPathAndNames", "outPathANDAddress", "outPathOrName", "outNameOrAddress", "outPathOrPath", "outPathANDPath", "outPathANDName", "outPathOrNames", "outpathAndname", "outNameOrName", "outPathOrTime", "outPathAndTime", "outPathANDRam", "outPathandName", "outpathAndName", "outpathOrName", "outPathANDNames", "outPathOrRam", "outPathAndname"], "uploadedFile": ["processchedfile", "uploadedImage", "uploadendedFile", "uploadatedfile", "uploadratedFile", "uploadchedfile", "UploadpedFile", "uploadenedFile", "uploadatedFolder", "uploadpedFile", "processedfile", "uploadendedF", "uploadendedfile", "Uploadedfile", "uploadenedFolder", "Uploadpedfile", "uploadratedF", "uploadchedF", "uploadatedFile", "uploadededFile", "UploadpedFull", "uploadatedFiles", "uploadedFiles", "uploadizedFiles", "uploadpedFiles", "uploadpedImage", "uploadededFiles", "uploadizedFull", "uploadchedPath", "uploadpedfile", "processchedPath", "uploadenedFiles", "processchedFile", "uploadizedImage", "uploadededFull", "uploadizedFile", "UploadpedFolder", "processchedF", "uploadedFull", "UploadpedFiles", "UploadedFile", "uploadchedFile", "uploadendedPath", "UploadedFull", "uploadedfile", "uploadratedfile", "processedFile", "uploadedPath", "uploadpedFolder", "processedF", "processedPath", "UploadedImage", "uploadpedFull", "UploadpedImage", "UploadedFiles", "uploadratedPath", "uploadedF", "UploadedFolder", "uploadededImage", "uploadenedfile", "uploadedFolder"], "outStream": ["inSteam", "Copy", "inFile", "outFile", " outFile", "s", "URL", "outSteam", "tempStream", " outSteam", "Type", "format", "Bytes", "Directory", "inBuffer", "outBuffer", "tempFile", "Url", "url", "_", "tempSteam", "tempBuffer", "New", " outBuffer"]}}
{"id1": "13666876", "id2": "19549577", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 0, "substitutes": {"transformSingleFile": ["transformMultiSourceFile", " transformOneFiles", " transformOneSourceFile", "transform1File", " transformOneFile", "transformOnePath", "transformsinglefile", "transformSinglefile", " transformOnePath", "transformsingleFiles", "transformOnefile", "transformMultiFile", " transformSinglePath", "transformsingleSourceFile", "transformOneFile", "transformMultiFiles", "transform1SourceFile", "transformOneSourceFile", "transformsingleFile", "transformSingleFiles", " transformSingleSourceFile", "transformSinglePath", "transformOneFiles", " transformOnefile", "transformMultifile", "transformSingleSourceFile", " transformSinglefile", "transform1Files", " transformSingleFiles", "transform1Path"], "xed": ["xeded", " Xeb", "xxeb", "xxED", "exED", "xteds", "rexed", " xedited", " xended", "xted", "exed", " Xed", " xeds", "rexeds", "Xed", " xeded", "exEd", "xxended", "exeds", " xED", "xedited", "xxed", "exeded", "rexED", "Xended", "xxedited", "Xedited", "xeb", "exeb", "xED", "xeds", "xended", "Xeded", "xEd", "xxeded", " Xeds", " Xeded", "xxeds", "xtEd", "xtED", "rexeded", " xEd"], "node": ["event", "root", "index", "path", "copy", "op", "option", "document", "message", "Node", "slave", "instance", "child", "set", "location", "day", "query", "edge", "part", "source", "load", "no", "live", "component", "parent", "config", "file", "route", "none", "page", "object", "row", "name", "tree", "image", "leaf", "ode", "shape", "error", "menu", "loc"], "dob": ["ddod", "adub", "ddOB", " dod", "DOb", "ddOb", " dub", "dOB", "DOB", " dOB", "adOB", "dod", "dOb", "ddob", "adob", "ddub", " dOb", "adod", "Dub", "Dob", "dub"], "mySrc": ["MyAssrc", " myEssrc", "myssrc", "mySRC", "MyAsrc", "MyAsource", "MyEsRC", "myAsource", "myEsst", "MySsrc", "MySrb", "myDrc", "MySRC", "MyAsRC", "MySrc", "myAsRC", "myDsRC", "mySsrc", "MyEsrc", "mySst", " mySRC", "myDst", " mySsrc", " myEsrc", "myDssrc", "myEsRC", "MyEssrc", "myEsource", "myEssrc", " myEsst", "mySource", "myEsrc", "myDRC", "MySource", "myAsrb", " mySst", "mysrc", "myDsrc", "mysRC", "mysrb", "myEsrb", " myEsRC", "myAssrc", "mySrb", "MyEsrb", "myDsource", "myAsst", "myAsrc"], "mySrcF": ["mySRCf", "mySRCFile", "mySrcM", "mySRCM", "myCrcF", "mySsrcE", "mySsrcM", "myCRCf", "mySrcf", "mySourcef", "mySckF", "mySckM", "myEssrcf", "mySourceE", "mySRCE", "myCrcM", "myCRCE", "myEsrcFile", "mySsrcf", "myCrcE", "myEsrcF", "myEsrcE", "mySckf", "myCRCF", "myEsrcf", "mySourceF", "myCrcf", "mySourceFile", "mySRCF", "mySckE", "mySrcE", "mySsrcF", "mySsrcFile", "myEssrcF", "mySrcFile", "myEssrcFile", "myEssrcE", "myCRCM"], "myOutF": ["myInD", "myOutputC", "MyOutFile", " myOutE", "myOUTE", "myOUTFF", "myInFF", "myOutputF", "MyOutFF", "myInFile", "MyInD", "MyInF", "myOutQ", "myOutPF", "myOutputFile", "MyOutE", "MyInPF", "myInE", "myOutE", " myOutC", " myOutputFile", "MyInFF", "myOUTQ", "myOutFile", "myoutFile", "myInQ", "myInF", " myOutFile", "MyInQ", "myoutPF", "myoutE", "myoutF", "MyInFile", "myOUTF", "myOUTFile", "MyOutF", " myOutputE", "myOutputE", "myInC", "myoutC", " myOutputC", "MyInE", "myInPF", "myoutFF", "myOutC", "myOutFF", "MyOutQ", "MyOutPF", "myOUTD", "MyOutD", "myOUTPF", "myOutD", " myOutputF"], "co": ["aco", "cu", "lo", "colo", "fe", "cc", "ko", "ee", "cmp", "cf", "rc", "coe", "auto", " Co", "ck", "con", "mo", "c", "ctrl", "fc", "cb", "o", "cho", "bo", "CO", "company", "la", "oo", "flo", "oe", "so", "no", "ce", "lc", "cache", "ob", "BO", "ca", "bb", "che", "isco", "po", "coll", "fo", "ci", " CO", "pc", "mc", "CC", "bc", "ico", "Co", "pe", "can", "conf", "gro", "OO", "cur", "cca", "code", "cos", "loc"], "x3dvFile": ["x3rdvfile", "x3ndsvfile", "x3dvPage", "x3dsvSource", "x3dVfile", "x3dvfile", "x3dvsfile", "x3rdVFiles", "x3ndvSource", "x3ndvFiles", "x3ndsvSource", "x3dvFiles", "x3dsvFile", "x3dvsFile", "x3dffile", "x3rdvFile", "x3dfFile", "x3ndvFile", "x3dVSource", "x3dVFiles", "x3dsvFiles", "x3dVPage", "x3dsvfile", "x3rdVPage", "x3dvsPage", "x3dvSource", "x3ndsvFile", "x3ndsvFiles", "x3dfFiles", "x3dfSource", "x3rdVFile", "x3dVFile", "x3rdVfile", "x3ndvfile", "x3rdvPage", "x3dvsFiles", "x3dsvPage", "x3rdvFiles"], "fis": ["elfs", "elfisa", "fs", "elfiss", "elfus", " fs", "Fbs", "Fus", "fi", " fiss", "elfbs", "refiss", "fus", " fus", "refi", "refisa", "elfi", "fisa", " fi", "Fis", " fisa", "fbs", "refis", "fiss", " fbs", "Fs", "elfis"], "gzos": ["wxis", "gzis", "wxo", "zos", "zxos", "wxOS", "gzOS", "wxos", "gzo", "zipOS", "bagos", "bagOS", "zops", "bagis", "zipops", "zxops", "zis", "zxis", "zipis", "zipos", "zxo", "zipo", "gzops", "bago", "zOS", "bagops", "zxOS", "zo"], "buf": ["buffer", "bf", "bd", "bh", "uint", "cap", "lb", "cb", "result", "grab", "done", "bin", "ff", "feat", "queue", "uf", "la", "bag", "cv", "rb", "ab", "cas", "uc", "buff", "len", "data", "fb", "av", "box", "vec", "port", "dec", "db", "bytes", "bc", "Buff", "seq", "b", "br", "fab", "ba", "pad", "block", "batch", "cur", "loc"], "ret": ["val", "ry", "fun", "Ret", "num", "id", "att", "bf", "rf", "rc", "continue", "res", "ref", "result", "match", "rt", "ft", "en", "fin", "nt", "pet", "len", "r", "alt", "default", "rets", "out", "rep", "reply", " RET", "bit", "success", "ver", "b", "reg", "obj", "det", "count", "f", "repl", "RET", "re"]}}
{"id1": "19549489", "id2": "2668853", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copy": ["zip", "Copy", "move", " copies", "all", "write", "clone", " copying", "split", " transfer", "sync", "cop", "source", "upload", "file", " copied", "Cop", "p", "delete", "io", " move", " Copy", "create", "Transfer", "paste", "transfer", "download"], "sourceFile": ["servicefile", " sourceFILE", "siteFILE", "sourceFILE", "siteDirectory", "SourceDirectory", " sourceFiles", "serviceFile", "resourceFiles", "serviceFilename", "searchfile", "serviceFiles", "searchFiles", "sourceFiles", "resourceFile", "SourceFILE", "SourceFile", "sourceFilename", "searchFile", "siteFiles", " sourceDirectory", "sourcefile", " sourceFilename", "resourceDirectory", "searchFilename", "sourceDirectory", "resourcefile", " sourcefile", "Sourcefile", "SourceFiles", "siteFile"], "destinationFile": ["destinatorfile", "distinatedFile", "distinationFiles", "DestinationFile", "destationfile", "distinatedImage", "distinatedDirectory", "destinatorDirectory", "destinatedImage", "DestinatorFiles", "destinatedDirectory", "destationFiles", "destinationImage", "destinatedDir", "destinationDirectory", "destinatedFile", "destinationfile", "destationDir", "destinatedfile", "distinatedFiles", "distinationDirectory", "destinatorFile", "destinationDir", "destationDirectory", "destinatedFiles", "destinatorImage", "distinationFile", "Destinationfile", "destinatorFiles", "distinationImage", "DestinatorDir", "DestinationFiles", "destationImage", "DestinationDir", "DestinatorFile", "Destinatorfile", "destationFile", "destinatorDir", "destinationFiles"], "sourceFileChannel": ["sourceStreamchannel", " sourceFileContext", "targetLibraryChannel", " sourceFilesConnection", "sourceLinechannel", "sourceLibraryClient", "sourceFilesService", "sourceFileConnection", "targetLibrarySocket", "sourceStreamChannel", "sourceFilesConnection", "sourceLibraryChannel", "sourceDirChannel", "sourceFilesChannel", "sourceFileStream", "sourceStreamService", "sourceDirStream", "sourceLibrarySocket", "sourceDirectoryChan", "ourceFileChannel", "ourceStreamChannel", "sourceFunctionContext", "sourceFileContext", "ourceStreamChan", "ourceStreamchannel", " sourceFilesService", "targetLibraryClient", "sourceFileClient", " sourceFileConnection", "sourceLineSocket", "sourceFunctionConnection", "sourceLineClient", "sourceDirectoryChannel", "sourceFilesContext", " sourceFileService", "sourceLineChan", "sourceDirchannel", "targetLibraryChan", "targetFileChannel", "ourceFilechannel", "sourceFileService", "sourceStreamConnection", "sourceFileSocket", "sourceFunctionService", "sourceDirectoryClient", "sourceDirectorySocket", "sourceLineStream", " sourceFilesContext", "targetFileChan", "sourceStreamStream", "sourceStreamChan", "sourceDirChan", "sourceFileChan", "sourceLineChannel", "sourceFilechannel", "ourceFileChan", "ourceFileStream", "sourceStreamContext", "ourceStreamStream", " sourceFilesChannel", "targetFileClient", "targetFileSocket", "sourceLibraryChan", "sourceFunctionChannel"], "destinationFileChannel": ["destinationDirectoryChannel", "destinatorFileService", "destinationFileClient", "destinationIOClient", "destinationFileService", "destinationFileHandler", "destinatorFileCache", "destinationIOCache", "destinationFilesClient", "destinationFileChan", "destinationFilesChannel", "destinationLineChannel", "destinationFileConnection", "destinationLineHandler", "destinationIOChannel", "destinatorFilesCache", "destinatorFileChannel", "destinatorFileConnection", "destinatorFileClient", "destinationDirectoryChan", "destinationFilesChan", "destinatorFilesClient", "destinationFilesConnection", "destinationLineClient", "destinatorFileChan", "destinationLineChan", "destinationDirectoryHandler", "destinationDirectoryCache", "destinationFilesCache", "destinatorFilesService", "destinationLineConnection", "destinatorFilesConnection", "destinatorFilesHandler", "destinationFileCache", "destinationLineService", "destinatorFileHandler", "destinationDirectoryService", "destinationFilesHandler", "destinationDirectoryConnection", "destinationFilesService", "destinatorFilesChan", "destinationDirectoryClient", "destinatorFilesChannel", "destinationIOService"]}}
{"id1": "16851955", "id2": "16719805", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"testTrainingBackprop": ["testTrainingBackdrop", "testTrainingBackpressure", "testTrainBackdrop", "testTrainingBACKpressure", "testTrainingFrontpointer", "testTrainBACKpointer", "testTrainingBACKdrop", "testTrainingBackpointer", "testTrainBACKprop", "testTrainBackprop", "testTrainingFrontpressure", "testTrainBACKpressure", "testTrainBackpressure", "testTrainingFrontprop", "testTrainBACKdrop", "testTrainingBACKpointer", "testTrainingBACKprop", "testTrainingFrontdrop", "testTrainBackpointer"], "temp": ["directory", "zip", "path", "base", "buffer", "input", "ex", "output", "copy", "clean", "lock", "http", "tem", "current", "dest", "Temp", "save", "pdf", "txt", "form", "wrap", "session", "cache", "parent", "model", "config", "data", "file", "tmp", "out", "flat", "fake", "local", "empty", "archive", "pipe", "test", "storage", "template", "folder", "cel", "stable", "writer", "io", "font", "full", "mount", "v", "container", "f", "dat", "porary", "this", "emp"], "layers": ["nlibraries", "licikes", "languages", "backs", "nlayers", "lasses", " lients", " lores", " llements", "gobs", "Lients", " languages", "nlikes", "flanguages", " libraries", "gients", "dlasks", "bayers", "lores", "blasses", " lasks", "players", "dlayers", "lients", "flasses", "liibraries", " lobs", " lacks", "likes", "llements", "planguages", "slays", "placks", "bays", "blayers", " lays", "lowers", "gayers", "Lobs", "libraries", "slowers", "licagers", "flayers", "slacks", "licibraries", "dlibraries", "bllements", "lacks", "slayers", "lobs", "fllements", "bowers", "lagers", " lagers", " likes", "liores", "dlacks", "dlores", "plasks", "liacks", "blanguages", "lasks", "nlagers", "dlanguages", "liayers", "licayers", " lowers", "lays", " lasses", "Layers"], "fann": ["larn", "fannon", "Fain", "xfann", "xfannon", "sfanny", "sfannon", "elfann", "garn", "Fann", "Fanny", "elfarn", "fanny", "gnn", "fnn", "sfain", "fana", "lnn", "Fannon", "sfann", "elfana", "lana", "gana", "lann", "xfain", "farn", "fain", "gann", "elfnn", "xfanny"], "trainer": ["rainer", "strainer", "tainer", "racker", "strayer", "Tracer", "trrain", "trayer", "traainer", "trarain", "tacer", "rain", "tacker", " tracker", " train", "stracer", "triner", "traacker", " tracer", "Trainer", "retainer", "racer", "strain", "Triner", "striner", "train", "Tracker", "Trrain", "Trayer", "stracker", "tracker", "tracer", "retayer", "traacer", "retacer", "retiner"], "desiredError": ["desiredSize", "desiredFailure", "descidederror", "desizedError", "descidedFailure", "deservedError", "desivedError", "desirederror", "desidedError", "descidedProblem", "desizedSize", "deservedEvent", "desireSize", "reservedError", "descidedError", "desireException", "desciredFailure", "desiredException", "desiredOrder", "desirableOrder", "designedError", "desiredEvent", "desivedException", "resiredError", "desirableEvent", "DesireSize", "desireError", "resiredSize", "deservedSize", "desiringerror", "DesireError", "designedSize", "reservedEvent", "desciredError", "DesiredError", "designedOrder", "despectedProblem", "desivedSize", "desiringError", "desirableSize", "designedEvent", "desidederror", "DesiredSize", "despectederror", "desciredProblem", "desidedFailure", "DesireException", "reservedOrder", "desiringFailure", "desirableError", "desiredProblem", "DesiredException", "descirederror", "despectedError", "desizedException", "despectedFailure", "resiredEvent", "resiredOrder", "desidedProblem", "desiringProblem", "reservedSize", "deservedOrder"], "mse": ["fge", "Mze", "gmge", "Mge", "fmce", " mge", " mSE", "fmse", "mte", "mce", "gmce", " mte", "fse", "Mte", "mze", "fce", "fSE", "MSE", "gmSE", " mce", "Mse", "mSE", "fmte", "fmze", "gmse", "Mce", "mge", " mze"]}}
{"id1": "15409512", "id2": "3187685", "code1": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"inFileName": ["sourceFileName", "inSourceFileName", "sourcefileLocation", "inFileLength", "inLineLength", "inStreamSystem", "incFilename", "inFileSystem", "inStreamLocation", "incFileLength", "inStreamname", "inFilenameLength", "infileName", "sourcefilePath", "inStreamPath", "outFileSystem", "infileLocation", "inLinename", "incFilenameLocation", "incFileLocation", "inSourceFilePath", "inLineLocation", "outFilePath", "sourceFilePath", "incFileName", "inFilenameName", "inFilePath", "sourcefileName", "inFILEPath", "incFilenameLength", "sourceFileLocation", "sourceFilename", "inFilenamename", "outStreamSystem", "inLineName", "inStreamIn", "inFilenamePath", "inFILESystem", "outStreamName", "infileLength", "inSourceFilename", "incFilenamename", "inSourceFileLocation", "inFileIn", "incFilenameName", "inFILEIn", "outFileIn", "outStreamPath", "inStreamName", "inFilenameIn", "outStreamIn", "infilePath", "inFilename", "inFilenameLocation", "infilename", "inFILEName", "inFileLocation", "sourcefilename", "inFilenameSystem"], "outFileName": ["OutFileLine", "outPackageName", "outFILEUrl", "inDirNum", "outFILELocation", "outSourceFileLine", "outPackageNum", "inFileNum", "inDirPath", "outSourceFileLocation", "inDirLine", "OutFileName", "outFilenameLine", "outSourceFileAddress", "OutFilenameName", "OutFilenameUrl", "outFilenameAddress", "outSourceFileUrl", "outputSourceFileName", "OutFileUrl", "outDirNum", "outFileLine", "outFilenameNum", "inFileLine", "outDirName", "outFilePath", "outFilenameName", "outStringName", "outFilenamePath", "outputFileName", "inFilePath", "outFileLocation", "outputSourceFileAddress", "outFileUrl", "outFileNum", "outFileAddress", "outFilenameLocation", "OutFilenameLine", "outFILEName", "outputSourceFileLocation", "outStringLine", "outFilenameUrl", "outDirLine", "outDirPath", "inDirName", "outStringUrl", "outFILEAddress", "outputFileLocation", "outputFileUrl", "outSourceFileName", "outputFileAddress", "outPackagePath", "outputSourceFileUrl", "outPackageLine"], "position": ["index", "order", "address", "release", "job", "i", "buffer", "duration", "id", "Position", "lock", "pose", "move", "option", "version", "sequence", "clock", "maximum", "number", "limit", "character", "location", "length", "patch", "layout", "sort", "slice", "time", "condition", "offset", "expression", "part", "type", "session", "use", "operation", "connection", "ion", "before", "page", "object", "size", "motion", "name", "image", "port", "pos", "pointer", "url", "unit", "shape", "left", "portion", "state", "display", "point", "loc"], "bis": ["uds", "lis", "bus", "fits", "be", "tis", "cb", "bones", "obb", "bs", "abs", "ois", "obos", "is", "uno", "cus", "bes", "binary", "sb", "ros", "bps", "ais", "oris", "buff", "bian", "BBC", "ubis", "bas", "ob", "nis", "onis", "fb", "phis", "bb", "bi", "idis", "opus", "ris", "obs", "ls", "lins", "isin", "iris", "ios", "ses", "pins", "abi", "los", "zo", "os", "bits", "rots", "kos", "vas", "boot", "cos"], "bos": ["uds", "mos", "bh", "bies", "antis", "zos", "dos", "bones", "outs", "obb", "bs", "bo", "ois", "obos", "bin", "oos", "obo", "obi", "bes", "so", "ros", "ops", "ubis", "bas", "ob", "bott", "ubs", "ods", "oids", "phis", "bi", "osi", "opus", "obs", "banks", "lins", "ios", "oS", "ses", "osa", "los", "zo", "os", "bits", "kos", "asio"], "b": ["buffer", "base", "i", "bf", "emb", "bd", "lb", "c", "cb", "o", "l", "orb", "bin", "mb", "reb", "rb", "ab", "d", "binary", "sb", "buff", "r", "machine", "ob", "g", "fb", "object", "bb", "p", "null", "e", "m", "bit", "nb", "db", "bytes", "a", "B", "k", "v", "br", "bl", "f"]}}
{"id1": "16572931", "id2": "13783549", "code1": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"unJar": ["putjar", "putServer", "copyJava", "putTar", "copyServer", "addjar", "updatejar", "putJava", "updateJava", "copyjar", "updateTar", "addServer", "addJava", "addTar", "updateServer", "copyTar"], "jarPath": ["relEntry", "Jarpath", "jarLog", " jarPo", "jarName", "javaPath", " jarpath", "JarName", "javaDir", "browserPath", " jarUrl", "browserName", "JarFile", "relFile", "browserpath", "javaFile", "garEntry", "browserEntry", "jarpath", "JarUrl", "javaName", "jarFile", " jarLog", "javaEntry", "erbPath", "garLog", " jarDir", "garPath", "JarEntry", " jarFile", "javaUrl", "jarUrl", "erbPo", "relDir", "javapath", "erbEntry", " jarName", "JarDir", "erbName", "javaLog", "javaPo", "garpath", "jarPo", "JarPath", "jarDir"], "jarEntry": ["jarentry", "jarJar", "aliasEnt", "xmlEntry", "javaInfo", "jarLog", "dropentry", "xmlPath", "jarName", "javaPath", "zipName", " jarInfo", "javaDir", " jarJar", " jarUrl", "dropInfo", "xmlInfo", "irName", "cookEntry", "cookEnt", "javaName", " jarEnt", " jarLog", "javaEntry", "dropEntry", "irentry", " jarDir", "Jarentry", "JarEntry", "javaUrl", "jarUrl", "zipDir", "javaentry", "cookDir", "jarEnt", " jarName", "JarInfo", "irJar", "aliasInfo", "javaLog", " jarentry", "zipEntry", "aliasEntry", "dropPath", "javaEnt", "javaJar", "irEntry", "xmlLog", "jarInfo", "zipUrl", "aliasName", "cookPath", "JarPath", "jarDir"], "path": ["zip", "root", "base", "temp", "resource", "patch", "host", "content", "not", "model", "default", "file", "archive", "context", "conn", "it", "mount", "url", "PATH", "ph", "step", "string", "address", "id", "clean", "lock", "end", "location", "zone", "next", "sync", "part", "source", "binary", "dir", "ion", "str", "ath", "work", "parent", "route", "test", "name", "skip", "th", "left", "directory", "core", "uri", "entry", "Path", "inner", "mode", "dest", "wd", "cat", "src", "request", "p", "image", "prop", "project", "pass", "key", "pattern", "type", "config", "data", "text", "out", "log", "cel", "folder", "po", "home", "prefix", "right", "this", "code", "loc"], "relPath": ["RelUrl", "relEntry", "RelPath", "revpath", "revEntry", "relativeUrl", " relName", "relType", "RelEntry", "Relpath", " relType", "revType", " relUrl", "RelType", "relativepath", "RelName", "relativePath", " relEntry", "revPath", "relName", "relUrl", " relpath", "relpath", "relativeName"], "jar": ["zip", " Jar", "base", "job", "pkg", "her", "drop", "entry", "fire", "py", "j", "z", "java", "tar", "jo", "dr", "keeper", "zone", "ler", "bag", "er", "bar", "ja", "Jar", "gar", "tab", "lib", "dir", "browser", "binary", "open", "file", "war", "archive", "le", "rar", "plugin", "ball", "folder", "pack", "car", "gi", "sl", "url", "cook", "b", "gap", "xml", "ar", "cur", "module"], "ze": ["zip", "zee", "zer", "ipe", "ke", "entry", "zy", "zes", "be", "ie", "zed", "kee", "pse", "ge", "z", "se", "aze", "te", "ine", "ele", "za", "zzy", "ja", "ce", "je", "sle", "ZE", "de", "le", " je", "e", "zi", "zin", "sl", "pe", "zen", "oe", "zie"], "bin": ["zip", "base", "sin", "pin", "brain", "bis", "ban", "resource", "lock", "inner", "abin", "jin", "in", "binary", "lib", "proxy", "login", "bian", "len", "bas", "data", "file", "web", "bb", "bed", "log", "bi", "gen", "init", "plugin", "bit", "pack", "isin", "kin", "gi", "spin", "bot", "b", "cookie", "abi", "cin", "win", "bon", "boot"]}}
{"id1": "13122204", "id2": "18891988", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "label": 1, "substitutes": {"unzipModel": ["UnzipProject", "UnzipFile", "Unzipmodel", "unpatchFile", "unzipProject", "unpatchModel", "UnzipModel", "unpackProject", "unarchiveProject", "unarchiveModel", "unpatchmodel", "unpackFile", "unpackModel", "unpackmodel", "unarchiveFile", "unzipmodel", "UnarchiveProject", "unarchivemodel", "Unarchivemodel", "UnarchiveModel", "unzipFile", "unpatchProject", "UnarchiveFile"], "filename": ["directory", "string", "path", "bf", "uri", "jet", "username", "fits", "kl", "fp", "location", "fn", "il", "l", "database", "File", "txt", "utf", "source", "Filename", "model", "FILE", "SourceFile", "file", "src", "nil", "title", "folder", "name", "fil", "fd", "files", "url", "f", "module", "download", "loc"], "tempdir": [" tempfolder", "tmpDIR", "tempfolder", "tmpdirectory", "tempDIR", "tmpdir", "temdirectory", "Tempdirectory", "TempDir", " tempdirectory", "Tempdir", "temDir", "temfolder", " tempDir", "tempDir", " tempDIR", "TempDIR", "tmpDir", "Tempfolder", "temdir", "tempath", "temppath", "tmppath", " temppath", "tmpfolder", "tempdirectory"], "dest": ["zip", "rest", "handler", "temp", "output", "builder", "cont", "inner", "result", "later", "walker", "tar", "trans", "done", "ui", " Dest", "dc", "usr", "std", "exit", "txt", "die", "comb", "sync", "nt", "cdn", "session", "source", "proc", "wb", "dir", "target", "dist", "default", "store", "file", "src", "tmp", "Dest", "flat", "de", "export", "log", "gen", "delete", "test", "desc", "folder", "home", "opt", "walk", "sup", "di", "prop", "obj", "st", "transfer", "dat", "transform", "loc"], "fis": ["fileiss", "lis", "fileid", "filebis", "fi", " fiss", "filei", "fsbis", "fid", "fbis", "fileisa", "fliss", "flbis", "flis", "fisa", "li", " fi", " fid", "liss", "lid", "fsis", "fsisa", "fileis", "fsiss", "fiss", "flisa"], "BUFFER": ["UPVEN", "CUFFER", " BUFF", " BUVEN", " BUVER", "MAFFER", "BOFFER", "UPVER", "SAFFER", "SAPER", "CUVEN", "BUPER", " BUFIX", "BOPER", "BUFIX", "BOFER", "CUFF", "MAFIX", "TAUCK", "SAVER", "BUFER", "CUPER", "BOFIX", "BUVER", "MAFER", "BUUCK", "UPFF", "MAPER", "TAFFER", "TAPER", "TAVER", " BUPER", "CUUCK", "BUVEN", "BUFF", " BUUCK", "UPFFER", "SAUCK", " BUFER", "CUVER"], "zis": ["yis", "dii", "yin", "zisa", "jis", " zi", " zbis", "zos", "zas", " zii", "xis", "xiss", " zisa", "Zisa", "zIS", "xbis", "zins", "zipin", "zii", "ji", "dbis", "xists", " zIS", "ziss", "zipas", " zins", "jists", "zists", "Zas", "zipis", " zists", "zipisa", "dis", "xos", " zos", "zipins", "zi", "xii", "zbis", "Zins", "zin", "yIS", "xi", "diss", "yisa", "Zis", "jos", " zas", " ziss", "zipIS", " zin"], "entry": ["zip", "ry", "info", "ou", "her", "ace", "id", "feed", "spec", "server", "rc", "ie", "ge", "inner", "end", "result", "se", "match", "jo", "record", "ries", "si", "ident", "line", "Entry", "next", "la", "ent", "nt", "part", "reader", "ce", "lc", "source", "module", "connection", "je", "cat", "inc", "file", "de", "archive", "li", "iterator", "way", "row", "or", "cel", "name", "e", "image", "pack", "pe", "porter", "element", "enter", "valid"], "count": ["val", "index", "base", "buffer", "sum", "max", "core", "list", "id", "feed", "i", "add", "ind", "c", "current", "end", "limit", "number", "length", "line", "write", "read", "time", "in", "key", "weight", "iter", "next", "last", "part", "allow", "type", "use", "cache", "cond", "len", "counter", "file", "Count", "size", "log", "start", "name", "e", "coll", "writer", "pos", "low", "_", "b", "f", "code"], "data": ["index", "info", "base", "buffer", "input", "id", "feed", "message", "number", "result", "length", "record", "write", "shift", "read", "alpha", "content", "next", "raw", "la", "reader", "load", "d", "value", "media", "len", "str", "DATA", "batch", "body", "size", "format", "name", "start", "image", "pos", "array", "pack", "bytes", "a", "block", "zero", "dat"], "fos": ["fops", "bis", " foos", "afos", " fops", "foos", "dfoos", "afis", "xoes", "bos", " fOS", "afops", "dfops", "dfoes", " foes", "bOS", "xos", "bops", "dfos", "xops", "fOS", "xoos", "foes", "afOS"]}}
{"id1": "7843322", "id2": "3184073", "code1": "    public void run(IAction action) {\n        int style = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell().getStyle();\n        Shell shell = new Shell((style & SWT.MIRRORED) != 0 ? SWT.RIGHT_TO_LEFT : SWT.NONE);\n        GraphicalViewer viewer = new ScrollingGraphicalViewer();\n        viewer.createControl(shell);\n        viewer.setEditDomain(new DefaultEditDomain(null));\n        viewer.setRootEditPart(new ScalableFreeformRootEditPart());\n        viewer.setEditPartFactory(new TableEditPartFactory());\n        viewer.setContents(getContents());\n        viewer.flush();\n        int printMode = new PrintModeDialog(shell).open();\n        if (printMode == -1) return;\n        PrintDialog dialog = new PrintDialog(shell, SWT.NULL);\n        PrinterData data = dialog.open();\n        if (data != null) {\n            PrintGraphicalViewerOperation op = new PrintGraphicalViewerOperation(new Printer(data), viewer);\n            op.setPrintMode(printMode);\n            op.run(selectedFile.getName());\n        }\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 0, "substitutes": {"run": ["play", "index", "execute", "input", "output", "register", "report", "save", "render", "task", "read", "form", "loop", "select", "use", "load", "running", "show", "build", "work", "config", "launch", "submit", "test", "start", "plot", "exec", "image", "apply", "runner", "call", "app", "update", "Run", "process", "view"], "action": ["ctions", " fn", "act", " c", "ction", " ACTION", "next", "ACTION", " activity", " flow", " f", " result", " act", " Action", " step", " app", " module", " actions", "controller", "it", " controller", "actions", "ctx", "app", "Action", "state", " input", "tx"], "style": ["letter", "info", "css", "profile", "phase", "py", "mode", "styles", "length", "layout", "pattern", "color", "offset", "sty", "like", "type", "rule", "dot", "value", "config", "level", "Style", "file", "background", "size", "inline", "format", "template", "image", "estyle", "normal", "theme", "role", "position", "sh", "shape", "shadow", "print", "state", "script", "element"], "shell": ["hell", "roll", "sel", "buffer", "console", "skin", "server", "sole", "lock", "system", "mode", "o", "window", "child", "l", "pty", "si", "layout", "ui", "clone", "loop", "session", "scroll", "sb", "live", " Shell", "math", "body", "cl", "nl", "ll", "widget", "log", "null", "control", "search", "cel", "lex", "Shell", "sl", "sym", "sql", "sh", "kel", "wrapper", "tty", "xml", "help", "ol", "gui", "cli", "tool"], "viewer": ["looker", "footerver", "lookener", "showoser", "viewar", "Vieworer", "presentaer", "Viewers", "Viewener", "viewter", "Viewter", "lookers", "viewester", "viewsers", "Viewr", " viewaer", "viewsed", "Viewerver", "displayer", "viewerver", "viewitter", "viewaer", "viewser", "lookier", "scaner", "looke", "displayier", "Viewier", "viewsr", " viewener", "Viewar", " viewerver", " vieworer", "Viewner", "footers", "viewER", " viewe", "reviewed", "Viewed", "Viewitter", "presentester", "footorer", "reviewter", " viewER", "presenter", " viewester", " viewitter", "reviewe", "showester", " viewter", " viewier", "Viewer", "reviewer", "lookER", "vieworer", " viewed", "presentoser", "viewoser", "displayner", "displayitter", " viewar", "Viewe", "viewier", "viewers", "scanener", "showaer", " viewr", "shower", " viewner", "viewe", "scanar", "viewed", "viewr", "viewener", "footer", " viewers", "scanner", "ViewER", " viewoser", "viewner"], "printMode": ["PrintRole", "printmode", "patchStyle", " printSize", "logMODE", "PrintMode", "viewMode", "writemode", "writeMODE", "printRole", "printSize", " printMODE", "PrintMODE", "patchMODE", "writeMode", "logMode", "patchmode", "viewSize", "writeRole", " printRole", "printMODE", "patchMode", "logmode", "logStyle", " printStyle", " printmode", "printStyle", "PrintSize", "Printmode"], "dialog": ["demDialog", "slog", "protink", "collOG", "dialoder", "demoder", "Dialoder", "dialOG", "protog", "logogo", "logdr", "DialDialog", "Dialog", "dialogo", "collDialog", "logink", "sldr", "protogo", "demOG", "dialdr", "dialDialog", "collog", "logog", "slink", "protdr", "DialOG", "slogo", "colloder", "demog", "dialink"], "data": ["where", "info", "buffer", "loader", "handler", "input", "output", "response", "resource", "entry", "map", "json", "oper", "inner", "result", "o", "layout", "done", "ui", "next", "raw", "form", "part", "reader", "up", "ops", "operation", "media", "model", "value", "parser", "text", "body", "page", "object", "p", "format", "or", "plugin", "po", "frame", "image", "writer", "to", "area", "di", "a", "processor", "da", "obj", "state", "pad", "dat", "error", "api", "view", "valid"], "op": ["opl", "job", "opa", "oper", "opp", "o", "set", "co", "orb", "dr", "OP", "oop", "post", "comp", "cop", "ap", "proc", "pp", "operation", "ops", "up", "mp", "oc", "ob", "open", " operation", "ip", "object", "p", "init", "or", "hop", "po", "opus", "exp", "pop", "opt", "operator", "Op", "jp", "it", "app", "top", "sp", "obj", "and", "opy", "auto"]}}
{"id1": "16353490", "id2": "720361", "code1": "    private String executePost(String targetURL, String urlParameters) {\n        URL url;\n        HttpURLConnection connection = null;\n        try {\n            url = new URL(targetURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(urlParameters.getBytes().length));\n            connection.setRequestProperty(\"Content-Language\", \"en-US\");\n            connection.setUseCaches(false);\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            wr.writeBytes(urlParameters);\n            wr.flush();\n            wr.close();\n            InputStream is = connection.getInputStream();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n            String line;\n            StringBuffer response = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                response.append(line);\n                response.append('\\r');\n            }\n            rd.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        int result = 20;\n        if (args.length == 1) {\n            StringBuffer urlString = new StringBuffer(args[0]);\n            if (urlString.lastIndexOf(\"/\") != urlString.length() - 1) {\n                urlString.append('/');\n            }\n            urlString.append(\"GetConfig.jsp\");\n            URLConnection conn = new URL(urlString.toString()).openConnection();\n            System.out.println(Configuration.readObject(conn.getInputStream()));\n            result = 0;\n        } else {\n            System.err.println(\"usage: GetConfig <URL>\");\n        }\n        System.exit(result);\n    }\n", "label": 0, "substitutes": {"executePost": ["executePut", "executePosts", "sendPosts", "sendPut", "executePOST", "invokePOST", " executePosts", "sendPost", "invokePost", " executePOST", "invokePosts", " executePut", "invokePut", "sendPOST"], "targetURL": [" targetUrl", "targeturl", "sourceURL", "TargetUrl", " targetLocation", "outputURI", "outputURL", "TargetLocation", "outputurl", "Targeturl", "sourceUrl", "targetURI", " targetURI", "TargetURI", "targetUrl", "sourceURI", "sourceurl", "outputUrl", "sourceLocation", "TargetURL", "targetLocation"], "urlParameters": ["urlParameter", "URLBytes", "httpPosition", "formParameter", " urlString", "urlRequest", " urlParameter", " urlRequest", " urlRequirements", "URLParameters", "formRequest", "URLRequirements", "urlRequirements", "urlString", "URLString", "implParameter", "httpParameters", "implParameters", "URLParameter", "httpRequest", "urlPosition", "implRequirements", "URLPosition", " urlBytes", "httpParameter", "implString", "urlBytes", "httpBytes", "formParameters", " urlPosition"], "url": ["zip", "string", "Connection", "base", "ssl", "address", "path", "server", "uri", "resource", "feed", "http", "location", "l", "host", "URL", "client", "session", "source", "cache", "proxy", "r", "ob", "config", "data", "file", "li", "channel", "page", "web", "log", "conn", "e", "image", "link", "db", "sl", "Url", "bc", "www", "f", "loc"], "connection": ["handler", "resource", "http", "document", "database", "condition", "nc", "component", "conv", "context", "conn", "contact", "Connection", "server", "lock", "result", "driver", "query", "sync", "source", "cache", "lc", "use", "proxy", "ion", "section", "channel", "object", "link", "unit", "connect", "service", "directory", "remote", "close", "uri", "entry", "con", "socket", "relation", "password", "union", "session", "reader", "collection", "body", "director", "request", "creator", "image", "writer", "io", "function", "position", "sql", "wrapper", "error", "communication", "character", "c", "connected", "current", "instance", "manager", "client", "application", "config", "environment", "log", "db", "ctx", "command", "network", "loc"], "wr": ["nw", "Wr", "rw", "wi", "nr", "wp", "vr", "ru", "WR", "fw", "wt", "wm", "dr", "mr", "fr", "usr", "shr", "raw", "rou", "rh", "pr", "wb", "ws", "wh", "r", "w", "war", "wer", "wal", "rr", "rss", "writer", "rx", "cro", "worker", "angler", "hr", "wire", "raf", "wa", "sw", "RW", "wx", "sr", "raft"], "is": ["bis", "i", "iss", "serv", "IS", "isa", "ini", "Is", "as", "ri", "s", "ois", "rt", "ui", "in", "rs", "ws", "ais", "r", "str", "isc", "ir", "src", "war", "has", "conn", "ai", "ris", "js", "ci", "rss", "io", "rx", "isin", "iris", "ios", "isi", "stream", "os", "was", "ar", "sr", "iso"], "rd": ["rw", "ud", "dra", "bd", "rc", "ru", "rg", "lr", "dr", "rt", "fr", "mr", "ro", "rs", "ld", "RD", "arr", "rb", "reader", "rh", "pr", "xd", "ra", "rod", "rn", "r", "rar", "rr", "rss", "rx", "writer", "cr", "rob", "adr", "fd", "rl", "respond", "hr", "raf", "rm", "pd", "dd"], "line": ["letter", "string", "buffer", "i", "lf", "message", "character", "LINE", "ge", "end", "l", "key", "content", "raw", "sync", "part", "source", "reader", "lines", "lc", "len", "str", "r", "data", "text", "file", "body", "li", "page", "inline", "row", "name", "header", "e", "frame", "cr", "link", "sl", "pe", "unit", "comment", "Line", "lin", "err", "obj", "parse", "block", "f", "error", "code", "cell"], "response": ["string", "respons", "buffer", "server", "output", "resource", "uri", "feed", "report", "site", "message", "json", "document", "description", "version", "result", "answer", "queue", "content", "one", "source", "resp", "cover", "value", "r", "application", "collection", "default", "data", "text", "body", "out", "page", "request", "object", "reply", "example", "tree", "image", "writer", "array", "function", "bytes", "Response", "respond", "error", "api", "view"]}}
{"id1": "20414923", "id2": "17773263", "code1": "    protected int deleteBitstreamInfo(int id, Connection conn) {\n        PreparedStatement stmt = null;\n        int numDeleted = 0;\n        try {\n            stmt = conn.prepareStatement(DELETE_BITSTREAM_INFO);\n            stmt.setInt(1, id);\n            numDeleted = stmt.executeUpdate();\n            if (numDeleted > 1) {\n                conn.rollback();\n                throw new IllegalStateException(\"Too many rows deleted! Number of rows deleted: \" + numDeleted + \" only one row should be deleted for bitstream id \" + id);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"Problem deleting bitstream. \" + e.getMessage(), e);\n            throw new RuntimeException(\"Problem deleting bitstream. \" + e.getMessage(), e);\n        } finally {\n            cleanup(stmt);\n        }\n        return numDeleted;\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 1, "substitutes": {"deleteBitstreamInfo": ["deletebitStreamINFO", "deleteBitStreaminfo", "deletebitstreamInfo", "deleteBitsystemDetails", "deleteBitstreamDetails", "deleteBitsysteminfo", "deleteBitStreamDetails", "deletebitstreamDetails", "deleteBitsystemINFO", "deletebitStreaminfo", "deleteBitstoreINFO", "deletebitstreamINFO", "deletebitStreamInfo", "deleteBitStreamInfo", "deleteBitstreaminfo", "deleteBitstoreInfo", "deleteBitStreamINFO", "deleteBitstreamINFO", "deletebitstreaminfo", "deleteBitstoreinfo", "deleteBitstoreDetails", "deletebitStreamDetails", "deleteBitsystemInfo"], "id": ["index", "path", "info", "root", "address", "num", "i", "entry", "ref", "uid", "number", "did", "sid", "ide", "ident", "in", "ids", "key", "ad", "offset", "part", "like", "type", "no", "d", "one", "source", "which", "aid", "rid", "kid", "parent", "data", "oid", "x", "ip", "object", "p", "name", "start", "status", "db", "pid", "vid", "url", "ID", "seq", "create", "count", "mid", "error", "Id", "code"], "conn": ["Connection", "Conn", "cc", "server", "serv", "cf", "enc", "rc", "con", "c", "act", "col", "co", "rt", "dc", "nc", "client", "sync", "cm", "nt", "session", "cp", "stat", "pr", "ct", "connection", "ch", "config", "ca", "coll", "ci", "exec", "dn", "cr", "ann", "db", "jp", "mc", "ctx", "sql", "mn", "obj", "connect", "cn", "pg"], "stmt": ["strlt", "strmn", "strm", "shMT", " stMT", "Stmn", "shart", "stpr", " stlt", "strst", "Stst", " stm", "Stdb", "stlt", "strmt", "StMT", " stmd", "stMT", "Stmr", "stm", "strmd", "shmt", "shmd", " start", "sttr", "strtr", "stmr", "Stmd", "start", "strdb", " stdb", "strMT", "Stpr", " stst", "Stm", "strmr", "stst", " stpr", "Start", " stmn", "Stlt", " stmr", "stmn", "strpr", "stdb", "Stmt", "stmd", " sttr", "Sttr"], "numDeleted": [" numDeashed", "numDuleted", "numDeletes", "numDuDelete", "Numdeleted", "numDelleted", "numUndued", " numdeoded", "numNeleted", " numdeleted", "numdeued", "numDeloded", "numDefleted", " numDeased", "Numdeigrated", "numExashed", "numDeflected", "Numdeued", "numNeletes", "numDeoded", "numDefased", "numNelete", "NumDeleted", " numDeletes", " numdeletes", "numExleted", "NumdeDelete", " numDeoded", "numModleted", " numDelected", "numDeDelete", " numdelected", "numDeued", "numdeDelete", "numExletes", "numDeased", "numDellected", "numDefoded", "numMododed", "numModletes", "numDuigrated", " numdeased", " numDelete", "NumDeigrated", "numdeletes", "numdelete", "numdelected", "numUndleted", "numDeigrated", "NumDeued", "numDelected", "numExoded", "numDelete", "numDeashed", "numdeleted", "numDelased", "NumDeDelete", "numdeashed", "numModashed", " numdeashed", "numdeased", "numUndDelete", "numdeoded", "numdeigrated"]}}
{"id1": "4481712", "id2": "4599372", "code1": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 0, "substitutes": {"deleteObject": ["saveItem", "deleteItem", "saveObject", "saveDB", " deleteObj", "removeObject", "deleteDB", " deleteItem", " deleteDB", "removeDB", "removeItem", "removeObj", "deleteObj", "saveObj"], "id": ["string", "path", "info", "root", "i", "uri", "resource", "lock", "uid", "sid", "query", "ident", "database", "in", "ids", "key", "type", "source", "rid", "model", "parent", "data", "object", "oid", "ip", "delete", "name", "it", "pid", "sql", "url", "ID", "create", "f", "error", "Id", "api"], "conn": ["Connection", "nw", "ssl", "core", "ou", "Conn", "cc", "server", "n", "serv", "cmp", "cf", "rc", "enc", "lock", "con", "c", "act", "cb", "col", "host", "pool", "co", "rt", "dc", "nc", "ec", "client", "cms", "nt", "cm", "cp", "sync", "cache", "lc", "cond", "ct", "connection", "ch", "cat", "config", "cmd", "ca", "parent", "h", "log", "ai", "po", "coll", "ci", "exec", "cr", "ann", "db", "pc", "mc", "ctx", "sql", "comm", "auth", "conf", "err", "connect", "cn", "ac", "orp", "cli", "error", "cur", "pg", "org", "loc"], "stmt": ["strmn", "stql", "strm", "strmp", "tm", "tmn", "Stmm", "Stmn", "strtx", " stmb", " stm", " stmp", "istmt", " stmit", "pttx", " stmm", "strmt", "tmt", "ptmn", " stmd", "stmp", "Stma", "Stmr", "stmd", "tmm", "stm", "strmd", "stma", " sttx", "Stmp", "dma", "istmr", "stmit", "istmit", "dmt", "dmb", "stmr", "Stmd", "Stmit", "strmi", "strmb", "dm", "Stm", "strmr", "Stmb", "stmm", "ptql", "strmm", " stma", "Stmi", " stql", " stmn", " stmr", "stmn", "stmb", "sttx", "ptmt", "Stmt", "stmi", "istm", " stmi", "strql"], "dbConn": ["dbConnection", "dbconn", "cbConnection", "cbCon", "bbConn", " dbConnect", "bdConnection", "dbConnect", "databaseConn", "databaseConnection", "cbConnect", " dbConnection", "bbconn", " dbconn", "bdCon", "bdConn", "databaseConnect", "bbConnect", "databaseconn", "cbConn", " dbCon", "bdConnect", "bbConnection", "dbCon"], "selfConnection": [" selfconnection", "passReference", "parentconnection", "passConnection", "thisConnection", "SelfConnection", "parentConn", "thisConn", "selfconnection", "SelfConnect", "thisConnect", "selfReference", " selfConn", "Selfconnection", " selfConnect", "passConn", "thisReference", "selfConnect", "selfConn", " selfReference", "thisconnection", "parentConnect", "passConnect", "SelfReference", "SelfConn", "passconnection", "parentConnection"]}}
{"id1": "16804988", "id2": "23273706", "code1": "    public void init() {\n        String filename = getParameter(\"filename\");\n        if (filename == null) {\n            Error(\"Illegal filename\");\n            return;\n        }\n        Dimension dim = DEFAULT_SIZE;\n        try {\n            int w = Integer.parseInt(getParameter(\"width\"));\n            int h = Integer.parseInt(getParameter(\"height\"));\n            dim = new Dimension(w, h);\n        } catch (Exception e) {\n        }\n        InputStream in;\n        try {\n            File ff = new File(filename);\n            in = new FileInputStream(ff);\n        } catch (Exception ignore) {\n            try {\n                URL url = new URL(filename);\n                in = url.openStream();\n            } catch (Exception e) {\n                Error(\"Graph viewer: Failed to open: \" + filename + \"\\n\" + e);\n                return;\n            }\n        }\n        getContentPane().add(getWindow(in));\n        resize(dim);\n        repaint();\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 0, "substitutes": {"init": ["info", "close", "setup", " initialized", "activate", " initialization", "draw", "layout", "construct", "load", " startup", "show", "build", "Initialized", "config", "launch", " Init", "format", "start", "image", "it", "update", "create", "parse", "ize", "Init", "initial"], "filename": ["directory", "string", "path", "doi", "online", "ssl", "loader", "sf", "uri", "n", "username", "dll", "kl", "fp", "l", "fn", "length", "location", "il", "database", "content", "password", "txt", "params", "utf", "Filename", "binary", "which", "license", "SourceFile", "config", "upload", "file", "size", "journal", "nil", "ppa", "metadata", "title", "name", "folder", "fil", "word", "prefix", "fd", "files", "fax", "download", "f", "kn", "phrase", "ename", "jpg", "loc"], "dim": ["val", "index", "info", "num", "spec", "wid", "slice", "py", " reim", "project", "fi", "iframe", "grid", "sam", "si", "dr", "wm", "du", "ims", "part", "cm", "thin", "d", "min", "diff", "dist", "div", "g", "config", "marg", "lim", "size", "p", "mi", "format", "Dim", "m", "fm", "image", "dm", " Dim", "grad", "imm", "di", "dimension", "ext", "span", "shape", "dem", "dom", "dat", "multi", "scale", "width", "mod", "fac", "im", "gm", "param", "img"], "w": ["max", "rw", "i", "n", "c", "z", "o", "l", "s", "wt", "fw", "ew", "wd", "en", "weight", "d", "q", "W", "wh", "r", "x", "p", "u", "e", "m", "t", "a", "height", "k", "v", "b", "y", "wa", "sw", "hw", "f", "width", "ow", "win"], "h": ["n", "gh", "oh", "bh", "ah", "c", "ht", "j", "z", "kh", "o", "l", "s", "ih", "H", "hs", "en", "d", "rh", "uh", "q", "hd", "x", "p", "u", "e", "hm", "t", "ha", "th", "height", "sh", "k", "hr", "b", "y", "v", "ph", "f"], "in": ["impl", "IN", "pin", "ssl", "i", "input", "fe", "id", "n", "resource", "serv", "ini", "cf", "gin", "socket", "as", "fc", "fp", "l", "ins", "el", "bin", "is", "read", "reader", "source", "lib", "login", "connection", "amin", "min", "r", "inc", "data", "file", "out", "src", "fb", "cl", "conn", "again", "cgi", "ax", "io", "In", "kin", "nin", "stream", "err", "b", "ac", "inn", "f", "fac", "win", "din"], "ff": ["fe", "sf", "bf", "lf", "feed", "cmp", "cf", "df", "xff", "fff", "fc", "library", "cb", "fp", "eff", "ffe", "uf", "fl", "back", "pp", "buff", "buf", "iff", "aff", "fed", "ulp", "file", "fb", "ef", "bb", "FF", "af", "ouf", "fd", "ctx", "f", "fx"], "url": ["zip", "path", "string", "ssl", "base", "sf", "server", "uri", "resource", "feed", "http", "fp", "l", "URL", "fr", "fl", "source", "connection", "ob", "open", "file", "src", "fb", "web", "ll", "ls", "e", "image", "io", "sl", "Url", "www", "stream", "b", "f", "download"]}}
{"id1": "3330775", "id2": "19276022", "code1": "    public static JSONObject getJSONData(String url) throws JSONException {\n        JSONObject jObject = null;\n        InputStream data = null;\n        DefaultHttpClient httpClient = new DefaultHttpClient();\n        URI uri;\n        try {\n            uri = new URI(url);\n            HttpGet httpGet = new HttpGet(uri);\n            HttpResponse response = httpClient.execute(httpGet);\n            data = response.getEntity().getContent();\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader;\n            reader = new BufferedReader(new InputStreamReader(data), 8192);\n            while ((line = reader.readLine()) != null) builder.append(line);\n            reader.close();\n            jObject = (JSONObject) new JSONTokener(builder.toString()).nextValue();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return jObject;\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 1, "substitutes": {"getJSONData": ["loadJdata", "loadJSONResponse", "getJObject", "getJSdata", "getJSData", "getJSONdata", "loadJSONdata", "loadJObject", "getJData", "getjsonResponse", "getJSResponse", "loadJResponse", "getJResponse", "getJSONResponse", "loadJSONObject", "getjsonObject", "getJSObject", "loadJData", "loadJSONData", "getjsonData", "getJdata", "getJSONObject", "getjsondata"], "url": ["string", "path", "address", "buffer", "ssl", "i", "input", "id", "resource", "server", "feed", "username", "http", "json", "filename", "html", "location", "l", "host", "URL", "like", "source", "proxy", "connection", "str", "file", "route", "request", "ll", "href", "style", "name", "coll", "ls", "image", "full", "sl", "Url", "base", "ur", "xml", "api"], "jObject": [" jObj", "ojObj", "jiObject", "ojObject", "JData", " jData", "jobObj", "Jobject", "jobject", "jiobject", "jObj", "ojJSON", "jobobject", "jobObject", "JObject", "JObj", "jJSON", "ojData", " jJSON", "ojobject", "jiData", "jData", "jobData", "jiJSON", " jobject", "JJSON"], "data": ["zip", "info", "base", "buffer", "handler", "i", "input", "server", "resource", "feed", "entry", "results", "json", "message", "plain", "slice", "as", "result", "html", "api", "record", "memory", "done", "database", "ad", "content", "post", "client", "part", "source", "cache", "load", "media", "DATA", "file", "body", "text", "style", "writer", "image", "to", "bytes", "stream", "partial", "address", "dat", "error", "dd", "download", "storage"], "httpClient": ["HttpCl", "urlclient", " httpCl", "ttpGet", "HttpC", "urlCl", "ttpCall", " httpCall", "urlConnect", "httpC", " httpC", "ttpClient", " httpclient", "httpCall", "HttpClient", "Httpclient", "httpclient", "httpCl", "ttpC", "HttpGet", "HttpCall", " httpConnect", "urlClient", "HttpConnect", "httpConnect"], "uri": ["string", "address", "base", "handler", "i", "server", "resource", "pi", "id", "absolute", "http", "ri", " URI", "location", "si", "query", "ui", "database", "API", "qi", "client", "source", "cache", "connection", "file", "route", "request", "mi", "uni", "folder", "io", "iri", "ur", "reference", "range", "cli", "URI", "service", "api"], "httpGet": [" httpPut", "ttpQuery", "apiClient", " httpReturn", "HttpPut", "ttpPut", "ttpGet", "httpQuery", "jsonGet", "HttpQuery", "httpPut", "jsonget", " httpget", "jsonClient", "apiReturn", "httpReturn", "apiGet", "httpget", "HttpGet", "apiget", "jsonReturn", " httpQuery"], "response": ["server", "resource", "output", "feed", "http", "res", "report", "json", "message", "results", "document", "onse", "result", "query", "next", "client", "resp", "connection", "file", "body", "page", "request", "object", "reply", "e", "status", "writer", "received", "Response", "stream", "respond", "api"], "line": ["val", "letter", "string", "buffer", "base", "i", "id", "lf", "feed", "column", "entry", "LINE", "message", "character", "end", "number", "l", "jo", "el", "pass", "char", "key", "content", "part", "type", "one", "lines", "lc", "len", "str", "file", "text", "li", "liner", "cl", "page", "object", "ip", "le", "inline", "row", "style", "name", "header", "e", "link", "layer", "unit", "comment", "Line", "lin", "code", "point", "cell"], "builder": ["letter", "string", "base", "Builder", "buffer", "handler", "editor", "address", "entry", "building", "inner", "result", "office", "number", "driver", "obb", "length", "keeper", "database", "iter", "er", "type", "ener", "builders", "sb", "up", "oder", "r", "build", "parser", "object", "null", "row", "built", "or", "creator", "writer", "array", "runner", "worker", "db", "layer", "b", "wrapper", "upper"], "reader": ["ry", "buffer", "loader", "i", "input", "handler", "resource", "feed", "reading", "editor", "server", "entry", "per", "ri", "driver", "ro", "keeper", "read", "iter", "ler", "er", "client", "source", "rh", "bird", "ra", "oder", "ner", "r", "parser", "file", "rar", "iterator", "row", "rr", "or", "rer", "io", "writer", "rx", "runner", "worker", "stream", "finder", "Reader"]}}
{"id1": "12242903", "id2": "9687813", "code1": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"hashKey": ["buildkey", "buildSecret", "buildKEY", "HashKey", "Hashkey", "shakey", "shaKEY", "shaKey", "HashSecret", "hashkey", "HashKEY", "hashKEY", "buildKey", "hashSecret", "shaSecret"], "key": ["keys", "string", "base", "sum", "address", "input", "id", "temp", "token", "user", "message", "number", "hex", "password", "sync", "type", "source", "cache", "mac", "use", "seed", "value", "KEY", "connection", "mix", "parent", "data", "text", "Key", "check", "object", "x", "name", "chain", "word", "prefix", "k", "secret", "pair", "sign", "block", "crypt", "cert", "this", "code"], "hashed": ["Hhed", "hhasha", "bhotted", " hhed", "shotted", "ahashing", "Hash", "shashed", "hhashing", "hotted", "hsasha", "shashing", "hoded", "shoded", "Hasha", "ahhed", "ahashed", "hhed", "hhash", "Hotted", "bhash", "hsashing", "Hashing", "shash", "hashing", "bhashed", "hsash", " hoded", "Hoded", "ahash", "Hashed", "hsashed", "bhashing", "hhashed", "hasha", "shhed"], "md5": ["base62", "mand512", "MD62", " mddown", "md62", "amd3", "base5", "md4", " md4", "md50", "amddown", " md3", "amd5", "md2", "mand50", "MDdown", "MD5", "MD512", "MD3", "amd2", "MD2", "md3", "mand5", " md2", "MD4", "md512", "base2", " md512", "mddown", " md50", " md62", "base4", "mand4", "MD50"], "hash": ["string", "base", "sum", "her", "num", "id", "copy", "message", "json", "result", "hex", "Hash", "html", "length", "ash", "throw", "rh", "mac", "dot", "cache", "sha", "value", "check", "carry", "h", "size", "log", "search", "image", "hed", "array", "url", "v", "shadow", "abi", "print", "count", "f", "code"]}}
{"id1": "13757855", "id2": "2521141", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"process": ["Process", "path", "resource", "output", "project", "run", "construct", "load", "proc", "build", "request", "cess", "submit", "processing", "exec", "call", "evaluate", "update", "processor", "parse", "create", "handle", "transform", "code", "view"], "tpl": ["tipl", "templ", "atpl", "fml", "tbl", "lcl", "qtpl", " tple", "Tpp", "tml", "Tbl", "stPL", " tipl", " tplate", "lplate", "latyl", "qtfc", "lpl", "tmpl", " tcl", "latcp", "tcp", "Tplate", " ttemplate", "pipl", "tplate", "Tpl", "temPL", "fplate", "qtple", "lPL", "latpl", "lple", "qtyl", "tmcp", "tmyl", "qtcp", "pcl", "psl", " tplug", "tsl", " tfc", "TPL", " tbl", " tper", "tmple", "tyl", "Tcl", "tpp", "templates", "Tper", "ppl", "tplug", "lml", "itPL", "Tipl", "lper", "Ttemplate", "temtemplate", "qtbl", "atplug", "tplates", " tsl", "pPL", "ttemplate", "itplates", "tfc", "Tple", "Tsl", "Tplates", " tplates", "tcl", "Tml", " tml", "stpl", "itplate", "fpl", "fplug", "atml", "tPL", " tpp", "stpp", "tple", "atplate", "stplate", "Tfc", " tPL", "latple", "itpl", "tper"], "model": ["where", "node", "copy", "json", "message", "document", "project", "result", "location", "params", "doc", "media", "config", "data", "body", "models", "language", "log", "Model", "m", "graph", "conf", "command", "xml", "module", "param"], "packageName": ["PackageName", "Packagename", "contextInfo", "packageInfo", "modulename", "groupUrl", "groupname", "contextname", "packageUrl", " packageNames", "packageNames", "groupName", "projectKey", "moduleUrl", "projectname", "PackageInfo", "moduleKey", "projectName", "moduleName", " packageInfo", "PackageNames", "contextNames", "packagename", "groupKey", "packageKey", " packagename", "projectUrl", "contextName"], "outFileName": ["outFilenameHalf", "outFullTime", "outFullLine", "inDirCopy", "OUTFileHalf", "OutFileName", "outfileOnce", "outfileNames", "outDirName", "outFullname", "difffileTime", "difffileName", "outFilenameNames", "diffFileTime", "OutFilename", "outDirname", "OutDirNames", "outFullNames", "outFileCopy", " outFileInfo", "OUTBufferName", "difffileOnce", "diffFileName", "OutFileLine", "outFilesLine", "outLineInfo", "OUTFileMode", "outLineNames", "outfileName", "inFileName", "outDirInfo", "outfileEnd", "inDirPath", " outFullInfo", " outFileLine", " outDirName", " outFilePath", "outfilePath", "outLinename", "outFileLine", "outFilenameMode", "outFilePath", "outFilenameEnd", "outFullPath", "outFilenamePath", "outLineTime", "outFileInfo", "outfileCopy", "outDirLine", "outfileMode", "outStreamName", "outDirPath", " outDirTime", "OUTBufferMode", "outRuleInfo", "OUTBufferHalf", "outRuleType", "outFilename", "outFilenameCopy", "outDirCopy", "difffileInfo", " outFileTime", "outFileHalf", "outBufferMode", " outDirLine", "outDirNames", "diffFileOnce", "OutDirLine", "outfileInfo", "inFilePath", "OutDirName", "outDirEnd", "outFileEnd", " outFullName", "outFullInfo", "OUTFileNames", "diffFileInfo", "outfileHalf", "outBufferNames", "OutFileNames", " outFileType", "outfileTime", "outDirOnce", "inDirEnd", "inFileEnd", "outStreamInfo", "outFileTime", "outFileMode", "outFileOnce", "outLineOnce", "outFilesPath", "OUTFileName", "outFileNames", "outDirTime", "OUTBufferNames", "outFullType", "outLineName", "outRuleName", " outDirPath", "outFilenameName", "outLineLine", "outBufferName", "outFileType", "outFilesTime", "outFilesName", " outFullType", "inDirName", "inFileCopy", "outStreamType", "OutDirname", "outBufferHalf", "outFullName"], "xsltParam": ["xldparam", "xsldParam", "xsltVal", "xslicVal", "xltMode", "xslpVal", "xslpParam", "xslpMode", "xsldparam", "xltVal", "xslicMode", "xldParam", "xldVal", "xltparam", "xslicParam", "xslicparam", "xslpparam", "xsltparam", "xsldVal", "xltParam", "xsldMode", "xsltMode", "xldMode"], "artifact": ["ARTifest", " artifacts", " artribution", "ARTifact", "Artifact", "adverturation", "aratifest", "ARTfact", "advertifacts", "arturation", "ARTifacts", "advertribution", "aratifacts", "aratifact", "Arturation", " arturation", "Artifest", "aratfact", "Artifacts", "artifest", "artifacts", "artribution", "Artribution", "Artfact", "advertifact", "artfact"], "destinationPath": ["destinatorLocation", "destinationWidth", "restinationHalf", "destinatedpath", "combinatorpath", "restificationPath", "datinationTime", "destinationHalf", "distinatorPath", "destinateHandler", "destinatorHalf", "DestinationName", "destinationCry", "destinatorStep", "distributionPath", "destiationPath", "destiningName", "constinationsName", "DestinationPart", "destiningPoint", "destinationHandler", "destinatedDir", "destinateName", "restinationPoint", "destiationAuth", "destinationUrl", "distinationName", "restificationpath", "restificationPoint", "destinatorWidth", "destificationPath", "constinationContext", "destinatedStep", "destinatingName", "destinatorPath", "destinatorHandler", "restinatorPoint", "destinatorFile", "distributionpath", "destinatingLocation", "desturationHandler", "destinatorKey", "constinatorUrl", "destinationTime", "destplingDir", "distinationCry", "datinatepath", "destinatorString", "distinatorFile", "destinerContext", "destinatedString", "destributionCase", "desticationPart", "distinatorName", "destiationDir", "destationpath", "tempinatedHalf", "DestinatingPoint", "destcreationPath", "destignmentCry", "destiningpath", "datinationpath", "destinationpath", "destinatorPoint", "combinationpath", "destinatedPoint", "destplingUrl", "distinationpath", "destinatorCase", " destificationLog", "constinatorWidth", "destiationLog", "destinatePath", "tempinationDir", "DestificationPart", "destplingWidth", "destinationString", "destinatingPoint", "constinationDir", "destinatedPath", "destinationAuth", "destributionpath", "destinationKey", "destinerPath", "destinatedFile", "destensionText", "restinatorHalf", "destinationsPath", "constinatorDir", "destplingLog", "DestificationPath", "datinatePath", "destinationDir", "constinationUrl", "destinatorTime", "destinationsName", "distinationFile", "restinationpath", "destplingAuth", "destributionPath", "distinationKey", "constinatorContext", "destinationText", "restinationPath", "tempinatedPath", "destinationName", "restinatorString", "destinationPart", "constinationsPath", "destinateString", "distinatorStep", "destinatePoint", "distinationCase", "destributionDir", "desticationFile", "restinationString", "destificationDir", "destinationFile", "combinatorPath", "constinatorPath", "desticationPath", "destinateText", "destensionPoint", " destinationLog", "destiningContext", "destinatingpath", "destplingPath", "desturationpath", "destificationpath", "destignmentName", "restinationLocation", "destificationPoint", "datinateTime", "destributionCry", "datinationLocation", "restinatorPath", "destinatingPath", "destinateLocation", "destinatedHalf", "destinatorCry", " destinationAuth", "DestinatingPath", "destinerDir", " destinationDir", "destcreationUrl", "constinationspath", "constinationWidth", "destributionName", "destinatorpath", "destinationStep", "tempinationPath", "destationPath", "destensionPath", "combinationHandler", "tempinationHalf", "datinationPath", " destificationAuth", "destiningDir", "destinatorUrl", "distributionDir", "destiningPath", "distinatorCase", "destinatedCase", "DestinationText", "distinationStep", "distributionCase", "destinatingText", "destationTime", "destinatorDir", "desturationPath", "DestinatingText", "destificationName", "destinateDir", "tempinationpath", "datinateLocation", "distinationDir", " destificationPath", "destinationCase", "distinationPath", "destationLocation", "destificationPart", "combinationName", "distinatorCry", "desticationKey", "combinatorHandler", "destinateHalf", "destificationAuth", "destinationLog", "destinatedKey", "desticationStep", "tempinatedDir", "destificationLocation", "desturationName", "constinationpath", "destinatepath", "destinationLocation", "constinationPoint", "destinationContext", "destensionName", "constinationName", "destinateTime", "constinationsPoint", "combinatorName", "destignmentCase", "destinationspath", "DestificationName", "DestinationPoint", "destinatorContext", "constinationPath", "DestinatingName", "restificationLocation", "destcreationWidth", "destignmentPath", "distinatorKey", "desticationName", " destificationDir", "destinationsPoint", "constinatorpath", "DestinationPath", "destinationPoint", "tempinatedpath", "destinatePart", "destinatorName", "destinerpath", "destificationLog", "combinationPath"], "in": ["IN", "i", "input", "ex", "n", "con", "c", "ins", "bin", "source", "reader", "d", "doc", "cache", "connection", "min", "r", "inc", "config", "data", "x", "name", "image", "t", "In", "din"], "out": ["index", "string", "path", "temp", "outer", "output", "ex", "sys", "server", "user", "lock", "copy", "Output", "version", "OUT", "result", "outs", "o", "pool", "all", "write", "line", "manager", "bin", "key", "post", "client", "part", "session", "source", "doc", "cache", "lib", "up", "connection", "str", "group", "store", "parent", "w", "file", "page", "log", "gen", "conn", "msg", "ne", "again", "name", "exec", "Out", "io", "writer", "dump", "prefix", "full", "free", "comment", "err", "obj", "with", "state", "cli", "error", "list", "point"], "root": ["index", "path", "node", "loader", "id", "results", "resources", "json", "instance", "modules", "meta", "query", "pattern", "params", " result", "cache", "r", "cat", "collection", "parent", "roots", "Root", "options", "format", "tree", "graph", "values", "url", "_", "include", " roots", "history", "xml", "module", "transform"]}}
{"id1": "7945594", "id2": "293167", "code1": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"fileDownload": ["filePull", " filedownload", " fileURL", "urlURL", "folderdownload", "folderDownload", "folderURL", "filedownload", "urlDownload", "urlPull", "fileURL", " filePull", "urldownload", "folderPull"], "fAddress": ["sfOrder", "rfMessage", "urlOrder", " fPath", "fEmail", "baddress", "FAddress", "fileAddress", "FAdd", "sfPath", " fMessage", "FLocation", "faddr", "urladdress", "rfaddress", "sfAdd", " fEmail", "fingaddr", "bAdd", "urlAdd", "fingEmail", "sfLocation", "sfaddress", "fileAdd", "bPath", "fOrder", "fPath", "fingAdd", "fMessage", "rfLocation", "faddress", "fLocation", "sfAddress", "bLocation", " fAdd", "baddr", "fingAddress", "urlAddress", "bAddress", "bEmail", "fAdd", "sfMessage", " fOrder", "fileLocation", " faddress", "rfAddress", " fLocation", " faddr"], "destinationDir": ["destributionDur", "destativeDIR", "DestributionDir", "destinatedDar", "declinationDur", "declinatedPath", "destativeArea", "declinatedDar", "DestinationDIR", "destinatedDir", "destinationDirectory", "destinationDar", "destinationDur", "destributionDirectory", "destributionDar", "destinatedPath", "destinePath", "destinationPath", "declinationDar", "destributionDIR", "destineDir", "destinationArea", "DestinationArea", "destippingArea", "DestributionArea", "destinationDIR", "declinationDir", "destinatedDur", "destativeDir", "destippingDir", "destributionPath", "destativeDirectory", "destineDur", "declinationPath", "destineDar", "destippingDIR", "DestinationDir", "destributionArea", "declinatedDir", "DestributionDIR", "DestributionDirectory", "destributionDir", "destippingDirectory", "declinatedDur", "DestinationDirectory"], "slashIndex": ["Slashedindex", "SlashLength", "slashedIndex", "slashLength", "SlashCount", "SlashIndex", "SlashedCount", "slushLength", "slashedCount", "slushIndex", "slargeindex", "slargeLength", "Slashindex", "slushindex", "sllashCount", "slargeCount", "slashedindex", "SlashedLength", "slargeIndex", "slashindex", "sllashindex", "sllashLength", "slashCount", "sllashIndex", "slashedLength", "SlashedIndex"], "periodIndex": ["moneyStart", "moneyindex", "dollarindex", " periodStart", "periodStart", "dollarIndex", " periodindex", "moneyIndex", "moneyOffset", "periodindex", " periodOffset", "dollarOffset", "periodOffset", "dollarStart"], "fileName": [" filePath", "FilePath", "filePath", " fileAddress", "fname", "fPath", "fName", "fileAddress", "FileAddress", "Filename", "FileName", "filename", " filename"], "url": ["path", "string", "base", "ssl", "ou", "server", "uri", "resource", "feed", "user", "http", "c", "socket", "rel", "l", "URL", "uu", "fl", "proxy", "up", "connection", "oc", "str", "ch", "ob", "open", "config", "org", "li", "channel", "web", "page", "ll", "bel", "log", "u", "conn", "image", "re", "blog", "link", "sl", "rl", "Url", "www", "bug", "ur", "ul", "download", "f", "plug", "service", "api", "loc"], "uc": ["anc", "cu", "ou", "tc", "cc", "sc", "um", "rc", "http", "con", "c", "fc", "uu", "nc", "cus", "ec", "union", "lc", "auc", "connection", "oc", "exc", "usc", "u", "conn", "ci", "uci", "ucc", "pc", "mc", "soc", "bc", "com", "stream", "cci", "ac", "UC", "ul", "unc", "hub", "cur"], "in": ["IN", "i", "input", "n", "rc", "ini", "gin", "into", "con", "c", "inner", "socket", "ins", "s", "bin", "is", "reader", "source", "up", "login", "inside", "r", "inc", "data", "conn", "init", "again", "io", "image", "it", "In", "nin", "stream", "lin", "b", "ac", "err", "cin", "inn", "f", "cli", "this", "din"], "file": ["zip", "path", "letter", "base", "class", "fe", "output", "resource", "ile", "filename", "per", "socket", "place", "fp", "o", "l", "line", "File", "source", "rule", "dir", "up", "book", "connection", "FILE", "parent", "data", "page", "log", "name", "folder", "e", "io", "to", "full", "files", "b", "f", "this"], "fos": ["fops", "fileOs", "sfis", "sfOS", "sfo", " fops", "FOs", "FOS", " fOs", " fOS", "Fis", "Fos", "fob", "fOs", "fileops", "fileob", "fo", " fis", " fob", "sfos", "Fops", "Fo", " fo", "fOS", "Fob", "fileos", "fis"], "out": ["string", "ou", "outer", "output", "copy", "net", "plain", "OUT", "inner", "o", "outs", "s", "line", "write", "bin", "sync", "up", "w", "work", "data", "inc", "down", "log", "init", "again", "exec", "Out", "io", "writer", "to", "flush", "update", "err", "b", "block", "f"], "inputLine": ["outputL", "outputRow", "inputRow", " inputRow", " inputBlock", "errorRow", " inputLINE", "outputline", "InputEl", "outputBlock", "inputEl", "InputLine", "Inputline", "errorL", "inputBlock", "InputBlock", "errorLINE", "inputL", "outputEl", "InputChar", " inputline", "InputL", " inputEl", "inputChar", " inputChar", "outputLine", "inputline", "outputChar", "outputLINE", "inputLINE", " inputL", "errorLine"]}}
{"id1": "2834524", "id2": "494226", "code1": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"write": ["rite", "zip", "output", "end", "run", "all", "save", "post", "sync", "load", "after", "open", "file", "out", "check", "append", "delete", "writer", "Write", "flush", "update", " rewrite", "create", "parse", "println", "process", "handle", "download"], "jarOut": ["garIn", "jarOutput", "tarOUT", "jarIn", "sheetOutput", "tarOut", "jarout", " jarCatalog", "jarCatalog", "jarOUT", "garout", " jarOutput", "serOUT", "javaout", "tarOutput", "serOut", " jarOUT", " jarout", "javaOUT", "javaCatalog", "sheetIn", "garOut", "JarOutput", "JarOUT", "JarIn", " jarIn", "serIn", "sheetOUT", "javaOutput", "serout", "garOUT", "JarCatalog", "JarOut", "javaIn", "tarout", "javaOut", "sheetOut", "Jarout"], "allEntries": ["allentories", "allenties", " allEnties", " allEntories", "allChrys", "Allentries", "allTrys", "allEntry", "AllEntries", "AllEntry", "allChories", "allEntrs", "allentry", "allAddries", "allTry", "allEntrys", "Allentrs", "allChries", "allentries", "allentrs", "allEntories", "allAddry", "allentrys", "allEnties", "allTrs", "AllEntrys", "allTries", "allAddrys", "Allentrys", " allEntrys", "Allentry", "AllEntrs", "allChies"], "iterator": ["order", "handler", "loader", "i", "outer", "cmp", "uri", "ators", "starter", "division", "entry", "now", "ie", "slice", "heid", "inter", "inner", "end", "started", "oper", "walker", "later", "ter", "set", "instance", "gener", "done", "query", "keeper", "inst", "engine", "iter", "next", "loop", "er", "pie", "filter", "Iterator", "reader", "running", "river", "collection", "parser", "section", "ator", "Iter", "size", "init", "or", "creator", "start", "consider", "eni", "runner", "ski", "skip", "stream", "processor", "finder", "step", "former", "basic", "list"], "jar": ["zip", "base", "audio", "pkg", "job", "ssl", "mag", "drop", "entry", "json", "java", "tar", "jo", "record", "tag", "keeper", "sheet", "zone", "magic", "in", "ler", "bag", "er", "docker", "bar", "Jar", "tab", "binary", "dir", "browser", "config", "file", "archive", "war", "pod", "star", "style", "plugin", "folder", "start", "image", "pack", "ski", "jam", "url", "ser", "parse", "cookie", "container", "ar", "module", "space"], "jarEntries": ["jarEntryorts", "jarTies", "jarErrys", "jarAires", "jarErorts", "jarAories", "jarIntriers", " jarEntories", "jarAries", "JarEnties", "parseEntories", "jarEntrs", "jarEories", "jarEnires", "jarErries", "jarEntriers", "jarEnries", "parseEntries", "jarErs", "parseEries", "parseEriers", " jarEnties", "jarEnies", "JarEntorts", "jarEntorts", "JarEntrys", "JarEntries", "jarTories", "parseErs", "jarEnories", "jarTires", "parseEntrs", "jarTries", "parseEories", "parseEntriers", "jarEntires", "jarEntrys", " jarEnries", "jarIntrs", "jarEntryies", "jarEntryrys", "jarEriers", "jarIntries", "jarIntories", "jarEries", "jarAies", " jarEnies", " jarEnires", "jarEntryries", "jarEnties", " jarEntires", " jarEnories", "jarEntories"], "o1": ["O1", "opart", "Opart", "opOne", "oinf", "oaone", "oa11", "so1", "O11", "oe11", "oa91", " oOne", " o3", "soOne", "po11", "o91", "op3", "O0", "oa0", " o0", "oone", "o3", "oe3", "po1", "so3", "oe1", "oe91", "oeone", "oeinf", " o11", "O3", "oa4", "op1", "oepart", " o91", "OOne", "oaOne", "o4", "o11", " o4", "oa1", "o0", " oone", "oainf", "oOne", " oinf", "po4", " opart"], "entryStream": ["entrySteam", "zipString", "inputSteam", "connectionReader", "connectionStream", "zipstream", " entrystream", "EntryString", "entryString", " entryString", "connectionSteam", "entrystream", "inputStream", "EntrySteam", " entrySteam", "entryReader", "zipStream", "Entrystream", "zipSteam", " entryReader", "EntryStream", "inputReader"]}}
{"id1": "8132219", "id2": "659316", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "inFile": ["inputPlace", " inSourceFile", "InSourceFile", "INfile", "binfile", "outPlace", "inputfile", "outfile", " infile", "infile", "inputFile", "outFiles", "InFilename", " inFilename", "Infile", "inFiles", "inPlace", "inputFiles", "binFiles", "binFile", "INFile", "binPlace", "InFile", "INSourceFile", "inFilename", "inSourceFile", "INFilename"], "outFile": ["againFilename", "outputFilename", "outputfile", "againFile", " outfile", "outPlace", "outfile", "infile", "outFiles", "outputPlace", " outFilename", "inFiles", "againfile", " outFiles", "outputFiles", "againPlace", "outFilename", "inFilename", "outputFile", " outPlace"], "in": ["IN", "index", "pin", "base", "i", "input", "id", "n", "ini", "ic", "c", "inner", "as", "ins", "bin", "is", "part", "like", "reader", "source", "connection", "inc", "work", "data", "file", "config", "rin", "x", "name", "again", "m", "image", "io", "In", "a", "url", "inn", "f", "din"], "out": ["string", "buffer", "ex", "output", "n", "copy", "resource", "user", "Output", "plain", "c", "OUT", "version", "o", "outs", "write", "line", "bin", "client", "part", "cache", "dot", "default", "w", "data", "file", "x", "p", "log", "null", "conn", "name", "exec", "Out", "io", "image", "writer", "to", "call", "prefix", "ext", "v", "b", "obj", "external"], "inChannel": ["sinSocket", "INSocket", "inSocket", "inputChannel", "INchannel", "iniChannel", "inStream", " inFlow", " inchannel", "inputchannel", "inchannel", "INFlow", "sinChannel", "inLanguage", "sinChan", "iniLanguage", "winLanguage", "inputChan", "iniStream", "INChan", "outStream", "outchannel", "outChan", "inChan", "inputStream", "inichannel", "outConnection", "INStream", "winChannel", "winchannel", " inConnection", "INChannel", "inConnection", " inChan", "winStream", "sinFlow", " inSocket", "inFlow", "INConnection", "outLanguage"], "outChannel": [" outContext", "OutStream", "againChannel", "OutConnection", "OutChannel", "inchannel", "outContext", " outConnection", "againPath", "againChan", "OutChan", "outStream", "outchannel", "inPath", "outChan", "inChan", "outPath", "OutContext", "outputchannel", "outputChannel", " outPath", "outConnection", "newStream", "Outchannel", "newChan", "againchannel", "outputChan", "inConnection", " outStream", "newContext", "newChannel", " outchannel", " outChan"]}}
{"id1": "12078471", "id2": "9738825", "code1": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "code2": "    public void load(URL url) throws IOException {\n        ResourceLocator locator = null;\n        try {\n            locator = new RelativeResourceLocator(url);\n        } catch (URISyntaxException use) {\n            throw new IllegalArgumentException(\"Bad URL: \" + use);\n        }\n        ResourceLocatorTool.addResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n        InputStream stream = null;\n        try {\n            stream = url.openStream();\n            if (stream == null) {\n                throw new IOException(\"Failed to load materials file '\" + url + \"'\");\n            }\n            logger.fine(\"Loading materials from '\" + url + \"'...\");\n            load(stream);\n        } finally {\n            if (stream != null) stream.close();\n            ResourceLocatorTool.removeResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n            locator = null;\n        }\n    }\n", "label": 0, "substitutes": {"tryLoadURL": ["tryLoadingURL", "tryReadSSL", "tryloadSSL", "tryReadString", "tryReadUrl", "tryloadUrl", " tryReadURL", " tryLoadUrl", "tryLoadUrl", "tryLoadingUrl", "tryloadURL", "tryloadString", " tryLoadString", "tryLoadString", " tryLoadSSL", "tryLoadingSSL", " tryReadSSL", " tryReadString", "tryReadURL", " tryReadUrl", "tryLoadingString", "tryLoadSSL"], "url": ["path", "string", "address", "base", "ssl", "input", "id", "uri", "resource", "server", "feed", "http", "filename", "version", "l", "location", "host", "URL", "source", "connection", "str", "config", "file", "text", "page", "ll", "language", "href", "name", "image", "link", "sl", "Url", "ur", "xml", "f", "service", "download", "loc"], "format": ["info", "class", "handler", "agent", "att", "feed", "settings", "version", "filename", "et", "mode", "host", "magic", "feat", "Format", "key", "pattern", "content", "form", "filter", "at", "type", "value", "str", "feature", "config", "file", "export", "object", "environment", "language", "style", "template", "writer", "function", "unit", "print", "atter", "printf", "and", "stage", "f", "attribute", "method", "field", "transform", "api", "platform"], "c": ["cu", "tc", "cc", "i", "sc", "n", "cf", "rc", "enc", "con", "fc", "cb", "l", "dc", "nc", "ec", "client", "cm", "cp", "ce", "lc", "d", "ct", "connection", "r", "ch", "conv", "cl", "p", "cd", "C", "conn", "u", "coll", "ci", "m", "e", "exec", "cr", "pc", "mc", "ctx", "b", "cn", "ac", "cs", "f"], "data": ["string", "base", "buffer", "input", "id", "resource", "response", "output", "message", "json", "result", "o", "s", "bin", "database", "in", "key", "alpha", "content", "la", "type", "source", "reader", "d", "value", "media", "connection", "str", "DATA", "text", "body", "empty", "p", "u", "name", "ata", "bytes", "a", "stream", "da", "f", "dat", "storage"], "model": ["zip", "base", "handler", "server", "feed", "response", "copy", "df", "builder", "json", "message", "document", "lp", "fp", "instance", "child", "l", "api", "record", "query", "pattern", "content", "form", "client", "cm", "type", "reader", "lc", "value", "parent", "file", "config", "ca", "channel", "models", "bel", "object", "row", "style", "coll", "m", "Model", "image", "layer", "ga", "xml", "f", "module", "code", "view"]}}
{"id1": "21827619", "id2": "7499186", "code1": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 0, "substitutes": {"SHA1": ["sha256", "HAOne", "SHA384", " SHA384", "HA384", "SHAOne", " SHA256", " SHAOne", "sha384", "HA256", "shaOne", "sha1", "HA1", "SHA256"], "text": ["letter", "string", "path", "EXT", "class", "translation", "input", "editor", "output", "token", "Text", "message", "TEXT", " TEXT", "version", "hex", "number", "in", "key", "pattern", "content", "password", "txt", "source", "connection", "value", "str", "config", "data", "object", "struct", "format", "test", "name", "template", "image", "font", "word", "url", "ext", "secret", "contract", "obj", " Text", "this", "code"], "UnsupportedEncodingException": ["UnsupportedEncodingEx", "UnsupportedEncoderException", "UnsupportedEncasingEx", "UnsupportedEncasingception", "UnsupportedEncodedEx", "UnsupportedEncasingException", "UnsupportedEncodingception", "UnsupportedEncoderEx", "UnsupportedEncodedception", "UnsupportedEncodedException", "UnsupportedEncoderception"], "md": ["editor", "bf", "gd", "mag", "bd", "df", "od", "Cmd", "amd", "map", "message", "mo", "ind", "mode", "ma", "am", "meta", "wd", "MD", " MD", "ms", "ld", "sm", "ad", "mb", "mt", "mac", "d", "mp", "hd", "sha", "pm", "pd", "data", "cmd", "body", "mm", "metadata", "cd", "dig", "m", "dm", "mand", "mc", "di", "nm", "mn", "me", "vd", "rm", "mg", "mad", "mod", "dd", "hash", "code", "valid"], "sha1hash": ["sha256sum", "sha64hash", "wa1sum", "SHA1h", "SHA1Hash", "sha256Hash", "sha4hash", "sha4h", "sha256hash", "wa5hash", "sha256h", "wa5copy", "wa1hex", "sha5hex", "sha64hex", "sha64sum", "SHA2sum", "sha5copy", "wa5hex", "sha1h", "sha2Hash", "sha64copy", "sha1Hash", "SHA2h", "sha2sha", "SHA1sha", "sha4Hash", "sha5sum", "sha4copy", "wa1hash", "sha11hash", "wa5sum", "sha1copy", "wa1copy", "sha4sha", "sha4sum", "SHA1hash", "sha2sum", "sha1sha", "sha4hex", "SHA1sum", "SHA2Hash", "sha2h", "sha2hash", "SHA2sha", "sha11sum", "sha5hash", "sha1hex", "sha11sha", "SHA2hash", "sha1sum"]}}
{"id1": "8093133", "id2": "8430178", "code1": "    public static Object loadXmlFromUrl(URL url, int timeout, XML_TYPE xmlType) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        BufferedInputStream buffInputStream = new BufferedInputStream(connection.getInputStream());\n        return loadXml(buffInputStream, xmlType);\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"loadXmlFromUrl": ["loadXMLFromurl", "loadXmlAsURL", "loadXmlfromFile", "loadXmlfromUrl", "loadXmlfromurl", "loadXmlFromFile", "loadXmlAsurl", "loadXmlAsUrl", "loadXmlWithFile", "loadXMLfromUrl", "loadXMLfromurl", "loadXmlWithurl", "loadXmlFromURL", "loadXmlWithURL", "loadXmlAsFile", "loadXMLFromURL", "loadXMLFromUrl", "loadXMLfromURL", "loadXmlfromURL", "loadXmlWithUrl", "loadXMLFromFile", "loadXmlFromurl", "loadXMLfromFile"], "url": ["path", "string", "base", "address", "buffer", "loader", "ssl", "server", "uri", "resource", "feed", "id", "user", "http", "l", "location", "host", "URL", "client", "source", "str", "open", "config", "file", "page", "object", "conn", "image", "io", "link", "sl", "service", "Url", "obj", "org", "loc"], "timeout": ["capacity", "ssl", "buffer", "duration", "server", "token", "resource", "until", "lock", "socket", "limit", "window", "length", "time", "key", "sleep", "offset", "period", "sync", "client", "type", "scroll", "cache", "delay", "config", "data", "out", "size", "Timeout", "io", "seconds", "port", "resolution", "unit", "wait", "network"], "xmlType": ["mlTypes", " xmlStyle", " xmltype", "phpType", " xmlTypes", "phpFile", "xmlClass", "elementStyle", "writerType", "mlClass", "phpClass", "mlType", "writertype", "xmlModel", "xmlStyle", "elementtype", "elementModel", "writerModel", "xmlTypes", "mlFile", "elementType", " xmlModel", "xmlFile", "xmltype", " xmlFile", "writerStyle", " xmlClass", "phpTypes"], "connection": ["directory", "Connection", "index", "event", "handler", "server", "resource", "response", "uri", "entry", "http", "builder", "character", "con", "c", "socket", "connected", "communication", "version", "l", "relation", "database", "condition", "union", "client", "use", "reader", "lc", "proxy", "ion", "which", "application", "collection", "section", "config", "open", "channel", "context", "conn", "io", "writer", "function", "closed", "position", "bc", "unit", "b", "connect", "wrapper", "container", "network", " Connection", "loc"], "buffInputStream": ["buffinputSteam", "buffinputStream", "BuffReadstream", "buffInStream", "BuffOutputstream", "buffOutputstream", "BuffOutputSteam", "BuffInputstream", "buffReadStream", "buffInputstream", "buffInputSteam", "BuffOutputStream", "buffInSteam", "buffInstream", "BuffReadStream", "buffinputstream", "buffReadSteam", "BuffReadSteam", "buffOutputSteam", "buffReadstream", "buffOutputStream", "BuffInputStream", "BuffInputSteam"]}}
{"id1": "14053882", "id2": "5951961", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": [" encode", "encryption", " encryptrypt", "decryption", " encryptryption", " enryption", " enrypt", " enipher", " encryptcode", "decipher", "deccode", "enccode", "encipher", "decrypt", " encryptipher"], "plaintext": ["protectedText", "plainfont", "batfont", "plainText", "protectedstruct", "protectedtext", "encryptedtext", "encryptedstruct", " plainstring", "plainstruct", "plainstring", "plaincontent", "batstring", "protectedcontent", " plaincontent", " plainText", "givenstring", "batsource", "giventext", " plainfont", "givenfont", " plainsource", "plainsource", " plainstruct", "givensource", "encryptedText", "battext", "encryptedcontent"], "md": ["pkg", "mu", "mag", "bd", "od", "df", "Cmd", "amd", "mo", "kg", "ma", "cb", "am", "meta", "dr", "wd", "MD", "dc", " MD", "ms", "sm", "ad", "material", "cm", "mt", "dh", "d", "mac", "mb", "mage", "mp", "hd", "sha", "pm", "pd", "data", "mm", "metadata", "cd", "dig", "po", "m", "hm", "dm", "mand", "mc", "nm", "alg", "mod", "da", "ph", "mg", "mad", "cmd", "dd", "pg", "code"], "raw": ["string", "original", "buffer", "input", " RAW", "response", "feed", "clean", "enc", "rc", "rew", "ack", "json", "RAW", "hex", "instance", "unknown", "load", "binary", "sha", "buf", "serial", "shared", "wave", "Raw", "data", "text", "empty", "row", "null", "unsigned", "image", "pure", "array", "dec", "pack", "full", "stream", "auth", "partial", "wrapper", "block", "initial"], "hash": ["index", "base", "buffer", "sum", "her", "id", "response", "ashes", "message", "version", "kh", "hex", "Hash", "html", "length", "ash", "key", "password", "mac", "cache", "rh", "sha", "data", "h", "log", "href", "header", "image", "ha", "array", "url", "sh", "secret", "auth", "block"]}}
{"id1": "6457199", "id2": "13499897", "code1": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 1, "substitutes": {"doRequest": ["runResponse", "DoRequest", "doCall", "DoCall", "doResponse", "runCall", " doCall", " doProxy", "doProxy", "runProxy", "runRequest", "DoProxy", " doResponse", "DoResponse"], "request": ["event", "string", "error", "buffer", "Request", "server", "uri", "user", "http", "report", "message", "json", "result", "instance", "query", "queue", "req", "client", "session", "reader", "application", "route", "object", "context", "complete", "hello", "name", "call", "url", "right", "reference", "xml", "method", "re", "view"], "response": ["index", "respons", "server", "output", "feed", "more", "report", "results", "http", "message", "document", "json", "site", "onse", "result", "host", "client", "resp", "connection", "model", "application", "parent", "out", "route", "body", "page", "object", "reply", "template", "status", "writer", "re", "success", "Response", "respond", " Response", "v", "reference", "error", "service", "api", "view"], "path": ["anc", "index", "string", "base", "info", "self", "uri", "id", "token", "http", "relative", "message", "slice", "Path", "inner", "end", "patch", "location", "child", "host", "api", "key", "pattern", "content", "part", "type", "source", "dir", "ath", "alias", "work", "data", "text", "route", "object", "p", "context", "name", "template", "arc", "image", "port", "pointer", "walk", "full", "prefix", "url", "PATH", "ith", "partial", "right", "left", "method", "code"], "internal": ["impl", "remote", "string", "base", "personal", "original", "absolute", "uri", "rc", "http", "relative", "intern", "primary", "system", "Internal", "inner", "join", "standard", "origin", "api", "ident", "outside", "source", "central", "binary", "exclusive", "international", "inside", "shared", "alias", "parent", "attr", "route", "regular", "local", "background", "x", "inline", "context", "storage", "name", "rx", "normal", "re", "prefix", "special", "url", "foreign", "custom", "actual", "external", "single", "initial"], "resource": ["string", "rest", "base", "address", "buffer", "server", "uri", "rc", "http", "resources", "res", "result", "rera", "api", "relation", "record", "manager", "client", "source", "rule", "use", "connection", "sr", "media", "r", "real", "file", "route", "ruby", "src", "context", "image", "pointer", "url", "this", "Resource", "stream", "resolution", "reference", "range", "ource", "re", "external"], "mimeType": [" mileInfo", "mimeInfo", "mimePath", "maxtype", "modName", "mimeTypes", " mimeInfo", " mileType", "mimesInfo", " mimePath", "smIMEType", "mipType", "mpeType", "monsePath", "mIMEInfo", "mileTypes", "mIMEName", "pimePath", "mpePath", "pipPath", "mpeTypes", "smIMEtype", "smIMEInfo", " mileTypes", "manceType", "pimetype", "manceTypes", "mancePath", "monsetype", "smimetype", "monseType", "smimeType", "smIMEName", "mimetype", "milePath", "pipType", "pimeTypes", "maxName", "smimeInfo", "maxType", "pipTypes", "pimeType", "mileInfo", "modType", "mipPath", "piptype", "mileType", "modInfo", "mpeInfo", "maxInfo", "mIMEType", "monseTypes", "mancetype", "mipTypes", "modtype", "mimesTypes", "mimesPath", "miptype", "mIMEtype", " mimeTypes", "mimeName", "mimesType", " milePath", "smimeName"], "is": ["info", "bis", "i", "iss", "lis", "uri", "serv", "IS", "fs", "isa", "http", "res", "Is", "as", "ri", "api", "ois", "ui", "in", "ori", "its", "ops", "ais", "isc", "ir", "nis", "ras", "ip", "or", "vs", "ris", "iris", "ios", "us", "isi", "sis", "are", "ps", "was", "im", "iso"], "os": ["oses", "acs", "Os", "opens", "res", "ols", "dos", "as", "OS", "o", "outs", "s", "bs", "ori", "ies", "so", "ros", "bos", "ops", "ais", "nos", "ows", "oes", "ose", "vs", "aos", "oss", "io", "ios", "oS", "us", "cs", "los", "ps", "osi", "iso", "cos"]}}
{"id1": "20181656", "id2": "7143591", "code1": "    private int[] sortRows(int[] rows) {\n        for (int i = 0; i < rows.length; i++) {\n            for (int j = 0; j < rows.length - 1; j++) {\n                if (rows[j] > rows[j + 1]) {\n                    int temp = rows[j];\n                    rows[j] = rows[j + 1];\n                    rows[j + 1] = temp;\n                }\n            }\n        }\n        return rows;\n    }\n", "code2": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "label": 0, "substitutes": {"sortRows": ["sortLRow", "ortLows", "sortSlows", "sortPows", "sortSlOWS", "ortRrows", "sortLOWS", "sortProws", "sortPRow", "ortROWS", "sortSlrows", "sortLows", "ortRRow", "sortLrows", "ortLOWS", "ortLRow", "sortPOWS", "sortROWS", "ortLrows", "sortRrows", "sortSlRow", "sortRRow", "ortRows"], "rows": ["keys", "tracks", "maps", "uds", "index", "headers", "checks", "results", "pages", "docs", "ks", "vers", "slice", "posts", "result", "grid", "roads", "rank", "errors", "cases", "shows", "rs", "ids", "raw", "items", "projects", "users", "flows", "ros", "blocks", "lines", "builders", "diff", "ports", "runs", "members", "orders", "points", "roots", "ows", "grades", "ends", "models", "ips", "breaks", "row", "forms", "boards", "groups", "frames", "rss", "tests", "cells", "holes", "ss", "rooms", "array", "types", "values", "files", "relations", "fields", "rates", "right", "acks", "rules", "heads", "multi", "views", "times"], "i": ["index", "id", "pi", "ij", "ind", "c", "z", "ri", "l", "si", "ui", "ii", "ji", "phi", "li", "ip", "x", "p", "mi", "bi", "u", "ai", "ci", "I", "m", "io", "xi", "ix", "a", "ki", "b", "v", "y", "iu", "f", "ik"], "j": ["index", "job", "uj", "n", "ij", "dj", "json", "jc", "ind", "z", "o", "jl", "l", "jo", "fr", "ui", "ii", "key", "aj", "next", "qi", "ja", "ji", " dj", "d", "jan", "q", "li", "h", "x", "p", "u", "jj", "J", "js", "e", "jp", "ix", "k", "b", "y", "v", "jit", "obj", "br", "oj", "adj", "f", "ik"], "temp": ["index", " tmp", "max", "tc", "id", "n", "input", "pre", "tem", "z", "col", "Temp", "flow", "shift", "extra", "iter", "offset", "except", "cache", "diff", " Temp", "parent", "needed", "flat", "tmp", "fake", "emp", "ip", "empty", "get", "null", "test", "dev", "stable", "area", "circ", "k", "unit", "partial", "v", "err", "this", "orig", "cell"]}}
{"id1": "13596891", "id2": "15822137", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public TableDirectory(RandomAccessFile raf) throws IOException {\n        version = raf.readInt();\n        numTables = raf.readShort();\n        searchRange = raf.readShort();\n        entrySelector = raf.readShort();\n        rangeShift = raf.readShort();\n        entries = new DirectoryEntry[numTables];\n        for (int i = 0; i < numTables; i++) {\n            entries[i] = new DirectoryEntry(raf);\n        }\n        boolean modified = true;\n        while (modified) {\n            modified = false;\n            for (int i = 0; i < numTables - 1; i++) {\n                if (entries[i].getOffset() > entries[i + 1].getOffset()) {\n                    DirectoryEntry temp = entries[i];\n                    entries[i] = entries[i + 1];\n                    entries[i + 1] = temp;\n                    modified = true;\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doTransfer": [" doRequest", "doRequest", " doImport", "doImport", "doSend", "handleImport", "makeImport", "handleRequest", "makeTransfer", "handleTransfer", "handleSend", " doSend", "makeRequest", "makeSend"], "request": ["event", "remote", "input", "Request", "server", "resource", "rf", "user", "http", "report", "subject", "message", "version", "current", "result", "instance", "record", "query", "time", "in", "queue", "req", "condition", "post", "form", "client", "session", "reader", "type", "q", "connection", "model", "application", "config", "data", "object", "requ", "context", "complete", "QUEST", "received", "position", "com", "stream", "create", "command", "xml", "this", "re", "enter"], "response": ["index", "remote", "event", "server", "output", "resource", "serv", "report", "http", "res", "message", "results", "site", "warning", "onse", "version", "result", "document", "json", "en", "content", "next", "client", "session", "cache", "resp", "cover", "connection", "model", "application", "default", "out", "body", "page", "object", "reply", "header", "status", "image", "writer", "success", "call", "full", "service", "Response", " Response", "respond", "error", "re", "view"], "method": ["path", "reason", "string", "class", "head", "resource", "subject", "message", "description", "json", "version", "mode", "Method", "sort", "time", "METHOD", "content", "type", "session", "use", "date", "text", "route", "format", "verb", "status", "send", "call", "prefix", "pull", "position", "sign", "command", "process", "hod", "cmd", "callback", "property", "term", "direction"], "servletContext": ["servLETConfig", " servletCurrent", "servLETContext", "servApplicationConfig", "ServletController", "servleConfig", "Servletscontext", "servleCurrent", "servantContext", "servletsConfig", "ServletConfig", "servletCurrent", "servletController", "servletscontext", "servletsContext", "servletsController", "servLETProvider", " servletConfig", "servletConfig", "servLETCurrent", "servleProvider", "servantProvider", "ServletsContext", "servlexController", " servletProvider", "ServletContext", "servlexConfig", "servantCurrent", "servApplicationcontext", "servletcontext", "ServletsController", "ServletsConfig", "servApplicationController", "servleContext", " servantConfig", "servApplicationContext", "servletProvider", " servantProvider", "Servletcontext", " servantContext", "servlexcontext", "servlexContext", " servantCurrent", "servantConfig"], "wac": [" wAC", " Wac", " WAC", "wsac", " wae", " Wae", "wsacs", " Wacs", "wae", "wsAC", " wacs", "wsae", "wacs", "wAC"], "szUrl": [" sizurl", "szerFrame", "szUr", "szFrame", "sznUrl", "sznPath", "sizFrame", "sizUr", "sizUrl", "szeUrl", "aszFrame", "szenFolder", "szerUrl", "asizURL", "sizFolder", "szFolder", " sizFolder", "szeFolder", "szeUr", " szurl", "asizPath", "szenurl", " sizUrl", "szaUr", "szaUrl", "szaURL", " szFolder", "asizUr", "sizurl", "szPath", "szaPath", "asizUrl", "asizFrame", "szeURL", "sziUr", "szenUrl", "asizurl", "sziUrl", "szeurl", "sznUr", "aszURL", " sizURL", "aszUrl", "sziURL", "sizPath", "aszPath", "sznurl", "szerUr", "sizURL", "szurl", "szeFrame", "szerURL", "sznURL", "szURL", "aszurl", "aszUr", " szURL", "szenURL", "sziurl"], "url": ["impl", "event", "string", "base", "ssl", "buffer", "server", "uri", "resource", "user", "http", "lb", "socket", "rel", "l", "host", "il", "URL", "location", "el", "key", "fl", "client", "source", "connection", "org", "config", "file", "li", "web", "page", "ll", "log", "cloud", "context", "conn", "get", "name", " URL", "sl", "rl", "service", "Url", "www", "stream", "ur", "obj", "ul", "xml", "f", "gl", "re", "loc"], "is": ["info", "bis", "i", "iss", "lis", "uri", "serv", "IS", "rc", "isa", "Is", "as", "ri", "il", "bs", "ii", "isl", "cms", "was", "ais", "isc", "ir", "src", "web", " isn", "ip", "x", " are", "isu", "has", "ai", "ris", "ci", "rx", "io", "oss", "it", "isf", "ils", "ios", "ib", "us", "isi", "os", " bis", "im", "iso"], "sout": [" sOUT", "sOUT", "sin", "Sout", "souts", "Sdata", "SOUT", "sdata", " sOut", " souts", "Sin", "SOut", " sdata", "sOut", "Souts", " sin"], "con": ["ssl", "pin", "fa", "cf", "ran", "on", "pre", "http", "net", "fc", "run", "java", "func", "en", "nc", "cp", "uc", "ct", "common", "crit", "conv", "open", "xc", "get", "gen", "conn", "coll", "don", "cn", "wan", "Connection", "fun", "cc", "server", "rc", "subject", "Internal", "Con", "query", "ocon", "cache", "lc", "Common", "connection", "min", "un", "cl", "C", "exec", "can", "connect", "wa", "win", "cos", "event", "remote", "close", "core", "cons", "co", "util", "syn", "ca", "web", "internal", "m", "const", "ver", "bc", "cur", "single", "view", "non", "fe", "CON", "user", "author", "version", "c", "ctrl", "l", "san", "ec", "client", "type", "login", "inc", "ren", "status", "pc", "ctx", "pen", "com", "conf", "general", "re"], "hNames": ["hrNames", "hFiles", "ihVs", "hrKeys", "hrNs", "HTypes", "hKeys", "hNs", "hrFiles", "ihNames", "hName", "hostNs", "ihBlocks", " hKeys", " hNs", "hBlocks", "HName", "HNames", "hostKeys", " hName", " hVs", "HVs", " hTypes", "hTypes", " hBlocks", "ihName", "hrTypes", "hostNames", "hrName", " hFiles", "hostTypes", "HFiles", "HBlocks", "hVs"], "txt": ["gt", "zip", "xt", "qt", "lt", " text", "utt", "Text", "TEXT", "py", "et", "ht", "cb", "fp", "wt", "inet", "prot", "in", "vt", "key", "htm", "xxx", "csv", "elt", "dt", "nt", "git", "binary", "q", "ct", "value", "XT", "str", "kt", "section", "sv", "text", "struct", "rr", "name", "header", "gz", "rx", "t", "jp", "nm", "gi", "bt", "ctx", "v", "obj", "lv", "wx", "tin", "phrase", "tx", "fx"], "inBody": ["outbody", "inStream", " inReader", "inFile", "outFile", " inbody", " inFile", "InReader", "InBody", "outStream", "INBody", "inReader", "Inbody", "insBody", "InStream", "insStream", "inbody", "INStream", "INbody", "INFile", "outBody", " inStream", "InFile", "INReader", "insReader", "insFile"], "bufCh": ["queueCh", "ufChar", "queueCH", "buffC", "bufCH", " bufC", "bufferCh", " bufCH", "bufch", "buffch", "bufferCH", "ufC", "queueCol", " bufCol", "ufch", "ufCh", "bufCol", " bufChar", "buffCh", " bufch", "bufC", "bufChar", "queuech", "buffCH", "bufferch", "ufCol", "bufferChar", "ufCH"], "r": ["R", "rw", "i", "n", "rf", "nr", "rc", "res", "c", "ru", "ri", "rg", "lr", "result", "fr", "rt", "rs", "er", " rg", "rb", "reader", "d", "pr", "rh", "q", "ner", "ror", "str", "g", "w", "x", "p", "u", "rr", "m", "e", "cr", "rl", "k", "hr", "b", "br", "range", "reg", "v", "err", "rd", "f", "ar", "sr", "re"], "outReq": ["outRece", "outConque", "outConce", "outDequest", " outRquest", "outRsh", " outSece", " outSeque", " outRsq", " outRque", "outREh", "outEck", " outEck", " outRsce", "outEque", " outEreq", " outRequest", " outRsh", " outRece", "outDeque", "outConq", " outReque", " outReck", "outRque", " outEque", "outRreq", "outReque", "outRecq", "outRecce", "outEq", " outEq", "outDeq", "outRsq", "outRecque", "outRsque", "outRsce", " outReh", "outSeque", "outSeck", "outREce", "outRecck", " outRsque", "outRq", " outRq", " outRce", "outRquest", "outSece", "outRecreq", " outRereq", "outReck", " outSeck", "outDece", "outRce", " outSeq", "outEreq", "outRequest", "outREque", "outREq", "outRck", "outREck", "outSeq", "outReh", "outRereq", "outConh", "outSequest"], "buff": ["info", "buffer", "num", "Buffer", "map", "uf", "lines", "buf", "ch", "data", "file", "bb", "p", "Pad", "Ptr", "array", "Buff", " chunk", "b", "Info", "f", " buffers", " Buffer", " Buff", "Msg"]}}
{"id1": "10218878", "id2": "19912848", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"DecodeMapFile": ["DecodeFilefile", "DecodeDataFile", "DecoderFileFile", "DecodeDataFiles", "DecoderMapFiles", "DecoderFilefile", "DecodemapFiles", "DecodeDatafile", "DecodeMapfile", "DecoderMapfile", "DecodeFileFile", "DecodeFileFiles", "DecodeMapFiles", "DecodemapFile", "Decodemapfile", "DecoderFileFiles", "DecoderMapFile"], "mapFile": ["loadfile", "addressTable", "loadTable", "mapFull", "fileTable", "MapUrl", "mapLog", "batchLog", "batchUrl", "addressfile", "mapTable", "loadFull", "fileFull", "MapFile", "batchFile", "addressFull", "filefile", "MapLog", "addressFile", "mapUrl", "mapfile", "apperLog", "loadFile", "apperUrl", "apperFile", "fileFile"], "outputFile": ["inputFolder", "outputfile", "outputFolder", "responseStream", "OutputFolder", " outputFolder", "responseFiles", "inputFile", "OutputFiles", "inputDir", "OutputStream", " outputStream", "OutputDir", "outputStream", " outputfile", "responseFile", " outputFiles", "inputFiles", " outputDir", "outputFiles", "Outputfile", "outputDir", "OutputFile", "responsefile"], "magicKey": [" magicLetter", "MagicLetter", "prefixKEY", " specialKey", "magicKEY", "MagicK", "magicChar", "magicLetter", " specialkey", "cacheKey", " magicChar", "magicK", " specialK", " specialLetter", "magicSecret", "MagicKey", " magickey", "magickey", " magicSecret", "techKey", " magicK", "prefixLink", "prefixKey", " magicKEY", "techLink", "specialKey", "cachekey", "specialkey", "techkey", "cacheChar", "specialChar", "cacheSecret", "prefixkey", " magicLink", "magicLink", "Magickey", "techKEY", "specialSecret"], "buffer": ["base", "address", "Buffer", "input", "uffer", "token", "feed", "pause", "document", "message", "slice", "result", "length", "memory", "read", "queue", "iter", "offset", "bar", "source", "cache", "reader", "binary", "seed", "buff", "buf", "wave", "data", "variable", "bb", "row", "null", "header", "writer", "FFER", "array", "layer", "position", "url", "shape", "comment", "b", "reference", "stack", "count", "pad", "transfer", "batch", "code"], "nread": ["enfind", " nwrite", "Nreader", " nfind", "NRead", "nreads", "enreads", "nload", "Nwrite", " nreader", "enwrite", "neRead", "pload", "enRead", "nfind", "enread", "nereader", "newrite", "nwrite", " nreads", "pwrite", "Nload", "Nfind", "pRead", "neread", " nload", "nRead", " nRead", "Nreads", "pread", "nreader", "Nread"], "map": ["index", "maps", "address", "core", "input", "list", "copy", "resource", "lock", "master", "pre", "bridge", "message", "per", "pool", "write", "flow", "key", "client", "ap", "cm", "MAP", "one", "cache", "use", "source", "cover", "media", "group", "wave", "work", "open", "data", "file", "out", "config", "header", "m", "image", "pack", "layer", "app", "stream", "create", "parse", "pair", "over", "apper", "block", "make", "pad", "transfer", "module", "code"], "output": ["address", "ou", "core", "error", "console", "outer", "response", "resource", "input", "Output", "document", "oper", "ilo", "o", "run", "pot", "number", "office", "global", "write", "flow", "sort", "queue", "exit", "cache", "operation", "cut", "target", "connection", "model", "other", "application", "config", "data", "file", "out", "export", "web", "page", "object", "put", "log", "control", "image", "function", "layer", "update", "unit", "reference", "utils", "module", "external"], "i": ["info", "id", "mu", "pi", "uri", "ini", "slice", "c", "j", "z", "ri", "o", "l", "length", "si", "ui", "ii", "in", "qi", "ti", "ji", "phi", "li", "ip", "x", "p", "bi", "u", "uli", "oi", "ai", "e", "I", "io", "ci", "m", "zi", "t", "it", "xi", "di", "gi", "a", "b", "v", "multi", "f"]}}
{"id1": "14783950", "id2": "7087108", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressedWithSax", "compressedUsingZip", "compressInSax", "compressUsingJar", "compresswithSax", "compressInZip", "compressedUsingSax", "compressWithSax", "compressUsingZip", "compressWithJar", "compressUsingSax", "compressedWithZip", "compresswithJar", "compressedUsingJar", "compresswithZip", "compressedWithJar", "compressInJar"], "fileList": ["modelCollection", "wordName", " fileCollection", "fileStream", " filelist", "zipName", "filelist", " fileStream", " fileChain", "FileStream", "stringChain", "FileChain", "stringList", " fileString", "FileSet", "FileList", "inputCollection", "inputEx", "fileSet", " fileSet", "wordStream", "stringName", "fileCollection", "Filelist", "stringlist", "inputList", "wordString", "fileEx", "modelEx", "inputStream", "ziplist", "modelList", " fileEx", "zipList", "fileString", "modelStream", "FileString", "FileName", "fileChain", "wordList", "zipSet"], "zipFileName": ["folderFileName", "archiveFilePath", "zipFullDir", "zipDirName", "zipGlobalname", "zipDirNames", "zipFilePath", "zipFullPath", "zipDirname", "folderFilename", "folderGlobalname", "zipGlobalPath", "zipGlobalName", "archiveDirName", "zipPackagePath", "archiveFileDir", "zipPackageName", "zipGlobalNames", "zipFullname", "zipPackageDir", "folderGlobalNames", "folderGlobalName", "folderGlobalPath", "folderFilePath", "archiveFileName", "zipFilename", "zipFileNames", "zipFullName", "zipFullNames", "zipDirPath", "archiveDirDir", "folderFileNames", "zipDirDir", "archiveDirPath", "zipFileDir"], "fos": ["flos", "afos", "infaos", "afoS", "flosh", "afaos", "infoS", "FoS", "infis", "infos", "afis", "Fosh", "flis", " fosh", "Fis", "Fos", "foS", "faos", "Faos", "fosh"], "zos": ["zip", "bis", "css", "tz", "closure", "oses", "zer", "fits", "ZI", "zes", "zy", "dos", "z", "iframe", "outs", "fi", "obb", "zz", "packs", "onz", "zzy", "bes", "bag", "loop", "zon", "ros", "bos", "phi", "inos", "LOS", "zx", "zar", "es", "zb", "zers", "gz", "jobs", "seconds", "zi", "lins", "rez", "chini", "spin", "zl", "ses", "lol", "zik", "webkit", "nz", "budget", "ozo", "ZA", "zo", "abi", "jas", "os", "zan", "uz", "zen", "osi", "zag", "kos", "cos"], "iter": ["ite", "index", "upper", "order", "i", "itter", "outer", "http", "ie", "inse", "inter", "oper", "inner", "end", "walker", "slice", "set", "ter", "fer", "gener", "el", "fr", "is", "sort", "next", "er", "izer", "Iterator", "ener", "ner", "iz", "inc", "file", "ir", "ip", "ator", "Iter", "iterator", "keep", "test", "coll", "e", "iner", "chain", "it", "cher", "ser", "parse", "err", "finder", "f", "liter", "former", "list", "enter", "loc"], "fileName": ["localPath", "FilePath", "fPart", " fileLine", "fileLine", "fullPath", "fName", "pagename", "fileUrl", "fileOpen", "localPart", "pageName", "filename", "filenameInfo", "simplePath", "localname", "pageType", "filePart", "fLine", "filenamename", "filePath", "simpleOpen", "currentUrl", "FileFull", " filePart", "FileUrl", "fullName", " fileString", "fileInfo", "fileType", "fileFull", " fileType", " filename", "Filename", "FileData", "currentName", "localName", "FileLine", " fileData", " filePath", " fileInfo", "fullOpen", "filenameName", "pageString", "currentname", "fname", "FileType", "FilePart", "simpleName", " fileUrl", "FileInfo", " fileOpen", "currentData", " fileFull", "fileString", "FileString", "FileName", "filenameFull", "fileData"], "ind": ["val", "index", "pend", "i", "id", "mind", "ord", "j", "z", "rib", "end", "IND", "eff", "length", "fr", "ii", "in", "ld", "ad", "Ind", "d", "dir", "cond", "len", "div", "inc", "ded", "bind", "nd", "x", "start", "ci", "pos", "wind", "pull", "count", "inn", "mid", "pt", "vert", "ix", "loc"], "shortName": ["shortPart", "ShortString", "fullPath", "ShortPath", "longPart", "shortString", "ShortName", "shortLine", "longPath", "longName", "fullName", "fullLine", "fullString", "ShortPart", "smallName", " shortLine", "fullname", "longLine", "Shortname", "smallPart", " shortPath", "longname", " shortString", "shortname", "smallname", "shortPath", " shortname", "smallPath"], "fis": ["gis", "fs", "pris", "afris", "afos", "pios", " fris", " fs", "cfis", " fiss", "gisa", "fris", "pis", "afis", "cfos", "pisa", "gios", "fisa", "Fis", "Fos", "cfs", "fios", "gris", " fisa", "cfiss", "cfris", "fiss", " fios", "afiss", "Fs", "Fiss"], "buf": ["buffer", "bf", "bd", "bh", "rc", "lb", "cb", "grab", "done", "bin", "ff", "feat", "pb", "queue", "uf", "la", "bag", "bu", "cv", "rb", "wb", "uc", "buff", "data", "tmp", "fb", "lim", "bb", "box", "vec", "fd", "bytes", "bc", "Buff", "bp", "seq", "b", "v", "br", "bl", "ba", "batch", "cur", "loc"], "bytesRead": ["wordsLength", "secondsWrite", "bytesNeed", "secondsNeed", "flowsRead", " bytesSkip", "wordsRead", "tesRead", "bitsUse", " bytesUse", "bytesLength", "bitsLength", " bytesLoad", "wordsUse", "bytesSkip", "bytesLoad", " bytesNeed", "secondsLength", "tesSkip", "bitsWrite", "wordsWrite", "flowsWrite", "bitsSkip", "bitsRead", "secondsRead", "tesLoad", " bytesWrite", " bytesLength", "bytesWrite", "bytesUse", "bitsLoad", "flowsNeed", "tesWrite", "flowsLength"]}}
{"id1": "12306305", "id2": "10158738", "code1": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"doCopyFile": ["doCopFile", "doCopfile", "DoCopFile", "DoCopDirectory", "doCopFiles", "doTransferFile", "doCopyfile", "docopyDirectory", "docopyFile", "doCopyFiles", "doTransferDirectory", "doTransferFiles", "docopyFiles", "doCopDirectory", "DoCopFiles", "DoCopyFiles", "DoCopyDirectory", "DoCopyFile", "docopyfile", "doTransferfile", "DoCopfile", "doCopyDirectory", "DoCopyfile"], "srcFile": [" srcfile", "srcPage", "destFilename", "instfile", "instDir", "sourceDir", "accessPage", "rcFile", " srcDir", "destfile", "srcFiles", " srcFilename", "instFile", "sourcePage", "rcfile", "accessFile", "rcPage", "sourceFile", "accessPath", "destFiles", "sourceFiles", "destPage", " srcFiles", "srcPath", "destDir", " srcDirectory", "sourcefile", "srcDir", "accessFilename", "srcFilename", "destPath", " srcPage", "sourceDirectory", "rcDir", " srcPath", "srcfile", "instPage", "rcDirectory", "srcDirectory"], "destFile": ["destFilename", "descTitle", " destTime", "destDirectory", "homeFiles", "descFile", " destFolder", "flatFile", "sourceDir", " Destfile", "DestTime", " destDirectory", "descFolder", "homefile", "restTime", "destfile", "srcFiles", "optPath", "sourcePage", "DestFile", "descFilename", "flatFolder", "restFile", "restSourceFile", "targetFiles", " destFiles", "destSourceFile", " destDir", "sourceFile", "targetfile", " destFilename", "srcTime", "destTime", "DestPage", "destFiles", "flatTitle", " destTitle", "destFolder", "destPage", "srcSourceFile", " DestFile", "DestFiles", "optfile", "targetSourceFile", "targetPath", " destfile", "homeFile", " destPath", "destDir", "DestDir", "srcDir", "destPath", " destSourceFile", "homeDir", "Destfile", " destPage", "DestDirectory", " DestTime", "destTitle", "targetDirectory", "sourceDirectory", "optFile", "optSourceFile", " DestDir", "flatFilename", "restDirectory", "srcfile", "srcDirectory", "targetFile"], "preserveFileDate": ["preservingFilesdate", "preserveDirectorydate", "preservingFileSince", "preserveFiledate", "preserveFileSince", "preserveTimeDay", "preservedTimedate", "preserveFileDay", "preserveUnitdate", "preserveUnitSince", "preservedTimeTime", "preserveDirectoryTime", "preservedFiledate", "preserveTimeDate", "preserveLineSince", "preservingFilesDate", "preserveLinedate", "preservingFilesSince", "preservedFileDay", "preserveFileTime", "preservedTimeDate", "preserveFilesTime", "preserveDirectoryDay", "preserveDirectoryDate", "preserveLineDate", "preservingFileDate", "preserveFilesDate", "preserveFilesdate", "preserveFilesDay", "preserveTimedate", "preservedFileTime", "preservingFiledate", "preserveUnitDate", "preserveFilesSince", "preserveTimeTime", "preservedTimeDay", "preservedFileDate"], "input": ["event", "audio", "buffer", "address", "i", "temp", "copy", "self", "feed", "socket", "current", "inner", "error", "instance", "child", "active", "in", "form", "client", "source", "reader", "binary", "Input", "up", "connection", "upload", "open", "parent", "config", "channel", "out", "file", "data", "ip", "request", "context", "null", "conn", "internal", "exec", "io", "image", "url", "stream", "this", "api", "view"], "output": ["address", "ou", "audio", "core", "console", "response", "copy", "four", "outer", "feed", "video", "Output", "version", "socket", "oper", "ilo", "current", "o", "child", "write", "flow", "queue", "next", "source", "operation", "connection", "target", "other", "application", "parent", "config", "file", "out", "channel", "object", "environment", "put", "null", "control", "again", "io", "writer", "image", "unit", "download", "office", "external"]}}
{"id1": "19810820", "id2": "13063241", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copyFileChannel": ["copyFilechannel", "transferfileStream", "copyDirectoryChannel", "copyDirectoryChan", "copyDirectorychannel", "copyStreamChan", "copyfileStream", "transferFilechannel", "transferFileChan", "copyDirectoryStream", "copyfileChan", "transferFileStream", "transferFileChannel", "transferfilechannel", "transferfileChan", "copyStreamChannel", "copyfileChannel", "copyFileChan", "copyStreamStream", "copyStreamchannel", "copyFileStream", "transferfileChannel", "copyfilechannel"], "src": ["path", "rest", "sel", "sin", "ssl", "sc", "server", "input", "sys", "rc", "Source", "lower", "slice", "filename", "sub", "dest", "loc", "s", "inst", "func", "rs", "SOURCE", "sync", "client", "sit", "source", "rb", "sb", "dist", "upload", "config", "ruby", "tmp", "sq", "conn", "ls", "sth", "start", "RC", "sup", "sl", "ctx", "url", "ses", "scene", "stream", "b", "st", "cur", "download", "img"], "dst": ["tst", "drc", " dST", "dart", "adrc", "adST", "ddest", "Ddest", "DST", "adput", "stlt", "bart", "bst", "dST", "Dost", "fdst", "dost", " ddest", "bput", "tart", "fdrc", "ldost", "lddest", "ldST", "dput", "bST", "start", "ldst", "fdput", "Dst", "stst", "stST", "blt", "adst", "dlt", " dost", "fdST", "tlt", "brc", "tST"], "preserveModificationTime": ["preserveModifiedFile", "preserveModifyingTime", "preserveModifytime", "preserveModifyTime", "preserveMinificationFile", "preserveMinificationTime", "preserveModationFile", "preserveModifiedtime", "preserveModifiedTime", "preserveModifyingFile", "preserveMinifiedtime", "preserveMinificationtime", "preserveModificationFile", "preserveMinifiedTime", "preserveMinifiedFile", "preserveModificationtime", "preserveModationTime", "preserveModifyingtime", "preserveModationtime"], "inputChannel": ["errorChannel", "fileConnection", " inputConnection", "outputConnection", " inputBuffer", " inputchannel", "inputchannel", "inputSocket", "InputBuffer", "outputBuffer", "outputGate", "imagechannel", "imageGate", "InputQueue", "binaryGate", "binaryChan", "fileChannel", "outputSocket", " inputSocket", " inputConsole", "InputSocket", "outputQueue", " inputCode", "inputChan", " inputQueue", "fileChan", "inputConsole", "inputBuffer", "binarychannel", "inputConnection", " inputStream", "errorChan", "errorCache", "outputCache", "outputStream", "inputCache", "errorStream", "inputStream", "outputchannel", "InputChannel", "requestStream", "requestCode", "Inputchannel", "fileConsole", "binaryChannel", "outputConsole", " inputChan", " inputCache", "outputChan", "InputChan", "inputGate", "inputQueue", "outputCode", "requestChan", "imageChan", "requestChannel", "imageChannel", "inputCode"], "outputChannel": ["Outputchannel", " outputchannel", "outputManager", "OutputQueue", " outputQueue", "OutputChannel", " outputManager", " outputButton", "outputQueue", "inputChan", "outStream", "outchannel", "outChan", "OutputStream", "writeQueue", " outputStream", "writeChannel", "outputStream", "outputchannel", "inputStream", " outputChan", "outputButton", "outButton", "writeStream", "writeManager", "outputChan", "OutputChan", "writeChan", "outChannel", "inputButton", "inputManager"], "length": ["base", "max", "sum", "buffer", "head", "duration", "id", "lock", "sequence", "slave", "current", "end", "result", "volume", "limit", "l", "join", "php", "child", "number", "last", "offset", "next", "form", "part", "session", "type", "load", "delay", "value", "len", "Length", "build", "section", "text", "size", "style", "complete", "start", "available", "full", "pull", "position", "partial", "with", "count", "block", "width"], "total": ["base", "max", "sum", "i", "translation", "duration", "id", "info", "current", "result", "limit", "set", "all", "otal", "done", "failed", "key", "last", "offset", "part", "less", "type", "no", "Total", "len", "used", "size", "complete", "start", "available", "toc", "full", "always", "partial", "count", "found", "multi", "scale", "error", "cur", "valid"]}}
{"id1": "11049257", "id2": "19206412", "code1": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "code2": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"generate": ["Generate", " genating", "Generating", "validation", "generating", " genation", "GenerATE", " genATE", "validate", "generATE", " genate", "Generation", "validating", "validATE", "generation"], "secure": ["ite", "zip", "remote", "ssl", "protect", "express", "ssh", "server", "sys", "secondary", "socket", "weak", " securely", "host", "security", "password", "client", "session", "proxy", "quiet", "debug", "config", "sensitive", "https", "encrypted", "sq", "force", "stable", "Secure", " insecure", "service", "secret", "deep", " secured", "sr", "sec"], "sep": ["spepel", "ensept", "seep", " sepel", "ensepent", "perseep", "spept", " seep", " sepa", "sepent", " sepent", "persep", "ensepel", " sept", "spepent", "sept", "persepa", "SEb", " seb", "SEep", "sepel", "perseb", "sepa", "ensep", "seb", "SEp", "SEpa", "spep"], "messagedigest": ["messageddigher", "messagighse", "messagedagester", "messagigist", "messagedimest", "messagagher", "messagighEST", "messagedligress", "messagedigress", "messagedimester", "messagedighest", "messagedligester", "messagigester", "messagedigester", "messagedagest", "messagedaghest", "messagedegester", "messagedigEST", "messagedigist", "messagedigse", "messagigest", "messagedligest", "messagaghest", "messagedighEST", "messagedimist", "messageddigester", "messagedimress", "messagedagist", "messagedighester", "messagedligse", "messagigress", "messagagress", "messagigher", "messageddigest", "messagighester", "messagedagher", "messagagse", "messagedagse", "messagedegher", "messagedligist", "messagagest", "messagagist", "messagedighse", "messagedagress", "messagagester", "messagagEST", "messagedegest", "messagedeghest", "messagighest", "messagedigher", "messageddighest", "messagigse", "messagedagEST", "messagedligEST", "messagigEST"], "stringbuffer": ["groupbuffer", "serialbuffer", "serialbuff", "defaultbuf", "ringsource", "linebuff", "stringbuf", "numberbuf", "arraybase", "ringmanager", "stringbuff", "binarybuff", "linequeue", "defaultqueue", "serialcache", "numberbuilder", "groupbuf", "Stringbuilder", "numberaddress", "stringqueue", "writebuff", "stringbuilder", "stringboard", "binarybuf", "systembuffer", "systembuff", "filemanager", "stringmanager", " stringbuff", "defaultbuffer", "binarythrow", "serialboard", "stringcache", " stringbuf", "stringsource", "stringaddress", "filesource", "jsonbuf", "numberqueue", "writethrow", "stringurl", "stringthrow", "filecache", "groupuffer", "fileurl", "Stringbase", "arraybuffer", "binarybuffer", " stringqueue", " stringboard", " stringthrow", "arraybuilder", "groupaddress", "systemqueue", "linebuf", "writebuf", "numberbuffer", "functionqueue", "jsonaddress", " stringaddress", "stringbase", "numberbase", " stringuffer", "ringurl", " stringmanager", "linebuffer", "stringuffer", "systembuf", "filebuff", " stringsource", "Stringbuf", "functionbuffer", "ringbuffer", "arraybuf", "functionbuff", "jsonbuffer", "writebuffer", " stringcache", "Stringbuffer", "filebuffer", "functionbuf", " stringurl", "jsonuffer", "fileboard", "defaultaddress"], "stringbuffer2": ["stringloaderII", " stringBuffer3", "stringbuffer5", " stringfb20", " stringcomment002", "stringbuffer52", " stringcache12", "doubleBuffer1", "finalbufferTwo", "stringbarTwo", " stringcache02", "stringcomment2", "stringbufferAll", "stringbufCache", "stringfb8", "doublebuffer4", "doubleBufferTwo", "stringbar5", " stringbuffer32", " stringBuffer2", "stringbufTwo", "stringbar2", "doubleBuffer4", "stringbuf4", " stringcommentTwo", "listloopL", "listloop02", " stringreader64", "stringpageTwo", " stringbufferTwo", "listbuffer2", " stringloop2", "stringcopy62", "stringbuffer82", " stringbuffer20", " stringBuffer52", "stringBuffer2", "stringbuilder10", "stringcommentTwo", "stringbuff1", "stringfbTwo", " stringloop200", "stringbuffer20", " stringbuffer82", " stringBuffer4", " stringcode2", "stringbuffer200", "doubleBuffer2", "stringbuffer12", "stringpage02", " stringfbCache", "objectbuffer62", "stringreader64", " stringbuffer3", " stringcache2", "stringbuffer4", "stringqueue2", "stringbufferTwo", "finalbuffTwo", " stringreaderII", "stringbufferL", "stringbuilder2", " stringbuffer002", "stringbuff4", "stringbuf3", "stringbufferCache", "stringfb200", "stringserverType", "stringcodeTwo", " stringbuffer64", "stringloader2", "stringviewTwo", "stringbuff5", "stringloop8", "stringcode32", "stringcache10", " stringloop8", "finalbuff5", " stringreaderTwo", "stringbuf5", "stringBuffer52", "stringbuff8", "stringbase4", "stringfb2", "stringufferTwo", "stringbreak4", "stringbuffer02", "stringbuffer8", "stringloopTwo", "stringloop200", "stringufferII", "stringuffer2", "stringcomment82", "stringpageL", " stringcodeTwo", "listbuffer02", "stringbuffer10", "stringpage2", " stringfb2", "objectbuff2", " stringbuffer52", "stringloaderTwo", " stringbufferII", "stringuffer64", "listloopTwo", "stringloop02", "doublebuffer1", "stringqueue5", "doublebuffer52", "stringbase2", " stringbufferAll", "stringserver2", "stringbreak3", "stringcache12", "stringserver5", " stringbuffer8", "listbufferL", "stringbufAll", "stringbuff62", " stringcomment82", "stringbase3", "stringbreak1", "stringbuf20", "doubleBuffer52", "stringbuf2", "stringserver002", "objectbuff5", "stringbuf52", "stringfb20", "stringbufType", "stringreader2", "stringbuffer64", "stringfbAll", " stringbuffer4", "finalbuffer2", "stringbuffAll", " stringbuffer10", "stringBuffer1", " stringcache10", "stringBufferTwo", "finalbuff2", "stringbuffer3", "stringbuf82", "stringbuf002", "stringcache02", "stringbuffer32", "stringbuffer62", "stringbreak2", "stringbuffCache", "stringcomment002", " stringbuffer12", "finalbuffType", "stringBuffer4", " stringcode5", "listbufferTwo", "stringloader64", "stringreaderII", "objectbuffer5", "stringbuff10", "finalbuffer5", "stringcopy2", " stringbuffer02", "stringview4", "stringbuffType", "stringview2", "stringbuff3", "doublebuffer3", "stringbufferType", "listloop2", "stringbuffL", "stringview52", "stringcopy5", " stringbufferCache", " stringfbAll", "stringcode2", " stringreader2", "stringbuff20", "stringbufferII", "stringbase52", "stringbuffer002", " stringbuffer5", "stringbuff200", "stringserver82", "stringcache2", "objectbuffer2", " stringcomment2", "stringbuff32", "stringserverTwo", "stringbuff2", "doublebufferTwo", "stringBuffer3", "doublebuffer2", "stringloopL", "stringbuilder02", " stringbuffer200", "stringbuff12", "stringbuilder12", "stringreaderTwo", "stringbuffTwo", "stringbar32", "finalbufferType", "stringfbCache", " stringcode32", " stringloopTwo", "stringbuff02", "stringloop2", "objectbuff62", "stringqueue62", "doubleBuffer3", "stringcode5"], "inetaddress": ["tunaccount", "etaccount", "tunimage", "inetaccount", "netaddress", "iotaccount", "iotAddress", "netAddress", "netaddr", "iotimage", "inethost", "ethost", "nethost", "inetimage", "networkAddress", "networkhost", "etaddress", "networkaddr", "iotaddress", "etimage", "inetAddress", "tunaddress", "etaddr", "networkaddress", "etAddress", "tunAddress", "inetaddr"], "l": ["lang", "n", "lf", "kl", "lp", "lb", "c", "tl", "z", "lr", "length", "el", "dl", "d", "lc", "r", "li", "al", "nl", "ll", "p", "u", "ls", "m", "t", "sl", "rl", "ln", "b", "v", "lv", "f", "L"], "l1": ["sl5", "l7", "ll81", "L2", "Lx", "il5", "L1", "llone", "L7", "ll1", "il51", "cl2", "lOne", "clOne", "lc1", " l5", " l7", " lone", "l2", "sl51", " l51", "sl1", "L81", "sl2", "ll2", "l81", "l5", " l81", "lcx", " l2", "cl1", "il1", " lOne", " lx", "Lone", "lone", "slOne", "lc2", "lx", "l51", "lc7"], "abyte0": ["abytes8", "iterator8", "umbo0", "gmentkeeper", "abytes1", "abyte000", "iterator0", "gmentzero", " arrayzero", "gment0", "omei", "ome0", "ome1", "abytej", " arraykeeper", "umboj", "abasekeeper", "abyte50", "omej", "byte8", "abyte1", "umboi", "umbo1", "bytej", "byte1", "iterator000", "abytekeeper", "iterator1", "abasezero", "abytezero", "byte000", "abase50", "abytes0", "abyte8", " array50", "gment50", "bytei", "abase0", "abytes000", "byte0", "abytei", " array0"], "stringbuffer1": ["stringview1", "doubleBuffer1", "StringBuffer8", "stringlayer1", "stringviewFirst", "stringBuffer2", " stringview81", "stringbuff1", "doublebufferOne", "stringlayer81", "doubleBuffer2", " stringbuffer3", "stringuffer3", "stringuffer1", "stringbuilder2", "stringBuffer81", "stringbuf3", " stringview1", "stringbuffer01", "stringbuilder1", "StringBuffer1", "stringbuff8", "stringviewone", "stringufferFirst", "Stringbuffer11", "stringbuffer8", "stringbuffer81", "stringuffer2", "stringlayerFirst", "doublebuffer1", "stringuffer81", "stringview81", "stringbuilder11", "doubleBufferOne", " stringbufferone", "doublebuffer81", " stringbuffer01", "Stringbuffer2", "stringbufferOne", "stringBufferOne", " stringuffer3", "stringBuffer1", "stringufferone", "stringbuff01", "stringbuffer3", "stringbuilder8", "Stringbuffer8", "stringuffer01", "stringbufferone", " stringbufferFirst", " stringbuffer81", "stringBuffer8", "stringbuff11", "stringbuff3", "stringbufferFirst", " stringviewFirst", "Stringbuffer1", " stringviewone", " stringuffer01", "StringBuffer11", "stringbuf01", "stringufferOne", "stringbuffer11", "StringBuffer2", "doubleBuffer81", "stringbuff2", "stringbuf1", "doublebuffer2", "stringBuffer11", "stringlayerone", " stringuffer1"], "i": ["index", "id", "uri", "pi", "n", "ini", "ie", "yi", "ind", "slice", "c", "z", "ri", "o", "fi", "si", "ui", "ii", "in", "ori", "qi", "vi", "ji", "ti", "d", "phi", "li", "ip", "x", "p", "h", "mi", "u", "bi", "oi", "ai", "ci", "I", "io", "e", "eni", "xi", "di", "gi", "hi", "k", "v", "y", "abi", "iu", "f", "ix"], "j": ["job", "n", "jet", "note", "ij", "dj", "json", "jc", "c", "ie", "z", "o", "jl", "length", "jo", "si", "ii", "aj", "qi", "ja", "ji", "d", "ch", "g", "bj", "li", "x", "p", "journal", "jj", "J", "js", "e", "kj", "jp", "k", "ali", "b", "v", "obj", "adj", "oj", "f", "jack", "ix", "cell"], "s": ["services", "string", "bis", "ssl", "sports", "n", "fs", "http", "results", "ns", "c", "S", "as", "o", "ins", "qs", "bs", "styles", "abs", "is", "series", "ms", "rs", "hs", "ings", "parts", "states", "its", "ws", "lines", "sb", "strings", "r", "sv", "g", "str", "gs", "xs", "h", "p", "es", "south", "u", "ts", "sites", "hes", "ls", "js", "e", "m", "sets", "tests", "t", "seconds", "resses", "ss", "a", "us", "ches", "ses", "ions", "b", "v", "words", "os", "f", "ps"]}}
{"id1": "1769771", "id2": "23666867", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyChannel", "copyChannel", "CopyFile", "copyfile", "transferfile", "transferFiles", "transferChannel", " copyFiles", "Copyfile", " copyChannel", "CopyFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "base", "pin", "i", "input", "id", "ex", "lock", "c", "inner", "l", "ins", "bin", "query", "source", "reader", "login", "min", "diff", "inc", "work", "config", "file", "data", "again", "name", "m", "image", "io", "In", "url", "lin", "inn", "f", "win"], "out": ["string", "base", "ex", "n", "output", "server", "resource", "user", "plain", "OUT", "c", "o", "outs", "off", "write", "extra", "cache", "dot", "up", "target", "default", "w", "file", "x", "p", "conn", "name", "again", "exec", "Out", "io", "writer", "image", "call", "prefix", "ext", "v", "b", "external", "point"], "inChannel": ["binStream", "inputChannel", "INchannel", "binchannel", "inStream", " inchannel", "inputchannel", " inClient", "winChan", "binClient", "inchannel", "binChan", "InChan", "Inchannel", "inputChan", "INChan", "outStream", "outchannel", "outChan", "inChan", "InChannel", "insClient", "outClient", "insStream", "InStream", "inputStream", "insChannel", "binChannel", "INStream", "winChannel", "winchannel", "INChannel", " inStream", "InClient", "inClient", " inChan", "insChan", "winStream"], "outChannel": ["outputCh", "inputChannel", "inStream", "inputchannel", "OutConnection", "OutChannel", "inchannel", " outConnection", "nManager", "nChan", "OutChan", "inCh", "inputChan", "outStream", "outchannel", "nChannel", "outChan", "inChan", "inputController", "outputStream", "outputChannel", "outputchannel", "outputController", " outCh", "outConnection", "Outchannel", "nStream", "outCh", " outManager", "inConnection", "outputChan", " outStream", "inManager", "outController", "outManager", "inController", " outchannel", " outChan"]}}
{"id1": "14191679", "id2": "9846843", "code1": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"EncodeReturn": ["EnccodeData", "EnodedReturns", "EnccodeReturns", "EnodedReturn", "EncodReturn", "EncodeData", "EncodeResult", "EnodeReturns", "EnodedResult", "EnodeReturn", "EncodData", "EnodeResult", "EncodResult", "EnodeData", "EnccodeReturn", "EncodReturns", "EncodeReturns", "EnodedData", "EnccodeResult"], "IOException": ["IOError", "DownloadError", " IOception", "IPException", "DownloadException", "IOception", " IOError", "IPError", "IPception", "Downloadception"], "c": ["cu", "cc", "sc", "n", "cmp", "cf", "enc", "gc", "fc", "l", "dc", "cpp", "nc", "ec", "client", "cp", "ce", "proc", "lc", "d", "ct", "cache", "uc", "r", "ch", "conv", "xc", "p", "cd", "C", "u", "ci", "e", "m", "t", "cr", "chain", "pc", "mc", "b", "y", "ac", "cs", "f", "cur"], "tmpf": ["zipF", "poraryf", "tempfen", "vmF", " tmpfs", "tempcf", " tmpF", "vmf", "tmpcf", "poraryfen", "tmpfd", "tempf", "tempfs", "tempF", "zipfs", "empf", "porarycf", "tmpF", "empF", "empfd", "vmfs", "empfs", "vmcf", "poraryF", "zipf", " tmpfen", " tmpcf", "zipfd", "tmpfen", "tempfd", "tmpfs"], "cw": [" cW", " cwa", "pw", "rcwd", " cwd", "cwe", " cwe", "ffw", "fw", "fwa", " cfw", "psw", "CW", "cW", "pwa", "fws", "lcwb", "cwd", "lcw", "lcwd", "rcwe", "pW", "Cw", " cwb", "cws", "lcwe", "cwa", "rcwb", "cfw", "csw", "Csw", "Cfw", "Cws", "Cwa", " csw", "rcw", "cwb", " cws"], "encdata": ["Enckeys", "encdatabase", "envreader", " enccache", " encdatabase", "secdata", "extdatabase", "envkeys", "envData", "extdat", "installdat", "encreader", "increader", " encdat", "seckeys", "secData", " encroot", "incdata", "envdat", "installdata", "EncData", "enckeys", "installData", " encreader", "Encdata", "extdata", "encdat", "envdata", "envroot", "Encdat", "encroot", "inccache", "installdatabase", "envcache", "encData", "incroot", " encData", "secdat", "extData", "enccache"], "pigdata": ["Pigsla", "pigsla", "pagresults", "Pigdata", "pippdata", "pocdat", "picresource", "Pibresource", "pigData", "pibData", "Pigsresults", "pibresource", "pibdat", "pocresource", "Pigdat", "Pigcache", "Pigla", "pichData", "Pigresource", "pocdata", "picdata", "pagdat", "pigscache", "pagData", "pigresults", "pigsdat", "Pigresults", "pigrData", "pagdata", "pigsdata", "pigrresults", "Pigsdat", "pigsData", "pigrdat", "pocData", "pippcache", "pibdata", "pigsresults", "Pigsdata", "pichcache", "pigcache", "pigrdata", "PigsData", "PibData", "Pigscache", "pippla", "pichla", "pichdata", "pigresource", "pigla", "picData", "picdat", "Pibdata", "PigData", "Pibdat", "pippData", "pigdat"], "pigroute": ["pipelange", "fibrote", "apigrouting", "miarune", "figrote", "apibrouting", "pigerote", "pipelune", "pigrouting", "figroute", "apigrroute", "fibrange", "pibrroute", "pirmouting", "migrote", "pirmroute", "pigrationoute", "pigrationange", "pibroute", "pigrange", "pibrange", "apigrouter", "pigerouting", "pigerune", "fibroute", "pigrroute", "pipelote", "pigrationroute", "pigrationote", "pibrouting", "apibrouter", "pigeroute", "pirmoute", "fibrroute", "figrroute", "piarote", "figrange", "migroute", "miaroute", "pipeloute", "apigroute", "pibrouter", "miarouting", "apibroute", "pigrote", "pirmouter", "pigrationouting", "pigrune", "pibrote", "miarote", "pigrouter", "piarouting", "migrune", "pigrationouter", "pipelroute", "piarune", "piaroute", "apibrroute", "migrouting", "pipelouting"], "fos": ["fops", "pOS", "poes", " fops", "Foes", "refos", "Foc", "refOS", " fOS", "tos", "Fos", "refoes", " foes", "fo", "pops", "pos", "toc", "to", "Fo", " fo", "toes", "fOS", "foes", "refops"], "foc": ["infec", "Fac", "infoc", "infocol", "infic", "Fec", "Focol", " focol", " fac", "Foc", "Fic", "infac", " fec", "focol", "fac", "fec"], "fis": ["cig", "fig", "fi", "infic", "infis", "cic", "Fig", "cics", "Fi", "Fic", "infi", " fi", "cis", "Fis", "fics", " fics", "infics", " fig", "Fics"], "fic": ["Fico", "cfic", " fico", "Fac", "infoc", "cfis", "cfics", "cfoc", "infic", "poc", "rfics", "fisc", "pis", "Foc", " fac", "Fisc", "rfic", "pac", " fisc", "Fic", "fico", "Fis", "pic", "fics", "rfis", " fics", "cfico", "infics", "rfoc", "infisc", "Fics", "fac"]}}
{"id1": "255765", "id2": "4921631", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 0, "substitutes": {"f": ["path", "fun", "fe", "sf", "n", "fs", "feed", "cf", "df", "fa", "lf", "bf", "rf", "filename", "c", "ref", "j", "fc", "fp", "fi", "l", "s", "fn", "fr", "ff", "form", "fold", "d", "r", "g", "w", "file", "flat", "h", "x", "p", "name", "folder", "e", "m", "io", "t", "fo", "fm", "function", "F", "fd", "self", "a", "fen", "of", "v", "b", "tf", "inf", "this", "fx"], "in": ["IN", "pin", "ssl", "fa", "token", "ini", "ic", "ins", "bin", "thin", "vin", "get", "gen", "it", "a", "with", "din", "ex", "serv", "lock", "part", "source", "up", "connection", "min", "r", "str", "g", "w", "rin", "again", "exec", "isin", "In", "lin", "b", "v", "inn", "win", "n", "gin", "con", "inner", "socket", "session", "reader", "d", "diff", "p", "init", "or", "m", "image", "nin", "ac", "cin", "fe", "input", "c", "l", "pass", "is", "login", "inc", "config", "data", "rec", "t", "err"], "cbuf": ["cbux", "dbuf", "zbuff", "bbuff", "fbbuf", "cfbuf", "rbuff", "bbull", "cbul", "bcul", "CBuc", "bcuc", "bcull", "CBuf", "CBuff", "zbuu", "cfuf", "fbuc", "bcurs", "dbuc", "rbuc", "cbutf", "rbuu", "cbbuf", "cburs", "CBul", "bault", "bux", "buff", "ebuu", "buf", "cfuc", "rbutf", "rbbuf", "rbull", "bcuf", "bcuff", "bcault", "ebuf", "fbuff", "rbux", "zbuf", "bcur", "ebutf", "cbuff", "rbuf", "rburs", "rbul", "cbull", "cbuc", "bbuf", "cbuu", "cfuff", "fbuf", "zbutf", "dbuff", "ebuff", "bburs", "bcux", "dbur", "cfur", "rbault", "cbur", "cbault"], "read": ["index", "Read", "each", "hex", "run", "ride", "en", "raw", "only", "q", "build", "open", "used", "get", "lex", "it", "readable", "ed", "print", "know", "buffer", "num", "id", "feed", "rc", "add", "report", "oct", "ack", "ind", "end", "find", "sync", "use", "load", "r", "g", "work", "w", "level", "un", " READ", "fill", "name", "bit", "ing", "full", "skip", "connect", " reading", "val", "play", "close", "reading", "ok", "socket", "se", "length", "write", "record", "iter", "sleep", "loop", "er", "allow", "reader", "d", "old", " Read", "bind", "insert", "start", "change", "io", "update", "create", "y", "wait", "repeat", " write", "ink", "error", "view", "valid", "ak", "input", "child", "draw", "reads", "pass", "key", "last", "select", "type", "want", "seek", "inc", "data", "text", "config", "check", "x", "size", "log", "put", "cel", "send", "call", "pe", "k", "parse", "stream", "ize", "count", "READ", "re", "orig"], "totRead": ["octotoLength", "tottedWrite", "TotGet", "tcotClose", "tcotRead", "dottLoad", "octotWrite", " totalBuild", "tottedGet", "tntReader", "tottUse", "octotoRead", "totLink", "totBuild", "towLength", "dottReader", "totoLength", "tazonClose", "tetReading", "toyDraw", "totClose", "totiBuild", " totWrite", "notLoad", "notWrite", "intottBuild", "tottLength", "tottAccept", "totalLoad", "towLoad", "totalLink", " totalWrite", "nottAccept", "towWrite", "nottRead", "totoSearch", "tochRead", "intotLoad", "tottReading", "tottWrite", "toyWrite", "tollRead", "tottedRead", "tottLoad", "octotLength", "TotConnect", "ntotWrite", "tetRead", "TotLoad", "totoUse", "tntRead", "dottUse", "octotReading", "TottConnect", "ntottLoad", "TotSearch", "TotaRead", "totoLoad", "tntLoad", "TotaLoad", "tottClose", "totDraw", "totLength", "towAccept", "TottReading", "tobyRead", "intotClose", "towReading", "totingSearch", "totaDraw", "totoWrite", "TotDraw", "nottLoad", "toyRead", "tcotBuild", "totReading", "totConnect", "octotRead", "ntottWrite", "totalAccept", "totalRead", "totLoad", "tazonBuild", "totalBuild", "tntWrite", "totoRead", "dotRead", "ntotRead", "totingWrite", "ntotLoad", "totReader", "notAccept", "totaRead", " totBuild", "tottSearch", "ntottReader", "notRead", "totingRead", "totWrite", "tazonLoad", "totingGet", "dotLoad", "dotReader", "dotUse", "dottFind", "tobyFind", "TotaWrite", "tochLoad", "tottedFollow", "ntotReader", "intotRead", "intottLoad", "totUse", "totaReading", "totaLoad", "totaWrite", "tcotLoad", "TottReader", "tottReader", "totiRead", "tatRead", "totiWrite", "dottWrite", "toyLoad", "TottFollow", "tottFollow", "tatLoad", "totingConnect", "dotFind", "tochReader", "tottConnect", "dottReading", "intotBuild", "TotReader", "totoFind", "tollLoad", "tochWrite", "tobyUse", "tottDraw", "dottRead", "totaLink", "tobyLoad", "totoConnect", " totalRead", "totingFollow", "TottLoad", "TottWrite", "TotaDraw", "tottRead", "tetWrite", "totFind", "nottWrite", "towRead", "TotReading", "totalWrite", "octotoReading", "tollReading", "tatReader", "tollWrite", "dotReading", "tottFind", "ntottRead", "intottRead", "totiLink", "totFollow", "tetLoad", " totalLink", "tazonRead", "totSearch", "TotFollow", "totGet", "octotoWrite", "TottRead", "TotRead", "totaBuild", "TottGet", " totLink", "intottClose", "totoReading", "tottGet", "TottSearch", "totaReader", "dotWrite", "totAccept", "tottBuild", "tatWrite", "TotWrite"], "out": ["ex", "output", "n", "plus", "outer", "net", "c", "OUT", "socket", "o", "outs", "l", "fn", "s", "off", "bin", "client", "sync", "part", "d", "up", "connection", "r", "g", "w", "inc", "parent", "file", "h", "x", "p", "conn", "init", "again", "exec", "Out", "io", "t", "exp", "writer", "In", "a", "ext", "conf", "v", "b", "err", "obj", "ac"], "i": ["index", "ini", "ic", "ii", "q", "chi", "ci", "I", "eni", "zi", "it", "hi", "iu", "multi", "info", "buffer", "id", "ind", "z", "ui", "ori", "ti", "source", "r", "g", "ip", "mi", "ai", "name", "oi", "e", "b", "v", "ik", "uri", "ei", "yi", "slice", "o", "length", "qi", "one", "ji", "d", "phi", "h", "p", "bi", "u", "init", "start", "m", "io", "di", "y", "ni", "api", "ix", "input", "pi", "ie", "c", "current", "j", "fi", "ri", "l", "si", "is", "key", "my", "data", "li", "x", "xi", "gi", "k", "me", "abi"]}}
{"id1": "11183087", "id2": "8064604", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"doPost": ["handlePut", "handlePOST", "doingPut", "doingPOST", "handleSearch", " doPOST", "doSearch", " doPut", "doPut", "handlePost", "doingSearch", "doPOST", " doSearch", "doingPost"], "request": ["event", "remote", "info", "order", "buffer", "input", "Request", "server", "resource", "rf", "user", "report", "http", "subject", "message", "have", "current", "project", "result", "join", "instance", "child", "forward", "press", "query", "queue", "req", "post", "er", "client", "rate", "type", "use", "q", "the", "model", "r", "application", "config", "data", "parent", "route", "web", "get", "object", "context", "view", "complete", "hello", "e", "QUEST", "image", "frame", "call", "pull", "url", "pe", "create", "right", "xml", "state", "error", "external", "enter", "initial"], "response": ["server", "resource", "output", "http", "report", "results", "message", "document", "res", "site", "onse", "result", "pool", "next", "client", "resp", "connection", "model", "application", "parent", "body", "page", "object", "web", "reply", "template", "writer", "status", "Response", "respond", "guide", "api", "view"], "senha": ["suitha", "senca", " senwa", "sensha", "zenha", "zensha", "senaka", "zenca", " senHa", "zenHa", "renha", "tonlah", " senaka", "sanha", "suitla", "tonwa", "renca", "sanwa", "tonha", "renHa", "tonHa", "senwa", "snsha", "senhi", "suitsha", "sanlah", "snla", " senca", "zenaka", "suithi", "senHa", "snha", "renaka", "snhi", " senlah", "sanHa", "senla", "zenla", "zenhi", "senlah"], "email": ["letter", "string", "zip", "address", "server", "id", "username", "user", "mail", "message", "account", "line", "Email", "password", "login", "model", "alias", "data", "file", "ip", "environment", "language", "hello", "name", "example", "e", "home", "label", "mobile", "url", "fax", "secret", "xml", "business", "office", "phrase", "service"], "messageDigest": ["medigher", " messageDEST", "medigester", " messagedigEST", "messagedigest", " messagedigest", "messagedigester", " messageDest", "messageDigester", "medigest", "messagedigEST", "messageMailest", " messageDigester", "messageDEST", "messageMailester", "messageMailEST", "messageDher", "messageDend", " messageDester", "messageDigher", " messageDend", "messagedigend", "messageDest", "meDigher", "meDigest", "messageDigend", "messageDester", "meDigester", "messageDigEST", " messageDigend", " messagedigester", "meDigEST", "medigEST", "messagedigher", " messageDigEST", "messageMailend"], "usuario": ["ususillo", " usuiarium", "uslurio", "usueariat", "suluario", "usituario", " usurio", "usuiasio", " ususarius", "usuarium", "usuitrio", "usuitarium", "usuirio", "usuarius", "ususario", " ususario", "usluasio", " usuasio", " usuarius", " ususillo", "sulurio", "usuillo", "usurio", " usuariat", "usueillo", "ussuarial", "usuasio", "ussurio", "usuarial", "usuitasio", " usuirio", "usuiario", " usuarium", "usueario", "usguarius", "usuitario", "ussuasio", "suluarial", " usuiasio", "suuario", "ussuario", "usguario", "suurio", "suuarial", "ussuarium", "ususarius", " usuillo", "usuariat", "suluasio", "usuearius", "usluarial", "suuasio", "usiturio", "usluario", "ususariat", "usguillo", "usuiarium", " usuiario", "usituasio", "usguariat", " ususariat", "usituarial"], "redirect": ["redRECT", "Redroute", " redrict", "predrict", " redurl", " reduce", "indirect", "predRECT", "Redition", "reduce", "rerict", "reroute", "redirection", "redrict", "redroute", "predroute", " redRECT", "predirect", "RedRECT", "indrict", "reirection", "indirection", "edirection", "edition", "Redrict", "redurl", " redition", "induce", "edirect", "edurl", "reirect", "Redirection", " redirection", "Redirect", "preduce", "predirection", "Redurl", "redition"], "session": ["event", "info", "ssl", "ession", "node", "input", "server", "user", "http", "site", "message", "document", "system", "result", "child", "sid", "query", "client", "use", "cache", "proxy", "browser", "connection", "group", "config", "data", "page", "object", "flash", "Session", "image", "person", "sl", "app", "comment", "sp", "cookie", "state", "service", "view", "storage"]}}
{"id1": "11341711", "id2": "9347451", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"makeBackup": ["createBackUp", "makePickup", "makeBackups", "makeCleanUp", "makePickdown", "makeCleanups", "makebackdown", "makeBackdown", "makePickUp", "createbackUp", "makePickups", "createbackups", "createBackup", "makebackUp", "createBackdown", "makebackup", "createbackdown", "makeCleandown", "makeBackUp", "createBackups", "createbackup", "makeCleanup", "makebackups"], "dir": ["directory", "zip", "root", "path", "base", "pkg", "rc", "run", "dest", "manager", "done", "wd", "source", "Dir", "d", "cache", "doc", "up", "diff", "lib", "dist", "group", "build", "work", "config", "store", "file", "ir", "data", "md", "director", "log", "init", "folder", "Directory", "desc", "dict", "io", "name", "db", "DIR", "url", "dep", "module", "download", "direction"], "sourcedir": ["sourcedirs", "sourcesiri", "sodedIR", "seedir", "sodeddir", "sortedIR", "sourcesdir", "ssourcediri", "sourcesir", "sodediri", "sodedir", "sourceddir", "ssourcedIR", "seedIR", "seediri", "sortedirs", "sourcesore", "asourcedIR", "sourcesIR", "ssodedIR", "seeddir", "sortedore", "asourcedir", "sodedore", "sourcediri", "sodedirs", "asourcedirs", "sourcedIR", "asourcedore", "sourcedore", "asortedirs", "sourcesirs", "asortedore", "ssourcedir", "ssourceddir", "ssodeddir", "asortedIR", "asortedir", "ssodedir", "sortedir", "ssodediri"], "destinationdir": ["destinatorfile", "desturationdirection", "destinateDIR", "DestificationDir", "destinatedir", "Destinationdirection", "dominationDIR", "desturationfolder", "Destificationdir", "destinatorDIR", "dominationdir", "destificationfolder", "destinationfolder", "destinationsfile", "Destificationfolder", "Destificationdirection", "destinationdirection", "destinationsDIR", "destificationdirection", "destificationDir", "destinatordir", "destinatefolder", "Destinationfolder", "destinationDIR", "destinationDir", "dominatorDir", "dominatorfile", "dominationfile", "dominationDir", "destinationsdir", "destinatedirection", "destinatefile", "dominatordir", "destificationdir", "Destinationdir", "DestinationDir", "desturationDir", "desturationdir", "dominatorDIR", "destinatorDir", "destinationsDir", "destinationfile", "destinateDir"], "destinationDirEnding": ["destinationDirectoryEnding", "destinationDirENDging", "destinationDirBegining", "destinationDirBeginning", "destinationPathEndging", "destinationDirBeginging", "destinationPathBeginING", "destinationDirectorySignING", "destinationPathBeginging", "destinationDirPassING", "destinationDirBeginING", "destinationPathBegining", "destinationDirectoryEndening", "destinationDirectoryEndING", "destinationDirEndining", "destinationDirEndging", "destinationDirPassging", "destinationDirPassning", "destinationDirectoryEndining", "destinationDirEndening", "destinationDirectorySignening", "destinationDirSignening", "destinationDirSignining", "destinationDirPassing", "destinationDirSignING", "destinationPathBeginning", "destinationDirEndning", "destinationDirectorySigning", "destinationDirLeadING", "destinationDirLeading", "destinationDirLeadening", "destinationDirENDning", "destinationDirEndING", "destinationDirENDING", "destinationPathEndning", "destinationDirectorySignining", "destinationDirENDing", "destinationDirSigning", "destinationPathEnding", "destinationDirBeginining", "destinationDirBeginening", "destinationPathEndING", "destinationDirLeadining"], "files": ["keys", "balls", "index", "services", "locks", "output", "fs", "pages", "docs", "resources", "results", "features", "l", "ins", "Files", "reports", "modules", "errors", "ids", "split", "items", "projects", "its", "uploads", "iles", "users", "lines", "flows", "blocks", "children", "parents", "runs", "strings", "bugs", "names", "classes", "file", "data", "images", "objects", " Files", "models", "ips", "groups", "log", "planes", "ls", "thumbnails", "tests", "types", "rows", "books", "actions", "fields", "rules", "xml", "words", "events", "ps", "sections", "boxes", "links"], "checkdir": ["blockDir", "checkdirectory", "checkd", "calld", "blockdraft", "workdirectory", " checklog", "blockdirectory", "CheckDir", "ckdir", " checkfile", "workdir", "ckDir", "workDIR", "workdraft", "Checkdir", "checkDir", "searchdir", "ckfile", "workfile", " checkDIR", "Checkfile", "lockdir", "searchdirectory", " checkfolder", "workfolder", "calldir", " checkFolder", "workFolder", "ckd", "lockFolder", "checkfolder", "searchDir", " checkd", "checkdraft", "checkFolder", "locklog", "CheckDIR", "checklog", "checkDIR", "lockDir", " checkdirectory", "calldirectory", "ckdirectory", "blockdir", "workDir", "worklog", "ckfolder", "checkfile", "searchdraft", "callfolder", " checkDir"], "date": ["event", "mu", "user", "month", "now", "ge", "ime", "late", "set", "tag", "day", "zone", "time", "ate", "dt", "at", "rate", "d", "doc", "Date", "md", "config", "data", "file", "de", "mate", "open", " Date", "log", "start", "name", "e", "m", "image", "change", "update", "sign", "contact", "state", "age", "dat"], "msec": [" mif", " mSec", "csec", "dseconds", "Msecond", "Mseconds", "mnsec", "css", "lsec", "dsecond", "msecond", " minif", "lseconds", "fmisec", "disec", "fmsecond", "mss", "mnsc", "fmseconds", "rseconds", "csecond", "mseconds", "cseconds", " msc", "lss", "mSec", "mnSec", "rsec", "mnif", "rss", "Msec", " minSec", "msc", " minsc", "mif", " minsec", "lsecond", "Misec", "rsecond", "misec", "dsec", "fmsec"], "checkFile": ["changefile", "workFile", "CheckFile", "workFiles", " checkDirectory", "checkFilename", "CheckDir", " checkfile", " checkFilename", "checkFiles", "checkDir", "ckfile", "workfile", "Checkfile", "checkLine", " checkDir", "controlLine", "changeFilename", "ckFiles", "changeFile", " checkFiles", "controlfile", "controlFile", "changeLine", "ckDirectory", "controlFilename", "CheckFiles", "workDir", "checkDirectory", " checkLine", "checkfile", "CheckDirectory", "ckFile"], "i": ["index", "info", "id", "n", "pi", "uri", "mu", "ini", "ie", "slice", "j", "fi", "ri", "si", "ui", "is", "ii", "key", "qi", "part", "vi", "ti", "ji", "phi", "li", "ip", "x", "p", "bi", "u", "ai", "oi", "ci", "I", "e", "io", "eni", "m", "xi", "di", "gi", "hi", "v", "y", "b", "iu", "multi", "field", "im", "ix"], "f": ["info", "fun", "fe", "sf", "n", "fs", "feed", "cf", "df", "fc", "fi", "j", "fp", "o", "fn", "l", "fr", "fl", "d", "q", "r", "w", "file", "fb", "h", "p", "u", "folder", "e", "m", "t", "F", "fd", "b", "v", "fx"], "g": ["vg", "n", "gd", "gh", "gin", "sg", "gc", "ge", "tg", "rg", "l", "global", "s", "gg", "bg", "gb", "gar", "d", "q", "r", "group", "ger", "w", "erg", "gs", "ig", "file", "gn", "gp", "go", "h", "p", "u", "msg", "e", "m", "t", "G", "gi", "og", "reg", "ga", "gu", "eg", "b", "mg", "ng", "gm", "pg"], "destinationFile": ["destinatorLocation", "DestinationFile", "destationfile", "destinationFilename", "DestificationDir", "destinatorDirectory", "DestationDir", "DestinationFilename", "destiningFile", "destacementDir", "DestificationLocation", "destificationFile", "destacementfile", "destinationDirectory", "destationFilename", "destificationLocation", "destacementFilename", "destinationfile", "destationDir", "destinationLocation", "destinationsFile", "destificationDirectory", "destinatorFile", "DestinationLocation", "Destationfile", "destiningFilename", "destinationDir", "DestificationDirectory", "Destinationfile", "destacementFile", "DestationFile", "DestationFilename", "destiningfile", "destiningDir", "DestinationDir", "destinationsLocation", "destationFile", "destinatorDir", "DestificationFile", "destinationsDir", "destinationsDirectory", "destificationDir", "DestinationDirectory"], "sourceFile": ["srcModule", "SourceDir", "sourceDir", "SourceModule", " sourceDir", " sourceFiles", "srcFile", "ourceFile", "inputFile", "sourceFiles", "ourceFiles", " sourceModule", "inputDir", "SourceFile", " sourceDirectory", "sourcefile", "inputFiles", "ourceDirectory", "srcDir", "sourceModule", "sourceDirectory", " sourcefile", "Sourcefile", "ourceDir", "srcfile", "inputDirectory"], "infile": ["outdir", "inFile", "inputdata", "outstream", "outFile", "inputfile", "diffdir", "indata", " instream", " inFile", "Instream", "winstream", "inputFile", "Inf", "indir", "difffile", "Infile", "diffstream", "outf", "outdata", "winfile", "windir", " indata", "InFile", "instream", "diffFile", "inputf", "inputstream", "inf", "winFile"], "outfile": ["intfile", "outline", " outpage", "outpage", "againpage", " outfunction", "againFile", "intstream", "outstream", "outFile", "inputfile", " outFile", " outstream", "outlive", "inputFile", "exstream", "intlive", "inputfunction", "againstream", "exfile", "Outlive", "Outfunction", "exFile", "againfile", "Outline", "expage", "intFile", " outlive", "Outstream", "OutFile", "inputline", "outfunction", "Outfile", " outline"], "c": ["index", "string", "cu", "id", "n", "rc", "enc", "character", "cont", "z", "end", "o", "col", "l", "in", "char", "ec", "cm", "d", "lc", "uc", "ct", "r", "ch", "cy", "w", "channel", "ice", "xc", "cl", "h", "x", "p", "C", "u", "e", "m", "ci", "t", "cr", "pointer", "esc", "dec", "pc", "a", "abc", "k", "comment", "v", "b", "ac", "code"]}}
{"id1": "9996334", "id2": "18570190", "code1": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"generateToken": ["generateKey", "generationTokens", "generATESecret", "generationToken", " GenerATEKey", " GenerateToken", "generationKey", "generateTokens", " GenerateSecret", "generATEToken", "generatedSecret", "generATEKey", " GenerATETokens", " GenerateTokens", "generatedKey", "generATETokens", "generatedTokens", " GenerateKey", " GenerATEToken", "generatedToken", "generateSecret", "generationSecret", " GenerATESecret"], "code": ["string", "info", "address", "buffer", "input", "id", "output", "token", "message", "c", "hex", "tag", "Code", "key", "content", "next", "password", "source", "mac", "cache", "value", "str", "config", "data", "text", "body", "coded", "name", "header", "ode", "prefix", "cod", "state", "script", "codes", "hash"], "md": ["mu", "editor", "gd", "mag", "bd", "od", "df", "amd", "mo", "ind", "kg", "ma", "meta", "wd", "MD", " MD", "ms", "sm", "ad", "mb", "cm", "mt", "mac", "d", "mp", "hd", "sha", "pm", "cmd", "mm", "metadata", "cd", "dig", "po", "m", "dm", "grad", "mand", "mc", "mod", "ds", "rm", "mg", "f", "pd", "dd", "hash"], "bytes": ["zip", "string", "address", "bles", "output", "pieces", "tes", "les", "outs", "s", "bs", "bin", "parts", "binary", "lines", "blocks", "bps", "strings", "buf", "data", "classes", "body", "objects", "ips", "es", "groups", "Bytes", "vs", "seconds", "values", "files", "b", "units", "words", "bits", "codes", "boot"]}}
{"id1": "9347451", "id2": "18693224", "code1": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"writeData": [" writeDATA", "appendData", "appendText", "appenddata", "WriteText", "Writedata", " writeText", "writedata", "WriteData", "appendDATA", "writeDATA", "WriteDATA", " writedata", "writeText"], "name": ["index", "path", "string", "base", "NAME", "class", "info", "temp", "id", "n", "report", "filename", "table", "l", "ame", "line", "pass", "time", "active", "key", "part", "type", "date", "old", "model", "str", "parent", "names", "data", "out", "size", "title", "Name", "start", "image", "word", "prefix", "url", "f", "named", "code"], "items": ["keys", "locks", "pages", "pieces", "features", "steps", "cases", "ids", "projects", "lines", "flows", "blocks", "item", "Items", "names", "classes", "images", "objects", "models", "plugins", "ips", "chains", "groups", "planes", "months", "jobs", "ints", "tests", "types", "amples", "files", "xml", "units", "events", "sections", "days"], "mzmin": ["Mzstart", "mozMin", "mZmin", "dzmin", "mvMin", "mxmax", "mizmin", "Mxstart", "mczmin", "MZmin", "mwmax", "mzmins", "mozmins", "mczmax", "MZstart", "mizMin", "Mxmin", "MZmax", "mZmax", "mxmins", "mvstart", "dzstart", "mozmin", "dzMin", "MxMin", "mizmax", "Mxmins", "dizMin", "mozmax", "Mzmin", "mzstart", "dizstart", "mxMin", "mxstart", "mvmins", "mizstart", "mwstart", "dizmax", "dzmax", "mczMin", "mczstart", "mZstart", "mzMin", "Mzmins", "mozstart", "mwmin", "mvmin", "mxmin", "dizmin", "MzMin", "Mzmax"], "mzmax": ["mZmin", "mzhmin", "mjMax", "MzMax", " mizmin", "mxmax", "MZMAX", "mizmin", "MZlast", "mgzlast", "MZmin", "mzhMax", "mgzMax", "mizMax", " mizMax", "mZMAX", " mzend", "mgzmax", "MZMax", "MZmax", " mzlast", "mZmax", "mazMAX", " mzhmin", "mxMax", "mjmax", "mjlast", "mizmax", "mazmin", "Mzlast", "mazmax", "mxend", "Mzmin", "mZMax", "Mzax", "mZend", "mxMAX", " mzhmax", " mzhMax", "mxax", "mzMax", "mzlast", " mizmax", "mgzmin", "mZax", "mjmin", "mxlast", "mazax", "mZlast", "mzMAX", " mizlast", "MzMAX", "mzax", "mizlast", " mzMax", "mxmin", "mzend", "MZax", "mzhmax", " mzhend", "Mzmax", "mzhend"], "tstart": ["tnadd", "tadd", "pend", "pmin", " tmin", "pstop", "fstart", "ttstart", "fadd", " tend", "tnmin", "fend", "tstop", " tstop", "fstop", "ttmin", "ttend", "tmin", "ttstop", "tnstart", " tadd", "fmin", "pstart", "tend"], "tdelta": ["ddiff", "ndiff", "ddiffs", "dtiff", "tdata", "TDiff", "dtiffs", "ruedatum", "dtata", "TDiffs", "tdiff", "ddata", "ndiffs", "ulediff", "ruediffs", "uledelta", "ruedelta", "ruediff", "dtelta", "uledatum", "tdiffs", "ddelta", "ndata", "TDelta", "ulediffs", "TDatum", "tdatum", "ndelta"], "peaks": ["meaks", "meakers", "leak", "speakers", "leakes", "meakes", "keak", "speaked", "feaks", "feakes", "peakers", "feakers", "teaks", "peakes", "meak", "feak", "peak", "keaked", "teakes", "speakes", "teasons", "feasons", "teak", "speak", "leaks", "leaked", "keakes", "speaks", "speasons", "peasons", "keaks"], "file": ["base", "class", "loader", "temp", "output", "resource", "http", "fit", "run", "lib", "model", "pipe", "get", "force", "it", "files", "comment", "print", "module", "where", "info", "buffer", "server", "feed", "lock", "report", "site", "result", "global", "use", "cache", "load", "source", "w", "parent", "work", "page", "le", "object", "e", "full", "unit", "b", "handle", "tool", "letter", "path", "core", "ile", "message", "per", "socket", "line", "write", "el", "File", "queue", "bar", "reader", "book", "show", "group", "h", "io", "writer", "image", "function", "auto", "single", "view", "fe", "user", "place", "table", "fp", "l", "il", "pool", "save", "form", "FILE", "ger", "wave", "sample", "out", "check", "log", "let", "folder", "port", "db", "pe", "parse", "f", "this"], "i": ["index", "info", "mu", "id", "uri", "pi", "n", "step", "ini", "yi", "ie", "slice", "c", "z", "fi", "ri", "l", "si", "ui", "is", "ii", "qi", "part", "ti", "d", "adi", "phi", "chi", "li", "ip", "x", "p", "mi", "bi", "u", "init", "uli", "jj", "ai", "oi", "start", "e", "I", "ci", "io", "eni", "m", "it", "xi", "gi", "di", "hi", "sup", "h", "v", "y", "ni", "ik", "iu", "multi", "mini", "f", "im", "api", "ix"], "nothing": [" difference", " total", " worst", "total", "info", "something", "stuff", "Nothing", "ta", "things", "whatever", "tips", "broken", "miss", "wrong", " it", "anything", " stop", "done", " tries", "worst", "unknown", "life", "shit", "what", "xxx", "dt", "sorry", "no", "huge", "diff", " rest", "show", "none", " tid", "empty", "little", "different", "init", "hello", " trials", " no", "tests", "how", "it", "good", "thing", "T", "yeah", "tt", "hack", " trial", "false", "everything", "missing", "wait", " skip", "zero", "them", " tot", "terror", "notice"], "fileLoc": ["Fileloc", "baseLocation", "fileloc", "baseloc", "fLOC", " fileLocation", "fileLOC", "FileLOC", "fLocation", " fileLOC", "fLoc", "baseLOC", "floc", "fileLocation", " fileloc", "FileLoc", "FileLocation", "baseLoc"], "tempDate": ["tmpdate", "TempDat", "temDat", " tempLine", "tempdate", "tmpSign", "TempDate", "temDate", "tempDat", "Tempdate", " tempdate", " tempDat", "fakeDate", "fakeDat", "tempLine", "tmpDate", "tmpDay", "TempSign", " tempDay", "temdate", "tempSign", "tmpDat", "TempLine", "TempDay", "tempDay", " tempSign", "fakedate", "tmpLine"], "t": [" difference", " ng", "total", " title", "tz", "n", "duration", "ta", "utt", "c", " it", " tf", "l", "that", "dt", "at", "ti", " ti", "d", "the", " n", "target", "g", "flat", "out", " p", " tid", "p", "ts", "tim", "m", "e", "ot", " e", "it", " pt", "T", "tt", "b", "y", "tf", " ta", "f", " tail", " tot"], "k": ["mk", "ak", "sk", "n", "ko", "ok", "ke", "kl", "ck", "dk", "ks", "c", "kh", "z", "o", "l", "uk", "K", "kat", "key", "ku", "unk", "d", "tk", "q", "kk", "ijk", "kind", "kid", "work", "g", "w", "kick", "x", "p", "u", "jj", "e", "kw", "ky", "ka", "ki", "v", "y", "b", "kr", "ek", "f", "kn", "ik"], "j": ["dy", "job", "uj", "n", "ij", "jen", "jet", "ie", "dj", "jc", "ind", "z", "o", "jl", "l", "jo", "off", "el", "fr", "pass", "ii", "key", "aj", "ja", "ji", "d", "pr", "q", "r", "ch", "g", "bj", "li", "x", "p", "u", "jj", "J", "js", "e", "m", "kj", "it", "jp", "v", "y", "b", "obj", "br", "err", "oj", "adj", "f", "ik"], "peaked": ["paaking", "paky", "apeaker", "keaker", "feaking", "paaken", "keaken", "ceaker", "meaking", "ceaked", "keak", "keaky", "feaken", "ceaking", "peaker", "speaked", "peake", "ceaky", "ceaken", "meaken", "paked", "paake", "cleaking", "feaked", "ceak", "meaker", "peaken", "keake", "cleaked", "peak", "keaked", "feaker", "paken", "speak", "cleaken", "peaking", "paaked", "meaked", "speaken", "apeaking", "speaky", "cleake", "apeaken", "pak", "keaking", "peaky", "apeaked"], "test": ["val", "trial", "temp", "server", "feed", "user", "master", "report", "py", "inner", "table", "end", "result", "driver", "match", "all", "pass", "iter", "fail", "txt", "loop", "filter", "reader", "Test", "diff", "show", "build", "testing", "data", "out", "check", "search", "start", " tests", "tests", "train", "call", "pack", "runner", "tr", "cher", "ver", "v", "err", "print", "scan", "f", "here", "this", "valid"]}}
{"id1": "5977352", "id2": "13946197", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "label": 0, "substitutes": {"copyFile": ["copyDir", " copyfile", "transferDir", "CopyFile", "copyfile", "transferfile", "transferFiles", "CopyDir", " copyFiles", "Copyfile", " copyDir", "CopyFiles", "copyFiles", "transferFile"], "src": ["path", "sel", "loader", "input", "sc", "resource", "uri", "rc", "filename", "slice", "loc", "fp", "s", "ins", "inst", "gb", "rb", "source", "proc", "sb", "proxy", "buf", "dist", "config", "data", "file", "tmp", "conn", "sl", "files", "url", "this", "stream", "obj", "b", "ource", "view", "img"], "dest": ["zip", "path", "rest", "class", "temp", "output", "master", "table", "cont", "project", "later", "destroy", "done", "trans", " Dest", "dc", "die", "txt", "part", "cdn", "cp", "source", "d", "thin", "wb", "dir", "cache", "target", "dist", "store", "parent", "config", "file", "Dest", "de", "tmp", "route", "null", "delete", "desc", "folder", "name", "home", "opt", "url", "dep", "obj", " destination", "st", "this", "orig", "img"], "bufSize": ["ufLen", "queueLen", "queueSize", "bufsize", "queuesize", "ufsize", " bufLen", " bufsize", "buffer2", "uf2", "ufSize", "buffersize", "bufferLen", "bufferSize", "buf2", "bufLen", " buf2"], "force": ["push", "remote", "base", "id", "dirty", "replace", "forced", "rc", "forces", "place", "write", "ride", "only", "sync", "like", "Force", "load", "use", "source", "no", "store", "parent", "file", "route", "ist", "require", "forcing", "p", "delete", "apply", "pull", "flush", "urse", "count", "deep", "f", "hard", "auto", "front"], "buffer": ["border", "base", "Buffer", "address", "uffer", "feed", "slice", "limit", "result", "length", "write", "bin", "memory", "queue", "offset", "iter", "split", "raw", "source", "cache", "binary", "reader", "seed", "buff", "value", "buf", "load", "data", "fb", "append", "request", "null", "bytes", "url", "flush", "b", "reference", "padding", "transfer", "batch", "zero"], "read": ["play", "index", "close", "i", "input", "Read", "feed", "n", "id", "reading", "copy", "add", "ind", "current", "end", "find", "run", "se", "length", "write", "reads", "ride", "pass", "sleep", "ad", "iter", "raw", "next", "sync", "select", "allow", "use", "load", "d", "reader", "len", "show", "build", "seek", "work", "level", "data", "open", "text", "check", "ip", "get", "size", "fill", "start", "exec", "io", "lex", "send", "skip", "ed", "k", "parse", "create", "b", "connect", "wait", "count", "READ", " write", "block", "view"], "in": ["IN", "base", "pin", "i", "input", "id", "n", "ex", "sin", "serv", "ini", "gin", "con", "c", "socket", "inner", "as", "ins", "bin", "pass", "part", "reader", "source", "thin", "lib", "up", "login", "min", "connection", "inside", "r", "inc", "rin", "init", "conn", "again", "m", "image", "isin", "In", "nin", "kin", "a", "pull", "url", "err", "b", "ac", "cin", "inn", "f", "win", "din"], "out": ["ou", "max", "i", "ex", "output", "n", "outer", "id", "user", "by", "net", "plain", "OUT", "socket", "inner", "outs", "o", "off", "write", "bin", "line", "co", "key", "sync", "client", "part", "at", "one", "no", "source", "cache", "lib", "up", "connection", "w", "inc", "conn", "init", "again", "name", "exec", "Out", "writer", "io", "exp", "home", "image", "call", "nin", "app", "ext", "url", "can", "b", "obj", "err", "ac", "with", "this"]}}
{"id1": "16851955", "id2": "11377441", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"testTrainingBackprop": ["testTrainingBackdrop", "testTrainingBackpressure", "testTrainBackdrop", "testTrainingBACKpressure", "testTrainingFrontpointer", "testTrainBACKpointer", "testTrainingBACKdrop", "testTrainingBackpointer", "testTrainBACKprop", "testTrainBackprop", "testTrainingFrontpressure", "testTrainBACKpressure", "testTrainBackpressure", "testTrainingFrontprop", "testTrainBACKdrop", "testTrainingBACKpointer", "testTrainingBACKprop", "testTrainingFrontdrop", "testTrainBackpointer"], "temp": ["directory", "zip", "path", "base", "buffer", "input", "ex", "output", "copy", "clean", "lock", "http", "tem", "current", "dest", "Temp", "save", "pdf", "txt", "form", "wrap", "session", "cache", "parent", "model", "config", "data", "file", "tmp", "out", "flat", "fake", "local", "empty", "archive", "pipe", "test", "storage", "template", "folder", "cel", "stable", "writer", "io", "font", "full", "mount", "v", "container", "f", "dat", "porary", "this", "emp"], "layers": ["nlibraries", "licikes", "languages", "backs", "nlayers", "lasses", " lients", " lores", " llements", "gobs", "Lients", " languages", "nlikes", "flanguages", " libraries", "gients", "dlasks", "bayers", "lores", "blasses", " lasks", "players", "dlayers", "lients", "flasses", "liibraries", " lobs", " lacks", "likes", "llements", "planguages", "slays", "placks", "bays", "blayers", " lays", "lowers", "gayers", "Lobs", "libraries", "slowers", "licagers", "flayers", "slacks", "licibraries", "dlibraries", "bllements", "lacks", "slayers", "lobs", "fllements", "bowers", "lagers", " lagers", " likes", "liores", "dlacks", "dlores", "plasks", "liacks", "blanguages", "lasks", "nlagers", "dlanguages", "liayers", "licayers", " lowers", "lays", " lasses", "Layers"], "fann": ["larn", "fannon", "Fain", "xfann", "xfannon", "sfanny", "sfannon", "elfann", "garn", "Fann", "Fanny", "elfarn", "fanny", "gnn", "fnn", "sfain", "fana", "lnn", "Fannon", "sfann", "elfana", "lana", "gana", "lann", "xfain", "farn", "fain", "gann", "elfnn", "xfanny"], "trainer": ["rainer", "strainer", "tainer", "racker", "strayer", "Tracer", "trrain", "trayer", "traainer", "trarain", "tacer", "rain", "tacker", " tracker", " train", "stracer", "triner", "traacker", " tracer", "Trainer", "retainer", "racer", "strain", "Triner", "striner", "train", "Tracker", "Trrain", "Trayer", "stracker", "tracker", "tracer", "retayer", "traacer", "retacer", "retiner"], "desiredError": ["desiredSize", "desiredFailure", "descidederror", "desizedError", "descidedFailure", "deservedError", "desivedError", "desirederror", "desidedError", "descidedProblem", "desizedSize", "deservedEvent", "desireSize", "reservedError", "descidedError", "desireException", "desciredFailure", "desiredException", "desiredOrder", "desirableOrder", "designedError", "desiredEvent", "desivedException", "resiredError", "desirableEvent", "DesireSize", "desireError", "resiredSize", "deservedSize", "desiringerror", "DesireError", "designedSize", "reservedEvent", "desciredError", "DesiredError", "designedOrder", "despectedProblem", "desivedSize", "desiringError", "desirableSize", "designedEvent", "desidederror", "DesiredSize", "despectederror", "desciredProblem", "desidedFailure", "DesireException", "reservedOrder", "desiringFailure", "desirableError", "desiredProblem", "DesiredException", "descirederror", "despectedError", "desizedException", "despectedFailure", "resiredEvent", "resiredOrder", "desidedProblem", "desiringProblem", "reservedSize", "deservedOrder"], "mse": ["fge", "Mze", "gmge", "Mge", "fmce", " mge", " mSE", "fmse", "mte", "mce", "gmce", " mte", "fse", "Mte", "mze", "fce", "fSE", "MSE", "gmSE", " mce", "Mse", "mSE", "fmte", "fmze", "gmse", "Mce", "mge", " mze"]}}
{"id1": "14567939", "id2": "7499186", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 0, "substitutes": {"baseHash": ["baseFile", " generateHash", "Basehash", " generateSecret", "baseSecret", " chainFile", "basehash", "BaseHash", " generatehash", " generateFile", "BaseSecret", " chainSecret", "BaseFile", " chainHash", " chainhash"], "name": ["NAME", "path", "base", "class", "string", "address", "id", "n", "resource", "definition", "user", "account", "host", "ame", "key", "part", "type", "member", "alias", "parent", "names", "file", "data", "object", "style", "hello", "Name", "image", "normal", "word", "prefix", "secret", "create", "named", "hash"], "password": ["string", "path", "input", "token", "username", "profile", "account", "stroke", "priv", "wd", "pass", "key", "pattern", "security", "Password", "source", "PASS", "seed", "value", "diff", "sword", "data", "text", "device", "word", "wallet", "prefix", "secret", "auth", "paste", "padding", "words", "attribute", "crypt", "phrase", "hash", "code"], "digest": ["Digester", "signester", "DigEST", "Diger", "decEST", "modested", "signest", "signusher", "Digr", "signer", "modester", " digested", " diger", "modest", "decest", "signger", " digusher", "mdest", " digger", "digester", "digr", "digested", "mdester", "decr", "digger", "decester", "Digest", "moder", "Digusher", "mdEST", "digusher", "diger", "mdr", "Digger", " digester", "Digested", "digEST"]}}
{"id1": "13122204", "id2": "23008590", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "            public void run() {\n                URL url;\n                try {\n                    url = new URL(Config.UPDATE_SITE_URL);\n                    InputStream is = url.openStream();\n                    Writer writer = new StringWriter();\n                    char[] buffer = new char[1024];\n                    Reader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n                    int n;\n                    while ((n = reader.read(buffer)) != -1) {\n                        writer.write(buffer, 0, n);\n                    }\n                    String updatePage = writer.toString();\n                    is.close();\n                    writer.close();\n                    System.out.println(\"DOWNLOAD PAGE :\\n\" + updatePage);\n                    int pos1 = updatePage.indexOf(\"[ANA-CABV]\") + 10;\n                    int pos2 = updatePage.indexOf(\"[/ANA-CABV]\");\n                    int pos3 = updatePage.indexOf(\"[ANA-CABVURL]\") + 13;\n                    int pos4 = updatePage.indexOf(\"[/ANA-CABVURL]\");\n                    String currentVersion = updatePage.substring(pos1, pos2);\n                    currentVersionLabel.setText(currentVersionLabel.getText() + currentVersion);\n                    if (Double.valueOf(Config.VERSION) < Double.valueOf(currentVersion)) {\n                        downloadButton.setEnabled(true);\n                        label0.setText(mw.getLangMap().get(\"Update_Avalaible\"));\n                    } else label0.setText(mw.getLangMap().get(\"Update_NonAvalaible\"));\n                    downloadURL = updatePage.substring(pos3, pos4);\n                } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n", "label": 0, "substitutes": {"unzipModel": ["UnzipProject", "UnzipFile", "Unzipmodel", "unpatchFile", "unzipProject", "unpatchModel", "UnzipModel", "unpackProject", "unarchiveProject", "unarchiveModel", "unpatchmodel", "unpackFile", "unpackModel", "unpackmodel", "unarchiveFile", "unzipmodel", "UnarchiveProject", "unarchivemodel", "Unarchivemodel", "UnarchiveModel", "unzipFile", "unpatchProject", "UnarchiveFile"], "filename": ["directory", "string", "path", "bf", "uri", "jet", "username", "fits", "kl", "fp", "location", "fn", "il", "l", "database", "File", "txt", "utf", "source", "Filename", "model", "FILE", "SourceFile", "file", "src", "nil", "title", "folder", "name", "fil", "fd", "files", "url", "f", "module", "download", "loc"], "tempdir": [" tempfolder", "tmpDIR", "tempfolder", "tmpdirectory", "tempDIR", "tmpdir", "temdirectory", "Tempdirectory", "TempDir", " tempdirectory", "Tempdir", "temDir", "temfolder", " tempDir", "tempDir", " tempDIR", "TempDIR", "tmpDir", "Tempfolder", "temdir", "tempath", "temppath", "tmppath", " temppath", "tmpfolder", "tempdirectory"], "dest": ["zip", "rest", "handler", "temp", "output", "builder", "cont", "inner", "result", "later", "walker", "tar", "trans", "done", "ui", " Dest", "dc", "usr", "std", "exit", "txt", "die", "comb", "sync", "nt", "cdn", "session", "source", "proc", "wb", "dir", "target", "dist", "default", "store", "file", "src", "tmp", "Dest", "flat", "de", "export", "log", "gen", "delete", "test", "desc", "folder", "home", "opt", "walk", "sup", "di", "prop", "obj", "st", "transfer", "dat", "transform", "loc"], "fis": ["fileiss", "lis", "fileid", "filebis", "fi", " fiss", "filei", "fsbis", "fid", "fbis", "fileisa", "fliss", "flbis", "flis", "fisa", "li", " fi", " fid", "liss", "lid", "fsis", "fsisa", "fileis", "fsiss", "fiss", "flisa"], "BUFFER": ["UPVEN", "CUFFER", " BUFF", " BUVEN", " BUVER", "MAFFER", "BOFFER", "UPVER", "SAFFER", "SAPER", "CUVEN", "BUPER", " BUFIX", "BOPER", "BUFIX", "BOFER", "CUFF", "MAFIX", "TAUCK", "SAVER", "BUFER", "CUPER", "BOFIX", "BUVER", "MAFER", "BUUCK", "UPFF", "MAPER", "TAFFER", "TAPER", "TAVER", " BUPER", "CUUCK", "BUVEN", "BUFF", " BUUCK", "UPFFER", "SAUCK", " BUFER", "CUVER"], "zis": ["yis", "dii", "yin", "zisa", "jis", " zi", " zbis", "zos", "zas", " zii", "xis", "xiss", " zisa", "Zisa", "zIS", "xbis", "zins", "zipin", "zii", "ji", "dbis", "xists", " zIS", "ziss", "zipas", " zins", "jists", "zists", "Zas", "zipis", " zists", "zipisa", "dis", "xos", " zos", "zipins", "zi", "xii", "zbis", "Zins", "zin", "yIS", "xi", "diss", "yisa", "Zis", "jos", " zas", " ziss", "zipIS", " zin"], "entry": ["zip", "ry", "info", "ou", "her", "ace", "id", "feed", "spec", "server", "rc", "ie", "ge", "inner", "end", "result", "se", "match", "jo", "record", "ries", "si", "ident", "line", "Entry", "next", "la", "ent", "nt", "part", "reader", "ce", "lc", "source", "module", "connection", "je", "cat", "inc", "file", "de", "archive", "li", "iterator", "way", "row", "or", "cel", "name", "e", "image", "pack", "pe", "porter", "element", "enter", "valid"], "count": ["val", "index", "base", "buffer", "sum", "max", "core", "list", "id", "feed", "i", "add", "ind", "c", "current", "end", "limit", "number", "length", "line", "write", "read", "time", "in", "key", "weight", "iter", "next", "last", "part", "allow", "type", "use", "cache", "cond", "len", "counter", "file", "Count", "size", "log", "start", "name", "e", "coll", "writer", "pos", "low", "_", "b", "f", "code"], "data": ["index", "info", "base", "buffer", "input", "id", "feed", "message", "number", "result", "length", "record", "write", "shift", "read", "alpha", "content", "next", "raw", "la", "reader", "load", "d", "value", "media", "len", "str", "DATA", "batch", "body", "size", "format", "name", "start", "image", "pos", "array", "pack", "bytes", "a", "block", "zero", "dat"], "fos": ["fops", "bis", " foos", "afos", " fops", "foos", "dfoos", "afis", "xoes", "bos", " fOS", "afops", "dfops", "dfoes", " foes", "bOS", "xos", "bops", "dfos", "xops", "fOS", "xoos", "foes", "afOS"]}}
{"id1": "20306677", "id2": "6866575", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 0, "substitutes": {"update": ["index", "resource", "run", "patch", "database", "offset", "build", "get", "row", "bug", "width", "where", "address", "id", "feed", "plus", "lock", "add", "end", "result", "find", "query", "next", "sync", "use", "load", "up", "connection", "value", "object", "delete", "fill", "edit", "apply", "full", "unit", "ul", "ite", "event", "core", "more", "replace", "response", "json", "write", "grade", "two", "diff", "other", "insert", "change", "create", "future", "property", "view", "UPDATE", "version", "current", "draw", "save", "updated", "date", "inc", "data", "check", "Update", "size", "put", "append", "status", "latest", "range"], "o": ["article", "ou", "i", "vo", " bo", "n", "od", "oa", "mo", "ilo", " O", "s", "bo", "ingo", "oo", "one", " object", "oro", "out", "object", "oid", "p", "or", "po", "e", "t", "ao", "bot", "O", "b", "obj", "OO", "os", "ol", "ow", "Obj", "office", "oe", "f"], "bill": ["order", "base", "ban", "roll", "fee", "foo", "ee", "note", "user", "report", " contract", "project", "number", "account", "pool", "mill", "flow", "nn", "company", "fl", "bar", "bird", "book", "charge", "batch", "object", "bel", "log", "conn", "BILL", "db", "bug", "unit", "contract", "b", "bl", "Bill", "business", "f", "bean", "service"], "pst": ["psth", "Psp", "lpct", "ppsc", " psth", "Psts", " psts", "prect", "Psc", " pct", "presc", "Pct", "psc", "prest", "nsp", "pct", "ppct", "Pst", "jpst", "jpsth", "ppst", "psts", "lpsts", "presp", "Psth", "nst", "psp", "lpst", "nsts", "jpsts", "ppsp", "jpct", "lpsp", "nct"]}}
{"id1": "14820302", "id2": "22611968", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"innerProcess": ["subConnect", " innerConnect", "subprocess", "subProcess", "binaryConnect", "innerConnect", "binaryprocess", "binaryProcess", "binaryWrite", "subWrite", "innerprocess", "innerWrite", " innerWrite", " innerprocess"], "curi": ["lURI", "pri", "luri", " cunit", " cURI", " cgui", "lri", "cURI", " cui", "capi", "lurl", "lciri", "lcui", "lcuri", "Capi", "Cri", "lcURI", " capi", "Curi", "papi", "lcri", "cui", "fri", "lcunit", "cunit", "Curl", "pURI", "fui", "Cui", "curl", " cri", "Ciri", "ciri", "furi", "lcgui", "fURI", "Cunit", " curl", "cri", "cgui", "puri", "Cgui", "CURI", "firi"], "regexpr": ["relexp", "recrepre", "renexPR", "pregexpr", "rereper", "regexp", "recer", "reruer", "RenexPR", "renexpl", "regnexpl", "regexer", "rerup", "renexpr", "receper", "Renexpr", "pregexer", "pregexpl", "recrepr", "prenexp", "renexr", "Renexp", "relexPR", "RegexPR", "regnexpr", "Regexpre", "recrep", "recreer", "reggexpr", "regexr", "pregexp", "reggexpl", "rerer", "regexpre", "regexPR", "prenexpr", "rerepr", "regnexper", "recepl", "rerepl", "rerupl", "Regexpr", "rerupr", "prenexer", "reggexr", "Renexpre", "regexper", "relexpr", "regexpl", "regnexr", "recepr", "recrepl", "renexpre", "renexper", "renexer", "prenexpl", "renexp", "reggexper", "relexpre", "Regexp", "recrePR"], "cs": ["cing", "tc", "cc", "sc", "cer", "css", "fs", "acs", "cf", "rc", "cons", "spec", "ns", "ks", "c", "cb", "qs", "Cs", "bs", "ins", "cases", "ms", "rs", "cus", "ec", "ces", "sync", "cms", "cm", "cp", "ce", "lc", "cache", "cas", "ced", "icks", "ca", "gs", "es", "CS", "wcs", "conn", "acts", "js", "ls", "ci", "coll", "ics", "vs", "cr", "cers", "cells", "ars", "ss", "pc", "details", "ios", "ctx", "bc", "ches", "cn", "ac", "ds", "acks", "os", "ps", "cks", "codes", "cos"], "digest": ["Digester", "signester", "bigests", " diggest", "Diger", "signEST", "igested", "digity", "logit", "signest", " digcher", "signer", "bigest", " digested", " diger", "Digity", "hashger", "biggest", "signger", "digit", "hashest", "digcher", "signests", "logester", "bigEST", "igity", "signested", "diggest", " digger", "digester", " digity", "Digit", "digested", "hashester", "digests", "digger", "Digcher", "Digest", "hashcher", "igest", "diger", "logger", " digEST", "Digger", " digester", " digests", " digit", "Digested", "logest", "signgest", "igester", "digEST"], "s": ["services", "string", "address", "sum", "n", "settings", "ns", "c", "S", "o", "l", "bs", "abs", "si", "su", "is", "ms", "rs", "sync", "states", "ws", "binary", "sb", "strings", "str", "r", "g", "ans", "data", "gs", "h", "p", "groups", "u", "ls", "js", "e", "sets", "t", "obs", "ss", "sl", "sym", "bytes", "ses", "b", "v", "ds", "os", "f", "ps"], "m": ["om", "string", "tm", "vm", "map", "M", "c", "mo", "am", "match", "wm", "mr", "ms", "sm", "ym", "cm", "pm", "r", "machine", "mm", "mi", "p", "hm", "fm", "e", "dm", "imm", "nm", "mc", "me", "v", "bm", "rm", "man", "gm"], "newDigestValue": ["newDigeterValue", "newDigesterValues", "newDigESTValues", "newSignestedValue", "newDigesterVal", "newDigeterString", "newDigesterKey", "newSignestValue", "newDigeterVal", "newDigestVal", "newSignestedValues", "newDigestedString", "newSignestedKey", "newDigesterString", "newDigESTValue", "newDigesterValue", "newDigESTKey", "newSignestValues", "newDigestedVal", "newSignestString", "newDigestValues", "newSignestedString", "newSignestKey", "newDigESTString", "newDigestedKey", "newDigestKey", "newDigestString", "newDigeterKey", "newDigestedValues", "newDigestedValue"]}}
{"id1": "13886238", "id2": "16719805", "code1": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"init": ["rest", "info", "setup", "reset", " reload", "activate", "construct", "load", "art", "build", "open", "strap", "config", "check", "launch", " Init", "destruct", "initialized", "test", "start", "it", "update", "parse", " discover", "Init", "error"], "backupFile": ["backupsFile", "backrapFiles", "backupFILE", "backrapDir", "backrapFile", "BackupStream", "BackdownStream", "lookupfile", "backacyFILE", "backupDir", "backupStream", "lookupFILE", "backbookF", "backoutFolder", "backupsDir", "lookoutFILE", "lookupFile", "backupfile", "BackupSourceFile", "backUPStream", "lookoutFile", "BackupDir", "BackureFile", "backupFiles", "backoutFILE", "backupsSourceFile", "BackureFiles", "backbackFolder", "backUPF", "backbookStream", "backureFile", "backureDir", "BackdownF", "backbookFile", "backupsFiles", "backUPFiles", "backupSourceFile", "backdownFile", "BackdownFile", "backbackfile", "backureSourceFile", "backupF", "lookoutFolder", "backdownFiles", "BackupFiles", "backrapSourceFile", "backoutFile", "backacyFolder", "lookupFolder", "BackdownFiles", "backUPFile", "backacyfile", "BackupFile", "backbackFILE", "BackureSourceFile", "BackupF", "backbackFile", "backureFiles", "lookoutfile", "backdownF", "backdownStream", "backupFolder", "backoutfile", "backbookFiles", "backacyFile", "BackureDir"], "buff": ["zip", "uff", "buffer", "fe", "bf", "feed", "oct", "now", "slice", "cb", "grab", "length", "gg", "ff", "ffff", "pb", "char", "uf", "bg", "txt", "gb", "comp", "mb", "utf", "cp", "rb", "comb", "load", "pp", "sb", "back", "buf", "cond", "ch", "ob", "build", "bind", "fb", "cast", "bb", "gz", "font", "Buff", "flush", "app", "shape", "comment", "b", "bound", "ph", "fab", "cod", "pad", "cmd", "boot"], "in": ["IN", "pin", "ssl", "i", "input", "id", "n", "serv", "ini", "gin", "con", "c", "inner", "socket", "slice", "l", "ins", "s", "el", "bin", "pass", "part", "reader", "up", "login", "min", "diff", "connection", "r", "inside", "old", "inc", "data", "get", "or", "again", "e", "exec", "image", "isin", "In", "nin", "url", "stream", "lin", "b", "ac", "cin", "inn", "f", "win", "din"], "out": ["IN", "ex", "output", "copy", "n", "serv", "user", "net", "OUT", "inner", "socket", "o", "outs", "ins", "line", "co", "bin", "pass", "client", "sync", "part", "one", "reader", "doc", "lib", "up", "inc", "file", "gen", "conn", "again", "exec", "Out", "io", "writer", "exp", "ax", "prefix", "ext", "conf", "err", "b", "win"], "read": ["index", "roll", "max", "Read", "run", "ride", "en", "raw", "build", "open", "get", "row", "lex", "readable", "buffer", "id", "feed", "lock", "add", "ind", "end", "find", "next", "sync", "use", "load", "r", "work", "level", "ip", "search", "fill", "exec", "skip", "reach", "b", "connect", "play", "close", "i", "n", "reading", "ok", "se", "length", "write", "ad", "sleep", "iter", "reader", "d", " Read", "bind", "start", "wait", "ink", "view", "input", "copy", "current", "child", "reads", "pass", "last", "select", "ask", "seek", "data", "text", "check", "x", "size", "log", "send", "k", "parse", "count", "READ", "block"], "reportWriter": [" reportReader", "reportHelper", "summaryJournal", "reportReader", "reportedTime", " reportDriver", "commentWrite", "exportJournal", "reportedWriter", "reviewWrite", "ReportWs", "reportWs", "reportWalker", "commentStream", "exportWrite", "resultStream", " reportHelper", "reportedDriver", "summaryWriter", "exportWriter", "ReportWriting", "exportHelper", "ReportReader", "reviewTime", "exportApplication", "reportApplication", " reportWriting", "summaryStream", "reportedReader", "reportedWriting", "exportPublisher", "reviewWriter", " reportWalker", "exportWalker", "commentWriter", " reportPublisher", "reportWrite", " reportTime", "reviewEditor", "reportedWs", "ReportWrite", "reportedEngine", "reportWriting", "resultWriter", "ReportWriter", "reportedHelper", "ReportApplication", " reportWrite", "reportJournal", " reportJournal", "reportTime", "reportedWalker", " reportEngine", "reportEditor", "reportStream", "reportPublisher", "reviewEngine", " reportApplication", "summaryWrite", "reportEngine", "reportedEditor", " reportWs", "resultPage", "summaryPublisher", "resultWrite", "summaryPage", "reviewDriver", " reportEditor", "reportPage", "exportReader", "reportDriver", "reportedWrite", "commentPage"], "restarting": ["restrupted", "restarmING", "restarmed", "restartting", "Restriting", "Restrited", "restarted", "restritating", "restartsing", "Restarting", "restarsing", "restartable", "restartING", "Restritating", "restritING", "Restartting", "Restarted", "RestartING", "restrited", "Restritable", "restriting", "restarsING", "restartsting", "restarmable", "Restartating", "restartating", "restritting", "Restartable", "restruptING", "restartsating", "restruptable", "restarming", "restarsting", "RestritING", "restritable", "restartsING", "restarsating", "Restritting", "restrupting"]}}
{"id1": "19335986", "id2": "16549995", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"uncaughtException": ["CaughtException", "uncachedexc", "uncatchedexc", "uncaughtEvent", "CatchedEvent", "Catchedexc", "Caughtexc", "uncaughtexc", "uncachedEvent", "uncachedException", "uncatchedException", "unchandledException", "unchandledexc", "CatchedException", "uncatchedEvent", "CaughtEvent", "unchandledEvent"], "t": ["n", "c", "l", "s", "te", " T", "ty", "type", "d", "r", "g", "w", "out", "p", "ts", "let", "title", "m", "tree", "ing", "it", " td", "T", "tr", "ed", "f", "tx"], "e": ["event", "fe", "i", "ace", "ee", "be", "ie", "eb", "c", "ge", "j", "se", "o", "s", "el", "ception", "ele", "en", "ec", "er", "d", "ce", "diff", "r", "data", "de", "exc", "ep", "p", "es", "ae", "environment", "ne", "eu", "example", "m", "E", "ev", "ed", "pe", "me", "err", "f", "error", "oe", "Exception", "element", "code", "enter", "esi"], "display": ["play", "fe", "console", "panel", "report", "profile", "description", "window", "host", "layout", "content", "monitor", "scroll", "d", "hide", "show", "default", "config", "de", "body", "page", "object", "p", "style", "dis", "status", "image", "screen", "Display", "position", "app", "me", "summary", "design", "container", "process", "this", "view", "platform"], "shell": ["hell", "buffer", "console", "server", "copy", "lock", "mail", "system", "echo", "l", "child", "host", "el", "clone", "loop", "tools", "sb", "live", " Shell", "machine", "math", "body", "cl", "launch", "h", "environment", "log", "bash", "m", "exec", "image", "status", "Shell", "ml", "kernel", "sym", "app", "sh", "sound", "b", "poll", "container", "process", "xml", "help", "gui", "cli", "tool"], "message": ["event", " exception", "address", "buffer", "translation", "mess", "console", "server", "output", "copy", "response", "report", "mail", "document", "description", "result", "management", "queue", "content", "monitor", "email", "member", "value", "media", "model", "application", "data", "body", "page", "object", "request", "flash", "Message", "log", "msg", "header", "m", "meter", "status", "image", " messenger", "update", "summary", "xml", "essage", "error", "view"], "e1": [" e3", "e3", "exc2", "e8", " e2", "E1", "e2", "E3", "E2", " e8", "E8", "exc3", "exc8", "exc1"]}}
{"id1": "16550855", "id2": "7468819", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "label": 1, "substitutes": {"readPage": ["readPages", "openpage", "readFile", "openPages", "getFile", "findPage", "getPages", "getPage", "readpage", "findPages", "openFile", "getpage", "findFile", "openPage", "findpage"], "ignoreComments": ["useComments", "includeTags", "includeComments", " ignoreTags", "oreComment", "ignorecomments", "orecomments", "ignoreComment", "oreQuotes", "useTags", " ignoreComment", "useQuotes", "ignoreQuotes", "usecomments", "includeComment", "oreComments", " ignorecomments", "oreTags", "includecomments", " ignoreQuotes", "ignoreTags"], "in": ["IN", "index", "ssl", "buffer", "i", "input", "id", "token", "loader", "user", "ini", "gin", "on", "http", "into", "con", "c", "inner", "socket", "version", "as", "ins", "s", "bin", "is", "client", "reader", "source", "login", "connection", "min", "inside", "r", "inc", "data", "file", "out", "h", "init", "rec", "again", "e", "m", "image", "t", "re", "isin", "it", "In", "nin", "kin", "url", "stream", "lin", "b", "err", "inn", "f", "win", "din"], "inputLine": ["InputText", "incLook", "incL", "InputLook", "requestRow", "inputName", "requestline", "pullLine", "installline", "inputRow", " inputRow", "requestLink", " inputCell", "incLine", "ifLook", "ifline", "InputName", "pullline", "installLook", "imageLine", " inputText", " inputLook", "imageL", "InputLine", "rawLine", "Inputline", "pullLink", "requestLine", "InputLink", "incline", "rawL", "ifLine", " inputName", "ifCo", " inputCo", "inputL", " inputPage", "imageline", "commentline", " inputline", "rawName", "requestLook", "installL", "pullRow", "InputL", "inputCo", "commentLine", "inputCell", "inputText", "inputline", "rawLink", "InputCell", "requestCo", "inputPage", "rawText", "inputLook", " inputL", "commentCell", " inputLink", "installLine", "imageLook", "inputLink", "rawline", "InputPage", "commentPage"], "html": ["article", "base", "temp", "css", "HTML", "output", "bf", "atom", "embed", "gh", "http", "message", "json", "plain", "ht", "result", "hot", "ui", "detail", "strong", "high", "htm", "content", "part", "wrap", "links", "doc", "tml", "source", "live", "show", "str", "data", "attr", "body", "flat", "amp", "war", "web", "h", "page", "flash", "inline", "format", "msg", "title", "template", "rss", "header", "js", "text", "home", "blog", "link", "details", "dump", "url", "tt", "www", "summary", "xml", "tf", "bsp", "f", "hard", "api", "view", "img"]}}
{"id1": "2668853", "id2": "8778962", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFiletoFiles", "decodeFileAsStream", "decodeString2file", "decodeFile2Stream", "decodeFiletoFile", "decodeFileToStream", "decodeFiletofile", "decodeFileAsFiles", "decodeFileTofile", "decodeStringToFile", "decodeStringTofile", "decodeStringToStream", "decodeFileAsFile", "decodeString2Stream", "decodeFile2File", "decodeString2File", "decodeFileAsfile", "decodeFiletoStream", "decodeFileToFiles", "decodeFile2file", "decodeStringToFiles", "decodeString2Files", "decodeFile2Files"], "infile": ["minfile", "infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", "inputfp", " inFile", "inputFile", "outfiles", " infilename", "inputfiles", " infiles", "outfp", "minfilename", "minFile", "minfp", "inputfilename", "infilename"], "outfile": ["infp", "outfull", "outputfile", " outfull", "outfilename", "outFile", " outFile", "infolder", "outputfolder", " outfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "outputfull", "Outfull", "Outfolder", "OutFile", "Outfile", "outputFile", "infilename", " outfilename"], "in": ["IN", "pin", "i", "input", "inas", "ex", "ini", "gin", "ic", "con", "inner", "socket", "as", "ins", "s", "bin", "is", "reader", "source", "up", "login", "min", "inside", "r", "inc", "data", "rin", "init", "conn", "again", "m", "e", "image", "re", "In", "nin", "a", "lin", "err", "b", "ac", "cin", "inn", "f", "win", "this", "din"], "out": ["base", "ex", "output", "copy", "outer", "op", "lock", "on", "net", "OUT", "socket", "as", "inner", "outs", "o", "s", "off", "line", "write", "bin", "co", "pass", "exit", "post", "client", "sync", "session", "no", "cache", "lib", "up", "target", "other", "inc", "work", "file", "conn", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "exp", "In", "ext", "b", "obj", "err", "error", "point"], "buffer": ["address", "base", "input", "Buffer", "uffer", "resource", "pause", "border", "server", "feed", "slice", "limit", "result", "length", "bin", "memory", "queue", "offset", "iter", "split", "reader", "source", "binary", "seed", "buff", "value", "buf", "wave", "data", "size", "bb", "null", "row", "bytes", "layer", "flush", "url", "shape", "b", "reference", "padding", "pad", "transfer", "batch"], "read": ["index", "Read", " receive", " r", "run", "ride", " get", "open", " copy", "get", "lex", " send", " check", "id", "feed", "add", "ind", "end", "find", " reach", "next", "sync", "use", "load", " sleep", "r", "work", "fill", "exec", "skip", "connect", " request", "play", " use", "reading", " parse", "limit", "se", "length", "write", "line", "ad", "sleep", "iter", "allow", "reader", " Read", "start", "tell", " load", "wait", " write", "input", "copy", " connect", "current", "reads", "pass", "select", " ride", "seek", "inc", " find", "check", "x", "size", " reader", "send", "k", "parse", "count", "READ"], "success": ["roll", "accept", "job", "response", "rolling", "ok", "continue", "ceed", "results", "warning", "better", "yes", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "selected", "default", "data", "safe", "null", "cess", "danger", "complete", "again", "status", " successful", "full", "correct", "good", "Success", "successful", "successfully", "rolled", "found", " succ", "zero", "error", "fast", "first", "winner", "initial"]}}
{"id1": "2668634", "id2": "23677147", "code1": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 0, "substitutes": {"inputName": ["imagename", "imageAddress", " inputFile", " inputUrl", "InputName", "Inputname", "InputUrl", "imageFile", "inputUrl", "inputFile", " inputname", "outputPath", "inputPath", "InputFile", "InputAddress", " inputAddress", "outputUrl", "inputname", "outputFile", "imageName", "InputPath", "inputAddress", " inputPath"], "outputName": ["applicationName", "OutputFile", "inputFile", "applicationPath", "outputPath", "OutputName", "applicationname", "inputPath", "applicationFile", "inputDir", "OutputDir", " outputFile", " outputDir", "outputDir", "outputname", "Outputname", " outputname", "outputFile", "OutputPath", "applicationDir"], "stripLoggers": ["stripColgers", "stripDebugger", "striplogters", "stripColging", " striplogters", " striploggers", " stripLogging", " striplogging", "striplogger", "stripDebuggers", " stripLogger", "stripLogters", "striploggers", "stripColters", " stripLogters", "stripDebugters", "stripDebugging", "stripLogger", " striplogger", "stripLogging", "stripColger", "striplogging"], "tempFile": [" temporaryfile", "poraryFile", " temporaryFiles", " temporaryFile", " tempfile", "inputfile", "tmpFile", " tempFiles", " temporaryStream", "tempMessage", "inputFile", "poraryFiles", "TempDir", "TempMessage", "tmpfile", "poraryfile", "Tempfile", "TempFile", "tempStream", "TempFiles", "inputDir", " tempDir", "tempDir", " tempStream", "TempStream", "tmpFiles", "tmpDir", "tmpPage", "tempPage", "tempfile", " tempPage", "tempFiles", "inputPage", " tempMessage", "poraryMessage"], "jin": ["pillar", "zip", "pin", "sin", "rio", "lu", "jen", "Kit", "skin", "ini", "gin", "NJ", "john", "NI", "jack", "Ru", "jl", "jun", "arin", "hn", "bin", "Mu", "su", "util", "in", "Js", "ja", "zon", "thin", "sit", "jan", "lib", "hin", "jing", "vin", "rin", "icer", "irin", "plugin", "nir", "fil", "inx", "zin", "jp", "kin", "nin", "ln", "spin", "unin", "Intern", "fen", "zn", "zik", "lin", " Jin", "ni", "raf", "cin", "Skin", "nu", "cli", "tin", "din", "Mos", "cos"], "jout": ["jetout", "ujout", "jarray", "nOUT", " jOUT", "Jout", "nout", "jetarray", "jetOUT", "jOUT", "jOut", " jouter", "ujouter", "nOut", " jarray", "narray", "JOut", "jouter", " jOut", "jetOut", "ujOut", "Jouter"], "srcChannel": [" srcChan", "rcchannel", "rcChannel", "srcchannel", "sourceCh", " srcchannel", "srcChan", "sourcechannel", " srcCh", "rcChan", "sourceChannel", "srcCh", "sourceChan", "rcCh"], "dstChannel": ["dspCh", " ddestchannel", " dstCh", " dstchannel", "ddestChan", " ddestChannel", "dndChannel", "dspchannel", "dndchannel", "dndCh", "dspChan", " ddestCh", " dstChan", "ddestCh", " ddestChan", "ddestChannel", "dspChannel", "ddestchannel", "dstChan", "dstchannel", "dndChan", "dstCh"], "portletApplicationName": ["portletApplicationsCode", "portletsAppPath", "portletPlatformInfo", "portalPlatformPath", "portletApplicationUrl", "portletapplicationPath", "portletApplicationsName", "portalApplicationName", "portletPlatformName", "portletPlatformUrl", "portletPlatformCode", "portletApplicationInfo", "portletsApplicationInfo", "portletsAppInfo", "portletapplicationName", "portletAppName", "portletAppPath", "portletPlatformType", "portalPlatformName", "portalPlatformType", "portletsApplicationCode", "portalApplicationPath", "portalApplicationType", "portletapplicationType", "portletsAppName", "portalPlatformUrl", "portalApplicationUrl", "portletApplicationsPath", "portletAppCode", "portletAppType", "portletAppUrl", "portletsAppCode", "portletsApplicationName", "portletsApplicationPath", "portletAppInfo", "portletPlatformPath", "portletApplicationCode", "portletApplicationPath", "portletApplicationType", "portletApplicationsInfo", "portletapplicationUrl"], "webXml": [" webXxml", "webCrossul", "webXli", "WebXML", "webXMML", "WebXml", "webXlass", "webWorkaml", "webXMxml", "webxxml", "contextCrossul", "contextXlass", "webWorkml", "webXMml", "webWorkli", "webXaml", " webXMml", "webHML", "webEcml", " webXaml", "contextCxml", "webHiel", "webWorkxml", "webXML", " webXMML", "webxml", "webEcpl", "webxaml", "webCML", "webEcML", "webWorkML", "webxlass", "WebXiel", "contextXxml", "webXpl", "webXxml", "contextXML", "webCrossml", " webXMaml", "contextCrossml", "contextCml", "WebXMml", "WebXpl", "contextXul", "webClass", "contextClass", "WebXMpl", "webXMaml", " webXML", "webHpl", "webXMiel", "contextCML", "webCxml", "webCrossli", "WebXMiel", "contextCrossli", "webXMpl", "webEciel", "WebXMML", "contextXli", "webXul", "webXiel", "webCrossML", "webHml", "webCml", " webXMxml", "contextCrossML", "webxML", "webWorkul"], "portletXml": ["portfileXmos", "portleXaml", "portletxml", "portletXmos", "portletXMaml", "portletHmos", "portletXng", "portletxmos", "portletXxml", "portletSynctml", "portfileXml", "portletCxml", "portletxxml", "portleXml", "portletXmal", "portletXML", "portletSyaml", "portfileHML", "portletEng", "portletSyml", "portletSyncaml", "portletsXmal", "portletCmos", "portletsXML", "portletCml", "portletXMML", "portletSyncxml", "portletXtml", "portletEML", "portfileHxml", "portletXaml", "portletsYml", "portletYmal", "portfileHml", "portletHxml", "portletEmal", "portleXtml", "portletsYmal", "portletCML", "portletYng", "portletsYML", "portletsXml", "portleSytml", "portfileXxml", "portletHml", "portletSyncml", "portfileHmos", "portletXMmal", "portleSyaml", "portletHML", "portfileXML", "portletEml", "portletsYng", "portletsXng", "portletSyxml", "portletXMng", "portletXMxml", "portletYML", "portletxML", "portletYml", "portleSyml", "portletXMtml", "portletSytml", "portleSyxml", "portletXMml", "portleXxml"], "contextXml": ["contextXML", "contextAxml", "conceptHxml", " contextAxla", "conceptHaml", " contextAxML", "contextxxml", "contextExML", "contextXMml", "contextUla", "conceptXml", " contextXML", "contextUML", "contextxwl", "contextXaml", "contextxaml", "conceptXwl", " contextAxml", "conceptXxml", " contextAxl", "contextAxla", "contextExml", " contextXl", "contextXMwl", "conceptXaml", "contextExl", "contextHml", "conceptHml", "contextUml", "contextExla", " contextXla", "contextHwl", "contextHaml", "contextxml", "conceptHwl", "contextXwl", "contextXl", "contextXMaml", "contextXla", "contextXxml", "contextAxl", "contextXMxml", "contextHxml", "contextUl", "contextAxML"], "src": ["zip", "rest", "ssl", "sel", "sin", "i", "sc", "resource", "spec", "uri", "username", "rc", "Source", "entry", "http", "lower", "bh", "ie", "slice", "socket", "rel", "cont", "sub", "dest", "result", "ri", "s", "prot", "host", "inst", "in", "rs", "SOURCE", "req", "comp", "gb", "sync", "sit", "rb", "jar", "sb", "uc", "sr", "dist", "r", "config", "ruby", "rin", "img", "sq", "href", "rec", "lit", "gz", "rss", "sup", "sl", "rl", "secure", "ctx", "url", "ses", "ser", "ur", "obj", "st", "sn", "cur", "ource", "loc"], "source": ["zip", "string", "reason", "sin", "handler", "core", "i", "input", "loader", "resource", "uri", "spec", "token", "Source", "rc", "resources", "ie", "slice", "inner", "result", "fp", "driver", "ources", "in", "SOURCE", "iter", "form", "client", "comp", "sit", "reader", "use", "thin", "proxy", "session", "sr", "connection", "component", "scope", "parent", "text", "out", "file", "channel", "get", "size", "null", "gen", "context", "start", "e", "status", "function", "ce", "kin", "sl", "secure", "url", "this", "stream", "unit", "sp", "wrapper", "stack", "xml", "ource", "service", "from", "view", "storage"], "zipEntries": ["sliceEresses", "zipCurries", "zipIntegry", "zipIntegrations", "sliceEries", "sliceEntry", "zipEndlines", "zipEnry", "zipEntrations", "ZipEntries", "zipEnresses", " zipEntrys", "zipEresses", "zipEnrations", "sliceEntlines", "zipentions", "zipCurlements", "sliceEntries", "ZipEntrys", " zipEntry", "zipentrys", "zipEnlines", "zipEndry", "zipIntegrys", "zipEntlements", "zipElines", "zipEntresses", "zipEntrys", "zipEnries", "zipEntlines", "sliceElines", "ZipEntlements", "sliceEry", "zipCurions", " zipEntrations", "zipEntions", "zipEntry", "zipentries", "zipEry", "zipEndries", "zipEndresses", "ZipEntions", "zipEnrys", "zipentlements", "zipCurrys", "sliceEntresses", "zipIntegries", "zipEries"], "target": ["path", "string", "address", "class", "goal", "remote", "tail", "output", "resource", "bh", "site", "filename", "project", "wrong", "current", "rel", "dest", "Target", "location", "host", "match", "tag", "feat", "platform", "content", "next", "nt", "type", "value", "component", "scope", "arget", "config", "data", "file", "route", "flat", "object", "context", "href", "style", "format", "hop", "name", "template", "it", "prefix", "theme", "compatible", "unit", "top", "method", "external", "loc"], "webRewriter": [" webrewitcher", "webReworter", "webrewrite", " webrewriter", " webRewrite", "http", "webRepitcher", "webreworter", "s", "webRewrite", "Entry", "webRepriter", " webreworter", "webRewitcher", "webResitcher", " webReworter", "webrewitcher", "webResrite", "application", "webReprite", " webRewitcher", "webReporter", " webrewrite", "webrewriter", "app", "_", "New", "webResorter", "this", "webResriter"]}}
{"id1": "6890417", "id2": "646016", "code1": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "code2": "    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorCliente.elimina()\");\n        int id = cli.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            sql = \"DELETE FROM persona WHERE id =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt.executeUpdate(sql);\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        }\n    }\n", "label": 0, "substitutes": {"a1": ["a01", "alpha0", "A01", "A1", "an2", "ga0", "A2", "alpha1", "ga01", " a0", "an3", "ga1", "alpha01", "an01", "a0", "ga2", "A3", " a01", "alpha2", "an1"], "a2": ["A4", "n5", "A8", "A1", "n2", "A5", "A2", "n4", "p5", "n8", "p1", "p4", "p2"], "a3": ["a23", "la33", " a23", "an23", "ga3", "an3", "alpha3", "ga9", "ga5", "a33", "alpha9", "alpha5", "ga2", " a33", "la23", "an33", "alpha2", "la3"], "a4": ["A4", "ma10", "A5", "A2", "pa4", "as2", "ma8", "ga8", "pa8", "ga4", "pa10", "A9", "as9", "as5", "as4", "ga10", "ma4"], "a5": ["A4", "n5", "A8", "p7", "n2", "A5", "alpha6", "a7", "a6", "p5", "alpha4", "p6", "n6", " a6", "alpha5", "A6", "alpha8", "n7", "p2", " a7"], "a8": ["b7", "A4", "A8", "b4", "an6", "alpha6", "a7", "an10", "an7", "a6", "b10", "alpha4", "b8", " a6", "alpha11", "A6", "alpha8", "A11", "an8", "b6", " a7", "b11"], "a9": ["p09", "a09", "A8", "p7", "p10", "a7", "alpha09", "A9", "alpha9", " a09", "A7", "alpha8", "A11", "alpha10", "alpha7", "p9", "alpha11", " a7"], "a10": ["as8", "a09", "A8", "b9", " a12", "a12", "as10", "an10", "an12", "an9", "b10", "A9", "b8", "alpha9", "as09", "as9", "alpha8", "alpha10", "A10", "an8", "b09", "A09", "alpha12"], "a11": [" a18", "A8", "a13", "A18", " a12", "a12", "a18", "a7", "alpha18", "A13", "am11", " a13", "A12", "am7", "A7", "alpha8", "A11", "A10", "am10", "alpha11", " a7", "am13", "alpha12"], "ps": ["pps", "pres", "pi", "settings", "pse", "res", "gets", "Ps", "ns", "py", "ks", "ples", "as", "posts", "per", "qs", "s", "ins", "ases", "pass", "is", "cases", "ms", "pes", "rs", "params", "changes", "parts", "ws", "pr", "pp", "ams", "proxy", "ops", "pers", "ons", "ports", "lines", "eps", "points", "ups", "gs", "ras", "ips", "p", "es", "aps", "ts", "vs", "ls", "js", "hes", "tests", "pos", "alls", "ss", "jp", "details", "ils", "files", "pe", "pa", "ipes", "cs", "ds", "als", "rules", "os", "properties", "ppa", "PS"], "url": ["string", "ssl", "address", "base", "buffer", "server", "uri", "response", "user", "http", "document", "l", "URL", "fl", "twitter", "client", "proxy", "connection", "browser", "build", "config", "file", "web", "ll", "object", "log", "page", "control", "cloud", "ls", "image", "sl", "Url", "www", "bug", "contact", "f", "gl", "service", "download"], "request": ["push", "remote", "rest", "info", "buffer", "temp", "Request", "resource", "response", "server", "user", "builder", "http", "report", "per", "result", "child", "req", "next", "post", "client", "rate", "session", "use", "connection", "r", "upload", "open", "web", "p", "reply", "complete", "hello", "call", "access", "worker", "pull", "pe", "respond", "create", "connect", "transfer", "method", "this", "re", "external"]}}
{"id1": "6613944", "id2": "8486429", "code1": "    public static String installOvalDefinitions(final String xml_location) {\n        InputStream in_stream = null;\n        try {\n            URL url = _toURL(xml_location);\n            if (url == null) {\n                in_stream = new FileInputStream(xml_location);\n            } else {\n                in_stream = url.openStream();\n            }\n        } catch (IOException ex) {\n            throw new OvalException(ex);\n        }\n        Class<OvalDefinitions> type = OvalDefinitions.class;\n        OvalDefinitions object = _unmarshalObject(type, in_stream);\n        String pid = _getDatastore().save(type, object);\n        return pid;\n    }\n", "code2": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"installOvalDefinitions": [" saveOvaldefinitions", " saveOvalRefinitions", " saveOptdefinitions", " saveOvalRefaults", " saveOvalFaults", " saveOvaldefines", " saveOvalRefplates", " saveOvalFinitions", " saveOptdefplates", " saveOvalDefines", " saveOptdefaults", " saveOvalRefines", " saveOvalFplates", " saveOvaldefplates", " saveOvalFines", " saveOptDefplates", " saveOptDefaults", " saveOvalDefinitions", " saveOvalDefplates", " saveOptdefines", " saveOptDefinitions", " saveOvalDefaults", " saveOptDefines", " saveOvaldefaults"], "xml_location": ["http_loc", "http_directory", "xml_filename", "xml_loc", "xml_path", "xmlFilearea", "xml_type", "xml67loc", " xml_loc", "xmlFileLocation", "xml67location", "xml_directory", "xml67path", " xml_path", "xmlFilelocation", "xml_Location", "xml67type", " xml_filename", "xmlFilefilename", " xml_type", "http_location", "xml_area", " xml_area", " xml_Location"], "in_stream": [" in_form", "in67struct", "in_ream", " in_url", "in67clean", "in67sw", "in_struct", "inc_stream", "in_form", "thin67struct", "in_channel", "inc_ream", "in67stream", "in67ream", "inc_cont", "thin67stream", "in67channel", "thin_sw", "in_trans", "in_cont", "thin_channel", "in67cont", "thin_struct", " in_stack", "in_sw", "in_stack", "thin_stream", "inc_clean", " in_trans", "thin67sw", "thin67channel", "in_clean", "in_url"], "url": ["impl", "string", "path", "base", "address", "ssl", "server", "resource", "feed", "uri", "http", "ref", "socket", "html", "l", "location", "host", "URL", "fl", "source", "connection", "browser", "str", "ob", "open", "data", "file", "page", "ll", "bb", "bel", "log", "web", "ls", "coll", "image", "blog", "sl", "Url", "bug", "www", "stream", "obj", "b", "xml", "f", "org", "api", "loc"], "type": ["path", "ype", "base", "class", "handler", "core", "info", "category", "id", "copy", "address", "element", "http", "ref", "py", "python", "o", "instance", "tag", "key", "like", "part", "module", "model", "kind", "group", "collection", "parser", "parent", "file", "Type", "pod", "p", "null", "product", "style", "plugin", "format", "name", "t", "port", "types", "function", "TYPE", "link", "pe", "unit", "obj", "xml", "method", "tool", "single", "platform"], "object": ["string", "info", "base", "class", "address", "node", "id", "document", "version", "project", "result", "o", "instance", "number", " obj", " structure", "nt", "part", "value", "target", "model", "parent", "data", "config", "objects", "oid", "product", "name", "function", "array", "pointer", " error", "obj", "os", " python", "element"], "pid": ["root", "pin", "pkg", "id", "pse", "lp", "uid", "pty", "sid", "bin", "pb", "ids", "iana", "proc", "pp", "phi", "proxy", "pac", "parent", " tid", "oid", "p", "product", "plugin", " pin", "port", "pos", "pointer", "pc", " PID", "vid", "ping", "jp", "pins", "pa", "processor", "abi", "pak", "ps", "pd", "phrase"]}}
{"id1": "1005107", "id2": "11933797", "code1": "    public void googleImageSearch() {\n        if (artist.compareToIgnoreCase(previousArtist) != 0) {\n            MusicBoxView.googleImageLocation = 0;\n            try {\n                String u = \"http://images.google.com/images?q=\" + currentTrack.getArtist() + \" - \" + currentTrack.getAlbum() + \"&sa=N&start=0&ndsp=21\";\n                if (u.contains(\" \")) {\n                    u = u.replace(\" \", \"+\");\n                }\n                URL url = new URL(u);\n                HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();\n                httpcon.addRequestProperty(\"User-Agent\", \"Mozilla/4.76\");\n                BufferedReader readIn = new BufferedReader(new InputStreamReader(httpcon.getInputStream()));\n                String text = \"\";\n                String lin = \"\";\n                while ((lin = readIn.readLine()) != null) {\n                    text += lin;\n                }\n                readIn.close();\n                if (text.contains(\"\\n\")) {\n                    text = text.replace(\"\\n\", \"\");\n                }\n                String[] array = text.split(\"\\\\Qhref=\\\"/imgres?imgurl=\\\\E\");\n                for (String s : array) {\n                    if (s.startsWith(\"http://\") || s.startsWith(\"https://\") && s.contains(\"&amp;\")) {\n                        String s1 = s.substring(0, s.indexOf(\"&amp;\"));\n                        googleImages.add(s1);\n                    }\n                }\n            } catch (Exception ex4) {\n                MusicBoxView.showErrorDialog(ex4);\n            }\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"googleImageSearch": ["googleMediaSearch", " googleImageScan", "googleImagesScan", " googleFileScan", " googleFileSearch", "googleMediaScan", " googleImagesearch", "googleMediasearch", "googleFileScan", "googleImagessearch", "googleFileSearch", "googleFilesearch", "googleImagesSearch", "googleImagesearch", "googleImageScan", " googleFilesearch"], "MusicBoxView": ["MusicBookDisplay", "MusicBookClient", "musicBoxDisplay", "MusicBOXDisplay", "MusicboxClient", "musicboxUI", "MusicboxUI", "MusicBOXClient", "musicboxClient", "MusicFieldDisplay", "musicboxDisplay", "MusicBoxDisplay", "musicboxContainer", "MusicBOXUI", "musicBoxUI", "MusicBookView", "MusicFieldUI", "MusicBoxUI", "MusicBOXView", "musicBoxView", "musicBoxClient", "MusicboxContainer", "MusicFieldContainer", "MusicBoxContainer", "MusicBookUI", "musicBoxContainer", "MusicBoxClient", "musicboxView", "MusicFieldView", "MusicBOXContainer", "MusicboxDisplay", "MusicboxView"], "googleImageLocation": ["googleUrlLocation", "googleUrlAddress", "googlePictureLoc", "googlePicturePosition", "remotePictureLocation", "googleUploadPosition", "googleUploadAddress", "remoteImagePosition", "googleImagePosition", "remotePictureAddress", "remotePictureLoc", "remotePicturePosition", "googlePictureLocation", "googleImageLoc", "googlePictureAddress", "remoteImageLocation", "googleImageAddress", "googleUrlPosition", "googleUrlLoc", "googleUploadLoc", "remoteImageLoc", "remoteImageAddress", "googleUploadLocation"], "u": ["string", "U", "cu", "ou", "base", "i", "input", "lu", "uri", "n", "mu", "username", "user", "plus", "http", "uv", "ue", "c", "ru", "o", "fp", "l", "s", "ui", "su", "util", "universal", "ku", "uu", "ua", "bu", "back", "d", "fu", "up", "q", "ut", "un", "tu", "file", "data", "p", "hu", "e", "t", "a", "ur", "b", "yu", "ul", "iu", "f", "nu", "pu"], "url": ["impl", "string", "path", "ssl", "base", "server", "uri", "user", "http", "l", "host", "URL", "fr", "util", "fl", "connection", "file", "fb", "web", "page", "ll", "log", "conn", "ls", "image", "blog", "sl", "pull", "Url", "bc", "www", "stream", "ur", "b", "ul", "download", "f", "org", "api"], "httpcon": [" httpcn", "httpconnection", "perconf", "urlcon", " httpCon", "httpconn", "webcn", " httpConn", "httpscn", "urlurl", "percon", "webcon", "weburl", "webconnection", " httpconnection", "webCon", "httpConn", "webconf", " httpconf", "urlCon", " httpconn", "httpsConn", "httpcn", "httpCon", "httpscon", " httpurl", "webConn", "httpsconnection", "httpurl", "urlconn", "perCon", "webconn", "httpconf", "perconn"], "readIn": ["runIn", "readIns", "readedIn", "ReadedIn", "readIN", " readin", "readerIns", "ReadStream", "readerStream", " readIns", " readIN", "parseIn", "playIn", "playRef", " readStream", "readin", "readerIn", "loadIn", "loadIN", " readRef", "parsein", "readRef", "readStream", "runedIn", "loadedIn", "runIN", " readedIn", "ReadIn", "ReadIns", "parseIN", "playin", "playIN", "parseRef", "loadin", "readeredIn", "runin"], "text": ["letter", "string", "translation", "path", "info", "event", "input", "id", "feed", "output", "editor", "Text", "message", "TEXT", "act", "inner", "concept", "l", "line", "layout", "code", "pass", "in", "pattern", "content", "txt", "form", "source", "lines", "str", "ut", "config", "data", "body", "out", "object", "ip", "struct", "log", "context", "delete", "format", "lit", "fruit", "test", "title", "name", "lex", "image", "font", "it", "word", "ext", "contract", "b", "left", "f", "vert", "tx", "term", "img"], "lin": ["lt", "val", "string", "base", "sel", "pin", "lu", "lang", "Lu", "Lin", "lock", "kl", "lp", "lb", "late", "l", "ins", "line", "pl", "el", "in", "ele", "hl", "txt", "la", "dl", "fl", "lines", "lc", "len", "str", " line", "li", "vin", "lim", "liner", "le", "ll", "log", "inline", "LIN", "lit", "lic", "ls", "coll", "lex", "ml", "lins", "kin", "sl", "rl", "ln", "Line", "bl"], "array": ["index", "string", "address", "audio", "vector", "api", "all", "record", "database", "queue", "arr", "part", "angle", "ab", "our", "r", "group", "Array", "collection", "section", "archive", "page", "object", "row", "ray", "coll", "image", "area", "pair", "v", "range", "stack", "air", "ar", "element", "list", "arrow"], "s1": ["cOne", "sOne", " s0", " sOne", "gOne", "g2", "c2", "g1", "c1", "s0", "s2", " s81", "c81", "s81", "g0", " s2", "c0"], "ex4": ["Ex8", "ception384", "exp2", "Exfour", "EXfour", "ext384", "Ex4", " ex384", "ext4", "ception4", " exfour", "extfour", "ception04", "EX4", "exp4", "expfour", "EX8", "ext04", "exfour", "Ex2", "EX2", "ex2", "ex8", "ex384", "exp8", " ex04", "ceptionfour", "ex04"]}}
{"id1": "20310134", "id2": "8216539", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyChannel", "copyChannel", "CopyFile", "copyfile", "transferfile", "transferFiles", "transferChannel", " copyFiles", "Copyfile", " copyChannel", "CopyFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "base", "buffer", "i", "input", "id", "ex", "lock", "ic", "c", "inner", "as", "l", "ins", "bin", "query", "reader", "source", "login", "min", "diff", "inc", "work", "config", "file", "data", "again", "name", "m", "image", "io", "In", "url", "lin", "inn"], "out": ["string", "base", "server", "output", "n", "ex", "resource", "user", "plain", "c", "OUT", "outs", "o", "write", "off", "cache", "dot", "connection", "default", "w", "file", "page", "x", "p", "conn", "again", "name", "exec", "Out", "io", "writer", "image", "call", "prefix", "ext", "v", "b", "external", "point", "img"], "inChannel": ["binStream", "inputChannel", "INchannel", "iniChannel", "binchannel", "inStream", "insConnection", " inchannel", "inchannel", "binChan", "InQueue", "InChan", "loginChan", "loginChannel", "Inchannel", "iniStream", "INChan", "outStream", "inputChan", "iniChan", "outchannel", "outQueue", "inputConnection", "outChan", "inChan", "InGate", "InChannel", "InStream", "inputStream", "insStream", "inQueue", "binChannel", "INStream", "insChannel", "INChannel", " inQueue", "inConnection", " inChan", "insChan", "loginchannel", "binGate", "loginStream", "INConnection", "iniGate", "inGate"], "outChannel": ["netChan", "ouChan", "inStream", "netGate", "netChannel", "outputGate", "OutConnection", "OutChannel", "ouChannel", "inchannel", " outChar", " outConnection", "ouchannel", "OutChan", "ouGate", "outStream", "outChar", "outchannel", "outChan", "inChan", "outputStream", "netStream", "outputchannel", "outputChannel", "outConnection", "Outchannel", " outGate", "inGate", "outputChan", "inConnection", " outStream", "outputChar", "outGate", "inChar", " outchannel", " outChan"]}}
{"id1": "21425787", "id2": "8135072", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "base", "i", "input", "id", "ex", "ini", "c", "inner", "ins", "bin", "at", "reader", "source", "up", "connection", "min", "login", "inc", "work", "data", "file", "or", "again", "name", "m", "exec", "image", "io", "In", "a", "url", "b", "ac", "inn"], "out": ["base", "temp", "ex", "output", "n", "server", "user", "c", "OUT", "result", "dest", "outs", "o", "off", "client", "part", "at", "source", "cache", "up", "connection", "target", "w", "inc", "data", "file", "object", "x", "p", "conn", "name", "again", "exec", "Out", "writer", "io", "to", "call", "prefix", "v", "b", "point"], "sourceChannel": ["srcConnection", " sourcechannel", "sourcechannel", "ourceChan", "ourceConnection", "Sourcechannel", " sourceSocket", "targetChan", "SourceStream", " sourceStream", "sourceChan", "ourceSocket", " sourceChan", "targetStream", "sourceConnection", "srcSocket", "resourcechannel", "resourceChan", "ourcechannel", "srcChannel", "ourceChannel", "sourceStream", "SourceChan", "sourceSocket", "resourceChannel", "targetchannel", "srcChan", "SourceChannel", "targetChannel", "SourceConnection", " sourceConnection", "resourceConnection"], "destinationChannel": ["destinationFile", "destationChannel", "destinatedchannel", "DestinationFile", "destinatorchannel", "destinatorChannel", "destructionChan", "destinationConnection", "destinateChannel", "destinatedChannel", "destinatingChan", "destinationChan", "destationConnection", "Destinatorchannel", "DestinatingStream", "destinatorManager", "destinatedChan", "destinatedFile", "destinatedManager", "destationchannel", "DestinationConnection", "destinatorFile", "destinatingChannel", "DestinationChan", "DestinationChannel", "destinatorConnection", "destinateChan", "Destinationchannel", "DestinatingManager", "DestinatingChan", "destinationStream", "DestinationManager", "destructionConnection", "destinationManager", "DestinationStream", "destinatingManager", "DestinatorConnection", "DestinatingChannel", "destinationchannel", "DestinatorChannel", "DestinatorFile", "destinatingStream", "DestinatorChan", "destinatorStream", "destinateConnection", "destationFile", "destinatorChan", "destinatedConnection", "destinatedStream", "destructionChannel"]}}
{"id1": "1141361", "id2": "17557289", "code1": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 0, "substitutes": {"makeRead": ["doRead", "executePut", " executeRead", " makePut", "executeAdd", "executeRead", "doREAD", "doPut", " executePut", " executeAdd", "doAdd", "executeREAD", " executeREAD", " makeREAD", " makeAdd"], "user": ["custom", "string", "job", "server", "token", "username", "USER", "author", "project", "User", "uid", "mode", "admin", "host", "meta", "write", "owner", "usr", "password", "post", "use", "users", "date", "item", "alias", "pod", "log", "row", "creator", "name", "blog", "word", "db", "human", "url", "bug", "comment", "field", "install"], "databaseID": ["tableID", " databaseid", " databaseUID", "databaseName", "DatabaseUID", "DatabaseID", "databaseKey", "connectionID", " databaseKey", "connectionKey", "connectionid", "databaseid", " databaseName", "dbID", "DatabaseName", "dbUID", "databaseUID", "DatabaseId", "tableid", "dbId", "tableKey", "databaseId", " databaseId", "dbName"], "time": ["string", "path", "tz", "id", "timeout", "month", "year", "message", "clock", "table", "end", "ime", "mode", "instance", "length", "set", "host", "read", "post", "rate", "type", "source", "TIME", "money", "date", "value", "str", "text", "timer", "size", "tim", "name", "port", "home", "Time", "hour", "comment", "times", "depth"], "query": ["string", "execute", "id", "timeout", "report", "sequence", "message", "table", "join", "qu", "eries", "database", "post", "select", "filter", "q", "connection", "ql", "work", "request", "search", "sq", "Query", "name", "function", "call", "db", "commit", "sql", "update", "comment", "question", "command", "script", "error", "module", "code"], "statement": ["string", "i", "execute", "server", "agent", "response", "note", "builder", "usage", "document", "message", "table", "slave", "result", "join", "instance", "ma", "s", "volume", "jo", "si", "memory", "database", "joined", "ment", "password", "post", "expression", "stat", "mt", "use", "rule", "session", "connection", "media", "str", "machine", "parser", "alias", "section", "opened", "journal", "study", "language", "style", "init", "Statement", "status", "function", "commit", "di", "sql", "unit", "comment", "general", "st", "command", "state", "batch", "this", "storage"], "count": ["index", "total", "base", "sum", "cc", "id", "more", "list", "table", "number", "limit", "child", "length", "offset", "content", "handle", "part", "type", "cache", "cond", "expected", "connection", "diff", "counter", "inc", "Count", "check", "size", "log", "start", "force", "err", "process", "state", "found", "batch", "error", "code", "depth"]}}
{"id1": "22410173", "id2": "10391753", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "source": ["path", "base", "sin", "input", "id", "resource", "copy", "Source", "ie", "site", "slice", "inner", "ins", "ources", "SOURCE", "iter", "use", "reader", "up", "connection", "target", "down", "parent", "file", "src", "route", "size", "start", "name", "internal", "image", "url", "stream", "unit", "ource", "from"], "dest": ["path", "temp", "output", "project", "later", "destroy", "done", "bin", "exit", "die", "comb", "thin", "true", "wb", "connection", "target", "dist", "down", "file", "src", "Dest", "de", "flat", "tmp", "delete", "test", "desc", "folder", "name", "home", " destination", "transfer", "this", "orig", "img"], "in": ["IN", "info", "pin", "i", "input", "id", "n", "resource", "ini", "lock", "gin", "by", "ie", "con", "c", "inner", "socket", "as", "ins", "s", "bin", "client", "reader", "up", "login", "min", "inside", "r", "inc", "work", "data", "file", "src", "init", "conn", "plugin", "again", "start", "m", "name", "image", "re", "In", "nin", "a", "pull", "url", "err", "b", "cin", "inn", "f", "win", "this", "din"], "out": ["index", "ou", "i", "temp", "ex", "output", "n", "self", "outer", "id", "timeout", "option", "net", "plain", "OUT", "socket", "c", "inner", "o", "outs", "pool", "off", "write", "bin", "extra", "password", "client", "sync", "at", "no", "lib", "up", "not", "connection", "our", "cat", "w", "inc", "data", "file", "channel", "parent", "log", "init", "conn", "again", "name", "exec", "Out", "io", "writer", "exp", "to", "call", "url", "ext", "err", "obj", "with", "vert", "this", "img"]}}
{"id1": "4593011", "id2": "3430784", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 0, "substitutes": {"loadDDL": ["LoadDDE", "loadSDLL", "loadDDML", "LoadCDL", "loadSDL", "loadODML", "loadCDE", "loadODL", "LoadCDE", "loadDDE", "loadCDLL", "loadSDE", "LoadCDML", "loadSDML", "LoadDDL", "loadDDLL", "LoadDDML", "loadCDL", "LoadCDLL", "loadCDML", "loadODLL", "loadODE", "LoadDDLL"], "stmt": ["strgr", "tm", "Stmn", "stpr", "rmt", "estmd", "tmd", "constm", "sttt", " stm", "esttt", "rdb", "Stdb", "STgr", "tmt", "strmt", " stmd", "tdb", "stmp", "Stmr", " sttt", "stm", " sttr", "STpr", "STmp", "Stmp", "STmt", "estmt", "sttr", "stmr", "strtr", "constmt", "Stmd", "estmp", "STmr", "rmd", "STmb", "stgr", "constmn", " stdb", "estmr", "STtr", " stgr", "constdb", "Stm", "Stmb", " stpr", " stmn", "rm", "stmn", "Sttt", "stmb", "stdb", "Stmt", "estm", "estmb", "stmd", "strpr"], "qry": [" qri", "qRY", "equry", "qries", "Qries", "qrys", "Qry", "quries", "quury", " qries", "eqry", " qRY", " qrys", "qri", "Qrys", " qury", "Qri", "quri", "quRY", "eqRY", "eqrys", "qurys", "qury"], "q": ["iq", "qt", "i", "qa", "id", "n", "c", "qu", "qs", "query", " query", "dq", "key", "queue", "req", "select", "d", "r", "ch", "eq", "ql", "qq", "config", "quant", "Q", " p", "request", "requ", "p", "sq", " sq", "e", "t", "quest", "k", "v", "b", " req", "f"]}}
{"id1": "942693", "id2": "11952735", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"convert": ["CONverting", "subverting", "Conversion", "oconversion", "oconverting", "Converting", "CONversion", "unversion", "CONvert", "conversion", "CONception", "oconverted", " deconverted", "converting", "CONverted", "subvert", "oconvert", "Conception", "unvert", "converted", " deconverting", "subversion", "Converted", "unception", "unverted", "subverted", " deconversion", "conception", "Convert", " deconvert"], "src": ["impl", "string", "path", "sel", "ssl", "sin", "input", "sc", "uri", "resource", "sys", "spec", "rc", "Source", "video", "cmp", "username", "filename", "ref", "slice", "cb", "fp", "fn", "s", "prot", "code", "inst", "feat", "cpp", "req", "gb", "back", "source", "reader", "load", "proc", "sb", "rb", "sit", "buf", "component", "dist", "upload", "SourceFile", "config", "file", "tmp", "Dest", "supp", "attr", "img", "href", "storage", "name", "sth", "gz", "RC", "rl", "ctx", "secure", "url", "scene", "stream", "obj", "st", "stage", "sn", "ource", "download", "loc"], "dest": ["path", "class", "temp", " dst", "cont", "fn", "bin", "dc", "std", "txt", "source", "dir", "lib", "target", "dist", "tmp", "Dest", "null", "test", "home", "di", "obj", " destination", "dat", "disk", "orig", "img"], "in": ["IN", "val", "pin", "i", "input", "ex", "n", "inas", "ini", "as", "ins", "bin", "pass", "is", "reader", "d", "source", "doc", "up", "login", "r", "inc", "data", "file", "io", "t", "isin", "In", "a", "stream", "err", "inn", "ps", "f", "inf", "win", "din"], "p": ["P", "i", "pi", "op", "wp", "pre", "lp", "per", "py", "c", "j", "fp", "o", "l", "s", "pb", "cop", "part", "cp", "d", "pr", "pp", "pm", "r", "g", "parser", "h", "np", "po", "tp", "m", "e", "t", "pc", "jp", "pa", "bp", "pe", "b", "sp", "v", "ps", "f", "pd", "pg"], "ds": ["services", "uds", "ays", "docs", "ants", "dos", "s", "ins", "dp", " DS", "parts", "points", "gs", "els", " props", "des", "ts", "js", "utils", "ths", "ys", "gd", "sys", "df", "lp", "bs", "dc", " ps", "dt", "sync", "lines", "eps", "vs", "ges", "amps", "ipes", "pd", "dd", "sts", "DS", "cons", "ks", "ns", "qs", "ld", "hs", "d", "dist", "ans", "ads", "xs", "models", "plugins", "groups", "tests", "ss", "di", "os", "posts", "styles", "rs", "dl", "tools", "ded", "ups", "data", "vals", "scripts", "Ds", "ls", "obs", "dm", "db", "ils", "nas", "dates", "da", "cs", "words", "dds", "ps", "dat", "icks", " sd"], "format": ["letter", "string", "path", "class", "handler", "spec", "filename", "act", "version", "table", "fp", "fn", "host", "tag", "record", "layout", "feat", "magic", "Format", "pattern", "form", "filter", "at", "type", "source", "part", "model", "parser", "config", "data", "file", "sche", "struct", "ant", "language", "style", "plugin", "template", "name", "frame", "t", "function", "prefix", "fd", "nat", "url", "unit", "atter", "f", "scale", "api"], "hasPixelData": ["hasPixeldata", "showsPixelDATA", "hasPixelDATA", "hasPicturedata", "hasByteSize", "hasByteDATA", "hasByteData", "haspixelData", "hasPixelStyle", " hasPixelSize", "showsByteDATA", "hasPictureSize", " hasPixeldata", "haspixeldata", "showsBytedata", "hasPictureData", "haspixelSize", "showsByteData", "showsPixelData", "showsByteStyle", "hasPixelSize", "hasByteStyle", "showsPixelStyle", "hasBytedata", "showsPixeldata"], "inflate": ["inadequating", "insflode", "insvenating", "inffated", "Inflation", "InFlation", "inflating", "Inflated", "inflATE", "InFlace", "insvenate", "inadequode", "InFlated", "insflate", "infolATE", "infface", "invenode", "InFlate", "inffation", "inflated", "inFlation", "infolode", "infloace", "insvenATE", "infloate", "invenATE", "inFlate", "inadequATE", "insflATE", "infloation", "invenating", "inffate", "insvenode", "inadequate", "Inflace", "inflation", "inflode", "inFlated", "Inflate", "infolate", "inFlace", "infloated", "invenate", "infolating", "inflace", "insflating"], "pxlen": ["pxdata", "xpsize", "pxlin", "pngcount", "mxsize", "campos", "fxlen", "pxl", "pgLen", "axlen", "ppLen", "mxcount", "fxln", "pxlon", "pxln", "pcln", "pglen", "ppl", "pxlength", "ppden", "camln", "txln", "pngsize", "pxpos", "pclon", "camlen", "mxdata", "axln", "axlon", "mxlength", "mxpos", "mxlen", "xplen", "txlin", "pxden", "pxcount", "fxpos", "txlon", "pclin", "pxsize", "fxdata", "pxLen", "mxln", "xpcount", "pgl", "fxLen", "axlin", "pnglen", "xplength", "fxl", "pgden", "fxden", "pclen", "pnglength", "txlen", "pplen", "camdata"], "out": ["step", "server", "output", "copy", "sys", "user", "lock", "OUT", "inter", "outs", "line", "co", "query", "post", "session", "cache", "lib", "up", "group", "store", "parent", "work", "page", "log", "gen", "conn", "again", "Out", "io", "dump", "obj", "v", "err", "state", "pad", "cli", "error", "re", "list", "point"]}}
{"id1": "19335986", "id2": "812803", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["CaughtException", "uncachedexc", "uncatchedexc", "uncaughtEvent", "CatchedEvent", "Catchedexc", "Caughtexc", "uncaughtexc", "uncachedEvent", "uncachedException", "uncatchedException", "unchandledException", "unchandledexc", "CatchedException", "uncatchedEvent", "CaughtEvent", "unchandledEvent"], "t": ["n", "c", "l", "s", "te", " T", "ty", "type", "d", "r", "g", "w", "out", "p", "ts", "let", "title", "m", "tree", "ing", "it", " td", "T", "tr", "ed", "f", "tx"], "e": ["event", "fe", "i", "ace", "ee", "be", "ie", "eb", "c", "ge", "j", "se", "o", "s", "el", "ception", "ele", "en", "ec", "er", "d", "ce", "diff", "r", "data", "de", "exc", "ep", "p", "es", "ae", "environment", "ne", "eu", "example", "m", "E", "ev", "ed", "pe", "me", "err", "f", "error", "oe", "Exception", "element", "code", "enter", "esi"], "display": ["play", "fe", "console", "panel", "report", "profile", "description", "window", "host", "layout", "content", "monitor", "scroll", "d", "hide", "show", "default", "config", "de", "body", "page", "object", "p", "style", "dis", "status", "image", "screen", "Display", "position", "app", "me", "summary", "design", "container", "process", "this", "view", "platform"], "shell": ["hell", "buffer", "console", "server", "copy", "lock", "mail", "system", "echo", "l", "child", "host", "el", "clone", "loop", "tools", "sb", "live", " Shell", "machine", "math", "body", "cl", "launch", "h", "environment", "log", "bash", "m", "exec", "image", "status", "Shell", "ml", "kernel", "sym", "app", "sh", "sound", "b", "poll", "container", "process", "xml", "help", "gui", "cli", "tool"], "message": ["event", " exception", "address", "buffer", "translation", "mess", "console", "server", "output", "copy", "response", "report", "mail", "document", "description", "result", "management", "queue", "content", "monitor", "email", "member", "value", "media", "model", "application", "data", "body", "page", "object", "request", "flash", "Message", "log", "msg", "header", "m", "meter", "status", "image", " messenger", "update", "summary", "xml", "essage", "error", "view"], "e1": [" e3", "e3", "exc2", "e8", " e2", "E1", "e2", "E3", "E2", " e8", "E8", "exc3", "exc8", "exc1"]}}
{"id1": "8468859", "id2": "17724879", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "label": 0, "substitutes": {"connect": ["close", "add", "on", "con", "connected", "socket", "find", "run", "patch", "Connect", "host", "write", " connection", "read", " reconnect", "en", " disconnect", "select", "client", "stat", "nect", "construct", "login", "connection", "build", "open", "bind", "config", "log", "conn", "init", "start", "exec", "port", "establish", "create", "sign", "download", "boot", "stop"], "status": ["index", "temp", "id", "output", "response", "server", "user", "continue", "site", "version", "current", "result", "standard", "si", "ui", "active", "content", "Status", "fail", "sync", "session", "source", "use", "stat", "type", "login", "min", "str", "parent", "log", "style", "complete", "edit", "success", "full", "skip", "update", "unit", "summary", "wait", "stage", "count", "progress", "state", "step", "speed", "code"], "reply": ["reason", "info", "address", "fee", "dy", "base", "server", "response", " response", "message", "py", "result", "answer", "query", "ret", "next", "post", "sync", "resp", "connection", "Reply", "data", "request", "vote", "action", "send", "call", "link", "prefix", "second", "ping", "bot", "respond", "update", "comment", "random", "state", "count", "repl", "error", "code"], "isConnected": ["isNECTalled", "isaAdapting", "isaConnectified", "IsConnected", "isConnectaged", "isFinalled", "IsConnections", "isConnectionp", "IsConnectionp", "isAcceptted", "isConnects", "isConnectioning", "isConnectted", "isAcceptaged", " isAcceptted", "IsConnectioning", " isConnectioned", "isFinaged", " isConnectable", " isAcceptaged", "isNECTing", "IsConnectp", "isAdapting", "isconnecteded", "isConnectionified", "isConnectified", "isaConnecting", " isConnectted", "isAdaptified", "IsConnects", " isConnecting", "isConnectished", "IsConnectioned", "isconnecteding", "isAdapteded", "isFinished", "isConnectioneded", "isConnectp", "isaAdaptified", "isConnections", " isAcceptable", "isNECTished", "isaAdapteded", "isAdapted", "isaAdapted", " isAccepted", "isAcceptable", " isConnectionished", "isconnectedp", " isConnectalled", " isConnectaged", "isFined", "isConnectionished", "isFinted", "isConnecteded", "isConnectioned", "isConnectionalled", " isConnectionalled", " isConnectioning", "isNECTed", "IsConnecting", "isFinable", " isConnectished", "isAccepted", "isaConnecteded", "isaConnected", "isFining", "isconnecteds", "isConnectalled", "isConnecting", "isConnectable"]}}
{"id1": "16142024", "id2": "7499186", "code1": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFolder", " copyfile", "transferDirectory", "CopyFile", "copyfile", "transferfile", "CopyFolder", " copyDirectory", "copyFolder", "CopyDirectory", "copyDirectory", "Copyfile", " copyFolder", "transferFile"], "srcFile": [" srcfile", "sourceDir", "rcFile", "destClass", " srcDir", "srcFiles", "rcfile", "sourcePath", "sourceFolder", "rcPath", "sourceFile", "srcClass", "sourceClass", "destFiles", "sourceFiles", "rcFiles", " srcFiles", "srcPath", " srcClass", "rcFolder", " srcDirectory", "sourcefile", "srcDir", " srcFolder", "srcFolder", "sourceDirectory", "rcDir", " srcPath", "srcfile", "rcDirectory", "srcDirectory"], "destDir": ["Destdir", "targetFolder", "targetdir", " destFolder", "destDirectory", "sourceDir", "destdir", " destDirectory", "DestFolder", "DestFile", "sourceFolder", "destFolder", "targetDir", "DestDir", "srcDir", "DestDirectory", "srcFolder", "sourceDirectory", "targetDirectory", "sourcedir", "srcDirectory"], "buffer": ["info", "address", "border", "Buffer", "input", "uffer", "resource", "feed", "entry", "message", "slice", "document", "result", "length", "memory", "read", "queue", "iter", "raw", "source", "cache", "seed", "buff", "value", "buf", "data", "file", "text", "request", "size", "null", "header", "array", "received", "position", "flush", "url", "b", "reference", "padding", "transfer", "batch", "phrase"], "destFile": ["targetFolder", " destFolder", "destDirectory", " destDirectory", "DestFolder", "DestFile", " destinationModel", " destModel", "destFolder", " destinationDir", "targetDir", "DestDir", " destinationDirectory", "DestDirectory", "targetDirectory", " destinationFile", "DestModel", "destModel", "targetFile"], "in": ["IN", "i", "input", "n", "id", "serv", "token", "ex", "ini", "lock", "gin", "con", "inner", "socket", "as", "l", "ins", "bin", "pass", "is", "client", "part", "reader", "source", "up", "min", "inside", "r", "inc", "data", "file", "h", "init", "again", "m", "image", "In", "nin", "a", "pull", "url", "stream", "lin", "err", "inn", "f", "win", "din"], "out": ["base", "ex", "output", "n", "outer", "net", "plain", "OUT", "inner", "outs", "o", "s", "line", "co", "bin", "post", "client", "part", "one", "source", "cache", "up", "other", "inc", "w", "data", "file", "work", "parent", "null", "conn", "again", "name", "exec", "Out", "writer", "io", "image", "ext", "err", "obj", "v"], "bytesRead": ["linesCount", "Bytesread", "filesFollow", "bytesCount", "sizeWritten", "sizeOpen", "bytesNeed", " bytesWritten", "classesRead", "linesUse", "filesNeed", "classesFollow", "BytesRead", "piecesWrite", "piecesUse", "sizeRead", "BytesOpen", "sizeread", "linesRead", " bytesUse", "bytesFollow", "bytesWritten", "bytesread", "filesWrite", " bytesNeed", " bytesread", "classesWrite", " bytesCount", "piecesCount", " bytesOpen", "classesNeed", "BytesWritten", "filesRead", " bytesWrite", "linesWrite", "bytesWrite", "bytesUse", "piecesRead", " bytesFollow", "bytesOpen"]}}
{"id1": "15510198", "id2": "23677147", "code1": "    protected static Parser buildParser(URL url) throws IOException, ParserException {\n        Parser parser;\n        URLConnection connection = openConnection(url);\n        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {\n            parser = new Parser(connection);\n        } else {\n            parser = null;\n        }\n        return parser;\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 0, "substitutes": {"buildParser": ["constructParser", "constructReader", "makeReader", "makeWriter", "buildWriter", "newHandler", "makeParser", "newReader", "newParser", "constructHandler", "buildHandler", "newWriter", "constructWriter", "buildReader", "makeHandler"], "url": ["path", "address", "base", "loader", "class", "ssl", "server", "uri", "resource", "http", "c", "location", "l", "host", "URL", "source", "proxy", "str", "open", "config", "data", "file", "channel", "page", "object", "null", "name", " URL", "image", "io", "link", "sl", "Url", "bug", "www", "obj", "this", "service", "loc"], "ParserException": ["IOError", "IOExc", "SSLError", " IOExc", "SSLException", "SSLExc", " IOException", " IOError", "ParserError", "ParserExc", "IOException"], "parser": ["root", "handler", "class", "arser", "loader", "server", "builder", "master", "http", "slave", "result", "se", "instance", "library", "api", "pool", "php", "fp", "manager", "ler", "pard", "er", "type", "reader", "cache", "seed", "parent", "data", "au", "config", "object", "x", "p", "null", "style", "plugin", "test", "fruit", "writer", "worker", "jp", "pc", "angler", "pe", "parse", "processor", "xml", "Parser", "pd", "this", "jack"], "connection": ["directory", "Connection", "event", "handler", "class", "server", "resource", "response", "uri", "http", "document", "con", "c", "communication", "connected", "socket", "message", "character", "instance", "j", "relation", "database", "condition", "client", "session", "reader", "lc", "proxy", "ion", "application", "collection", "open", "config", "section", "channel", "object", "context", "conn", "image", "io", "function", "pointer", "link", "db", "service", "position", "bc", "connect", "reference", "this", " Connection", "loc"]}}
{"id1": "18731843", "id2": "23118425", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"doBody": ["doFile", "handleFile", "handleResponse", "handleBytes", "handleBody", "doResponse", " doBytes", " doFile", "doBytes", "DoBody", "DoBytes", "DoFile", " doResponse", "DoResponse"], "req": ["qt", "info", "Request", "resource", "sem", "spec", "serv", "report", "res", "http", "ref", "fr", "query", "comp", "reader", "rh", "proc", "q", "r", "crit", "config", "data", "qq", "src", "request", "requ", "rr", "rec", "conn", "rss", "cgi", "rx", "jp", "respond", "err", "obj", "reg", "def", "this", "download"], "resp": ["val", "respons", "job", "serv", "response", "cmp", "report", "res", "pre", "ref", "result", "cb", "html", "api", "inv", "prot", "ret", "comp", "part", "cache", "Resp", "proc", "r", "data", "exc", "rep", "request", "bb", "p", "reply", "rr", "rec", "pos", "jp", "rev", "respond", "Response", "err", "sp", "b", "obj", "re", "download"], "bis": ["uds", "sin", "usb", "iss", "lis", "bh", "alis", "tis", "obb", "bs", "obos", "bin", "ois", "is", "ori", "obi", "bes", "binary", "sb", "oris", "bps", "ais", "bian", "ubis", "bas", "nis", "fb", "phis", "bb", "bi", "ris", "obs", "isin", "lins", "iris", "ios", "atis", "ses", "pins", "sis", "b", "abi", "los", "os", "bits", "rots", "bid", "boot", "mis"], "bos": ["uds", "mos", "oses", "fits", "bh", "antis", "zos", "tis", "bones", "obb", "bs", "bo", "obos", "ois", "bin", "oos", "obo", "obi", "bes", "ros", "ops", "bps", "ubis", "bas", "bris", "bott", "las", "phis", "bi", "opus", "aos", "obs", "oks", "lins", "ios", "oS", "osa", "lol", "los", "zo", "abi", "oops", "os", "oros", "osi", "bits", "boot"]}}
{"id1": "11032546", "id2": "22625683", "code1": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "code2": "    public static Model downloadModel(String url) {\n        Model model = ModelFactory.createDefaultModel();\n        try {\n            URLConnection connection = new URL(url).openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\");\n                httpConnection.setRequestProperty(\"Accept-Language\", \"en\");\n            }\n            InputStream in = connection.getInputStream();\n            model.read(in, url);\n            in.close();\n            return model;\n        } catch (MalformedURLException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"testCopyUnknownSize": ["testCopyUnknownsize", "testcopyunknownsize", "testcopyunknownSize", "testCopyKnownsize", "testcopyUnknownsize", "testcopyUnknownSize", "testCopyunknownsize", "testCopyunknownSize", "testCopyKnownSize"], "in": ["IN", "info", "i", "input", "id", "n", "c", "inner", "as", "ins", "bin", "is", "at", "reader", "source", "up", "connection", "min", "inside", "r", "inc", "data", "src", "conn", "m", "exec", "io", "image", "In", "nin", "a", "url", "err", "b", "inn", "this", "din"], "out": ["path", "base", "buffer", "temp", "input", "plus", "ex", "output", "copy", "user", "OUT", "o", "outs", "pool", "off", "bin", "extra", "next", "post", "sync", "client", "at", "one", "cache", "up", "target", "work", "parent", "data", "file", "inc", "append", "size", "conn", "again", "name", "exec", "Out", "image", "io", "to", "array", "prefix", "ext", "obj", "with", "error", "auto"], "cpySize": ["cpiMode", " cpeSize", "cpeCount", "cciCount", "czipSize", "cpiLength", "CpeSize", " cpeArray", "CpeCount", "cpiSize", "cpiArray", "cpyLength", "cpeLength", "cPyLength", "czipLength", "CpySize", " cpyMode", " cpyLength", "CpeLength", " cpyArray", " cpeMode", "cpyMode", "cpeSize", "cciSize", "czipArray", "CpyLength", "cpyCount", "cPySize", "czipMode", "cpeArray", " cpeLength", "cpeMode", "CpyCount", "cpyArray", "cciLength", "cPyCount"], "outArray": ["outputList", " outAmount", "viewArray", "outputArray", "targetMemory", "viewBuffer", "outputBuffer", "inArray", "inAmount", "outSize", "inSize", " outList", "targetList", " outMemory", "outAmount", "targetArray", "viewSize", "inBuffer", "targetBuffer", "outputMemory", "outList", "outBuffer", " outSize", "viewAmount", " outBuffer", "outMemory"]}}
{"id1": "10214218", "id2": "12146394", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "label": 1, "substitutes": {"encrypt": ["enrypt", "encress", " encipher", "enress", " encress", " enccrypt", "decipher", "enipher", "encipher", "decress", "enccrypt", "deccrypt", "decrypt"], "plaintext": ["anystruct", "plaintxt", "anytxt", "batText", "plainText", " plaintxt", "mainText", "plainstruct", "mainstruct", "anytext", " plainText", "anyText", "mainsource", "batsource", "battxt", " plainsource", "plainsource", "maintext", " plainstruct", "batstruct", "battext"], "md": ["mu", "mag", "arm", "od", "bd", "Cmd", "amd", "message", "mo", "kg", "ma", "am", "meta", "dr", "wd", "MD", " MD", "ld", "ms", "ad", "sm", "key", "cm", "mb", "mt", "dh", "d", "mac", "mage", "mp", "sha", "pm", "pd", "data", "mm", "metadata", "dig", "pg", "m", "hm", "dm", "db", "mand", "mc", "nm", "mod", "em", "mg", "mad", "cmd", "dd"], "raw": ["original", "buffer", "input", " RAW", "feed", "clean", "enc", "rew", "rc", "message", "ack", "RAW", "hex", "instance", "unknown", "content", "load", "binary", "serial", "buf", "wave", "Raw", "none", "data", "text", "null", "row", "unsigned", "image", "array", "dec", "pack", "full", "good", "bytes", "wrapper", "words", "block", "ng", "initial"], "hash": ["base", "sum", "her", "id", "response", "ashes", "message", "version", "kh", "hex", "Hash", "html", "ash", "key", "alpha", "mac", "cache", "rh", "sha", "data", "ruby", "h", "log", " hex", "header", "image", "hed", "array", "ha", "url", "sh", "secret", "abi", "block", "code"]}}
{"id1": "15445861", "id2": "3184073", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "transferDirectory", "CopyFile", "copyfile", "transferfile", "transferFiles", " copyDirectory", " copyFiles", "CopyDirectory", "Copyfile", "copyDirectory", "CopyFiles", "copyFiles", "transferFile"], "srcFile": [" srcfile", "srcPlace", " srcTime", "destDirectory", "rcPlace", "sourceDir", "rcFile", "supFile", " srcDir", "srcFiles", "ourcePath", "ourceTime", "srcStream", "ourceFile", "rcfile", "sourcePath", "ourcePlace", "rcStream", "rcPath", "rcTime", "sourceFile", "srcTime", "destTime", "supPath", "rcFiles", "sourceFiles", "supStream", " srcFiles", "srcPath", "supfile", "destDir", " srcDirectory", "sourcefile", "srcDir", " srcPlace", "sourceDirectory", "rcDir", " srcPath", "srcfile", "rcDirectory", "srcDirectory", " srcStream"], "destFile": ["destFilename", "inationFilename", "stdfile", "destDirectory", " destTime", "sourceTime", "stdFile", " destDirectory", "endTime", "endPath", "DestPath", "destfile", "vertFilename", "DestFilename", "inationPath", "DestFile", "tempPath", " destFiles", "sourceFile", " destFilename", "destTime", "destFiles", "inationFiles", "stdTime", "DestFiles", "inationFile", "targetPath", " destfile", "stdDirectory", " destPath", "endFile", "sourcefile", "destPath", "vertFile", "Destfile", "vertPath", "sourceDirectory", "targetTime", "tempfile", "tempFile", "tempFiles", "vertFiles", "targetFilename", "endFilename", "targetFile"], "in": ["IN", "base", "pin", "i", "input", "id", "ex", "serv", "ini", "gin", "con", "socket", "inner", "as", "ins", "bin", "is", "read", "source", "reader", "up", "login", "min", "inside", "r", "inc", "rin", "h", "get", "init", "or", "again", "m", "io", "image", "isin", "In", "nin", "kin", "a", "pull", "url", "b", "ac", "cin", "inn", "f", "win", "din"], "out": ["base", "ex", "n", "output", "user", "by", "gin", "net", "OUT", "socket", "inner", "outs", "o", "off", "line", "bin", "pass", "sync", "client", "one", "cache", "up", "other", "inc", "w", "parent", "file", "work", "conn", "again", "exec", "Out", "io", "writer", "exp", "to", "ext", "err", "obj"], "buffer": ["base", "border", "Buffer", "input", "uffer", "address", "server", "feed", "pause", "document", "slice", "limit", "result", "length", "memory", "read", "queue", "offset", "iter", "reader", "source", "binary", "buff", "buf", "wave", "data", "channel", "variable", "size", "null", "header", "bytes", "position", "layer", "flush", "url", "b", "reference", "padding", "block", "transfer", "batch", "phrase"], "no": ["index", "info", "lo", "i", "num", " NO", " lo", "id", "ko", "nr", "mo", "yes", "number", "o", "off", "co", " mo", "No", "ino", "only", "nothing", "nt", "nor", "type", "so", "was", " none", "which", "nos", "none", "data", "eno", "maybe", "go", "x", "size", "po", "io", "pos", "to", "na", " number", "wa", "os", "zero", "NO", "error", "from", "auto"]}}
{"id1": "6517139", "id2": "10212189", "code1": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 0, "substitutes": {"getPrefsKey": ["getPrefixedSecret", "getPubixedSecret", "getPubixedKey", "getPubsSecret", "getPrefixKey", "getPrefesValue", "getPubsValue", "getPrefixSecret", "getPrefesKey", "getPrefsValue", "getPrefixKeys", "getPrefixValue", "getPrefixedKey", "getPrefesKeys", "getPubixedValue", "getPubsKey", "getPrefixedValue", "getPrefesSecret", "getPrefsKeys", "getPrefixedKeys", "getPrefsSecret", "getPubsKeys", "getPubixedKeys"], "key": ["keys", "string", "reason", "address", "base", "fee", "core", "temp", "id", "ace", "token", "original", "enc", "entry", "path", "message", "json", "result", "hex", "char", "password", "part", "type", "source", "cache", "seed", "value", "KEY", "connection", "str", "data", "text", "Key", "export", "empty", "msg", "name", "word", "ring", "prefix", "k", "secret", "pair", "wire", "sign", "block", "crypt", "cert", "phrase", "hash", "code"], "MD5": ["md6", "MT55", "AMD2", "MET2", "AMD5", "MET5", "SHA6", "SHA5", "DER2", "MET11", " MDse", "md5", "SHA3", "MD85", "MT5", "md4", "md55", "AMD4", "MET85", "mdse", "MD11", "SHA4", "MT4", "md2", "MD6", " MD3", " MD6", " MD4", "DER11", "Dse", "D1", " MD1", "D5", "md85", "MD3", "MDse", "MD2", "DER85", "md3", "MT6", "DER5", "MD4", "MD55", " MD55", " MD2", "MD1", "md11", "D4", "md1"], "resultBytes": [" resultBitcoin", "keyBytes", "responseBytes", "Resultbytes", "keybytes", " resultByte", "ResultBytes", "resultByte", "responsebytes", " resultbytes", "ResultByte", "responseBitcoin", "keyByte", "resultbytes", "resultBitcoin", "ResultBitcoin"]}}
{"id1": "14473711", "id2": "16820041", "code1": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "code2": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "label": 1, "substitutes": {"str2md5": ["str_md3", "str2h512", "str2dig512", "str_MDse", "str_MD512", "str2MD512", "str2MD3", "str_MD3", "str2digse", "str2dig5", "str2h5", "str2MD5", "str2dig3", "str2hse", "str2md3", "str2md512", "str2MDse", "str_md5", "str_mdse", "str_MD5", "str2h3", "str2mdse", "str_md512"], "str": ["string", "buffer", "input", "i", "spec", "enc", "inner", "hex", "result", "s", "fr", "dr", "pass", "in", "char", "txt", "arr", "er", "Str", "source", "strings", "r", "STR", "data", "text", "empty", "p", "format", "msg", "test", "name", "dict", "t", "exp", "cr", "tr", "bytes", "url", "obj", "err", "sp", "kr", "st", "br", "f", "sr", "code"], "alga": ["ALsa", "ALqa", "ALja", "elda", " alsa", "Alsa", "alsca", "ela", "alsda", "alja", " ala", " alda", "alda", "ALda", "elga", "alqa", "algas", "alca", " algas", "alsga", " alja", "ALa", "ALca", "alsqa", "Alga", "Alja", "elgas", "alsa", "Algas", "ala", "ALgas", " alqa", "ALga", " alca"], "digesta": ["codza", "igesta", "badera", "digza", "igera", "finsta", "codera", "codosta", "igza", "diffeste", "badza", "badesta", "codesta", "codsta", "diffosta", "badosta", "digsta", "digosta", "codeste", "diffesta", "fineste", "finosta", "finesta", "digera", "digeste", "igosta", "diffsta"]}}
{"id1": "18370075", "id2": "1097147", "code1": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"createPasswordDigest": ["createPassworddigest", "createPassworddigenge", "createpasswordDigest", "createPasswordSignest", "createPasswordModest", "createpassworddigester", "createPasswordSignenge", "createpasswordDigester", "createPassworddigester", "createPasswordDigifier", "createpassworddigifier", "createpassworddigest", "createPassworddigifier", "createPasswordSignifier", "createPasswordDigester", "createPasswordDigenge", "createpassworddigenge", "createPasswordModester", "createPasswordModifier", "createPasswordSignester", "createpasswordDigenge", "createpasswordDigifier", "createPasswordModenge"], "password": ["path", "string", "address", "token", "username", "user", "message", "filename", "account", "wd", "pass", "database", "key", "pattern", "security", "Password", "email", "source", "PASS", "seed", "login", "sword", "data", "text", "config", "Pass", "p", "name", "word", "wallet", "auth", "secret", "command", "padding", "words", "pad", "crypt", "phrase", "hash"], "salt": ["psecret", "pALT", "ssALT", "sesalt", "ssecret", "Ssecret", "pass", "ssass", "sesass", "Salt", "sass", "sessecret", "sesALT", "sALT", "SALT", "sssecret", " sALT", "Sass", "palt", " sass", " ssecret", "ssalt"], "md": ["zip", "bf", "gd", "mag", "bd", "od", "clean", "amd", "mail", "message", "mo", "ind", "kg", "ma", "meta", "MD", " MD", "ms", "ld", "ad", "mb", "mt", "d", "mac", "sha", "pm", "cmd", "mm", "nd", "metadata", "cd", "po", "m", "dm", "mand", "mc", "di", "nm", "mn", "mod", "me", "ph", "mad", "pd", "dd", "code"], "digest": [" digress", "dEST", "Digester", "signester", "DigEST", "dested", "digcode", "signest", "dest", "generester", " digested", "decest", "hashcode", "generests", "hashest", "hashested", "signested", "digester", "signcode", "digests", "digested", "hashester", "dester", "Digest", "digress", "decester", "decests", "generress", " digEST", " digester", " digests", "Digested", "generest", "decress", "digEST", " digcode"]}}
{"id1": "149935", "id2": "9347451", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"convert": ["CONverting", "subverting", "Conversion", "oconversion", "oconverting", "Converting", "CONversion", "unversion", "CONvert", "conversion", "CONception", "oconverted", " deconverted", "converting", "CONverted", "subvert", "oconvert", "Conception", "unvert", "converted", " deconverting", "subversion", "Converted", "unception", "unverted", "subverted", " deconversion", "conception", "Convert", " deconvert"], "src": ["impl", "string", "path", "sel", "ssl", "sin", "input", "sc", "uri", "resource", "sys", "spec", "rc", "Source", "video", "cmp", "username", "filename", "ref", "slice", "cb", "fp", "fn", "s", "prot", "code", "inst", "feat", "cpp", "req", "gb", "back", "source", "reader", "load", "proc", "sb", "rb", "sit", "buf", "component", "dist", "upload", "SourceFile", "config", "file", "tmp", "Dest", "supp", "attr", "img", "href", "storage", "name", "sth", "gz", "RC", "rl", "ctx", "secure", "url", "scene", "stream", "obj", "st", "stage", "sn", "ource", "download", "loc"], "dest": ["path", "class", "temp", " dst", "cont", "fn", "bin", "dc", "std", "txt", "source", "dir", "lib", "target", "dist", "tmp", "Dest", "null", "test", "home", "di", "obj", " destination", "dat", "disk", "orig", "img"], "in": ["IN", "val", "pin", "i", "input", "ex", "n", "inas", "ini", "as", "ins", "bin", "pass", "is", "reader", "d", "source", "doc", "up", "login", "r", "inc", "data", "file", "io", "t", "isin", "In", "a", "stream", "err", "inn", "ps", "f", "inf", "win", "din"], "p": ["P", "i", "pi", "op", "wp", "pre", "lp", "per", "py", "c", "j", "fp", "o", "l", "s", "pb", "cop", "part", "cp", "d", "pr", "pp", "pm", "r", "g", "parser", "h", "np", "po", "tp", "m", "e", "t", "pc", "jp", "pa", "bp", "pe", "b", "sp", "v", "ps", "f", "pd", "pg"], "ds": ["services", "uds", "ays", "docs", "ants", "dos", "s", "ins", "dp", " DS", "parts", "points", "gs", "els", " props", "des", "ts", "js", "utils", "ths", "ys", "gd", "sys", "df", "lp", "bs", "dc", " ps", "dt", "sync", "lines", "eps", "vs", "ges", "amps", "ipes", "pd", "dd", "sts", "DS", "cons", "ks", "ns", "qs", "ld", "hs", "d", "dist", "ans", "ads", "xs", "models", "plugins", "groups", "tests", "ss", "di", "os", "posts", "styles", "rs", "dl", "tools", "ded", "ups", "data", "vals", "scripts", "Ds", "ls", "obs", "dm", "db", "ils", "nas", "dates", "da", "cs", "words", "dds", "ps", "dat", "icks", " sd"], "format": ["letter", "string", "path", "class", "handler", "spec", "filename", "act", "version", "table", "fp", "fn", "host", "tag", "record", "layout", "feat", "magic", "Format", "pattern", "form", "filter", "at", "type", "source", "part", "model", "parser", "config", "data", "file", "sche", "struct", "ant", "language", "style", "plugin", "template", "name", "frame", "t", "function", "prefix", "fd", "nat", "url", "unit", "atter", "f", "scale", "api"], "hasPixelData": ["hasPixeldata", "showsPixelDATA", "hasPixelDATA", "hasPicturedata", "hasByteSize", "hasByteDATA", "hasByteData", "haspixelData", "hasPixelStyle", " hasPixelSize", "showsByteDATA", "hasPictureSize", " hasPixeldata", "haspixeldata", "showsBytedata", "hasPictureData", "haspixelSize", "showsByteData", "showsPixelData", "showsByteStyle", "hasPixelSize", "hasByteStyle", "showsPixelStyle", "hasBytedata", "showsPixeldata"], "inflate": ["inadequating", "insflode", "insvenating", "inffated", "Inflation", "InFlation", "inflating", "Inflated", "inflATE", "InFlace", "insvenate", "inadequode", "InFlated", "insflate", "infolATE", "infface", "invenode", "InFlate", "inffation", "inflated", "inFlation", "infolode", "infloace", "insvenATE", "infloate", "invenATE", "inFlate", "inadequATE", "insflATE", "infloation", "invenating", "inffate", "insvenode", "inadequate", "Inflace", "inflation", "inflode", "inFlated", "Inflate", "infolate", "inFlace", "infloated", "invenate", "infolating", "inflace", "insflating"], "pxlen": ["pxdata", "xpsize", "pxlin", "pngcount", "mxsize", "campos", "fxlen", "pxl", "pgLen", "axlen", "ppLen", "mxcount", "fxln", "pxlon", "pxln", "pcln", "pglen", "ppl", "pxlength", "ppden", "camln", "txln", "pngsize", "pxpos", "pclon", "camlen", "mxdata", "axln", "axlon", "mxlength", "mxpos", "mxlen", "xplen", "txlin", "pxden", "pxcount", "fxpos", "txlon", "pclin", "pxsize", "fxdata", "pxLen", "mxln", "xpcount", "pgl", "fxLen", "axlin", "pnglen", "xplength", "fxl", "pgden", "fxden", "pclen", "pnglength", "txlen", "pplen", "camdata"], "out": ["step", "server", "output", "copy", "sys", "user", "lock", "OUT", "inter", "outs", "line", "co", "query", "post", "session", "cache", "lib", "up", "group", "store", "parent", "work", "page", "log", "gen", "conn", "again", "Out", "io", "dump", "obj", "v", "err", "state", "pad", "cli", "error", "re", "list", "point"]}}
{"id1": "17111859", "id2": "13565787", "code1": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "code2": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "label": 1, "substitutes": {"getHash": ["GetHash", "GetSalt", " getHTML", "Gethash", "buildhash", "buildHash", "gethash", "buildHTML", "buildSalt", " getSalt", "GetHTML", " gethash", "getSalt", "getHTML"], "string": ["address", "buffer", "input", "duration", "uri", "resource", "server", "message", "slice", "sequence", "filename", "version", "number", "s", "time", "in", "database", "content", "password", "source", "cache", "strings", "value", "section", "STR", "data", "file", "text", "object", "p", "null", "format", "name", "array", "ring", "word", "prefix", "reference", "this", "hash"], "hashTime": ["hexTimer", "versionTimer", "hexTrack", " hashTrack", "HashFunction", "hashtime", "HashTrack", "HashTimer", "hashTrack", "Hashtime", "hexCheck", " hashTimer", "hashCheck", "HashTime", "HashCheck", "hashFunction", " hashCheck", "hexTime", "versionTime", "versiontime", " hashtime", "versionFunction", "hashTimer", " hashFunction"], "md5": ["digse", "md6", "madse", "md25", "mdb", " mddown", "maddown", "hash5", "madkey", "mandql", "mand2", "mad512", "mad2", "hash53", "digdown", "MDol", "mdql", "mad5", " md25", "dig6", "hashol", "mad3", " mdkey", "dig512", " mdol", "digb", "mdse", "mand25", " mdql", " md3", " md53", "digql", "MDkey", "dig5", "md2", "sha2", "md53", "sha6", " md6", "MD5", "shab", "dig2", "dig25", "MD3", "hash2", "MD2", "mdol", "mdkey", " md2", "mand5", "md3", "md512", "sha5", " md512", "MD53", "mddown", " mdb", " mdse"], "result": ["buffer", "uri", "response", "entry", "results", "res", "message", "json", "character", "current", "number", "hex", "match", "length", "digit", "part", "source", "expected", "value", "diff", "r", "default", "feature", "work", "section", "data", "page", "search", "product", "format", "test", "dict", "hash", "card", "array", "function", "success", "word", "prefix", "comment", "err", "range", "Result", "found", "error", "list", "valid"], "hexString": ["packArray", "rawBuffer", "hexBuffer", "packstring", "hexArray", "rawstring", "hexstring", " hexStr", " hexBuffer", " hexArray", "packStr", "packString", "rexString", "exString", "tempString", "rawArray", "hexStr", "hashString", "rexArray", "exBuffer", "tempArray", "exArray", " hexstring", "hashArray", "hashstring", "rexStr", "rexstring", "exstring", "tempstring", "rawString", "tempBuffer", "hashBuffer"], "i": ["index", "id", "uri", "pi", "slice", "c", "j", "fi", "ri", "o", "end", "l", "s", "length", "si", "ui", "ii", "in", "qi", "ti", "d", "phi", "data", "li", "h", "x", "p", "ip", "bi", "u", "oi", "start", "ai", "e", "I", "ci", "m", "io", "zi", "xi", "di", "gi", "a", "k", "b", "v", "abi", "multi", "f", "code", "ix"], "str": ["val", "buffer", "input", "id", "output", "uri", "enc", "entry", "res", "c", "s", "fr", "pass", "char", "key", "Str", "source", "pr", "r", "STR", "data", "text", "out", "x", "p", "name", "e", "t", "sl", "tr", "url", "err", "sp", "br", "obj", "st", "f", "sr", "code"]}}
{"id1": "16048516", "id2": "160705", "code1": "    public static SVNConfiguracion load(URL urlConfiguracion) {\n        SVNConfiguracion configuracion = null;\n        try {\n            XMLDecoder xenc = new XMLDecoder(urlConfiguracion.openStream());\n            configuracion = (SVNConfiguracion) xenc.readObject();\n            configuracion.setFicheroConfiguracion(urlConfiguracion);\n            xenc.close();\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        }\n        return configuracion;\n    }\n", "code2": "    public static boolean downloadFile(String url, String destination) throws Exception {\n        BufferedInputStream bi = null;\n        BufferedOutputStream bo = null;\n        File destfile;\n        byte BUFFER[] = new byte[100];\n        java.net.URL fileurl;\n        URLConnection conn;\n        fileurl = new java.net.URL(url);\n        conn = fileurl.openConnection();\n        long fullsize = conn.getContentLength();\n        long onepercent = fullsize / 100;\n        MessageFrame.setTotalDownloadSize(fullsize);\n        bi = new BufferedInputStream(conn.getInputStream());\n        destfile = new File(destination);\n        if (!destfile.createNewFile()) {\n            destfile.delete();\n            destfile.createNewFile();\n        }\n        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n        int read = 0;\n        int sum = 0;\n        long i = 0;\n        while ((read = bi.read(BUFFER)) != -1) {\n            bo.write(BUFFER, 0, read);\n            sum += read;\n            i += read;\n            if (i > onepercent) {\n                i = 0;\n                MessageFrame.setDownloadProgress(sum);\n            }\n        }\n        bi.close();\n        bo.close();\n        MessageFrame.setDownloadProgress(fullsize);\n        return true;\n    }\n", "label": 0, "substitutes": {"load": ["Load", "loader", "add", "loaded", "set", "save", "read", "content", "loads", "show", "upload", "open", "build", "LOAD", "oad", "check", "get", "init", "start", "dump", "update", "create", "parse", "process", "transform", "download", "install"], "urlConfiguracion": ["urlConfigutabet", "urlConfigureaton", "urlConfigurator", "urlConfigURation", "urlconfigurator", "urlConfiguraci", "urlConfigurerabet", "urlconfiguracion", "urlConfigureabet", "urlConfigurerator", "urlConfiguraton", "urlConfigaurator", "urlConfureacion", "urlConfigURaci", "urlConfuracion", "urlConfigurateacion", "urlConfigureation", "urlConfigureado", "urlConfuraci", "urlConfigurateator", "urlConfuration", "urlConfureator", "urlConfureation", "urlConfigauracion", "urlconfiguraton", "urlConfigURator", "urlConfurator", "urlConfigauraton", "urlConfigauraci", "urlconfiguraci", "urlConfigurateaci", "urlConfigurerado", "urlConfigurado", "urlconfigaurator", "urlConfigURaton", "urlConfigutado", "urlConfigurabet", "urlConfigureaci", "urlConfigURacion", "urlConfigurateation", "urlConfiguration", "urlConfigutator", "urlConfigureator", "urlConfureaci", "urlConfigureacion", "urlconfigauracion", "urlConfigureracion", "urlConfigutacion", "urlconfigauraci", "urlconfigauraton"], "configuracion": ["calureaton", "Configureant", "configoration", "Configuraton", "Configureaci", "configureaton", "configurateur", "configuralaton", "configuralation", "configuralant", "Configuration", "configuraacion", "configureant", "configaurab", "configutaton", "configuration", "configoraton", "Configuracion", "configuralator", "configurant", "configureateur", "Configureab", "caluration", "caluraton", "configuraab", "configuralaci", "calureation", "caluracion", "configureation", "Configureator", "Configurant", "calureacion", "Configurateur", "configuraator", "Configuraci", "Configureation", "configoraci", "configurab", "configutaci", "configaurateur", "configutacion", "configureaci", "configauraton", "configauracion", "configuralacion", "configuraton", "calureaci", "Configurator", "Configureaton", "Configureacion", "configuraci", "configurator", "configauration", "Configurab", "configoracion", "Configureateur", "configureacion", "caluraci", "configuraateur", "configauraci", "configureator", "configutant", "configureab", "configaurator"], "xenc": ["xens", "xenv", "Xenc", "xEnc", "xstream", " xstream", "xec", "ixec", "exsen", " xens", "fxEnc", " xEnc", "Xens", "exstream", "Xenz", "xmlenc", "fxenz", "xsen", " xenv", "fxenc", "ixsen", "exec", " xenz", "xenz", "xmlEnc", "Xenv", " xsen", "fxens", "XEnc", "ixstream", "ixenc", "exenc", "xmlenv", "xmlens", " xec"]}}
{"id1": "16931472", "id2": "9550506", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"handler": [" handling", " notify", " fn", " on", " next", " response", " done", " success", "Handler", " transfer", " init", " f", " fire", " callback", " dispatch", " redirect", " serve", " complete", " processing", " rewrite", " setup", " load", "process", "handle", "callback", " handle", " finish"], "result": ["event", "order", "buffer", "resource", "response", "output", "results", "report", "res", "map", "message", "document", "table", "json", "match", "record", "manager", "session", "source", "cache", "group", "feature", "data", "page", "row", "complete", "dict", "status", "array", "Result", "re", "list", "view"], "target": ["event", "goal", "base", "class", "tail", "server", "output", "resource", "response", "token", "master", "http", "site", "version", "current", "project", "Target", "html", "location", "host", "layout", "manager", "task", "owner", "database", "that", "content", "next", "client", "type", "source", "session", " Target", "proxy", "connection", "the", "arget", "config", "data", "parent", "route", "page", "object", "request", "environment", "style", "about", "template", "favorite", "image", "it", "link", "theme", "unit", "reference", "external", "this", "download"], "url": ["string", "path", "base", "buffer", "loader", "address", "ssl", "server", "resource", "uri", "feed", "user", "http", "socket", "l", "URL", "source", "connection", "browser", "str", "org", "build", "file", "channel", "page", "io", "blog", "sl", "Url", "stream", "service", "view"], "reader": ["ry", "loader", "buffer", "input", "i", "feed", "editor", "server", "reading", "rc", "builder", "report", "http", "ri", "driver", "read", "in", "iter", "ler", "er", "bird", "ner", "parser", "file", "iterator", "row", "rr", "rer", "e", "io", "writer", "rx", "worker", "layer", "stream", "over", "err", "f", "Reader"], "line": ["zip", "base", "rule", "file", "row", "style", "frame", "sl", "comment", "Line", "point", "string", "info", "buffer", "id", "lock", "site", "LINE", "end", "sync", "source", "lines", "lc", "live", "str", "liner", "cl", "page", "le", "nl", "plugin", "name", "header", "e", "link", "rl", "strip", "lin", "lf", "response", "message", "limit", "o", "look", "el", "iter", "email", "no", "body", "inline", "side", "or", "lined", "error", "view", "cell", "non", "lo", "user", "profile", "l", "ine", "key", "data", "text", "li", "log", "status", "home", "pe", "parse", "err", "range", "block", "definition", "code"], "entry": ["string", "ry", "her", "editor", "resource", "uri", "feed", "rc", "builder", "ie", "per", "ge", "inner", "se", "match", "owner", "extra", "Entry", "key", "exit", "ent", "part", "source", "member", "ener", "value", "ner", "connection", "counter", "section", "data", "archive", "entity", "page", "row", "or", "e", "writer", "link", "layer", "element", "service", "term", "enter", "cell"], "fromIndex": ["toPoint", "fromPosition", "FromPoint", "sourcePosition", "FromSection", " fromLength", " fromPoint", " fromPosition", "sourceSection", "FromOffset", "FromPosition", "fromOffset", "toPosition", "fromPoint", "FromIndex", "FromLength", "startOffset", "startPosition", "toOffset", "startLength", "fromLength", " fromSection", "startIndex", "fromSection", "sourcePoint", "sourceIndex", "toIndex", " fromOffset"], "r": ["R", "nr", "rc", "res", "vr", "c", "ru", "ri", "rg", "lr", "l", "fr", "mr", "rs", "er", "rb", "d", "pr", "q", "ner", "w", "attr", "p", "u", "rr", "m", "e", "cr", "array", "rl", "v", "b", "range", "f", "ar", "sr", "re"]}}
{"id1": "9267602", "id2": "11082670", "code1": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException {\n        StringBuilder json = new StringBuilder();\n        String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n        try {\n            URL url = new URL(requestUrl.toString());\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                json.append(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            throw new GtugsException(e);\n        }\n        List<Event> events = new ArrayList<Event>();\n        JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString());\n        JSONArray results = (JSONArray) jsonObj.get(\"results\");\n        for (int i = 0; i < results.size(); i++) {\n            JSONObject result = (JSONObject) results.get(i);\n            Event e = new Event();\n            e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\")));\n            e.setCity((String) result.get(\"venue_city\"));\n            e.setDescription((String) result.get(\"description\"));\n            e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\")));\n            e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\")));\n            e.setName((String) result.get(\"name\"));\n            Date myDate = null;\n            String time = (String) result.get(\"time\");\n            try {\n                myDate = meetupDateFormat.parse(time);\n                e.setStartTime(timeDateFormat.format(myDate));\n                e.setEndTime(timeDateFormat.format(myDate));\n                e.setStartDate(myDate);\n                e.setEndDate(myDate);\n                String tz = tzDateFormat.format(myDate);\n                if (tz != null && tz.startsWith(\"+\")) {\n                    tz = tz.substring(1);\n                }\n                e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100));\n            } catch (ParseException ex) {\n                ex.printStackTrace();\n                continue;\n            }\n            e.setState((String) result.get(\"venue_state\"));\n            StringBuilder addressBuilder = new StringBuilder();\n            if (result.get(\"venue_address1\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address1\") + \" \");\n            }\n            if (result.get(\"venue_address2\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address2\") + \" \");\n            }\n            if (result.get(\"venue_address3\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address3\") + \" \");\n            }\n            if (result.get(\"venue_address4\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address4\"));\n            }\n            e.setStreetAddress(addressBuilder.toString().trim());\n            e.setZipCode((String) result.get(\"venue_zip\"));\n            e.setUrl((String) result.get(\"event_url\"));\n            events.add(e);\n        }\n        return events;\n    }\n", "label": 1, "substitutes": {"urltext": ["feedbr", "urlfeed", "URLtext", "urlTEXT", "filename", "URLTEXT", "lltext", "urlname", "feedtext", "feedfeed", "llTEXT", " urlname", "feedname", " urlfeed", "llobject", " urlobject", "filebr", "URLobject", " urlTEXT", "urlobject", " urlbr", "filetext", "filefeed", "urlbr"], "url": ["zip", "string", "base", "buffer", "address", "i", "ssl", "id", "uri", "resource", "server", "feed", "user", "http", "ref", "socket", "l", "URL", "queue", "source", "lib", "jar", "connection", "r", "open", "data", "file", "out", "web", "bel", "page", "log", "name", "ball", "image", "blog", "db", "sl", "Url", "b", "f", "plug", "this", "service"], "in": ["IN", "ssl", "buffer", "i", "input", "id", "loader", "ini", "gin", "into", "inner", "as", "l", "s", "ins", "line", "bin", "read", "is", "client", "cms", "reader", "source", "login", "min", "inside", "r", "inc", "data", "file", "out", "init", "isin", "In", "nin", "kin", "stream", "lin", "b", "err", "inn", "f", "din"], "inputLine": ["outputByte", "outputL", "execStream", " inputData", " inputBlock", "outputData", "outputline", "outputBlock", "InputString", "InputLine", "rawLine", "InputByte", "Inputline", "inputBlock", "rawL", "InputBlock", " inputStream", "inputL", "inputByte", "outputStream", "inputStream", " inputline", "InputL", "execLine", "execData", " inputByte", " inputString", "outputLine", "inputline", "execline", "rawString", " inputL", "inputData", "inputString", "rawline"]}}
{"id1": "18005010", "id2": "1156851", "code1": "    private void setProfile(String loginName, SimpleUserProfile profile) throws MM4UCannotStoreUserProfileException {\n        try {\n            OutputStream outStream = null;\n            URL url = new URL(this.profileURI + profile.getID() + FILE_SUFFIX);\n            if (url.getProtocol().equals(\"file\")) {\n                File file = new File(url.getFile());\n                outStream = new FileOutputStream(file);\n            } else {\n                URLConnection connection = url.openConnection();\n                connection.setDoOutput(true);\n                outStream = connection.getOutputStream();\n            }\n            OutputStreamWriter writer = new OutputStreamWriter(outStream);\n            Enumeration myEnum = profile.keys();\n            while (myEnum.hasMoreElements()) {\n                String key = myEnum.nextElement().toString();\n                if (key != \"id\") writer.write(key + \"=\" + profile.getStringValue(key) + System.getProperty(\"line.separator\"));\n            }\n            writer.flush();\n            writer.close();\n        } catch (Exception e) {\n            throw new MM4UCannotStoreUserProfileException(this, \"setProfile\", e.toString());\n        }\n    }\n", "code2": "    public void runWeb(String beginURL, String contextRoot, String pageURI) {\n        if (bDebug) System.out.println(\"WEB Path\");\n        List<String> vtURLs = new ArrayList<String>();\n        List<String> vtRobots = getRobots(beginURL, contextRoot);\n        vtURLs.add(\"/\" + contextRoot + \"/\" + pageURI);\n        Indexer indexer = null;\n        IndexDocument indexDoc = null;\n        try {\n            indexer = new Indexer(\"/tmp/tmp/index\");\n            for (String sxURL : vtURLs) {\n                if (bDebug) System.out.println(\"\\n\\n*** INDEXING \" + sxURL);\n                if (bDebug) System.out.println(\"Have - \" + sxURL);\n                boolean bIndexPage = true;\n                if (vtRobots != null) {\n                    for (String sxRobotURL : vtRobots) {\n                        if (bDebug) System.out.println(\"Comparing to - \" + sxRobotURL);\n                        if (sxURL.startsWith(sxRobotURL)) {\n                            if (bDebug) System.out.println(\"Found URL - \" + sxRobotURL + \" - \" + sxURL);\n                            bIndexPage = false;\n                            break;\n                        }\n                    }\n                } else {\n                    bIndexPage = true;\n                }\n                sxURL = beginURL + sxURL;\n                ParserDelegator pd = new ParserDelegator();\n                CallbackHandler cb = new CallbackHandler(vtURLs, bIndexPage, contextRoot);\n                try {\n                    URLConnection urlConn = new URL(sxURL).openConnection();\n                    urlConn.setUseCaches(false);\n                    Date modDate = new Date(urlConn.getLastModified());\n                    if (bDebug) System.out.println(\"\\nMatch - \" + sxURL + \" - Modified Date - \" + modDate);\n                    BufferedReader bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n                    pd.parse(bfReader, cb, true);\n                    if (bIndexPage) {\n                        if (bDebug) System.out.println(\"Adding Index - \" + sxURL + \"\\nContent:\" + cb.getText() + \"\\nSummary:\" + cb.getSummary() + \"\\nTitle:\" + cb.getTitle());\n                        indexDoc = new IndexDocument();\n                        indexDoc.setUID(sxURL + modDate.toString());\n                        indexDoc.setPageURL(sxURL);\n                        indexDoc.setModifiedDate(modDate.toString());\n                        indexDoc.setContents(cb.getText());\n                        indexDoc.setTitle(cb.getTitle());\n                        indexDoc.setSummary(cb.getSummary());\n                        indexer.addDocument(indexDoc);\n                    }\n                } catch (Exception ee) {\n                    PetstoreUtil.getLogger().log(Level.SEVERE, \"Inner Exception\" + ee);\n                }\n            }\n        } catch (Exception e) {\n            PetstoreUtil.getLogger().log(Level.SEVERE, \"Outer Exception\" + e);\n        } finally {\n            try {\n                if (indexer != null) {\n                    indexer.close();\n                }\n            } catch (Exception ee) {\n                ee.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"setProfile": ["updateProfile", "setAccount", "SetProfile", "Setprofile", "updateAccount", " setAccount", " setprofile", "updateprofile", " setRole", "updateRole", "SetRole", "setRole", "setprofile", "SetAccount"], "loginName": [" profilePath", " friendlyName", " screenUrl", " profileUrl", "displayUrl", " friendlyPath", " screenName", " profileID", "displayID", " profileName", "displayName", " screenPath", " screenID", " friendlyUrl", "displayPath", " friendlyID"], "profile": ["path", "base", "buffer", "job", "resource", "username", "user", "settings", "report", "option", "site", "character", "project", "result", "account", "line", "prof", "queue", "picture", "password", "type", "proxy", "FILE", "application", "feature", "config", "data", "phone", "page", "object", "environment", "p", "style", "plugin", "Profile", "name", "header", "image", "family", "person", "role", "phy", "position", "photo", "pe", "summary", "shadow", "history", "network", "office", "display", "property"], "outStream": ["inSteam", "OutStream", "inStream", "intSteam", "inFile", "intstream", "outstream", "outFile", "outputSteam", "OutWriter", " outFile", " outstream", "intStream", "outputPath", " outWriter", "outSteam", "outputstream", " outSteam", "outPath", "outputStream", " outPath", "inWriter", "intFile", "Outstream", "OutPath", "OutFile", "instream", "outputFile", "outWriter", "OutSteam"], "url": ["impl", "zip", "string", "path", "base", "ssl", "address", "buffer", "server", "uri", "resource", "feed", "id", "entry", "http", "socket", "l", "location", "host", "URL", "large", "client", "email", "source", "proxy", "browser", "org", "open", "data", "out", "channel", "web", "page", "log", "conn", "or", "coll", "e", "image", "function", "link", "sl", "pull", "Url", "position", "www", "stream", "b", "download", "f", "hub", "plug", "this", "service", "api", "loc"], "file": ["zip", "path", "base", "class", "fe", "output", "resource", "feed", "http", "plain", "filename", "per", "place", "fp", "l", "line", "File", "content", "part", "use", "binary", "lib", "FILE", "data", "out", "channel", "body", "entity", "page", "le", "get", "log", "name", "folder", "io", "image", "function", "full", "files", "pe", "stream", "unit", "b", "f", "loc"], "connection": ["directory", "Connection", "handler", "server", "resource", "response", "character", "con", "c", "socket", "connected", "driver", "relation", "co", "password", "union", "client", "part", "session", "cache", "proxy", "which", "application", "open", "config", "conv", "out", "channel", "section", "director", "object", "control", "conn", "creator", "io", "to", "function", "ctx", "position", "bc", "stream", "connect", "communication", "loc"], "writer": ["string", "event", "writing", "handler", "buffer", "loader", "editor", "outer", "output", "ee", "server", "element", "builder", "master", "entry", "per", "inner", "writers", "socket", "walker", "driver", "later", "write", "er", "Writer", "reader", "w", "work", "data", "out", "widget", "e", "to", "function", "worker", "word", "runner", "riter", "wrapper", "wire", "xml", "writ", "office", "engine", "this"], "myEnum": ["myenque", "yourEnum", "myENque", "MyENumeric", "myRenation", "MyEnumeric", " myEnUM", "myEation", "myenum", " myEation", "MyENum", "myEnumeric", "yourEnumber", "MyEnum", "myEncumb", "myEnums", "myENums", "myEum", "myEnUM", "myEnumb", "myENum", " myEnumb", " myEUM", "myENumeric", "yourEncumber", "myRenum", "myLenums", "myEnation", "yourEncum", "myEnque", "myLenumer", " myEum", " myEnation", "myEncum", "yourEncumer", "myENumer", "myEumb", "myEnumer", " myEumb", "yourEnque", "yourEncque", "myEncumer", "myenumber", "myLenumeric", "myRenUM", "yourEnumer", "myEncque", "MyEnums", "MyENumer", "myEnumber", "myEUM", "MyENums", "myLenum", "myEncumber", "MyEnumer", "myEncUM", "myRenumb", "myEncation", "myenumer", "myENumber"], "key": ["val", "keys", "string", "info", "base", "ace", "id", "ex", "by", "entry", "lock", "ie", "act", "fix", "result", "any", "col", "child", "match", "co", "char", "weight", "form", "part", "type", "source", "rule", "member", "load", "item", "value", "KEY", "nice", "str", "feature", "section", "my", "ask", "Key", "ice", "check", "page", "ip", "row", "hop", "name", "box", "change", "exp", "link", "ver", "k", "pe", "me", "cookie", "sign", "step", "field", "element", "code", "point"]}}
{"id1": "9236363", "id2": "16825994", "code1": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"unJarStart": ["syncServerPath", "copyJarPath", "copyJarStart", "copyjarRest", "syncServerRest", "syncJarRest", "copyJarEnd", "copyServerRest", "copyjarEnd", "copyServerPath", "copyjarPath", "syncJarEnd", "copyJarRest", "copyZipRest", "syncJarStart", "copyjarStart", "copyServerEnd", "copyServerStart", "copyZipStart", "copyZipEnd", "syncServerEnd", "syncServerStart", "copyZipPath", "syncJarPath"], "jarPath": ["relEntry", "Jarpath", "jarLog", "jarText", "zipPath", "jamLog", "zippath", "archivePath", " jarpath", "javaPath", "jamPath", "javaCh", "jarName", " jarText", "JarName", "narCh", "jarContent", " jarContent", " jarUrl", "garText", "JarFile", "relFile", "archivepath", "javaFile", "badPath", "jarpath", "garUrl", "javaName", "badLog", "jarFile", "JarCh", "narPath", "javaText", " jarLog", "garPath", " jarFile", " jarDir", "javaEntry", "garFile", "javaUrl", "jarUrl", "jarCh", "archiveDir", "javapath", " jarName", "badpath", "javaLog", "badUrl", "archiveLog", "zipEntry", "zipFile", "jampath", "garpath", "narpath", "JarContent", "garContent", "jamDir", "relpath", "narName", "JarPath", "jarDir"], "jarEntryStart": ["jarEntSource", " jarEntryFollow", "jarEntPart", "jarEntryName", " jarImportStart", "tarEntryPart", "jarFileSource", " jarFileStart", "jarFileName", "jarImportPart", "jarEntryPart", "jarEntrySource", "jarEntStart", " jarFilePart", " jarEntrySource", "jarFileStart", " jarEntryEnd", "jarEntName", "jarFileFollow", " jarImportPart", "jarEntryFinish", "jarentryName", "jarFileEnd", "jarImportName", "jarentryStart", "tarentryName", "jarEntryFollow", "jarAttemptStart", "tarEntrySource", "jarEntryEnd", "jarImportStart", " jarFileEnd", "jarAttemptPart", "tarEntryStart", " jarFileFinish", "jarImportFollow", " jarImportEnd", "jarAttemptFollow", "jarentrySource", "jarFileFinish", " jarFileName", "jarImportFinish", " jarEntryFinish", "jarentryPart", "tarentryStart", "jarAttemptEnd", "jarFilePart", "tarentrySource", " jarImportFollow", "jarPartStart", "jarImportSource", "tarentryPart", "jarPartFinish", " jarFileSource", " jarEntryName", " jarEntryPart", "jarImportEnd", "jarPartEnd", "jarPartPart", "tarEntryName"], "path": ["zip", "then", "root", "base", "temp", "output", "resource", "patch", "host", "content", "default", "file", "archive", "context", "conn", "graph", "it", "mount", "url", "PATH", "ph", "step", "string", "id", "clean", "location", "next", "source", "cache", "dir", "ion", "ath", "work", "parent", "route", "object", "test", "name", "th", "left", "cookie", "boot", "directory", "uri", "json", "Path", "inner", "system", "mode", "dest", "wd", "session", "request", "p", "template", "image", "prop", "method", "error", "api", "pass", "key", "pattern", "type", "config", "data", "text", "log", "folder", "po", "home", "ha", "pointer", "prefix", "ctx", "ith", "right", "code", "loc"], "relPath": ["RelPath", "relativeDir", " relName", "RELPath", "RELpath", "Relpath", " relPos", " relDir", "RELPos", "relPos", "relativepath", "relDir", "RelName", "relativePath", "RelDir", "relativePos", "relName", "RELName", " relpath", "relpath", "relativeName"], "jar": ["zip", "ssl", "pkg", "her", " tar", "server", "mag", "drop", "fire", " manifest", "per", "ge", " parser", "java", "tar", " java", " capsule", "jo", " dir", "dr", "sheet", "zone", "keeper", "magic", "ler", "bag", " archive", "er", " war", "bar", "Jar", "cache", "tab", "dir", "browser", "sr", "open", "pipe", "war", "archive", " module", "rar", "log", "plugin", "ball", "folder", "start", "pack", "car", "sl", "spin", "url", "com", "ser", "parse", "sp", "cookie", "gap", "xml", "ar", "module", "space"], "entries": ["entryers", "countries", "ENTlements", "antlements", "countEntry", "addries", "entrys", "ientlements", "Entursions", "adders", "endories", "antursions", "entryensions", "entEntry", "quries", "entensions", "Entry", "entursions", "itrys", "iters", "counters", "Entrys", "Entries", "addensions", "quies", "endries", "antry", "endrys", "itries", "ENTies", "entlements", "countensions", "Entories", "enters", "qulements", "enties", "addEntry", "Entlements", "itories", "Entents", "ENTries", "entories", "Enters", "entryries", "ientry", "antries", "enders", "ENTents", "ientursions", "ientries", "entents", "entryEntry", "quents", "Enties"], "entry": ["zip", "ry", "address", "server", "resource", "be", "add", "ie", "ge", "se", "jo", "ries", "Entry", " Entry", "key", "ler", "la", "pie", "ent", "part", "reader", "ce", "module", "je", "r", "cat", "de", "or", "cel", "name", "e", "lie", "pack", "it", "parse", "mer", "obj", "oe", "element", "enter"], "jarEntry": ["jarentry", "jobentry", "carEnt", "serName", "jarName", "javaPath", "archiveEntry", "jarRule", "archiveElement", "archiveName", "archiveEnt", "celFile", "jobEntry", "jobPath", "javaFile", "serEntry", "javaElement", "javaName", "jarFile", " jarImport", " jarEnt", "javaEntry", "jobImport", "javaImport", "archiveRule", "javaentry", "jarEnt", "carEntry", "carPath", "serElement", " jarentry", "jarImport", "javaRule", "javaEnt", "serFile", "carElement", "celEntry", " jarElement", "celRule", "celEnt", "archiveFile", "jarElement"], "ze": ["zip", "fe", "zer", "ipe", "ke", "be", "zes", "zy", "ie", "kee", "ge", "z", "se", "aze", "jo", "ide", "te", "ine", " ace", "za", "ja", "ce", "je", "li", "ZE", "le", " je", "ne", "cel", "xe", "e", "zi", "sl", "pe", "zo", "zen", "code", "zie"], "bin": ["zip", "index", "info", "base", "sin", "pin", "bis", "resource", "lock", "ini", "inner", "abin", "arin", "zone", "in", "bar", "binary", "lib", "proxy", "login", "len", "bas", "data", "file", "body", "vin", "bb", "log", "bi", "bank", "init", "plugin", "bn", "bit", "isin", "kin", "gi", "di", "spin", "bot", "abi", "cin", "inn", "win", "boot"]}}
{"id1": "13563706", "id2": "16511008", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "label": 0, "substitutes": {"doGet": ["handlePut", "didGet", "didGET", "didPut", "didget", "doget", " doPut", "doGET", "handleGET", "doPut", "handleget", " doget", "handleGet", " doGET"], "request": ["event", "remote", "info", "string", "buffer", "input", "Request", "server", "resource", "user", "report", "message", "document", "current", "result", "instance", "query", "queue", "req", "client", "type", "connection", "model", "application", "config", "data", "object", "p", "complete", "QUEST", "image", "frame", "url", "Response", "create", "xml", "attribute", "method", "view"], "response": ["index", "reason", "server", "output", "resource", "feed", "report", "http", "res", "message", "results", "site", "document", "onse", "subject", "result", "json", "description", "location", "pool", "query", "client", "resp", "connection", "model", "application", "collection", "body", "object", "reply", "header", "status", "writer", "image", "re", "Response", "respond", " Response", "wa", "error", "service", "api", "view"], "selectedPage": ["lectedButton", "selectionpage", "selectedButton", " selectedAction", "namedpage", "lectedpage", "electedLine", "namedFile", "lectedSite", "selectionHour", "selectionLine", "selectionFile", " selectedItem", "selectionItem", "selectedLine", "selectedSite", "selectedpage", "lectedFile", "namedLine", "selectedFile", " selectedHour", " selectedFile", "electedPage", "selectionButton", "lectedPage", "namedPage", "lectedItem", " selectedButton", "selectionPage", "selectedAction", "electedpage", " selectedpage", "selectedHour", "selectionAction", "lectedAction", "lectedLine", " selectedSite", "lectedHour", "electedButton", "namedSite", " selectedLine", "selectedItem"], "page": ["handler", "resource", "document", "number", "rule", "model", "phone", "row", "url", "sp", "office", "module", "menu", "point", "address", "server", "site", "result", "account", "location", "html", "pl", "cache", "pp", "proxy", "connection", "section", "parent", "channel", "route", "ip", "plugin", " Page", "unit", "peer", "article", "node", "message", "per", "ge", "record", "queue", "Page", "ice", "p", "language", "change", "image", "position", "photo", "display", "pg", "view", "fe", "user", "profile", "project", "instance", "child", "pool", "layout", "client", "type", "item", "je", "po", "port", "me", "age", "block", "f"], "portalRequest": ["portialQuery", "portALUser", "portailResponse", "PortortalOrder", "PortortalEvent", "portpalAccess", "portailRequest", "portALResponse", "PortortalAccess", "portialRequest", "portalQuery", "portortalResponse", "portelRequest", " portialQuery", "PortortalUser", "portortalPage", "portortalUser", "portugalResponse", "portallingPage", "portalPage", "PortortalResponse", "portugalRequest", " portalQuery", "PortortalPage", "portortalOrder", "PortalEvent", " portialPage", "portugalOrder", "portalAccess", "portpalRequest", " portalResponse", " portialResponse", "PortalUser", "portALRequest", "portallServer", "portortalAccess", "portortalEvent", "PortalAccess", "portallUser", "portallingRequest", "portugalUser", "portialPage", "portbalQuery", "portortalServer", "portelCommand", "portelPage", "PortalPage", "PortalOrder", "PortortalServer", "portalUser", "PortalCommand", "portallRequest", "portpalResponse", "PortalServer", "portelResponse", "portailUser", "PortalResponse", "portallResponse", "portortalRequest", "portialResponse", "portpalPage", "portbalPage", "portallingAccess", " portalPage", "portailOrder", "portallingResponse", "portalServer", "PortortalRequest", " portialRequest", "portugalEvent", "portalResponse", "portugalServer", "portALEvent", "portbalResponse", "portelQuery", "PortortalCommand", "portalCommand", "portalOrder", "portallingCommand", "PortalRequest", "portalEvent", "portbalRequest", "portortalCommand"], "pageProp": ["PageProp", "agePro", "resourceProperty", "projectPro", "pageprop", "pluginPro", "Pageprop", "peerStr", "resourceProp", "ageProp", "pageObj", "pageProperty", " pageStr", "parentObj", "PageProperty", "PageStr", "pageStr", "pluginprop", "PagePro", "parentProperty", "PageObj", "peerProperty", " pageProperty", "ageProperty", "peerPro", "resourceprop", "projectprop", "pagePro", " pagePro", "projectProp", "projectProperty", "parentProp", "ageprop", "pluginProperty", " pageObj", "resourcePro", "peerProp", "parentPro", "pluginProp"], "possiblePage": ["possiblePages", "pablePages", "possiblepage", "puredPage", "possibilityLine", "Possibilitypage", "possiblyPages", "PossiblyGroup", "PossibilityLine", "possibleLine", "permanentLine", "possibleOrder", "PossiblyPage", "pablepage", "PossibleOrder", "possibleItem", "PossiblyItem", "Possiblepage", "puredpage", "PossibleGroup", "possiblyItem", "permanentpage", "puredItem", "PossiblyOrder", "PossibleItem", "patchingpage", "patchingItem", "possiblypage", "patchedOrder", "patchedpage", "PossiblyLine", "pableLine", "PossiblePage", "permanentPage", "PossibilityPage", "PossiblePages", "possibilityPage", "possibleGroup", "PossibleLine", "PossibilityPages", "patchingPage", "possiblyLine", "possiblyOrder", "patchingGroup", "Possiblypage", "permanentOrder", "possiblyGroup", "pablePage", "patchedLine", "possibilityPages", "puredGroup", "possiblyPage", "patchedPage", "possibilitypage"], "property": ["integer", "string", "address", "class", "uration", "duration", "resource", "perties", "character", "profile", "maximum", "table", "project", "result", "number", "set", "key", " Property", "expression", "Property", "type", "binary", "value", "feature", "section", "config", "data", "entity", "object", "p", "variable", "language", "name", "header", "notation", "t", "function", "operator", "label", "prefix", "layer", "prop", "future", "binding", "properties", "attribute", "f", "term"], "referer": ["rere", "redber", "reiner", "Referers", "refender", "Referer", "affere", "referen", " refre", " refber", "reerer", "diffender", "differer", "rederer", "Refre", "defere", "defber", "Refber", " refender", "afferer", "diffrer", "Refeline", "afferen", "Refrer", "rerer", "refiner", " referen", " refere", "refber", "Refiner", "redrer", "redeline", "refeline", "defender", " refeline", "Refender", "diffiner", "Referen", "refrer", "ferers", " referers", " refiner", "frer", " refrer", "ferer", "fere", "reere", "refre", "deferer", "referers", "affrer", "refere", "Refere", "defrer"], "e": ["event", "fe", "i", "ee", "ie", "message", "o", "se", "ception", "ele", "er", "type", "one", "d", "see", "ea", "de", "exc", "p", "es", "ae", "null", "or", "E", "a", "ed", "this", "me", "err", "f", "error", "eme", "element", "esi"]}}
{"id1": "23273706", "id2": "14038176", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"getProjectTreeData": ["getprojecttreeData", "getprojectTreeDATA", "getProjectPageMeta", "getprojecttreeMeta", "getProjecttreeMeta", "getProjecttreeData", "getprojectTreeMeta", "getProjectDocumentMeta", "getProjectTreeMeta", "getProjecttreeDATA", "getProjectPageData", "getProjectDocumentInfo", "getProjectTreeInfo", "getprojectTreeData", "getprojecttreeDATA", "getProjectPageDATA", "getProjectTreeDATA", "getProjectPageInfo", "getProjectDocumentDATA", "getprojectTreeInfo", "getProjectDocumentData", "getprojecttreeInfo", "getProjecttreeInfo"], "treeData": ["monkeyDec", "treeArray", " treeArray", "TreeList", "treeList", " treeString", "contentDat", "reeData", " treeList", "treeString", " treeInfo", "reeText", "contentData", "bodyList", " treeDec", "bodyDat", "reeDat", "storyArray", "storyData", "reeList", "reeArray", "contentInfo", "monkeyDat", "treeDec", "contentText", "bodyData", "treeDat", "TreeString", "reeString", "reeInfo", "bodyString", "monkeyData", "monkeyArray", "TreeInfo", "TreeArray", "treeText", "storyDat", "storyDec", "treeInfo", "TreeData", " treeDat", " treeText"], "filename": ["directory", "path", "string", "framework", "uri", "username", "dylib", "dll", "whatever", "kl", "fp", "fn", "location", "sheet", "database", "password", "txt", "Filename", "FILE", "upload", "SourceFile", "data", "file", "tmp", "metadata", "nil", "journal", "ppa", "title", "folder", "name", "kj", "fil", "ername", "prefix", "fd", "files", "url", "wav", "xml", "figure", "kn", "jpg"], "urlString": ["URLStr", "urlstring", " urlUrl", "addressString", "URLUrl", "locationStr", "urlURL", "locationString", "locationstring", " urlStr", "addressstring", " urlstring", "locationUrl", "URLString", "urlUrl", " urlURL", "addressStr", "URLURL", "URLstring", "urlStr", "addressURL"], "urldata": [" urldta", " urldATA", "urlddata", "urLDdata", "URldata", "URlfata", "urlledta", "urllat", "URlfdata", "URldat", "urlfata", " urLDta", "urldta", " urLDdata", " urLData", "urlldata", "urldATA", "urldat", "urlfdata", "URlfATA", " urlddata", "urLDATA", "urleddata", "urledATA", "urllata", "URlfat", "urLDta", "urLDat", "URldATA", "urlfATA", "URlddata", "urLData", "urllATA", " urLDATA", "urlleddata", "urlledata", "urledta", "urlfat", "urlledATA", "urledata"], "factory": ["pault", "filler", "ufiller", "lictionary", "confiller", " fictionary", "lactory", "cfFactory", "fFactory", "confactory", "ufuild", "cfactory", "liller", "conflier", "fault", " fFactory", "ufictionary", " flier", "cault", "fictionary", " filler", "confFactory", "pFactory", "luild", "cactory", "ufactory", "piller", " fuild", "cFactory", "flier", "ciller", " fault", "pactory", "cfiller", "fuild", "cflier"], "parser": ["string", "root", "handler", "loader", "arser", "uri", "builder", "http", "lp", "json", "library", "se", "instance", "l", "s", "monkey", "driver", "api", "manager", "pdf", "util", "er", "reader", "up", "r", "ger", "parent", "p", "plugin", "fruit", "writer", "t", "parse", "b", "ph", "raf", "xml", "Parser", "utils", "jack", "auto"], "u": ["U", "cu", "ou", "lu", "uri", "http", "uv", "c", "ru", "o", "l", "s", "ui", "su", "util", "universal", "uu", "uf", " ur", "d", "tu", "p", "uni", "eu", "hu", "io", "us", "url", "ur", "b", "yu", "ul", "iu", "nu", "plug"], "is": ["info", "bis", "iss", "lis", "serv", "fs", "IS", "uri", "isa", "pi", "http", "gets", "Is", "ie", "as", "ri", "api", "s", "abs", "ui", "in", "ori", "isl", "its", "ops", "ais", "ob", "ir", "ip", "p", "es", "has", "init", "or", "ai", "ris", "obs", "io", "it", "iris", "ios", "us", "ib", "are", "isu", "ar", "iso", "mis"], "os": ["bis", "oses", "sys", "fs", "Os", "fits", "http", "gets", "oa", "dos", "as", "OS", "o", "s", "bs", "oos", "ms", "so", "ros", "bos", "ops", "ob", "ens", "es", "oes", "ose", "or", "osi", "aos", "obs", "oss", "io", "pos", "ils", "ios", "us", "los", "ol", "ps", "opens", "iso", "cos"], "iBufSize": ["iLlfsize", "iBbufLength", "iBbufsize", "iBytebufLength", "iBbufSize", "iBufLength", "iLlfLength", "iLlfSize", "iBytebufSize", "iLufsize", "iByteufSize", "iBuffLen", "iBufferSt", "iBytebufLen", "iLufSt", "iBlfSt", "iBufLen", "iBlfLen", "iBuffsize", "iBuffSize", "iBbufLen", "iByteufsize", "iBlfSize", "iByteufLength", "iBlfLength", "iBlfsize", "iLlfSt", "iBuffSt", "iBufsize", "iLufSize", "iBuffersize", "iBufSt", "iBuffLength", "iByteufLen", "iLufLength", "iBufferSize", "iBufferLength", "iBytebufsize"], "inBuf": ["inBuffub", "outBuffump", "inBuff", " inCbuf", "inCaf", " inBaf", "inbump", "inbub", " inCunk", " inBbuf", "inDuff", "inCunk", "inBlub", "inCuff", "inFuff", " inBuff", " inCuf", "inBuffuf", "inDbuf", "inFuf", "inBbuf", "inBlump", " inFuff", "inDaf", "outBuffbuf", "inFaf", "inBump", "inFbuf", "outBbuf", " inFbuf", "inBuffump", " inCump", "inBaf", " inBunk", "inBub", " inBump", "inbuf", "inbbuf", "outBuffuf", "outBuf", "inPlunk", "inBunk", "inPluf", "inBluf", " inFuf", "inCuf", "outBub", "inPlbuf", "inDuf", "outBump", "inCump", " inFaf", "inBlbuf", "inPlump", "inCbuf", "outBuffub", "inBuffbuf", "inBlunk"], "iNumRead": ["iValread", "iNumberRead", "iChanRead", "iFatRead", "iChanread", "inumWrite", "qiNumread", "iChanBuild", "qiValread", " iFatWritten", "iChanREAD", " iFatWrite", "inumWritten", "iNumberBuild", "qiNumBuild", "pNumWritten", "iNumberWrite", "iFatWritten", "pNumWrite", "inumRead", "iNumberREAD", "qiValREAD", "iLenWritten", "iNumberWritten", "iLenWrite", "inumread", "iNumberread", "iNumBuild", "iNumREAD", "iLenRead", "qiNumRead", "pNumread", "iValBuild", "iNumWrite", "pNumRead", "iFatWrite", " iFatRead", " iNumWritten", "iValREAD", "pNumberRead", "qiNumREAD", "pNumberWritten", "iValRead", "iNumread", " iNumWrite", "iNumWritten", "qiValRead", "pNumberread", "qiValBuild", "pNumberWrite"], "f": ["handler", "fe", "sf", "n", "fs", "fa", "feed", "df", "rf", "c", "fc", "fi", "fp", "o", "l", "s", "fn", "j", "fr", "ff", "uf", "d", "r", "g", "file", "h", "p", "e", "m", "io", "t", "F", "full", "fd", "b", "v"], "inputstream": [" inputchannel", "inputsystem", "contentsystem", "Inputsw", "inputchannel", " inputsw", " inputsystem", "contentstream", "contentsw", " inputStream", "outputstream", "outputStream", "outputchannel", "inputStream", "Inputchannel", "Inputsystem", "Inputstream", "contentStream", "InputStream", "inputsw"], "document": ["directory", "info", "node", "output", "response", "n", "docs", "project", "DOM", "l", "window", "html", "record", " documents", " documentation", "content", "source", "doc", "d", "media", "collection", "parent", "data", "file", "director", "page", "object", "p", "language", "context", "null", "ocument", "tree", "m", "e", "t", "Documents", "container", "xml", "dom", "office", "Document", "list"], "nodelist": ["nODestyle", "nodedlist", "Nodelist", "nozelist", " nodesename", "nodedeme", "snodelist", "nodesh", "nozemark", "nonedels", " nodeselist", "NODelist", "Nodemark", "nozename", "nodedesh", "nODeline", " nodename", "nodels", "nondelist", "nodedata", "snodslist", "NODemark", "snodselist", "nondata", "nodeeme", "nodesette", "nodeme", "Nodesh", "snodette", "nodeline", "anodedata", "nodedestate", "nODesh", "nozette", "snodsette", " nodesette", "nozestyle", "snodseline", "nodsette", "nODemark", "nondeme", "nodestyle", "anodedeme", "nodesename", "nodeelist", "nodette", "snodlist", "anodelist", "nodeata", "nodata", "nODette", "anodedestate", "nodedestyle", "nozesh", "nodemark", "nodselist", "nodename", "nodeestate", "anodestate", "nodedette", "snodeline", "nodseline", "nODlist", "nodedelist", "anodata", "anodeme", "nondestate", "nODelist", "nodedeline", "nodlist", "nonedelist", "NODestyle", " nodesels", " nodels", "nonedette", "nonedename", "nodedemark", "nodeselist", "Nodestyle", "anodedelist", "nodslist", "nozels", "nodestate", " nodette", "NODesh", "nodesels"], "num": ["index", "mult", "total", "om", "node", "sum", "mu", "um", "n", "uri", "max", "temp", "nr", "net", "con", "number", "col", "en", "mon", "comb", "part", "nom", "len", "div", "inc", "lim", "nam", "np", "init", "dim", "uni", "tri", "m", "pos", "nb", "NUM", "Num", "umi", "unit", "span", "ul", "count", "dom", "multi", "nu", "zero", "norm", "loc"], "i": ["index", "info", "mu", "id", "uri", "pi", "ini", "yi", "ie", "slice", "c", "j", "fi", "ri", "o", "col", "l", "si", "ui", "ii", "in", "ori", "qi", "part", "ti", "ji", "d", "phi", "chi", "g", "li", "ip", "mi", "p", "x", "bi", "ai", "oi", "start", "ci", "I", "io", "m", "eni", "it", "xi", "di", "gi", "hi", "a", "isi", "v", "y", "b", "ik", "iu", "multi", "cli", "iv", "ix"]}}
{"id1": "21348951", "id2": "13499897", "code1": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 1, "substitutes": {"processAddByURLSubmit": ["processAddByURLSummitted", "processAddByURLSsubmitted", "processAddByURLSubmitted", "processAddByURLSsubmitter", "processAddByURLSUBmit", "processAddByURLSUBmission", "processAddByURlsUBmitted", "processAddByURLSUBmitted", "processAddByURlsUBmission", "processAddByURlsubmitted", "processAddByURLSummitter", "processAddByURlsubmitter", "processAddByURLSsubmission", "processAddByURLSummission", "processAddByURLSummit", "processAddByURLSubmission", "processAddByURlsubmit", "processAddByURLSubmitter", "processAddByURlsubmission", "processAddByURLSUBmitter", "processAddByURlsUBmitter", "processAddByURLSsubmit", "processAddByURlsUBmit"], "url": ["string", "path", "address", "base", "ssl", "buffer", "server", "uri", "feed", "resource", "user", "entry", "http", "ref", "l", "location", "host", "URL", "email", "source", "connection", "ug", "str", "ob", "data", "file", "src", "route", "page", "ll", "log", "ls", "e", "image", "io", "link", "sl", "secure", "Url", "www", "stream", "ur", "xml", "org", "loc"], "invalidUrlMsg": ["inbadUrlMsg", "inInvalidUrlMessage", "inbadFileMsg", "inbadUrlMessage", "invalidURLog", "invalidStringMessage", "invalidUrlStr", "invalidUrlMessage", "invalidFileStr", "invalidUrlmsg", "inInvalidUrlUrl", "invalidUrog", "invalidFileMessage", "inbadUrlmsg", "invalidFileUrl", "invalidURLMessage", "invalidTimeMsg", "invalidTimemsg", "inbadFileMessage", "inInvalidUrlmsg", "invalidFileog", "inInvalidURLUrl", "invalidUrlog", "invalidFileMsg", "inbadUrlog", "invalidTimeStr", "invalidTimeMessage", "inInvalidURLMsg", "inInvalidURLMessage", "invalidUrlUrl", "invalidURLUrl", "invalidStringUrl", "invalidFilemsg", "inInvalidUrlMsg", "invalidURLMsg", "inbadFilemsg", "invalidStringMsg", "invalidUrMessage", "inInvalidUrlStr", "inInvalidURLmsg", "invalidStringmsg", "inbadFileog", "invalidURLStr", "invalidURLmsg", "invalidUrmsg", "invalidUrMsg", "inInvalidURLStr"], "xmlSourceWriter": ["jsonStringwriter", "jsonReaderReader", " xmlSourceWritten", "xmlStrReader", "jsonSourceWritten", " xmlourceWritten", "xmlourceString", "xmlInputString", "xmlStrWriter", "xmlSourcewriter", "jsonReaderWriter", "xmlStrwriter", "jsonReaderWritten", "xmlResourceString", "jsonSourcewriter", "xmlSourceWritten", "xmlInputWrite", "xmlResourceWriter", "xmlServiceReader", "jsonStringReader", "xmlResourceWritten", "xmlReaderReader", "jsonReaderWrite", "xmlStringWrite", "xmlResourceReader", "jsonSourceWrite", "xmlInputWriter", "xmlInputWritten", "xmlServiceWritten", "xmlServiceWrite", "xmlourceWritten", "xmlServicewriter", " xmlSourceString", "jsonStringWrite", "jsonStringWriter", "xmlInputReader", "xmlReaderWriter", "xmlStringWriter", "jsonSourceWriter", "xmlSourceWrite", "xmlReaderWrite", "xmlStrWrite", "xmlSourceString", "xmlStringwriter", " xmlourceReader", " xmlourceString", " xmlSourceReader", "xmlReaderWritten", "xmlServiceWriter", "xmlourceWriter", "jsonSourceReader", "xmlSourceReader", "xmlStringReader", "xmlourceReader", " xmlourceWriter"]}}
{"id1": "17111859", "id2": "16353490", "code1": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "code2": "    private String executePost(String targetURL, String urlParameters) {\n        URL url;\n        HttpURLConnection connection = null;\n        try {\n            url = new URL(targetURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(urlParameters.getBytes().length));\n            connection.setRequestProperty(\"Content-Language\", \"en-US\");\n            connection.setUseCaches(false);\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            wr.writeBytes(urlParameters);\n            wr.flush();\n            wr.close();\n            InputStream is = connection.getInputStream();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n            String line;\n            StringBuffer response = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                response.append(line);\n                response.append('\\r');\n            }\n            rd.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getHash": ["GetHash", "GetSalt", " getHTML", "Gethash", "buildhash", "buildHash", "gethash", "buildHTML", "buildSalt", " getSalt", "GetHTML", " gethash", "getSalt", "getHTML"], "string": ["address", "buffer", "input", "duration", "uri", "resource", "server", "message", "slice", "sequence", "filename", "version", "number", "s", "time", "in", "database", "content", "password", "source", "cache", "strings", "value", "section", "STR", "data", "file", "text", "object", "p", "null", "format", "name", "array", "ring", "word", "prefix", "reference", "this", "hash"], "hashTime": ["hexTimer", "versionTimer", "hexTrack", " hashTrack", "HashFunction", "hashtime", "HashTrack", "HashTimer", "hashTrack", "Hashtime", "hexCheck", " hashTimer", "hashCheck", "HashTime", "HashCheck", "hashFunction", " hashCheck", "hexTime", "versionTime", "versiontime", " hashtime", "versionFunction", "hashTimer", " hashFunction"], "md5": ["digse", "md6", "madse", "md25", "mdb", " mddown", "maddown", "hash5", "madkey", "mandql", "mand2", "mad512", "mad2", "hash53", "digdown", "MDol", "mdql", "mad5", " md25", "dig6", "hashol", "mad3", " mdkey", "dig512", " mdol", "digb", "mdse", "mand25", " mdql", " md3", " md53", "digql", "MDkey", "dig5", "md2", "sha2", "md53", "sha6", " md6", "MD5", "shab", "dig2", "dig25", "MD3", "hash2", "MD2", "mdol", "mdkey", " md2", "mand5", "md3", "md512", "sha5", " md512", "MD53", "mddown", " mdb", " mdse"], "result": ["buffer", "uri", "response", "entry", "results", "res", "message", "json", "character", "current", "number", "hex", "match", "length", "digit", "part", "source", "expected", "value", "diff", "r", "default", "feature", "work", "section", "data", "page", "search", "product", "format", "test", "dict", "hash", "card", "array", "function", "success", "word", "prefix", "comment", "err", "range", "Result", "found", "error", "list", "valid"], "hexString": ["packArray", "rawBuffer", "hexBuffer", "packstring", "hexArray", "rawstring", "hexstring", " hexStr", " hexBuffer", " hexArray", "packStr", "packString", "rexString", "exString", "tempString", "rawArray", "hexStr", "hashString", "rexArray", "exBuffer", "tempArray", "exArray", " hexstring", "hashArray", "hashstring", "rexStr", "rexstring", "exstring", "tempstring", "rawString", "tempBuffer", "hashBuffer"], "i": ["index", "id", "uri", "pi", "slice", "c", "j", "fi", "ri", "o", "end", "l", "s", "length", "si", "ui", "ii", "in", "qi", "ti", "d", "phi", "data", "li", "h", "x", "p", "ip", "bi", "u", "oi", "start", "ai", "e", "I", "ci", "m", "io", "zi", "xi", "di", "gi", "a", "k", "b", "v", "abi", "multi", "f", "code", "ix"], "str": ["val", "buffer", "input", "id", "output", "uri", "enc", "entry", "res", "c", "s", "fr", "pass", "char", "key", "Str", "source", "pr", "r", "STR", "data", "text", "out", "x", "p", "name", "e", "t", "sl", "tr", "url", "err", "sp", "br", "obj", "st", "f", "sr", "code"]}}
{"id1": "4389475", "id2": "14691829", "code1": "    @Override\n    public URLConnection openConnection(URL url) throws IOException {\n        if (!url.getProtocol().equals(\"file\")) {\n            String name = url.getFile();\n            File f = new File(cacheFolder, ((name.charAt(0) == '/') ? name.substring(1) : name).replace('/', File.separatorChar));\n            if (!f.exists()) {\n                File f2 = new File(f.getParentFile(), f.getName() + \"-not_found\");\n                if (!f2.exists()) {\n                    try {\n                        f.getParentFile().mkdirs();\n                        downloadFile(url, f);\n                    } catch (IOException e) {\n                        f.delete();\n                        throw e;\n                    }\n                }\n            }\n            return f.toURI().toURL().openConnection();\n        }\n        return super.openConnection(url);\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 0, "substitutes": {"openConnection": ["openChannel", "newConnect", "newConn", "newConnection", "closeconnection", "closeConnect", "closeConnection", "OpenConnect", " openConnect", " openChannel", "closeConnector", "loadConnector", "loadConnect", "loadConn", "OpenConnection", "openConnect", "createConnection", "OpenChannel", "closeChannel", "openconnection", "closeConn", "openConn", "newConnector", "createconnection", "openConnector", "createChannel", "createConnect", "loadConnection", " openconnection"], "url": ["path", "ssl", "base", "loader", "address", "server", "uri", "resource", "feed", "id", "user", "http", "c", "o", "lr", "l", "location", "html", "URL", "host", "el", "source", "cache", "proxy", "connection", "str", "r", "ob", "config", "file", "li", "route", "web", "object", "page", "bel", "log", "u", "e", "io", "image", "link", "sl", "Url", "ur", "obj", "b", "gl", "this", "org", "loc"], "name": ["anc", "string", "path", "base", "info", "i", "NAME", "self", "n", "id", "uri", "core", "clean", "resource", "now", "filename", "o", "l", "ame", "key", "part", "type", "no", "d", "cache", "source", "default", "w", "parent", "data", "file", "names", "alias", "x", "size", "search", "Name", "e", "image", "word", "full", "prefix", "nm", "v", "original", "named"], "f": ["info", "i", "sf", "fa", "n", "fs", "lf", "feed", "df", "bf", "rf", "http", "cf", "c", "j", "fc", "fp", "o", "l", "fn", "fw", "fr", "ff", "flow", "fl", "form", "d", "q", "r", "g", "parent", "file", "fb", "h", "x", "p", "fe", "u", "folder", "e", "m", "fo", "t", "io", "af", "function", "F", "full", "fd", "of", "b", "v", "tf", "found", "inf", "fx", "front"], "f2": ["feed1", "f1", "elftwo", " fz", "F2", "fz", "F0", "Fz", "elf2", "fsecond", "ftwo", " f0", "p0", "feed2", " ftwo", "feedtwo", " f1", "F1", "feedsecond", "p1", "elf1", "f0", "elfsecond", "p2", "pz", " fsecond"]}}
{"id1": "18974466", "id2": "3184073", "code1": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["moveFile", "moveSourceFile", "moveFiles", " copySourceFile", " CopySourceFile", " CopyFile", " copyFiles", "copyResource", "copyFiles", "moveResource", " CopyFiles", "copySourceFile", " copyResource", " CopyResource"], "sourceFile": ["ourcePage", "targetFolder", "SourceDir", "ourceStream", "ourceFolder", "sourceDir", " sourceDir", " sourcePage", " sourceFiles", "sourcePage", "ourceFile", "sourceFolder", "targetFiles", "targetfile", "SourcePage", "SourceStream", " sourceStream", "ourcefile", "sourceFiles", "ourceFiles", "SourceFile", "sourcefile", "sourceStream", " sourcefile", "ourceDir", " sourceFolder", "targetFile"], "destinationFile": ["destationChannel", "distinationfile", "destroyingFiles", "distinationFiles", "DestinationFile", "destionDir", "destationfile", "destinationFilename", "destroyingfile", "distributionChannel", "destinationChannel", "DestinationFilename", "DestationDir", "distributionFiles", "destationFiles", "destinationsfile", "destationFilename", "destinationsFilename", "destinationfile", "destationDir", "distributionFile", "destionfile", "destinationsFile", "distributionfile", "destributionFile", "destributionChannel", "Destationfile", "distinationChannel", "destionFilename", "destionFile", "destinationDir", "destributionFiles", "distinationFile", "Destinationfile", "DestationFile", "destroyingFile", "DestationFilename", "DestinationDir", "destroyingChannel", "destributionfile", "destationFile", "destinationsDir", "destinationFiles"], "srcChannel": ["sourceContext", "srcConnection", "rcchannel", "srcchannel", "sourcechannel", "sourceChannel", "destChan", " srcConnection", " srcContext", "destContext", "sourceChan", "sourceConnection", " srcchannel", "destchannel", "srcContext", "rcChan", " srcChan", "rcChannel", "destConnection", "srcChan", "destChannel", "rcContext", "rcConnection"], "dstChannel": [" dndFile", "drcchannel", "DstContext", "DdestChan", "DstChan", " dndChannel", "dvchannel", "DdestChannel", "dsrcChannel", "dstStream", "drestStream", "drcChannel", "DdestContext", "ddestFile", "dstContext", "dsrcChan", "dstFile", "dndContext", " dstchannel", "ddestChan", "drestChannel", "ddestContext", "dndChannel", "dspchannel", "DstStream", "dndchannel", "drestchannel", "dspContext", "drcStream", " dndchannel", "dsrcchannel", "drcContext", "dspFile", " dndContext", "dvChannel", "dvChan", "drestContext", "dndFile", "dsrcStream", "Dstchannel", "ddestChannel", "dspChannel", " dstContext", "ddestStream", "dvStream", "ddestchannel", "dstChan", "dstchannel", "Ddestchannel", " dstFile", "DstChannel", "DdestStream"]}}
{"id1": "15166511", "id2": "19276022", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandomGCuid", "getRandUuid", "getRandGid", "getRandomGID", "getRandomIGuid", "getRandomGuid", "getRandomGid", "getRandUID", "getRandGID", "getRandomUID", "getRandomGCid", "getRandomIGID", "getRandomGCID", "getRandomUUID", "getRandGuid", "getRandomGCUID", "getRandomUid", "getRandomIGUID", "getRandomUuid", "getRandGUID", "getRandUid", "getRandomIGid", "getRandUUID"], "secure": ["zip", "remote", "ssl", "server", "timeout", "secondary", "smart", "confirmed", "weak", "host", "active", "security", "allow", "session", "use", "ce", "seed", "proxy", "debug", "exclusive", "config", "sensitive", "https", "require", "safe", "encrypted", "unsigned", "force", "stable", "pure", "Secure", " insecure", "service", "secret", "random", "deep", "protect", "sr", "sec", "external", "depth"], "md5": ["MD500", "cmdql", " md500", "cmd3", "mdql", " mdql", " md3", "MD11", "md2", " MD3", "MD5", " MD11", "md500", "MD3", "MD512", "MD2", "MDql", "md3", " md2", " MD2", "md512", " md512", "md11", " MD5", "cmd5", " MD500", "cmd512", " md11"], "sbValueBeforeMD5": ["sbValueBeforeDER0", "sbValueBeforeMD75", "sbValueBeforeMC375", "sbValueBeforeMS5", "sbValueAfterMS3", "sbValueGivenmd375", "sbValuebeforeSD005", "sbValuebeforeMD005", "sbValueBeforeSD20", "sbValueAfterMS65", "sbValuebeforeSD20", "sbValueBeforeMI7", "sbValueAfterMP5", "sbValueAfterMD20", "sbValuebeforeMD5", "sbValueBeforeMD7", "sbValueAfterMS5", "sbValueAfterMS20", "sbValueBeforeMR3", "sbValueBeforemd3", "sbValueBeforeMS7", "sbValueGivenmd512", "sbValueBeforeMS95", "sbValueAfterMD95", "sbValueBeforeMR5", "sbValueBeforeSHA005", "sbValuebeforeSD5", "sbValueBeforeMI1", "sbValueBeforeMAC3", "sbValueAfterMP7", "sbValueAfterMS55", "sbValueAfterMS0", "sbValueBeforeMD95", "sbValueBeforeMS512", "sbValueGivenMD3", "sbValueAfterMD75", "sbValueBeforeSHA20", "sbValueBeforeAMD5", "sbValueBeforemd512", "sbValueBeforeDER3", "sbValueBeforeMAC55", "sbValueBeforeMI20", "sbValueBeforeMS55", "sbValueBeforeMS0", "sbValueBeforeMAC0", "sbValuebeforeMD1", "sbValueBeforeSD005", "sbValueBeforemd5", "sbValueBeforeD5", "sbValueBeforemd25", "sbValueAfterMD5", "sbValuebeforeSD1", "sbValueBeforeD65", "sbValueBeforeMR95", "sbValueBeforemd375", "sbValueBeforemd95", "sbValueAfterMD0", "sbValueBeforeSD1", "sbValueBeforeMD0", "sbValueBeforeMP1", "sbValueBeforeMC5", "sbValueAfterMS25", "sbValueGivenMD375", "sbValueAfterMP3", "sbValueAfterMS1", "sbValueAfterMD25", "sbValueBeforeMC512", "sbValueBeforeMS25", "sbValueBeforeMS1", "sbValueBeforeDER005", "sbValueBeforeMD65", "sbValueAfterMD1", "sbValueBeforeAMD20", "sbValueBeforeDER55", "sbValueGivenmd3", "sbValueBeforeMD20", "sbValueBeforeSD5", "sbValueBeforeMD25", "sbValueGivenMD512", "sbValueBeforeDER20", "sbValueBeforeMS65", "sbValueBeforeMS75", "sbValueBeforeMS375", "sbValueBeforeMAC5", "sbValueBeforeMR25", "sbValueAfterMP1", "sbValueGivenMD5", "sbValueBeforeMP7", "sbValueAfterMS75", "sbValueBeforeSHA1", "sbValueBeforeMD1", "sbValueBeforeMI5", "sbValueBeforeMD512", "sbValueBeforemd65", "sbValueBeforeDER1", "sbValueAfterMD65", "sbValueBeforeMS20", "sbValueBeforeMI3", "sbValueBeforeMP5", "sbValueBeforeMP3", "sbValueAfterMD3", "sbValueBeforeAMD1", "sbValueBeforeMD005", "sbValueBeforeMS3", "sbValueBeforeSHA5", "sbValueBeforeAMD3", "sbValueBeforeMD55", "sbValueBeforeMD3", "sbValueAfterMS95", "sbValueBeforeDER5", "sbValueBeforeMC3", "sbValueAfterMD7", "sbValueBeforeMD375", "sbValueBeforemd75", "sbValueGivenmd5", "sbValueBeforeD3", "sbValueAfterMD55", "sbValuebeforeMD20", "sbValueBeforeD75"], "time": ["event", "cost", "error", "tz", "id", "duration", "user", "timeout", "year", "clock", "version", "slice", "ime", "mode", "loc", "length", "host", "offset", "rate", "type", "money", "TIME", "delay", "date", "value", "seed", "counter", "work", "timer", "size", "tim", "name", "start", "race", "Time", "hour", "random", "etime", "count", "times", "speed", "depth"], "rand": ["index", "root", "order", "max", "id", "lang", "round", "clean", "rc", "year", "rol", "res", "version", "rank", "ro", "alpha", "Rand", "rate", "type", "rule", "rh", "chance", "seed", "delay", "q", "serial", "min", "r", "pick", "gen", "rr", "risk", "bit", "raid", "cr", "bot", "reg", "right", "range", "random", "count", "ng", "mid", "error", "win", "rage", "winner", "depth"], "valueBeforeMD5": ["valueAfterAMD2", "valueBeforeMC5", "valueBeforeMC3", "valueBeforeMC2", "valueBeforeMD85", "valueAfterAMD5", "valueBeforeMP53", "valueBeforeMP2", "valueBeforeMD53", "valueBeforeMP5", "valueBeforeAMD2", "valueAfterAMD53", "valueBeforeMD3", "valueBeforemd5", "valueBeforeAMD3", "valueAfterMD3", "valueBeforemd2", "valueInsideMD5", "valueBeforeMC85", "valueBeforemd85", "valueInsideMD3", "valueBeforemd3", "valueAfterMD53", "valueInsideMD85", "valueAfterMD2", "valueBeforeMP3", "valueAfterAMD3", "valueBeforeAMD53", "valueBeforeMD2", "valueBeforeAMD5", "valueInsideMD2"], "array": ["integer", "string", "audio", "address", "list", "vector", "message", "number", "any", "result", "instance", "record", "database", "arr", "expression", "angle", "allow", "cache", "binary", "value", "our", "Array", "collection", "sample", "data", "feature", "archive", "section", "object", "row", "ray", "arrow", "image", "function", "area", "app", "shape", "pair", "range", "air", "batch", "error", "element", "api", "view", "storage"], "sb": ["buffer", "BB", "sf", "usb", "bf", "bh", "sg", "lp", "lb", "eb", "lab", "cb", "lr", "obb", "s", "bs", "kb", "si", "orb", "nn", "pb", "gb", "mb", "abb", "rb", "sa", "ab", "binary", "wb", "buf", "sv", "ob", "bj", "ruby", "src", "fb", "bb", "sq", "zb", "stab", "sth", "rob", "nb", " SB", "sl", "ib", "bt", "bc", "bp", "xb", "bl", "bm", "bsp", "sbm", "SB"], "j": ["index", "dy", "job", "i", "num", "uj", "n", "ij", "ie", "c", "z", "end", "o", "jl", "l", "length", "jo", "ii", "key", "aj", "part", "ja", "ji", "d", "pr", "q", "ch", "g", "bj", "li", "out", "x", "p", "jj", "J", "js", "e", "jp", "k", "y", "br", "v", "obj", "adj", "f", "code"], "b": ["job", "i", "BB", "bf", "n", "be", "eb", "lb", "c", "cb", "l", "bs", "bin", "orb", "pb", "bar", "mb", "rb", "d", "ab", "binary", "ob", "fb", "bb", "x", "p", "bi", "e", "bit", "nb", "db", "ib", "a", "bc", "B", "bug", "k", "y", "br", "f"], "valueAfterMD5": ["valueAfterMP3", "valueAfterAMD2", "valueAfterMP7", "valueAfterMP5", "valueAfterVM7", "valueAfterAMD5", "valueAfterAMD7", "valueBeforeMP2", "valueBeforeMP5", "valueBeforeMD3", "valueAfterMD3", "valueAfterMD7", "valueAfterVM3", "valueAfterVM5", "valueBeforeMD7", "valueAfterMD2", "valueBeforeMP3", "valueAfterAMD3", "valueBeforeMD2", "valueAfterMP2", "valueBeforeMP7", "valueAfterVM2"]}}
{"id1": "18891988", "id2": "17207832", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    @Test\n    public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception {\n        Exception e = new UnsuccessfulResponseException(resp);\n        expect(mockBackend.execute(host, req, ctx)).andThrow(e);\n        replay(mockBackend);\n        HttpResponse result = impl.execute(host, req, ctx);\n        verify(mockBackend);\n        assertSame(resp, result);\n    }\n", "label": 0, "substitutes": {"getFile": ["downloadString", "getfile", "Getfile", "loadfile", "loadString", "loadFilename", "downloadFilename", "loadFile", "getFilename", "GetString", "GetFile", "downloadfile", "GetFilename", "downloadFile", "getString"], "serviceName": [" servicePath", "serviceUrl", "Servicename", "projectPath", "ServiceName", "servicename", "packageUrl", " servicename", "ServicePath", "projectType", "packageName", "ServiceUrl", "projectUrl", "projectName", "ServiceType", " serviceType", " serviceUrl", "packagename", "servicePath", "packagePath", "serviceType"], "wsdlLocation": ["wllAddress", "wsdlFolder", "wssdAddress", "wdlFile", "wslFolder", "wsDLUrl", "wslFile", "wllLocation", "wsslFolder", "wsslLocation", "wsdlDirectory", "wsDLFile", "wllFolder", "wdlFolder", "wsllAddress", "wslpLocation", "awsdlUrl", "wsslFile", "wslDirectory", "wddlFolder", "wsslAddress", "wslLocation", "wdlLocation", "wsDLDirectory", "wssdFile", "wsllUrl", "wslpFile", "wdlDirectory", "wslpFolder", "wsllFile", "wllFile", "awslLocation", "wddlLocation", "wssdFolder", "awslDirectory", "awsdlFile", "awslUrl", "wslUrl", "awsdlLocation", "awsdlDirectory", "wsdlUrl", "wsDLLocation", "wsdlAddress", "wsllLocation", "awslFile", "wsdlFile", "wddlDirectory", "wslpDirectory", "wsllDirectory", "wddlFile", "wdlAddress", "wssdLocation", "wsllFolder"], "endpoint": ["endaddress", "endsocol", "enpointer", "Endocol", "startPoint", " endword", "Endpoints", "enaddress", " endPoint", " endpo", "ENDpoint", " endpointer", "enpoints", "EndPoint", " endocol", "ENDPoint", "endpoints", "startpointer", "Endpo", "Endword", "enination", "enPoint", "endword", "ENDination", "endpo", " endaddress", "endpointer", "startpoint", "endocol", "Endpoint", "endspoint", "endination", "endsword", "endspo", "Endination", "endPoint", "startaddress", "ENDpoints", "enpoint"], "fileLocation": ["fileDirectory", "FileDirectory", "fileURI", "FILELocation", "FILEUrl", "FileUrl", "fileUrl", "FILEURI", " fileUrl", "FileURI", " fileDirectory", "FILEDirectory", " fileURI", "FileLocation"], "tempDir": ["TempDirectory", " tempDirectory", " tempVer", " tempPath", "tmpVer", "tmpdir", "tempPath", "TempDir", "tempDirectory", "Tempdir", "TempPath", " tempdir", " temporaryDirectory", " temporaryDir", " temporaryPath", "tmpDir", "tempVer", " temporaryVer", "tempdir", "tmpDirectory", "tmpPath"], "url": ["string", "path", "ssl", "address", "base", "server", "uri", "http", "socket", "l", "host", "URL", "el", "fl", "client", "source", "connection", "open", "config", "file", "channel", "web", "ll", "log", "conn", "ls", "coll", "image", "io", "sl", "pull", "Url", "www", "stream", "ur", "ul", "contact", "f", "service", "download"], "WSDLFile": ["WDDLFolder", "WINDLFile", "WSDLBase", "WSDLLfile", "WDDLBase", "WSDlPath", "WDDLfile", "WINDELPath", "WDDlBase", "WSDLLBase", "WSDLLSourceFile", "WSDDLSourceFile", "WSDDLFile", "WSDLfile", "WSDlFile", "WSDDLPath", "WSDLFolder", "WSDELFiles", "WSDDLfile", "WSDLLFolder", "WSDDLBase", "WSDLFiles", "WSDDLFolder", "WINDELFile", "WSDLSourceFile", "WDDlfile", "WSDLPath", "WSDlFolder", "WINDLFiles", "WINDLPath", "WSDlBase", "WSDlfile", "WSDLLFiles", "WDDLFile", "WSDELFolder", "WSDLLPath", "WSDDLFiles", "WINDELFiles", "WSDELPath", "WINDELFolder", "WDDLPath", "WDDlFolder", "WDDlFile", "WSDLLFile", "WSDlSourceFile", "WDDlPath", "WINDLFolder", "WDDlSourceFile", "WSDELFile", "WDDLSourceFile"], "tmpWSDLFile": ["tmpWSDlFiles", "tmpWSDLLFiles", "tmpWSDELFile", "tmpWSDlLocation", "tmpWSDlFolder", "tmpWSDLFolder", "tmpWDDLFile", "tmpWSDlUrl", "tmpWDDELLocation", "tmpWSDELLocation", "tmpWDDLFiles", "tmpWDDLUrl", "tmpWDDlFiles", "tmpWDDELUrl", "tmpWSDDLLocation", "tmpWDDlFolder", "tmpWSDLLUrl", "tmpWDDELFile", "tmpWSDDLFile", "tmpWDDELFiles", "tmpWSDLLFolder", "tmpWDDLLocation", "tmpWSDLFiles", "tmpWSDLUrl", "tmpWSDELUrl", "tmpWSDELFiles", "tmpWSDlFile", "tmpWDDlFile", "tmpWSDLLFile", "tmpWDDLFolder", "tmpWDDlUrl", "tmpWSDDLFiles", "tmpWSDELFolder", "tmpWSDLLocation", "tmpWSDDLUrl"], "inputFile": ["inputPlace", " inputDir", " inputBuffer", "tempPlace", "InputDir", "outputfile", "inFile", "InputBuffer", "inputBase", " inputPlace", "tempBase", " inputUrl", "inputfile", "tempUrl", "InputUrl", "inputFactory", " inputfile", "inputUrl", "infile", " inputFactory", "InputBase", "inputBuffer", "InputFile", "InputFactory", " inputStream", "inputDir", "requestFile", "requestfile", "inDir", " inputPage", " inputBase", "inputStream", "inputFiles", "requestFiles", "outputFiles", "requestStream", "InputPlace", "tempPage", "tempfile", "tempFile", "outputDir", "tempFactory", "InputFiles", "tempBuffer", "inputPage", "outputFile", " inputFiles", "inPage", "InputStream", "InputPage", "Inputfile"], "tmpFile": ["TempDirectory", " tmpFiles", "tempDocument", "uploadStream", "uploadDocument", "TempFile", "uploadFiles", "tempStream", "tempDirectory", "TempFiles", "inputDocument", "TempPage", "tmpStream", "inputStream", "inputFiles", "tmpFiles", "tmpPage", "tempPage", "tempFile", "tempFiles", " tmpDirectory", "tmpDirectory", "uploadFile", " tmpPage"], "in": ["IN", "impl", "pin", "ssl", "input", "id", "lock", "gin", "on", "c", "inner", "socket", "l", "ins", "bin", "is", "client", "reader", "source", "up", "connection", "login", "r", "inc", "data", "file", "p", "conn", "init", "again", "m", "image", "In", "lin", "inn", "f", "win", "din"], "out": ["IN", "input", "outer", "output", "copy", "server", "timeout", "on", "net", "OUT", "inner", "socket", "c", "outs", "o", "line", "co", "bin", "client", "sync", "part", "source", "cache", "up", "connection", "ch", "group", "inc", "conv", "parent", "file", "channel", "log", "conn", "again", "name", "Out", "image", "io", "writer", "to", "In", "can", "conf", "err", "error"], "con": ["IN", "close", "ssl", "Conn", "CON", "rc", "gin", "ran", "plain", "c", "inner", "socket", "fc", "ctrl", "Con", "ins", "co", "en", "nc", "sync", "client", "cm", "thin", "uc", "connection", "ch", "inc", "conv", "un", "channel", "open", "conn", "rec", "kin", "bc", "com", "can", "conf", "connect", "cn", "win"], "fileLength": ["contentLength", "channelLength", "channelLen", " fileSize", "FileSize", "fileSize", "Filelength", " fileLen", "fileLen", "contentSize", "filelength", "contentlength", "FileLength", " fileWidth", " filelength", "FileWidth", "channelSize", "FileLen", "fileWidth", "channelWidth", "contentLen"], "channelIn": ["characterIN", " channelIN", "ChannelIN", "connectionin", "connectionOut", "Channelin", "channelIN", "characterin", "channelConn", "connectionIn", "resourceIn", "channelin", "ChannelOut", " channelConn", "resourceOut", "ChannelIn", "resourcein", "ChannelConn", "resourceIN", "characterOut", "characterIn", "connectionConn", " channelin"], "channelOut": ["chanOutside", "canOutside", "ChannelOutside", "chanOut", "connectionOut", "Channelout", "canIn", " channelOutput", "channelOutside", "connectionIn", "channelOutput", "chanOUT", "channelOUT", "ChannelOut", "chanout", "chanIn", "connectionout", "ChannelIn", "connectionOutput", "channelout", "connectionOutside", "ChannelOUT", "ChannelOutput", "canOut", " channelout", "canOUT"], "tmpDocument": [" tmpContent", " tmpdocument", "mpFile", "tempDoc", "tmpNode", "tmdocument", "mpNode", "tmpDoc", "tempNode", "mpDocument", "tempDocument", "tmNode", "tmpdocument", "newContent", "tmDocument", "newDocument", "newdocument", "mpDoc", "tempdocument", "tempContent", "tmFile", " tmpDoc", " tmpNode", "tempFile", "tmpContent", "newFile"], "nl1": ["ln2", "nlone", "ln1", "nl2", "NL1", "NL11", "nn11", "arlone", "dl2", "kl5", "kl1", "NL2", "dl1", "nlFirst", "ln11", "klFirst", "klone", "arl5", "NL0", "nn1", "nn6", "jlone", "ln6", "arl1", "nl6", "jl1", "NL6", "nn0", "jl5", "nn2", "nl5", "nl11", "dl0", "nl0", "jlFirst", "arlFirst"], "i": ["index", "info", "mu", "id", "uri", "pi", "n", "ini", "ie", "yi", "slice", "j", "fi", "ri", "o", "z", "l", "si", "ui", "ii", "qi", "part", "ti", "ji", "d", "phi", "chi", "li", "ip", "mi", "p", "bi", "u", "uli", "oi", "ai", "ci", "I", "e", "m", "io", "eni", "it", "xi", "di", "gi", "hi", "v", "b", "ni", "y", "abi", "iu", "multi", "f", "ix"], "node1": ["nOne", " nodeone", "shape1", "package91", "Node2", "layer2", "n2", "node91", "Node91", "Node0", "shapeone", " node2", " node91", "Node1", "nodeOne", "packageOne", " nodeOne", "layer1", " node0", "packageone", "nodeone", "n0", "layer91", "node0", "NodeOne", "package1", "shapeOne", "n1", "shape91", "layerOne", "node2"], "tmpOut": ["ptyIn", "cacheOut", "tmpOUT", "tmpout", "tempOUT", "vmOUT", "tempWriter", " tmpIn", "vmout", "tempout", "cacheIn", " tmpOUT", " tmpWriter", "vmOut", "ptyOut", "tmpIn", "cacheOUT", "ptyout", "tempOut", "cacheFile", "tempIn", "tmpOutput", " tmpout", "ptyOutput", "vmIn", "tempFile", "tempOutput", " tmpOutput", "txtWriter", "txtOut", "txtOutput", "txtout", "tmpWriter"], "retVal": ["RETval", "valObj", " retObj", " retval", "RETVal", "valval", "valVal", "retRet", "valRet", "RETRet", "retObj", " retRet", "retval", "RETObj"]}}
{"id1": "20995534", "id2": "14598566", "code1": "    private static Properties loadPropertiesFromClasspath(String path) {\n        Enumeration<URL> locations;\n        Properties props = new Properties();\n        try {\n            locations = Thread.currentThread().getContextClassLoader().getResources(path);\n            while (locations.hasMoreElements()) {\n                URL url = locations.nextElement();\n                InputStream in = url.openStream();\n                props.load(in);\n                in.close();\n                logger.config(\"Load properties from \" + url);\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"load properties from classpath \\\"\" + path + \"\\\" failed\", e);\n        }\n        return props;\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"loadPropertiesFromClasspath": ["loadPropertiesFromclassloader", "loadPropertiesfromclassloader", "loadPropertiesfromClassname", "loadPropertiesfromclassfile", "loadPropertiesFromclasspath", "loadPropertiesFromSubloader", "loadPropertiesFromSubpath", "loadPropertiesFromClassloader", "loadPropertiesfromclasspath", "loadPropertiesfromclassname", "loadPropertiesfromClassfile", "loadPropertiesfromClassloader", "loadPropertiesFromclassname", "loadPropertiesFromclassfile", "loadPropertiesFromClassfile", "loadPropertiesFromSubname", "loadPropertiesFromSubfile", "loadPropertiesFromClassname", "loadPropertiesfromClasspath"], "path": ["root", "base", "handler", "loader", "error", "string", "id", "resource", "uri", "enc", "filename", "c", "Path", "location", "host", "key", "pattern", "content", "part", "type", "source", "dir", "value", "ath", "work", "config", "level", "text", "parent", "data", "route", "request", "object", "p", "log", "context", "name", "template", "pointer", "full", "prefix", "PATH", "prop", "xml", "properties", "method"], "locations": ["slibraries", "locors", "LocATIONS", "LOCations", " loclements", "slations", "location", "colions", "LOCors", "locators", "Locors", "colations", "Locator", "locator", "Loclements", "slators", "Locations", "operation", " locors", "operibraries", "loclements", "lococations", "slator", " locATIONS", "locibraries", " locators", "operations", " location", "colation", "colATIONS", "LOCocations", " locibraries", "slATIONS", "sllements", "Lococations", " locator", " lococations", "Locions", "Location", "locions", "LOCions", "slation", "operators", "locATIONS", "LOCation", "LOCATIONS"], "props": [" probs", "peps", "pbs", "pps", "producs", "suppcs", " propps", " propp", "pperties", "posbs", "propp", " procs", "protros", "posperties", "pebs", "ppp", "pbps", "supppps", "posps", "pbbs", "suppps", "protps", "pospp", "probs", "protbs", "peperties", "pbperties", "peros", "procs", " properties", "propps", "produperties", "proros", "protperties", "properties", "suppperties", "pbros", "produps", "produpps"], "url": ["string", "base", "class", "address", "ssl", "i", "id", "uri", "resource", "element", "feed", "user", "entry", "http", "rel", "lr", "location", "l", "URL", "el", "key", "source", "connection", "r", "str", "ob", "file", "out", "route", "src", "bel", "ll", "href", "ls", "name", "e", "coll", "sl", "rl", "layer", "Url", "err", "obj", "b", "f", "gl", "ource", "org", "loc"], "in": ["IN", "impl", "i", "input", "ex", "resource", "n", "serv", "id", "ini", "gin", "into", "ic", "con", "c", "inner", "socket", "as", "s", "ins", "bin", "is", "source", "reader", "connection", "login", "r", "inc", "config", "data", "file", "out", "src", "conn", "init", "again", "io", "image", "it", "isin", "In", "nin", "a", "stream", "lin", "err", "ac", "inn", "f", "din"]}}
{"id1": "21063400", "id2": "1421557", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"doImageProcess": ["doThumbnailProcess", "doFileFile", "doThumbnailprocess", "doimageFile", " doimageProcess", " doimageFile", "doimageprocess", " doImageprocess", " doImageFile", "doImageFile", "doFileProcess", "doFileprocess", " doimageprocess", "doImageprocess", "doimageProcess", "doThumbnailFile"], "request": ["path", "input", "Request", "resource", "server", "report", "message", "result", "instance", "query", "req", "client", "type", "reader", "model", "application", "config", "data", "object", "name", "header", "writer", "image", "url", "stream", "xml", "method"], "response": ["index", "server", "output", "resource", "feed", "video", "more", "report", "http", "results", "message", "document", "site", "description", "onse", "json", "result", "version", "location", "host", "pool", "ception", "queue", "next", "client", "session", "cache", "resp", "connection", "model", "application", "collection", "default", "wave", "out", "body", "page", "object", "reply", "complete", "example", "image", "status", "writer", "success", "full", "Response", "respond", " Response", "error", "service", "api", "view"], "imgSize": ["refSize", "hrC", "ifsize", "dimLength", "imgsize", "imgScale", "hrType", "bgLen", "dimSize", "ifSize", " imgsize", "imgLength", "augWidth", "imageName", "bgLength", "imSize", "imagsize", "refLength", "imagType", "imgType", "hrSize", "bgScale", "imagC", "imHeight", "imageLength", "imLength", "imagesize", "augFamily", "bgSize", "imagSize", "imageScale", " imgLen", "imgHeight", "imgWidth", "augLen", " imgScale", "largeSize", "hrsize", "imsize", "augSize", " imgWidth", "ifName", "refHeight", "imageSize", "imgFamily", " imgFamily", "imgName", "refsize", "imageLen", " imgName", "ifLen", "largeType", "largesize", " imgLength", "imgC", "bgWidth", "imgLen", "bgFamily", "dimHeight", "largeC", "dimsize"], "imageInputStream": ["pictureInputstream", "imageReadstream", "fileInputStream", " imageOutputView", "imageInputstream", "imageStreamStream", "photoInputStream", "fileReadstream", "fileInputLength", "imageFileString", "photoReadFile", "imageUploadstream", "pictureUploadstream", "fileReadLength", " imageInputFile", "imageInputString", "imageReadString", "pictureUploadFile", "imageInputSteam", " imageInputView", "pictureUploadSteam", "fileReadString", "imageOutputstream", "pictureUploadStream", "imageReadLength", "imageUploadSteam", "imageContentSteam", "imageOutputFile", "photoInputFile", "pictureInputStream", "pictureInputFile", "imageInLength", "imageStreamFile", "fileReadStream", "imageUploadStream", "imageOutputSteam", "imageUploadFile", "pictureInputSteam", "imageInstream", " imageOutputSteam", "imageFileLength", " imageOutputFile", "imageInputFile", "imageUploadView", "photoReadstream", "imageFilestream", "imageContentStream", "imageFileStream", " imageOutputStream", "imageReadStream", "photoInputSteam", "imageContentFile", "imageStreamSteam", "photoReadStream", " imageInputSteam", "imageReadFile", "photoReadSteam", "imageInStream", "imageReadSteam", "fileInputString", "fileInputstream", "imageInputLength", "imageInString", "imageOutputView", "imageContentView", "photoInputstream", "imageOutputStream", "imageStreamstream", "imageInputView"], "imageBytes": [" imageData", "imageByte", "imgByte", "audioByte", "filebytes", "ImageData", "imageBuffer", "imgBytes", "Imagebytes", "audiobytes", " imageBuffer", " imageUrl", " imagebytes", "viewData", "picturebytes", " imageByte", "imgData", "fileBlocks", "viewbytes", "pictureBlocks", "imagebytes", "audioBuffer", "viewUrl", "imageData", "pictureData", "imageUrl", "imgbytes", "viewBytes", "audioBytes", "ImageBlocks", "imageBlocks", "imgBuffer", "fileBytes", "pictureBytes", "fileData", "ImageBytes", "imgUrl"]}}
{"id1": "4398382", "id2": "8665321", "code1": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"digest": [" digress", "digse", "encress", "Digester", " digse", "generester", "Digress", "generested", " digested", "generests", "Digse", "encse", "mdest", "mdested", "digester", "digests", "mdester", "digested", "encester", "digress", "Digest", "encest", "mdests", " digester", " digests", "generest"], "algorithm": ["malgebra", " algo", "Alignment", "alenge", "challgo", "malgorithm", "challgebra", "algo", "arignment", "Alenge", "challgorithm", "challenge", " alenge", "Algo", "aroding", "algebra", "alignment", "argorithm", "Algebra", "Algorithm", " algebra", "argebra", "Aloding", "maloding", "aloding", "malignment"], "text": ["letter", "string", "path", "address", "buffer", "input", "output", "token", "feed", "username", "Text", "message", "TEXT", "sequence", "length", "pattern", "content", "password", "txt", "source", "value", "connection", "str", "config", "data", "object", "struct", "format", "test", "name", "image", "word", "bytes", "url", "ext", "secret", "attribute", "code"], "mDigest": ["mCodest", "mEncge", "mDigester", "mCodested", "mDiggest", "MDiger", " mGester", "mDenge", "mdiger", "mGast", "mSignest", " mDigge", "amDigested", "mDesignester", "mSignge", "mSignester", "mDigenge", "amPostest", "mdigener", "mGge", "mSignast", "mDesignest", "mPostested", "mDer", "mGest", "mDiger", "mDigener", "mdiggest", "MDiggest", "mDgest", " mGge", "mDigast", "mCodener", "mDesigngest", "amPostener", "MDest", " mGest", "MDester", "mPostest", "mDester", "amPostested", "MDigest", "MDigester", " mDigester", "mDest", "mDigge", "mEncast", " mGast", "MDigenge", "mSignenge", "MDgest", "mSignEST", "mDEST", "mDesigner", "mGester", "mdigester", "MDer", "mDigested", "mDigEST", "mEncest", "mdigest", "mPostener", "mdigested", "amDigest", "mEncester", " mDigast", "MDigEST", "amDigener"], "raw": ["original", "buffer", "input", "output", "response", "feed", "clean", "enc", "json", "message", "RAW", "result", "hex", "instance", "content", "wrap", "source", "binary", "serial", "buf", "default", "Raw", "none", "data", "row", "unsigned", "null", "internal", "image", "array", "full", "partial", "container", "orig", "initial"], "encoder": ["ecoded", "decoder", "enoder", "Encoded", "Encoder", " encoding", "ecode", " encode", "encode", "decoding", "enccode", "Encoding", "eccode", "enoding", "enode", " encoded", "ecoder", "decode", "Encode", "ecoding", "deccode", "encoded", "encoding"]}}
{"id1": "1421557", "id2": "884867", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFiletoFiles", "encodeFileToFiles", "encodeFiletoFile", "encodeString2File", "encodeString2Stream", "encodeFileToStream", "encodeFileFromStream", "encodeStringToStream", "encodeFileFromFile", "encodeString2String", "encodeFile2Files", "encodeStringToFile", "encodeFile2File", "encodeFileToString", "encodeString2Files", "encodeFiletoString", "encodeStringToString", "encodeFile2Stream", "encodeFiletoStream", "encodeStringToFiles", "encodeFileFromString", "encodeFileFromFiles", "encodeFile2String"], "infile": ["infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", " infp", "inputfp", "inputFile", "outfiles", " infilename", "inputfiles", "Infilename", " infiles", "outfp", "Infile", "InFile", "inputfilename", "infilename", "Infiles"], "outfile": ["newfile", "Outname", "infp", "outfilename", "outputfile", "outFile", "newname", " outFile", "infolder", " outfolder", "outputfolder", "newfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "Outfolder", " outname", "outname", "OutFile", "Outfile", "infilename", "newFile", " outfilename"], "in": ["IN", "base", "pin", "i", "input", "inas", "sin", "id", "ini", "gin", "into", "ic", "con", "inner", "as", "socket", "ins", "s", "bin", "pass", "is", "reader", "source", "thin", "login", "min", "inside", "r", "inc", "data", "rin", "vin", "init", "conn", "again", "m", "image", "re", "isin", "In", "nin", "a", "err", "b", "ac", "cin", "inn", "win", "din"], "out": ["base", "ou", "job", "ex", "output", "outer", "copy", "timeout", "on", "net", "OUT", "socket", "inner", "outs", "o", "off", "write", "bin", "co", "line", "exit", "post", "client", "sync", "session", "no", "cache", "source", "one", "up", "lib", "inc", "parent", "work", "file", "conn", "or", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "In", "err", "obj", "error", "point"], "buffer": ["address", "base", "Buffer", "input", "uffer", "feed", "server", "border", "slice", "limit", "result", "length", "write", "queue", "offset", "iter", "split", "raw", "type", "reader", "cache", "binary", "source", "seed", "buff", "value", "buf", "len", "wave", "data", "fb", "size", "bb", "null", "bytes", "layer", "flush", "url", "b", "reference", "count", "padding", "transfer", "batch"], "read": ["play", "close", "i", "input", "Read", "feed", "n", "copy", "reading", "id", "add", "ind", "slice", "current", "end", "limit", "run", "se", "find", "length", "write", "reads", "ride", "pass", "sleep", "ad", "iter", "next", "raw", "sync", " count", "select", "allow", "use", "load", "reader", " Read", "len", "seek", "work", "inc", "check", " copy", "ip", "size", "x", "get", "fill", "start", "exec", "io", "lex", "send", "tell", "_", "parse", "connect", "wait", "count", "READ", " write", " skip", "f"], "success": ["respons", "roll", "error", "path", "response", "rolling", "continue", "results", "ceed", "modified", "xx", "message", "primary", "warning", "better", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "model", "default", "open", "data", "growth", "flash", "null", "cess", "danger", "complete", "again", "status", " successful", "good", "Success", "comment", "right", "successful", "successfully", "rolled", " succ", "method", "fast", "first", "winner", "initial"]}}
{"id1": "21979717", "id2": "2217889", "code1": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"upload": ["accept", "execute", "add", " submit", "run", "save", " transfer", "post", "select", "load", "up", "open", "archive", " download", "Upload", "request", "init", "submit", "start", "Submit", "create", " Upload", "paste", "process", "transfer", "download"], "fileResult": ["FileResults", "downloadRes", "filesResult", "fpRank", "filesresult", "fileRank", "fileResults", "FileRes", "fpRes", " fileResults", " fileRes", "fpResults", "FileRank", "downloadRank", "downloadResult", "filesResults", "fpResult", "downloadResults", "Fileresult", " fileresult", "fileRes", "fileresult", "FileResult", "filesRes"], "in": ["IN", "info", "pin", "i", "input", "ini", "gin", "on", "into", "c", "inner", "socket", "ins", "arin", "bin", "source", "cache", "up", "login", "min", "inside", "inc", "data", "file", "rin", "vin", "p", "init", "conn", "again", "image", "isin", "In", "kin", "conf", "lin", "cin", "inn", "f", "tin", "win"], "url": ["impl", "path", "ssl", "address", "server", "uri", "http", "c", "socket", "l", "host", "URL", "pl", "fl", "client", "connection", "ob", "file", "channel", "cl", "web", "bel", "log", "conn", "ls", "coll", "image", "sl", "pull", "Url", "www", "ur", "b", "ul", "f", "gl", "org", "api"], "con": ["remote", "close", "ssl", "fun", "non", "Conn", "pin", "fa", "CON", "cf", "rc", "cons", "http", "ran", "on", "plain", "c", "per", "fc", "ctrl", "sub", "run", "socket", "Con", "co", " conn", "func", "en", "ec", "client", "sync", "cm", "syn", "cp", "ocon", "part", "rou", "uc", "connection", "login", "min", "ch", "open", "conv", "un", "ca", "cl", "request", "log", "gen", "conn", "exec", "pc", "pen", "bc", "ver", "can", "conf", "connect", "cn", "cur", "re"], "out": ["base", "ssl", "input", "ex", "output", "copy", "outer", "resource", "server", "on", "c", "socket", "OUT", "as", "outs", "o", "pool", "line", "bin", "client", "at", "cache", "connection", "login", "ch", "inc", "parent", "file", "object", "conn", "again", "Out", "image", "io", "can", "conf", "b", "obj", "v", "err", "win", "this", "external"], "in2": ["in02", "inTwo", "In4", " in4", "errTwo", "InTwo", "IN4", "intwo", " inTwo", "INTwo", " intwo", "IN02", "input2", " in02", "in4", "outtwo", "out2", "input4", " in1", "out1", "errtwo", "input02", "out4", "In2", "in1", "outTwo", "err2", "inputTwo", "IN2", "In1", "err1"], "buf": ["base", "buffer", "Buffer", "bf", "bd", "bh", "rc", "cf", "cap", "lb", "cb", "pool", "done", "bin", "ff", "feat", "uf", "la", "bag", "utf", "cv", "rb", "cas", "uc", "buff", "cat", "data", "text", "fb", "av", "box", "vec", "home", "font", "ha", "dec", "db", "fd", "bytes", "bc", "Buff", "seq", "b", "br", "fab", "ba", "block", "batch"], "bytesRead": ["byteLength", "bytesRun", "linesRun", "rowsRead", " bytesWritten", "rowsread", "rowsUse", "BytesRead", "BytesWrite", " bytesRun", "byteRead", "linesRead", "tesRead", " bytesUse", "bytesLength", "bytesWritten", "bytesread", " bytesLoad", "BytesLoad", "tesRun", "blocksread", "bytesLoad", "blocksWrite", "BytesLength", " bytesread", "tesWritten", "byteLoad", "blocksRead", "byteWrite", "linesWritten", "rowsWrite", " bytesWrite", " bytesLength", "bytesWrite", "linesWrite", "bytesUse", "tesWrite", "blocksUse"]}}
{"id1": "16048516", "id2": "4168534", "code1": "    public static SVNConfiguracion load(URL urlConfiguracion) {\n        SVNConfiguracion configuracion = null;\n        try {\n            XMLDecoder xenc = new XMLDecoder(urlConfiguracion.openStream());\n            configuracion = (SVNConfiguracion) xenc.readObject();\n            configuracion.setFicheroConfiguracion(urlConfiguracion);\n            xenc.close();\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        }\n        return configuracion;\n    }\n", "code2": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "label": 0, "substitutes": {"load": ["Load", "loader", "add", "loaded", "set", "save", "read", "content", "loads", "show", "upload", "open", "build", "LOAD", "oad", "check", "get", "init", "start", "dump", "update", "create", "parse", "process", "transform", "download", "install"], "urlConfiguracion": ["urlConfigutabet", "urlConfigureaton", "urlConfigurator", "urlConfigURation", "urlconfigurator", "urlConfiguraci", "urlConfigurerabet", "urlconfiguracion", "urlConfigureabet", "urlConfigurerator", "urlConfiguraton", "urlConfigaurator", "urlConfureacion", "urlConfigURaci", "urlConfuracion", "urlConfigurateacion", "urlConfigureation", "urlConfigureado", "urlConfuraci", "urlConfigurateator", "urlConfuration", "urlConfureator", "urlConfureation", "urlConfigauracion", "urlconfiguraton", "urlConfigURator", "urlConfurator", "urlConfigauraton", "urlConfigauraci", "urlconfiguraci", "urlConfigurateaci", "urlConfigurerado", "urlConfigurado", "urlconfigaurator", "urlConfigURaton", "urlConfigutado", "urlConfigurabet", "urlConfigureaci", "urlConfigURacion", "urlConfigurateation", "urlConfiguration", "urlConfigutator", "urlConfigureator", "urlConfureaci", "urlConfigureacion", "urlconfigauracion", "urlConfigureracion", "urlConfigutacion", "urlconfigauraci", "urlconfigauraton"], "configuracion": ["calureaton", "Configureant", "configoration", "Configuraton", "Configureaci", "configureaton", "configurateur", "configuralaton", "configuralation", "configuralant", "Configuration", "configuraacion", "configureant", "configaurab", "configutaton", "configuration", "configoraton", "Configuracion", "configuralator", "configurant", "configureateur", "Configureab", "caluration", "caluraton", "configuraab", "configuralaci", "calureation", "caluracion", "configureation", "Configureator", "Configurant", "calureacion", "Configurateur", "configuraator", "Configuraci", "Configureation", "configoraci", "configurab", "configutaci", "configaurateur", "configutacion", "configureaci", "configauraton", "configauracion", "configuralacion", "configuraton", "calureaci", "Configurator", "Configureaton", "Configureacion", "configuraci", "configurator", "configauration", "Configurab", "configoracion", "Configureateur", "configureacion", "caluraci", "configuraateur", "configauraci", "configureator", "configutant", "configureab", "configaurator"], "xenc": ["xens", "xenv", "Xenc", "xEnc", "xstream", " xstream", "xec", "ixec", "exsen", " xens", "fxEnc", " xEnc", "Xens", "exstream", "Xenz", "xmlenc", "fxenz", "xsen", " xenv", "fxenc", "ixsen", "exec", " xenz", "xenz", "xmlEnc", "Xenv", " xsen", "fxens", "XEnc", "ixstream", "ixenc", "exenc", "xmlenv", "xmlens", " xec"]}}
{"id1": "4481712", "id2": "6371580", "code1": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "code2": "    public void insertDomain(final List<String> domains) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"domain.add\"));\n                    Iterator<String> iter = domains.iterator();\n                    String domain;\n                    while (iter.hasNext()) {\n                        domain = iter.next();\n                        psImpl.setString(1, domain);\n                        psImpl.setString(2, domain.toLowerCase(locale));\n                        psImpl.executeUpdate();\n                    }\n                }\n            });\n            connection.commit();\n            cmDB.updateDomains(null, null);\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                    log.error(ex);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"deleteObject": ["saveItem", "deleteItem", "saveObject", "saveDB", " deleteObj", "removeObject", "deleteDB", " deleteItem", " deleteDB", "removeDB", "removeItem", "removeObj", "deleteObj", "saveObj"], "id": ["string", "path", "info", "root", "i", "uri", "resource", "lock", "uid", "sid", "query", "ident", "database", "in", "ids", "key", "type", "source", "rid", "model", "parent", "data", "object", "oid", "ip", "delete", "name", "it", "pid", "sql", "url", "ID", "create", "f", "error", "Id", "api"], "conn": ["Connection", "nw", "ssl", "core", "ou", "Conn", "cc", "server", "n", "serv", "cmp", "cf", "rc", "enc", "lock", "con", "c", "act", "cb", "col", "host", "pool", "co", "rt", "dc", "nc", "ec", "client", "cms", "nt", "cm", "cp", "sync", "cache", "lc", "cond", "ct", "connection", "ch", "cat", "config", "cmd", "ca", "parent", "h", "log", "ai", "po", "coll", "ci", "exec", "cr", "ann", "db", "pc", "mc", "ctx", "sql", "comm", "auth", "conf", "err", "connect", "cn", "ac", "orp", "cli", "error", "cur", "pg", "org", "loc"], "stmt": ["strmn", "stql", "strm", "strmp", "tm", "tmn", "Stmm", "Stmn", "strtx", " stmb", " stm", " stmp", "istmt", " stmit", "pttx", " stmm", "strmt", "tmt", "ptmn", " stmd", "stmp", "Stma", "Stmr", "stmd", "tmm", "stm", "strmd", "stma", " sttx", "Stmp", "dma", "istmr", "stmit", "istmit", "dmt", "dmb", "stmr", "Stmd", "Stmit", "strmi", "strmb", "dm", "Stm", "strmr", "Stmb", "stmm", "ptql", "strmm", " stma", "Stmi", " stql", " stmn", " stmr", "stmn", "stmb", "sttx", "ptmt", "Stmt", "stmi", "istm", " stmi", "strql"], "dbConn": ["dbConnection", "dbconn", "cbConnection", "cbCon", "bbConn", " dbConnect", "bdConnection", "dbConnect", "databaseConn", "databaseConnection", "cbConnect", " dbConnection", "bbconn", " dbconn", "bdCon", "bdConn", "databaseConnect", "bbConnect", "databaseconn", "cbConn", " dbCon", "bdConnect", "bbConnection", "dbCon"], "selfConnection": [" selfconnection", "passReference", "parentconnection", "passConnection", "thisConnection", "SelfConnection", "parentConn", "thisConn", "selfconnection", "SelfConnect", "thisConnect", "selfReference", " selfConn", "Selfconnection", " selfConnect", "passConn", "thisReference", "selfConnect", "selfConn", " selfReference", "thisconnection", "parentConnect", "passConnect", "SelfReference", "SelfConn", "passconnection", "parentConnection"]}}
{"id1": "12097948", "id2": "20619879", "code1": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL url = loader.getResource(id);\n        if (url == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = url.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 0, "substitutes": {"systemID": ["systemURI", "classId", "classURI", "systemName", "sysName", "SystemIDS", " systemURL", "systemIDS", "classID", "SystemURL", "sysURI", "systemURL", "sysURL", " systemURI", "SystemId", " systemIDS", " systemRI", "SystemURI", "sysIDs", "systemId", "systemIDs", " systemName", "sysId", "sysID", " systemIDs", "systemRI", "SystemRI", "SystemIDs", "sysRI", "classIDS", " systemId", "SystemID", "SystemName"], "id": ["path", "string", "address", "info", "base", "i", "uri", "resource", "entry", "http", "modified", "uid", "end", "did", "sid", "ide", "layout", "ident", "is", "in", "ids", "key", "ad", "part", "like", "type", "one", "source", "aid", "value", "rid", "kid", "data", "file", "ip", "oid", "init", "style", "name", "start", "image", "it", "pid", "ID", "create", "xml", "and", "mid", "f", "error", "Id", "element", "code"], "loader": ["impl", "path", "class", "buffer", "handler", "lang", "resource", "user", "lock", "builder", "system", "loaded", "library", "l", "driver", "pool", "util", "er", "reader", "load", "cache", "lc", "up", "parser", "acl", "file", "cl", "loading", "rar", "log", "init", "folder", "Loader", "layer", "container", "module", "loc"], "url": ["impl", "event", "string", "path", "address", "base", "buffer", "job", "resource", "uri", "server", "feed", "rc", "http", "lr", "location", "l", "il", "URL", "fr", "client", "source", "rule", "lib", "r", "file", "src", "ssl", "ll", "ls", "coll", "name", "image", "io", "link", "sl", "rl", "pull", "Url", "stream", "ur", "b", "xml", "download", "f", "this", "service", "api", "loc"], "inStream": [" inSteam", "inSteam", "inSocket", " inReader", "inString", "conStreamer", "outstream", " instream", "inputSteam", "conSteam", "Instream", "innSocket", "innStream", "outStream", "outSteam", "innSteam", "inStreamer", "outReader", " inString", "inReader", "INStreamer", "outSocket", "InStream", "inputStream", "conStream", "conString", "INStream", "InSocket", "InSteam", " inStreamer", "innstream", "instream", "inputReader", "inputstream", "INSteam", "INString"], "constraints": ["Constraints", "contains", "constrains", "concomplaints", "Constions", "concomplains", "Constraint", "Constrions", "Constains", "Constaints", "concomplaint", "Constrains", "constraint", "Constaint", "constaints", "containts", "constions", "constrions", "contions", "constaint", "constains", "containt", "concomplions"]}}
{"id1": "19086952", "id2": "23310397", "code1": "    public static HttpResponse createUrlResponse(final URL url, final TcpConnection connection) throws IOException, NullPointerException {\n        String fullPath = url.toString();\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        final long length = conn.getContentLength();\n        if (connection.isDebugEnabled()) connection.logDebug(\"Sending \" + fullPath + \" to \" + connection.getRemoteAddress() + \" (length: \" + length + \").\");\n        return createInputStreamResponse(in, conn.getContentType(), length, connection);\n    }\n", "code2": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        mButton1 = (Button) findViewById(R.id.myButton1);\n        mButton2 = (Button) findViewById(R.id.myButton2);\n        mTextView1 = (TextView) findViewById(R.id.myTextView1);\n        mButton1.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpPost httpRequest = new HttpPost(uriAPI);\n                List<NameValuePair> params = new ArrayList<NameValuePair>();\n                params.add(new BasicNameValuePair(\"str\", \"post string\"));\n                try {\n                    httpRequest.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n        mButton2.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpGet httpRequest = new HttpGet(uriAPI);\n                try {\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        strResult = eregi_replace(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"\", strResult);\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n", "label": 0, "substitutes": {"createUrlResponse": ["getUrlResponse", "createUrlresponse", "getUrlResp", "getURLRequest", "createHttpResponse", "createHttpResp", "getUrlresponse", "createURLresponse", "createURLResp", "getUrlRequest", "createUrlResp", "createWebResponse", "createUrlRequest", "createURLResponse", "createURLRequest", "getURLResponse", "getURLResp", "createHttpresponse", "getURLresponse", "createWebResp", "createWebresponse", "createHttpRequest", "createWebRequest"], "url": ["string", "path", "address", "base", "ssl", "buffer", "remote", "server", "uri", "resource", "response", "entry", "http", "con", "socket", "l", "location", "host", "URL", "client", "source", "proxy", "org", "open", "config", "file", "text", "channel", "page", "object", "log", "name", " URL", "image", "io", "link", "sl", "Url", "bug", "connect", "f", "service", "loc"], "connection": ["directory", "Connection", "event", "handler", "tc", "cc", "server", "resource", "response", "uri", "timeout", "http", "subject", "character", "con", "c", "socket", "connected", "communication", "description", "current", "pool", "relation", "database", "nc", "password", "client", "sync", "session", "source", "cache", "lc", "ch", "application", "section", "config", "collection", "channel", "object", "context", "ci", "io", "writer", "function", "graph", "db", "link", "ctx", "service", "bc", "conf", "connect", "wrapper", "general", "container", "cli", " Connection", "loc"], "fullPath": ["FullURL", "Fullpath", "FullPath", "halfpath", "tempUrl", " fullUrl", "tempPath", "halfUrl", "halfPath", "fullUrl", " fullpath", "fullURL", "tempURL", "temppath", " fullURL", "FullUrl", "fullpath"], "conn": ["Connection", "close", "Conn", "server", "n", "serv", "cf", "enc", "con", "c", "connected", "act", "cb", "col", "l", "Con", "co", "rt", "en", "nc", "ec", "sync", "client", "nt", "part", "cp", "stat", "lc", "ct", "ion", "ch", "open", "conv", "config", "ca", "init", "coll", "ci", "exec", "ann", "db", "ctx", "conf", "reg", "cn", "connect", "f", "cli", "cur", "sec", "api", "loc"], "in": ["IN", "index", "ssl", "i", "input", "inas", "n", "id", "ini", "gin", "con", "c", "inner", "socket", "as", "ins", "s", "bin", "is", "client", "reader", "login", "min", "inc", "data", "rin", "out", "again", "m", "In", "nin", "kin", "stream", "ac", "cin", "inn", "f", "din"], "length": ["zip", "string", "total", "path", "class", "duration", "id", "lock", "slice", "library", "number", "limit", "l", "child", "offset", "type", "angle", "load", "value", "len", "Length", "build", "section", "level", "size", "style", "port", "available", "pull", "position", "height", "th", "shape", "ength", "count", "padding", "width", "depth"]}}
{"id1": "18544890", "id2": "1097146", "code1": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"get": ["remote", "info", "list", "resource", "gets", "json", "end", "find", "match", "query", "next", "select", "load", "cache", "debug", "show", "data", "GET", "start", "Get", "send", "call", "pull", "update", "create", "download"], "url": ["string", "path", "address", "base", "ssl", "server", "uri", "id", "resource", "feed", "http", "location", "host", "l", "URL", "key", "queue", "email", "source", "rule", "date", "connection", "str", "file", "route", "page", "ll", "href", "name", "ls", "image", "sl", "layer", "Url", "www", "ur", "f", "service", "download", "loc"], "lat": ["play", "base", "address", "id", "game", "loc", "late", "l", "length", "location", "grid", "offset", "la", "at", "live", "street", "alt", "west", "gal", "data", "out", "league", "route", "local", "las", "Lat", "home", "pos", "port", "tile", "height", "bot", "range", "distance", "width", "point"], "lon": ["val", "lag", "base", "online", "fat", "lang", "vel", "on", "lb", "number", "l", "location", "length", "off", "lan", "offset", "ino", "la", "live", "len", "level", "nl", "log", "pos", "depth", "ln", "layer", "position", "lin", "left", "range", "ng", "land", "width", "loc"], "count": ["val", "index", "total", "base", "sum", "num", "id", "n", "more", "timeout", "c", "limit", "number", "length", "all", "code", "amount", "pool", "time", "follow", "offset", "part", "type", "scroll", "load", "cache", "len", "level", "file", "Count", "size", "log", "name", "force", "age", "found", "f", "batch", "error", "list", "depth"], "req": ["temp", "rf", "cf", "http", "ref", "fit", "rt", "fail", "cp", "proc", "q", "ctr", "build", "fb", "conn", "gr", "worker", "jp", "respond", "hr", "wx", "org", "download", "qt", "server", "serv", "pub", "query", "next", "post", "cache", "pr", "r", "work", "requ", "rr", "test", "exec", "exp", "grad", "wa", "pkg", "sem", "bur", "ok", "ru", "socket", "fr", "orb", "dq", "fin", "request", "p", "io", "rob", "ver", "ur", "def", "plug", "cmd", "cur", "fe", "Request", "res", "c", "cb", "form", "client", "rb", "resp", "https", "check", "require", "sq", "rx", "call", "ctx", "pull", "tr", "cook", "ext", "conf", "err", "reg", "f", "loc"], "gl": ["sel", "fe", "console", "ogl", "rg", "l", "GL", "il", "gg", "fr", "global", "pl", "cal", "el", "bs", "gel", "hl", "bg", "fl", "gb", "berg", "cm", "gold", "lc", "browser", "gall", "g", "ger", "gal", "las", "lim", "gn", "cl", "bel", "ll", "nl", "groups", "go", "img", "coll", "ml", "Gl", "sl", "rl", "gi", "gre", "ang", "lol", "ga", "bl", "ul", "gm", "fx", "list", "view", "loc"], "br": ["bh", "res", "bridge", "result", "lr", "fr", "dr", "mr", "bro", "ler", "arr", "BR", "bar", "rb", "reader", "pr", "ctr", "browser", "buf", "r", "ch", "Br", "str", "div", "body", "gr", "brush", "io", "yr", "cr", "tr", "bc", "stream", "hr", "b", "sp", "bl", "err", "ber", "ar", "sr", "img"], "line": ["letter", "string", "sel", "lo", "base", "lf", "entry", "LINE", "ge", "end", "l", "look", "jo", "el", "fr", "co", "ine", "char", "key", "ino", "sync", "rule", "source", "lines", "lc", "live", "str", "data", "file", "text", "cl", "le", "page", "nl", "log", "row", "inline", "style", "ne", "name", "e", "pos", "cle", "word", "link", "sl", "pe", "unit", "comment", "lin", "Line", "bl", "block", "code", "cell"]}}
{"id1": "17161805", "id2": "1235538", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 1, "substitutes": {"encode": ["enccod", "ensoder", "enoder", "Encod", "enscod", "enscode", "recode", "reode", "recod", "Enoder", "enccode", "reoding", "encod", "enoding", "enode", "encoder", "Encode", "ensode", "encoding", "Enoding", "Enode"], "plaintext": ["forestring", "foreText", " plainTEXT", " plainform", "batText", "plainText", "plainTEXT", " plainstring", "plainstring", "bodytext", "plainform", "plaincontent", "batstring", "foretext", "longText", "longcontent", " plaincontent", "bodyform", " plainText", "batTEXT", "bodyText", "foreTEXT", "longform", "longtext", "battext", "bodycontent"], "md": ["um", "gd", "mag", "bd", "od", "df", "amd", "ind", "ma", "meta", "wd", "MD", " MD", "ms", "sm", "ad", "rpm", "mb", "dh", "d", "mac", "mp", "hd", "sha", "pm", "pd", "mm", "metadata", "cd", "po", "m", "dm", "grad", "mand", "mc", "di", "mod", "me", "rm", "mad", "f", "cmd", "dd", "code"], "raw": ["micro", "remote", "original", "buffer", "input", "feed", "clean", "enc", "rew", "ack", "RAW", "hex", " Raw", "instance", "all", "unknown", "alpha", "load", "binary", "blocks", "serial", "shared", "Raw", "out", "local", "row", "unsigned", "ghost", "internal", " hex", "pure", "array", "dec", "pack", "ode", "stream", "missing", "block", "custom", "orig", "initial"]}}
{"id1": "8665649", "id2": "18693224", "code1": "    private BufferedImage _getImage(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.connect();\n        InputStream in = null;\n        try {\n            in = conn.getInputStream();\n            return ImageIO.read(in);\n        } finally {\n            IOUtilities.close(in);\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"_getImage": ["_readImage", "_getThumbnail", "_readThumbnail", "_parseImages", "_downloadThumbnail", "_parseThumbnail", "_downloadImages", "_parseimage", "_downloadImage", "_readImages", "_parseImage", "_getimage", "_downloadimage", "_getImages", "_readimage"], "urlStr": ["urlSTR", " urlString", "strStr", " urlstr", "imageSt", "fileSTR", "strString", "strstr", "urlSt", " urlSt", "imageSTR", "urlString", "imageText", "imagestr", "imageString", "fileSt", " urlSTR", "fileStr", "strText", "urlstr", "urlText", " urlText", "fileString", "imageStr"], "url": ["impl", "path", "ssl", "job", "loader", "server", "resource", "uri", "feed", "user", "http", "c", "l", "host", "URL", "fl", "client", "lc", "connection", "browser", "str", "ch", "r", "build", "config", "channel", "page", "object", "ll", "web", "log", "bb", "ls", "image", "blog", "sl", "rl", "Url", "www", "b", "f", "org", "loc"], "conn": ["impl", "Connection", "close", "ssl", "Conn", "n", "enc", "http", "con", "c", "socket", "act", "cb", "co", "rt", "ad", "nc", "sync", "client", "nt", "cp", "ct", "connection", "ch", "open", "conv", "out", "h", "ls", "ci", "exec", "pc", "ctx", "conf", "err", "connect", "cn", "cli", "cmd", "cur", "api"], "in": ["IN", "pin", "ssl", "i", "input", "ex", "n", "inas", "id", "token", "ini", "gin", "con", "c", "socket", "as", "inner", "ins", "s", "bin", "is", "reader", "source", "connection", "login", "min", "r", "inc", "data", "rin", "out", "null", "rec", "init", "again", "gz", "m", "ax", "image", "isin", "In", "nin", "pc", "fd", "kin", "stream", "b", "ac", "err", "cin", "inn", "f", "win", "din"]}}
{"id1": "804637", "id2": "15768167", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRebwrite", "readAndRebrap", "readAndRewwrite", "readAndSwrap", "readAndrewwrite", "readAndRebrite", "readandRewrap", "readandRewrites", "readAndSwwrite", "readandrewrap", "readAndRewrap", "readAndSwrite", "readandrewrites", "readandrewwrite", "readAndRebrites", "readAndRewrites", "readAndrewrite", "readAndSwrites", "readandrewrite", "readAndrewrites", "readAndrewrap", "readandRewwrite", "readandRewrite"], "inFile": [" inSourceFile", "InSourceFile", "oldfile", "outSourceFile", "inputfile", "outfile", " inFiles", "inputFilename", "InFiles", " infile", "infile", "inputFile", "outFiles", "oldFile", "loginFile", " inFilename", "Infile", "inFiles", "inputFiles", "oldFiles", "loginFilename", "loginfile", "loginFiles", "InFile", "oldFilename", "outFilename", "inFilename", "inSourceFile"], "outFile": ["newfile", "outDir", "OutStream", "processFile", "outputFilename", "exFilename", "outputfile", " outfile", "outPlace", "outFILE", "outputFILE", "outfile", "processFilename", "offFILE", "outputPlace", "thisFilename", "outStream", "thisFile", "processPlace", "exfile", "thisFILE", "newDir", "exFILE", "OutDir", "exFile", "processFILE", "newStream", "offPlace", "OutFile", " outStream", "outFilename", "offFilename", "Outfile", " outDir", "outputFile", "newFile", "thisfile", "offFile"], "iis": ["iIS", "Iais", "iIs", "iiris", "iniIs", "iiiss", "iais", "Iis", "ciis", "iiis", " iIs", " iIS", " iais", "ciiss", "Iiss", "ciais", " iiss", "iiss", "iiIS", "iniiss", " iris", "iniis", "ciris", "iniIS", "iniris", "IIS", "iris", "iiIs", "ciIS", "ciIs"], "dcmParser": ["dbmPolicy", "dbmParser", "dmmLoader", "dmissionParser", "dcmInstallation", "dmoduleJar", "dpmLoader", "dmoduleparser", "dhemReader", "dkmParser", "dmissionLanguage", "dCMPlugin", " dpmparser", " dcrParser", "fpmparser", "dhemJar", " dpmPolicy", "dkmPolicy", "dpmParser", "dcmPolicy", "dmissionPlugin", " dcmarser", "dmmPlugin", " dcrPlugin", "DcmInstallation", " dcmLanguage", "dpmHandler", "dmcJar", "dkmPlugin", " dpmParser", "dmoduleReader", " dcrLoader", "fcmReader", "dmissionReader", "dcrParser", "dmcarser", "dbmHelper", "dmLoader", "fpmHandler", "dcrarser", "dhemInstallation", "dmcParser", "dmmparser", "dpmLanguage", "dmodulePlugin", " dcmPolicy", "dpmarser", "dpmReader", "dcmPar", "dpmPar", "dmReader", "dcmparser", "dcrLoader", "dmParser", " dcmLoader", " dcmReader", "fcmparser", "dpmPolicy", "dcrJar", "dcmPlugin", "dpmparser", "fpmReader", "dcmarser", " dpmPlugin", "dbmPlugin", "dpmPlugin", " dpmHelper", "dCMLoader", " dpmLoader", " dpmJar", "dmoduleParser", " dcrReader", "dcmLoader", "fcmParser", "dpmHelper", "dcmReader", " dpmPar", "dCMHandler", "dmPlugin", "dcmJar", "dcrPlugin", "dpmJar", " dcmJar", "fcmHandler", " dcmHelper", "dCMparser", "dcrPar", "DcmParser", " dcmPar", "dcrReader", "fpmParser", " dpmReader", " dcmparser", "dmcPar", " dpmLanguage", "dcmHelper", "dpmInstallation", "dcmHandler", "dCMParser", "dcmLanguage", "dmmParser", "DcmReader", "dCMReader", "dkmHelper", " dcmPlugin", "DcmJar", "dhemParser", " dpmarser"], "ds": ["services", "ys", "uds", "ays", "DS", "iss", "gd", "sys", "Os", "df", "ants", "ns", "tes", "ks", "drivers", "qs", "bs", "s", "ins", "dr", "is", "dc", "rs", "ld", "dt", "parts", "cdn", "sync", "session", "ws", "d", "ros", "eps", "points", "icks", "ads", "data", "gs", "src", "xs", "utils", "vals", "ras", "Ds", "des", "ts", "conn", "vs", "ls", "js", "ss", "db", "ils", "di", "nas", "details", "amps", "Db", "da", "asi", "cs", "dds", "ps", "os", "dat", "pd", "dd", "tx"], "pdReader": ["hdRunner", "pbRunner", "pcReader", "pdRunner", "xdreader", "dsReader", "dsreader", "pbLoader", "hdReader", "hdreader", "dsLoader", "pcLoader", "pbStream", "hdStream", "ddStream", "pcRead", "xdWriter", "ddLoader", "pdLoader", "pdStream", "ddRunner", "pbReader", "hdWriter", "dsRead", "dsWriter", "xdRead", "pcWriter", "xdReader", "hdRead", "hdLoader", "ddReader", "pdreader", "pdRead"], "out": ["ssl", "base", "temp", "output", "net", "as", "s", "in", "at", "lib", "model", "default", "file", "gen", "conn", "Out", "url", "obj", "with", "external", "point", " in", "outer", "ex", "sys", "lock", "builder", "result", "later", "sync", "part", "cache", "up", "oder", "connection", "w", "parent", "store", "page", "object", "device", "again", "name", "exec", "exp", "array", "full", "over", "list", "order", "inner", "outs", "o", "line", "flow", "co", "write", "password", "session", "doc", "diff", "group", "director", "null", "dev", "io", "writer", "image", "to", "word", "cli", "term", "auto", "her", "copy", "user", "OUT", "child", "manager", "pass", "key", "client", "dot", "login", "inc", "down", "data", "db", "layer", "ext", "err", "code", "img"], "dcmEncParam": ["dcmEnParam", "dcmEstParam", "dcmDecParam", "dcmEnParameter", "dcmSecPart", "dcmDecType", "dcmDecPar", "dcmEncType", "dcmEncParameter", "dcmArchParam", "dcmEncPart", "dcmElParameter", "dcmEnPar", "dcmEnPart", "dcmDecArg", "dcmArchArg", "dcmArchParameter", "dcmSecPar", "dcmEnArg", "dcmDecParameter", "dcmDecPart", "dcmSecType", "dcmElParam", "dcmEstPar", "dcmEncPar", "dcmSecParam", "dcmElPar", "dcmEncArg", "dcmElType", "dcmEnType", "dcmEstType", "dcmEstParameter"], "pdWriter": ["dpWrite", "pdOutput", "ddWrite", "pdWriting", "htWriter", "dpReader", "dsReader", "hdReader", "pdWrite", "htWriting", "dpWriting", "PDWrite", "dpWriter", "hdWriter", "dsOutput", "dsWriter", "hdWrite", "htWrite", "PDWriter", "dsWrite", "ddOutput", "PDReader", "ddReader", "htReader", "PDWriting", "ddWriter", "hdOutput"]}}
{"id1": "22135199", "id2": "20019847", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": ["testCodingZeroFiles", "testCachingEmptyFile", "testCachingEmptyStream", "testCachingEmptyFiles", "testCodingEmptySourceFile", "testCodingOfStream", "testCodingNoStream", "testCachingOfStream", "testCodingZeroSourceFile", "testCodingOfSourceFile", "testCachingOfFiles", "testCodingNoFile", "testCodingNoSourceFile", "testCodingOfFile", "testCachingOfFile", "testCodingZeroStream", "testCodingOfFiles", "testCodingZeroFile", "testCodingEmptyStream", "testCodingNoFiles", "testCodingEmptyFiles", "testCachingOfSourceFile", "testCachingEmptySourceFile"], "baos": ["buo", "waoS", "Baoes", "baOs", "aaaaOs", "baoes", " baotes", "Baotes", "kao", "paOS", "aaaaOS", "biotes", " baoes", "baoa", "buoa", "kaos", "kaoa", "buOS", "waOs", " baoS", "bao", "kaOS", "bios", "bioes", "BaoS", "bioS", "BaOs", "paos", "aaaaoS", "buos", "paoa", "baoS", "aaaaos", "Baos", "waOS", "baOS", "BaOS", "waos", "pao", "baotes"], "channel": ["handler", "sc", "console", "feed", "self", "video", "server", "c", "system", "socket", "cam", "cho", "flow", "queue", "client", "an", "reader", "camera", "source", "connection", "ch", "chan", "group", "config", "data", "out", "Channel", "parent", "log", "context", "conn", "io", "annels", "sea", "url", "stream", "can", "container", "bean", "service"], "params": ["css", "Par", "cmp", "settings", "http", "cms", "proc", " parameters", "ams", "ops", "stats", "par", "Parameters", "parser", "config", "mm", "options", "cpu", "size", "null", "conn", "ctx", "processor", " param", "ps", "Param", "tx", "param", "api"], "outbuf": ["outbuff", "outbag", "inputbuf", "outputbag", "outputbuffer", "Outbuffer", "Outbuf", " outbuffer", "outputqueue", "outcb", "inputbag", "Outcb", "outputbuf", "Outbuff", " outqueue", "outbuffer", "inputbuff", " outcb", " outbuff", "outputbuff", "inputqueue", "outqueue", "outputcb", " outbag"], "metrics": ["Metras", "metrix", "metric", " metrix", "matrix", "matals", "metals", "monrics", "matric", "Metics", "Metals", "monras", " metric", "monics", "Metric", "metics", " metics", "Metrix", " metras", "metras", "matrics", "monric", " metals", "Metrics"], "encoder": ["ecoded", " encler", "enoder", "Encoded", "Encoder", " encoding", "Encoser", "ecode", " enccode", "Encipher", " encode", "encode", " encipher", "ecipher", "ecler", "encler", "enccode", "Encoding", "encipher", "eccode", "enressor", "ecressor", "Encler", "enoded", " encressor", "enode", " encoser", " encoded", "ecoder", "encressor", "enoser", "Encode", "ecoding", "encoded", "encoding", "encoser", "ecoser"], "tmpFile": ["poraryFile", "mpFile", "testFolder", " tmpPath", " tmpfile", "mpFilename", "mpfile", "tmpFunction", "txtFile", " tmpFiles", "mpPath", "testfile", "vtDir", "txtfile", " tmpDir", "testFiles", "mpFunction", "mpPage", "tempPath", "poraryPage", "tmpfile", "poraryfile", "txtFunction", "txtPage", "mpDir", "mpFiles", "vtfile", "tmpFolder", "vtFilename", " tmpFolder", "tmpFilename", "tmpFiles", "tmpDir", "tmpPage", "tempfile", "tempFile", "tempFolder", " tmpFilename", "tempFiles", "poraryFunction", "vtFile", "tmpPath", "testFile"], "fout": ["frout", "Fchannel", " ffile", "frurl", "fdout", "flagain", "fdwrite", "frwrite", "Ffile", "sfio", "furl", "sfchannel", "flwrite", "fdurl", "Fio", "fdagain", "sfout", "flout", " fio", "fio", "Fout", "sffile", "fwrite", "flurl", "fragain", "fagain", "ffile"], "wrtout": ["wrcOut", "wrdwriter", " wrcout", " wrcouter", "wrcn", "wadrwriter", "wrcouter", "wrtwriter", "wrin", "wrtn", "Wrtn", "wadragain", "wrdout", "wRTagain", "WRTin", "wRTOut", "wRTout", " wrtagain", "wRTwriter", "wRTin", "wRTouter", "wrtin", "WRTOut", "WrtOut", " wrcagain", "Wrtwriter", " wrtin", "wrtouter", "wRTn", "wrdouter", "wrcout", "wadrouter", "wrdin", "wrtOut", "wrn", "Wrtin", "WRTwriter", "wrout", "wrcin", "wrtagain", "WRTout", "Wrtout", " wrtouter", "wadrout", " wrcin", "wrcagain", "Wrtouter", "WRTouter", "wadrin", "WRTn", "wrOut"], "fchannel": ["bchannel", "fenchannel", "fcontainer", "fstream", "fconn", "fenresource", "pchan", "hqueue", "fresource", "pchannel", "pconn", "fenqueue", "fchan", "fqueue", " fcontainer", " fconn", "pqueue", " fchan", "hresource", "fenstream", "pstream", "hstream", "pcontainer", "bcontainer", "presource", "bchan", "hchannel", "bconn"], "s": ["services", "string", "i", "n", "settings", "ns", "c", "S", "o", "qs", "ins", "abs", "l", "su", "ms", "ings", "states", "strings", "r", "g", "gs", "p", "es", "u", "ts", "ls", "js", "m", "e", "t", "ss", "ses", "b", "v", "os", "ps", "f"]}}
{"id1": "6304373", "id2": "8788371", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrMempl", "uploadOrDeleteMediaOrTemplateporary", "uploadOrDeleteMediaOrTemFiles", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrTemplateplates", "uploadOrDeleteMediaOrtempl", "uploadOrDeleteMediaOrMemporary", "uploadOrDeleteMediaOrtemplates", "uploadOrDeleteMediaOrMemFiles", "uploadOrDeleteMediaOrTemplatepl", "uploadOrDeleteMediaOrtemFiles", "uploadOrDeleteMediaOrTemplateFiles", "uploadOrDeleteMediaOrtemporary", "uploadOrDeleteMediaOrTemporary", "uploadOrDeleteMediaOrMemplates"], "action": ["event", "error", "resource", "element", "lock", "now", "site", "act", "version", "ction", "activation", "flow", "active", "next", "ACTION", "what", "part", "type", "operation", "activity", "item", "section", "parent", "flash", "environment", "style", "plugin", "format", "test", "effect", "name", "change", "status", "controller", "function", "call", "commit", "actions", "url", "Action", "state", "step", "method", "module", "service", "api", "view"], "object": ["directory", "article", "event", "string", "address", "class", "node", "letter", "self", "resource", "lock", "ject", "now", "subject", "document", "version", "project", "system", "current", "mode", "o", "instance", "number", "host", "thread", "zone", "part", "email", "not", "target", "module", "model", "group", "none", "parent", "objects", "oid", "environment", "request", "edit", "image", "function", "full", "url", "obj", "office", "element", "service", "auto"], "numElements": [" numElem", "numEllement", "numEllem", "numelem", "numelement", " numEodes", "numEllements", "numGelement", "numGelements", "numeodes", "numGeodes", " numeodes", " numelement", "numelements", "numElem", " numelem", "numEodes", "numGelem", "numElodes", " numelements"], "req": ["base", "builder", "report", "res", "html", "ro", "mr", "usr", "util", "next", "params", "use", "load", "resp", "r", "g", "parent", "log", "verb", "msg", "gr", "ctx", "update", "conf", "err", "obj", "xml", "module"], "session": ["event", "ession", "temp", "resource", "response", "token", "lock", "http", "site", "document", "subject", "system", "result", "instance", "global", "thread", "manager", "security", "client", "sa", "cache", "use", "connection", "browser", "scope", "shared", "local", "request", "flash", "h", "context", "Session", "test", "image", "person", "ctx", "ESSION", "sp", "container", "state", "service"], "ftp": ["FTp", " ftcp", "ftcp", "FTP", "ftP", "ftc", "ttc", " ftP", "ttP", " ftc", "FTc", "FTcp", "ttp", "ttcp"], "user": ["string", "info", "path", "base", "class", "self", "ee", "username", "lock", "by", "mail", "USER", "profile", "author", "per", "User", "project", "result", "system", "account", "html", "admin", "current", "match", "record", "pass", "usr", "post", "er", "client", "type", "use", "users", "rule", "member", "facebook", "connection", "browser", "module", "other", "group", "shared", "config", "data", "used", "parent", "usa", "page", "log", "creator", "name", "e", "image", "home", "db", "person", "full", "ver", "url", "bug", "auth", "comment", "state", "error", "custom", "this", "hash", "view"], "links": ["base", "headers", "Link", "pages", "results", "mail", "posts", "html", "styles", "ids", "linked", "items", "email", "lines", "members", "images", "flash", "log", "groups", "Links", "tree", "image", "link", "details", "actions", "mails", "url", "menu"], "folders": ["anchers", "anchors", "handries", "filors", "handers", "filages", "filers", "handages", "filries", "foldages", "anchries", "handors", "foldries", "anchages", "foldors"], "folder": ["directory", "zip", "path", "letter", "address", "editor", "uri", "resource", "id", "division", "document", "filename", "slice", "project", "volume", "location", "layout", "zone", "database", "two", "picture", "email", "fold", "source", "dir", "connection", "scope", "upload", "sample", "level", "archive", "flat", "region", "ignore", "append", "device", "plugin", "home", "area", "theme", "layer", "url", "future", "Folder", "command", "network", "menu", "element", "license", "enter"], "server": ["directory", "string", "remote", "ssl", "address", "node", "resource", "uri", "username", "outer", "token", "master", "Server", "site", "filename", "version", "socket", "slave", "system", "inner", "account", "location", "host", "manager", "database", "client", "email", "type", "source", "reader", "seed", "connection", "value", "page", "device", "status", "port", "erver", "url", "ser", "localhost", "peer", "network", "scale", "engine", "service", "enter"], "login": ["string", "path", "info", "pin", "ssl", "resource", "skin", "username", "lock", "sudo", "mail", "site", "bridge", "filename", "profile", "socket", "account", "shell", "layout", "pass", "database", "picture", "email", "users", "connection", "Login", "group", "machine", "config", "journal", "log", "plugin", "name", "status", "blank", "blog", "label", "access", "url", "auth", "secret", "consumer", "cookie", "network", "basic", "service"], "password": ["directory", "string", "token", "username", "mask", "timeout", "sudo", "division", "filename", "profile", "slave", "volume", "account", "manager", "pass", "database", "pattern", " passwords", "picture", "security", "Password", "email", "PASS", "connection", "alias", "sword", "language", "device", "plugin", "name", "ass", "word", "worker", "access", "strip", "photo", "secret", "auth", "cookie", "padding", "basic", "phrase", "column"], "fileTransferFolder": ["fileTransferPath", "FileUploadfolder", "mediaTransferFolder", "fileUploadTheme", "fileImportFolder", "fileAccessFolder", "fileImportServer", "fileUploadPath", "fileTransferfolder", "mediaUploadServer", "fileTransformPath", "FileTransferPath", "fileUploadServer", "fileTransferServer", "mediaUploadfolder", "FileTransferTheme", "FileUploadFolder", "fileTransformfolder", "fileUploadfolder", "fileTransferTheme", "mediaTransferfolder", "FileUploadPath", "mediaUploadDirectory", "FileUploadTheme", "fileUploadDirectory", "fileImportfolder", "fileUploadFolder", "mediaTransferDirectory", "fileImportDirectory", "fileTransferDirectory", "fileAccessfolder", "FileTransferfolder", "fileAccessPath", "fileTransformFolder", "fileAccessTheme", "FileTransferFolder", "mediaUploadFolder", "fileTransformTheme", "mediaTransferServer"], "liveFolder": ["PreviewLocation", " liveDirectory", "PreviewFolder", "Livefolder", "PreviewDirectory", "Previewfolder", "livefolder", "LiveLocation", "LiveFolder", "LiveDirectory", " livefolder", "liveDirectory", "liveLocation", " liveLocation"], "servers": ["serServer", "servations", " serls", "serls", "servServer", "Serations", "SerServer", " serations", "Servers", "serations", "servls", " serServer", "servvers", "Serls"], "message": ["string", "path", "address", "buffer", "mess", " messages", "response", "resource", "mail", "document", "description", "manager", "content", "email", "member", "module", "application", "body", "page", "request", "flash", "Message", "log", "msg", "header", "status", "image", "array", "details", "url", "update", "summary", "error", "element", "menu"]}}
{"id1": "1180878", "id2": "7149578", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchJSONdata", "fetchUrlDATA", "fetchUrldata", "fetchHTTPData", "fetchUrlData", "frieveUrlData", "fetchHTTPDATA", "fetchURLdata", "frieveUrldata", "fetchJSONDATA", "fetchURLDATA", "frieveURLDATA", "frieveURLData", "fetchJSONData", "fetchHTTPdata", "frieveUrlDATA", "frieveURLdata"], "url": ["string", "path", "address", "base", "ssl", "server", "uri", "resource", "username", "feed", "user", "http", "filename", "html", "l", "host", "location", "URL", "el", "fl", "source", "connection", "data", "file", "text", "src", "page", "href", "name", "ls", "image", "sl", "Url", "www", "ur", "xml", "download", "f", "gl", "api", "view", "loc"], "proxyHost": ["serverHost", " proxyAddress", "ProxyAddress", "ProxyHost", " proxyhost", "proxyServer", "serverServer", "proxyPath", "ProxyDomain", "remoteDomain", "Proxyhost", "baseHead", "serverPath", "remoteHead", "cacheAddress", "baseHost", "proxyAddress", " proxyPath", "proxyhost", "proxyDomain", "ProxyServer", "ProxyPort", " proxyServer", "cacheHost", "remoteAddress", "cachehost", "baseAddress", "proxyHead", "remoteHost", "cachePort", "serverAddress", "baseDomain", "ProxyPath", "ProxyHead"], "proxyPort": [" proxyAddress", "httpAddress", "httpServer", "ProxyAddress", "cacheport", "ProxyHost", "proxyServer", "proxyport", "httpPort", "Proxyport", "cacheAddress", "proxyAddress", "ProxyServer", "ProxyPort", "cacheHost", " proxyServer", "cachePort", " proxyport", "httpHost"], "con": ["pin", "fa", "fan", "cf", "http", "ran", "pre", "on", "fc", "run", "func", "en", "an", "cm", "cp", "uc", "common", "open", "conv", "xc", "gen", "conn", "ci", "don", "cn", "fun", "cc", "rc", "pub", "Con", "fl", "sync", "part", "ocon", "cache", "connection", "min", "ch", "un", "cl", "ai", "exec", "cr", "mc", "can", "connect", "win", "remote", "close", "n", "canon", "cons", "act", "per", "socket", "sub", "co", "syn", "ca", "go", "cone", "change", "ver", "bc", "ac", "cur", "CON", "c", "ctrl", "ec", "cas", "login", "inc", "out", "x", "rec", "ls", "pc", "pen", "com", "conf", "f", "fac", "re"], "is": ["info", "bis", "i", "iss", "lis", "serv", "fs", "IS", "id", "isa", "ie", "Is", "act", "as", "ri", "s", "bs", "abs", "si", "il", "does", "in", "ori", "isl", "cms", "its", "ws", "was", "ops", "ais", "isc", "ir", "out", "get", "p", "es", "has", "conn", "iso", "or", "ai", "ris", "js", "vs", "ci", "oss", "ics", "it", "isin", "iris", "ios", "us", "ib", "isi", "can", "are", "sp", "cs", "state", "os", "ps", "isu", "ar", "im", "api", "cos", "mis"], "u": ["U", "cu", "ou", "i", "lu", "uri", "user", "http", "uv", "ue", "c", "ru", "o", "l", "ui", "su", "client", "fu", "uc", "up", "q", "ut", "un", "tu", "file", "h", "p", "conn", "hu", "m", "io", "uci", "us", "ur", "b", "v", "yu", "ul", "iu", "os", "f", "nu", "api"], "proxy": ["zip", "remote", "address", "ssl", "pin", "fe", "server", "uri", "copy", "plus", "resource", "timeout", "http", "pse", "c", "socket", "l", "host", "pool", "prot", "clone", "client", "cop", "roxy", "type", "cache", " Proxy", "lib", "connection", "config", "phone", "web", "ip", "x", "p", "XY", "force", "port", "xy", "Proxy", "pc", "pe", "pa", "create", "shadow", "wrapper", " proxies", "f", "bean", "api"], "baos": ["Bais", "BAos", "baOs", "abros", "balos", "pais", "bolos", "caOS", "BAOS", "bais", "haOS", "hao", "baas", "boOS", "paOS", "boas", "BAros", "baros", "aas", "BAis", "BAo", "hais", "BAOs", "alos", "haos", "abOs", "abos", "bao", "aos", "calos", "BaOs", "paos", "abis", "caos", "aOS", "Baros", "caas", "Baos", "baOS", "boos", "pao"]}}
{"id1": "14390569", "id2": "7908169", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"title": ["string", "id", "resource", "itle", "subject", "message", "filename", "description", "version", "html", "layout", "chapter", "alpha", "content", " Title", "part", "type", "license", "section", "data", "text", "body", "itles", "page", "size", "ppa", "format", "msg", "name", "TIT", "header", "desc", "image", "heading", "label", "prefix", "details", "notes", "theme", "url", "summary", "Title", "phrase", "term"], "imageURL": ["fileurl", " imageURI", "fileUrl", "ImageURL", "pictureurl", "pictureURL", "mediaUrl", "fileURL", "ImageUrl", "imgURL", "filePath", " imageUrl", " imageurl", "mediaURL", "imgURI", "fileURI", "pictureURI", "ImagePath", "imagePath", "imageUrl", "mediaURI", "pictureUrl", "imgPath", "imageURI", "ImageURI", "imageurl", "imgUrl"], "jd": ["zdd", "ajdo", "ajb", "jobb", "jdh", "ajdos", " jdom", "jobdo", "jds", " jdd", "argdo", "adjb", "ajD", "jobd", "ssdo", "qd", "argf", "ze", "ssd", "zl", "ssdi", " jdh", "jdd", "jD", "Jdos", "Jf", "Jdo", "jsb", " jds", " jD", " jf", "jdom", " jdo", "jdo", "Je", "jackd", "zb", " jdl", "jackf", "JD", "Jdom", "ajdi", "Jl", "qb", "Jds", "ajf", "jjdh", "qdh", "Jb", "jackdd", "zdo", "jdl", "jf", "argdl", "jdos", "adjdos", " jdi", "adjdo", "ssD", "jdi", "jjd", "zd", "jsdh", " je", "qdo", "ajdh", "jsd", "ajd", "jsdo", "qdom", "jjb", "Jd", "jjdo", "je", "jobD", "zds", "adjd", "jackb", "zf", "argd", "ajdl"], "jl": ["uj", "lu", "lf", "iji", "kl", "NJ", "dj", "lp", "jc", "lb", "wl", "j", "eb", "iol", "fp", "l", "il", "elly", "el", "ld", "hl", "dl", "elt", "syn", "ja", "ji", "oji", "bj", "li", "nl", "ll", "cli", "jon", "jj", "igl", "chal", "bn", "Label", "kj", "label", "zl", "bl", "kel", "JM", "adj", "vd", "lv", "kn"], "icon": [" image", "info", "core", "css", "eye", "n", "token", "note", "resource", "uri", "on", "ic", "fc", "ui", "content", "picture", "ion", "iao", "alias", "Icon", "text", "gn", "img", "pic", " Icon", "size", "plugin", "uni", "bn", "header", "io", "image", "icons", "ann", "action", "label", "artist", "ico", "url", "cn", "png", "cha"], "chooser": ["close", "boosen", "jooses", "Choosen", "Choer", "jooder", " choressor", "jooser", "boressor", "choressor", "Chooser", "choosen", "dialer", "choer", "dialoser", " chooses", "Chooses", "closen", "cler", "dialose", "boose", "choose", "booser", "chooses", " chooder", "Choose", " choose", "clressor", "dialosen", " choosen", "chooder", "joose", "closer", "Chooder"], "jp": [" j", " tmp", " pa", " JM", "j", " pane", "Panel", " ax", " obj", " plugin", "ja", "ji", " dj", " cm", "bj", " js", " cp", " app", " bar", " bridge", " je", " gp", " np", " pic", " sp", " mp", " dock", "JP", " robot"], "jb": ["ajf", " jsb", "ajb", "jsbb", "jf", "djcb", "jcb", "jsb", "qsb", "jbb", " jf", " jbb", "ajsb", "ajcb", "djb", "qcb", "jsd", "djbb", "qf", "djd", " jcb", "qb", "jscb"], "e": ["event", "ee", "ie", "c", "et", "te", "ception", "in", "ec", "ce", "je", "de", "exc", " E", "x", " ate", "ae", "E", "t", " fe", "ctx", "a", "ev", "pe", "v", " Event", "f"], "returnVal": ["ReturnVal", " returnVAL", "replyval", "replyValue", "resultVal", "replyVAL", "ReturnValue", "returnValue", "returnVAL", "resultNum", " returnNum", "resultval", "ReturnVAL", "replyVal", "resultValue", "returnNum", "returnval", " returnValue", "Returnval", "ReturnNum", " returnval"], "file": ["zip", "base", "handler", "http", "document", "picture", "die", "rule", "lib", "model", "build", "get", "force", "files", "url", "comment", "module", "info", "buffer", "lock", "part", "use", "load", "binary", "dir", "live", "work", "parent", "page", "object", "name", "full", "unit", "b", "play", "letter", "path", "directory", "core", "ile", "message", "line", "File", "queue", "book", "show", "body", "image", "io", "function", "future", "auto", "single", "ban", "user", "filename", "fp", "l", "il", "pool", "type", "FILE", "data", "out", "local", "log", "folder", "po", "home", "db", "pe", "parse", "f"], "fileName": ["imagename", "FilePath", "binaryName", "resourceName", "fileUrl", "resourceInfo", "filename", "filePath", "singleInfo", "fileInfo", "fileType", "resourcename", " fileType", " filename", "Filename", "binaryUrl", "singlePath", " filePath", " fileInfo", "binaryPath", "FileType", " fileUrl", "FileInfo", "imagePath", "singleName", "singlename", "imageUrl", "singleType", "resourcePath", "FileName", "imageName", "imageInfo"], "ext": ["xt", "EXT", "path", " extension", "class", "qt", "ex", "ace", "enc", "oct", "version", "eng", "feat", "extra", "txt", "xp", "type", "lib", "ct", "ch", "ension", "fb", "p", "Ext", "format", "name", "desc", "ax", "t", "exp", "word", "alg", " Ext", "pe", "abc", "v", "obj", "f", "phrase", "sec", "orig"], "i": ["info", "bis", "id", "uri", "pi", "ini", "c", "j", "z", "ri", "o", "si", "ui", "is", "ii", "ment", "ti", "phi", "ion", "li", "ip", "mi", "p", "bi", "u", "ai", "ci", "I", "io", "m", "xi", "gi", "di", "a", "v", "y", "ni", "b", "iu", "multi", "mini", "cli", "api"], "doIt": [" doNot", " doit", "hoIt", "doit", " doYou", " doIT", " doWhich", "addNot", "diIt", "skipit", "hoYou", "doIts", "odoIt", "skipIts", "skipIt", "addit", "poIt", "diit", "DOIT", "odoit", "doWhich", "odoIT", "odoWhich", "doIT", " doIts", "DOWhich", "hoit", "poIT", "doYou", "hoIT", "skipIT", "diIts", "DOit", "doNot", "DOIt", "diIT", "addIt", "addIT", "odoNot", "poit", "poYou"], "src": ["impl", "path", "rest", "sel", "ssl", "sc", "input", "cmp", "rc", "slice", "socket", "rel", "fi", "cb", "loc", "fc", "sub", "ff", "ources", "inst", "rs", "split", "gb", "sync", "cdn", "rb", "source", "sb", "uc", "target", "buf", "dist", "r", "upload", "conv", "attr", "tmp", "Dest", "bb", "sq", "storage", "desc", "gz", "sth", "rx", "sup", "sl", "secure", "ctx", "pull", "url", "bc", "us", "stream", "b", "st", "sn", "cur", "ource", "RC", "cos", "img"], "dest": ["rest", "output", "gd", "uv", "cont", "later", "destroy", "trans", "wd", "done", "inst", "dc", "usr", " Dest", "std", "exit", "die", "comb", "cdn", "source", "proc", "wb", "dir", "ctr", "uc", "target", "dist", "config", "route", "Dest", "tmp", "img", "gen", "desc", "dev", "home", "sup", "di", "dep", "prop", "st", "dat", "loc"]}}
{"id1": "15516136", "id2": "20568568", "code1": "    public static synchronized BufferedImage loadBufferedJPEGImage(URL url) {\n        BufferedImage image = null;\n        if (url != null) {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(in);\n                image = decoder.decodeAsBufferedImage();\n            } catch (Exception e) {\n                log.severe(\"URL: \" + url + \" - \" + e.getMessage());\n                image = null;\n            } finally {\n                try {\n                    if (in != null) in.close();\n                } catch (IOException ioe) {\n                    log.severe(\"URL: \" + url + \" - \" + ioe.getMessage());\n                }\n            }\n            if (image != null) {\n                log.config(\"Image type : \" + image.getType());\n                if (image.getWidth() <= 0 || image.getHeight() <= 0) {\n                    log.severe(\"URL: \" + url + \" =0\");\n                    image = null;\n                }\n            }\n        }\n        return image;\n    }\n", "code2": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"loadBufferedJPEGImage": ["loadBufferedJPNGMedia", "loadBufferedJPEGMedia", "loadBufferedMPPGMedia", "loadBufferedJPELFile", "loadBufferedMPEGMedia", "loadBufferedMPEGimage", "loadBufferedJPEGimage", "loadBufferedJPELMedia", "loadBufferedMPEGFile", "loadBufferedJPNGFile", "loadBufferedMPEGImage", "loadBufferedMPPGImage", "loadBufferedJPPGImage", "loadBufferedJPPGMedia", "loadBufferedMPPGFile", "loadBufferedMPPGimage", "loadBufferedJPNGimage", "loadBufferedJPPGimage", "loadBufferedJPELImage", "loadBufferedJPEGFile", "loadBufferedJPPGFile", "loadBufferedJPNGImage", "loadBufferedJPELimage"], "url": ["play", "path", "string", "address", "buffer", "loader", "base", "ssl", "server", "uri", "resource", "feed", "job", "id", "http", "remote", "filename", "ref", "location", "l", "large", "URL", "host", "el", "dl", "email", "source", "rule", "connection", "media", "alt", "config", "data", "file", "src", "page", "object", "ll", "bb", "log", "href", "style", "name", "coll", "blog", "link", "sl", "mount", "Url", "layer", "www", "stream", "pull", "ur", "xml", "found", "f", "gl", "service", "download", "loc"], "image": ["zip", "pin", "eye", "output", "resource", "ini", "document", "large", "database", "Image", "picture", "cm", "thin", "cover", "model", "default", "build", "file", "archive", "bug", "container", "xml", "element", "jpg", "info", "audio", "game", "site", "result", "ui", "icon", "source", "cache", "up", "connection", "value", "ami", "work", "parent", "page", "object", "pixel", "job", "i", "video", "message", "slice", "inner", "show", "upload", "p", "issue", "m", "available", "gallery", "position", "photo", "shadow", "error", "im", "api", "auto", "view", "copy", "instance", "manager", "hole", "media", "pm", "feature", "config", "data", "out", "size", "layer", "figure", "age", "gif", "f", "img"], "in": ["IN", "impl", "pin", "ssl", "i", "input", "ex", "n", "id", "inas", "cf", "serv", "ini", "gin", "con", "c", "socket", "inner", "l", "ins", "el", "bin", "pass", "is", "part", "source", "reader", "doc", "login", "min", "inside", "r", "inc", "data", "rin", "out", "file", "fb", "conn", "init", "or", "again", "m", "ax", "isin", "In", "nin", "kin", "a", "fd", "stream", "err", "b", "ac", "container", "cin", "xml", "inn", "f", "win", "din"], "decoder": ["decoded", "deode", "Decoded", "deenter", "recoder", "Decoding", " decode", "Decenter", "recode", "encode", "decoding", " decoded", "decenter", "recenter", "deoding", "recoding", "Decode", "deoder", "encoder", "decode", " decoding", "encoded", "encoding", "Decoder"]}}
{"id1": "3046085", "id2": "3252116", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "label": 1, "substitutes": {"s": ["services", "string", "path", "i", "n", "speech", "ns", "S", "is", "joined", "in", "content", "params", "parts", "source", "sb", "strings", "str", "r", "g", "w", "sample", "data", "text", "gs", "p", "es", "south", "name", "e", "m", "sets", "t", "ss", "a", "ses", "b", "v", "sound", "f"], "tokenizer": ["tunzer", " tokenener", "generize", "tunner", "finize", "tokenize", " tokenized", "initialize", "okeniser", "okenister", "tokenizable", "finizer", "Tokenizers", "initialization", "normalize", "initialiser", "tokenized", " tokenner", "okenizer", "initialiner", "statizers", " tokenization", " tokenize", " tokenator", "okenizable", "tokenizers", "normalizer", "okenizers", "finer", "tunizer", "Tokenize", "optiminer", "generiser", " tokenzer", "okenator", "Tokenizable", "Tokenizer", "logize", " tokenizers", "okenzer", "tokeniner", "logizer", "Tokeniser", "optimizer", "tokenzer", "tokenister", "initializable", "widgetizable", "optimiser", "okenize", "tokeniser", "tuner", "statator", "Tokener", "normalizable", "tokenner", "statiter", "okeniter", "widgetiser", " tokenizable", "tokenener", "Tokenister", "tokenization", " tokener", " tokeniter", "logizable", "tokener", "okenization", "statizer", "tokeniter", "okenner", " tokeniser", "toolizable", "generized", "tooliner", "Tokeniner", "toolize", "okeniner", "Tokenized", "tokenator", "generizer", "initializer", "normaliner", " tokenister", "loginer", "widgetizer", "toolizer", "Tokenener", "finizable", "okener", "optimizable", "okenener", "widgetiner"], "title": ["string", "song", "audio", "album", "resource", "editor", "username", "author", "description", "profile", "filename", "tag", "meta", "owner", "company", "type", "source", "art", "media", "genre", "data", "text", "metadata", "format", "name", "label", "prefix", "theme", "layer", "team", "url", "bot", "summary", "music", "Title", "license"], "artist": ["song", "audio", "album", "video", "username", "master", "author", "filename", "track", "patch", "tag", "source", "player", "cover", "art", "target", "media", "genre", "alias", "archive", "metadata", "creator", "episode", "Artist", "image", "chart", " artists", "theme", "prefix", "layer", "photo", "music", "piece", "season", "voice", "winner"], "location": ["path", "address", "audio", "lang", "album", "message", "description", "length", "tag", "layout", "time", "content", "media", "region", "level", "language", "motion", "image", "gallery", "area", "mobile", "layer", "position", "url", "theme", "photo", "Location", "loc"], "rating": ["training", "audio", "album", "game", "description", "rank", "weight", "sharing", "alpha", "score", "rate", "tracking", "fps", "live", "scoring", "ranking", "media", "breaking", "genre", "boarding", "style", "playing", "rising", "resolution", "random", "repeat", "padding", "season"], "overplay": ["oplay", "opledge", "reledge", "overload", "opplay", "offlay", "offplay", "overledge", "offledge", "offload", "replay", "reload", "opload", "relay", "overlay"], "temp": ["string", "path", "base", " tmp", "tc", "original", "message", "sequence", "current", "track", "loc", "Temp", "tag", "layout", "content", "txt", "part", "type", "source", "cache", "media", "str", "testing", "data", "flat", "tmp", "body", "fake", "empty", "style", "format", "test", "name", "template", "stable", "font", "prefix", "unit", " temporary", "partial", "music", "stage", "pt", "list", "emp"], "tags": ["tracks", "products", "archives", "resources", "comments", "features", "assets", "styles", "modules", "reports", "ids", "terms", "users", "bugs", "strings", "stats", "names", "images", "Tags", "plugins", "authors", "phones", "stars", "bots", "thumbnails", "tests", "videos", "types", "packages", "notes", "files", "relations", "dates", "fields", "words", "events", "sections", "properties"], "bytes": ["keys", "balls", "fee", "pages", "pieces", "gets", "tes", "comments", "les", "outs", "errors", "params", "parts", "articles", "lines", "strings", "blocks", "bps", "data", "body", "objects", "ips", "size", "es", "Bytes", "videos", "seconds", "notes", "values", "files", "units", "words", "bits", "codes", "letters"], "hasher": ["hashr", "hanest", "haveher", "haveer", "Haser", "hashest", "Hasher", "hashher", "hadhandler", "hashers", "haser", "hanhr", "Hasest", "hashhandler", " hashed", "haner", "hahed", "haest", "hanher", " haser", "hashed", " hashers", "haveest", "havehr", "hasumper", "hadher", "hashandler", "haher", "hadest", "Hashed", "Hashers", "havehandler", "hashumper", "hasest", "haer", "hahers", "haveumper", "hadumper", " hasest", " hashr"]}}
{"id1": "22022715", "id2": "5723876", "code1": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"digest": ["Digester", "dit", "doit", "dger", "dest", "generester", " digested", "Digure", "generger", "digit", "genester", "mdit", "genested", "mdest", "Digests", "doest", "mdested", "digester", "digests", "digested", "mdester", "Digit", "digger", "dester", "Digest", "digure", "doested", "mdger", "doure", " digester", "genest", " digests", "Digested", "generit", "generest", "genests", "mdure"], "s": ["services", "string", "ssl", "i", "n", "ns", "message", "c", "S", "is", "ms", "rs", "password", "params", "ws", "d", "lines", "sb", "source", "strings", "g", "data", "gs", "p", "es", "ls", "m", "e", "ss", "sym", "bytes", "a", "ses", "b", "ds", "words", "os", "ps", "f"], "ret": ["val", "xt", "info", "fun", "Ret", "bf", "replace", "mem", "continue", "res", "result", "match", "arg", "rt", "pass", "key", "std", "pat", "arr", "nt", "Return", "value", "alt", "default", "data", "rets", "out", "al", "reply", "addr", "hash", "array", "success", "rev", "ext", "secret", "obj", "det", "def", "RET", "repl", "re", "valid"], "md": ["pkg", "um", "editor", "gd", "mag", "bd", "od", "df", "arm", "Cmd", "amd", "mo", "ind", "ma", "cb", "am", "meta", "wd", "MD", " MD", "rpm", "ad", "mb", "mt", "mac", "d", "mp", "hd", "pm", "pd", "mm", "metadata", "cd", "dig", "m", "dm", "mand", "mc", "di", "nm", "mod", "me", "mg", "mad", "cmd", "dd", "pg"]}}
{"id1": "3375722", "id2": "14194234", "code1": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private String File2String(String directory, String filename) {\n        String line;\n        InputStream in = null;\n        try {\n            File f = new File(filename);\n            System.out.println(\"File On:>>>>>>>>>> \" + f.getCanonicalPath());\n            in = new FileInputStream(f);\n        } catch (FileNotFoundException ex) {\n            in = null;\n        } catch (IOException ex) {\n            in = null;\n        }\n        try {\n            if (in == null) {\n                filename = directory + \"/\" + filename;\n                java.net.URL urlFile = ClassLoader.getSystemResource(filename);\n                if (urlFile == null) {\n                    System.out.println(\"Integrated Chips list file not found: \" + filename);\n                    System.exit(-1);\n                }\n                in = urlFile.openStream();\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            StringBuffer xmlText = new StringBuffer();\n            while ((line = reader.readLine()) != null) {\n                xmlText.append(line);\n            }\n            reader.close();\n            return xmlText.toString();\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"Integrated Chips list file not found\");\n            System.exit(-1);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"importarSetor": [" importTarSetor", " importTarsetor", " importarSetorn", " importarsetor", " importarProcessutor", " importTarsetutor", " importTarsetori", " importarSetori", " importarsetutor", " importarStructor", " importarStructori", " importarSetutor", " importTarSetorn", " importarProcessor", " importTarSetori", " importTarsetorn", " importarsetori", " importarStructutor", " importarProcessorn", " importarsetorn", " importarProcessori", " importarStructorn", " importTarSetutor"], "pArquivoXLS": ["pArquivaXSL", "pArquivaEXLS", "pArquivaXCL", "pArquivoXls", "pArquivoZXls", "pArquivoEXLS", "pArquivaXML", "pArquivoXCL", "pArquivoEXls", "pArquivoYCL", "pArquivaEXSL", "pArquivaEXCL", "pArquivoEXML", "pArquivoTXls", "pArquivoYML", "pArquivoXML", "pArquivoTXSL", "pArquivoTXLS", "pArquivoTXCL", "pArquivaXls", "pArquivoEXSL", "pArquivoZXML", "pArquivoYLS", "pArquivaEXML", "pArquivaXLS", "pArquivaEXls", "pArquivoEXCL", "pArquivoZXLS", "pArquivoTXML", "pArquivoXSL", "pArquivoZXSL", "pArquivoYls"], "pCabecalhoSetor": ["pCabecalhaSelector", "pCabecalhaSelecte", "pCabecalhoEditors", "pCabecalhoEditor", "pCabecalhoSelecteur", "pCabecalhoSelecte", "pCabecalhaSete", "pCabecalhaSetor", "pCabecalhoSete", "pCabecalhaSeteur", "pCabecalhoSeteur", "pCabecalhoSetors", "pCabecalhaSetors", "pCabecalhoSelectors", "pCabecalhoEdite", "pCabecalhaSelectors", "pCabecalhoSelector", "pCabecalhaSelecteur", "pCabecalhoEditeur"], "pAndamento": ["pAndietO", "pOremento", "pAndmentO", "pAndieto", "pOramentono", "pAndmentono", "pOrementO", "pOramentos", "pAndamentos", "pAndementos", "pAndmentos", "pAndemento", "pOrementos", "pAndietono", "pOramentO", "pOramento", "pAndamentono", "pAndamentO", "pAndementono", "pAndementO", "pAndietos", "pAndmento", "pOrementono"], "iLinha": ["NumPlanya", "iFranHa", "NumLinya", "NumPlaneno", "NumLinha", "iMalya", "iLinHa", "iPlanya", "iMaleno", "NumPlanha", "iMalHa", "iPlaneno", "iLinya", "iMalha", "NumLineno", "iFranya", "NumLinHa", "iPlanHa", "iFraneno", "iLineno", "NumPlanHa", "iFranha", "iPlanha"], "stmtLimpezaInicialDestino": ["stmtLimpezaIniciadestaco", "stmtLimpezaIniciodestania", "stmtLimpezaInicialESTino", "stmtLimpezaInicialCombaco", "stmtLimpezaInicioDestina", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialdestination", "stmtLimpezaInicialDestina", "stmtLimpezaIniciodestino", "stmtLimpezaIniciodestaco", "stmtLimpezaIniciadestino", "stmtLimpezaInicialdestINO", "stmtLimpezaInicialdestaco", "stmtLimpezaInicialESTination", "stmtLimpezaInicialDestaco", "stmtLimpezaInicialdestina", "stmtLimpezaInicialdestin", "stmtLimpezaInicioDestination", "stmtLimpezaInicialDestania", "stmtLimpezaInicialDestination", "stmtLimpezaInicioDestania", "stmtLimpezaInicioDestino", "stmtLimpezaIniciadestination", "stmtLimpezaInicialDesino", "stmtLimpezaInicialCombINO", "stmtLimpezaInicialDestin", "stmtLimpezaInicialCombina", "stmtLimpezaIniciodestINO", "stmtLimpezaIniciaDestination", "stmtLimpezaIniciadestin", "stmtLimpezaInicialDestINO", "stmtLimpezaInicialDesania", "stmtLimpezaInicialdestania", "stmtLimpezaInicioDestaco", "stmtLimpezaInicialCombino", "stmtLimpezaInicialdestino", "stmtLimpezaInicialDesINO", "stmtLimpezaInicialESTin", "stmtLimpezaIniciaDestin", "stmtLimpezaInicialDesination", "stmtLimpezaInicialESTaco", "stmtLimpezaIniciodestina", "stmtLimpezaIniciodestination", "stmtLimpezaIniciaDestino", "stmtLimpezaInicioDestINO"], "stmtDestino": ["stmtDestaco", "stmtdestino", "stmtRestINO", "stmtRestino", "stmDestin", "stmtLocationaco", "stmtDistINO", "stmtDestin", "stmpdestINO", "stmtdestaco", "stmDestinos", "stmtDistino", "stmtRestin", "stmpdestino", "stmrdestinning", "stmrdestINO", "stmtCombinos", "stmtCombino", "stmtDistaco", "stmDestino", "stmtdestINO", "stmrDestinning", "stmDestINO", "stmtRestaco", "stmrDestino", "stmtRestinos", "stmpDestaco", "stmrdestaco", "stmtDestINO", "stmrDestaco", "stmrdestino", "stmtCombINO", "stmtdestin", "stmtDestorno", "stmpDestino", "stmdestinos", "stmtLocationino", "stmrDestINO", "stmtdestinning", "stmdestino", "stmtDistorno", "stmdestin", "stmtCombin", "stmtdestorno", "stmdestINO", "stmtDestinning", "stmtLocationINO", "stmpdestaco", "stmpdestorno", "stmtdestinos", "stmtDestinos", "stmtLocationinning", "stmtRestinning", "stmpDestorno", "stmpDestINO"], "arquivo": ["arquiva", " ar\u00e7ivo", "Arquoso", "Arqico", " ar\u00e7iva", "arQuoso", "arQuiva", "Arqiva", "arqoso", " arqiva", "Arqivo", "arquarius", "arqarius", " arQuivo", " arquiva", " arqicio", " arqarius", " arquicio", "arQuivo", "Arquivo", "arQuico", "arqicio", "arQUico", "arQUivo", " arquarius", " arQuicio", " ar\u00e7icio", "arqico", "arqivo", " arqivo", "arquoso", "Arquico", "arquicio", "Arquiva", "arquico", " ar\u00e7arius", "Arqoso", "arQUoso", "arQUiva", " arQuiva", " arQuarius", "arqiva"], "plan1": ["product1", " plan0", "PlanName", "planName", "product0", " Plan1", " PlanOne", " Plan2", "productName", " plan2", "Plan1", "product2", "plan0", "plan2", "planOne", "PlanOne", "Plan2", " planName", "Plan0", " planOne", " Plan0"], "QUANTIDADE_DE_REGISTROS_DE_CABECALHO": ["QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRATES__", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRONS_", "QUANTIDADE_DE_REGISTERO__", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTRO__", "QUANTIDADE_DE_REGISTRASAD", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTRONS__", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTROSAD", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTEROS__", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTEROSAD", "QUANTIDADE_DE_REGISTRosAD", "QUANTIDADE_DE_REGISTRASJ", "QUANTIDADE_DE_REGISTRosJ", "QUANTIDADE_DE_REGISTROAD", "QUANTIDADE_DE_REGISTEROAD", "QUANTIDADE_DE_REGISTROS__"], "QUANTIDADE_DE_REGISTROS_DE_RODAPE": ["QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTEROEC", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRYOS_", "QUANTIDADE_DE_REGISTROSEC", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTROsEC", "QUANTIDADE_DE_REGISTRYAS_", "QUANTIDADE_DE_REGISTRYOSJ", "QUANTIDADE_DE_REGISTROEC", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTEROSEC", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTRYASJ", "QUANTIDADE_DE_REGISTRosEC", "QUANTIDADE_DE_REGISTROs_", "QUANTIDADE_DE_REGISTRASJ", "QUANTIDADE_DE_REGISTRosJ", "QUANTIDADE_DE_REGISTROsJ"], "QUANTIDADE_DE_REGISTROS_DE_METADADOS": ["QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTEROEC", "QUANTIDADE_DE_REGISTROSID", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTROSEC", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTEROSID", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTRONID", "QUANTIDADE_DE_REGISTRATESEC", "QUANTIDADE_DE_REGISTEROID", "QUANTIDADE_DE_REGISTRESJ", "QUANTIDADE_DE_REGISTROEC", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTRosID", "QUANTIDADE_DE_REGISTRES_", "QUANTIDADE_DE_REGISTEROSEC", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTROID", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTRON_", "QUANTIDADE_DE_REGISTRESEC", "QUANTIDADE_DE_REGISTRATESJ"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimmator", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstifado", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstivator", "quantidadeDeRegistrosEstifadas", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstivado", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstifator", "quantidadeDeRegistrosEstifada", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstimator"], "vSetor": ["vShipe", "vSelector", "vShiporing", " vSetors", "vSelecte", "vShipors", "vSete", "vShipor", " vSetoring", "vSetoring", "vSetors", "vSelectoring", "vSelectors", " vSete"], "vSubsetor": ["vSubscriptor", "vsubscor", "vSubjector", "vsubscors", "vSubscripto", "vSubscors", "vsubseto", "vsubscr", "vsubsetors", "vsubsetr", "vSubscriptr", "vSubsco", "vSubjectors", "vSubjectr", "vSubjecto", "vsubsetor", "vSubsetr", "vSubscor", "vSubscriptors", "vSubseto", "vsubsco", "vSubscr", "vSubsetors"], "vSegmento": ["vGmenta", "vSegamentos", "vGmentor", "vSegmentationos", "vGamenta", "vGmento", "vGamento", "vSegmentationo", "vSegMENTa", "vSegmentor", "vGamentor", "vSegMENTos", "vSegMENTor", "vSegamenta", "vGamentos", "vSegmenta", "vSegmentationa", "vSegMENTo", "vGmentos", "vSegamento", "vSegmentos", "vSegamentor", "vSegmentationor"], "registroAtual": ["Registroational", "RegistroAtial", "RegistrosAtual", "RegistrosatUAL", "RegistroAtUAL", "RegistrosAtional", "RegistroAtional", "RegistroExUAL", "RegistroGenual", "RegistroExial", "RegistroatUAL", "RegistroExional", "RegistroAtual", "Registrosatual", "RegistrosAtUAL", "Registrosatial", "RegistroGenUAL", "RegistroGenial", "RegistroGenional", "Registroatual", "RegistrosAtial", "RegistroExual", "Registrosational", "Registroatial"], "vPapeisPorSegmento": ["vPapeisPorSegamento", "vPapeisPorFragmento", "vPapeisPorFragmentos", "vPapeisPorSegamente", "vPapeisPorSegmentationos", "vPapeisPorSegmentsor", "vPapeisPorSegmentse", "vPapeisPorSegamentos", "vPapeisPorFragmente", "vPapeisPorSegamentor", "vPapeisPorFragmentse", "vPapeisPorSegmentso", "vPapeisPorFragmentsor", "vPapeisPorFragmentsos", "vPapeisPorSegmentor", "vPapeisPorSegmentos", "vPapeisPorSegmentationor", "vPapeisPorSegmente", "vPapeisPorFragmentso", "vPapeisPorSegmentatione", "vPapeisPorSegmentsos", "vPapeisPorSegmentationo", "vPapeisPorFragmentor"], "sql": ["where", "zip", "string", "base", "ssl", "sf", "id", "spec", "setup", "serv", "http", "sg", "json", "description", "slice", "spr", "html", " SQL", "s", "sol", "shell", "layout", "query", "util", "csv", "dl", "params", "select", "pr", "sb", "seed", "str", "sv", "eps", "ql", "acl", "data", "section", "body", "nl", "log", "sq", "msg", "ls", "db", "sl", "ln", "QL", "url", "comment", "SQL", "sn", "statement", "os", "script", "term", "install"]}}
{"id1": "18504192", "id2": "18748516", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "info", "base", "buffer", "i", "input", "id", "copy", "ini", "c", "inner", "ins", "bin", "part", "at", "reader", "d", "login", "min", "old", "diff", "inc", "parent", "data", "file", "src", "or", "again", "name", "m", "image", "io", "In", "url", "b", "ac", "inn"], "out": ["string", "base", "temp", "ex", "output", "n", "copy", "c", "OUT", "outs", "o", "dest", "line", "password", "client", "part", "cache", "connection", "target", "w", "inc", "data", "file", "object", "p", "conn", "name", "again", "exec", "Out", "writer", "io", "call", "prefix", "b", "obj", "err", "external", "point"], "source": ["sin", "ssl", "core", "i", "input", "self", "server", "copy", "Source", "settings", "ie", "slice", "slave", "project", "se", "dest", "origin", "ources", "clone", "SOURCE", "iter", "client", "sync", "use", "reader", "proxy", "connection", "target", "scope", "component", "parent", "channel", "src", "size", "get", "null", "start", "writer", "sl", "secure", "stream", "unit", "ource", "service", "from", "view", "storage"], "destination": ["declinated", "dependination", "contining", "declination", "testination", "testinated", " destinations", "dependinator", "declification", "destining", "continator", " destinated", "destinated", "testinator", " destinator", "Destination", "Destinated", "dependification", "Destification", "Destinator", "destification", "contination", "dependinated", "Destining", "declinator", "destinator", "testinations", "continated", "Destinations", "destinations", " destining"]}}
{"id1": "6625074", "id2": "7948308", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"SHA1": ["sha256", "HAOne", "SHA384", " SHA384", "HA384", "SHAOne", " SHA256", " SHAOne", "sha384", "HA256", "shaOne", "sha1", "HA1", "SHA256"], "text": ["letter", "string", "path", "translation", "class", "buffer", "input", "editor", "output", "token", "Text", "message", "TEXT", "plain", "hex", "in", "pattern", "content", "password", "txt", "source", "value", "str", "config", "data", "out", "object", "struct", "context", "format", "test", "name", "template", "image", "font", "word", "bytes", "ext", "contract", "obj", " Text", "transfer", "code"], "sha1hash": ["sha_Hash", "sha256password", "SHA1Hash", "ha2sum", "shaOnetext", "sha256Hash", "shaOneHash", "ha2hex", "sha1text", "sha256hash", "sha81hash", "sha6hash", "sha6cap", "sha_hex", "shaOnehash", "ha1hex", "ha1hash", "sha6log", "SHA2cap", "sha2hex", "ha2hash", "sha1password", "SHA1text", "SHA1log", "ha2Hash", "shaOnepassword", "sha_hash", "sha2Hash", "sha1Hash", "sha81log", "sha6Hash", "sha2cap", "sha256text", "sha1sum", "SHA1hash", "sha1log", "sha2sum", "sha81cap", "SHA2Hash", "SHA1password", "sha1cap", "sha81Hash", "sha2log", "SHA1cap", "SHA2log", "sha2hash", "sha_sum", "ha1sum", "sha1hex", "ha1Hash", "SHA2hash"], "md": ["pkg", "editor", "um", "mag", "bd", "df", "cf", "od", "amd", "mo", "ma", "meta", "wd", "MD", " MD", "ms", "rpm", "ad", "ld", "sm", "gb", "mb", "mt", "d", "mac", "mp", "hd", "sha", "pm", "pd", "de", "mm", "nd", "metadata", "cd", "dig", "m", "hm", "dm", "nm", "mc", "vd", "rm", "f", "cmd", "dd", "hash"]}}
{"id1": "189963", "id2": "17792212", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRebwrite", "readAndRebrap", "readAndRewwrite", "readAndSwrap", "readAndrewwrite", "readAndRebrite", "readandRewrap", "readandRewrites", "readAndSwwrite", "readandrewrap", "readAndRewrap", "readAndSwrite", "readandrewrites", "readandrewwrite", "readAndRebrites", "readAndRewrites", "readAndrewrite", "readAndSwrites", "readandrewrite", "readAndrewrites", "readAndrewrap", "readandRewwrite", "readandRewrite"], "inFile": [" inSourceFile", "InSourceFile", "oldfile", "outSourceFile", "inputfile", "outfile", " inFiles", "inputFilename", "InFiles", " infile", "infile", "inputFile", "outFiles", "oldFile", "loginFile", " inFilename", "Infile", "inFiles", "inputFiles", "oldFiles", "loginFilename", "loginfile", "loginFiles", "InFile", "oldFilename", "outFilename", "inFilename", "inSourceFile"], "outFile": ["newfile", "outDir", "OutStream", "processFile", "outputFilename", "exFilename", "outputfile", " outfile", "outPlace", "outFILE", "outputFILE", "outfile", "processFilename", "offFILE", "outputPlace", "thisFilename", "outStream", "thisFile", "processPlace", "exfile", "thisFILE", "newDir", "exFILE", "OutDir", "exFile", "processFILE", "newStream", "offPlace", "OutFile", " outStream", "outFilename", "offFilename", "Outfile", " outDir", "outputFile", "newFile", "thisfile", "offFile"], "iis": ["iIS", "Iais", "iIs", "iiris", "iniIs", "iiiss", "iais", "Iis", "ciis", "iiis", " iIs", " iIS", " iais", "ciiss", "Iiss", "ciais", " iiss", "iiss", "iiIS", "iniiss", " iris", "iniis", "ciris", "iniIS", "iniris", "IIS", "iris", "iiIs", "ciIS", "ciIs"], "dcmParser": ["dbmPolicy", "dbmParser", "dmmLoader", "dmissionParser", "dcmInstallation", "dmoduleJar", "dpmLoader", "dmoduleparser", "dhemReader", "dkmParser", "dmissionLanguage", "dCMPlugin", " dpmparser", " dcrParser", "fpmparser", "dhemJar", " dpmPolicy", "dkmPolicy", "dpmParser", "dcmPolicy", "dmissionPlugin", " dcmarser", "dmmPlugin", " dcrPlugin", "DcmInstallation", " dcmLanguage", "dpmHandler", "dmcJar", "dkmPlugin", " dpmParser", "dmoduleReader", " dcrLoader", "fcmReader", "dmissionReader", "dcrParser", "dmcarser", "dbmHelper", "dmLoader", "fpmHandler", "dcrarser", "dhemInstallation", "dmcParser", "dmmparser", "dpmLanguage", "dmodulePlugin", " dcmPolicy", "dpmarser", "dpmReader", "dcmPar", "dpmPar", "dmReader", "dcmparser", "dcrLoader", "dmParser", " dcmLoader", " dcmReader", "fcmparser", "dpmPolicy", "dcrJar", "dcmPlugin", "dpmparser", "fpmReader", "dcmarser", " dpmPlugin", "dbmPlugin", "dpmPlugin", " dpmHelper", "dCMLoader", " dpmLoader", " dpmJar", "dmoduleParser", " dcrReader", "dcmLoader", "fcmParser", "dpmHelper", "dcmReader", " dpmPar", "dCMHandler", "dmPlugin", "dcmJar", "dcrPlugin", "dpmJar", " dcmJar", "fcmHandler", " dcmHelper", "dCMparser", "dcrPar", "DcmParser", " dcmPar", "dcrReader", "fpmParser", " dpmReader", " dcmparser", "dmcPar", " dpmLanguage", "dcmHelper", "dpmInstallation", "dcmHandler", "dCMParser", "dcmLanguage", "dmmParser", "DcmReader", "dCMReader", "dkmHelper", " dcmPlugin", "DcmJar", "dhemParser", " dpmarser"], "ds": ["services", "ys", "uds", "ays", "DS", "iss", "gd", "sys", "Os", "df", "ants", "ns", "tes", "ks", "drivers", "qs", "bs", "s", "ins", "dr", "is", "dc", "rs", "ld", "dt", "parts", "cdn", "sync", "session", "ws", "d", "ros", "eps", "points", "icks", "ads", "data", "gs", "src", "xs", "utils", "vals", "ras", "Ds", "des", "ts", "conn", "vs", "ls", "js", "ss", "db", "ils", "di", "nas", "details", "amps", "Db", "da", "asi", "cs", "dds", "ps", "os", "dat", "pd", "dd", "tx"], "pdReader": ["hdRunner", "pbRunner", "pcReader", "pdRunner", "xdreader", "dsReader", "dsreader", "pbLoader", "hdReader", "hdreader", "dsLoader", "pcLoader", "pbStream", "hdStream", "ddStream", "pcRead", "xdWriter", "ddLoader", "pdLoader", "pdStream", "ddRunner", "pbReader", "hdWriter", "dsRead", "dsWriter", "xdRead", "pcWriter", "xdReader", "hdRead", "hdLoader", "ddReader", "pdreader", "pdRead"], "out": ["ssl", "base", "temp", "output", "net", "as", "s", "in", "at", "lib", "model", "default", "file", "gen", "conn", "Out", "url", "obj", "with", "external", "point", " in", "outer", "ex", "sys", "lock", "builder", "result", "later", "sync", "part", "cache", "up", "oder", "connection", "w", "parent", "store", "page", "object", "device", "again", "name", "exec", "exp", "array", "full", "over", "list", "order", "inner", "outs", "o", "line", "flow", "co", "write", "password", "session", "doc", "diff", "group", "director", "null", "dev", "io", "writer", "image", "to", "word", "cli", "term", "auto", "her", "copy", "user", "OUT", "child", "manager", "pass", "key", "client", "dot", "login", "inc", "down", "data", "db", "layer", "ext", "err", "code", "img"], "dcmEncParam": ["dcmEnParam", "dcmEstParam", "dcmDecParam", "dcmEnParameter", "dcmSecPart", "dcmDecType", "dcmDecPar", "dcmEncType", "dcmEncParameter", "dcmArchParam", "dcmEncPart", "dcmElParameter", "dcmEnPar", "dcmEnPart", "dcmDecArg", "dcmArchArg", "dcmArchParameter", "dcmSecPar", "dcmEnArg", "dcmDecParameter", "dcmDecPart", "dcmSecType", "dcmElParam", "dcmEstPar", "dcmEncPar", "dcmSecParam", "dcmElPar", "dcmEncArg", "dcmElType", "dcmEnType", "dcmEstType", "dcmEstParameter"], "pdWriter": ["dpWrite", "pdOutput", "ddWrite", "pdWriting", "htWriter", "dpReader", "dsReader", "hdReader", "pdWrite", "htWriting", "dpWriting", "PDWrite", "dpWriter", "hdWriter", "dsOutput", "dsWriter", "hdWrite", "htWrite", "PDWriter", "dsWrite", "ddOutput", "PDReader", "ddReader", "htReader", "PDWriting", "ddWriter", "hdOutput"]}}
{"id1": "6379126", "id2": "4272289", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public static int[] sortstring(int[] a1) {\n        int temp;\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        return a1;\n    }\n", "label": 0, "substitutes": {"gerarTutorialPage": ["riarTravispage", "riarTutorialDir", "riarTinyDir", "riarTravisPage", "riarTourElement", "riartourpage", "riartourPage", "riartourElement", "riarTinypage", "riartutorialPage", "riarTourpage", "riarTourDir", "riartutorialpage", "riartourDir", "riarTutorialpage", "riarTinyPage", "riarTutorialElement", "riartutorialDir", "riarTravisElement", "riarTinyElement", "riarTutorialPage", "riartutorialElement", "riarTravisDir", "riarTourPage"], "indexDir": ["IndexDIR", "includeTier", "IndexDir", "zipDir", "includeDir", "includeDIR", "indexDIR", "indexTier", "IndexTier", "zipDIR", "zipTier", "indexJar", "includeJar", "IndexJar", "zipJar"], "cssDir": ["fontDIR", "codesLen", "ssDar", "ssUrl", "cssUrl", "cssDIR", "catsDoc", "ssDb", "ssDir", "piecesDie", "fontD", "gzDIR", "piecesDir", "cssD", "ssDIR", "javascriptDb", "cssLen", "CSSLen", "ssD", "cssDb", "javascriptDIR", "CSSDoc", "cssDie", "javascriptDir", "CSSDb", "codesDoc", "piecesDIR", "piecesD", "cssDar", "cssDirectory", "CSSDar", "gzDir", "javascriptDar", "ssDie", "CSSDIR", "fontDie", "cssDoc", "fontDir", "codesDir", "CSSUrl", "catsLen", "catsDir", "ssDirectory", "gzUrl", "gzDirectory", "CSSDir", "CSSDirectory"], "capDir": ["casDir", "casdir", "apsVol", "Capdir", "casVol", "CapDirectory", "capdir", "apsdir", "apsDirectory", "CapVol", "capVol", "capDirectory", "apsDir", "casDirectory", "CapDir"], "licDir": ["libdir", "lifdir", "lifManager", "volDir", "libDir", "libDoc", "voldir", "licDoc", "volDoc", "licManager", "lifDoc", "lifDir", "licdir", "volManager", "libManager"], "midDir": ["casDir", "casdir", "middir", "limdir", "limTier", "mindDir", "limDir", "casTier", "limDIR", "minddir", "midDIR", "midTier", "casDIR", "mindTier", "mindDIR"], "filesDir": ["FilesFolder", "FilesDir", "imagesDir", "FilesFile", "filesFolder", "filesFile", "stylesDirectory", "filesVol", "imagesFile", "ballsVol", "stylesDIR", "filesDirectory", "locksDir", "filesDIR", "imagesDirectory", "opensDIR", "ballsDir", "locksDIR", "opensDirectory", "opensDir", "stylesDur", "imagesFolder", "filesPos", "ballsPos", "stylesDir", "filesDur", "videosFolder", "opensDur", "videosFile", "FilesDirectory", "pagesVol", "locksDirectory", " filesVol", "pagesPos", " filesPos", "locksDur", "videosDirectory", "pagesDir"], "videosDir": ["imagesDir", "videoFile", " videosDirectory", " videosFile", "videoUrl", "videosUrl", " videosDb", "imagesDb", "videoDb", "viewsFile", "viewsDir", " videosUrl", "viewsUrl", "videosFile", "viewsDirectory", "videosDb", "videoDir", "videoDirectory", "videosDirectory"], "imagensDir": ["imagersDirectory", "imgensDir", "imagenJar", "imagenciesDir", "imagensJar", " imagersJar", " imagersDirectory", " imagensFile", "imagenDir", " imagensDirectory", "imagenDirectory", "imagenciesDirectory", "imagentsJar", "imagensDIR", "imagensFile", "imagersFile", " imagersDir", "imagensDirectory", "imagenFile", "imgentsDirectory", "imgensDIR", "imagersDIR", "imagentsDir", "imgensDirectory", "imgentsFile", "imagentsDirectory", "imagersDir", "imgentsDIR", " imagersFile", "imagenciesFile", "imagenciesDIR", "imgensFile", " imagensJar", "imagentsFile", "imgentsDir", "imagersJar", "imagentsDIR"], "local": ["directory", "where", "path", "total", "base", "remote", "personal", "temp", "defined", "pal", " Local", "self", "username", "managed", "user", "lock", "Local", "relative", "http", "json", "current", "inner", "present", "standard", "l", "location", "global", "pass", "util", "active", "part", "back", "d", "valid", "dir", "serial", "specified", "shared", "upload", "data", "file", "tmp", "small", "input", "same", "request", "p", "log", "safe", "name", "internal", "home", "available", "initial", "prefix", "LOC", "localhost", "partial", "Location", "conf", "state", "basic", "loc"], "srcCss1": ["srcCass81", "srcRss0", "srcCrss1", "srcCass2", "srcCpe4", "srcCss81", "srcCpe1", "srcCfg2", "srcCse11", "srcRss11", "srcRss81", "srcPcss1", "srcRcss81", "srcCrss3", "srcCcss2", "srcCss11", "srcRcss11", "srcCass11", "srcPcss3", "srcRcss1", "srcPss1", "srcPssPre", "srcCass1", "srcCcss4", "srcCrss11", "srcRcss2", "srcCass3", "srcPss2", "srcCfg1", "srcCcss0", "srcPss4", "srcCcss11", "srcCass0", "srcCssPre", "srcCse1", "srcCfgPre", "srcPcss2", "srcCcss3", "srcCpe2", "srcCcss1", "srcRss2", "srcRss1", "srcCse0", "srcCcss81", "srcCpePre", "srcCfg4", "srcPss81", "srcCrss81", "srcCse2", "srcCcssPre", "srcCss0", "srcPcss4", "srcRcss0", "srcPcssPre", "srcPcss81", "srcCrss2", "srcPss3"], "destCss1": ["destCcss3", "destCrss1", "destCass2", "destCfg0", "destPss3", "destCxxCard", "destPcss3", "destCrss2", "destPss81", "destCrss81", "destCass3", "destCrss3", "destPss0", "destCss0", "destCrss0", "destCcss0", "destPcss81", "destCfg3", "destCss81", "destCcss2", "destCfg1", "destCxx1", "destCxx2", "destCassCard", "destPcss1", "destPss2", "destCcssCard", "destPcss0", "destPcssCard", "destCssCard", "destCxx3", "destPssCard", "destPcss2", "destCass81", "destCass1", "destPss1", "destCcss1", "destCcss81", "destCfg2"], "srcCss2": ["srcCross52", "srcCssL", "srcChessTwo", "srcAccss2", "srcCrss1", "srcCng27", "srcCng2", "srcAcss1", "srcCfg3", "srcCcss27", "srcCass2", "srcCfg2", "srcPcssL", "srcPcss1", "srcUss2", "srcCcss2", "srcCass4", "srcChess1", "srcPcss3", "srcPss1", "srcCcssTwo", "srcCcss52", "srcUcssB", "srcAcss4", "srcCcssL", "srcAccss52", "srcPcss27", "srcChessB", "srcCass1", "srcCcss4", "srcChess2", "srcCfgTwo", "srcUss1", "srcUssTwo", "srcCass52", "srcAccss4", "srcAccss1", "srcCross2", "srcPss2", "srcCfg1", "srcCross1", "srcUcssTwo", "srcCfgB", "srcCss52", "srcCrssL", "srcCssTwo", "srcCrss27", "srcPss27", "srcUcss1", "srcAcss52", "srcCcssB", "srcPcss2", "srcCross4", "srcCcss3", "srcCcss1", "srcAcss2", "srcCssB", "srcUcss2", "srcCfgL", "srcCss27", "srcCrss2", "srcPssL", "srcUssB", "srcPss3", "srcCng1", "srcCrss3"], "destCss2": ["destNcss1", "destNcss2", "destNcssB", "destCfgB", "destCcssB", "destCcss3", "destNcss3", "destCcss4", "destNcss32", "destCest1", "destCss32", "destCssB", "destNss2", "destCestB", "destNss72", "destCest3", "destNss3", "destNss32", "destCess72", "destCess4", "destCfg3", "destCfg32", "destNss4", "destCess1", "destNss1", "destCfg1", "destCcss2", "destNcss72", "destNcss4", "destCss72", "destCfg4", "destCcss32", "destCest2", "destCess32", "destCfg72", "destCess2", "destNssB", "destCcss1", "destCcss72", "destCfg2"], "srcCss3": ["srcRcssThird", "srcCsh183", "srcClass93", "srcCcss2", "srcRcss1", "srcCass1", "srcCcss4", "srcRcss2", "srcPss2", "srcRss4", "srcPcss2", "srcClass15", "srcCsh2", "srcScstyle93", "srcCstyleAND", "srcScss2", "srcCss93", "srcCstyle3", "srcCass2", "srcPcss3", "srcRss3", "srcRcss3", "srcCstyle93", "srcCsh3", "srcCass3", "srcRcss4", "srcCcss3", "srcCcss1", "srcRss1", "srcCcssAND", "srcRssThird", "srcCcss93", "srcCfg2", "srcScstyle15", "srcCcssThird", "srcCshThird", "srcRss183", "srcClass2", "srcCfg1", "srcPss6", "srcScss93", "srcCsl183", "srcCstyle15", "srcCrss6", "srcScss3", "srcCcss15", "srcScss15", "srcCass4", "srcPss3", "srcCrss3", "srcRcss183", "srcCsl2", "srcCsl3", "srcCfg3", "srcCrssAND", "srcScstyle2", "srcPssAND", "srcScstyle3", "srcPcss6", "srcCcss183", "srcCslThird", "srcCcss6", "srcCss15", "srcCss183", "srcClass3", "srcRss2", "srcCstyle6", "srcCfg4", "srcPcssAND", "srcCssAND", "srcCstyle2", "srcCssThird", "srcCrss2"], "destCss3": ["destCstyle03", "destCass43", "destCss03", "destNss43", "destCss43", "destNcss2", "destCcss3", "destPcss03", "destCstyle3", "destScrss6", "destCrss6", "destCross3", "destNcss3", "destCass2", "destCja183", "destPss3", "destCja2", "destPcss3", "destCrss2", "destCss183", "destCass3", "destCcss183", "destCja3", "destCrss3", "destCstyle43", "destNss2", "destCross2", "destScss3", "destPcss53", "destNss3", "destCcss43", "destCross03", "destScrss2", "destCstyle2", "destCcss2", "destCcss6", "destCss53", "destScss6", "destPss53", "destScrss3", "destCcss03", "destPss2", "destCja6", "destCross53", "destNcss43", "destScss183", "destCstyle53", "destScss2", "destPcss2", "destScrss183", "destPss03", "destCrss183", "destCcss53"], "srcCss4": ["srcCass2", "srcCrss1", "srcPcssFour", "srcPcss1", "srcCcss2", "srcPss1", "srcCass1", "srcCcss4", "srcCassFour", "srcCssFour", "srcPss2", "srcPss4", "srcCrssFour", "srcCcssFour", "srcPcss2", "srcCcss1", "srcCrss4", "srcPcss4", "srcPssFour", "srcCrss2", "srcCass4"]}}
{"id1": "5138455", "id2": "411595", "code1": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"save": ["zip", "output", "copy", "Copy", "run", "Save", "write", "clone", "split", "post", "load", "upload", "store", "file", "append", "put", "apply", "pack", "dump", "files", "create", "parse", "process", "xml", "transfer", "download"], "bytes": ["services", "zip", "buffer", "address", "resources", "tes", "slice", "outs", "bs", "s", "gb", "parts", "its", "rb", "binary", "lines", "blocks", "bps", "buf", "data", "vals", "objects", "ips", "es", "frames", "Bytes", "ls", "pointer", "values", "files", "pins", "words", "os", "bits", "codes", "boot"], "outputFile": ["OutputDirectory", "referenceFile", "outputJar", "outputfile", "responseJar", "inputfile", "referencePath", " outputJar", "OutputF", "responseDir", "inputFile", "outputPath", "targetfile", "outputF", "referencefile", "inputPath", " outputDirectory", "OutputFiles", "targetJar", "inputDir", "targetDir", " outputF", " outputPath", " outputfile", "responseFile", "inputFiles", " outputFiles", " outputDir", "outputFiles", "inputF", "inputDirectory", "outputDirectory", "outputDir", "referenceDir", "OutputFile", "targetFile", "responsefile"], "in": ["IN", "info", "base", "pin", "i", "input", "inas", "n", "copy", "id", "token", "ini", "con", "c", "inner", "as", "s", "ins", "sin", "bin", "pass", "is", "part", "reader", "source", "up", "login", "connection", "inside", "r", "inc", "work", "data", "file", "rin", "ssl", "init", "conn", "again", "m", "exec", "image", "isin", "In", "nin", "a", "url", "b", "err", "cin", "inn", "f", "win", "din"], "out": ["i", "temp", "ex", "n", "output", "copy", "outer", "user", "server", "op", "OUT", "inner", "as", "socket", "outs", "o", "write", "bin", "outside", "post", "sync", "client", "at", "cache", "up", "connection", "inc", "w", "parent", "file", "object", "x", "null", "conn", "init", "again", "exec", "Out", "writer", "io", "exp", "image", "call", "In", "a", "ext", "err", "b", "obj", "f", "error", "this"]}}
{"id1": "9371421", "id2": "20685385", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private Long getNextPkValueForEntityIncreaseBy(String entityName, int count, int increasePkBy) {\n        if (increasePkBy < 1) increasePkBy = 1;\n        String where = \"where eoentity_name = '\" + entityName + \"'\";\n        if (false) {\n            EOEditingContext ec = ERXEC.newEditingContext();\n            ec.lock();\n            try {\n                EODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n                dbc.lock();\n                try {\n                    EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n                    EOAdaptorChannel channel = (EOAdaptorChannel) dbc.adaptorContext().channels().lastObject();\n                    NSArray result = channel.primaryKeysForNewRowsWithEntity(increasePkBy, entity);\n                    return (Long) ((NSDictionary) result.lastObject()).allValues().lastObject();\n                } finally {\n                    dbc.unlock();\n                }\n            } finally {\n                ec.unlock();\n            }\n        } else {\n            ERXJDBCConnectionBroker broker = ERXJDBCConnectionBroker.connectionBrokerForEntityNamed(entityName);\n            Connection con = broker.getConnection();\n            try {\n                try {\n                    con.setAutoCommit(false);\n                    con.setReadOnly(false);\n                } catch (SQLException e) {\n                    log.error(e, e);\n                }\n                for (int tries = 0; tries < count; tries++) {\n                    try {\n                        ResultSet resultSet = con.createStatement().executeQuery(\"select pk_value from pk_table \" + where);\n                        con.commit();\n                        boolean hasNext = resultSet.next();\n                        long pk = 1;\n                        if (hasNext) {\n                            pk = resultSet.getLong(\"pk_value\");\n                            con.createStatement().executeUpdate(\"update pk_table set pk_value = \" + (pk + increasePkBy) + \" \" + where);\n                        } else {\n                            pk = maxIdFromTable(entityName);\n                            con.createStatement().executeUpdate(\"insert into pk_table (eoentity_name, pk_value) values ('\" + entityName + \"', \" + (pk + increasePkBy) + \")\");\n                        }\n                        con.commit();\n                        return new Long(pk);\n                    } catch (SQLException ex) {\n                        String s = ex.getMessage().toLowerCase();\n                        boolean creationError = (s.indexOf(\"error code 116\") != -1);\n                        creationError |= (s.indexOf(\"pk_table\") != -1 && s.indexOf(\"does not exist\") != -1);\n                        creationError |= s.indexOf(\"ora-00942\") != -1;\n                        if (creationError) {\n                            try {\n                                con.rollback();\n                                log.info(\"creating pk table\");\n                                con.createStatement().executeUpdate(\"create table pk_table (eoentity_name varchar(100) not null, pk_value integer)\");\n                                con.createStatement().executeUpdate(\"alter table pk_table add primary key (eoentity_name)\");\n                                con.commit();\n                            } catch (SQLException ee) {\n                                throw new NSForwardException(ee, \"could not create pk table\");\n                            }\n                        } else {\n                            throw new NSForwardException(ex, \"Error fetching PK\");\n                        }\n                    }\n                }\n            } finally {\n                broker.freeConnection(con);\n            }\n        }\n        throw new IllegalStateException(\"Couldn't get PK\");\n    }\n", "label": 0, "substitutes": {"eventHash": ["bytehash", "eventKey", "byteHash", "byteKey", "messagehash", "eventhash", " eventDig", "messageDig", " eventKey", " eventhash", "eventDig", "messageHash", "messageKey", "byteDig"], "eventstr": ["Eventstring", "eventStr", "errorstr", "exdict", "EventStr", " eventstring", " eventdict", "exstr", "errorStr", "eventdict", "Eventdict", "errorstring", "exStr", "eventstring", "errorsource", "exstring", "Eventstr", "eventsource", " eventsource", "Eventsource", " eventStr"], "md": ["mu", "id", "mag", "mem", "ke", "bd", "od", "amd", "map", "mo", "ma", "meta", "dr", "wd", "MD", "ms", "ld", "sm", "key", "ad", " MD", "rpm", "cm", "mb", "mt", "dh", "mac", "doc", "d", "mp", "hd", "sha", "pm", "cmd", "data", "mm", "metadata", "dig", "m", "hm", "dm", "mand", "mc", "di", "mn", "em", "vd", "mg", "ng", "mod", "dd", "hash"], "theDigest": ["TheDigester", "theDigEST", "theHashEST", " theSignEST", "Thedigester", " theDigEST", "TheDigest", " theDighest", "theDighest", "thedigEST", "theSignester", "TheDigEST", "thedigest", "theSignhest", "Thedigest", "theSignest", " theSignest", " theDigester", "thedighest", "theHashest", " theSignester", "theHashester", "theDigester", "theSignEST", "ThedigEST", "thedigester", " theSignhest"]}}
{"id1": "19944975", "id2": "13783549", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["saveConfig", "saveReport", "WriteSection", " writeSection", "saveConfiguration", "writeReport", "WriteConfig", "writeSection", " writeReport", "WriteReport", " writeConfig", "writeConfig", "saveSection", "WriteConfiguration"], "out": ["IN", "path", "string", "base", "temp", "ex", "output", "resource", "list", "server", "user", "inas", "report", "res", "plain", "filename", "OUT", "c", "project", "inner", "outs", "o", "window", "pool", "write", "line", "key", "password", "client", "sync", "at", "reader", "lib", "connection", "scope", "w", "config", "parent", "file", "object", "conn", "init", "name", "again", "m", "Out", "io", "writer", "exp", "exec", "dump", "prefix", "flush", "ext", "obj", "err", "xml", "this", "external"], "url": ["path", "string", "base", "address", "ssl", "server", "resource", "uri", "feed", "http", "rel", "l", "location", "URL", "source", "connection", "r", "org", "ob", "open", "config", "data", "file", "channel", "page", "object", "ll", "web", "conn", "io", "image", "sl", "Url", "stream", "b", "xml", "f", "service", "api"], "in": ["IN", "pin", "ssl", "i", "input", "resource", "copy", "n", "id", "inas", "ini", "serv", "gin", "c", "inner", "as", "socket", "s", "ins", "bin", "is", "cms", "reader", "source", "login", "min", "inside", "r", "inc", "data", "rin", "file", "conn", "again", "isin", "In", "nin", "kin", "a", "stream", "lin", "b", "err", "ac", "cin", "xml", "inn", "f", "win", "din"]}}
{"id1": "9236363", "id2": "873012", "code1": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"unJarStart": ["syncServerPath", "copyJarPath", "copyJarStart", "copyjarRest", "syncServerRest", "syncJarRest", "copyJarEnd", "copyServerRest", "copyjarEnd", "copyServerPath", "copyjarPath", "syncJarEnd", "copyJarRest", "copyZipRest", "syncJarStart", "copyjarStart", "copyServerEnd", "copyServerStart", "copyZipStart", "copyZipEnd", "syncServerEnd", "syncServerStart", "copyZipPath", "syncJarPath"], "jarPath": ["relEntry", "Jarpath", "jarLog", "jarText", "zipPath", "jamLog", "zippath", "archivePath", " jarpath", "javaPath", "jamPath", "javaCh", "jarName", " jarText", "JarName", "narCh", "jarContent", " jarContent", " jarUrl", "garText", "JarFile", "relFile", "archivepath", "javaFile", "badPath", "jarpath", "garUrl", "javaName", "badLog", "jarFile", "JarCh", "narPath", "javaText", " jarLog", "garPath", " jarFile", " jarDir", "javaEntry", "garFile", "javaUrl", "jarUrl", "jarCh", "archiveDir", "javapath", " jarName", "badpath", "javaLog", "badUrl", "archiveLog", "zipEntry", "zipFile", "jampath", "garpath", "narpath", "JarContent", "garContent", "jamDir", "relpath", "narName", "JarPath", "jarDir"], "jarEntryStart": ["jarEntSource", " jarEntryFollow", "jarEntPart", "jarEntryName", " jarImportStart", "tarEntryPart", "jarFileSource", " jarFileStart", "jarFileName", "jarImportPart", "jarEntryPart", "jarEntrySource", "jarEntStart", " jarFilePart", " jarEntrySource", "jarFileStart", " jarEntryEnd", "jarEntName", "jarFileFollow", " jarImportPart", "jarEntryFinish", "jarentryName", "jarFileEnd", "jarImportName", "jarentryStart", "tarentryName", "jarEntryFollow", "jarAttemptStart", "tarEntrySource", "jarEntryEnd", "jarImportStart", " jarFileEnd", "jarAttemptPart", "tarEntryStart", " jarFileFinish", "jarImportFollow", " jarImportEnd", "jarAttemptFollow", "jarentrySource", "jarFileFinish", " jarFileName", "jarImportFinish", " jarEntryFinish", "jarentryPart", "tarentryStart", "jarAttemptEnd", "jarFilePart", "tarentrySource", " jarImportFollow", "jarPartStart", "jarImportSource", "tarentryPart", "jarPartFinish", " jarFileSource", " jarEntryName", " jarEntryPart", "jarImportEnd", "jarPartEnd", "jarPartPart", "tarEntryName"], "path": ["zip", "then", "root", "base", "temp", "output", "resource", "patch", "host", "content", "default", "file", "archive", "context", "conn", "graph", "it", "mount", "url", "PATH", "ph", "step", "string", "id", "clean", "location", "next", "source", "cache", "dir", "ion", "ath", "work", "parent", "route", "object", "test", "name", "th", "left", "cookie", "boot", "directory", "uri", "json", "Path", "inner", "system", "mode", "dest", "wd", "session", "request", "p", "template", "image", "prop", "method", "error", "api", "pass", "key", "pattern", "type", "config", "data", "text", "log", "folder", "po", "home", "ha", "pointer", "prefix", "ctx", "ith", "right", "code", "loc"], "relPath": ["RelPath", "relativeDir", " relName", "RELPath", "RELpath", "Relpath", " relPos", " relDir", "RELPos", "relPos", "relativepath", "relDir", "RelName", "relativePath", "RelDir", "relativePos", "relName", "RELName", " relpath", "relpath", "relativeName"], "jar": ["zip", "ssl", "pkg", "her", " tar", "server", "mag", "drop", "fire", " manifest", "per", "ge", " parser", "java", "tar", " java", " capsule", "jo", " dir", "dr", "sheet", "zone", "keeper", "magic", "ler", "bag", " archive", "er", " war", "bar", "Jar", "cache", "tab", "dir", "browser", "sr", "open", "pipe", "war", "archive", " module", "rar", "log", "plugin", "ball", "folder", "start", "pack", "car", "sl", "spin", "url", "com", "ser", "parse", "sp", "cookie", "gap", "xml", "ar", "module", "space"], "entries": ["entryers", "countries", "ENTlements", "antlements", "countEntry", "addries", "entrys", "ientlements", "Entursions", "adders", "endories", "antursions", "entryensions", "entEntry", "quries", "entensions", "Entry", "entursions", "itrys", "iters", "counters", "Entrys", "Entries", "addensions", "quies", "endries", "antry", "endrys", "itries", "ENTies", "entlements", "countensions", "Entories", "enters", "qulements", "enties", "addEntry", "Entlements", "itories", "Entents", "ENTries", "entories", "Enters", "entryries", "ientry", "antries", "enders", "ENTents", "ientursions", "ientries", "entents", "entryEntry", "quents", "Enties"], "entry": ["zip", "ry", "address", "server", "resource", "be", "add", "ie", "ge", "se", "jo", "ries", "Entry", " Entry", "key", "ler", "la", "pie", "ent", "part", "reader", "ce", "module", "je", "r", "cat", "de", "or", "cel", "name", "e", "lie", "pack", "it", "parse", "mer", "obj", "oe", "element", "enter"], "jarEntry": ["jarentry", "jobentry", "carEnt", "serName", "jarName", "javaPath", "archiveEntry", "jarRule", "archiveElement", "archiveName", "archiveEnt", "celFile", "jobEntry", "jobPath", "javaFile", "serEntry", "javaElement", "javaName", "jarFile", " jarImport", " jarEnt", "javaEntry", "jobImport", "javaImport", "archiveRule", "javaentry", "jarEnt", "carEntry", "carPath", "serElement", " jarentry", "jarImport", "javaRule", "javaEnt", "serFile", "carElement", "celEntry", " jarElement", "celRule", "celEnt", "archiveFile", "jarElement"], "ze": ["zip", "fe", "zer", "ipe", "ke", "be", "zes", "zy", "ie", "kee", "ge", "z", "se", "aze", "jo", "ide", "te", "ine", " ace", "za", "ja", "ce", "je", "li", "ZE", "le", " je", "ne", "cel", "xe", "e", "zi", "sl", "pe", "zo", "zen", "code", "zie"], "bin": ["zip", "index", "info", "base", "sin", "pin", "bis", "resource", "lock", "ini", "inner", "abin", "arin", "zone", "in", "bar", "binary", "lib", "proxy", "login", "len", "bas", "data", "file", "body", "vin", "bb", "log", "bi", "bank", "init", "plugin", "bn", "bit", "isin", "kin", "gi", "di", "spin", "bot", "abi", "cin", "inn", "win", "boot"]}}
{"id1": "7169984", "id2": "5707205", "code1": "    public static String connRemote(JSONObject jsonObject, String OPCode) {\n        String retSrc = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(AZConstants.validateURL);\n            HttpParams httpParams = new BasicHttpParams();\n            List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>();\n            nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode));\n            nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString()));\n            httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair));\n            httpPost.setParams(httpParams);\n            HttpResponse response = httpClient.execute(httpPost);\n            retSrc = EntityUtils.toString(response.getEntity());\n        } catch (Exception e) {\n            Log.e(TAG, e.toString());\n        }\n        return retSrc;\n    }\n", "code2": "            public void run() {\n                Log.d(LOG_TAG, \"Fetching \" + url);\n                WebDbAdapter dbHelper = new WebDbAdapter(mContext);\n                dbHelper.open();\n                boolean errorOccurred = true;\n                int notifyId = 0;\n                String host = AppUtils.getHostFromUrl(url);\n                try {\n                    if (host == null) {\n                        Log.d(LOG_TAG, \"Bad url \" + url);\n                        errorOccurred = true;\n                    } else {\n                        notifyId = showNotification(\"Fetching \" + host, \"Fetching \" + host, android.R.drawable.stat_sys_download, 0);\n                        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);\n                        String userAgent = sp.getString(mContext.getString(R.string.pref_key_user_agent), mContext.getString(R.string.default_user_agent));\n                        Log.d(LOG_TAG, \"Using user agent=\" + userAgent);\n                        AndroidHttpClient ahc = AndroidHttpClient.newInstance(mContext, url, userAgent);\n                        URI uri = new URI(url);\n                        URI norm = new URI(uri.getScheme().toLowerCase(), uri.getUserInfo(), uri.getHost().toLowerCase(), uri.getPort(), uri.getPath(), uri.getQuery(), null);\n                        norm = norm.normalize();\n                        HttpUriRequest get = new HttpGet(norm);\n                        HttpResponse response = ahc.execute(get);\n                        if (response.getStatusLine().getStatusCode() == 200) {\n                            HttpEntity entity = response.getEntity();\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            entity.writeTo(baos);\n                            String data = baos.toString();\n                            for (int i = 0; i < undesirables.length; i++) {\n                                Pattern p = Pattern.compile(undesirables[i], Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n                                data = data.replaceAll(p.pattern(), \"\");\n                            }\n                            long sysMillis = System.currentTimeMillis();\n                            String newFileName = getPath(sysMillis, sp.getBoolean(mContext.getString(R.string.pref_key_store_sdcard), false));\n                            FileOutputStream strm = new FileOutputStream(newFileName);\n                            Log.d(LOG_TAG, \"Writing to \" + newFileName + \" for url \" + url);\n                            String jsData = AppUtils.fromRawResourceFile(R.raw.retain_loadcolors, mContext);\n                            jsData = jsData.replaceAll(\"@css_file\", RETAIN_COLORS_CSS);\n                            strm.write(jsData.getBytes());\n                            strm.write(data.getBytes());\n                            strm.write(jsData.getBytes());\n                            strm.flush();\n                            strm.close();\n                            String entryName = getTitle(newFileName, url);\n                            long newRowId = dbHelper.createEntry(entryName, newFileName, url, sysMillis);\n                            postToast(\"Downloaded \\\"\" + entryName + \"\\\"\");\n                            errorOccurred = false;\n                            if (deleteRowId != 0) {\n                                Log.d(LOG_TAG, \"Deleting rowId=\" + deleteRowId);\n                                dbHelper.deleteEntry(deleteRowId);\n                                if (url == null) postToast(\"Item Deleted\");\n                                mContext.startActivity(new Intent(mContext, RetainActivity.class));\n                            } else {\n                                showNotification(\"Download Complete\", entryName, android.R.drawable.stat_sys_download_done, newRowId);\n                            }\n                        } else {\n                            Log.e(LOG_TAG, \"Response code=\" + String.valueOf(response.getStatusLine().getStatusCode()));\n                        }\n                    }\n                } catch (IOException ioe) {\n                    Log.e(LOG_TAG, \"RETAIN IOException: \" + ioe.getMessage());\n                } catch (URISyntaxException u) {\n                    Log.e(LOG_TAG, \"RETAIN URISyntaxException: \" + u.getMessage());\n                } catch (OutOfMemoryError oome) {\n                    Log.e(LOG_TAG, \"RETAIN OutOfMemoryError: \" + oome.getMessage());\n                } catch (Exception e) {\n                    Log.e(LOG_TAG, \"RETAIN Exception: \" + e.getMessage());\n                }\n                hideNotification(notifyId);\n                if (errorOccurred && host != null) {\n                    showNotification(\"Error Downloading\", host, android.R.drawable.stat_notify_error, 0);\n                    postToast(\"Error fetching \" + host);\n                }\n                dbHelper.close();\n            }\n", "label": 0, "substitutes": {"connRemote": ["execURL", " executeLocal", " executeRemote", " executeIP", " execURL", "invokeLocal", "execLocal", "invokeURL", "execRemote", " execLocal", " execRemote", "execIP", " executeURL", "invokeRemote", "invokeIP", " execIP"], "jsonObject": [" jsonString", "JSONString", "httpObj", "jsonString", "JSONObj", "JSONOperation", "JSONArray", " jsonBody", "customObj", "httpObject", "httpArray", "JSONObject", "javaOb", "jsonOperation", "javaString", "customArray", "jsonBody", " jsonOb", "customObject", "jsonObj", "javaObject", "javaBody", "jsonOb", "JSONOb", "httpOperation", "jsonArray", "customOperation", "JSONBody"], "OPCode": ["OPERcode", "OpName", " OPAction", "OpAction", " OPcode", " OPName", "opCode", "Opcode", "opName", "OPERCode", "opcode", "OPcode", "OpCode", "OPERName", "OPName", "opAction", "OPAction"], "retSrc": ["retNsrc", "retNrc", "RetAsrc", "retInRC", "retSsrc", "RetSrc", "retAsRC", "retSvc", "retNvc", "RetSuc", "retPRC", "RetAsuc", "retOsRC", "retNRC", "retOssrc", "retDRC", "retOsrc", "retInck", "retSRC", "retSck", "retPsrc", "retSuc", "retPrc", " retDrc", " retSvc", "RetSck", "retSrt", "retAsck", "retPvc", "RetAsck", "RetAsRC", "retNrt", " retDrt", " retDRC", "RetSRC", "retAsrc", "retInuc", " retSrt", "retDrt", "retInrc", "retDrc", "retAsuc", " retSRC", " retSsrc", " retDsrc", "retDsrc", "retDck", "retDuc", "retOsrt"], "httpClient": ["HttpCase", "xmlClient", "apiClient", " httpConnection", " httpCase", "httpsCall", "httpConnection", "xmlCase", "apiclient", "xmlConnection", " httpProxy", "phpclient", "httpProxy", "apiPost", "httpsPost", "phpCall", "httpsClient", "phpPost", "httpCall", "HttpClient", "HttpConnection", "httpclient", "httpsclient", "httpCase", "HttpProxy", "xmlProxy", "apiCall", "phpClient"], "httpPost": ["httpPOST", "htmlDo", "HttpRequest", "phpDo", " httppost", "webpost", "workpost", "HttpPost", "workPre", "workPost", " httpDo", "phpPOST", "HttpPOST", "webPost", "httpPre", "httpDo", "HttpCopy", "autoPost", "workDo", "httpsCopy", " httpCopy", "htmlPost", " httpPre", "httpRequest", " httpRequest", "HttpPre", "httpsPost", "HttpDo", "webPre", "httpsPOST", "httpCopy", "autoCopy", "autoPre", "phpPost", "htmlPOST", " httpPOST", "httpsPre", "httppost", "webDo", "autoPOST", "phpRequest", "htmlCopy"], "httpParams": ["httpVariars", "hrPars", "hrPams", "httpVariam", "hrPms", "httpCatars", "httpPerams", "hrParms", " httpParam", "httpPums", "httpPerums", " httpPars", "httpPam", "httpCatam", "hrParams", "httpVariums", " httpPam", "httpPars", "httpPerars", "hrParam", "httpPeram", "httpParms", "httpParums", "httpPms", " httpParums", "hrParars", "httpArgams", "httpParars", " httpPums", "hrPam", "httpCatams", " httpParars", "httpPams", "httpVariams", "httpParam", "httpArgars", " httpPams", "httpCatms", "httpArgms", "httpArgam"], "nameValuePair": ["nameValueParait", "nameValueFortion", "nameValuePore", "nameValuePiece", "nameValueProtenter", "nameNamePiece", "nameValueppair", "nameValuePerair", "nameNamePortion", "nameValuePpair", "nameNamepair", "nameValuePhiece", "nameValueCair", "nameValueProtore", "nameValuePointair", "nameVCpair", "nameValuePait", "nameNameLair", "nameValuePointenter", "nameValuePerolder", "nameValuePenter", "nameVPair", "nameNameProtore", "nameValuePointore", "nameValueCait", "nameNamePenter", "nameNameProtenter", "nameValuePhair", "nameValuePortion", "nameValueLolder", "nameValuePatch", "nameValuePointpair", "nameValueportion", "nameVPait", "nameValuepait", "nameValueParair", "nameValueSenter", "nameNameProtair", "nameValueLatch", "nameValuePeratch", "nameValuePolder", "nameNamePpair", "nameValueLair", "nameValuepair", "nameNameProtpair", "nameValueFair", "nameNamePair", "nameValueProtair", "nameValuepiece", "nameValueFiece", "nameNamePatch", "nameValueSair", "nameNameportion", "nameValueCpair", "nameNameLatch", "nameValuepolder", "nameValuePhortion", "nameValueProtpair", "nameNamePore", "nameVCair", "nameValueSore", "nameValueSpair", "nameNameLolder", "nameNamePolder", "nameVCait", "nameValueParpair", "nameValuepatch", "nameVPpair", "nameNamepiece"], "response": ["i", "server", "resource", "output", "jet", "feed", "http", "res", "site", "json", "message", "result", "throw", "session", "resp", "connection", "application", "wave", "data", "channel", "body", "entity", "page", "request", "object", "environment", "reply", "e", "tree", "status", "success", "full", "Response", " Response", "respond", "v", "block", "f", "method", "api", "view"]}}
{"id1": "149935", "id2": "19868933", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["CONverting", "subverting", "Conversion", "oconversion", "oconverting", "Converting", "CONversion", "unversion", "CONvert", "conversion", "CONception", "oconverted", " deconverted", "converting", "CONverted", "subvert", "oconvert", "Conception", "unvert", "converted", " deconverting", "subversion", "Converted", "unception", "unverted", "subverted", " deconversion", "conception", "Convert", " deconvert"], "src": ["impl", "string", "path", "sel", "ssl", "sin", "input", "sc", "uri", "resource", "sys", "spec", "rc", "Source", "video", "cmp", "username", "filename", "ref", "slice", "cb", "fp", "fn", "s", "prot", "code", "inst", "feat", "cpp", "req", "gb", "back", "source", "reader", "load", "proc", "sb", "rb", "sit", "buf", "component", "dist", "upload", "SourceFile", "config", "file", "tmp", "Dest", "supp", "attr", "img", "href", "storage", "name", "sth", "gz", "RC", "rl", "ctx", "secure", "url", "scene", "stream", "obj", "st", "stage", "sn", "ource", "download", "loc"], "dest": ["path", "class", "temp", " dst", "cont", "fn", "bin", "dc", "std", "txt", "source", "dir", "lib", "target", "dist", "tmp", "Dest", "null", "test", "home", "di", "obj", " destination", "dat", "disk", "orig", "img"], "in": ["IN", "val", "pin", "i", "input", "ex", "n", "inas", "ini", "as", "ins", "bin", "pass", "is", "reader", "d", "source", "doc", "up", "login", "r", "inc", "data", "file", "io", "t", "isin", "In", "a", "stream", "err", "inn", "ps", "f", "inf", "win", "din"], "p": ["P", "i", "pi", "op", "wp", "pre", "lp", "per", "py", "c", "j", "fp", "o", "l", "s", "pb", "cop", "part", "cp", "d", "pr", "pp", "pm", "r", "g", "parser", "h", "np", "po", "tp", "m", "e", "t", "pc", "jp", "pa", "bp", "pe", "b", "sp", "v", "ps", "f", "pd", "pg"], "ds": ["services", "uds", "ays", "docs", "ants", "dos", "s", "ins", "dp", " DS", "parts", "points", "gs", "els", " props", "des", "ts", "js", "utils", "ths", "ys", "gd", "sys", "df", "lp", "bs", "dc", " ps", "dt", "sync", "lines", "eps", "vs", "ges", "amps", "ipes", "pd", "dd", "sts", "DS", "cons", "ks", "ns", "qs", "ld", "hs", "d", "dist", "ans", "ads", "xs", "models", "plugins", "groups", "tests", "ss", "di", "os", "posts", "styles", "rs", "dl", "tools", "ded", "ups", "data", "vals", "scripts", "Ds", "ls", "obs", "dm", "db", "ils", "nas", "dates", "da", "cs", "words", "dds", "ps", "dat", "icks", " sd"], "format": ["letter", "string", "path", "class", "handler", "spec", "filename", "act", "version", "table", "fp", "fn", "host", "tag", "record", "layout", "feat", "magic", "Format", "pattern", "form", "filter", "at", "type", "source", "part", "model", "parser", "config", "data", "file", "sche", "struct", "ant", "language", "style", "plugin", "template", "name", "frame", "t", "function", "prefix", "fd", "nat", "url", "unit", "atter", "f", "scale", "api"], "hasPixelData": ["hasPixeldata", "showsPixelDATA", "hasPixelDATA", "hasPicturedata", "hasByteSize", "hasByteDATA", "hasByteData", "haspixelData", "hasPixelStyle", " hasPixelSize", "showsByteDATA", "hasPictureSize", " hasPixeldata", "haspixeldata", "showsBytedata", "hasPictureData", "haspixelSize", "showsByteData", "showsPixelData", "showsByteStyle", "hasPixelSize", "hasByteStyle", "showsPixelStyle", "hasBytedata", "showsPixeldata"], "inflate": ["inadequating", "insflode", "insvenating", "inffated", "Inflation", "InFlation", "inflating", "Inflated", "inflATE", "InFlace", "insvenate", "inadequode", "InFlated", "insflate", "infolATE", "infface", "invenode", "InFlate", "inffation", "inflated", "inFlation", "infolode", "infloace", "insvenATE", "infloate", "invenATE", "inFlate", "inadequATE", "insflATE", "infloation", "invenating", "inffate", "insvenode", "inadequate", "Inflace", "inflation", "inflode", "inFlated", "Inflate", "infolate", "inFlace", "infloated", "invenate", "infolating", "inflace", "insflating"], "pxlen": ["pxdata", "xpsize", "pxlin", "pngcount", "mxsize", "campos", "fxlen", "pxl", "pgLen", "axlen", "ppLen", "mxcount", "fxln", "pxlon", "pxln", "pcln", "pglen", "ppl", "pxlength", "ppden", "camln", "txln", "pngsize", "pxpos", "pclon", "camlen", "mxdata", "axln", "axlon", "mxlength", "mxpos", "mxlen", "xplen", "txlin", "pxden", "pxcount", "fxpos", "txlon", "pclin", "pxsize", "fxdata", "pxLen", "mxln", "xpcount", "pgl", "fxLen", "axlin", "pnglen", "xplength", "fxl", "pgden", "fxden", "pclen", "pnglength", "txlen", "pplen", "camdata"], "out": ["step", "server", "output", "copy", "sys", "user", "lock", "OUT", "inter", "outs", "line", "co", "query", "post", "session", "cache", "lib", "up", "group", "store", "parent", "work", "page", "log", "gen", "conn", "again", "Out", "io", "dump", "obj", "v", "err", "state", "pad", "cli", "error", "re", "list", "point"]}}
{"id1": "5551393", "id2": "5682569", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getMD5": ["getmd4", "getMD512", "getSHA512", "getM256", " getM512", "getmd512", "getmd5", " getM256", "getM4", " getM4", "getM5", " getM5", " getMD256", "getM512", "getmd256", "getSHA4", " getMD4", "getMD4", "getMD256", "getSHA5", " getMD512", "getSHA256"], "source": ["string", "info", "address", "buffer", "base", "temp", "input", "resource", "output", "Source", "message", "slice", "result", "dest", "length", "SOURCE", "sm", "content", "security", "seed", "proxy", "expected", "target", "config", "data", "file", "src", "text", "object", "size", "style", "name", "start", "template", "secure", "bytes", "url", "unit", "ource", "service", "code"], "tmp": ["zip", "foo", "buffer", "temp", "stuff", "bf", "output", "copy", "cmp", "vm", "var", "py", "current", "result", "dest", "fp", "html", "Temp", "cb", "meta", "vt", "cpp", "txt", "params", "part", "rb", "cache", "binary", "sb", "mp", "buf", "default", "data", "ignore", "src", "body", "emp", "metadata", "test", "array", "nm", "tt", "b", "obj", "code", "storage"], "md": ["zip", "mu", "editor", "bf", "gd", "mag", "bd", "od", "amd", "mo", "ind", "ma", "oda", "meta", "wd", "MD", " MD", "rpm", "ld", "ad", "ms", "cm", "mb", "mt", "mac", "d", "mp", "hd", "pm", "mmm", "pd", "sd", "mm", "nd", "mi", "cd", "m", "dm", "mand", "mc", "nm", "di", "mn", "mod", "vd", "rm", "mg", "mad", "cmd", "dd"]}}
{"id1": "7809093", "id2": "12678045", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"getContent": ["setContent", "requestBody", "setBody", " getData", "GetOutput", "responseBody", "GetContent", "GetData", " getBody", "requestContent", " getEntity", "GetBody", "setEntity", "GetEntity", "responseContent", "getBody", "getEntity", "responseOutput", "responseEntity", "setData", "getData", "requestEntity", "getOutput", "requestOutput"], "request": ["string", "path", "address", "handler", "input", "Request", "resource", "uri", "server", "user", "http", "report", "message", "current", "result", "instance", "query", "queue", "req", "type", "q", "operation", "connection", "r", "application", "data", "route", "object", "name", "e", "QUEST", "position", "url", "reference", "xml", "method"], "sb": ["buffer", "BB", "sf", "bf", "sk", "usb", "bd", "bh", "vm", "sg", "lp", "lb", "eb", "lab", "cb", "fp", "obb", "bs", "su", "pb", "bg", "gb", "abb", "rb", "sa", "ab", "binary", "wb", "bj", "src", "fb", "bb", "zb", "ls", "nb", "db", "sup", "bt", "ib", "bc", "bp", "b", "xb", "bm", "abi", "bsp", "amb", "SB"], "client": ["remote", "ssl", "handler", "tc", "console", "server", "output", "uri", "resource", "builder", "http", "net", "con", "per", "c", "current", "project", "host", "util", "queue", "session", "ce", "cache", "proxy", "bird", "connection", "application", "default", "config", "channel", "https", "cl", "web", "p", "context", "conn", "plugin", "force", "apache", "call", "app", "url", "Client", "connect", "container", "contact", "cli", "service", "api"], "httpParams": ["HTTPPARums", "httpArums", "httpPARams", "httpPARamas", "httpPerparams", "httpPARam", "HTTPParcs", "httpPamer", "httpPoeters", "httpPreters", "HttpParam", "httpPerams", "httpPARparams", "httpParamas", "httpAram", "httpPARcs", "httpArcs", "HTTPPARams", "HTTPPoamer", "HTTPPARcs", "httpPoparams", "httpPareters", "httpPeram", "HTTPParam", "httpPrams", "HTTPPoeters", "httpParums", "httpParparams", "HTTPParamer", "httpPeramas", "httpArams", "httpPARums", "httpPoams", "httpParcs", "httpPeters", "HttpParams", "httpPoamer", "httpPramer", "HTTPParparams", "HTTPPARam", "HTTPPoparams", "HTTPPareters", "httpPams", "httpParam", "HttpParamas", "httpPrparams", "httpPparams", "HTTPPoams", "httpParamer", "HTTPParums", "HTTPParams", "HttpParparams"], "response": ["server", "resource", "output", "feed", "report", "http", "results", "message", "json", "document", "onse", "result", "relation", "resp", "connection", "model", "application", "collection", "data", "body", "page", "object", "reply", "status", "success", "received", "Response", "respond", "successful", "error", "api", "view"], "entity": ["event", "article", "translation", "address", "node", "agent", "server", "resource", "Entity", "output", "entry", "http", "document", "json", "result", "instance", "company", "content", "ent", "type", "source", "ce", "connection", "component", "media", "model", "application", "collection", "data", "file", "body", "channel", "object", "environment", "conn", "creator", "coll", "e", "writer", "person", "pe", "em", "xml", "element", "api"], "reader": ["ry", "buffer", "loader", "i", "input", "handler", "server", "editor", "feed", "reading", "per", "inner", "ri", "driver", "read", "in", "iter", "ler", "er", "source", "bird", "oder", "ner", "r", "parser", "rar", "iterator", "row", "rr", "rer", "io", "writer", "rx", "worker", "ser", "stream", "Reader"], "line": ["val", "string", "base", "non", "job", "sel", "id", "feed", "lf", "user", "entry", "message", "LINE", "character", "ge", "end", "l", "el", "pass", "key", "iter", "content", "char", "sync", "source", "lines", "lc", "no", "len", "model", "r", "str", "data", "li", "cl", "page", "ip", "le", "inline", "row", "name", "header", "word", "link", "sl", "layer", "url", "unit", "comment", "Line", "lin", "block", "definition", "code", "cell"]}}
{"id1": "1798720", "id2": "2199604", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"save": ["release", "saving", "copy", "setup", "report", "move", "Save", "clone", "load", "upload", "store", "build", "data", "open", "archive", "change", "apply", "pack", "dump", "update", "create", "stage", "process", "make", "transfer", "transform", "install"], "packageName": ["PackageDir", "pluginPath", "PackageName", "directoryPart", "sourceDir", "packageInfo", "directoryName", "modulePath", "PackagePath", "sourcePath", " packagePath", "packagePart", "moduleInfo", " packagePart", "pluginDir", " packageNames", "packageNames", "directoryPath", "pluginPart", "PackageInfo", "sourcename", "directoryInfo", "directoryNames", "moduleDir", "moduleName", "directoryDir", " packageInfo", "PackageNames", "packagename", "packagePath", " packagename", "pluginName", "sourceName", "directoryname"], "fileContents": ["ileSources", "fileParts", "imageNames", " fileTextures", "getContent", "getContents", "FileTextures", "getParts", "FileSources", "FileContents", "fileContent", "ileNames", "fileSources", "ileTextures", " fileSources", " fileContent", "FileContent", "FileNames", "getNames", "FileHours", "imageParts", "imageContents", "fileTextures", "ileContents", "fileHours", "imageHours", "FileParts", " fileParts", " fileHours"], "fileNames": ["fTypes", "FileTypes", "FileNumbers", "fName", "fullTypes", "viewNames", "logTypes", "filenames", "pageTypes", "viewnames", "fullNames", " fileName", "playName", "fileTypes", "fullName", "logNames", "FileContents", "fileName", "fullContents", " fileTypes", "playNames", "pagenames", "viewTypes", "pageNames", "fNumbers", "logContents", " fileNumbers", "FileNames", " filenames", "fNames", "FileName", "fileNumbers", "playContents", "logName"], "dirBase": ["directoryBase", "folderBase", " dirbase", "DirPath", " dirRoot", "folderBased", "dirDir", "directoryKit", "packageBase", "dirBased", "modulebase", " dirPath", "packagebase", "moduleBased", "DirBase", "Dirbase", "directorybase", "DirKit", "dirPath", "moduleDir", "moduleBase", "folderDir", "DirDir", "directoryDir", "dirKit", "dirRoot", "packageRoot", "moduleKit", "DirRoot", "folderbase", "directoryBased", "packagePath", "dirbase"], "packageDir": ["PackageDir", " packageBase", "folderBase", "PackageDirectory", "modulePath", "PackagePath", " packageUrl", "parentUrl", " packagePath", "folderPath", "parentFolder", "packageBase", " packageLib", "packageUrl", "directoryDirectory", "PackageFile", "directoryPath", "directoryFolder", "packageFolder", "directoryUrl", " packageDirectory", "packageLib", "parentDir", " packageFolder", "moduleDir", "moduleBase", "folderDir", " packageFile", "directoryDir", "directoryFile", "parentFile", "packageDirectory", "folderLib", "packageFile", "moduleLib", "packagePath"], "created": ["path", " Created", "creation", " existed", "activated", "worked", "called", "authorized", "loaded", "Created", "result", "confirmed", "edited", "released", "failed", "established", "updated", "true", "founded", "produced", "aaaa", "needed", "used", "raised", "null", "added", "creator", "formed", "generated", "icated", "controlled", "owned", "ed", "required", "create", "left", "existent", "successful", "found", "made", "were", "paid"], "currentPath": ["CurrentDirectory", " currentDirectory", "currentlyPath", " currentRoot", "currentpath", "CurrentPage", "newRoot", "newpath", "Currentpath", "currentRoot", "currentLocation", " currentPage", " currentLocation", "CurrentLocation", "currentDirectory", "CurrentPath", "currentPage", "CurrentRoot", " currentpath", "newPath", "currentlyPage", "currentlypath", "currentlyDirectory", "newLocation"], "i": ["index", "info", "id", "uri", "pi", "n", "mu", "ini", "ie", "yi", "slice", "c", "inner", "j", "fi", "ri", "z", "current", "s", "si", "ui", "ii", "ori", "key", "qi", "part", "ti", "ji", "d", "phi", "li", "ip", "x", "h", "mi", "bi", "u", "init", "p", "ai", "oi", "name", "ci", "I", "e", "io", "eni", "start", "zi", "it", "xi", "gi", "di", "hi", "k", "isi", "me", "v", "y", "b", "iu", "multi", "f", "ix"], "file": ["play", "letter", "path", "base", "fe", "feed", "uri", "ile", "resource", "entry", "http", "filename", "place", "per", "fp", "l", "s", "child", "il", "File", "source", "rule", "dir", "up", "book", "work", "data", "out", "le", "log", "or", "folder", "name", "io", "full", "files", "pe", "unit", "b", "ul", "f"], "fos": ["fops", "cfoes", "flos", "cfob", "vos", "flops", "ofosh", "flosh", "flou", " fops", "ufob", "ufo", "Foes", "ofos", "ufoes", "cfos", "ofops", "Fosh", "flis", " fosh", "cfo", "Fis", "Fos", "fob", " foes", "voes", "fios", "fo", " fis", " fob", "vops", "fou", "vios", "Fops", "ufos", "ofou", " fo", "Fios", " fios", "Fou", "foes", "fosh", "fis"], "fileSrc": ["fileAsRC", "fileDRC", "fileAsrs", " fileDrs", " fileSRC", "FileDrec", "FileSource", "FileDrc", "fileAsrc", " fileSsrc", "fileDource", "fileDsrc", "fileDrs", " fileDRC", "fileAsrec", "FileSrec", "FileDRC", "fileDrc", "FileSRC", "fileNrc", "fileAssrc", "fileSrec", "fileNsrc", "fileSRC", "FileDource", "fileAsource", "fileNrs", "FileSrc", " fileDrc", "fileNRC", " fileSrs", "fileDrec", " fileDsrc", "fileSource", "fileSsrc", "fileSrs"], "fileDst": ["fileDsc", "FileFrc", "fileDaysrc", "fileSsc", "fileSST", "FileSsrc", "FileDrc", "fileFst", "FileFst", "fileDsrc", "fileEnST", "fileNsc", "fileDayrc", "FileSsc", "fileFsc", "fileDrc", "FileDsrc", "fileDST", "fileNrc", "FileFsc", "fileFrc", "fileEnrc", "fileNsrc", "fileEnst", "FileDst", "fileDaysc", "fileEnsc", "FileSrc", "FileDST", "fileDayst", "FileSst", "fileSst", "fileFST", "FileDsc", "FileFST", "fileSsrc", "fileNst"], "reader": ["ry", "audio", "handler", "loader", "buffer", "editor", "server", "reading", "rc", "builder", "entry", "report", "author", "per", "inner", "ri", "driver", "ro", "keeper", "read", "iter", "ler", "er", "oder", "book", "ner", "r", "parser", "data", "director", "rar", "row", "rr", "or", "rer", "e", "io", "rx", "worker", "layer", "stream", "right", "Reader", "re"], "writer": ["writing", "rw", "buffer", "handler", "editor", "outer", "output", "wr", "server", "loader", "builder", "master", "entry", "document", "author", "message", "inner", "writers", "per", "socket", "o", "later", "driver", "walker", "write", "sheet", "written", "key", "ler", "maker", "er", "Writer", "ws", "player", "book", "value", "connection", "r", "ger", "w", "parser", "data", "war", "out", "work", "widget", "e", "worker", "word", "riter", "wire", "wrapper", "wa", "with", "words", "writ", "width", "office", "element"], "line": ["letter", "string", "buffer", "job", "id", "lf", "response", "feed", "entry", "message", "LINE", "character", "ge", "end", "l", "stroke", "look", "code", "write", "jo", "pass", "key", "char", "sync", "part", "type", "source", "lines", "lc", "rule", "item", "connection", "model", "str", "data", "text", "page", "object", "le", "log", "row", "inline", "style", "name", "header", "cr", "cle", "word", "link", "url", "unit", "comment", "Line", "lin", "block", "error", "definition", "column", "cell"]}}
{"id1": "255765", "id2": "18114701", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"f": ["path", "fun", "fe", "sf", "n", "fs", "feed", "cf", "df", "fa", "lf", "bf", "rf", "filename", "c", "ref", "j", "fc", "fp", "fi", "l", "s", "fn", "fr", "ff", "form", "fold", "d", "r", "g", "w", "file", "flat", "h", "x", "p", "name", "folder", "e", "m", "io", "t", "fo", "fm", "function", "F", "fd", "self", "a", "fen", "of", "v", "b", "tf", "inf", "this", "fx"], "in": ["IN", "pin", "ssl", "fa", "token", "ini", "ic", "ins", "bin", "thin", "vin", "get", "gen", "it", "a", "with", "din", "ex", "serv", "lock", "part", "source", "up", "connection", "min", "r", "str", "g", "w", "rin", "again", "exec", "isin", "In", "lin", "b", "v", "inn", "win", "n", "gin", "con", "inner", "socket", "session", "reader", "d", "diff", "p", "init", "or", "m", "image", "nin", "ac", "cin", "fe", "input", "c", "l", "pass", "is", "login", "inc", "config", "data", "rec", "t", "err"], "cbuf": ["cbux", "dbuf", "zbuff", "bbuff", "fbbuf", "cfbuf", "rbuff", "bbull", "cbul", "bcul", "CBuc", "bcuc", "bcull", "CBuf", "CBuff", "zbuu", "cfuf", "fbuc", "bcurs", "dbuc", "rbuc", "cbutf", "rbuu", "cbbuf", "cburs", "CBul", "bault", "bux", "buff", "ebuu", "buf", "cfuc", "rbutf", "rbbuf", "rbull", "bcuf", "bcuff", "bcault", "ebuf", "fbuff", "rbux", "zbuf", "bcur", "ebutf", "cbuff", "rbuf", "rburs", "rbul", "cbull", "cbuc", "bbuf", "cbuu", "cfuff", "fbuf", "zbutf", "dbuff", "ebuff", "bburs", "bcux", "dbur", "cfur", "rbault", "cbur", "cbault"], "read": ["index", "Read", "each", "hex", "run", "ride", "en", "raw", "only", "q", "build", "open", "used", "get", "lex", "it", "readable", "ed", "print", "know", "buffer", "num", "id", "feed", "rc", "add", "report", "oct", "ack", "ind", "end", "find", "sync", "use", "load", "r", "g", "work", "w", "level", "un", " READ", "fill", "name", "bit", "ing", "full", "skip", "connect", " reading", "val", "play", "close", "reading", "ok", "socket", "se", "length", "write", "record", "iter", "sleep", "loop", "er", "allow", "reader", "d", "old", " Read", "bind", "insert", "start", "change", "io", "update", "create", "y", "wait", "repeat", " write", "ink", "error", "view", "valid", "ak", "input", "child", "draw", "reads", "pass", "key", "last", "select", "type", "want", "seek", "inc", "data", "text", "config", "check", "x", "size", "log", "put", "cel", "send", "call", "pe", "k", "parse", "stream", "ize", "count", "READ", "re", "orig"], "totRead": ["octotoLength", "tottedWrite", "TotGet", "tcotClose", "tcotRead", "dottLoad", "octotWrite", " totalBuild", "tottedGet", "tntReader", "tottUse", "octotoRead", "totLink", "totBuild", "towLength", "dottReader", "totoLength", "tazonClose", "tetReading", "toyDraw", "totClose", "totiBuild", " totWrite", "notLoad", "notWrite", "intottBuild", "tottLength", "tottAccept", "totalLoad", "towLoad", "totalLink", " totalWrite", "nottAccept", "towWrite", "nottRead", "totoSearch", "tochRead", "intotLoad", "tottReading", "tottWrite", "toyWrite", "tollRead", "tottedRead", "tottLoad", "octotLength", "TotConnect", "ntotWrite", "tetRead", "TotLoad", "totoUse", "tntRead", "dottUse", "octotReading", "TottConnect", "ntottLoad", "TotSearch", "TotaRead", "totoLoad", "tntLoad", "TotaLoad", "tottClose", "totDraw", "totLength", "towAccept", "TottReading", "tobyRead", "intotClose", "towReading", "totingSearch", "totaDraw", "totoWrite", "TotDraw", "nottLoad", "toyRead", "tcotBuild", "totReading", "totConnect", "octotRead", "ntottWrite", "totalAccept", "totalRead", "totLoad", "tazonBuild", "totalBuild", "tntWrite", "totoRead", "dotRead", "ntotRead", "totingWrite", "ntotLoad", "totReader", "notAccept", "totaRead", " totBuild", "tottSearch", "ntottReader", "notRead", "totingRead", "totWrite", "tazonLoad", "totingGet", "dotLoad", "dotReader", "dotUse", "dottFind", "tobyFind", "TotaWrite", "tochLoad", "tottedFollow", "ntotReader", "intotRead", "intottLoad", "totUse", "totaReading", "totaLoad", "totaWrite", "tcotLoad", "TottReader", "tottReader", "totiRead", "tatRead", "totiWrite", "dottWrite", "toyLoad", "TottFollow", "tottFollow", "tatLoad", "totingConnect", "dotFind", "tochReader", "tottConnect", "dottReading", "intotBuild", "TotReader", "totoFind", "tollLoad", "tochWrite", "tobyUse", "tottDraw", "dottRead", "totaLink", "tobyLoad", "totoConnect", " totalRead", "totingFollow", "TottLoad", "TottWrite", "TotaDraw", "tottRead", "tetWrite", "totFind", "nottWrite", "towRead", "TotReading", "totalWrite", "octotoReading", "tollReading", "tatReader", "tollWrite", "dotReading", "tottFind", "ntottRead", "intottRead", "totiLink", "totFollow", "tetLoad", " totalLink", "tazonRead", "totSearch", "TotFollow", "totGet", "octotoWrite", "TottRead", "TotRead", "totaBuild", "TottGet", " totLink", "intottClose", "totoReading", "tottGet", "TottSearch", "totaReader", "dotWrite", "totAccept", "tottBuild", "tatWrite", "TotWrite"], "out": ["ex", "output", "n", "plus", "outer", "net", "c", "OUT", "socket", "o", "outs", "l", "fn", "s", "off", "bin", "client", "sync", "part", "d", "up", "connection", "r", "g", "w", "inc", "parent", "file", "h", "x", "p", "conn", "init", "again", "exec", "Out", "io", "t", "exp", "writer", "In", "a", "ext", "conf", "v", "b", "err", "obj", "ac"], "i": ["index", "ini", "ic", "ii", "q", "chi", "ci", "I", "eni", "zi", "it", "hi", "iu", "multi", "info", "buffer", "id", "ind", "z", "ui", "ori", "ti", "source", "r", "g", "ip", "mi", "ai", "name", "oi", "e", "b", "v", "ik", "uri", "ei", "yi", "slice", "o", "length", "qi", "one", "ji", "d", "phi", "h", "p", "bi", "u", "init", "start", "m", "io", "di", "y", "ni", "api", "ix", "input", "pi", "ie", "c", "current", "j", "fi", "ri", "l", "si", "is", "key", "my", "data", "li", "x", "xi", "gi", "k", "me", "abi"]}}
{"id1": "5551393", "id2": "8588992", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public ActionForward perform(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String status = null;\n        HttpSession session = request.getSession();\n        ReportingBean reportingBean = null;\n        NewConceptBean conceptBean = null;\n        String conceptName = null;\n        String primitive = null;\n        MessageResources errorMessages = MessageResources.getMessageResources(\"com.apelon.apps.dts.treebrowser.resources.error_messages\");\n        LogonUtilities logonUtilities = new LogonUtilities();\n        if (logonUtilities.checkSession(session, status, reportingBean, errorMessages)) {\n            reportingBean = (ReportingBean) session.getAttribute(\"reportingBean\");\n            if ((reportingBean.getMessageHtml().indexOf(\"Classify\")) == -1) {\n                reportingBean.setReportingHtml(\"\");\n            }\n            conceptBean = (NewConceptBean) session.getAttribute(\"newConceptEntity\");\n            conceptName = request.getParameter(\"conceptName\");\n            primitive = request.getParameter(\"primitive\");\n            if (primitive == null) {\n                primitive = \"false\";\n            }\n            conceptBean.setConceptName(conceptName);\n            conceptBean.setPrimitive(primitive);\n            String namespace = conceptBean.getConceptNamespace();\n            if (namespace == null) {\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_3\"));\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n                return (mapping.findForward(status));\n            }\n            String[] roleMods = request.getParameterValues(\"some_or_all\");\n            String[] roleGrps = request.getParameterValues(\"role_group\");\n            Vector roles = conceptBean.getRoles();\n            RoleBean[] roleCons = new RoleBean[roles.size()];\n            roles.copyInto(roleCons);\n            if (roleMods != null && roleGrps != null && roleCons != null) {\n                if (roleCons.length == roleMods.length && roleCons.length == roleGrps.length) {\n                    for (int i = 0; i < roleCons.length; i++) {\n                        roleCons[i].setSomeOrAll(roleMods[i]);\n                        roleCons[i].setRoleGroup(roleGrps[i]);\n                    }\n                }\n            }\n            session.setAttribute(\"newConceptEntity\", conceptBean);\n            NewConceptXMLDisplayBean xmlBean = new NewConceptXMLDisplayBean();\n            xmlBean.setNewConceptXml(conceptBean);\n            String data = BrowserUtilities.encodeUrl(\"conceptXml\") + \"=\" + BrowserUtilities.encodeUrl(xmlBean.getNewConceptXml()) + \"&\" + BrowserUtilities.encodeUrl(\"nameSpace\") + \"=\" + BrowserUtilities.encodeUrl(namespace);\n            XMLPropertyHandler configPh = new XMLPropertyHandler(\"dtsbrowserclassify.xml\");\n            Properties configProps = configPh.getProps();\n            String urlString = configProps.getProperty(\"url\");\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuffer buf = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                buf.append(line);\n            }\n            String resultXml = buf.toString();\n            wr.close();\n            rd.close();\n            ClassifiedConceptBean ccBean = new ClassifiedConceptBean();\n            ClassifyResultParser parser = new ClassifyResultParser(resultXml);\n            ResultBuilder rbuilder = new ResultBuilder();\n            rbuilder.setConceptBean(ccBean);\n            rbuilder.setParser(parser);\n            rbuilder.setNamespace(namespace);\n            try {\n                rbuilder.buildResult();\n                ccBean = rbuilder.getConceptBean();\n                ClassifiedConceptDisplayBean displayBean = new ClassifiedConceptDisplayBean();\n                displayBean.setNewConceptHtml(ccBean);\n                session.setAttribute(\"classifyResult\", ccBean);\n                session.setAttribute(\"classifyDisplayResult\", displayBean);\n                status = \"success\";\n            } catch (Exception e) {\n                Categories.dataServer().error(StackTracePrinter.getStackTrace(e));\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_1\") + e.getMessage());\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n            }\n        }\n        return (mapping.findForward(status));\n    }\n", "label": 0, "substitutes": {"getMD5": ["getmd4", "getMD512", "getSHA512", "getM256", " getM512", "getmd512", "getmd5", " getM256", "getM4", " getM4", "getM5", " getM5", " getMD256", "getM512", "getmd256", "getSHA4", " getMD4", "getMD4", "getMD256", "getSHA5", " getMD512", "getSHA256"], "source": ["string", "info", "address", "buffer", "base", "temp", "input", "resource", "output", "Source", "message", "slice", "result", "dest", "length", "SOURCE", "sm", "content", "security", "seed", "proxy", "expected", "target", "config", "data", "file", "src", "text", "object", "size", "style", "name", "start", "template", "secure", "bytes", "url", "unit", "ource", "service", "code"], "tmp": ["zip", "foo", "buffer", "temp", "stuff", "bf", "output", "copy", "cmp", "vm", "var", "py", "current", "result", "dest", "fp", "html", "Temp", "cb", "meta", "vt", "cpp", "txt", "params", "part", "rb", "cache", "binary", "sb", "mp", "buf", "default", "data", "ignore", "src", "body", "emp", "metadata", "test", "array", "nm", "tt", "b", "obj", "code", "storage"], "md": ["zip", "mu", "editor", "bf", "gd", "mag", "bd", "od", "amd", "mo", "ind", "ma", "oda", "meta", "wd", "MD", " MD", "rpm", "ld", "ad", "ms", "cm", "mb", "mt", "mac", "d", "mp", "hd", "pm", "mmm", "pd", "sd", "mm", "nd", "mi", "cd", "m", "dm", "mand", "mc", "nm", "di", "mn", "mod", "vd", "rm", "mg", "mad", "cmd", "dd"]}}
{"id1": "14053882", "id2": "14794404", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "label": 1, "substitutes": {"encrypt": [" encode", "encryption", " encryptrypt", "decryption", " encryptryption", " enryption", " enrypt", " enipher", " encryptcode", "decipher", "deccode", "enccode", "encipher", "decrypt", " encryptipher"], "plaintext": ["protectedText", "plainfont", "batfont", "plainText", "protectedstruct", "protectedtext", "encryptedtext", "encryptedstruct", " plainstring", "plainstruct", "plainstring", "plaincontent", "batstring", "protectedcontent", " plaincontent", " plainText", "givenstring", "batsource", "giventext", " plainfont", "givenfont", " plainsource", "plainsource", " plainstruct", "givensource", "encryptedText", "battext", "encryptedcontent"], "md": ["pkg", "mu", "mag", "bd", "od", "df", "Cmd", "amd", "mo", "kg", "ma", "cb", "am", "meta", "dr", "wd", "MD", "dc", " MD", "ms", "sm", "ad", "material", "cm", "mt", "dh", "d", "mac", "mb", "mage", "mp", "hd", "sha", "pm", "pd", "data", "mm", "metadata", "cd", "dig", "po", "m", "hm", "dm", "mand", "mc", "nm", "alg", "mod", "da", "ph", "mg", "mad", "cmd", "dd", "pg", "code"], "raw": ["string", "original", "buffer", "input", " RAW", "response", "feed", "clean", "enc", "rc", "rew", "ack", "json", "RAW", "hex", "instance", "unknown", "load", "binary", "sha", "buf", "serial", "shared", "wave", "Raw", "data", "text", "empty", "row", "null", "unsigned", "image", "pure", "array", "dec", "pack", "full", "stream", "auth", "partial", "wrapper", "block", "initial"], "hash": ["index", "base", "buffer", "sum", "her", "id", "response", "ashes", "message", "version", "kh", "hex", "Hash", "html", "length", "ash", "key", "password", "mac", "cache", "rh", "sha", "data", "h", "log", "href", "header", "image", "ha", "array", "url", "sh", "secret", "auth", "block"]}}
{"id1": "18731843", "id2": "5707205", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "            public void run() {\n                Log.d(LOG_TAG, \"Fetching \" + url);\n                WebDbAdapter dbHelper = new WebDbAdapter(mContext);\n                dbHelper.open();\n                boolean errorOccurred = true;\n                int notifyId = 0;\n                String host = AppUtils.getHostFromUrl(url);\n                try {\n                    if (host == null) {\n                        Log.d(LOG_TAG, \"Bad url \" + url);\n                        errorOccurred = true;\n                    } else {\n                        notifyId = showNotification(\"Fetching \" + host, \"Fetching \" + host, android.R.drawable.stat_sys_download, 0);\n                        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);\n                        String userAgent = sp.getString(mContext.getString(R.string.pref_key_user_agent), mContext.getString(R.string.default_user_agent));\n                        Log.d(LOG_TAG, \"Using user agent=\" + userAgent);\n                        AndroidHttpClient ahc = AndroidHttpClient.newInstance(mContext, url, userAgent);\n                        URI uri = new URI(url);\n                        URI norm = new URI(uri.getScheme().toLowerCase(), uri.getUserInfo(), uri.getHost().toLowerCase(), uri.getPort(), uri.getPath(), uri.getQuery(), null);\n                        norm = norm.normalize();\n                        HttpUriRequest get = new HttpGet(norm);\n                        HttpResponse response = ahc.execute(get);\n                        if (response.getStatusLine().getStatusCode() == 200) {\n                            HttpEntity entity = response.getEntity();\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            entity.writeTo(baos);\n                            String data = baos.toString();\n                            for (int i = 0; i < undesirables.length; i++) {\n                                Pattern p = Pattern.compile(undesirables[i], Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n                                data = data.replaceAll(p.pattern(), \"\");\n                            }\n                            long sysMillis = System.currentTimeMillis();\n                            String newFileName = getPath(sysMillis, sp.getBoolean(mContext.getString(R.string.pref_key_store_sdcard), false));\n                            FileOutputStream strm = new FileOutputStream(newFileName);\n                            Log.d(LOG_TAG, \"Writing to \" + newFileName + \" for url \" + url);\n                            String jsData = AppUtils.fromRawResourceFile(R.raw.retain_loadcolors, mContext);\n                            jsData = jsData.replaceAll(\"@css_file\", RETAIN_COLORS_CSS);\n                            strm.write(jsData.getBytes());\n                            strm.write(data.getBytes());\n                            strm.write(jsData.getBytes());\n                            strm.flush();\n                            strm.close();\n                            String entryName = getTitle(newFileName, url);\n                            long newRowId = dbHelper.createEntry(entryName, newFileName, url, sysMillis);\n                            postToast(\"Downloaded \\\"\" + entryName + \"\\\"\");\n                            errorOccurred = false;\n                            if (deleteRowId != 0) {\n                                Log.d(LOG_TAG, \"Deleting rowId=\" + deleteRowId);\n                                dbHelper.deleteEntry(deleteRowId);\n                                if (url == null) postToast(\"Item Deleted\");\n                                mContext.startActivity(new Intent(mContext, RetainActivity.class));\n                            } else {\n                                showNotification(\"Download Complete\", entryName, android.R.drawable.stat_sys_download_done, newRowId);\n                            }\n                        } else {\n                            Log.e(LOG_TAG, \"Response code=\" + String.valueOf(response.getStatusLine().getStatusCode()));\n                        }\n                    }\n                } catch (IOException ioe) {\n                    Log.e(LOG_TAG, \"RETAIN IOException: \" + ioe.getMessage());\n                } catch (URISyntaxException u) {\n                    Log.e(LOG_TAG, \"RETAIN URISyntaxException: \" + u.getMessage());\n                } catch (OutOfMemoryError oome) {\n                    Log.e(LOG_TAG, \"RETAIN OutOfMemoryError: \" + oome.getMessage());\n                } catch (Exception e) {\n                    Log.e(LOG_TAG, \"RETAIN Exception: \" + e.getMessage());\n                }\n                hideNotification(notifyId);\n                if (errorOccurred && host != null) {\n                    showNotification(\"Error Downloading\", host, android.R.drawable.stat_notify_error, 0);\n                    postToast(\"Error fetching \" + host);\n                }\n                dbHelper.close();\n            }\n", "label": 0, "substitutes": {"doBody": ["doFile", "handleFile", "handleResponse", "handleBytes", "handleBody", "doResponse", " doBytes", " doFile", "doBytes", "DoBody", "DoBytes", "DoFile", " doResponse", "DoResponse"], "req": ["qt", "info", "Request", "resource", "sem", "spec", "serv", "report", "res", "http", "ref", "fr", "query", "comp", "reader", "rh", "proc", "q", "r", "crit", "config", "data", "qq", "src", "request", "requ", "rr", "rec", "conn", "rss", "cgi", "rx", "jp", "respond", "err", "obj", "reg", "def", "this", "download"], "resp": ["val", "respons", "job", "serv", "response", "cmp", "report", "res", "pre", "ref", "result", "cb", "html", "api", "inv", "prot", "ret", "comp", "part", "cache", "Resp", "proc", "r", "data", "exc", "rep", "request", "bb", "p", "reply", "rr", "rec", "pos", "jp", "rev", "respond", "Response", "err", "sp", "b", "obj", "re", "download"], "bis": ["uds", "sin", "usb", "iss", "lis", "bh", "alis", "tis", "obb", "bs", "obos", "bin", "ois", "is", "ori", "obi", "bes", "binary", "sb", "oris", "bps", "ais", "bian", "ubis", "bas", "nis", "fb", "phis", "bb", "bi", "ris", "obs", "isin", "lins", "iris", "ios", "atis", "ses", "pins", "sis", "b", "abi", "los", "os", "bits", "rots", "bid", "boot", "mis"], "bos": ["uds", "mos", "oses", "fits", "bh", "antis", "zos", "tis", "bones", "obb", "bs", "bo", "obos", "ois", "bin", "oos", "obo", "obi", "bes", "ros", "ops", "bps", "ubis", "bas", "bris", "bott", "las", "phis", "bi", "opus", "aos", "obs", "oks", "lins", "ios", "oS", "osa", "lol", "los", "zo", "abi", "oops", "os", "oros", "osi", "bits", "boot"]}}
{"id1": "14878593", "id2": "823074", "code1": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"hyperlinkUpdate": ["hyperflowStyle", " hyperLinkStyle", " hyperlinkStyle", "hyperLinkStyle", "hyperflowUpdate", " hyperLinkEvent", "hyperlinkUpdated", "hyperflowUpdated", " hyperlinkEvent", "hyperlinkStyle", "hyperLinkUpdate", "hyperimageUpdated", "hyperlinkEvent", "hyperLinkEvent", "hyperLinkUpdated", " hyperLinkUpdated", "hyperflowEvent", "hyperimageEvent", "hyperimageUpdate", " hyperlinkUpdated", " hyperLinkUpdate", "hyperimageStyle"], "e": ["event", "handler", "ee", "entry", "ie", "message", "c", "o", "el", "ec", "er", "type", "ce", " event", "eve", "g", "data", "ea", "de", "exc", "x", "p", "es", "ae", "u", "environment", "E", "m", "t", "change", "exec", "it", "a", "ev", "ed", "this", "v", "Event", "events", "f", "element", "enter", "esi"], "url": ["event", "string", "path", "base", "address", "ssl", "buffer", "server", "uri", "resource", "absolute", "video", "http", "filename", "l", "large", "location", "URL", "host", "email", "source", "browser", "connection", "config", "data", "file", "channel", "text", "page", "object", "log", "plugin", "image", "io", "link", "sl", "secure", "layer", "Url", "f", "element", "service", "download", "view"], "stream": ["path", "string", "ssl", "buffer", "handler", "temp", "input", "loader", "output", "response", "feed", "resource", "video", "http", "draft", "per", "oper", "driver", "pool", "thread", "trans", "read", "raw", "form", "client", "reader", "source", "Stream", "upload", "data", "file", "channel", "out", "src", "flash", "log", "or", "io", "image", "port", "sl", "wrapper", "sw", "f", "engine", "transform", "view"], "writer": ["string", "letter", "writing", "buffer", "handler", "temp", "rw", "output", "builder", "entry", "draft", "document", "author", "inner", "writers", "driver", "WR", "write", "written", "key", "Writer", "reader", "source", "player", "r", "w", "data", "text", "channel", "widget", "null", "format", "io", "word", "worker", "unit", "riter", "xml", "words", "wrote", "writ", "office", "engine", "this", "service", "storage"], "editor": ["article", "order", "translation", "info", "server", "video", "paper", "settings", "builder", "ie", "document", "author", "o", "html", "driver", "api", "edited", "layout", "manager", "button", "ui", "owner", "content", "er", "part", "reader", "player", "cover", "oder", "browser", "ner", "ob", "parser", "Editor", "config", "parent", "text", "attr", "open", "director", "archive", "object", "journal", "widget", "fb", "options", "plugin", "creator", "title", "edit", "io", "font", "area", "layer", "flower", "comment", "riter", "external", "office", "this", "term", "auto"], "name": ["anc", "letter", "string", "path", "base", "address", "info", "NAME", "id", "n", "uri", "username", "filename", "version", "number", "large", "ame", "time", "key", "part", "type", "source", "one", "no", "value", "connection", "default", "alias", "none", "data", "file", "names", "object", "size", "null", "style", "title", "Name", "image", "action", "home", "label", "word", "full", "prefix", "comment", "office", "named"], "dialog": ["llOG", "navbox", "lOG", "dialob", "dialoc", "collogs", "collOG", "fbot", "paloc", "palog", "demogged", "dialbox", "chooc", "lob", "dialOG", "dialect", "fogg", "navog", "locogue", "flogue", "flOG", "navect", "videoogged", "logue", "collogue", "fogged", "dialogged", "choog", "dialogs", "chobox", "plob", "flogs", "locOG", "flog", "collog", "navoc", "locog", "log", "dialogue", "demogg", "palect", "locob", "choect", "videobot", "plogue", "fog", "llogs", "dembot", "llogue", "plog", "llog", "dialbot", "videoogg", "videoog", "palbox", "demog", "dialogg", "plOG"]}}
{"id1": "20568568", "id2": "17999474", "code1": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "code2": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "label": 0, "substitutes": {"createHTML": ["CreateH", "newCSS", "CreateCSS", "CreatePDF", "createPDF", "newHTML", "createH", " createH", "CreateHTML", "createCSS", " createCSS", "newH", "newPDF", " createPDF"], "requestPage": ["pagePage", "RequestPage", "requestPC", "thispage", "requestRequest", " requestPages", " requestpage", "RequestResult", " requestResult", "returnPages", " requestPC", "requestResult", "thisPage", "requestpage", "returnRequest", "requestPages", "returnPage", "Requestpage", "returnpage", "thisPages", "pageResult", "thisRequest", "pagePC", "RequestPC", "pagepage", " requestRequest"], "result": ["event", "string", "info", "root", "order", "sum", "output", "response", "resource", "replace", "results", "report", "res", "message", "description", "document", "cup", "json", "answer", "html", "match", "ret", "detail", "color", "content", "part", "cache", "up", "date", "value", "diff", "our", "mark", "feature", "section", "data", "page", "msg", "test", "complete", "header", "status", "success", "comment", "err", "summary", "compl", "future", "Result", "figure", "error", "menu", "valid"], "url": ["string", "path", "base", "class", "loader", "ssl", "buffer", "server", "resource", "uri", "feed", "http", "resources", "l", "host", "URL", "in", "fl", "source", "up", "connection", "r", "org", "data", "file", "src", "channel", "page", "bel", "ll", "web", "ls", "name", "image", "io", "link", "sl", "hub", "pull", "Url", "b", "f", "plug", "gl", "service", "download"], "ins": ["ains", "bis", "limits", "fe", "inas", "fs", "cons", "gin", "ks", "inner", "as", "outs", "qs", "bs", "s", "abs", "is", "in", "its", "reader", "ws", "lines", "r", "inc", "ans", "ens", "src", "vals", "plugins", "ips", "ts", "vs", "ls", "rss", "ris", "ints", "alls", "INS", "ats", "rows", "ils", "kin", "ios", "pins", "lin", "Ins", "ds", "als", "inn", "ps", "din"], "bufferedReader": ["BuffererWriter", "buffererReader", "BufferedWriter", " buffenedStream", " buffenedIn", "buffererRead", "bufferingRead", "buffenedWriter", "buffererWriter", "buffledReader", "buffaredStream", "buffledStream", "BufferedRead", "BufferedReader", "BuffererRead", "buffaredIn", "buffledWriter", "buffaredWriter", "buffenedIn", "bufferingStream", "buffledRead", "buffenedStream", " bufferedStream", "BufferedStream", "bufferingReader", "buffererStream", "bufferedWriter", "buffaredReader", " bufferedIn", "bufferedIn", "buffenedReader", "BuffererReader", " buffenedWriter", " bufferedWriter", "BuffererStream", "buffledIn", "bufferedStream", "bufferingWriter", " buffenedReader", "bufferedRead"], "cssLine": ["ssBlock", "rssFile", "urlLine", "cssline", "ssLine", "rssline", "cssBlock", "ssL", "rssBlock", "styleStr", "urlline", "ssRow", "cssFile", "csvBlock", "csvLine", "styleLine", "CSSRow", "cssL", "ssFile", "styleBlock", "csvline", "urlRow", "CSSL", "styleFile", "CSSLine", "cssStr", "ssline", "csvStr", "styleline", "ssStr", "urlL", "rssLine", "CSSline", "cssRow"], "e1": ["me8", "ae8", "er3", "E2", "e9", "ea9", "er1", "ea2", "eaone", " eone", "e8", " e9", "e2", "aeOne", "E3", " eOne", "ea1", "ae2", " e3", "E9", "er2", "e3", " e2", "me1", "me2", "erone", "eone", "meOne", "E1", " e8", "ae1", "eOne", "Eone"], "queryZoom": ["queryzoo", "queryExom", "queryZooming", " queryzom", "queryZoo", "querySlooming", " queryZooming", "querySloom", "queryScoom", "queryExoom", "queryExooming", "queryZom", "queryExoo", "queryScom", "queryzoom", "queryXoom", "queryXoo", "queryXooming", " queryZoo", "queryXom", "queryzooming", " queryzoom", "querySlom", " queryzooming", "queryScooming", " queryzoo", "queryzom", " queryZom"], "appendToHome": ["appendFromBack", " append2Back", "appendToBack", "appendFromHome", " appendOnPage", "appendToRoot", "appendToPage", " append2Home", "appendFromRoot", " appendOnHome", " appendToBack", " appendFromBack", " appendToPage", " appendFromHome", " appendOnBack", " appendOnRoot", " appendFromRoot", "appendFromPage", " appendToRoot", " append2Page", " appendFromPage", " append2Root"], "sql": ["string", "base", "ssl", "job", "id", "serv", "sys", "setup", "lock", "res", "table", "col", " SQL", "shell", "query", "database", "csv", "dl", "params", "select", "pr", "seed", "str", "eps", "sv", "ql", "body", "vals", "log", "sq", "conn", "msg", "db", "details", "QL", "comment", "SQL", "general", "printf", "statement", "expr"], "pstmt": ["pspmd", " pstm", "psthm", "pspm", "pstct", "posttr", "psthpr", "pctt", "pscmt", "pstnt", " pscct", "Pstct", " posttr", "pstpr", " postmt", " pstmp", "postmp", "pstm", "Pctnt", "pctmt", "pptct", "pctct", " pstpr", "pscm", "pcttr", " postmp", "pctm", "postmt", " pscmt", "Pctmt", " pstpt", "pstt", "ppttr", " psttr", "pstrct", "pscmd", " pstmd", "pscct", "pstrnt", "psthmt", " pscpr", "psppt", "pspmt", "pscpr", " postct", " pscpt", "Pstt", "psthmd", "pfct", "pstmd", " pstct", "pfmt", "pctpr", "pptmp", "postct", "Pstnt", "pscpt", " pscmd", "Pstmt", "pfnt", "pstrt", "pctmp", "psttr", "pstrmt", "pptmt", " pscm", "psthpt", "pctnt", "pstpt", "Pctt", "pft", "psthct", "Pctct", "pstmp"], "rs": [" Rs", "pps", "rc", "RR", "res", "RS", "results", "ks", "LS", " res", "qs", "bs", "dr", "mr", "rt", "errors", "rb", "pr", "ops", "r", "runs", "eps", "ows", "ras", "rr", "ris", "ls", "rss", " RS", "ars", "rows", "details", "rl", "relations", "cs", "ds", "rm", "rd", "ps", "sr", "Rs", "RC"]}}
{"id1": "23510383", "id2": "494226", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"saveProject": ["insertProject", "deleteProject", "saveproject", "deleteApplication", " saveApplication", " saveproject", "deleteproject", "insertproject", "saveModel", "insertModel", " saveModel", "deleteModel", "insertApplication", "saveApplication"], "file": ["directory", "zip", "path", "base", "handler", "plus", "resource", "ile", "lock", "document", "filename", "table", "project", "fp", "line", "File", "picture", "part", "use", "dir", "connection", "model", "FILE", "work", "parent", "data", "out", "local", "object", "log", "complete", "single", "folder", "image", "db", "full", "files", "found"], "types": ["services", "keys", "cats", "Types", "locks", "products", "archives", "settings", "pages", "opens", "resources", "ames", "features", "Images", "styles", "versions", "reports", "packs", "shows", "ids", "pes", "params", "parts", "projects", "tools", "uploads", "its", "users", "boxes", "links", "blocks", "strings", "ports", "eps", "tags", "names", "classes", "models", "options", "plugins", "stores", "objects", "groups", "forms", "ts", "lists", "thumbnails", "jobs", "ypes", "tests", "packages", "files", "relations", "fields", "photos", "ions", "words", "properties", "times"], "images": ["services", "features", "assets", "Images", "styles", "modules", "reports", "versions", "uploads", "users", "boxes", "blocks", "media", "tags", "scripts", "plugins", "ips", "thumbnails", "image", "videos", "rooms", "actions", "files", "photos", "png", "events", "views"], "trajectories": ["transcessors", "traventors", "transjectories", "tracessions", "traventions", "transjectors", "traveyories", "tracessors", "traventories", "traveyory", "trajections", "transcessions", "transcessories", "trajectory", "traveyors", "traventory", "tracessories", "transjections", "trajectors", "transjectory", "traveyions", "transcessory", "tracessory"], "databasesIncluded": ["daturesInclusion", "databasesINhibited", "databasesInhibited", "databytesInshibited", "databasesOutclusive", "databytesInscluding", "databasesIncluding", "databytesInhibited", "databasesOutcluded", "databasesINclusion", "databytesInsclusion", "databasesInscluding", "databasesinclusive", "databasesInscluded", "databasesInsclusive", "databytesIncluded", "daturesInsclusive", "databasesInsclusion", "daturesInsclusion", "databasesInclusive", "databasesOutclusion", "databytesIncluding", "databasesinclusion", "databasesincluded", "databasesInclusion", "databasesINcluding", "daturesInshibited", "databasesInshibited", "daturesInscluded", "daturesInclusive", "databytesInclusion", "daturesInhibited", "databasesinhibited", "databasesINcluded", "databasesOutcluding", "databasesOuthibited", "databytesInscluded", "daturesIncluded"], "onlyLinks": [" onlyLink", "alllinks", "withlinks", "justLinks", "justFiles", "allLinks", "onlyLink", "OnlyLink", "OnlyFiles", "OnlyLinks", "withLink", " onlylinks", "withLinks", " onlyFiles", "allLink", "onlyFiles", "onlylinks", "justLink"], "index": ["string", "tail", "address", "head", "i", "num", "id", "input", "ini", "ind", "slice", "end", "number", "length", "Index", "match", "key", "weight", "offset", "pattern", "xxx", "part", "value", "old", "default", "inc", "level", "page", "x", "size", "search", "position", "found", "width", "point", "initial"], "name": ["string", "path", "base", "NAME", "temp", "id", "resource", "message", "filename", "number", "large", "memory", "domain", "key", "part", "up", "connection", "default", "none", "data", "names", "size", "title", "Name", "image", "home", "unique", "full", "url", "ext", "stage", "named", "vision"], "format": ["letter", "string", "base", "handler", "temp", "feed", "filename", "current", "layout", "Format", "pattern", "offset", "form", "at", "date", "value", "parser", "config", "data", "text", "export", "struct", "language", "style", "init", "template", "header", "pretty", "status", "function", "prefix", "position", "unit", "external", "scale", "transform", "term"], "count": ["path", "base", "sum", "num", "list", "limit", "child", "length", "match", "weight", "content", "cache", "counter", "build", "parent", "level", "Count", "page", "force", "call", "process", "found", "age", "error", "code", "depth"], "version": ["directory", "string", "release", "server", "output", "video", "master", "draft", "description", "project", "python", "versions", "manager", "database", "content", "cover", "dir", "target", "application", "default", "feature", "config", "data", "channel", "section", "VERSION", "environment", "journal", "header", "image", "latest", "ver", "update", "v", "xml", "vert", "Version", "vision", "download", "platform"], "writer": ["letter", "writing", "buffer", "handler", "temp", "editor", "output", "wr", "builder", "document", "author", "writers", "later", "driver", "walker", "write", "manager", "written", "er", "Writer", "reader", "player", "W", "book", "wave", "w", "parser", "data", "war", "out", "export", "director", "page", "journal", "widget", "creator", "worker", "word", "riter", "wire", "wrapper", "xml", "writ", "former", "engine"], "xmlDir": [" xmlFolder", "xmlDirectory", "jsonDirectory", "xmlPath", "jsonPath", "xmlArea", "externalDir", " xmlPath", "externalDirectory", "imageFile", "imageDir", "databasePath", " xmlArea", "databaseArea", "jsonArea", "externalFolder", "databaseDirectory", "xmlFile", "xmlFolder", "externalFile", "imageFolder", " xmlFile", "imageDirectory", "jsonDir", " xmlDirectory", "databaseDir"], "databases": ["structables", "datables", "arrabytes", "notases", "arrables", "variogs", "diations", "drations", "Datrooms", "Databases", "arrabases", "diogs", "Datations", "Datables", "notations", "structabases", "diabases", "diabytes", " datases", "Datases", " datations", "datations", "variabases", "datogs", "Databytes", " datrooms", "structases", "variabytes", "notrooms", "notabases", "drabytes", "drogs", "drabases", "datases", "variations", "datrooms", "structabytes", "databytes", "arrases"], "t": ["string", "class", "att", "i", "tm", "n", "token", "c", "j", "o", "te", "task", " T", "ty", "d", "q", "target", "w", "none", "Type", "h", "p", "ant", "ts", "title", "test", "e", "template", "m", "T", "v", "y"], "type": ["string", "ype", "info", "class", "base", "id", "token", "op", "option", "slice", "result", "o", "set", "match", "database", "key", "like", "ty", "rule", "part", "value", "target", "model", "other", "group", "collection", "parent", "data", "Type", "p", "language", "null", "style", "test", "template", "e", "action", "to", "function", "TYPE", "link", "role", "pe", "comment", "right", "y", "state", "block", "attribute", "error", "field", "definition", "single"], "currentName": [" currentMember", "currentMember", "currentStyle", " currentTime", "currentKey", "recentTime", " currentKey", "futureNames", "recentStyle", "thisName", "reportedAddress", "CurrentName", " currentPath", "reportedPath", "futureName", "currentPath", "thisPath", " currentStyle", "CurrentAddress", "CurrentPath", " currentFile", "CurrentType", "CurrentKey", "reportedNames", "currentAddress", " currentType", "thisMember", "thisTime", "reportedType", "thisStyle", "currentNames", "CurrentFile", "recentName", "currentType", "reportedKey", "recentMember", "thisAddress", "currentFile", "thisType", "futurePath", "futureFile", "currentTime", "reportedName", " currentNames", "CurrentNames"], "baseCopy": ["aseName", "basecopy", "basicCreate", "basiccopy", "aseShare", "BaseCop", " baseCreate", "binaryCop", "BaseCopy", "binaryCopy", "baseCreate", " baseCop", " baseShare", "BaseCreate", "baseCop", " baseName", "BaseShare", "asecopy", "baseShare", "baseName", " basecopy", "BaseName", "binarycopy", "Basecopy", "aseCopy", "baseSource", " baseSource", "basicCopy", "BaseSource", "basicSource"], "source": ["remote", "base", "core", "input", "server", "resource", "Source", "option", "site", "slice", "slave", "inner", "current", "result", "dest", "ie", "manager", "ources", "clone", "SOURCE", "client", "rate", "use", "reader", "cache", "proxy", "connection", "target", "component", "scope", "section", "config", "parent", "channel", "src", "text", "object", "size", "image", "scene", "unit", "stream", "reference", "ource", "service", "from", "view", "storage"], "destination": ["distination", "Destignment", "destment", "externalination", "transignment", "Destment", "transination", "destation", "externalinator", "combinator", "constinations", "distribution", " destinated", "constinator", "destinated", "combation", " destinator", "Destribution", "Destination", "Destinated", " destment", "distinator", "transribution", "Destinator", "transinator", "externalinated", "distignment", "externalment", "destribution", "destinator", "combination", "constation", "combinations", "Destinations", "destinations", "Destation", "constination", "destignment"], "clefs": ["Cleflows", "clebs", "CLEbs", "cleflows", "CLEfs", "Clebs", "clef", "CLEf", "CLEFS", "CLEflows", "Clefs", " clebs", " clef", "cleFS", "CleFS", "Clef", " cleflows", " cleFS"], "st": ["sta", "rest", "sc", "ust", "ST", "ast", "est", "set", "fr", "inst", "ld", "sm", "std", "St", "mt", "sa", "sb", "ste", "ct", "ost", "str", "ist", "src", "nd", "stru", "struct", "ts", "start", "sth", "cr", "ss", "sl", "bt", "tt", "sp", "bl", "sn", "statement", "rd", "sts"], "rs": ["R", " src", " Rs", " ans", "rc", "res", "RS", " rc", " success", "Res", " obj", " ra", " matches", " sq", " params", " repl", " RS", " changes", " re", " hits", " sr", " rm", "rd", " Result", "Rs", "RC"]}}
{"id1": "22046596", "id2": "19251426", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["zip", "Copy", "clip", " copies", "all", "write", " copying", " transfer", "sync", "cp", "upload", " cp", "file", " copied", " dup", "get", "p", "put", "exec", "io", "to", " Copy", "Transfer", "paste", "transfer", "download"], "s": ["services", "ssl", "sin", "i", "sf", "input", "fs", "ns", "c", "S", "as", "outs", "l", "ins", "se", "si", "o", "is", "less", "source", "sb", "sv", "g", "w", "gs", "src", "xs", "x", "p", "es", "south", "ts", "u", "ls", "e", "m", "ss", "sl", "files", "a", "ses", "sh", "b", "v", "ds", "os", "ps", "f", "storage"], "t": ["tc", "temp", "i", "n", "ta", "c", "z", "o", "l", " T", "ty", "at", "target", "r", "g", "down", "file", "object", "x", "p", "ts", "template", "tp", "e", "m", "ot", "to", "it", "T", "tr", "v", "b", "y", "tty", "tf", "f", "pt", "tor"], "in": ["IN", "pin", "ssl", "i", "input", "id", "n", "sin", "c", "socket", "inner", "as", "l", "ins", "bin", "is", "sync", "reader", "d", "source", "up", "login", "min", "r", "g", "inc", "rin", "file", "h", "p", "init", "conn", "again", "e", "m", "io", "In", "nin", "pull", "url", "b", "inn", "f", "win", "din"], "out": ["temp", "ex", "output", "n", "user", "net", "plain", "c", "OUT", "o", "outs", "l", "off", "bin", "client", "sync", "at", "d", "connection", "not", "g", "inc", "w", "parent", "file", "channel", "x", "p", "null", "conn", "again", "Out", "io", "image", "writer", "call", "ext", "err", "b", "v", "obj", "f"]}}
{"id1": "4501356", "id2": "1985677", "code1": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "code2": "    public SRWGuiClient(String initialURL) {\n        super(\"Simple Swing Browser\");\n        this.initialURL = initialURL;\n        addWindowListener(new ExitListener());\n        WindowUtilities.setNativeLookAndFeel();\n        JPanel topPanel = new JPanel();\n        topPanel.setBackground(Color.lightGray);\n        homeButton = new JIconButton(\"home.gif\");\n        homeButton.addActionListener(this);\n        JLabel urlLabel = new JLabel(\"URL:\");\n        urlField = new JTextField(30);\n        urlField.setText(initialURL);\n        urlField.addActionListener(this);\n        topPanel.add(homeButton);\n        topPanel.add(urlLabel);\n        topPanel.add(urlField);\n        getContentPane().add(topPanel, BorderLayout.NORTH);\n        try {\n            URL url = new URL(initialURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            boolean xml = true;\n            String inputLine;\n            StringBuffer content = new StringBuffer(), stylesheet = null;\n            Transformer transformer = null;\n            inputLine = in.readLine();\n            if (inputLine == null) {\n                System.out.println(\"No input read from URL: \" + initialURL);\n                return;\n            }\n            if (!inputLine.startsWith(\"<?xml \")) {\n                xml = false;\n                content.append(inputLine);\n            }\n            if (xml) {\n                inputLine = in.readLine();\n                if (inputLine.startsWith(\"<?xml-stylesheet \")) {\n                    int offset = inputLine.indexOf(\"href=\");\n                    String href = (inputLine.substring(inputLine.indexOf(\"href=\") + 6));\n                    href = href.substring(0, href.indexOf('\"'));\n                    System.out.println(\"href=\" + href);\n                    url = new URL(url, href);\n                    String stylesheetURL = url.toString();\n                    System.out.println(\"stylesheet URL=\" + url.toString());\n                    transformer = (Transformer) transformers.get(stylesheetURL);\n                    if (transformer == null) {\n                        BufferedReader sheetIn = new BufferedReader(new InputStreamReader(url.openStream()));\n                        sheetIn.readLine();\n                        stylesheet = new StringBuffer();\n                        while ((inputLine = sheetIn.readLine()) != null) stylesheet.append(inputLine).append('\\n');\n                        System.out.println(stylesheet.toString());\n                        TransformerFactory tFactory = TransformerFactory.newInstance();\n                        StreamSource xslSource = new StreamSource(new StringReader(stylesheet.toString()));\n                        transformer = tFactory.newTransformer(xslSource);\n                        transformers.put(stylesheetURL, transformer);\n                    }\n                }\n            }\n            while ((inputLine = in.readLine()) != null) content.append(inputLine).append('\\n');\n            htmlPane = new JEditorPane();\n            if (transformer != null) {\n                StringReader stringRecordReader = new StringReader(content.toString());\n                StringWriter xmlRecordWriter = new StringWriter();\n                StreamSource streamXMLRecord = new StreamSource(stringRecordReader);\n                transformer.transform(streamXMLRecord, new StreamResult(xmlRecordWriter));\n                String html = xmlRecordWriter.toString();\n                int i = html.indexOf('>');\n                html = \"<html>\" + html.substring(html.indexOf('>') + 1);\n                System.out.println(html);\n                htmlPane.setContentType(\"text/html\");\n                htmlPane.setText(\"<html><head><META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"><title>GSAFD Thesaurus</title></head><body><center><h2>GSAFD Thesaurus</h2></center><p>A thesaurus of genre terms to support the \\\"Guidelines on Subject Access to Individual Works of Fiction , Drama\\\" (GSAFD)</p><table cellspacing=\\\"5\\\" width=\\\"100%\\\"><tr><td><h3>Search</h3><p></p></td><td valign=\\\"top\\\"><h3>Browse</h3></td></tr></table></body></html>\");\n            } else htmlPane.setText(content.toString());\n            htmlPane.setEditable(false);\n            htmlPane.addHyperlinkListener(this);\n            JScrollPane scrollPane = new JScrollPane(htmlPane);\n            getContentPane().add(scrollPane, BorderLayout.CENTER);\n        } catch (IOException ioe) {\n            warnUser(\"Can't build HTML pane for \" + initialURL + \": \" + ioe);\n        } catch (TransformerException e) {\n        }\n        Dimension screenSize = getToolkit().getScreenSize();\n        int width = screenSize.width * 8 / 10;\n        int height = screenSize.height * 8 / 10;\n        setBounds(width / 8, height / 8, width, height);\n        setVisible(true);\n    }\n", "label": 0, "substitutes": {"calculateProfileDiffDigest": ["calculateProfilediffDigHash", "calculateProfilediffDigest", "calculateProfileDiffMDHash", "calculateProfileDiffdigests", "calculateProfileDiffdigHash", "calculateProfileDiffCodr", "calculateProfilediffDigr", "calculateProfileDiffDigr", "calculateProfilediffdigr", "calculateProfileDiffdigest", "calculateProfileDiffdigr", "calculateProfilediffdigest", "calculateProfilediffdigHash", "calculateProfileDiffMDr", "calculateProfilediffDigests", "calculateProfileDiffCodest", "calculateProfileDiffCodests", "calculateProfilediffdigests", "calculateProfileDiffCodHash", "calculateProfileDiffMDest", "calculateProfileDiffDigHash", "calculateProfileDiffMDests", "calculateProfileDiffDigests"], "profileDiff": ["picturediff", " profilediff", "messageInfo", "imageDie", " profileDelta", "settingsDiff", "familyInfo", " profileEdit", "settingsDust", "profdiff", "profileEdit", "profileDie", "profilediff", "profilePath", "profileInfo", "messagePath", "settingsDie", " profilePath", "stylediff", " profileInf", "imageDelta", "familyInf", "summaryInf", "profInfo", "summaryEdit", "styleInfo", " profileName", "messageDiff", " profileInfo", "pictureName", "pictureInfo", "styleDiff", "profDiff", "summaryDiff", " profileDust", "pictureDiff", "profPath", "settingsDelta", "familyDiff", "profileDelta", "familyEdit", "styleName", "summaryInfo", "profileName", "imageDiff", " profileDie", "imageDust", "messagediff", "profileDust", "profileInf"], "normaliseWhitespace": ["normaliseWhpacepaces", "normaliseWhitespaced", "normaliseWhpacesspace", "normaliseWhipspace", "normaliseWitespaced", "normaliseWhipsspace", "normaliseWhipespace", "normaliseWhpacespace", "normaliseWhicksspace", "normaliseWhpacespaced", "normaliseWpacesspace", "normaliseWhipespaces", "normaliseWhpacepace", "normaliseWhitespaces", "normaliseWhickspaced", "normaliseWhipesspace", "normaliseWhitesSpace", "normaliseWpacespaces", "normaliseWhipsSpace", "normaliseWitespaces", "normaliseWhipespaced", "normaliseWhitesspace", "normaliseWhipspaces", "normaliseWitesSpace", "normaliseWpacespaced", "normaliseWhickspaces", "normaliseWhpacespaces", "normaliseWitespace", "normaliseWhpacesSpace", "normaliseWhickspace", "normaliseWpacesSpace", "normaliseWpacespace", "normaliseWhpaceSpace", "normaliseWitesspace"], "md": ["editor", "bf", "gd", "mag", "bd", "df", "od", "Cmd", "amd", "message", "ma", "meta", "wd", "MD", " MD", "mb", "mt", "mac", "d", "mp", "sha", "diff", "pm", "hd", "sd", "cmd", "mm", "metadata", "cd", "dig", "msg", "m", "dm", "db", "mand", "mc", "me", "b", "ds", "rm", "mg", "mad", "f", "pd", "dd", "hash"]}}
{"id1": "9109613", "id2": "539195", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"fileCopy": [" fileTransfer", "foldercopy", "FileUpload", "fileUpload", "folderCopy", "folderTransfer", " fileUpload", "filecopy", "FileCopy", "FileTransfer", "fileTransfer", "Filecopy", "folderUpload", " filecopy"], "from_name": ["fromamename", " from_alias", "from_word", "fromqname", " from_resource", " from_key", " from_no", " from_time", "from__Name", "from_key", "from_filename", "fromameName", " from_size", "fromqpath", " from__address", "from__alias", "from__name", " from__alias", "from_no", " from_word", "from_resource", "fromTheName", " from_space", "from_Name", "from_address", "fromameno", " from_path", "from_size", " from__Name", "fromFullname", " from_image", "from_path", " from_address", "fromFullName", "from_image", "fromTheword", "fromFulladdress", "fromqName", " from_Name", " from__name", "from_time", "fromametime", "fromThename", "from_alias", " from_filename", "from_space", "fromqfilename", "fromFullalias", "fromThespace", "from__address"], "to_name": ["To_Name", "to_names", " to_key", "from_names", "from_Name", "To_name", "to_file", " to_file", "tokname", "to_key", "to_path", "to_Name", "tokcommon", "To_common", "to_common", "tokName", "from_path"], "fromFile": ["fromDir", "connectionFile", " fromfile", "FromFunction", "asFiles", " fromDir", "FromModel", " fromFolder", "toFiles", "sourcePage", "fromFolder", "autofile", "oneModel", "toLine", "FromDirectory", "fromFactory", "fromModel", "sourceFile", " fromPackage", "FromPage", "fromPackage", " fromDirectory", "ofPackage", "oneFunction", "toFunction", " fromFactory", "fromDirectory", "fromPage", "connectionFolder", "FromFolder", "sourceLibrary", " fromModel", " fromLibrary", "tofile", "FromDir", "oneDir", "oneFile", "Fromfile", "autoFolder", " fromPage", "connectionPackage", "FromFile", "asFactory", "connectionfile", "FromFiles", "FromLibrary", "FromLine", "sourceDirectory", " fromFiles", "fromfile", "fromLibrary", "asFile", " fromLine", "asfile", "ofFile", "autoPage", "fromFiles", " fromFunction", "toFactory", "offile", "autoFile", "ofFolder", "fromLine", "onefile", "fromFunction", "oneFolder", "onePage"], "toFile": ["targetFolder", "aFile", "targetPage", "toPage", "toFiles", " toFiles", "fromPage", "cofile", "targetSourceFile", "TODir", "TOFile", "ofDir", "ofTable", "toDirectory", "ToFactory", "TOPage", " toLine", " toSourceFile", "baseTable", "targetFile", "fromDir", "toLine", "targetfile", "ToFunction", " toDirectory", "toFunction", "tofile", "ToDirectory", " toPage", "baseDir", "tempfile", "fromfile", "basefile", "ToPlace", " tofile", "ofFile", "ToSourceFile", "ToLine", "sofile", "aFiles", "coFile", "aDir", "toLibrary", "Tofile", "fromDirectory", "soFile", " toFolder", " toFunction", "TOPlace", "baseFile", "targetDir", "toFolder", "coFunction", "toDir", "ToPage", "toPlace", "tempFolder", "ToFiles", "tempFactory", "afile", "noFile", "offile", "coDirectory", "fromLine", "ToDir", " toDir", "toSourceFile", "targetPlace", "nofile", "toTable", "targetFactory", "noPage", "soLibrary", "ToFile", " toFactory", "ToLibrary", " toTable", "tempFile", "soPage", "fromFiles", "toFactory", "noLibrary"], "parent": ["root", "class", "resource", "master", "any", "patch", "large", "content", "rule", "region", "file", "url", "pa", "point", "string", "address", "id", "server", "option", "location", "owner", "part", "Parent", "source", "pr", "lc", "connection", "g", "section", "page", "ip", "search", "complete", "test", "name", "exp", "full", "shape", "and", "directory", "path", "remote", "paren", "line", "session", "par", "div", "p", "null", "or", "ac", "pt", "api", "term", "valid", "user", "current", "col", "child", "pool", "manager", "key", "client", "type", "parents", "inc", "data", "out", "home", "port", "pe", "guard", "loc"], "dir": ["directory", "path", "root", "class", "lock", "per", "rel", "col", "wd", "dr", "manager", "dc", "iter", "die", "d", "Dir", "lib", "doc", "dist", "r", "group", "cat", "inc", "build", "file", "out", "ir", "attr", "director", "div", "keep", "rec", "dis", "or", "folder", "name", "coll", "dev", "dict", "home", "exp", "dec", "db", "di", "fd", "DIR", "url", "dep", "ver", "container", "def", "block", "f", "mod", "cur", "loc"], "from": ["base", "ou", "self", "vol", "user", "by", "add", "clean", "con", "per", "c", "se", "o", "api", "fr", "query", "in", "form", "flo", "client", "part", "one", "source", "ce", "so", "without", "ra", "connection", "old", "module", "wh", "component", "ch", "file", "out", "channel", "de", "empty", "get", "cm", "conn", "view", "or", "po", "name", "e", "start", "io", "cr", "normal", "who", "link", "hand", "url", "low", "stream", "can", "parse", "when", "left", "range", "with", "From", "bean", "this", "auto"], "to": ["tom", "base", "fat", "plus", "output", "token", "copy", "until", "eto", "op", "by", "pi", "on", "be", "http", "o", "api", "co", "will", "su", "via", "tto", "TO", "two", "sync", "flo", "so", "source", "type", "no", "cache", "proxy", "connection", "target", "see", "one", "not", "store", "file", "To", "out", "fb", "go", "page", "object", "size", "or", "about", "po", "name", "again", "io", "port", "db", "ver", "too", "top", "b", "with", "office", "auto"], "buffer": ["string", "total", "address", "border", "Buffer", "server", "uffer", "resource", "duration", "feed", "vector", "message", "character", "table", "document", "result", "number", "length", "memory", "read", "queue", "iter", "reader", "cache", "binary", "seed", "buff", "value", "buf", "default", "data", "channel", "page", "variable", "row", "device", "texture", "null", "header", "available", "layer", "position", "flush", "bytes", "shape", "comment", "reference", "padding", "block", "transfer", "batch"], "bytes_read": [" bytes_written", "lines_put", "bytes___read", "bytesESSreceived", "lines_written", "classes_available", "classesavREAD", "bytesaywritten", "bytesavREAD", "bytesavread", "bytesavavailable", "bytes___READ", " bytes_write", "bytes_load", "bytesESSwritten", "bytesayreceived", "bytesayput", "lines_received", "bytes_write", "lines_read", "bytes_READ", "bytes_written", "bytesavview", "bytes_put", "bytesESSread", "classes_READ", "bytes_received", "classesavavailable", "classes_read", "classes_view", "bytesayread", "bytes___view", "bytes_view", "classesavread", "classesavview", "bytes_available", "bytes___available", " bytes_load", "bytesESSput"]}}
{"id1": "949327", "id2": "16572931", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"f": ["path", "fun", "fe", "sf", "n", "fs", "feed", "cf", "df", "fa", "lf", "bf", "rf", "filename", "c", "ref", "j", "fc", "fp", "fi", "l", "s", "fn", "fr", "ff", "form", "fold", "d", "r", "g", "w", "file", "flat", "h", "x", "p", "name", "folder", "e", "m", "io", "t", "fo", "fm", "function", "F", "fd", "self", "a", "fen", "of", "v", "b", "tf", "inf", "this", "fx"], "in": ["IN", "pin", "ssl", "fa", "token", "ini", "ic", "ins", "bin", "thin", "vin", "get", "gen", "it", "a", "with", "din", "ex", "serv", "lock", "part", "source", "up", "connection", "min", "r", "str", "g", "w", "rin", "again", "exec", "isin", "In", "lin", "b", "v", "inn", "win", "n", "gin", "con", "inner", "socket", "session", "reader", "d", "diff", "p", "init", "or", "m", "image", "nin", "ac", "cin", "fe", "input", "c", "l", "pass", "is", "login", "inc", "config", "data", "rec", "t", "err"], "cbuf": ["cbux", "dbuf", "zbuff", "bbuff", "fbbuf", "cfbuf", "rbuff", "bbull", "cbul", "bcul", "CBuc", "bcuc", "bcull", "CBuf", "CBuff", "zbuu", "cfuf", "fbuc", "bcurs", "dbuc", "rbuc", "cbutf", "rbuu", "cbbuf", "cburs", "CBul", "bault", "bux", "buff", "ebuu", "buf", "cfuc", "rbutf", "rbbuf", "rbull", "bcuf", "bcuff", "bcault", "ebuf", "fbuff", "rbux", "zbuf", "bcur", "ebutf", "cbuff", "rbuf", "rburs", "rbul", "cbull", "cbuc", "bbuf", "cbuu", "cfuff", "fbuf", "zbutf", "dbuff", "ebuff", "bburs", "bcux", "dbur", "cfur", "rbault", "cbur", "cbault"], "read": ["index", "Read", "each", "hex", "run", "ride", "en", "raw", "only", "q", "build", "open", "used", "get", "lex", "it", "readable", "ed", "print", "know", "buffer", "num", "id", "feed", "rc", "add", "report", "oct", "ack", "ind", "end", "find", "sync", "use", "load", "r", "g", "work", "w", "level", "un", " READ", "fill", "name", "bit", "ing", "full", "skip", "connect", " reading", "val", "play", "close", "reading", "ok", "socket", "se", "length", "write", "record", "iter", "sleep", "loop", "er", "allow", "reader", "d", "old", " Read", "bind", "insert", "start", "change", "io", "update", "create", "y", "wait", "repeat", " write", "ink", "error", "view", "valid", "ak", "input", "child", "draw", "reads", "pass", "key", "last", "select", "type", "want", "seek", "inc", "data", "text", "config", "check", "x", "size", "log", "put", "cel", "send", "call", "pe", "k", "parse", "stream", "ize", "count", "READ", "re", "orig"], "totRead": ["octotoLength", "tottedWrite", "TotGet", "tcotClose", "tcotRead", "dottLoad", "octotWrite", " totalBuild", "tottedGet", "tntReader", "tottUse", "octotoRead", "totLink", "totBuild", "towLength", "dottReader", "totoLength", "tazonClose", "tetReading", "toyDraw", "totClose", "totiBuild", " totWrite", "notLoad", "notWrite", "intottBuild", "tottLength", "tottAccept", "totalLoad", "towLoad", "totalLink", " totalWrite", "nottAccept", "towWrite", "nottRead", "totoSearch", "tochRead", "intotLoad", "tottReading", "tottWrite", "toyWrite", "tollRead", "tottedRead", "tottLoad", "octotLength", "TotConnect", "ntotWrite", "tetRead", "TotLoad", "totoUse", "tntRead", "dottUse", "octotReading", "TottConnect", "ntottLoad", "TotSearch", "TotaRead", "totoLoad", "tntLoad", "TotaLoad", "tottClose", "totDraw", "totLength", "towAccept", "TottReading", "tobyRead", "intotClose", "towReading", "totingSearch", "totaDraw", "totoWrite", "TotDraw", "nottLoad", "toyRead", "tcotBuild", "totReading", "totConnect", "octotRead", "ntottWrite", "totalAccept", "totalRead", "totLoad", "tazonBuild", "totalBuild", "tntWrite", "totoRead", "dotRead", "ntotRead", "totingWrite", "ntotLoad", "totReader", "notAccept", "totaRead", " totBuild", "tottSearch", "ntottReader", "notRead", "totingRead", "totWrite", "tazonLoad", "totingGet", "dotLoad", "dotReader", "dotUse", "dottFind", "tobyFind", "TotaWrite", "tochLoad", "tottedFollow", "ntotReader", "intotRead", "intottLoad", "totUse", "totaReading", "totaLoad", "totaWrite", "tcotLoad", "TottReader", "tottReader", "totiRead", "tatRead", "totiWrite", "dottWrite", "toyLoad", "TottFollow", "tottFollow", "tatLoad", "totingConnect", "dotFind", "tochReader", "tottConnect", "dottReading", "intotBuild", "TotReader", "totoFind", "tollLoad", "tochWrite", "tobyUse", "tottDraw", "dottRead", "totaLink", "tobyLoad", "totoConnect", " totalRead", "totingFollow", "TottLoad", "TottWrite", "TotaDraw", "tottRead", "tetWrite", "totFind", "nottWrite", "towRead", "TotReading", "totalWrite", "octotoReading", "tollReading", "tatReader", "tollWrite", "dotReading", "tottFind", "ntottRead", "intottRead", "totiLink", "totFollow", "tetLoad", " totalLink", "tazonRead", "totSearch", "TotFollow", "totGet", "octotoWrite", "TottRead", "TotRead", "totaBuild", "TottGet", " totLink", "intottClose", "totoReading", "tottGet", "TottSearch", "totaReader", "dotWrite", "totAccept", "tottBuild", "tatWrite", "TotWrite"], "out": ["ex", "output", "n", "plus", "outer", "net", "c", "OUT", "socket", "o", "outs", "l", "fn", "s", "off", "bin", "client", "sync", "part", "d", "up", "connection", "r", "g", "w", "inc", "parent", "file", "h", "x", "p", "conn", "init", "again", "exec", "Out", "io", "t", "exp", "writer", "In", "a", "ext", "conf", "v", "b", "err", "obj", "ac"], "i": ["index", "ini", "ic", "ii", "q", "chi", "ci", "I", "eni", "zi", "it", "hi", "iu", "multi", "info", "buffer", "id", "ind", "z", "ui", "ori", "ti", "source", "r", "g", "ip", "mi", "ai", "name", "oi", "e", "b", "v", "ik", "uri", "ei", "yi", "slice", "o", "length", "qi", "one", "ji", "d", "phi", "h", "p", "bi", "u", "init", "start", "m", "io", "di", "y", "ni", "api", "ix", "input", "pi", "ie", "c", "current", "j", "fi", "ri", "l", "si", "is", "key", "my", "data", "li", "x", "xi", "gi", "k", "me", "abi"]}}
{"id1": "18891988", "id2": "20019847", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"getFile": ["downloadString", "getfile", "Getfile", "loadfile", "loadString", "loadFilename", "downloadFilename", "loadFile", "getFilename", "GetString", "GetFile", "downloadfile", "GetFilename", "downloadFile", "getString"], "serviceName": [" servicePath", "serviceUrl", "Servicename", "projectPath", "ServiceName", "servicename", "packageUrl", " servicename", "ServicePath", "projectType", "packageName", "ServiceUrl", "projectUrl", "projectName", "ServiceType", " serviceType", " serviceUrl", "packagename", "servicePath", "packagePath", "serviceType"], "wsdlLocation": ["wllAddress", "wsdlFolder", "wssdAddress", "wdlFile", "wslFolder", "wsDLUrl", "wslFile", "wllLocation", "wsslFolder", "wsslLocation", "wsdlDirectory", "wsDLFile", "wllFolder", "wdlFolder", "wsllAddress", "wslpLocation", "awsdlUrl", "wsslFile", "wslDirectory", "wddlFolder", "wsslAddress", "wslLocation", "wdlLocation", "wsDLDirectory", "wssdFile", "wsllUrl", "wslpFile", "wdlDirectory", "wslpFolder", "wsllFile", "wllFile", "awslLocation", "wddlLocation", "wssdFolder", "awslDirectory", "awsdlFile", "awslUrl", "wslUrl", "awsdlLocation", "awsdlDirectory", "wsdlUrl", "wsDLLocation", "wsdlAddress", "wsllLocation", "awslFile", "wsdlFile", "wddlDirectory", "wslpDirectory", "wsllDirectory", "wddlFile", "wdlAddress", "wssdLocation", "wsllFolder"], "endpoint": ["endaddress", "endsocol", "enpointer", "Endocol", "startPoint", " endword", "Endpoints", "enaddress", " endPoint", " endpo", "ENDpoint", " endpointer", "enpoints", "EndPoint", " endocol", "ENDPoint", "endpoints", "startpointer", "Endpo", "Endword", "enination", "enPoint", "endword", "ENDination", "endpo", " endaddress", "endpointer", "startpoint", "endocol", "Endpoint", "endspoint", "endination", "endsword", "endspo", "Endination", "endPoint", "startaddress", "ENDpoints", "enpoint"], "fileLocation": ["fileDirectory", "FileDirectory", "fileURI", "FILELocation", "FILEUrl", "FileUrl", "fileUrl", "FILEURI", " fileUrl", "FileURI", " fileDirectory", "FILEDirectory", " fileURI", "FileLocation"], "tempDir": ["TempDirectory", " tempDirectory", " tempVer", " tempPath", "tmpVer", "tmpdir", "tempPath", "TempDir", "tempDirectory", "Tempdir", "TempPath", " tempdir", " temporaryDirectory", " temporaryDir", " temporaryPath", "tmpDir", "tempVer", " temporaryVer", "tempdir", "tmpDirectory", "tmpPath"], "url": ["string", "path", "ssl", "address", "base", "server", "uri", "http", "socket", "l", "host", "URL", "el", "fl", "client", "source", "connection", "open", "config", "file", "channel", "web", "ll", "log", "conn", "ls", "coll", "image", "io", "sl", "pull", "Url", "www", "stream", "ur", "ul", "contact", "f", "service", "download"], "WSDLFile": ["WDDLFolder", "WINDLFile", "WSDLBase", "WSDLLfile", "WDDLBase", "WSDlPath", "WDDLfile", "WINDELPath", "WDDlBase", "WSDLLBase", "WSDLLSourceFile", "WSDDLSourceFile", "WSDDLFile", "WSDLfile", "WSDlFile", "WSDDLPath", "WSDLFolder", "WSDELFiles", "WSDDLfile", "WSDLLFolder", "WSDDLBase", "WSDLFiles", "WSDDLFolder", "WINDELFile", "WSDLSourceFile", "WDDlfile", "WSDLPath", "WSDlFolder", "WINDLFiles", "WINDLPath", "WSDlBase", "WSDlfile", "WSDLLFiles", "WDDLFile", "WSDELFolder", "WSDLLPath", "WSDDLFiles", "WINDELFiles", "WSDELPath", "WINDELFolder", "WDDLPath", "WDDlFolder", "WDDlFile", "WSDLLFile", "WSDlSourceFile", "WDDlPath", "WINDLFolder", "WDDlSourceFile", "WSDELFile", "WDDLSourceFile"], "tmpWSDLFile": ["tmpWSDlFiles", "tmpWSDLLFiles", "tmpWSDELFile", "tmpWSDlLocation", "tmpWSDlFolder", "tmpWSDLFolder", "tmpWDDLFile", "tmpWSDlUrl", "tmpWDDELLocation", "tmpWSDELLocation", "tmpWDDLFiles", "tmpWDDLUrl", "tmpWDDlFiles", "tmpWDDELUrl", "tmpWSDDLLocation", "tmpWDDlFolder", "tmpWSDLLUrl", "tmpWDDELFile", "tmpWSDDLFile", "tmpWDDELFiles", "tmpWSDLLFolder", "tmpWDDLLocation", "tmpWSDLFiles", "tmpWSDLUrl", "tmpWSDELUrl", "tmpWSDELFiles", "tmpWSDlFile", "tmpWDDlFile", "tmpWSDLLFile", "tmpWDDLFolder", "tmpWDDlUrl", "tmpWSDDLFiles", "tmpWSDELFolder", "tmpWSDLLocation", "tmpWSDDLUrl"], "inputFile": ["inputPlace", " inputDir", " inputBuffer", "tempPlace", "InputDir", "outputfile", "inFile", "InputBuffer", "inputBase", " inputPlace", "tempBase", " inputUrl", "inputfile", "tempUrl", "InputUrl", "inputFactory", " inputfile", "inputUrl", "infile", " inputFactory", "InputBase", "inputBuffer", "InputFile", "InputFactory", " inputStream", "inputDir", "requestFile", "requestfile", "inDir", " inputPage", " inputBase", "inputStream", "inputFiles", "requestFiles", "outputFiles", "requestStream", "InputPlace", "tempPage", "tempfile", "tempFile", "outputDir", "tempFactory", "InputFiles", "tempBuffer", "inputPage", "outputFile", " inputFiles", "inPage", "InputStream", "InputPage", "Inputfile"], "tmpFile": ["TempDirectory", " tmpFiles", "tempDocument", "uploadStream", "uploadDocument", "TempFile", "uploadFiles", "tempStream", "tempDirectory", "TempFiles", "inputDocument", "TempPage", "tmpStream", "inputStream", "inputFiles", "tmpFiles", "tmpPage", "tempPage", "tempFile", "tempFiles", " tmpDirectory", "tmpDirectory", "uploadFile", " tmpPage"], "in": ["IN", "impl", "pin", "ssl", "input", "id", "lock", "gin", "on", "c", "inner", "socket", "l", "ins", "bin", "is", "client", "reader", "source", "up", "connection", "login", "r", "inc", "data", "file", "p", "conn", "init", "again", "m", "image", "In", "lin", "inn", "f", "win", "din"], "out": ["IN", "input", "outer", "output", "copy", "server", "timeout", "on", "net", "OUT", "inner", "socket", "c", "outs", "o", "line", "co", "bin", "client", "sync", "part", "source", "cache", "up", "connection", "ch", "group", "inc", "conv", "parent", "file", "channel", "log", "conn", "again", "name", "Out", "image", "io", "writer", "to", "In", "can", "conf", "err", "error"], "con": ["IN", "close", "ssl", "Conn", "CON", "rc", "gin", "ran", "plain", "c", "inner", "socket", "fc", "ctrl", "Con", "ins", "co", "en", "nc", "sync", "client", "cm", "thin", "uc", "connection", "ch", "inc", "conv", "un", "channel", "open", "conn", "rec", "kin", "bc", "com", "can", "conf", "connect", "cn", "win"], "fileLength": ["contentLength", "channelLength", "channelLen", " fileSize", "FileSize", "fileSize", "Filelength", " fileLen", "fileLen", "contentSize", "filelength", "contentlength", "FileLength", " fileWidth", " filelength", "FileWidth", "channelSize", "FileLen", "fileWidth", "channelWidth", "contentLen"], "channelIn": ["characterIN", " channelIN", "ChannelIN", "connectionin", "connectionOut", "Channelin", "channelIN", "characterin", "channelConn", "connectionIn", "resourceIn", "channelin", "ChannelOut", " channelConn", "resourceOut", "ChannelIn", "resourcein", "ChannelConn", "resourceIN", "characterOut", "characterIn", "connectionConn", " channelin"], "channelOut": ["chanOutside", "canOutside", "ChannelOutside", "chanOut", "connectionOut", "Channelout", "canIn", " channelOutput", "channelOutside", "connectionIn", "channelOutput", "chanOUT", "channelOUT", "ChannelOut", "chanout", "chanIn", "connectionout", "ChannelIn", "connectionOutput", "channelout", "connectionOutside", "ChannelOUT", "ChannelOutput", "canOut", " channelout", "canOUT"], "tmpDocument": [" tmpContent", " tmpdocument", "mpFile", "tempDoc", "tmpNode", "tmdocument", "mpNode", "tmpDoc", "tempNode", "mpDocument", "tempDocument", "tmNode", "tmpdocument", "newContent", "tmDocument", "newDocument", "newdocument", "mpDoc", "tempdocument", "tempContent", "tmFile", " tmpDoc", " tmpNode", "tempFile", "tmpContent", "newFile"], "nl1": ["ln2", "nlone", "ln1", "nl2", "NL1", "NL11", "nn11", "arlone", "dl2", "kl5", "kl1", "NL2", "dl1", "nlFirst", "ln11", "klFirst", "klone", "arl5", "NL0", "nn1", "nn6", "jlone", "ln6", "arl1", "nl6", "jl1", "NL6", "nn0", "jl5", "nn2", "nl5", "nl11", "dl0", "nl0", "jlFirst", "arlFirst"], "i": ["index", "info", "mu", "id", "uri", "pi", "n", "ini", "ie", "yi", "slice", "j", "fi", "ri", "o", "z", "l", "si", "ui", "ii", "qi", "part", "ti", "ji", "d", "phi", "chi", "li", "ip", "mi", "p", "bi", "u", "uli", "oi", "ai", "ci", "I", "e", "m", "io", "eni", "it", "xi", "di", "gi", "hi", "v", "b", "ni", "y", "abi", "iu", "multi", "f", "ix"], "node1": ["nOne", " nodeone", "shape1", "package91", "Node2", "layer2", "n2", "node91", "Node91", "Node0", "shapeone", " node2", " node91", "Node1", "nodeOne", "packageOne", " nodeOne", "layer1", " node0", "packageone", "nodeone", "n0", "layer91", "node0", "NodeOne", "package1", "shapeOne", "n1", "shape91", "layerOne", "node2"], "tmpOut": ["ptyIn", "cacheOut", "tmpOUT", "tmpout", "tempOUT", "vmOUT", "tempWriter", " tmpIn", "vmout", "tempout", "cacheIn", " tmpOUT", " tmpWriter", "vmOut", "ptyOut", "tmpIn", "cacheOUT", "ptyout", "tempOut", "cacheFile", "tempIn", "tmpOutput", " tmpout", "ptyOutput", "vmIn", "tempFile", "tempOutput", " tmpOutput", "txtWriter", "txtOut", "txtOutput", "txtout", "tmpWriter"], "retVal": ["RETval", "valObj", " retObj", " retval", "RETVal", "valval", "valVal", "retRet", "valRet", "RETRet", "retObj", " retRet", "retval", "RETObj"]}}
{"id1": "530882", "id2": "13368520", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void sendTextFile(String filename) throws IOException {\n        Checker.checkEmpty(filename, \"filename\");\n        URL url = _getFile(filename);\n        PrintWriter out = getWriter();\n        Streams.copy(new InputStreamReader(url.openStream()), out);\n        out.close();\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndRebwrite", "readAndRebrap", "readAndRewwrite", "readAndSwrap", "readAndrewwrite", "readAndRebrite", "readandRewrap", "readandRewrites", "readAndSwwrite", "readandrewrap", "readAndRewrap", "readAndSwrite", "readandrewrites", "readandrewwrite", "readAndRebrites", "readAndRewrites", "readAndrewrite", "readAndSwrites", "readandrewrite", "readAndrewrites", "readAndrewrap", "readandRewwrite", "readandRewrite"], "inFile": [" inSourceFile", "InSourceFile", "oldfile", "outSourceFile", "inputfile", "outfile", " inFiles", "inputFilename", "InFiles", " infile", "infile", "inputFile", "outFiles", "oldFile", "loginFile", " inFilename", "Infile", "inFiles", "inputFiles", "oldFiles", "loginFilename", "loginfile", "loginFiles", "InFile", "oldFilename", "outFilename", "inFilename", "inSourceFile"], "outFile": ["newfile", "outDir", "OutStream", "processFile", "outputFilename", "exFilename", "outputfile", " outfile", "outPlace", "outFILE", "outputFILE", "outfile", "processFilename", "offFILE", "outputPlace", "thisFilename", "outStream", "thisFile", "processPlace", "exfile", "thisFILE", "newDir", "exFILE", "OutDir", "exFile", "processFILE", "newStream", "offPlace", "OutFile", " outStream", "outFilename", "offFilename", "Outfile", " outDir", "outputFile", "newFile", "thisfile", "offFile"], "iis": ["iIS", "Iais", "iIs", "iiris", "iniIs", "iiiss", "iais", "Iis", "ciis", "iiis", " iIs", " iIS", " iais", "ciiss", "Iiss", "ciais", " iiss", "iiss", "iiIS", "iniiss", " iris", "iniis", "ciris", "iniIS", "iniris", "IIS", "iris", "iiIs", "ciIS", "ciIs"], "dcmParser": ["dbmPolicy", "dbmParser", "dmmLoader", "dmissionParser", "dcmInstallation", "dmoduleJar", "dpmLoader", "dmoduleparser", "dhemReader", "dkmParser", "dmissionLanguage", "dCMPlugin", " dpmparser", " dcrParser", "fpmparser", "dhemJar", " dpmPolicy", "dkmPolicy", "dpmParser", "dcmPolicy", "dmissionPlugin", " dcmarser", "dmmPlugin", " dcrPlugin", "DcmInstallation", " dcmLanguage", "dpmHandler", "dmcJar", "dkmPlugin", " dpmParser", "dmoduleReader", " dcrLoader", "fcmReader", "dmissionReader", "dcrParser", "dmcarser", "dbmHelper", "dmLoader", "fpmHandler", "dcrarser", "dhemInstallation", "dmcParser", "dmmparser", "dpmLanguage", "dmodulePlugin", " dcmPolicy", "dpmarser", "dpmReader", "dcmPar", "dpmPar", "dmReader", "dcmparser", "dcrLoader", "dmParser", " dcmLoader", " dcmReader", "fcmparser", "dpmPolicy", "dcrJar", "dcmPlugin", "dpmparser", "fpmReader", "dcmarser", " dpmPlugin", "dbmPlugin", "dpmPlugin", " dpmHelper", "dCMLoader", " dpmLoader", " dpmJar", "dmoduleParser", " dcrReader", "dcmLoader", "fcmParser", "dpmHelper", "dcmReader", " dpmPar", "dCMHandler", "dmPlugin", "dcmJar", "dcrPlugin", "dpmJar", " dcmJar", "fcmHandler", " dcmHelper", "dCMparser", "dcrPar", "DcmParser", " dcmPar", "dcrReader", "fpmParser", " dpmReader", " dcmparser", "dmcPar", " dpmLanguage", "dcmHelper", "dpmInstallation", "dcmHandler", "dCMParser", "dcmLanguage", "dmmParser", "DcmReader", "dCMReader", "dkmHelper", " dcmPlugin", "DcmJar", "dhemParser", " dpmarser"], "ds": ["services", "ys", "uds", "ays", "DS", "iss", "gd", "sys", "Os", "df", "ants", "ns", "tes", "ks", "drivers", "qs", "bs", "s", "ins", "dr", "is", "dc", "rs", "ld", "dt", "parts", "cdn", "sync", "session", "ws", "d", "ros", "eps", "points", "icks", "ads", "data", "gs", "src", "xs", "utils", "vals", "ras", "Ds", "des", "ts", "conn", "vs", "ls", "js", "ss", "db", "ils", "di", "nas", "details", "amps", "Db", "da", "asi", "cs", "dds", "ps", "os", "dat", "pd", "dd", "tx"], "pdReader": ["hdRunner", "pbRunner", "pcReader", "pdRunner", "xdreader", "dsReader", "dsreader", "pbLoader", "hdReader", "hdreader", "dsLoader", "pcLoader", "pbStream", "hdStream", "ddStream", "pcRead", "xdWriter", "ddLoader", "pdLoader", "pdStream", "ddRunner", "pbReader", "hdWriter", "dsRead", "dsWriter", "xdRead", "pcWriter", "xdReader", "hdRead", "hdLoader", "ddReader", "pdreader", "pdRead"], "out": ["ssl", "base", "temp", "output", "net", "as", "s", "in", "at", "lib", "model", "default", "file", "gen", "conn", "Out", "url", "obj", "with", "external", "point", " in", "outer", "ex", "sys", "lock", "builder", "result", "later", "sync", "part", "cache", "up", "oder", "connection", "w", "parent", "store", "page", "object", "device", "again", "name", "exec", "exp", "array", "full", "over", "list", "order", "inner", "outs", "o", "line", "flow", "co", "write", "password", "session", "doc", "diff", "group", "director", "null", "dev", "io", "writer", "image", "to", "word", "cli", "term", "auto", "her", "copy", "user", "OUT", "child", "manager", "pass", "key", "client", "dot", "login", "inc", "down", "data", "db", "layer", "ext", "err", "code", "img"], "dcmEncParam": ["dcmEnParam", "dcmEstParam", "dcmDecParam", "dcmEnParameter", "dcmSecPart", "dcmDecType", "dcmDecPar", "dcmEncType", "dcmEncParameter", "dcmArchParam", "dcmEncPart", "dcmElParameter", "dcmEnPar", "dcmEnPart", "dcmDecArg", "dcmArchArg", "dcmArchParameter", "dcmSecPar", "dcmEnArg", "dcmDecParameter", "dcmDecPart", "dcmSecType", "dcmElParam", "dcmEstPar", "dcmEncPar", "dcmSecParam", "dcmElPar", "dcmEncArg", "dcmElType", "dcmEnType", "dcmEstType", "dcmEstParameter"], "pdWriter": ["dpWrite", "pdOutput", "ddWrite", "pdWriting", "htWriter", "dpReader", "dsReader", "hdReader", "pdWrite", "htWriting", "dpWriting", "PDWrite", "dpWriter", "hdWriter", "dsOutput", "dsWriter", "hdWrite", "htWrite", "PDWriter", "dsWrite", "ddOutput", "PDReader", "ddReader", "htReader", "PDWriting", "ddWriter", "hdOutput"]}}
{"id1": "8490710", "id2": "14317425", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"actualizar": [" actualizear", "actualizas", "actualizerar", "actualizeas", " actualizeada", "actualizeras", " actualizado", " actualizada", "actualisiada", "actualizada", "actualizado", " actualizas", " actualizeas", "actualisias", "actualizeado", " actualizeado", "actualizeada", "actualisiado", "actualizerado", "actualizerada", "actualizear", "actualisiar"], "ClassNotFoundException": ["ClassNotFoundES", "ClassNotFindException", "ClassNotSupportedException", "ClassNotPresentException", "ClassNameFoundException", "ClassNameFoundES", "ClassNotFindError", "ClassNameFoundError", "ClassNameSupportedError", "ClassNotSupportedError", "ClassNotFindES", "ClassNameSupportedES", "ClassNotPresentError", "ClassNameSupportedException", "ClassNotFoundError", "ClassNotSupportedES", "ClassNotPresentES"], "Exception": ["Connection", " exception", "Class", "Throw", "ERROR", "Request", "Entity", "Default", "Transaction", "Exp", "X", "Information", "Warning", "Failure", "ception", "Exc", "Element", "Except", "Unknown", "except", "W", "Application", "Context", "IO", "Un", "ceptions", "Adapter", "Problem", "Interface", "Fail", "Error", "E", "Ex", "F", "Engine", "T", "Null", "Abstract", "Event", "Document", "EX"], "conn": ["Connection", "ou", "Conn", "cc", "n", "enc", "rc", "ok", "con", "c", "jc", "pub", "cb", "col", "Connect", "dc", "util", "en", "nc", "client", "nt", "cm", "session", "cp", "dh", "ct", "connection", "ch", "cat", "ob", "config", "ca", "ens", "mm", "h", "p", "coll", "ci", "oss", "cr", "ann", "oci", "db", "mc", "ctx", "sql", "comm", "conf", "reg", "connect", "cn", "cs", "sn", "state", "cli", "pg", "loc"], "ms": ["keys", "ys", "ems", "tm", "mos", "DS", "sem", "fs", "res", "pse", "ns", "ks", "mo", "ma", "qs", "s", "bs", "ins", "is", "rs", "cus", "ims", "cms", "mb", "oms", "mt", "ws", "mp", "ops", "pm", "Ms", "ans", "ums", "ens", "gs", "mm", "mes", "models", "mx", "md", "mi", "es", "ts", "vs", "js", "mas", "m", "hm", "ls", "ml", "details", "mc", "sql", "mn", "em", "me", "cs", "bm", "ds", "os", "ps", "gm", "mod", "MS", "mis"], "fechaSystem": ["fechmasystem", "fekaSys", "fechasService", "fechmaSys", "fechetaSystem", "fechetaSys", "fichlaSystem", "febaSys", "fekaSystem", "fechlaSystem", "fechasSystem", "fekaSTEM", "fichaSys", "fetchaSystem", "fechmaSTEM", "fechosystem", "fechaService", "fechmaServer", "fechtaSystem", "fechlaSys", "fechasServer", "fetchmaSystem", "febasServer", "febasService", "fechasSys", "fichlasystem", "fetchaSTEM", "fechaServer", "fechmaSystem", "febaService", "fechaSys", "fetchmasystem", "fechetaService", "fechaSTEM", "fechmaService", "fekasSystem", "febasSys", "fechetaServer", "febasSystem", "fechoSystem", "fekasSTEM", "fichaSystem", "fechasSTEM", "fekasSys", "fechlaSTEM", "fechtaSys", "fechassystem", "fetchmaSTEM", "fichasystem", "fechasystem", "fetchasystem", "fichlaSys", "fechoSTEM", "fechlasystem", "febaSystem", "febaServer", "fechtasystem"], "aaaammdd": ["aaammd", "aaaammds", "aaaaamtz", "aaaammtz", "aaaasmds", "aaammtz", "aaaaamsd", "aaaaamd", "aaaammsd", "aaaamd", "aaammds", "aaaamds", "aaaaamdd", "aaaasmdd", "aaaaammtz", "aaaymmds", "aaaamsd", "aaaamtz", "aaaamdd", "aaaymmdd", "aaaasmtz", "aaaymmsd", "aaaaammds", "aaaasmd", "aaaaamds", "aaaaammdd", "aaaammd", "aaammsd", "aaaaammsd", "aaammdd", "aaaaammd", "aaaymmd"], "fzafsis": ["fzahs", "fzhafs", "fzhahsi", "fzaphsis", "fzaphtics", "fzaftics", "fzahsi", "fzAFsis", "fzAFsi", "fzhahs", "fzAFs", "fzhahtics", "fzhafsi", "fzhahsis", "fzahtics", "fzafsi", "fzhafsis", "fzaphsi", "fzhaftics", "fzAFtics", "fzaphs", "fzafs"], "hhmmss": ["hhmss", "hhms", "hhmds", "hhMMms", "hhmms", "HHmms", "hhhmmess", "hhMMds", "hhmmms", "hhhmmds", "hhMMss", "hhMMs", "HHMMss", "hhhmmmds", "hhmmess", "hhmmmds", "hhmmmss", "hhmls", "hhmdss", "HHmmms", "hhhmmss", "hhmdess", "hhhmmmss", "HHMMds", "hhhmmms", "HHmmss", "hhmlds", "hhmlss", "hhmmmess", "hhhmms", "hhmdds", "HHmmds", "HHMMs", "hhMMess", "HHMMms", "hhhmmmess", "hhmmds", "hhmlms"], "sss": ["\u00dfs", "\u00dfns", "ussses", "ssns", "ussp", "ssses", "rssns", "hesss", "ssss", "rssss", "\u00dfss", "usss", "hessns", "rssls", "rssp", "ssp", " ssss", "ussss", " ssp", "\u00dfls", "hessss", "rssses", "hessls", "ssls", " ssses", "rsss"], "ss": ["string", "ssl", "pps", "css", "ssh", "sf", "iss", "tz", "fs", "settings", "xx", "ns", "account", "styles", "s", "bs", "si", "nn", "su", "pass", "rs", "ross", "less", "ws", "hess", "str", "sv", "eps", "WS", "struct", "hh", "sq", "ts", "uss", "ls", "rss", "js", "ass", "ess", "\u00df", "vs", "oss", "sl", "ses", "ds", "cs", "st", "ng", "ps", "SS", "pg"], "fzahsis": ["fzeajses", "fzahsi", "fzaftics", "fzavsis", "fzeafsi", "fzajses", "fzajtics", "fzeajsis", "fzahtics", "fzahses", "fzavses", "fzajsis", "fzeafsis", "fzeaftics", "fzeajsi", "fzafsi", "fzavsi", "fzafses", "fzajsi", "fzeajtics", "fzeafses", "fzavtics"], "afectados": ["afectanos", "afectionanos", "rafctados", "afescantes", "afectionado", "AFectantes", "afemptadas", "AFectanos", "AFecados", "AFectados", "afecados", "afctado", "afectionados", "rafctado", "afecanos", "AFecanos", "afectadas", "afctados", "AFecantes", "afescanos", "rafectados", "afectantes", "rafctadas", "afecantes", "rafectado", "afectionadas", "AFecadas", "afctadas", "afescados", "afectado", "afectionantes", "rafectadas", "rafctatos", "afecadas", "rafectatos", "afemptados", "afemptado", "AFectadas", "afectionatos", "afemptatos", "afctatos", "afectatos", "afescadas"]}}
{"id1": "9261777", "id2": "4750967", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"source": ["zip", "string", "path", "address", "original", "index", "sin", "input", "id", "resource", "uri", "spec", "token", "Source", "element", "copy", "site", "slice", "project", "inner", "result", "dest", "se", "query", "info", "sort", "in", "SOURCE", "session", "use", "rule", "seed", "proxy", "target", "scope", "shared", "sample", "parent", "data", "text", "src", "file", "flat", "options", "config", "request", "size", "empty", "null", "style", "view", "start", "template", "force", "name", "image", "prefix", "sl", "secure", "strip", "url", "base", "unit", "parse", "comment", "missing", "ource", "service", "single"], "destination": ["distination", "Destignment", "dependination", "destinating", "homeignment", " destipping", "coordination", "Desturation", "databaseination", "Destinate", "Destinating", "databaseinated", "domuration", " destignment", "databaseinations", " destension", "destension", " destinate", "distipping", "dominated", " destinated", "destipping", "homeination", "distinated", "destinated", " destinator", "Destination", "Destinated", "distension", "homeinator", "Destinator", " destinating", "dependipping", "desturation", "dependension", "dependinated", "coordinating", "domination", "destinate", "destinator", "databaseuration", "homeinated", "coordinator", "Destinations", "destinations", "coordinate", "destignment", "dominations"], "is": ["zip", "info", "bis", "sin", "close", "i", "iss", "id", "serv", "fs", "IS", "lis", "isa", "ie", "Is", "act", "ic", "as", "ri", "se", "ins", "bs", "abs", "s", "ois", "ui", "in", "ori", "ii", "isl", "ops", "ais", "ar", "ob", "isc", "ir", "out", "ens", "nis", "src", "ip", "get", "es", "iso", "init", "or", "ai", "ris", "ci", "obs", "oss", "io", "eni", "ics", "iris", "ios", "us", "ib", "isi", "sis", "are", "was", "osi", "esi", "api", "cos", "mis"], "os": ["ou", "mos", "i", "oses", "sys", "Os", "fs", "op", "acs", "ks", "oa", "oise", "as", "dos", "OS", "o", "socket", "s", "bs", "ori", "ies", "so", "ros", "bos", "ops", "ais", "nos", "ob", "ens", "out", "ends", "es", "oes", "ose", "or", "vs", "ls", "aos", "obs", "js", "oss", "io", "ot", "pos", "ss", "ios", "us", "oS", "ds", "los", "ol", "ow", "osi", "boot", "cos"], "buffer": ["string", "address", "base", "border", "Buffer", "uffer", "feed", "copy", "server", "sequence", "slice", "limit", "result", "number", "read", "iter", "queue", "reader", "binary", "seed", "buff", "value", "buf", "wave", "data", "channel", "page", "size", "bb", "null", "header", "image", "writer", "layer", "position", "url", "bytes", "flush", "b", "reference", "padding", "pad", "transfer", "batch"], "length": ["index", "string", "total", "address", "id", "duration", "feed", "lower", "division", "lock", "character", "slice", "power", "sequence", "end", "limit", "number", "volume", "l", "match", "line", "quote", "weight", "split", "last", "offset", "key", "part", "type", "reader", "load", "value", "len", "Length", "ob", "section", "level", "data", "object", "size", "get", "row", "style", "start", "ring", "full", "strip", "position", "of", "url", "partial", "shape", "distance", "left", "range", "count", "age", "block", "width", "code", "point", "depth"]}}
{"id1": "17729554", "id2": "7425022", "code1": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"clonarFichero": ["clonarfICher", "clonarfICchio", "clonarFaichern", "clonarficher", "clonarFaicher", "clonarFiveher", "clonarFaicchio", "clonarfIChero", "clonarFaichero", "clonarFivehern", "clonarfIChern", "clonarFICchio", "clonarfichern", "clonarFichern", "clonarficchio", "clonarFicher", "clonarFICher", "clonarFivechio", "clonarfichero", "clonarFIChern", "clonarFicchio", "clonarFIChero", "clonarFivehero"], "rutaFicheroOrigen": ["rutaFicheroOrigeni", "rutaFichestOriginened", "rutaFichestOriginense", "rutaFichestOrigened", "rutaFicherOrigener", "rutaFicheroOriginen", "rutaFicherOriginalEN", "rutaFicheroOpense", "rutaFicherOrigen", "rutaFicheroOriginalense", "rutaFicheroOriginalen", "rutaFicherOrigEN", "rutaFicheroOpened", "rutaFicheroOpeni", "rutaFicherOriginalens", "rutaFicheroOrigened", "rutaFicheroOriginalena", "rutaFicheroOpEN", "rutaFicheroOpen", "rutaFicheroOpinen", "rutaFicheroOrigens", "rutaFichestOrigen", "rutaFicherOrigens", "rutaFicheroOrigener", "rutaFicheroExtened", "rutaFicheroExten", "rutaFichestOriginen", "rutaFicheroOpener", "rutaFichestOrigense", "rutaFichestOrigininen", "rutaFicheroOriginalEN", "rutaFicheroOpens", "rutaFicheroOriginalens", "rutaFicherOriginalener", "rutaFicheroOrigense", "rutaFicheroOrigEN", "rutaFicheroOriginalener", "rutaFicheroOrigena", "rutaFicheroOriginalened", "rutaFicheroOriginense", "rutaFicheroOpena", "rutaFicheroOriginalinen", "rutaFicheroOrigininen", "rutaFicheroOriginened", "rutaFicheroExteni", "rutaFicheroExtena", "rutaFicheroOriginaleni", "rutaFicherOriginalen"], "rutaFicheroDestino": ["rutaFicheroOrigina", "rutaFicheroRestina", "rutaFicheroDestina", "rutaFicherodestINO", "rutaFicheroCampino", "rutaFicheroOrigino", "rutaFicherOrigINO", "rutaFicheroDesINO", "rutaFicheroOrigin", "rutaFicherDestin", "rutaFicherDestino", "rutaFicheroDestINO", "rutaFicherDestina", "rutaFicheroOrigario", "rutaFicheroCampINO", "rutaFicheroDestination", "rutaFicherRestINO", "rutaFicheroDesina", "rutaFicheroRestario", "rutaFicherDestINO", "rutaFicherOrigin", "rutaFicherRestina", "rutaFicherDestario", "rutaFicherOrigination", "rutaFicherDestination", "rutaFicheroRestino", "rutaFicherodestino", "rutaFicherRestino", "rutaFicheroCampination", "rutaFicherodestin", "rutaFicherodestination", "rutaFicheroOrigINO", "rutaFicherRestario", "rutaFicheroDesino", "rutaFicherOrigino", "rutaFicheroCampin", "rutaFicheroRestINO", "rutaFicheroDestario", "rutaFicheroDesario", "rutaFicheroDestin", "rutaFicheroOrigination"], "salida": ["Salida", "balica", " salido", "palida", "slanda", "Salido", "salido", "saliza", "palanta", "salada", "palada", " salidas", "Salanda", "balanda", "salidi", "malida", "Salanta", "malada", " saliza", "palidi", "Salada", "salanda", " salica", "balida", "Salidas", "slida", " salanda", "malidi", "Saliza", "malanta", "balido", "salidas", "Salidi", "slidas", "salanta", "sliza", "salica", "Salica"], "canalOrigen": ["canalsOriginaln", "canelOriginalen", "canalOriginens", "canalsOriginalEN", "canalOriginaline", "canalorigain", "canalOrigened", "canalorigen", "canalorigun", "canelOrigen", "canelOriginaline", "canalorigens", "canelOriginalun", "canalOrigens", "canalOrigain", "canalOrigun", "canelOriginalens", "canalsOrigensen", "canalOriginalen", "canalOriginalensen", "canalsOrigens", "canalsOriginalen", "canalOrigensen", "canalOrdens", "canalOrden", "canalsOriginalens", "canalSequens", "canalSequen", "canalsOrign", "canelOrigun", "canalOriginalens", "canalOriginun", "canalOriginen", "canalSequEN", "canalsOrigEN", "canalsOrigain", "canalSequn", "canalOriginaln", "canalorigensen", "canalsOrigen", "canalOrdEN", "canelOrigens", "canalorigened", "canalOriginalain", "canalOrdn", "canalOrign", "canalorigine", "canalsOriginalensen", "canalOriginalEN", "canalOriginalened", "canalOrigEN", "canalsOrigened", "canalOriginine", "canelOrigine", "canalsOriginalened", "canalOrigine", "canalsOriginalain", "canalOriginalun"], "canalDestino": ["canpalDestino", "canalsDestination", "canalsdestino", "canalOrigINO", "canalOrigino", "canpaldestination", "canalsdestri", "canalCombini", "canaldestini", "canpaldestini", "canpalDestini", "canpalDestination", "canalsdestINO", "canpaldestino", "canpalDestINO", "canaldestination", "canaldestINO", "canalDestination", "canalCombino", "canalOrigini", "canalDestINO", "canalDestini", "canalsdestination", "canalOrigination", "canalDestri", "canaldestri", "canaldestino", "canpaldestINO", "canalsDestri", "canalCombINO", "canalCombination", "canalsDestino", "canalsDestINO"], "estado": ["apestano", "estada", "Estado", " featado", " Estados", " Estaid", "estados", " Estada", " estato", "estato", " estar", " estano", " estados", "gestada", "iestado", " featada", "istato", "gestado", "istar", " estaid", "istano", "istado", "iestada", "estaid", "apestato", "estar", " featados", " estada", "istaban", "iestato", "Estada", "iestaban", "gestato", "gestaban", "Estar", "estano", " estaban", "istada", "apestado", "Estaban", "estaban", "apestada", " feataid", " Estado"]}}
{"id1": "2381663", "id2": "293167", "code1": "    @Test(expected = GadgetException.class)\n    public void malformedGadgetSpecIsCachedAndThrows() throws Exception {\n        HttpRequest request = createCacheableRequest();\n        expect(pipeline.execute(request)).andReturn(new HttpResponse(\"malformed junk\")).once();\n        replay(pipeline);\n        try {\n            specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n            fail(\"No exception thrown on bad parse\");\n        } catch (GadgetException e) {\n        }\n        specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"malformedGadgetSpecIsCachedAndThrows": ["malformedGadgetSpecIsCachedandthrown", "malformedGadgetSpecIsCachedAndethrows", "malformedGadgetSpecIsCachedandthrows", "malformedGadgetSpecIsCachedAndthrows", "malformedGadgetSpecIsCachedAndThrown", "malformedGadgetSpecIsCachedAndthceptions", "malformedGadgetSpecIsCachedandthceptions", "malformedGadgetSpecIsCachedAndThceptions", "malformedGadgetSpecIsCachedandThrown", "malformedGadgetSpecIsCachedandThrows", "malformedGadgetSpecIsCachedAndethceptions", "malformedGadgetSpecIsCachedAndthrown", "malformedGadgetSpecIsCachedandThceptions", "malformedGadgetSpecIsCachedAndethrown"], "request": ["event", "job", "temp", "input", "Request", "output", "response", "resource", "server", "claim", "http", "report", "message", "result", "instance", "press", "query", "condition", "req", "queue", "er", "client", "q", "proxy", "r", "application", "config", "data", "parent", "p", "context", "complete", "test", "e", "QUEST", "call", "pe", "create", "pair", "trip", "method", "re", "enter"]}}
{"id1": "21092340", "id2": "22410173", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addtoAsIVE", "addToAsively", "addToAdaptive", "addToArchively", "addToSlIVE", "addtoAsives", "addToAsive", "addtoArchIVE", "addToAdaptively", "addToSlives", "addtoArchives", "addtoAsively", "addtoArchively", "addToAdaptives", "addToSlively", "addToAsIVE", "addToAsives", "addToSlive", "addtoAsive", "addToArchives", "addToArchIVE", "addtoArchive", "addToAdaptIVE"], "pod": ["zip", "node", "loader", "pkg", "cer", "pi", "od", "project", "per", "table", "child", "pot", "host", "pl", "ad", "post", "part", "ce", "proc", "cache", "component", "tmp", "ods", "object", "p", "product", "plugin", "po", "pc", "pid", "pe", "Pod", "peer", "pad", "plug", "bean", "module"], "podArchiveOutputStream": ["podArchiveFileDirectory", "podArchiveWriteFile", "podArchIVEInputSteam", "podArchivingWritePath", "podArchivesOutputResource", "podArchIVEOutputDirectory", "podArchiveByteStream", "podArchIVEInputFile", "podArchivingOutputFile", "podArchivesOutputFile", "podArchiveIOFile", "podArchivesOutputSteam", "podArchivesFileStream", "podArchiveFileStream", "podArchiveWritePath", "podArchiveOutputDirectory", "podArchiveByteDirectory", "podArchivingWriteStream", "podArchiveOutputPath", "podArchiveOperationFile", "podArchiveOperationStream", "podArchiveInputDirectory", "podArchiveByteFile", "podArchIVEInputStream", "podArchiveFileResource", "podArchivingOutputPath", "podArchiveFileFile", "podArchiveInputSteam", "podArchIVEOutputSteam", "podArchivingWriteSteam", "podArchiveIOStream", "podArchiveIODirectory", "podArchivingOutputSteam", "podArchiveInputPath", "podArchiveWriteStream", "podArchiveOutputResource", "podArchiveInputStream", "podArchiveOperationResource", "podArchiveFilePath", "podArchivesFileFile", "podArchivesFileSteam", "podArchivingWriteFile", "podArchivingOutputStream", "podArchiveFileSteam", "podArchIVEOutputFile", "podArchIVEInputDirectory", "podArchivesOutputStream", "podArchiveOutputFile", "podArchiveInputFile", "podArchiveIOResource", "podArchiveOperationSteam", "podArchiveWriteSteam", "podArchIVEOutputStream", "podArchiveOutputSteam", "podArchivesFileResource", "podArchiveByteSteam", "podArchiveIOSteam"], "filename": ["directory", "string", "path", "kn", "loader", "sf", "uri", "username", "dll", "kl", "subject", "sequence", "fp", "fn", "location", "l", "il", "database", "Filename", "binary", "which", "FILE", "application", "SourceFile", "alias", "file", "archive", "route", "nil", "title", "folder", "name", "fil", "label", "word", "prefix", "files", "url", "named", "download", "f", "ppa", "module", "property", "ename", "platform"], "source": ["zip", "string", "path", "loader", "input", "resource", "copy", "output", "uri", "Source", "document", "slice", "slave", "result", "driver", "SOURCE", "reader", "use", "seed", "proxy", "connection", "target", "parent", "config", "file", "src", "archive", "text", "image", "sl", "url", "stream", "unit", "stack", "ource", "service"], "entry": ["zip", "string", "article", "address", "letter", "event", "index", "path", "resource", "feed", "add", "ie", "ge", "result", "se", "child", "record", "line", "Entry", "post", "reader", "connection", "r", "parent", "data", "file", "archive", "object", "iterator", "row", "or", "e", "image", "pointer", "it", "this", "stream", "obj", "element", "auto"]}}
{"id1": "20247400", "id2": "10795866", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"in": ["IN", "i", "input", "n", "token", "gin", "con", "c", "socket", "inner", "l", "ins", "s", "bin", "pass", "client", "part", "reader", "source", "login", "diff", "connection", "r", "inc", "config", "data", "parent", "h", "p", "again", "image", "isin", "In", "nin", "a", "stream", "b", "inn", "f", "win", "this", "din"], "out": ["i", "console", "ex", "output", "sys", "server", "temp", "user", "lock", "outer", "OUT", "socket", "inner", "o", "window", "pool", "write", "line", "flow", "off", "client", "source", "cache", "up", "connection", "debug", "str", "group", "r", "inc", "w", "file", "channel", "page", "log", "style", "conn", "msg", "name", "again", "exec", "Out", "io", "image", "writer", "exp", "word", "dump", "prefix", "call", "ext", "comment", "err", "obj", "v", "print", "error", "list"], "buffer": ["border", "base", "Buffer", "input", "output", "uffer", "server", "feed", "loader", "document", "slave", "slice", "limit", "result", "window", "length", "flow", "bin", "read", "queue", "offset", "iter", "bar", "reader", "cache", "binary", "source", "buff", "buf", "wave", "config", "data", "channel", "batch", "fb", "pause", "size", "null", "context", "header", "writer", "layer", "flush", "b", "reference", "abi", "count", "pad", "f", "transfer"]}}
{"id1": "15745420", "id2": "6371589", "code1": "    private void download(String address, String localFileName) throws UrlNotFoundException, Exception {\n        String ext = G_File.getExtensao(address);\n        if (ext.equals(\"jsp\")) {\n            throw new Exception(\"Erro ao baixar pagina JSP, tipo negado.\" + address);\n        }\n        File temp = new File(localFileName + \".tmp\");\n        if (temp.exists()) temp.delete();\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            try {\n                URL url = new URL(address);\n                conn = url.openConnection();\n                in = conn.getInputStream();\n            } catch (FileNotFoundException e2) {\n                throw new UrlNotFoundException();\n            }\n            out = new BufferedOutputStream(new FileOutputStream(temp));\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n        } catch (UrlNotFoundException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        File oldArq = new File(localFileName);\n        if (oldArq.exists()) {\n            oldArq.delete();\n        }\n        oldArq = null;\n        File nomeFinal = new File(localFileName);\n        temp.renameTo(nomeFinal);\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"download": ["zip", "release", "output", "copy", "register", " downloading", "Download", "save", " transfer", "source", "load", "binary", "upload", "open", "data", "archive", " upload", " Download", "append", "gz", "exec", "dump", "update", "process", "transfer", "handle"], "address": ["index", "string", "path", "base", "remote", "order", "ace", "server", "uri", "output", "resource", "message", "mode", "number", "location", "host", "key", "content", "email", "Address", "type", "source", "target", "ress", "config", "data", "region", "route", "page", "ip", "object", "request", "name", "addr", "image", "port", "array", "pointer", "prefix", "position", "localhost", "point", "reference", "attribute", "service", "enter"], "localFileName": [" localPageName", "localSourceFileType", "globalSourceFileName", "localPageName", "localSourceFileAddress", "localImageSize", "localFilePath", "localFilenameName", "LocalSourceFileType", "LocalFileType", " localFileType", "localSourceFileLocation", "localDirPath", " localFilename", " localPageInfo", "localFilesPath", " localFileSize", "globalSourceFilePath", "localPagePath", "localPageSize", "localfileType", "localPlaceLocation", "localPlaceName", "localImageInfo", "localFilesAddress", "localFileInfo", "globalFilePath", "localPlacePath", "localStreamname", "LocalFileName", "LocalSourceFileNames", "globalFileName", "localImageName", "localSourceFileName", "LocalSourceFileName", "localFileNames", "LocalFileLocation", "globalSourceFileInfo", " localPageSize", "localStreamPath", "localImageType", "localFileAddress", "localFilenameNames", "localFilesName", "localDirInfo", "localFilenameLocation", "globalSourceFileAddress", " localPlaceLocation", "localFilesInfo", "localFileLocation", "LocalFileNames", " localFileLocation", "localFileType", "localfileName", "localfileLocation", " localPageType", "localStreamName", "localSourceFileSize", " localPlacePath", "localSourceFileInfo", "localFilename", "localfileNames", "localPlacename", "localPageLocation", "localDirName", "LocalSourceFileLocation", "globalFileInfo", " localFilePath", "localFileSize", "globalFileAddress", "localSourceFilePath", "localPageType", "localPageInfo", "localFilenameType", " localPlaceName", "localSourceFileNames", " localFileInfo", "localStreamLocation", " localPlacename", "localDirAddress", "localPagename"], "ext": ["zip", "xt", "EXT", "string", "info", "ex", "path", "expl", "enc", "prot", "extra", "content", "req", "txt", "xp", "type", "ect", "dist", "str", "alt", "config", "data", "file", "text", "x", "qt", "Ext", "format", "test", "name", "addr", "exp", "word", "app", "err", "f", "fort", "fx"], "temp": ["zip", "original", "base", "input", "server", "output", "ex", "clean", "lock", "wp", "now", "w", "tem", "wl", "ht", "c", "loc", "Temp", "memory", "iter", "txt", "form", "er", "wrap", "cp", "source", "cache", "valid", "session", "Tem", "old", "store", "parent", "data", "file", "tmp", "flat", "local", "fake", "empty", "pipe", "p", "null", "test", "template", "folder", "tp", "stable", "home", "t", "it", "full", "mount", "unit", " temporary", "v", "f", "porary", "this", "api", "emp"], "out": ["ssl", "i", "outer", "output", "copy", "ex", "server", "lock", "on", "Output", "net", "OUT", "socket", "inner", "con", "plain", "outs", "o", "s", "line", "write", "bin", "off", "key", "password", "sync", "client", "part", "lib", "up", "connection", "login", "not", "other", "inc", "w", "parent", "file", "log", "null", "init", "or", "again", "name", "exec", "Out", "io", "writer", "exp", "image", "call", "In", "prefix", "b", "obj", "err", "and", "cli", "this"], "conn": ["impl", "Connection", "close", "ssl", "Conn", "server", "n", "enc", "con", "c", "socket", "act", "fp", "l", "URL", "fr", "nn", "func", "nc", "client", "sync", "nt", "cm", "cp", "cache", "uc", "ct", "connection", "ch", "inc", "conv", "open", "config", "ll", "init", "ai", "coll", "ci", "exec", "Url", "b", "connect", "cn", "ac", "obj", "cli", "cmd"], "in": ["IN", "index", "pin", "i", "input", "id", "n", "ini", "lock", "by", "con", "inner", "socket", "l", "ins", "s", "bin", "is", "client", "sync", "part", "reader", "source", "lib", "up", "connection", "min", "login", "diff", "r", "inc", "data", "get", "init", "or", "again", "exec", "image", "isin", "it", "In", "nin", "kin", "pull", "lin", "ac", "cin", "inn", "f", "cli", "win", "din"], "url": ["impl", "string", "path", "ssl", "base", "i", "server", "n", "uri", "http", "socket", "l", "host", "URL", "client", "cdn", "source", "connection", "r", "ob", "open", "file", "channel", "web", "bel", "ll", "ls", "image", "blog", "db", "sl", "rl", "layer", "Url", "www", "b", "f", "loc"], "buffer": ["border", "Buffer", "input", "uffer", "feed", "sequence", "slice", "slave", "message", "limit", "result", "number", "length", "bin", "memory", "read", "iter", "queue", "offset", "uf", "reader", "cache", "binary", "buff", "value", "buf", "wave", "data", "bb", "null", "row", "FFER", "bytes", "layer", "position", "flush", "comment", "b", "reference", "padding", "pad", "block", "transfer", "batch"], "numRead": ["Numread", "NumRead", "NumWritten", "commonReader", "numberread", "numberWritten", "NumReader", "numReader", "nread", "commonRead", " numBuild", " numWrite", "numWrite", "umWrite", "nWritten", "nBuild", " numReader", "nRead", "numberBuild", "numBuild", "numread", "nWrite", "commonWrite", "NumWrite", "umWritten", "commonWritten", "numberRead", "umRead", " numread"], "numWritten": ["multiWritten", "NumRead", "multiWrite", "NumWritten", "NumWrit", " numWrit", "Numwritten", "numberWritten", "numberWrite", "numwritten", " numWrite", "numWrite", " numOutput", " numwritten", "numOutput", "multiWrit", "numberOutput", "numWrit", "NumWrite", "multiwritten", "numberRead", "NumOutput"], "oldArq": ["oldArquest", "oldarch", "oldarg", "oldAcqs", "oldParque", "oldarQ", "oldARqu", "oldarq", " oldParque", "OldAcq", "oldArp", "oldARqs", "oldArg", "OldAcquest", "oldArtq", "OldArquest", "OldARq", "OldARch", "oldArtque", "OldArque", " oldArg", "OldARqu", "oldAcq", "oldARQ", "oldParg", "oldArqs", "OldArqs", " oldParq", "oldArtquest", "oldArtqs", "oldArque", "oldDarch", "oldarque", "oldParq", "OldARque", "oldParQ", " oldParg", "oldARque", "oldArtQ", "oldARch", "oldarqu", "oldARquest", "oldAcque", "OldArq", "oldArtp", "oldDarq", "OldArp", "OldArQ", "oldAcQ", "OldAcQ", "OldArch", "oldDarqu", "oldARq", " oldArque", "oldArch", "OldArqu", "OldAcqs", "OldARp", "oldArQ", "oldARg", "oldArqu", " oldParQ", "oldDarque", "oldARp", "OldARQ", "oldAcp", "oldAcquest", " oldArQ"], "nomeFinal": ["navefinal", "nukeFin", "NomeFinal", "noefinal", "nukefinal", " nomesfinal", " nomeFin", "nomenfinal", "nomesFin", "nomefinal", "nomeFin", "NomesFinal", "nomesfinal", "nomesFinal", "Nomefinal", "nukeFinal", "nomenFinal", "noeFinal", "nomenFin", "Nomesfinal", " nomesFinal", " nomefinal", " nomesFin", "naveFinal"]}}
{"id1": "21013026", "id2": "14619453", "code1": "    private InputStream getPageStream(String query) throws MalformedURLException, IOException {\n        URL url = new URL(baseUrl + query + \"&rhtml=no\");\n        URLConnection connection = url.openConnection();\n        connection.connect();\n        InputStream in = connection.getInputStream();\n        BufferedInputStream bis = new BufferedInputStream(in);\n        return bis;\n    }\n", "code2": "    public Set<String> getAvailableRoles() {\n        if (availableRoles == null) {\n            availableRoles = new HashSet<String>();\n            try {\n                Enumeration<URL> resources = org.springframework.util.ClassUtils.getDefaultClassLoader().getResources(ROLE_FILE_LOCATION);\n                while (resources.hasMoreElements()) {\n                    URL url = resources.nextElement();\n                    InputStream is = null;\n                    try {\n                        URLConnection con = url.openConnection();\n                        con.setUseCaches(false);\n                        is = con.getInputStream();\n                        List<String> lines = IOUtils.readLines(is, \"ISO-8859-1\");\n                        if (lines != null) {\n                            for (String line : lines) {\n                                availableRoles.add(line.trim());\n                            }\n                        }\n                    } finally {\n                        if (is != null) {\n                            is.close();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return availableRoles;\n    }\n", "label": 0, "substitutes": {"getPageStream": ["getOutputSteam", "getPageForm", "getRequestStream", "getpageChannel", "getOutputStream", "downloadpageForm", "downloadPageForm", "getpageSteam", "getOutputForm", "getRequestChannel", "getRequestSteam", "downloadpageStream", "getpageForm", "downloadPageStream", "downloadPageChannel", "getpageStream", "downloadpageSteam", "getRequestForm", "getOutputChannel", "downloadpageChannel", "getPageChannel", "downloadPageSteam", "getPageSteam"], "query": ["iq", "path", "string", "i", "id", "uri", "resource", "timeout", "http", "result", "ri", "qu", "qs", "tag", "content", "password", "params", "qi", "filter", "type", "source", "q", "str", "build", "qq", "data", "text", "body", "options", "request", "search", "sq", "format", "Query", "name", "start", "prefix", "comment", "question", "script", "term"], "IOException": ["IOError", "ConnectionException", "Socketceptions", "SocketError", " IOError", "Connectionceptions", "SocketException", "IOceptions", " IOceptions", "ConnectionError"], "url": ["article", "string", "base", "ssl", "address", "i", "server", "uri", "resource", "id", "user", "http", "c", "l", "URL", "client", "use", "proxy", "open", "config", "file", "channel", "page", "object", "bb", "web", "conn", "plugin", "ls", "e", "image", "link", "db", "sl", "Url", "position", "bug", "b", "f", "api"], "connection": ["Connection", "handler", "server", "uri", "response", "http", "character", "con", "c", "socket", "connected", "l", "relation", "database", "condition", "union", "client", "reader", "lc", "cond", "proxy", "ion", "application", "open", "section", "channel", "out", "director", "context", "conn", "coll", "ci", "io", "function", "db", "ctx", "position", "bc", "b", "connect", "wrapper", "f", "communication", "loc"], "in": ["IN", "sin", "i", "input", "inas", "uri", "ini", "gin", "con", "c", "socket", "inner", "s", "ins", "bin", "reader", "source", "login", "inc", "data", "rin", "out", "body", "conn", "init", "image", "io", "isin", "In", "nin", "kin", "a", "lin", "inn", "f", "din"], "bis": ["uds", "bles", "lis", "iss", "inas", " cis", "board", "obb", "bs", "inet", "abs", "bin", "is", "series", "cus", "binary", "sb", "bos", "bps", "ais", "BBC", "ubis", "nis", "inos", "bi", "idis", "oi", "ris", "oss", " bos", "isin", "lins", "iris", "di", "ios", "us", "ses", "pins", "abi", "bits", "boot"]}}
{"id1": "344764", "id2": "19251426", "code1": "    static HttpURLConnection connect(String url, String method, String contentType, String content, int timeoutMillis) throws ProtocolException, IOException, MalformedURLException, UnsupportedEncodingException {\n        HttpURLConnection conn = (HttpURLConnection) (new URL(url).openConnection());\n        conn.setRequestMethod(method);\n        conn.setConnectTimeout(timeoutMillis);\n        byte[] bContent = null;\n        if (content != null && content.length() > 0) {\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", contentType);\n            bContent = content.getBytes(\"UTF-8\");\n            conn.setFixedLengthStreamingMode(bContent.length);\n        }\n        conn.connect();\n        if (bContent != null) {\n            OutputStream os = conn.getOutputStream();\n            os.write(bContent);\n            os.flush();\n            os.close();\n        }\n        return conn;\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 0, "substitutes": {"connect": ["remote", "close", "input", "output", "add", "con", "connected", "socket", "find", "run", "Connect", "write", "read", "client", "select", " Connect", "sync", "construct", "load", "connection", "login", "build", "open", "config", "bind", "request", "get", "log", "init", "complete", "start", "exec", "send", "call", "update", "create", "sign", "process", "download"], "url": ["remote", "path", "address", "ssl", "base", "string", "server", "uri", "resource", "user", "http", "l", "host", "location", "URL", "client", "email", "source", "proxy", "q", "connection", "file", "route", "web", "page", "href", "name", "image", "full", "sl", "Url", "www", "b", "f", "this", "download", "loc"], "method": ["path", "class", "resource", "direction", "subject", "message", "version", "end", "mode", "host", "length", "manager", "Method", "time", "sort", "METHOD", "post", "type", "session", "use", "operation", "text", "attr", "request", "format", "verb", "header", "status", "send", "function", "call", "position", "this", "sign", "process", "cmd", "module", "property", "loc"], "contentType": ["contentLength", "ContentType", " contenttype", "resourceName", "ContentClass", "ContentLength", "mediaClass", "resourceType", "resourcetype", "Contenttype", " contentLength", "contentClass", "mediaLength", "contentName", " contentClass", "contenttype", "mediaType", " contentName", "resourceLength", "ContentName", "mediaName"], "content": ["string", "path", "address", "buffer", "temp", "input", "server", "output", "resource", "response", "accept", "enc", "results", "message", "sequence", "version", "cont", "current", "document", "result", "host", "condition", "password", "Content", "raw", "client", "source", "load", "cache", "value", "connection", "media", "model", "config", "data", "text", "file", "body", "parent", "page", "empty", "object", "request", "size", "format", "header", "exec", "image", "ext", "create", "comment", "script", "code"], "timeoutMillis": ["timeoutMi", "timeoutMinus", "timeoutMilli", "TimeoutMini", "timeoutMIS", "TimeoutMinus", "TimeoutMinIS", "TimeoutMinis", "timeoutMinix", "timeoutmillis", "timeoutMilIS", "timeoutmillus", "timeoutMilix", "TimeoutMilus", "TimeoutMillIS", "timeoutMis", "timeoutMillix", "TimeoutMilix", "TimeoutMili", "timeoutMilis", "timeoutMillIS", "TimeoutMillix", "timeoutMini", "timeoutmilli", "timeoutMinIS", "timeoutMillus", "TimeoutMillus", "timeoutMilus", "timeoutMus", "timeoutMili", "timeoutMinis", "TimeoutMillis", "timeoutmillix", "TimeoutMilis", "TimeoutMilli"], "conn": ["Connection", "close", "ssl", "core", "Conn", "cc", "n", "cmp", "cf", "enc", "rc", "http", "ns", "con", "c", "oa", "act", "pub", "cb", "ctrl", "col", "fn", "fp", "co", "dc", "nc", "ec", "client", "sync", "nt", "cm", "cp", "uc", "ct", "connection", "ch", "cat", "open", "conv", "config", "ca", "init", "coll", "ci", "exec", "oss", "ann", "cr", "jp", "pc", "mc", "ctx", "comm", "auth", "conf", "obj", "cn", "cs", "cli", "cmd", "cur", "pg", "org", "api"], "bContent": ["lBody", "BCopy", " bcontent", "rContent", "oValue", "lbValue", "oContent", "iContent", "bBody", "bContents", "lbContent", " bMessage", "oContents", "bMessage", " bContents", "vCopy", "vContent", "ocontent", "rbContent", "sbCopy", "rebMessage", "sbContent", "rbWork", "lbcontent", "rebContent", "lbContents", "Bcontent", "bValue", " bCopy", "rContents", "lMessage", "bWork", "bCopy", " bCode", "sbWork", "icontent", "iContents", "rBody", "sbcontent", "vcontent", "rbCopy", "BCode", "rebContents", "rcontent", "bCode", "bcontent", " bWork", "iBody", "rbcontent", "rebBody", "lContent", "BContent", " bValue", "lContents", "vCode", " bBody"], "os": ["bis", "ou", "i", "oses", "fs", "Os", "acs", "op", "opens", "http", "gets", "ns", "oa", "c", "et", "ks", "dos", "OS", "o", "outs", "s", "bs", "is", "oos", "ms", "ros", "bos", "ops", "nos", "ob", "ens", "out", "object", "ips", "p", "es", "des", "or", "vs", "aos", "obs", "oss", "io", "ot", "pos", "ios", "us", "obj", "ds", "los", "osi", "cos"]}}
{"id1": "17199913", "id2": "20924119", "code1": "    protected static InputStream loadResource(String resource) throws MissingResourceException {\n        Thread thread = Thread.currentThread();\n        ClassLoader cLoader = thread.getContextClassLoader();\n        URL url = cLoader.getResource(resource);\n        if (url == null) {\n            throw new MissingResourceException(\"Unable to find resource '\" + resource + \"'.\", resource, resource);\n        }\n        try {\n            InputStream is = url.openStream();\n            return is;\n        } catch (IOException e) {\n            throw new MissingResourceException(\"Unable to load resource '\" + resource + \"' (IOException).\", resource, resource);\n        }\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 0, "substitutes": {"loadResource": ["findResource", " loadUrl", "findUrl", "findURL", "loadURL", "loadFile", "downloadResource", "downloadUrl", " loadURL", "loadUrl", " loadFile", "findFile", "downloadURL", "downloadFile"], "resource": ["base", "class", "loader", "http", "document", "match", "content", "rule", "serial", "component", "model", "region", "file", "archive", "context", "style", "reference", "module", "sr", "ource", "element", "string", "address", "buffer", "library", "query", "source", "use", "connection", "r", "parent", "channel", "route", "OURCE", "texture", "name", "resolution", "attribute", "service", "path", "remote", "rest", "core", "uri", "resources", "message", "record", "reader", "scope", "collection", "src", "request", "image", "Resource", "error", "method", "single", "view", "relative", "res", "filename", "project", "client", "expression", "type", "date", "media", "feature", "data", "text", "ruby", "href", "pointer", "role", "stream", "parse", "right", "range", "re"], "thread": ["path", "class", "loader", "tc", "job", "Thread", "http", "system", "project", "run", "host", "pool", "task", "util", "func", "loop", "reader", "connection", "module", "component", "build", "config", "parent", "object", "context", "or", "t", "worker", "kernel", "ctx", "layer", "app", "tt", "stream", "th", "stack", "runtime", "process", "method", "this", "boot", " Thread"], "cLoader": ["cUrl", "lCl", "CCl", "cConfig", "CConfig", "lLoad", "cDir", " cConfig", "cLoad", "lConfig", "cCl", "cPath", "CLoader", "lPath", "CLoad", "lDir", "lLoader", "CUrl", "CPath", " cDir", "CDir", "lUrl", " cPath", " cUrl", " cLoad", " cCl"], "url": ["impl", "path", "string", "base", "ssl", "loader", "job", "server", "uri", "feed", "id", "rc", "http", "ref", "rel", "lr", "l", "html", "location", "URL", "il", "el", "host", "source", "jar", "browser", "ob", "file", "src", "bel", "ll", "object", "bb", "conn", "ls", "coll", "e", "image", "io", "sl", "rl", "Url", "www", "stream", "ur", "xml", "download", "f", "gl", "element", "service", "api", "loc"], "is": ["bis", "lis", "css", "iss", "uri", "fs", "IS", "Is", "as", "ri", "bs", "il", "abs", "ui", "inst", "ii", "ms", "its", "ws", "ais", "ir", "web", "ip", "vs", "ris", "js", "ists", "ics", "it", "ils", "ios", "us", "isi", "os", "ps", "was", "ar", "iv", "im", "api", "mis"]}}
{"id1": "22536033", "id2": "5138455", "code1": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"setPayload": ["setMessageContent", "setShipload", "setRawload", "parseShipContent", "parsePayLoad", "setShipLoad", "setPayLoad", " setPayContent", " setPayloads", "setPayContent", "parseShiploads", "setPayloads", "setWorkLoad", "parsePayload", "parseShipload", "setShipContent", "setMessageLoad", "setRawloads", "setWorkloads", " setPayLoad", "setShiploads", "parsePayloads", "setWorkContent", "setRawLoad", "setMessageloads", "parseShipLoad", "setMessageload", "setRawContent", "parsePayContent", "setWorkload"], "fos": ["bis", "cfis", "cfics", "cfoc", "Foc", "bos", "cfos", "boc", "Fis", "Fos", "fics", "bics", " fics", "Fics"], "fis": ["eic", "fIS", "Fib", "foris", "FIS", " fib", "Foc", " fIS", "forib", "Fic", "foric", "fib", "Fis", "fics", " fics", "eis", "forics", "eIS", "Fics", "eoc"], "fic": ["cfic", "elfics", "Fac", "elfik", "cfics", "cfoc", "infic", "Fci", "ufik", " fac", "Foc", "Firc", "elfci", "cfac", "cfirc", "Fic", "infci", "ufic", "fik", "Fos", "ufoc", "fics", "firc", " firc", " fics", "Fik", "ufos", "infics", "infik", " fik", "elfic", "Fics", "fac", "fci"], "foc": ["Fac", " froc", "infoc", "infocol", "Foca", "Focon", "foca", "focon", "infic", "fisc", "infos", "Focol", " focol", " fac", "Foc", "Fisc", "infocon", " fisc", "Fic", " focon", "Fos", "toca", "toc", "infac", "focol", "tic", "Froc", "troc", "infisc", " foca", "fac", "froc"], "Index": ["index", "Loop", "Section", "Connection", "First", "Found", "Position", "Link", "Len", "Offset", "Path", "Exp", "Flag", "X", "Pos", "Width", "Code", "Interest", "Entry", "Rank", "Element", "Content", "Depth", "Value", "Address", "Inf", "Input", "Length", "Weight", "Array", "Page", "Number", "Pull", "Key", " index", "Count", "Instance", "x", "Body", "Mass", "Size", "Stage", "Header", "Dim", "Label", "I", "Url", "Num", "Insert", "ID", "Location", "Start", "Client", "Version", "Counter", "Level", "Order", "Row", "Loc"]}}
{"id1": "10281203", "id2": "8625346", "code1": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"makeRead": ["doRead", " executeRead", " manageSet", " executeSet", " manageREAD", " executeWrite", " manageRead", "doWrite", " manageWrite", " executeREAD", " makeSet", " makeREAD", " makeWrite", "doSet", "doREAD"], "user": ["custom", "string", "job", "server", "username", "month", "site", "USER", "author", "admin", "User", "uid", "host", "record", "write", "owner", "usr", "password", "post", "use", "users", "date", "alias", "pod", "log", "row", "creator", "name", "home", "blog", "nick", "word", "human", "pid", "url", "bug", "comment", "field", "install"], "databaseID": ["connectionIDs", "databaseName", "DatabaseID", "DatabaseIDS", " databaseIDS", "collectionID", "connectionID", "collectionName", "collectionId", "databaseIDS", " databaseName", "dbID", "DatabaseName", "connectionName", "DatabaseId", " databaseIDs", "dbIDs", "databaseId", " databaseId", "dbName", "databaseIDs", "collectionIDS"], "time": ["string", "tz", "duration", "id", "timeout", "month", "year", "clock", "table", "end", "ime", "times", "mode", "length", "set", "host", "read", "key", "sleep", "post", "rate", "type", "money", "delay", "date", "value", "counter", "timer", "ip", "size", "tim", "name", "start", "home", "port", "Time", "comment", "etime", "TIME"], "query": ["string", "error", "execute", "uri", "report", "message", "json", "result", "join", "answer", "eries", "database", "condition", "post", "params", "select", "rule", "q", "connection", "ql", "work", "request", "search", "sq", "conn", "Query", "name", "function", "call", "commit", "sql", "update", "comment", "question", "general", "command", "scan", "script", "cmd", "code"], "statement": ["i", "execute", "agent", "server", "response", "note", "usage", "document", "message", "table", "slave", "result", "join", "instance", "ma", "s", "volume", "jo", "si", "relation", "inst", "database", "joined", "condition", "password", "expression", "part", "stat", "mt", "session", "rule", "use", "connection", "media", "str", "parser", "alias", "section", "language", "study", "conn", "style", "Statement", "start", "status", "function", "db", "commit", "di", "sql", "unit", "comment", "general", "st", "command", "state", "script", "storage"], "count": ["index", "total", "base", "sum", "i", "id", "list", "by", "c", "table", "limit", "number", "find", "child", "length", "set", "key", "offset", "handle", "part", "type", "cache", "cond", "expected", "diff", "inc", "Count", "size", "get", "start", "force", "err", "process", "state", "age", "found", "batch", "error", "code", "depth"]}}
{"id1": "23161545", "id2": "8385785", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"getRandomGUID": ["getRandomGCuid", "getRandUuid", "getRandGid", "getRandomGID", "getRandomIGuid", "getRandomGuid", "getRandomGid", "getRandUID", "getRandGID", "getRandomUID", "getRandomGCid", "getRandomIGID", "getRandomGCID", "getRandomUUID", "getRandGuid", "getRandomGCUID", "getRandomUid", "getRandomIGUID", "getRandomUuid", "getRandGUID", "getRandUid", "getRandomIGid", "getRandUUID"], "secure": ["zip", "remote", "ssl", "server", "timeout", "secondary", "smart", "confirmed", "weak", "host", "active", "security", "allow", "session", "use", "ce", "seed", "proxy", "debug", "exclusive", "config", "sensitive", "https", "require", "safe", "encrypted", "unsigned", "force", "stable", "pure", "Secure", " insecure", "service", "secret", "random", "deep", "protect", "sr", "sec", "external", "depth"], "md5": ["MD500", "cmdql", " md500", "cmd3", "mdql", " mdql", " md3", "MD11", "md2", " MD3", "MD5", " MD11", "md500", "MD3", "MD512", "MD2", "MDql", "md3", " md2", " MD2", "md512", " md512", "md11", " MD5", "cmd5", " MD500", "cmd512", " md11"], "sbValueBeforeMD5": ["sbValueBeforeDER0", "sbValueBeforeMD75", "sbValueBeforeMC375", "sbValueBeforeMS5", "sbValueAfterMS3", "sbValueGivenmd375", "sbValuebeforeSD005", "sbValuebeforeMD005", "sbValueBeforeSD20", "sbValueAfterMS65", "sbValuebeforeSD20", "sbValueBeforeMI7", "sbValueAfterMP5", "sbValueAfterMD20", "sbValuebeforeMD5", "sbValueBeforeMD7", "sbValueAfterMS5", "sbValueAfterMS20", "sbValueBeforeMR3", "sbValueBeforemd3", "sbValueBeforeMS7", "sbValueGivenmd512", "sbValueBeforeMS95", "sbValueAfterMD95", "sbValueBeforeMR5", "sbValueBeforeSHA005", "sbValuebeforeSD5", "sbValueBeforeMI1", "sbValueBeforeMAC3", "sbValueAfterMP7", "sbValueAfterMS55", "sbValueAfterMS0", "sbValueBeforeMD95", "sbValueBeforeMS512", "sbValueGivenMD3", "sbValueAfterMD75", "sbValueBeforeSHA20", "sbValueBeforeAMD5", "sbValueBeforemd512", "sbValueBeforeDER3", "sbValueBeforeMAC55", "sbValueBeforeMI20", "sbValueBeforeMS55", "sbValueBeforeMS0", "sbValueBeforeMAC0", "sbValuebeforeMD1", "sbValueBeforeSD005", "sbValueBeforemd5", "sbValueBeforeD5", "sbValueBeforemd25", "sbValueAfterMD5", "sbValuebeforeSD1", "sbValueBeforeD65", "sbValueBeforeMR95", "sbValueBeforemd375", "sbValueBeforemd95", "sbValueAfterMD0", "sbValueBeforeSD1", "sbValueBeforeMD0", "sbValueBeforeMP1", "sbValueBeforeMC5", "sbValueAfterMS25", "sbValueGivenMD375", "sbValueAfterMP3", "sbValueAfterMS1", "sbValueAfterMD25", "sbValueBeforeMC512", "sbValueBeforeMS25", "sbValueBeforeMS1", "sbValueBeforeDER005", "sbValueBeforeMD65", "sbValueAfterMD1", "sbValueBeforeAMD20", "sbValueBeforeDER55", "sbValueGivenmd3", "sbValueBeforeMD20", "sbValueBeforeSD5", "sbValueBeforeMD25", "sbValueGivenMD512", "sbValueBeforeDER20", "sbValueBeforeMS65", "sbValueBeforeMS75", "sbValueBeforeMS375", "sbValueBeforeMAC5", "sbValueBeforeMR25", "sbValueAfterMP1", "sbValueGivenMD5", "sbValueBeforeMP7", "sbValueAfterMS75", "sbValueBeforeSHA1", "sbValueBeforeMD1", "sbValueBeforeMI5", "sbValueBeforeMD512", "sbValueBeforemd65", "sbValueBeforeDER1", "sbValueAfterMD65", "sbValueBeforeMS20", "sbValueBeforeMI3", "sbValueBeforeMP5", "sbValueBeforeMP3", "sbValueAfterMD3", "sbValueBeforeAMD1", "sbValueBeforeMD005", "sbValueBeforeMS3", "sbValueBeforeSHA5", "sbValueBeforeAMD3", "sbValueBeforeMD55", "sbValueBeforeMD3", "sbValueAfterMS95", "sbValueBeforeDER5", "sbValueBeforeMC3", "sbValueAfterMD7", "sbValueBeforeMD375", "sbValueBeforemd75", "sbValueGivenmd5", "sbValueBeforeD3", "sbValueAfterMD55", "sbValuebeforeMD20", "sbValueBeforeD75"], "time": ["event", "cost", "error", "tz", "id", "duration", "user", "timeout", "year", "clock", "version", "slice", "ime", "mode", "loc", "length", "host", "offset", "rate", "type", "money", "TIME", "delay", "date", "value", "seed", "counter", "work", "timer", "size", "tim", "name", "start", "race", "Time", "hour", "random", "etime", "count", "times", "speed", "depth"], "rand": ["index", "root", "order", "max", "id", "lang", "round", "clean", "rc", "year", "rol", "res", "version", "rank", "ro", "alpha", "Rand", "rate", "type", "rule", "rh", "chance", "seed", "delay", "q", "serial", "min", "r", "pick", "gen", "rr", "risk", "bit", "raid", "cr", "bot", "reg", "right", "range", "random", "count", "ng", "mid", "error", "win", "rage", "winner", "depth"], "valueBeforeMD5": ["valueAfterAMD2", "valueBeforeMC5", "valueBeforeMC3", "valueBeforeMC2", "valueBeforeMD85", "valueAfterAMD5", "valueBeforeMP53", "valueBeforeMP2", "valueBeforeMD53", "valueBeforeMP5", "valueBeforeAMD2", "valueAfterAMD53", "valueBeforeMD3", "valueBeforemd5", "valueBeforeAMD3", "valueAfterMD3", "valueBeforemd2", "valueInsideMD5", "valueBeforeMC85", "valueBeforemd85", "valueInsideMD3", "valueBeforemd3", "valueAfterMD53", "valueInsideMD85", "valueAfterMD2", "valueBeforeMP3", "valueAfterAMD3", "valueBeforeAMD53", "valueBeforeMD2", "valueBeforeAMD5", "valueInsideMD2"], "array": ["integer", "string", "audio", "address", "list", "vector", "message", "number", "any", "result", "instance", "record", "database", "arr", "expression", "angle", "allow", "cache", "binary", "value", "our", "Array", "collection", "sample", "data", "feature", "archive", "section", "object", "row", "ray", "arrow", "image", "function", "area", "app", "shape", "pair", "range", "air", "batch", "error", "element", "api", "view", "storage"], "sb": ["buffer", "BB", "sf", "usb", "bf", "bh", "sg", "lp", "lb", "eb", "lab", "cb", "lr", "obb", "s", "bs", "kb", "si", "orb", "nn", "pb", "gb", "mb", "abb", "rb", "sa", "ab", "binary", "wb", "buf", "sv", "ob", "bj", "ruby", "src", "fb", "bb", "sq", "zb", "stab", "sth", "rob", "nb", " SB", "sl", "ib", "bt", "bc", "bp", "xb", "bl", "bm", "bsp", "sbm", "SB"], "j": ["index", "dy", "job", "i", "num", "uj", "n", "ij", "ie", "c", "z", "end", "o", "jl", "l", "length", "jo", "ii", "key", "aj", "part", "ja", "ji", "d", "pr", "q", "ch", "g", "bj", "li", "out", "x", "p", "jj", "J", "js", "e", "jp", "k", "y", "br", "v", "obj", "adj", "f", "code"], "b": ["job", "i", "BB", "bf", "n", "be", "eb", "lb", "c", "cb", "l", "bs", "bin", "orb", "pb", "bar", "mb", "rb", "d", "ab", "binary", "ob", "fb", "bb", "x", "p", "bi", "e", "bit", "nb", "db", "ib", "a", "bc", "B", "bug", "k", "y", "br", "f"], "valueAfterMD5": ["valueAfterMP3", "valueAfterAMD2", "valueAfterMP7", "valueAfterMP5", "valueAfterVM7", "valueAfterAMD5", "valueAfterAMD7", "valueBeforeMP2", "valueBeforeMP5", "valueBeforeMD3", "valueAfterMD3", "valueAfterMD7", "valueAfterVM3", "valueAfterVM5", "valueBeforeMD7", "valueAfterMD2", "valueBeforeMP3", "valueAfterAMD3", "valueBeforeMD2", "valueAfterMP2", "valueBeforeMP7", "valueAfterVM2"]}}
{"id1": "10214218", "id2": "5725177", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    @Override\n    protected <T> T execute(final HttpMethod method, final String url, Parameters parameters, final Handler<T> handler) throws FoursquareException {\n        HttpURLConnection connection = null;\n        try {\n            switch(method) {\n                case GET:\n                    connection = openConnection(url.concat(\"?\").concat(formEncode(parameters)));\n                    connection.setRequestMethod(\"GET\");\n                    connection.connect();\n                    break;\n                case POST:\n                    connection = openConnection(url);\n                    connection.setRequestMethod(\"POST\");\n                    connection.setDoOutput(true);\n                    connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                    connection.connect();\n                    final OutputStream out = connection.getOutputStream();\n                    out.write(formEncode(parameters).getBytes());\n                    out.flush();\n                    out.close();\n                    break;\n            }\n            final int statusCode = connection.getResponseCode();\n            if (statusCode / 100 != 2) {\n                final Error error = parseBody(connection.getErrorStream(), new ErrorHandler());\n                if (error == null) throw new FoursquareException(connection.getResponseMessage()); else if (\"error\".equals(error.getType())) throw new FoursquareException(error.getMessage()); else if (\"unauthorized\".equals(error.getType())) throw new AuthenticationException(error.getMessage()); else if (\"ratelimited\".equals(error.getType())) throw new RateLimitingException(error.getMessage()); else throw new FoursquareException(connection.getResponseMessage());\n            }\n            return parseBody(connection.getInputStream(), handler);\n        } catch (final IOException e) {\n            throw new FoursquareException(e);\n        } catch (final ParserConfigurationException e) {\n            throw new FoursquareException(e);\n        } catch (final SAXException e) {\n            throw new FoursquareException(e);\n        } finally {\n            if (connection != null) connection.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["enrypt", "encress", " encipher", "enress", " encress", " enccrypt", "decipher", "enipher", "encipher", "decress", "enccrypt", "deccrypt", "decrypt"], "plaintext": ["anystruct", "plaintxt", "anytxt", "batText", "plainText", " plaintxt", "mainText", "plainstruct", "mainstruct", "anytext", " plainText", "anyText", "mainsource", "batsource", "battxt", " plainsource", "plainsource", "maintext", " plainstruct", "batstruct", "battext"], "md": ["mu", "mag", "arm", "od", "bd", "Cmd", "amd", "message", "mo", "kg", "ma", "am", "meta", "dr", "wd", "MD", " MD", "ld", "ms", "ad", "sm", "key", "cm", "mb", "mt", "dh", "d", "mac", "mage", "mp", "sha", "pm", "pd", "data", "mm", "metadata", "dig", "pg", "m", "hm", "dm", "db", "mand", "mc", "nm", "mod", "em", "mg", "mad", "cmd", "dd"], "raw": ["original", "buffer", "input", " RAW", "feed", "clean", "enc", "rew", "rc", "message", "ack", "RAW", "hex", "instance", "unknown", "content", "load", "binary", "serial", "buf", "wave", "Raw", "none", "data", "text", "null", "row", "unsigned", "image", "array", "dec", "pack", "full", "good", "bytes", "wrapper", "words", "block", "ng", "initial"], "hash": ["base", "sum", "her", "id", "response", "ashes", "message", "version", "kh", "hex", "Hash", "html", "ash", "key", "alpha", "mac", "cache", "rh", "sha", "data", "ruby", "h", "log", " hex", "header", "image", "hed", "array", "ha", "url", "sh", "secret", "abi", "block", "code"]}}
{"id1": "14820302", "id2": "5808579", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "label": 1, "substitutes": {"innerProcess": ["subConnect", " innerConnect", "subprocess", "subProcess", "binaryConnect", "innerConnect", "binaryprocess", "binaryProcess", "binaryWrite", "subWrite", "innerprocess", "innerWrite", " innerWrite", " innerprocess"], "curi": ["lURI", "pri", "luri", " cunit", " cURI", " cgui", "lri", "cURI", " cui", "capi", "lurl", "lciri", "lcui", "lcuri", "Capi", "Cri", "lcURI", " capi", "Curi", "papi", "lcri", "cui", "fri", "lcunit", "cunit", "Curl", "pURI", "fui", "Cui", "curl", " cri", "Ciri", "ciri", "furi", "lcgui", "fURI", "Cunit", " curl", "cri", "cgui", "puri", "Cgui", "CURI", "firi"], "regexpr": ["relexp", "recrepre", "renexPR", "pregexpr", "rereper", "regexp", "recer", "reruer", "RenexPR", "renexpl", "regnexpl", "regexer", "rerup", "renexpr", "receper", "Renexpr", "pregexer", "pregexpl", "recrepr", "prenexp", "renexr", "Renexp", "relexPR", "RegexPR", "regnexpr", "Regexpre", "recrep", "recreer", "reggexpr", "regexr", "pregexp", "reggexpl", "rerer", "regexpre", "regexPR", "prenexpr", "rerepr", "regnexper", "recepl", "rerepl", "rerupl", "Regexpr", "rerupr", "prenexer", "reggexr", "Renexpre", "regexper", "relexpr", "regexpl", "regnexr", "recepr", "recrepl", "renexpre", "renexper", "renexer", "prenexpl", "renexp", "reggexper", "relexpre", "Regexp", "recrePR"], "cs": ["cing", "tc", "cc", "sc", "cer", "css", "fs", "acs", "cf", "rc", "cons", "spec", "ns", "ks", "c", "cb", "qs", "Cs", "bs", "ins", "cases", "ms", "rs", "cus", "ec", "ces", "sync", "cms", "cm", "cp", "ce", "lc", "cache", "cas", "ced", "icks", "ca", "gs", "es", "CS", "wcs", "conn", "acts", "js", "ls", "ci", "coll", "ics", "vs", "cr", "cers", "cells", "ars", "ss", "pc", "details", "ios", "ctx", "bc", "ches", "cn", "ac", "ds", "acks", "os", "ps", "cks", "codes", "cos"], "digest": ["Digester", "signester", "bigests", " diggest", "Diger", "signEST", "igested", "digity", "logit", "signest", " digcher", "signer", "bigest", " digested", " diger", "Digity", "hashger", "biggest", "signger", "digit", "hashest", "digcher", "signests", "logester", "bigEST", "igity", "signested", "diggest", " digger", "digester", " digity", "Digit", "digested", "hashester", "digests", "digger", "Digcher", "Digest", "hashcher", "igest", "diger", "logger", " digEST", "Digger", " digester", " digests", " digit", "Digested", "logest", "signgest", "igester", "digEST"], "s": ["services", "string", "address", "sum", "n", "settings", "ns", "c", "S", "o", "l", "bs", "abs", "si", "su", "is", "ms", "rs", "sync", "states", "ws", "binary", "sb", "strings", "str", "r", "g", "ans", "data", "gs", "h", "p", "groups", "u", "ls", "js", "e", "sets", "t", "obs", "ss", "sl", "sym", "bytes", "ses", "b", "v", "ds", "os", "f", "ps"], "m": ["om", "string", "tm", "vm", "map", "M", "c", "mo", "am", "match", "wm", "mr", "ms", "sm", "ym", "cm", "pm", "r", "machine", "mm", "mi", "p", "hm", "fm", "e", "dm", "imm", "nm", "mc", "me", "v", "bm", "rm", "man", "gm"], "newDigestValue": ["newDigeterValue", "newDigesterValues", "newDigESTValues", "newSignestedValue", "newDigesterVal", "newDigeterString", "newDigesterKey", "newSignestValue", "newDigeterVal", "newDigestVal", "newSignestedValues", "newDigestedString", "newSignestedKey", "newDigesterString", "newDigESTValue", "newDigesterValue", "newDigESTKey", "newSignestValues", "newDigestedVal", "newSignestString", "newDigestValues", "newSignestedString", "newSignestKey", "newDigESTString", "newDigestedKey", "newDigestKey", "newDigestString", "newDigeterKey", "newDigestedValues", "newDigestedValue"]}}
{"id1": "10214218", "id2": "23677128", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "\tpublic FTPClient sample3a(String ftpserver, int ftpport, String proxyserver, int proxyport, String username, String password) throws SocketException, IOException {\n\t\tFTPHTTPClient ftpClient = new FTPHTTPClient(proxyserver, proxyport);\n\t\tftpClient.connect(ftpserver, ftpport);\n\t\tftpClient.login(username, password);\n\t\treturn ftpClient;\n\t}\n", "label": 0, "substitutes": {"encrypt": ["enrypt", "encress", " encipher", "enress", " encress", " enccrypt", "decipher", "enipher", "encipher", "decress", "enccrypt", "deccrypt", "decrypt"], "plaintext": ["anystruct", "plaintxt", "anytxt", "batText", "plainText", " plaintxt", "mainText", "plainstruct", "mainstruct", "anytext", " plainText", "anyText", "mainsource", "batsource", "battxt", " plainsource", "plainsource", "maintext", " plainstruct", "batstruct", "battext"], "md": ["mu", "mag", "arm", "od", "bd", "Cmd", "amd", "message", "mo", "kg", "ma", "am", "meta", "dr", "wd", "MD", " MD", "ld", "ms", "ad", "sm", "key", "cm", "mb", "mt", "dh", "d", "mac", "mage", "mp", "sha", "pm", "pd", "data", "mm", "metadata", "dig", "pg", "m", "hm", "dm", "db", "mand", "mc", "nm", "mod", "em", "mg", "mad", "cmd", "dd"], "raw": ["original", "buffer", "input", " RAW", "feed", "clean", "enc", "rew", "rc", "message", "ack", "RAW", "hex", "instance", "unknown", "content", "load", "binary", "serial", "buf", "wave", "Raw", "none", "data", "text", "null", "row", "unsigned", "image", "array", "dec", "pack", "full", "good", "bytes", "wrapper", "words", "block", "ng", "initial"], "hash": ["base", "sum", "her", "id", "response", "ashes", "message", "version", "kh", "hex", "Hash", "html", "ash", "key", "alpha", "mac", "cache", "rh", "sha", "data", "ruby", "h", "log", " hex", "header", "image", "hed", "array", "ha", "url", "sh", "secret", "abi", "block", "code"]}}
{"id1": "9261777", "id2": "812803", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"source": ["zip", "string", "path", "address", "original", "index", "sin", "input", "id", "resource", "uri", "spec", "token", "Source", "element", "copy", "site", "slice", "project", "inner", "result", "dest", "se", "query", "info", "sort", "in", "SOURCE", "session", "use", "rule", "seed", "proxy", "target", "scope", "shared", "sample", "parent", "data", "text", "src", "file", "flat", "options", "config", "request", "size", "empty", "null", "style", "view", "start", "template", "force", "name", "image", "prefix", "sl", "secure", "strip", "url", "base", "unit", "parse", "comment", "missing", "ource", "service", "single"], "destination": ["distination", "Destignment", "dependination", "destinating", "homeignment", " destipping", "coordination", "Desturation", "databaseination", "Destinate", "Destinating", "databaseinated", "domuration", " destignment", "databaseinations", " destension", "destension", " destinate", "distipping", "dominated", " destinated", "destipping", "homeination", "distinated", "destinated", " destinator", "Destination", "Destinated", "distension", "homeinator", "Destinator", " destinating", "dependipping", "desturation", "dependension", "dependinated", "coordinating", "domination", "destinate", "destinator", "databaseuration", "homeinated", "coordinator", "Destinations", "destinations", "coordinate", "destignment", "dominations"], "is": ["zip", "info", "bis", "sin", "close", "i", "iss", "id", "serv", "fs", "IS", "lis", "isa", "ie", "Is", "act", "ic", "as", "ri", "se", "ins", "bs", "abs", "s", "ois", "ui", "in", "ori", "ii", "isl", "ops", "ais", "ar", "ob", "isc", "ir", "out", "ens", "nis", "src", "ip", "get", "es", "iso", "init", "or", "ai", "ris", "ci", "obs", "oss", "io", "eni", "ics", "iris", "ios", "us", "ib", "isi", "sis", "are", "was", "osi", "esi", "api", "cos", "mis"], "os": ["ou", "mos", "i", "oses", "sys", "Os", "fs", "op", "acs", "ks", "oa", "oise", "as", "dos", "OS", "o", "socket", "s", "bs", "ori", "ies", "so", "ros", "bos", "ops", "ais", "nos", "ob", "ens", "out", "ends", "es", "oes", "ose", "or", "vs", "ls", "aos", "obs", "js", "oss", "io", "ot", "pos", "ss", "ios", "us", "oS", "ds", "los", "ol", "ow", "osi", "boot", "cos"], "buffer": ["string", "address", "base", "border", "Buffer", "uffer", "feed", "copy", "server", "sequence", "slice", "limit", "result", "number", "read", "iter", "queue", "reader", "binary", "seed", "buff", "value", "buf", "wave", "data", "channel", "page", "size", "bb", "null", "header", "image", "writer", "layer", "position", "url", "bytes", "flush", "b", "reference", "padding", "pad", "transfer", "batch"], "length": ["index", "string", "total", "address", "id", "duration", "feed", "lower", "division", "lock", "character", "slice", "power", "sequence", "end", "limit", "number", "volume", "l", "match", "line", "quote", "weight", "split", "last", "offset", "key", "part", "type", "reader", "load", "value", "len", "Length", "ob", "section", "level", "data", "object", "size", "get", "row", "style", "start", "ring", "full", "strip", "position", "of", "url", "partial", "shape", "distance", "left", "range", "count", "age", "block", "width", "code", "point", "depth"]}}
{"id1": "8132219", "id2": "8788371", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "inFile": ["inputPlace", " inSourceFile", "InSourceFile", "INfile", "binfile", "outPlace", "inputfile", "outfile", " infile", "infile", "inputFile", "outFiles", "InFilename", " inFilename", "Infile", "inFiles", "inPlace", "inputFiles", "binFiles", "binFile", "INFile", "binPlace", "InFile", "INSourceFile", "inFilename", "inSourceFile", "INFilename"], "outFile": ["againFilename", "outputFilename", "outputfile", "againFile", " outfile", "outPlace", "outfile", "infile", "outFiles", "outputPlace", " outFilename", "inFiles", "againfile", " outFiles", "outputFiles", "againPlace", "outFilename", "inFilename", "outputFile", " outPlace"], "in": ["IN", "index", "pin", "base", "i", "input", "id", "n", "ini", "ic", "c", "inner", "as", "ins", "bin", "is", "part", "like", "reader", "source", "connection", "inc", "work", "data", "file", "config", "rin", "x", "name", "again", "m", "image", "io", "In", "a", "url", "inn", "f", "din"], "out": ["string", "buffer", "ex", "output", "n", "copy", "resource", "user", "Output", "plain", "c", "OUT", "version", "o", "outs", "write", "line", "bin", "client", "part", "cache", "dot", "default", "w", "data", "file", "x", "p", "log", "null", "conn", "name", "exec", "Out", "io", "image", "writer", "to", "call", "prefix", "ext", "v", "b", "obj", "external"], "inChannel": ["sinSocket", "INSocket", "inSocket", "inputChannel", "INchannel", "iniChannel", "inStream", " inFlow", " inchannel", "inputchannel", "inchannel", "INFlow", "sinChannel", "inLanguage", "sinChan", "iniLanguage", "winLanguage", "inputChan", "iniStream", "INChan", "outStream", "outchannel", "outChan", "inChan", "inputStream", "inichannel", "outConnection", "INStream", "winChannel", "winchannel", " inConnection", "INChannel", "inConnection", " inChan", "winStream", "sinFlow", " inSocket", "inFlow", "INConnection", "outLanguage"], "outChannel": [" outContext", "OutStream", "againChannel", "OutConnection", "OutChannel", "inchannel", "outContext", " outConnection", "againPath", "againChan", "OutChan", "outStream", "outchannel", "inPath", "outChan", "inChan", "outPath", "OutContext", "outputchannel", "outputChannel", " outPath", "outConnection", "newStream", "Outchannel", "newChan", "againchannel", "outputChan", "inConnection", " outStream", "newContext", "newChannel", " outchannel", " outChan"]}}
{"id1": "6341264", "id2": "1371265", "code1": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "code2": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"getJarEntry": ["getFolderEntry", "GetJarSource", "GetZipEntry", "loadJarEnt", "getZipentry", "getFolderInfo", "loadZipEntry", "getZipFile", "loadZipEnt", "loadZipFile", "GetJarEntry", "GetJarFile", "getEntryEntry", "getZipSource", "getEntryentry", "loadJarEntry", "getJarEnt", "getJarFile", "getZipInfo", "GetZipSource", "getJarentry", "GetZipFile", "getFolderFile", "getFolderSource", "getJarSource", "loadZipentry", "getEntryEnt", "GetZipInfo", "getZipEntry", "getJarInfo", "getjarEnt", "getjarFile", "getjarentry", "loadJarentry", "GetJarInfo", "getEntryFile", "getjarEntry", "getZipEnt", "loadJarFile"], "jarName": ["javaAlias", " jarId", "javaPath", "JarName", " jarPath", " jarID", " jarUrl", "browserName", "browserUrl", "JarAlias", "browserId", "javaName", " jarAlias", "jarPath", "javaUrl", "jarUrl", "jarAlias", "JarID", "browserAlias", "jarId", "javaId", "javaID", "jarID", "JarPath"], "entry": ["zip", "string", "path", "address", "ry", "ticket", "server", "uri", "id", "resource", "feed", "ie", "filename", "description", "host", "query", "ident", "Entry", "key", "offset", "type", "source", "jar", "connection", "str", "data", "file", "archive", "route", "plugin", "start", "name", "image", "secret", "element", "service", "enter"], "port": ["string", "path", "address", "server", "ort", "uri", "timeout", "version", "project", "limit", "patch", "length", "host", "time", "key", "offset", "password", "type", "delay", "target", "ports", "file", "ip", "name", "pos", "pid", "position", "PORT", "count", "Port", "service", "point", "direction"], "b": ["base", "buffer", "i", "beta", "bf", "emb", "bd", "eb", "lb", "c", "library", "cb", "l", "s", "bs", "obb", "orb", "pb", "mb", "bar", "reb", "abb", "d", "binary", "ab", "wb", "erb", "sb", "buff", "buf", "r", "ob", "fb", "p", "bb", "zb", "e", "nb", "db", "a", "bytes", "ib", "B", "bp", "v", "br", "xb", "f", "boot"], "codebase": [" codebas", "Codebas", "workBase", "corebar", "queb", "workbase", "corebase", " codefull", "workb", "broadb", "corebas", "queBase", "codebar", "CodeBase", "workfull", " codeBase", "broadbase", "quebase", "codebas", "quebas", "Codeb", "Codebase", "broadBase", "codeBase", " codebar", " codeb", "Codebar", "codeb", "broadfull", "coreBase", "codefull"], "protocol": ["Protocol", "Protology", "proport", " protology", "ocolocol", "ocolore", "verbocol", "protport", "predocol", "proocol", "Protport", "ocolurl", "predore", "predurl", "propology", "verbology", " protost", "proturl", "verbost", "prourl", "verburl", "propocol", "propurl", "proology", "predology", "Protore", "protology", "ocolology", "Protost", "propport", "Proturl", " proturl", "protost", "protore"], "x": ["val", "index", "xt", "xxxx", "max", "cross", "xf", "ex", "id", "xa", "xx", "z", "X", "en", "xxx", "xp", "d", "xd", "xes", "w", "work", "xs", "check", "xc", "h", "p", "es", "m", "ax", "lex", "rx", "pos", "exp", "xi", "ctx", "xxxxxxxx", "pe", "v", "y", "dx", "f", "wx", "tx", "fx", "ix", "ww"], "s2": [" sls", "e62", "patter", "xls", "o2", "sii", "s62", "v2", "osecond", "vtwo", "sls", "ptwo", "satter", "qsii", "e2", "v1", " s62", "esecond", "string2", "qsls", "s1", " s1", "qs2", "o62", "vatter", "o1", "ssecond", "e1", "stringtwo", "stwo", "xii", "p1", "qs1", " ssecond", "x1", " sii", "string1", "p2", "stringatter"], "x2": ["ix6", "ix0", "xSecond", "index6", "X1", "x6", "x0", "index2", " xSecond", "index0", "tx2", " x52", "X52", "XSecond", "tx1", "txSecond", "ix1", "index1", " x6", " x1", "X2", "x52", "x1", " x0", "ix2", "tx52"], "downloadHost": ["DownloadHost", " downloadDomain", "urlHost", "transferAddress", "updateAddress", " downloadAddress", "urlPort", "urlhost", "transferRoot", "transferPort", "downloadPath", "updateRoot", " downloadRoot", "updatehost", "urlDomain", "DownloadPath", "writePort", "transferHost", "downloadDomain", " downloadhost", "DownloadAddress", "downloadhost", "writeHost", "writeDomain", "downloadPort", "downloadRoot", " downloadPort", "transferhost", " downloadPath", "writehost", "transferPath", "Downloadhost", "updateHost", "downloadAddress"], "url": ["zip", "base", "ssl", "server", "uri", "resource", "user", "lock", "http", "rel", "j", "l", "il", "URL", "orb", "el", "util", "fl", "source", "jar", "connection", "ob", "build", "file", "li", "web", "ll", "bb", "log", "control", "ls", "ball", "coll", "image", "link", "sl", "rl", "service", "Url", "www", "ur", "obj", "ul", "contact", "f", "gl", "org", "loc"], "jurl": ["Jconnection", "Juri", "jUrl", "jjfile", "nurl", "ajurl", "jjob", "Jurl", "gUrl", "jeturi", "nconnection", "gURL", "jURL", "jetfile", "Jhttp", " jURL", "Jcoll", " jcoll", " jjob", "Jjob", "nURL", "jpURL", "ajuri", "jhttp", "jphttp", "jconnection", "jfile", "JUrl", " jfile", "ajfile", "jjcoll", "gurl", "gconnection", "jeturl", " jhttp", "jjurl", "JURL", "jjURL", "ajURL", "jetURL", "nUrl", "Jfile", "jpjob", "jpurl", "juri", "jcoll"], "je": ["zip", " ze", "jen", "ee", "pse", "ju", "ie", "kee", "py", "j", "se", "jl", "java", "jo", "si", "fr", "su", "la", "elt", "ja", "ji", "jar", "li", "Je", "jj", "ne", "oi", "js", "e", "ze", "jp", "obj", "ni", "opy", "Obj", "oe", "esi"], "is": ["zip", "info", "sin", "address", "i", "lis", "iss", "uri", "self", "IS", "isa", "http", "ie", "Is", "as", "ri", "api", "bs", "s", "il", "si", "ois", "ui", "ii", "ori", "in", "isl", "its", "so", "jar", "ais", "ob", "ir", "nis", "li", "src", "bb", "es", "ai", "ris", "js", "vs", "oss", "isin", "iris", "ios", "ib", "ses", "isi", "are", "obj", "state", "os", "iso", "cos", "mis"], "bis": ["zip", "uds", "sin", "base", "lis", "iss", "i", "uri", "pi", "IS", "usb", "bus", "lock", "serv", "http", "Is", "slice", "inner", "ri", "cb", "obb", "bs", "s", "abs", "ois", "bin", "ori", "bes", "binary", "sb", "bos", "oris", "bps", "connection", "proxy", "ubis", "ob", "ignore", "nis", "fb", "bb", "bi", "afi", "ris", "ls", "obs", "oss", "isin", "iris", "di", "ios", "ses", "obj", "abi", "os", "download", "bits", "boot", "cos", "mis"], "size": ["capacity", "address", "core", "sum", "close", "enc", "rc", "now", "act", "loc", "se", "eng", "mode", "large", "length", "si", "co", "grade", "time", "en", "content", "sized", "sync", "form", "cm", "rate", "use", "len", "small", "body", "cl", "hh", "init", "Size", "cel", "name", "ci", "cr", "send", "esc", "area", "SIZE", "speed", "unit", "shape", "ize", "err", "range", "sn", "scale", "width", "sec", "term", "iz"], "rb": ["bf", "rf", "nr", "rc", "lb", "vr", "eb", " rc", "ru", "cb", "rg", "lr", "obb", "ri", "rub", "orb", "rt", "RB", "pb", "rab", "gb", "reb", "abb", "rh", "sb", "wb", "ra", "erb", "buf", "r", "ob", "ruby", "src", "fb", "bb", "rar", "zb", "rr", "io", "rx", "rob", "cr", "nb", "adr", "area", "rl", "xb", "range", "rd", "sr", "loc"], "chunk": ["schrow", "bone", "chink", "Chunks", "cheunk", "shink", "prow", "CHink", "chunks", " Chunks", "clone", "punky", "clink", "pask", "cloy", "shoy", "cheunc", "chone", "qurow", "cheink", "chunky", "chunc", "CHunc", "boy", "quunk", " chunks", "schunk", "clunk", "shunk", "clunks", "chack", "quask", "Chack", "CHunk", "quunky", " Chunk", "schunky", " chack", " Chack", "chask", "chrow", "Chunk", "punk", "CHunks", "bink", "choy", "clunc", "cheunks", "bunk", "schask", "shone"]}}
{"id1": "13720140", "id2": "16804988", "code1": "    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {\n        Property property = new Property(new Long(valueID), userID);\n        String newValue = value;\n        System.out.println(property.getName());\n        if (property.getName().equals(\"Password\")) {\n            try {\n                MessageDigest crypt = MessageDigest.getInstance(\"MD5\");\n                crypt.update(value.getBytes());\n                byte digest[] = crypt.digest();\n                StringBuffer hexString = new StringBuffer();\n                for (int i = 0; i < digest.length; i++) {\n                    hexString.append(hexDigit(digest[i]));\n                }\n                newValue = hexString.toString();\n                crypt.reset();\n            } catch (NoSuchAlgorithmException e) {\n                System.err.println(\"jspShop: Could not get instance of MD5 algorithm. Please fix this!\" + e.getMessage());\n                e.printStackTrace();\n                throw new JspTagException(\"Error crypting password!: \" + e.getMessage());\n            }\n        }\n        property.setValue(newValue);\n    }\n", "code2": "    public void init() {\n        String filename = getParameter(\"filename\");\n        if (filename == null) {\n            Error(\"Illegal filename\");\n            return;\n        }\n        Dimension dim = DEFAULT_SIZE;\n        try {\n            int w = Integer.parseInt(getParameter(\"width\"));\n            int h = Integer.parseInt(getParameter(\"height\"));\n            dim = new Dimension(w, h);\n        } catch (Exception e) {\n        }\n        InputStream in;\n        try {\n            File ff = new File(filename);\n            in = new FileInputStream(ff);\n        } catch (Exception ignore) {\n            try {\n                URL url = new URL(filename);\n                in = url.openStream();\n            } catch (Exception e) {\n                Error(\"Graph viewer: Failed to open: \" + filename + \"\\n\" + e);\n                return;\n            }\n        }\n        getContentPane().add(getWindow(in));\n        resize(dim);\n        repaint();\n    }\n", "label": 0, "substitutes": {"modifyProperty": ["modifyproperty", "modateString", "modifiedproperty", "modureProperty", "ModifyAttribute", "modifyString", "modateAttribute", "ModifiedString", "ModifiedAttribute", "modureproperty", "Modifiedproperty", "modureString", "ModifyProperty", "modifiedProperty", "modateProperty", "modifyAttribute", "Modifyproperty", "modifiedAttribute", "modureAttribute", "ModifiedProperty", "modateproperty", "modifiedString", "ModifyString"], "valueID": ["ValueIndex", "ValueID", "propertyid", "ValueId", "propertyIP", "VALUEID", "valueId", "VALUEIndex", "jobId", "jobIP", "contentID", "VALUEid", "valueid", "valueIndex", "ValueIP", "jobid", "Valueid", "valueIP", "jobID", "propertyID", "contentIndex", "contentid", "propertyId"], "value": ["val", "string", "address", "server", "output", "response", "resource", "username", "token", "entry", "message", "description", "document", "result", "number", "key", "pattern", "content", "password", "expression", "Value", "source", "target", "default", "data", "text", "VALUE", "object", "language", "format", "name", "example", "image", "function", "array", "values", "update", "secret", "v", "reference", "command", "padding", "attribute", "phrase", "element", "code"], "userID": [" userId", "userName", "Userid", "authorId", "UserMAC", "authorid", " userMAC", "authorMAC", "userId", "userMAC", " userid", "authorName", " userName", "UserName", "userid", "UserID", "UserId", "authorID"], "property": ["string", "info", "base", "address", "foo", "temp", "resource", "definition", "entry", "option", "message", "profile", "character", "project", "primary", "result", "jo", "key", "password", "expression", "part", "Property", "type", "operation", "connection", "module", "feature", "section", "config", "data", "parent", "tmp", "entity", "variable", "object", "metadata", "p", "prototype", "style", "name", "function", "operator", "prefix", "layer", "position", "update", "this", "pair", "prop", "attribute", "properties", "method", "field", "element", "term"], "newValue": ["nextValue", "currentVal", "newVal", "replaceVal", "oldvalue", "defaultvalue", "currentValue", " newVal", "defaultVALUE", "nextVal", "oldVALUE", " newVALUE", " newvalue", "rawVal", "NewVALUE", "NewVal", "rawVALUE", "defaultValue", "rawValue", "currentvalue", "newString", "replacevalue", "NewValue", "oldVal", "currentVALUE", "nextVALUE", " newString", "nextvalue", "rawString", "replaceVALUE", "oldValue", "defaultVal", "newvalue", "NewString", "replaceValue", "newVALUE"], "crypt": ["ssl", "core", "temp", "cc", "cmp", "copy", "enc", "chip", "con", "c", "python", "hex", "Crypt", "ryption", "prot", "pool", "key", "security", "password", "ec", "comb", "client", "cm", "cp", "mac", "cache", "lib", "binary", "ctr", "ch", "mix", "bec", "conv", "ca", "poly", "utils", " cryptography", "conn", "coll", "chain", "rypt", "cr", "dec", "com", "cook", "auth", "cash", "contract", "coin", "pt", "cmd", "hash", "code"], "digest": ["encress", "Digester", "codress", "designest", " digend", "DigEST", "Diger", "ddest", "signEST", "crist", "signest", "Digress", "signer", "gener", " digist", "digit", "signested", "genested", "crester", "Digoded", "genEST", "cododed", "digester", "ddusher", "digend", "crend", "digested", "Digit", "encester", "crest", "designit", "digress", "Digest", "designester", "digoded", "Digend", "codester", "Digusher", "digusher", "Digist", "diger", "encest", "ddester", "codest", "designusher", "digist", " digester", "genest", "Digested", "encoded", "digEST", "ddit"], "hexString": ["hexBuffer", "cryptArray", "tempSection", "hexArray", "hexSection", "hashStr", "hexstring", "byteBuffer", " hexStr", " hexBuffer", " hexArray", "rexString", "cryptString", " hexSection", "cryptSection", "byteString", "exString", "cryptBuffer", "tempString", "rexBuffer", "hexStr", "hashString", "rexArray", "exBuffer", "tempArray", "exArray", "hashArray", " hexstring", "rexstring", "exstring", "tempBuffer", "byteArray", "byteStr", "hashBuffer"], "i": ["index", "info", "id", "uri", "pi", "mu", "slice", "c", "j", "ri", "o", "l", "s", "si", "ui", "ii", "in", "key", "ti", "d", "phi", "r", "data", "li", "h", "x", "p", "ip", "bi", "u", "init", "oi", "e", "I", "ci", "m", "io", "pos", "it", "xi", "di", "gi", "hi", "k", "v", "b", "abi", "multi", "f", "field", "ix"]}}
{"id1": "22441244", "id2": "949327", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"send": ["address", "execute", "add", "mail", "message", "end", "set", "write", "Send", "post", "build", "open", "text", "export", "append", "get", "sent", "reply", "delete", "submit", "start", "exec", "create", "parse", "transfer", "from"], "hsession": ["hmession", "hhort", "hmsession", "hsess", "hhession", "opensession", "HSessions", "hmSession", "hesort", "HSSession", "HSession", "opensessions", "opensess", "hhessions", "hhsession", "hesession", "opensort", "hhess", "HSsession", "hessession", "hsSession", "hsort", "hssession", "hessions", "opensSession", "hsessions", "openssession", "hmessions", "hession", "hhSession", "hesess", "hSession"], "session": ["event", "ession", "class", "server", "resource", "response", "chat", "mail", "site", "message", "document", "project", "host", "manager", "security", "client", "essions", "cache", "proxy", "connection", "application", "parent", "context", "Session", "port", "sl", "state"], "repositoryName": ["reposessionName", "reposicationEmail", "repositoryFamily", "reposessionEmail", "repoitoryNAME", "repositoryEmail", "repositiveEmail", "repositoryAddress", "reposositoryFamily", "reposicleName", "reposositoryEmail", "reposicationFamily", "reposositoryName", "reposessionNAME", "repositiveName", "repoitoryName", "reposicleFamily", "repoitoryPath", "repoositoryPath", "repoositoryName", "reposositoryAddress", "reposositoryNAME", "reposessionPath", "repositoryPath", "reposositoryPath", "repositiveNAME", "repoositoryFamily", "reposicleEmail", "reposicleAddress", "repoitoryFamily", "reposicationName", "reposicationAddress", "repoositoryAddress", "repoitoryEmail", "repositivePath", "repoositoryNAME", "repositoryNAME", "repoositoryEmail", "repoitoryAddress"], "ideIdint": ["ideIdInt", "ideInint", "ideIdn", "IDEidn", "IDEidints", "IDEIdInt", "ideidInt", "ideTimenumber", "IDEIdn", "ideAuthn", "ideInfoInt", "ideidints", "ideTimeint", "ideNamenumber", "ideInints", "ideAuthints", "ideAuthint", "ideInInt", "IDEIdints", "IDEidInt", "ideIdnumber", "ideIdints", "ideidint", "ideInfoout", "ideNameInt", "IDENamenumber", "ideidn", "ideNameint", "ideNameout", "ideInn", "IDEIdint", "ideAuthInt", "ideInfoint", "ideTimeout", "IDEIdnumber", "ideTimeInt", "ideInfonumber", "IDEidint", "IDEIdout", "ideIdout", "IDENameInt", "IDENameint", "IDENameout"], "to": ["address", "uri", "token", "response", "by", "settings", "mail", "site", "message", "sub", "account", "location", "TO", "company", "client", "source", "target", "To", "phone", "options", "reply", "about", "title", "po", "name", "template", "tel", "mobile", "prefix", "top", "summary", "with", "contact", "office", "from"], "cc": ["from", "address", "tc", "sc", "cf", "rc", "ck", "c", "cb", "account", "dc", "company", "nc", "password", "cus", "ec", "client", "ce", "uc", "lc", "ct", "ca", "phone", "cl", "ci", "card", "cr", "CC", "comment", "ac", "cn", "cs", "contact", "cca", "code"], "bcc": ["fcc", "fc", "abck", "bck", " brc", "bbck", "pck", "bce", " bce", "pce", "bbcc", " bc", "bbrc", "bbc", "pc", "abcc", "bc", " bck", "abc", "abce", "frc", "fck", "pcc", "brc"], "subject": ["reason", "head", "uri", "response", "username", "ject", "mail", "author", "filename", "description", "message", "sub", "host", "content", "phone", "object", "request", "reply", "format", "title", "template", "header", "prefix", "comment", "state", "Subject", "method"], "body": ["zip", "string", "reason", "base", "foot", "resource", "response", "lock", "message", "description", "plain", "inner", "html", "length", "shell", "line", "pass", "content", "password", "part", "source", "money", "connection", "media", "data", "text", "pod", "object", "empty", "Body", "style", "name", "header", "template", "tree", "how", "normal", "function", "url", "comment", "secret", "bound", "summary", "left", "wrapper", "code", "view"], "attachments": ["Attachents", "attachents", "messings", "messment", "Attachments", "embedings", "Attachment", "embedents", "attachings", "messments", "messents", "Attachings", "embedments", "embedment"], "isHtml": ["isHail", " isHttp", "isHatml", " isChail", " isChtml", "isPhhtml", "isPhtml", " isWhive", "isHahtml", " isChhtml", " isHhtml", "isWhail", "isChive", " isHive", "isWhtml", "isHttp", "isHattp", "isWhhtml", "isCtml", "isChttp", " isHail", "isCive", " isChttp", "isPhttp", "isCail", " isWhtml", "isChhtml", "isHaail", "isHhtml", " isWhail", "isWhive", "isChtml", "isPhail", " isWhhtml", "isHive", "isChail"], "charset": ["cheanspace", "cheansete", "chackset", "chARSete", "charsete", "Charset", "charsets", "chasetting", "chARSets", "chaseseting", "chasesET", "chARSet", "chasesetting", "chearsete", "chashesET", "Charsets", "chearsET", "chearsetting", "charseting", "chacksET", "chaset", "charsetter", "chARSeting", "chearset", "chashespace", "Charsetting", "chearsetter", "CharsET", "chARSET", "cheansetter", "chaseset", "cheansET", "chaseting", "chARSetting", "cheanset", "chacksete", "chasetter", "chashesetter", "chasET", "chaspace", "chansetting", "cheansetting", "charspace", "chanspace", "chanset", "charsetting", "chasheset", "chansET", "chearspace", "chasets", "charsET", "chansetter", "chansete", "chacksetting", "Charseting"], "headers": [" emails", " messages", "settings", "ers", "comments", "writers", "errors", "content", "params", "users", "lines", "strings", "names", " recipients", " cookies", "classes", "options", "metadata", "authors", "groups", "header", "status", "types", "mails", "files", "properties"], "priority": ["reason", "class", " title", "lang", "author", "comments", "mode", "length", "queue", "security", "quote", "date", "level", " recipients", "phone", "language", " severity", "reply", "title", "template", "status", "theme", "prefix", "secret", "comment", "state", "code"], "email": ["letter", "article", "info", "address", "base", "event", "zip", "online", "server", "output", "response", "username", "note", "generic", "auto", "mail", "message", "document", "ilo", "result", "html", "account", "line", "el", "Email", "en", "password", "gmail", "install", "pm", "model", "international", "default", "data", "text", "entity", "liner", "export", "object", "ssl", "view", "test", "template", "name", "example", "e", "lex", "url", "fax", "ext", "update", "em", "create", "print", "contact", "xml", "core", "business", "office", "oe", "engine", "element", "service", "external", "enter"], "user": ["string", "info", "id", "resource", "token", "username", "author", "character", "USER", "profile", "User", "uid", "account", "unknown", "people", "client", "er", "friend", "use", "type", "users", "member", "connection", "model", "data", "object", "ip", "plugin", "creator", "name", "e", "person", "role", "mobile", "me", "consumer"], "identity": ["authority", "personity", "authentonymous", "IdentITY", "entityity", "personITY", "idity", "publicITY", "idization", "authoriciary", "ethnicifier", "authentity", "Identities", "electricentity", "ethniciciary", "identization", "authorication", "Identity", "authoronymous", "publicentity", "identITY", "publicity", "electriconymous", "authorifier", "idonymous", "identication", "identifier", "entityization", "authorentity", "ethnicity", "IDENTities", "authorities", "identiciary", "installITY", "electricITY", "idication", "idITY", "authentITY", "installentity", "publiciciary", "entityifier", "authentication", "entityonymous", "authentifier", "personifier", "ethnicITY", "ethnicication", "electricity", "personentity", "idifier", "authentization", "IDENTITY", "identonymous", "idententity", "IDENTentity", "authorITY", "installity", "ethnicentity", "IDENTity", "installonymous", "identities", "Idententity"], "_returnPath": ["_responsePath", "_correctPath", "_backPart", "_returnMid", " _returnHalf", " _backPart", " _backTo", "_replyNode", "_replyUrl", "_addType", "_relationId", "_relationText", "_backPath", "_returnTo", "_responseType", " _returnPart", "_resultTo", "_returnHalf", "_replyPath", "_returnpath", "_backName", "_backpath", " _backPath", "_displayPart", "_relationPath", "_inputMid", "_resultName", "_returnName", "_resultHalf", "_replyPart", "_displayUrl", "_returnId", "_returnType", " _returnTo", "_displayNode", " _backUrl", "_responsepath", "_returnNode", " _backName", " _backHalf", "_displayPath", "_addpath", "_inputUrl", " _returnUrl", "_returnPart", "_replyMid", "_successPath", "_correctText", "_relationDirectory", "_backHalf", "_returnDirectory", "_successDirectory", "_correctId", "_returnUrl", "_backUrl", "_inputPath", "_backType", "_successId", "_successText", "_resultPath", "_returnText", "_inputNode", "_displayMid", " _returnName", "_addPath", "_backTo", "_correctDirectory"], "_from": ["_From", "existingfrom", "_owner", "blockerror", "_with", "_error", "workto", "blockfrom", "workwho", " _source", "workfrom", "blockto", "_who", "worksource", "blockFrom", "placeowner", "existingto", "_source", " _error", "placefor", "placefrom", " _owner", " _with", " _for", " _who", "existingfor", " _From", "_for", "existingowner", "placeto"], "_replyTo": ["_returnTO", "_replyPoint", "_closeFrom", "_reasonUrl", " _returnFrom", "_respondAddress", "_respondUrl", "_replyAddress", "_reasonFrom", "_returnPoint", "_respondTO", "_closeTO", "_commentFrom", "_addTo", " _replyTO", " _returnUrl", "_replyOf", "_replyFrom", "_returnOf", "_reasonTo", "_commentTO", "_replyTO", "_addPoint", " _replyUrl", "_replyUrl", "_closeOf", "_respondTo", "_returnUrl", "_respondFrom", " _returnTo", "_addAddress", "_closeTo", " _returnTO", "_returnAddress", "_respondPoint", " _replyFrom", "_commentOf", "_reasonTO", "_commentTo", "_returnTo", "_returnFrom", "_addFrom"], "_to": ["_target", " _about", " _target", "Jto", "Jfrom", "Jabout", "Jtarget", "_about"], "_cc": [" _cf", "_cf", " _ce", " _cd", "_cd", "_ce"], "_bcc": ["_abcc", " _abcc", " _bc", " _abcs", "_rbcs", " _bcs", " _abc", "_rbcc", "_rbc", "_sbce", "_sbcs", "_abcs", "_sbc", "_abce", "_bc", " _abce", "_rbce", "_bce", "_sbcc", "_abc", "_bcs", " _bce"]}}
{"id1": "13757855", "id2": "18731843", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "label": 1, "substitutes": {"process": ["Process", "path", "resource", "output", "project", "run", "construct", "load", "proc", "build", "request", "cess", "submit", "processing", "exec", "call", "evaluate", "update", "processor", "parse", "create", "handle", "transform", "code", "view"], "tpl": ["tipl", "templ", "atpl", "fml", "tbl", "lcl", "qtpl", " tple", "Tpp", "tml", "Tbl", "stPL", " tipl", " tplate", "lplate", "latyl", "qtfc", "lpl", "tmpl", " tcl", "latcp", "tcp", "Tplate", " ttemplate", "pipl", "tplate", "Tpl", "temPL", "fplate", "qtple", "lPL", "latpl", "lple", "qtyl", "tmcp", "tmyl", "qtcp", "pcl", "psl", " tplug", "tsl", " tfc", "TPL", " tbl", " tper", "tmple", "tyl", "Tcl", "tpp", "templates", "Tper", "ppl", "tplug", "lml", "itPL", "Tipl", "lper", "Ttemplate", "temtemplate", "qtbl", "atplug", "tplates", " tsl", "pPL", "ttemplate", "itplates", "tfc", "Tple", "Tsl", "Tplates", " tplates", "tcl", "Tml", " tml", "stpl", "itplate", "fpl", "fplug", "atml", "tPL", " tpp", "stpp", "tple", "atplate", "stplate", "Tfc", " tPL", "latple", "itpl", "tper"], "model": ["where", "node", "copy", "json", "message", "document", "project", "result", "location", "params", "doc", "media", "config", "data", "body", "models", "language", "log", "Model", "m", "graph", "conf", "command", "xml", "module", "param"], "packageName": ["PackageName", "Packagename", "contextInfo", "packageInfo", "modulename", "groupUrl", "groupname", "contextname", "packageUrl", " packageNames", "packageNames", "groupName", "projectKey", "moduleUrl", "projectname", "PackageInfo", "moduleKey", "projectName", "moduleName", " packageInfo", "PackageNames", "contextNames", "packagename", "groupKey", "packageKey", " packagename", "projectUrl", "contextName"], "outFileName": ["outFilenameHalf", "outFullTime", "outFullLine", "inDirCopy", "OUTFileHalf", "OutFileName", "outfileOnce", "outfileNames", "outDirName", "outFullname", "difffileTime", "difffileName", "outFilenameNames", "diffFileTime", "OutFilename", "outDirname", "OutDirNames", "outFullNames", "outFileCopy", " outFileInfo", "OUTBufferName", "difffileOnce", "diffFileName", "OutFileLine", "outFilesLine", "outLineInfo", "OUTFileMode", "outLineNames", "outfileName", "inFileName", "outDirInfo", "outfileEnd", "inDirPath", " outFullInfo", " outFileLine", " outDirName", " outFilePath", "outfilePath", "outLinename", "outFileLine", "outFilenameMode", "outFilePath", "outFilenameEnd", "outFullPath", "outFilenamePath", "outLineTime", "outFileInfo", "outfileCopy", "outDirLine", "outfileMode", "outStreamName", "outDirPath", " outDirTime", "OUTBufferMode", "outRuleInfo", "OUTBufferHalf", "outRuleType", "outFilename", "outFilenameCopy", "outDirCopy", "difffileInfo", " outFileTime", "outFileHalf", "outBufferMode", " outDirLine", "outDirNames", "diffFileOnce", "OutDirLine", "outfileInfo", "inFilePath", "OutDirName", "outDirEnd", "outFileEnd", " outFullName", "outFullInfo", "OUTFileNames", "diffFileInfo", "outfileHalf", "outBufferNames", "OutFileNames", " outFileType", "outfileTime", "outDirOnce", "inDirEnd", "inFileEnd", "outStreamInfo", "outFileTime", "outFileMode", "outFileOnce", "outLineOnce", "outFilesPath", "OUTFileName", "outFileNames", "outDirTime", "OUTBufferNames", "outFullType", "outLineName", "outRuleName", " outDirPath", "outFilenameName", "outLineLine", "outBufferName", "outFileType", "outFilesTime", "outFilesName", " outFullType", "inDirName", "inFileCopy", "outStreamType", "OutDirname", "outBufferHalf", "outFullName"], "xsltParam": ["xldparam", "xsldParam", "xsltVal", "xslicVal", "xltMode", "xslpVal", "xslpParam", "xslpMode", "xsldparam", "xltVal", "xslicMode", "xldParam", "xldVal", "xltparam", "xslicParam", "xslicparam", "xslpparam", "xsltparam", "xsldVal", "xltParam", "xsldMode", "xsltMode", "xldMode"], "artifact": ["ARTifest", " artifacts", " artribution", "ARTifact", "Artifact", "adverturation", "aratifest", "ARTfact", "advertifacts", "arturation", "ARTifacts", "advertribution", "aratifacts", "aratifact", "Arturation", " arturation", "Artifest", "aratfact", "Artifacts", "artifest", "artifacts", "artribution", "Artribution", "Artfact", "advertifact", "artfact"], "destinationPath": ["destinatorLocation", "destinationWidth", "restinationHalf", "destinatedpath", "combinatorpath", "restificationPath", "datinationTime", "destinationHalf", "distinatorPath", "destinateHandler", "destinatorHalf", "DestinationName", "destinationCry", "destinatorStep", "distributionPath", "destiationPath", "destiningName", "constinationsName", "DestinationPart", "destiningPoint", "destinationHandler", "destinatedDir", "destinateName", "restinationPoint", "destiationAuth", "destinationUrl", "distinationName", "restificationpath", "restificationPoint", "destinatorWidth", "destificationPath", "constinationContext", "destinatedStep", "destinatingName", "destinatorPath", "destinatorHandler", "restinatorPoint", "destinatorFile", "distributionpath", "destinatingLocation", "desturationHandler", "destinatorKey", "constinatorUrl", "destinationTime", "destplingDir", "distinationCry", "datinatepath", "destinatorString", "distinatorFile", "destinerContext", "destinatedString", "destributionCase", "desticationPart", "distinatorName", "destiationDir", "destationpath", "tempinatedHalf", "DestinatingPoint", "destcreationPath", "destignmentCry", "destiningpath", "datinationpath", "destinationpath", "destinatorPoint", "combinationpath", "destinatedPoint", "destplingUrl", "distinationpath", "destinatorCase", " destificationLog", "constinatorWidth", "destiationLog", "destinatePath", "tempinationDir", "DestificationPart", "destplingWidth", "destinationString", "destinatingPoint", "constinationDir", "destinatedPath", "destinationAuth", "destributionpath", "destinationKey", "destinerPath", "destinatedFile", "destensionText", "restinatorHalf", "destinationsPath", "constinatorDir", "destplingLog", "DestificationPath", "datinatePath", "destinationDir", "constinationUrl", "destinatorTime", "destinationsName", "distinationFile", "restinationpath", "destplingAuth", "destributionPath", "distinationKey", "constinatorContext", "destinationText", "restinationPath", "tempinatedPath", "destinationName", "restinatorString", "destinationPart", "constinationsPath", "destinateString", "distinatorStep", "destinatePoint", "distinationCase", "destributionDir", "desticationFile", "restinationString", "destificationDir", "destinationFile", "combinatorPath", "constinatorPath", "desticationPath", "destinateText", "destensionPoint", " destinationLog", "destiningContext", "destinatingpath", "destplingPath", "desturationpath", "destificationpath", "destignmentName", "restinationLocation", "destificationPoint", "datinateTime", "destributionCry", "datinationLocation", "restinatorPath", "destinatingPath", "destinateLocation", "destinatedHalf", "destinatorCry", " destinationAuth", "DestinatingPath", "destinerDir", " destinationDir", "destcreationUrl", "constinationspath", "constinationWidth", "destributionName", "destinatorpath", "destinationStep", "tempinationPath", "destationPath", "destensionPath", "combinationHandler", "tempinationHalf", "datinationPath", " destificationAuth", "destiningDir", "destinatorUrl", "distributionDir", "destiningPath", "distinatorCase", "destinatedCase", "DestinationText", "distinationStep", "distributionCase", "destinatingText", "destationTime", "destinatorDir", "desturationPath", "DestinatingText", "destificationName", "destinateDir", "tempinationpath", "datinateLocation", "distinationDir", " destificationPath", "destinationCase", "distinationPath", "destationLocation", "destificationPart", "combinationName", "distinatorCry", "desticationKey", "combinatorHandler", "destinateHalf", "destificationAuth", "destinationLog", "destinatedKey", "desticationStep", "tempinatedDir", "destificationLocation", "desturationName", "constinationpath", "destinatepath", "destinationLocation", "constinationPoint", "destinationContext", "destensionName", "constinationName", "destinateTime", "constinationsPoint", "combinatorName", "destignmentCase", "destinationspath", "DestificationName", "DestinationPoint", "destinatorContext", "constinationPath", "DestinatingName", "restificationLocation", "destcreationWidth", "destignmentPath", "distinatorKey", "desticationName", " destificationDir", "destinationsPoint", "constinatorpath", "DestinationPath", "destinationPoint", "tempinatedpath", "destinatePart", "destinatorName", "destinerpath", "destificationLog", "combinationPath"], "in": ["IN", "i", "input", "ex", "n", "con", "c", "ins", "bin", "source", "reader", "d", "doc", "cache", "connection", "min", "r", "inc", "config", "data", "x", "name", "image", "t", "In", "din"], "out": ["index", "string", "path", "temp", "outer", "output", "ex", "sys", "server", "user", "lock", "copy", "Output", "version", "OUT", "result", "outs", "o", "pool", "all", "write", "line", "manager", "bin", "key", "post", "client", "part", "session", "source", "doc", "cache", "lib", "up", "connection", "str", "group", "store", "parent", "w", "file", "page", "log", "gen", "conn", "msg", "ne", "again", "name", "exec", "Out", "io", "writer", "dump", "prefix", "full", "free", "comment", "err", "obj", "with", "state", "cli", "error", "list", "point"], "root": ["index", "path", "node", "loader", "id", "results", "resources", "json", "instance", "modules", "meta", "query", "pattern", "params", " result", "cache", "r", "cat", "collection", "parent", "roots", "Root", "options", "format", "tree", "graph", "values", "url", "_", "include", " roots", "history", "xml", "module", "transform"]}}
{"id1": "18202328", "id2": "19322910", "code1": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "code2": "    @Test\n    public void test_blueprintTypeByTypeID() throws Exception {\n        URL url = new URL(baseUrl + \"/blueprintTypeByTypeID/20188\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"{\\\"blueprintTypeID\\\":20188,\\\"blueprintTypeName\\\":\\\"Obelisk Blueprint\\\",\\\"productTypeID\\\":20187,\\\"productTypeName\\\":\\\"Obelisk\\\",\\\"productCategoryID\\\":6,\\\"techLevel\\\":1,\\\"productionTime\\\":1280000,\\\"researchProductivityTime\\\":7680000,\\\"researchMaterialTime\\\":5120000,\\\"researchCopyTime\\\":2560000,\\\"researchTechTime\\\":500000,\\\"productivityModifier\\\":256000,\\\"wasteFactor\\\":10,\\\"maxProductionLimit\\\":1,\\\"productVolume\\\":\\\"17550000\\\",\\\"productPortionSize\\\":1,\\\"dumpVersion\\\":\\\"cru16\\\"}\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n        connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/xml\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?><invBlueprintTypeDto><blueprintTypeID>20188</blueprintTypeID><blueprintTypeName>Obelisk Blueprint</blueprintTypeName><dumpVersion>cru16</dumpVersion><maxProductionLimit>1</maxProductionLimit><productCategoryID>6</productCategoryID><productPortionSize>1</productPortionSize><productTypeID>20187</productTypeID><productTypeName>Obelisk</productTypeName><productVolume>17550000</productVolume><productionTime>1280000</productionTime><productivityModifier>256000</productivityModifier><researchCopyTime>2560000</researchCopyTime><researchMaterialTime>5120000</researchMaterialTime><researchProductivityTime>7680000</researchProductivityTime><researchTechTime>500000</researchTechTime><techLevel>1</techLevel><wasteFactor>10</wasteFactor></invBlueprintTypeDto>\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/xml; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"register": ["play", " reg", "setup", "user", "master", " regenerate", "activate", "Register", "save", "password", "load", "login", "Login", "bind", "config", "check", "init", "start", "chain", " registration", " unlock", "app", "update", "create", "auth", "reg", "connect", " Register"], "session": ["play", "event", "remote", "ssl", "ession", "temp", "input", "server", "resource", "video", "game", "user", "lock", "master", "site", "message", "version", "slave", "socket", "python", "window", "child", "shell", "host", "driver", "global", "thread", "manager", "database", "room", "security", "password", "client", "sync", "sa", "cache", "sb", "use", "proxy", "login", "connection", "browser", "facebook", "machine", "group", "section", "config", "parent", "channel", "h", "request", "device", "conn", "Session", "ess", "image", "port", "person", "mc", "position", "connect", "cookie", "state", "gui", "script", " Session", "service", "caster", "view"], "username": ["string", "path", "address", "NAME", "duration", "uri", "token", "user", "subject", "message", "filename", "profile", "character", "uid", "mother", "account", "driver", "host", "ame", "length", "database", "password", "Password", "monitor", "email", "minecraft", "source", "users", "seed", "login", " nickname", "sword", "text", "phone", "verb", "hello", "title", "name", "Name", "amer", "nick", "ername", "word", "voice", "prefix", "mobile", "person", "url", "steam", "property", "localhost", "auth", "secret", " password", "attribute", "crypt", "phrase", "term"], "verificationKey": ["verifyPoint", "vermentSecret", "verationSecret", "verificationSecret", "vermentKEY", "validifyingKey", "significationSecret", "verifySecret", "significationkey", "verationPoint", "verificationPoint", "verifykey", "verifyingkey", "signationKey", "validifyingPoint", "verationkey", "validificationKey", "verifyingKEY", "signationKEY", "significationKey", "validifyingkey", "vermentKey", "verifyingSecret", "verationKey", "vermentkey", "signationkey", "verificationkey", "verationKEY", "signationSecret", "validificationPoint", "verifyingPoint", "verifyingKey", "verificationKEY", "significationKEY", "validifyingSecret", "verifyKey", "validificationkey", "validificationSecret"], "salt": [" sodium", " sort", "Shash", "seSalt", "setsodium", "sSalt", "suffSalt", "sort", "Salt", "SSalt", "suffalt", "sALT", "SALT", "sodium", " sALT", "sehash", "setsalt", "seALT", "suffhash", "shash", "setsort", "suffALT", "setsALT", "sealt"], "hash": ["string", "square", "address", "total", "sum", "her", "input", "buffer", "output", "user", "message", "version", "kh", "result", "hex", "Hash", "html", "match", "pool", "host", "number", "memory", "query", "ash", "key", "password", "mac", "cache", "sha", "build", "text", "h", "log", "name", "header", "hed", "array", "url", "auth", "secret", "crypt"], "digest": ["defester", "Digester", " diggest", "DigEST", "signEST", "logit", "signest", "bigest", " digested", "biggest", "bigested", "digit", "signests", "hedested", "logester", " dige", "signested", "Digests", "diggest", "Diggest", " digger", "digester", "Dige", "digests", "digested", "Digit", "digger", "Digest", "defest", "logger", " digEST", "bigester", " digester", "Digger", "hedEST", " digests", "Digested", " digit", "defe", "dige", "defEST", "logest", "hedester", "digEST", "hedest"], "nameChars": ["nameCheARS", "namechacters", "nameChases", "nameCheats", "nameCharars", "nameChats", "nameChARS", "namechars", "nameCheases", " nameChararts", "nameChears", " nameChacters", " nameCharts", "nameGrars", " nameChARS", " nameCharars", "namechats", " nameChases", "namecharts", " nameChats", " nameCharacters", "nameGracters", " nameCharARS", "nameChacters", "namechARS", "nameCharARS", "nameChararts", "namechases", "nameGrARS", "nameGrarts", "nameCharts", "nameCharacters"], "nameChar": ["NameCh", "nameCharacter", "idChar", "Namechar", "addressCh", "nameCh", "NameChar", " NameText", " NameCharacter", "nameDir", "resourceCharacter", "idText", " nameDir", "addressCtrl", "addressChar", "nameCtrl", " nameCtrl", " nameText", "idCharacter", " nameCharacter", "idCh", "addressCharacter", " namechar", "nameText", " nameCh", " NameCh", "namechar", "NameCharacter", "NameCtrl", "resourceDir", "resourcechar", "resourceChar", " NameChar", "NameDir"], "p": ["P", "i", "n", "op", "pre", "lp", "per", "py", "j", "fp", "o", "l", "s", "er", "client", "cop", "part", "ap", "at", "d", "pp", "q", "up", "cp", "r", "g", "h", "np", "u", "po", "e", "m", "t", " P", "jp", "pc", "a", "pa", "pe", "pair", "b", "sp", "br", "v", "ps", "f", "api", "point"], "player": ["play", "class", "ace", "server", "video", "n", "game", "user", "gamer", "master", "slave", "per", "board", "l", "driver", "pool", "match", "players", "manager", "owner", " Player", "ler", "er", "client", "part", "member", "live", "aster", "connection", "leader", "media", "pm", "machine", "g", "parent", "data", "pro", "league", "party", "Player", "name", "e", "m", "playing", "controller", "worker", "person", "team", "layer", "position", "steam", "pe", "can", "played", "script", "conference", "caster", "winner"], "c": ["cu", "tc", "cc", "sc", "n", "cf", "rc", "enc", "con", "fc", "cb", "o", "l", "dc", "nc", "ec", "cm", "cp", "cache", "lc", "d", "ce", "ct", "r", "config", "ca", "cl", "h", "C", "arc", "ci", "m", "t", "cr", "chain", "pc", "mc", "ctx", "bc", "abc", "k", "conf", "v", "ac", "cs", "f"]}}
{"id1": "8801182", "id2": "5049453", "code1": "    private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception {\n        Properties list = new Properties();\n        list.load(new FileInputStream(fileWithListOfImages));\n        long current = 0;\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir);\n        System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\");\n        System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\");\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\");\n        }\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            URL url = new URL(uriPrefix + urlString);\n            File file = new File(outputDir + \"/\" + imageNameToFileName(urlString));\n            current++;\n            if (!file.exists()) {\n                try {\n                    BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000);\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000);\n                    int c;\n                    while ((c = in.read()) != -1) {\n                        out.write(c);\n                    }\n                    out.close();\n                    in.close();\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                    System.out.println(\"saved\");\n                } catch (Exception e) {\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage());\n                }\n            } else {\n                System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                System.out.println(\"already exists\");\n            }\n            if (current / 100 == current / 100.0) {\n                long delta = (System.currentTimeMillis() - startTime);\n                System.out.println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\");\n            }\n        }\n        long delta = (System.currentTimeMillis() - startTime);\n        System.out.println(\"Total time \" + delta + \" ms, \" + (delta / list.size()) + \" ms/file\");\n    }\n", "code2": "    private BingResponse queryBing(BingRequest request) throws BingException {\n        try {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Searching through bing...\");\n            }\n            String query = request.getQuery();\n            query = URLEncoder.encode(query, \"UTF-8\");\n            URL url = new URL(\"http://api.bing.net/json.aspx?\" + \"AppId=\" + request.getAppId() + \"&Query=\" + query + \"&Sources=\" + request.getType().toString());\n            URLConnection connection = null;\n            if (useProxy) {\n                if (proxyType == null) {\n                    throw new BingException(\"Please set a proxy first before trying to connect through a proxy\", new Throwable());\n                }\n                connection = ProxyWrapper.getURLConnection(url.toString(), proxyType.toString(), proxyHost, proxyPort);\n            } else {\n                connection = new URL(url.toString()).openConnection();\n            }\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            String response = builder.toString();\n            ResponseParser parser = new ResponseParser();\n            parser.getError(response);\n            return parser.getResults(response);\n        } catch (MalformedURLException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        } catch (IOException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        }\n    }\n", "label": 0, "substitutes": {"downloadImages": ["loadFiles", "getImage", "loadImage", "Downloadimages", "downloadimages", "downloadFiles", "DownloadFiles", "DownloadImage", "downloadImage", "loadimages", "getimages", "loadImages", "getImages", "getFiles", "DownloadImages"], "uriPrefix": ["uriRepiy", "iriAffiy", "uriRefixed", "URIPrefix", "uriPrefuff", "uriPrefixed", "uriBuffik", "iriAffix", "uriBufferences", "URIPrefIX", "URIPreix", "uriBuffix", "uriRepix", "uriPreIX", "uriPreix", "uriPrefiy", "uriRepIX", "uriAffIX", "iriPreffix", "uriRefIX", "URIPrefuff", "uriRepluff", "iriPrefIX", "uriAfffix", "uriRefuff", "URIPrefik", "URIAffix", "iriAfffix", "iriPrefix", "uriReffix", "uriRefik", "URIPreffix", "uriReplix", "uriAffix", "URIAffik", "uriBuffixed", "uriPrefIX", "uriPreferences", "uriPreiy", "uriAffiy", "uriAffixed", "iriAffIX", "URIAffixed", "URIPreferences", "uriPrefik", "uriReferences", "uriReplfix", "uriAffik", "URIPrefixed", "uriRefix", "uriRepfix", "iriPrefiy", "URIPreIX", "URIPreuff", "uriAfferences", "uriReplIX", "uriPreuff", "uriPreffix", "URIAfferences"], "fileWithListOfImages": ["fileWithListofFiles", "fileWithListOfFiles", "fileWithListofimages", "fileWithlistOfFiles", "fileWithlistOfimages", "fileWithListofImages", "fileWithListOrImages", "fileWithListTenimages", "fileWithListOfImage", "fileWithListTenImage", "fileWithlistofImages", "fileWithlistofimages", "fileWithListOrFiles", "fileWithlistofImage", "fileWithListTenImages", "fileWithlistOfImages", "fileWithListofImage", "fileWithListOrimages", "fileWithlistOfImage", "fileWithListOrImage", "fileWithlistofFiles", "fileWithListOfimages"], "outputDir": ["inputFolder", "targetFolder", "OutputDirectory", "exportDIR", "outputFolder", "exportFile", " outputFolder", "outputPath", "exportDirectory", "exportDir", "inputPath", " outputDirectory", "inputDir", "targetDir", "targetPath", "OutputDir", " outputPath", " outputFile", "inputDirectory", "outputDIR", "outputDirectory", "targetDirectory", " outputDIR", "OutputPath", "outputFile", "OutputFile", "OutputDIR"], "list": ["base", "pre", "cont", "set", "detail", "fail", "not", "default", "listed", "get", "format", "lists", "coll", "st", "xml", "string", "info", "self", "id", "later", "all", "part", "source", "load", "cache", "lc", "live", "parent", "best", "ist", "cl", "page", "object", "test", "name", "chain", "array", "full", "bl", "left", "i", "json", "system", "queue", "like", "see", "diff", "show", "collection", "plugins", "ll", "p", "null", "image", "stack", "state", "cli", "view", "user", "table", "l", "pool", "last", "LIST", "type", "config", "data", "li", "log", "ls", "we", "batch", "L", "this", "code"], "current": ["index", "total", "temp", "resource", "copy", "continue", "now", "sequence", "version", "recent", "result", "length", "active", "existing", "follow", "queue", "reported", "next", "loop", "client", "last", "content", "valid", "connection", "component", "running", "counter", "urrent", "section", "parent", "page", "request", "context", "style", "complete", "example", "status", "seconds", "correct", "latest", "position", "update", "today", "future", "left", "progress", "count", "currently", "multi", "width", "cur", "Current", "initial"], "startTime": ["startTimes", "endTimes", "StartTime", "endtime", "starttime", "startPath", "startedTime", "startedPath", "startedTimes", "endTime", "endPath", "Starttime", "StartPath", "startedtime", "StartTimes"], "it": ["ite", "index", "itter", "i", "id", "ort", "pi", "op", "ie", "ic", "ind", "slice", "IT", "j", "end", "et", "l", "il", "iv", "mit", "si", "iter", "its", "stat", "sit", "source", "the", "which", "ct", "not", "other", "section", "parent", "he", "ist", "itted", "ip", "ita", "p", "ant", "get", "init", "lit", "or", "edit", "start", "ci", "I", "iti", "t", "they", "chain", "rit", "itation", "ait", "ith", "you", "unit", "itory", "_", "ul", "st", "and", "It", " It", "pit", "ble"], "urlString": ["urlObject", "uriSingle", "URLObject", "URLBytes", "URLStr", "UrlBytes", "urlstring", "urlByte", "uriStr", "fileByte", " urlInt", "imageLetter", " urlStr", "httpString", " urlstring", "URLString", "urlUnit", "fileInt", "filestring", "uriString", "httpSingle", "imageString", " urlUnit", "slSingle", "urlSingle", "fileLetter", " urlByte", " urlSingle", "fileStr", "httpStr", "httpUnit", "slString", "UrlByte", "slStr", "urlLetter", "uristring", "UrlObject", " urlBytes", "URLstring", "fileString", "slstring", "urlBytes", "UrlString", "URLByte", "urlStr", "urlInt", "imageInt", "imageUnit", "imageStr", " urlLetter", "imageSingle", " urlObject"], "url": ["string", "path", "base", "address", "ssl", "i", "input", "id", "uri", "resource", "server", "user", "http", "socket", "rel", "l", "URL", "el", "key", "git", "source", "up", "connection", "str", "channel", "object", "ll", "name", "coll", "image", "link", "sl", "pull", "Url", "left", "ul", "f", "gl", "service", "download"], "file": ["base", "class", "resource", "http", "document", "plain", "rule", "model", "get", "fil", "files", "server", "lock", "part", "source", "use", "binary", "dir", "live", "up", "connection", "cache", "store", "un", "parent", "work", "page", "object", "le", "name", "e", "full", "unit", "b", "play", "letter", "path", "directory", "ile", "mail", "per", "line", "File", "queue", "back", "no", "book", "or", "image", "to", "function", "future", "field", "auto", "single", "ban", "user", "filename", "place", "table", "fp", "l", "media", "FILE", "data", "check", "local", "x", "log", "folder", "home", "db", "pe", "block", "f"], "in": ["IN", "index", "sin", "ssl", "pin", "token", "cf", "ini", "pre", "on", "as", "ins", "s", "bin", "none", "gen", "a", "din", "impl", "inas", "id", "by", "inv", "source", "binary", "up", "min", "inside", "r", "un", "again", "isin", "In", "skip", "b", "inn", "win", "i", "n", "gin", "con", "inner", "el", "no", "d", "reader", "diff", "body", "h", "p", "inline", "init", "image", "nin", "ac", "cin", "expl", "input", "l", "pass", "is", "ine", "login", "inc", "my", "data", "de", "pull", "of", "stream", "err", "f", "this", "re", "from"], "out": ["IN", "output", "token", "net", "window", "bin", "raw", "lib", "default", "gen", "conn", "Out", "comment", "obj", "print", "point", "ex", "outer", "sys", "server", "lock", "query", "post", "part", "cache", "up", "work", "w", "parent", "page", "again", "exec", "In", "b", "n", "con", "inter", "inner", "outs", "o", "line", "flow", "write", "co", "bar", "session", "one", "group", "init", "io", "writer", "image", "to", "state", "cli", "error", "cmd", "auto", "sum", "copy", "user", "OUT", "table", "pool", "extra", "key", "client", "ger", "inc", "data", "size", "log", "call", "dump", "prefix", "ext", "err", "code"], "c": ["cu", "i", "sc", "n", "rc", "enc", "ic", "character", "z", "end", "col", "l", "dc", "char", "ec", "d", "lc", "uc", "ct", "r", "ch", "cy", "w", "channel", "xc", "cl", "h", "x", "p", "C", "arc", "e", "ci", "m", "t", "cr", "pointer", "esc", "dec", "pc", "abc", "k", "b", "v", "count", "f", "code"]}}
{"id1": "3024987", "id2": "1954410", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamForencoded", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_Coding", "testCopy_readerToOutputStream_Coder", "testCopy_readerToOutputStream_encode", "testCopy_readerToOutputStream_Integoder", "testCopy_readerToOutputStream_Coded", "testCopy_readerToOutputStreamForEncode", "testCopy_readerToOutputStream_Integode", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStreamForencode", "testCopy_readerToOutputStream_Encode", "testCopy_readerToOutputStreamForencoder", "testCopy_readerToOutputStream_Code", "testCopy_readerToOutputStreamForEncoder", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStream_Integoded", "testCopy_readerToOutputStreamForEncoded", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStreamForencoding", "testCopy_readerToOutputStreamForEncoding", "testCopy_readerToOutputStream_Integoding", "testCopy_readerToOutputStream_Encoder"], "in": ["IN", "buffer", "i", "input", "n", "inas", "id", "reading", "ini", "entry", "slice", "inner", "ins", "arin", "bin", "pass", "read", "is", "source", "login", "min", "inside", "r", "inc", "data", "rin", "file", "init", "rec", "or", "again", "m", "image", "io", "re", "In", "a", "url", "include", "err", "with", "inn", "win", "Reader", "din"], "reader": ["buffer", "loader", "i", "input", "her", "handler", "feed", "reading", "per", "inner", "driver", "read", "iter", "ler", "er", "source", "ra", "oder", "ner", "r", "parser", "file", "rar", "x", "rr", "or", "rer", "io", "writer", "iner", "rx", "pointer", "worker", "stream", "b", "ink", "Reader"], "baout": ["Baout", "daout", "baparent", "vain", "waOut", "dain", "BaOut", "waout", "aain", "vaOut", "waoutput", "vaout", "vaparent", "BAin", "daOut", "abaOUT", "daOUT", "aaOut", "Baparent", "baoutput", "BAparent", "BAOUT", "BAOut", "baOut", "aaoutput", "bain", "Bain", "wain", "abain", "aaout", "abaout", "abaOut", "baOUT", "BAoutput", "BAout"], "out": ["base", "buffer", "inas", "server", "output", "user", "builder", "ref", "OUT", "inner", "outs", "o", "pool", "line", "write", "arr", "client", "cache", "lib", "up", "inc", "parent", "file", "object", "null", "again", "exec", "Out", "image", "writer", "io", "to", "array", "ext", "obj", "err", "with"], "bytes": ["zip", "string", "css", "output", "pages", "pieces", "tes", "ns", "comments", "android", "les", "outs", "bs", "reads", "content", "parts", "items", "ies", "its", "binary", "lines", "blocks", "strings", "bps", "data", "classes", "body", "text", "objects", "ips", "size", "es", "null", "Bytes", "ls", "ones", "seconds", "cells", "rows", "values", "files", "ipes", "units", "os", "bits", "odes", "codes"]}}
{"id1": "2198730", "id2": "11933797", "code1": "    public void importCSV(InputStream csvfile) throws Exception {\n        try {\n            String[] qmarks = new String[columns.length];\n            for (int i = 0; i < qmarks.length; i++) {\n                qmarks[i] = \"?\";\n            }\n            if (cleartable) {\n                String delsql = \"delete from \" + table;\n                Statement delstm = conn.createStatement();\n                delstm.executeUpdate(delsql);\n            }\n            String sql = \"insert into \" + table + \" (\" + StringUtils.join(columns, \", \") + \") values (\" + StringUtils.join(qmarks, \", \") + \")\";\n            log.debug(\"SQL: \" + sql);\n            PreparedStatement stm = conn.prepareStatement(sql);\n            int datatypes[] = new int[columns.length];\n            for (int i = 0; i < columns.length; i++) {\n                Table tbl = project.getTableByName(table);\n                if (tbl == null) throw new OntopiaRuntimeException(\"Unknown table: \" + table);\n                Column col = tbl.getColumnByName(columns[i]);\n                if (col == null) throw new OntopiaRuntimeException(\"Unknown table column: \" + columns[i]);\n                if (col.getType() == null) throw new OntopiaRuntimeException(\"Column type is null: \" + col.getType());\n                DataType datatype = project.getDataTypeByName(col.getType(), \"generic\");\n                if (datatype == null) throw new OntopiaRuntimeException(\"Unknown column type: \" + col.getType());\n                String dtype = datatype.getType();\n                if (\"varchar\".equals(dtype)) datatypes[i] = Types.VARCHAR; else if (\"integer\".equals(dtype)) datatypes[i] = Types.INTEGER; else throw new OntopiaRuntimeException(\"Unknown datatype: \" + dtype);\n            }\n            LineNumberReader reader = new LineNumberReader(new InputStreamReader(csvfile));\n            for (int i = 0; i < ignorelines; i++) {\n                String line = reader.readLine();\n                if (line == null) break;\n            }\n            log.debug(\"[\" + StringUtils.join(columns, \", \") + \"]\");\n            int lineno = 0;\n            while (true) {\n                lineno++;\n                String line = reader.readLine();\n                if (line == null) break;\n                try {\n                    String[] cols = StringUtils.split(line, separator);\n                    if (cols.length > columns.length && !ignorecolumns) log.debug(\"Ignoring columns: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    log.debug(\"CVALUES: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    String dmesg = \"(\";\n                    for (int i = 0; i < columns.length; i++) {\n                        String col = cols[i];\n                        if (stripquotes) {\n                            int len = col.length();\n                            if (len > 1 && ((col.charAt(0) == '\"' && col.charAt(len - 1) == '\"') || (col.charAt(0) == '\\'' && col.charAt(len - 1) == '\\''))) col = col.substring(1, len - 1);\n                        }\n                        if (col != null && col.equals(\"\")) col = null;\n                        dmesg = dmesg + col;\n                        if (i < columns.length - 1) dmesg = dmesg + \", \";\n                        stm.setObject(i + 1, col, datatypes[i]);\n                    }\n                    dmesg = dmesg + \")\";\n                    log.debug(dmesg);\n                    stm.execute();\n                } catch (Exception e) {\n                    conn.rollback();\n                    throw new OntopiaRuntimeException(\"Cannot read line \" + lineno + \": '\" + line + \"'\", e);\n                }\n            }\n            conn.commit();\n        } finally {\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"importCSV": [" importDSVP", " importCSW", "importWSV", "importCSVP", "importTSF", " importDSF", "importTSV", " importDSV", "importCSF", "importDSW", "importWSW", " importCSVP", " importCSF", "importWSVP", "importWSF", "importTSW", "importTSVP", "importDSF", " importDSW", "importDSV", "importDSVP", "importCSW"], "csvfile": ["summaryfile", "csvfilename", "csvstream", "summarystream", "svFile", "summarycache", "csvcache", "svfiles", "sqlstream", "svfile", "svfilename", "jsonfile", "seriesFile", "csvFile", "seriesfilename", "tablefilename", "jsonstream", "jsonFile", "sqlfile", "tableFile", "jsoncache", "sqlcache", "tablefile", "sqlFile", "csvfiles", "summaryFile", "seriesfile", "seriesfiles", "tablefiles"], "qmarks": ["qumarked", "sqboxes", "querymarks", "quapes", "qmarked", "sqmark", " qmarked", "Qmarks", "qumark", "karks", " qmares", "qumares", "sqmarks", "kapes", "Qarks", "qapes", "kmarked", "quarks", "quboxes", " qmark", "sqmarked", "qmares", " qboxes", "kmarks", "qmark", "Qapes", " qapes", "querymarked", " qarks", "qumarks", "qarks", "querymares", "queryarks", "Qmark", "qboxes"], "i": ["index", "info", "id", "n", "pi", "uri", "mu", "ini", "ie", "yi", "slice", "c", "inner", "j", "fi", "ri", "o", "z", "ind", "si", "ui", "ii", "key", "qi", "vi", "ti", "ji", "d", "lc", "phi", "diff", "chi", "g", "my", "li", "ip", "mi", "h", "p", "bi", "u", "init", "oi", "ai", "dim", "ci", "I", "e", "m", "io", "eni", "uni", "it", "xi", "gi", "di", "ix", "hi", "a", "v", "y", "ni", "b", "iu", "multi", "f", "cli", "ik"], "delsql": ["Delsif", "diffssql", "Dersquad", "DelsQL", "delsquad", "dersquad", "dalsearch", "delsif", "dersql", "dalesearch", "delssql", "dillesQL", "dalsql", "Delql", "delsearch", "Delsql", "Dersql", "DelQL", "delsQL", "Dersearch", "dalssql", "dersearch", "delif", "dillesif", "diffsql", "Delsearch", "derssql", "Delssql", "diffsif", "dalesquad", "dalesql", "delQL", "dillessql", "diffsQL", "Delif", "dalessql", "delql", "Delsquad", "dalsquad", "dillesql", "Derssql"], "delstm": ["delndr", "delndem", "delStms", "delstrmt", "delndmt", "delStv", "delctms", "delctr", "delndm", "delstv", "delStr", "delctv", "delndv", "updateistr", "delstrem", "delistr", "elndms", "updatestem", "delStm", "elstms", "elstr", "updateistm", "updateistmt", "updatestm", "updateistem", "elndr", "delistmt", "delistem", "delstrm", "delstms", "updatestmt", "elstv", "delstrr", "updatestr", "elndv", "delndms", "delistm", "elstm", "delstem", "elndm", "delstr", "delstmt", "delctm"], "sql": ["zip", "string", "ssl", "json", "table", "rel", "join", "fn", "sol", "shell", "lua", " SQL", "query", "database", "util", "csv", "dl", "params", "select", "sync", "expression", "stat", "sb", "seed", "sv", "eps", "ql", "section", "text", "body", "vals", "nl", "log", "sq", "conn", "init", "ls", "exec", "function", "db", "sl", "details", "url", "comment", "SQL", "general", "printf", "statement", "script", "repl", "pg", "install"], "stm": ["STM", "ntm", "ntM", "stmt", "STp", " stp", "ntmt", " stM", "STm", "stM", "STmt", " stmt", "ntp", "stp"], "datatypes": [" datattypes", "datetops", "datATypes", "datatpes", "datATpes", "datattops", "datATtypes", "DatATpes", "datetypes", " datetypes", "datetype", "datantpes", " datetype", "Datatypes", " datetpes", "DatATtypes", "datetpes", "datantype", "datatttypes", " datatops", " datatpes", "DatAType", "Datatpes", "datetapes", "datattapes", "datantops", " datetapes", "Datatype", "datettypes", "datantapes", " datettypes", "datanttypes", "datantypes", " datetops", "datAType", "Datattypes", "datatops", " datatapes", "datatapes", "DatATypes", "datattypes"], "tbl": ["bll", " tdb", "ltla", " tpl", " tll", "dtll", "bbal", "Tdb", "cpl", "dtld", "tBL", "tpl", "Tpl", "tdb", "tll", "ltll", "Tla", "dtbal", "Tll", "Tbl", "dtbl", "ktll", "tbs", " tbs", "tla", "ltbl", "Tbs", "ktbl", "ktbal", "TBL", "bbl", "bld", "ltBL", "tld", "cdb", "cbs", "ktld", " tla", "cbl", "tbal", " tBL"], "col": ["val", "sel", "cur", "cf", "enc", "con", "c", "cont", "fc", "table", "loc", "ctrl", "il", "act", "Col", "COL", "co", "cal", "dc", "el", "Column", "key", "fl", "comp", "flo", "part", "fact", "cp", "cop", "tab", "cond", "lib", "ct", "not", "cat", "ch", "collection", "parent", "crit", "file", "ca", "cl", "p", "row", "conn", "coll", "cr", "db", "bl", "count", "block", "ol", "f", "field", "column", "cell"], "datatype": ["datantime", " datatope", " datacype", "datATypes", "metatource", "metarource", "datetime", " datactype", "datasypes", "datetypes", "datasype", " datacope", " datetypes", "datacope", "datetype", "datanttype", "datATource", " datetype", "metattype", "datarource", "datATime", " datacypes", "datantype", "metartype", "datasope", " datattype", "datettype", "datatource", "metarype", "datattype", "datetope", "datatime", "datacype", " datatime", " datettype", "datarype", "datarypes", "datetource", "datastype", "datantypes", "metarypes", "datartype", "datAType", "datATtype", "metatypes", "datatope", "datacypes", "metatype", " datetime", "datactype"], "dtype": ["dtyp", "ldype", " dspace", "dspace", "dtypes", "jtyp", " dype", "adtypes", "dlvar", "dype", "dstyle", "ctype", "Dype", "dltype", "ldvar", "dpe", "cstyle", "clike", " dType", "ldtype", "jype", "adType", " dlike", "Dpe", "dlype", "udtypes", "ldlink", "ldtypes", "jtype", "dlike", "dlspace", "udlink", " dpe", "dType", "adlike", "adtype", "udtype", "dvar", "adstyle", " dstyle", "Dtype", " dtyp", "Dtyp", "ldstyle", "ldspace", "udstyle", "adlink", " dvar", "cType", "dlink", "jpe"], "reader": ["info", "handler", "buffer", "input", "reading", "df", "report", "instance", "l", "fr", "read", "in", "iter", "er", " readers", "r", "parser", "data", "object", "row", "rr", "e", "io", "writer", "array", "stream", "f", "Reader"], "line": ["letter", "string", "base", "entry", "LINE", "character", "number", "l", "type", "lines", "level", "file", "page", "object", "inline", "style", "name", "header", "word", "link", "ln", "comment", "Line", "lin", "block", "error", "cell"]}}
{"id1": "21488518", "id2": "18613870", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"createNew": ["openOpen", "openCopy", "createResource", "createCopy", "resourceNew", "openNew", "openResource", "newOpen", "resourceOpen", "newCopy", "createOpen", "resourceCopy", "newResource", "newNew", "resourceResource"], "name": ["directory", "anc", "path", "string", "address", "NAME", "class", "base", "non", "id", "n", "resource", "username", "self", "on", "filename", "current", "end", "number", "large", "code", "ame", "ui", "time", "key", "content", "client", "part", "type", "one", "no", "member", "value", "connection", "common", "model", "old", "default", "alias", "parent", "names", "file", "data", "none", "size", "x", "search", "style", "title", "Name", "folder", "image", "e", "label", "word", "full", "prefix", "url", "ext", "comment", "missing", "office", "named", "ename", "ix"], "in": ["IN", "buffer", "i", "input", "id", "resource", "plus", "ini", "slice", "con", "inner", "ins", "record", "bin", "pass", "read", "raw", "source", "reader", "thin", "up", "connection", "login", "len", "diff", "inc", "work", "data", "file", "src", "size", "init", "exec", "image", "In", "win", "din"], "length": ["path", "buffer", "duration", "id", "timeout", "sequence", "filename", "number", "limit", "line", "time", "offset", "content", "password", "type", "load", "len", "Length", "level", "body", "size", "bytes", "url", "ength", "count", "padding", "width"], "contentType": ["contenttype", "contentLength", " contentLength", "ContentType", "resourceType", "resourcetype", "contentPath", " contentPath", " contenttype", "resourceLength", "ContentPath", "ContentLength", "resourcePath", "Contenttype"], "dest": ["zip", "temp", "output", "cont", "result", "later", "destroy", "done", "trans", "dc", "txt", "comb", "cdn", "source", "d", "thin", "wb", "dir", "target", "dist", "upload", "store", "config", "parent", "flat", "src", "route", "Dest", "tmp", "de", "tif", "folder", "desc", "gz", "home", "opt", "sup", "conf", "prop", " destination", "trip", "tx", "transform", "orig", "img"], "out": ["zip", "path", "buffer", "temp", "ex", "output", "copy", "resource", "server", "lock", "OUT", "socket", "result", "outs", "o", "pool", "line", "bin", "password", "client", "sync", "source", "cache", "up", "connection", "parent", "data", "file", "channel", "page", "object", "log", "null", "conn", "again", "exec", "Out", "io", "image", "writer", "exp", "gz", "flush", "ext", "url", "obj", "err", "f", "cmd", "this", "view", "img"], "request": ["directory", "remote", "path", "base", "buffer", "job", "input", "Request", "resource", "claim", "response", "user", "report", "project", "forward", "instance", "child", "query", "req", "friend", "client", "rate", "type", "use", "respect", "upload", "store", "config", "open", "route", "get", "object", "complete", "rer", "QUEST", "quest", "call", "access", "url", "ext", "pe", "reference", "xml", "transfer", "wheel", "re", "external"]}}
{"id1": "8132219", "id2": "19335986", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "inFile": ["inputPlace", " inSourceFile", "InSourceFile", "INfile", "binfile", "outPlace", "inputfile", "outfile", " infile", "infile", "inputFile", "outFiles", "InFilename", " inFilename", "Infile", "inFiles", "inPlace", "inputFiles", "binFiles", "binFile", "INFile", "binPlace", "InFile", "INSourceFile", "inFilename", "inSourceFile", "INFilename"], "outFile": ["againFilename", "outputFilename", "outputfile", "againFile", " outfile", "outPlace", "outfile", "infile", "outFiles", "outputPlace", " outFilename", "inFiles", "againfile", " outFiles", "outputFiles", "againPlace", "outFilename", "inFilename", "outputFile", " outPlace"], "in": ["IN", "index", "pin", "base", "i", "input", "id", "n", "ini", "ic", "c", "inner", "as", "ins", "bin", "is", "part", "like", "reader", "source", "connection", "inc", "work", "data", "file", "config", "rin", "x", "name", "again", "m", "image", "io", "In", "a", "url", "inn", "f", "din"], "out": ["string", "buffer", "ex", "output", "n", "copy", "resource", "user", "Output", "plain", "c", "OUT", "version", "o", "outs", "write", "line", "bin", "client", "part", "cache", "dot", "default", "w", "data", "file", "x", "p", "log", "null", "conn", "name", "exec", "Out", "io", "image", "writer", "to", "call", "prefix", "ext", "v", "b", "obj", "external"], "inChannel": ["sinSocket", "INSocket", "inSocket", "inputChannel", "INchannel", "iniChannel", "inStream", " inFlow", " inchannel", "inputchannel", "inchannel", "INFlow", "sinChannel", "inLanguage", "sinChan", "iniLanguage", "winLanguage", "inputChan", "iniStream", "INChan", "outStream", "outchannel", "outChan", "inChan", "inputStream", "inichannel", "outConnection", "INStream", "winChannel", "winchannel", " inConnection", "INChannel", "inConnection", " inChan", "winStream", "sinFlow", " inSocket", "inFlow", "INConnection", "outLanguage"], "outChannel": [" outContext", "OutStream", "againChannel", "OutConnection", "OutChannel", "inchannel", "outContext", " outConnection", "againPath", "againChan", "OutChan", "outStream", "outchannel", "inPath", "outChan", "inChan", "outPath", "OutContext", "outputchannel", "outputChannel", " outPath", "outConnection", "newStream", "Outchannel", "newChan", "againchannel", "outputChan", "inConnection", " outStream", "newContext", "newChannel", " outchannel", " outChan"]}}
{"id1": "12417893", "id2": "16557837", "code1": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "code2": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "label": 0, "substitutes": {"download": ["zip", "remote", "resource", "output", "copy", "report", "Download", "find", "patch", "write", "client", "load", "upload", "open", "data", "file", "archive", "request", "get", "delete", "submit", "call", "pull", "url", "update", "create", "transfer"], "uri": ["directory", "path", "remote", "base", "address", "doi", "i", "id", "response", "resource", "server", "absolute", "pi", "http", "ri", " URI", "location", "query", "ui", "database", "req", "next", "qi", "client", "source", "connection", "data", "file", "route", "request", "nil", "href", "uni", "name", "ris", "io", "eni", "iri", "url", "future", "state", "cli", "URI", "service", "api"], "httpGet": ["httpsDo", " httpDo", "phpget", "Httpget", "HttpGET", " httpGET", "httpDo", " httpClient", "fCall", " httpCall", "httpGET", "httpClient", "httpsSet", "HttpSet", " httpSet", " httpget", "HttpDo", "httpsClient", "webGet", "fget", "webget", "httpCall", "HttpClient", "webClient", "httpSet", "httpget", "fGET", "httpsGet", "phpGet", "phpResponse", "HttpGet", "HttpCall", "webResponse", "fGet", "phpClient"], "httpResponse": ["baseClient", "httpsResp", "HTTPResponse", "HttpResp", "HTTPResp", "HTTPStatus", " httpresponse", " httpClient", " httpResp", "httpResp", "httpReply", "httpClient", "httpsResponse", "baseresponse", "httpStatus", "baseResp", " httpReply", "Httpresponse", "HttpResponse", "HttpClient", "baseResponse", "httpsStatus", " httpStatus", "httpsReply", "HTTPReply", "httpresponse"]}}
{"id1": "12236729", "id2": "11005804", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"copy": ["zip", "Copy", "replace", "cmp", "py", "clip", "php", "clone", " copying", "split", " transfer", "sync", "cop", "cp", "diff", "cat", "upload", " dup", " copied", "get", "p", "io", "dump", " Copy", "paste", "transfer", "download"], "inputFile": [" inputDir", "outputfile", "currentFiles", "inputfile", " inputfile", "sourcePath", "outputPath", "sourceFile", "inputPath", "sourceFiles", "inputDir", "currentfile", "sourcefile", "inputFiles", "currentDir", "outputFiles", "outputDir", "currentFile", " inputFiles", " inputPath"], "outputFile": ["referenceFilename", "OutputDirectory", "referenceFile", "outputFilename", "outputfile", "inputFilename", "inputfile", "referencefile", "tempDirectory", " outputDirectory", "inputDir", "OutputDir", "tempDir", " outputfile", " outputDir", "Outputfile", "outputDirectory", "tempfile", "tempFile", "outputDir", "referenceDir", " outputFilename", "OutputFile"], "in": ["IN", "sin", "pin", "i", "input", "id", "n", "ini", "lock", "gin", "into", "con", "inner", "socket", "as", "l", "ins", "s", "bin", "read", "is", "reader", "source", "up", "login", "connection", "min", "inside", "r", "inc", "file", "get", "init", "conn", "again", "e", "image", "In", "nin", "kin", "ln", "a", "pull", "lin", "err", "cin", "inn", "f", "win", "din"], "out": ["i", "temp", "ex", "output", "n", "outer", "plus", "net", "plain", "OUT", "socket", "outs", "o", "write", "off", "bin", "line", "extra", "outside", "post", "sync", "at", "one", "cache", "up", "w", "inc", "parent", "file", "log", "null", "conn", "again", "exec", "Out", "writer", "io", "over", "b", "err", "v", "obj", "error"], "c": ["cu", "i", "id", "n", "cc", "sc", "cf", "rc", "character", "fc", "o", "col", "l", "line", "char", "ec", "cm", "d", "ce", "uc", "lc", "ct", "r", "ch", "cy", "cl", "xc", "x", "p", "cd", "C", "u", "ci", "m", "e", "cr", "pointer", "esc", "pc", "a", "k", "b", "v", "count", "f", "code"]}}
{"id1": "12128591", "id2": "20208819", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["sum", "copy", "add", " Hash", "hex", " hashing", "Hash", "component", "str", "build", "text", "check", "h", "get", "log", "pack", "dump", "update", "parse", "SHA", " hashes", "print", " fingerprint", "crypt", "code"], "data": ["string", "info", "address", "buffer", "class", "input", "base", "output", "response", "message", "result", "hex", "s", "length", "memory", "database", "in", "alpha", "content", "source", "cache", "value", "media", "connection", "str", "DATA", "text", "body", "p", "style", "format", "name", "template", "image", "bytes", "a", "missing", "padding", "pad", "dat", "api"], "digest": ["Digester", "signester", "DigEST", "Diger", "mdast", "signEST", "signest", "signusher", "bigest", "peder", "generester", "decest", " diger", "decit", "digit", " digusher", "generests", "logenge", "logester", " dige", "mdest", " digger", "pede", "digester", "digests", "mdester", "Digenge", "digger", "decester", "Digest", "decests", "mdenge", "bigusher", "Digusher", "digusher", "diger", "digenge", "pedester", " digEST", " digester", "bigester", "Digger", " digests", "Digast", "dige", "generit", "generest", "pedest", "digast", " digit", "logest", "logast", "Dige", "digEST", "bigger"]}}
{"id1": "12197169", "id2": "14053882", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"read": ["Read", "replace", "reading", "continue", "report", "end", "run", "write", "ready", "loop", "reader", "load", "open", "work", "check", "request", "get", "init", "start", "readable", "stream", "parse", "create", "println", "print", "process", "download"], "in": ["IN", "path", "info", "ssl", "buffer", "input", "server", "id", "n", "token", "ex", "ini", "by", "on", "con", "c", "inner", "o", "l", "ins", "s", "fr", "bin", "is", "er", "cms", "at", "reader", "source", "doc", "login", "min", "connection", "r", "inc", "data", "file", "out", "log", "conn", "again", "e", "io", "image", "ing", "isin", "it", "In", "nin", "a", "url", "index", "of", "stream", "b", "err", "scan", "inn", "f", "error", "din", "from"], "line": ["val", "string", "buffer", "id", "lf", "entry", "LINE", "message", "ge", "end", "se", "col", "l", "el", "record", "ine", "key", "source", "reader", "lines", "lc", "value", "str", "data", "file", "text", "page", "le", "object", "log", "row", "inline", "ne", "name", "e", "frame", "status", "link", "sl", "url", "unit", "comment", "lin", "Line", "b", "parse", "block", "f", "L", "code", "cell"], "i": ["index", "info", "n", "pi", "ini", "ie", "slice", "j", "fi", "ri", "o", "l", "si", "ui", "is", "ii", "ori", "qi", "ti", "phi", "li", "ip", "x", "p", "bi", "u", "oi", "ai", "uni", "ci", "I", "io", "e", "eni", "zi", "ski", "xi", "gi", "di", "b", "ni", "abi", "f", "ix"], "logDatum": ["exDData", "logdum", "logDictionary", "logDum", "exDictionary", "Logdict", "logDatatum", "logDsatum", "logFam", "exDDam", "Logdata", "LogData", "exData", "logFatum", "Logdatum", "logDData", "logData", "logdict", "logdatum", "logDsict", "LogDatum", "Logdum", "logDict", "logDam", "logdata", "logDatictionary", "LogDict", "logDsata", "logDDam", "exDam", "logDDictionary", "exDDictionary", "logFictionary", "LogDum", "logDDatum", "logDatata", "logDatict", "logDsum", "logFata", "exDDatum", "logDatam", "exDatum"]}}
{"id1": "20028790", "id2": "823074", "code1": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"setBundleInfoName": ["setBundleIdDefault", "setBundleDirList", "setBindingIdList", "setBundleIdList", "setBundleInfoPart", "setBundleInformationDefault", "setBundleInformationName", "setBindingIdName", "setBindingIdPart", "setBundleIdName", "setBindingInfoDefault", "setBundleInformationPart", "setBindingInfoName", "setBindingInfoPart", "setBundleIdPart", "setBundleDirName", "setBindingInfoList", "setBundleInfoDefault", "setBundleDirDefault", "setBundleInformationList", "setBundleInfoList", "setBindingIdDefault", "setBundleDirPart"], "location": ["directory", "path", "string", "address", "node", "loader", "remote", "base", "server", "uri", "resource", "site", "message", "filename", "description", "library", "l", "URL", "layout", "database", "content", "type", "data", "file", "region", "language", "href", "selection", "folder", "station", "link", "area", "LOC", "position", "localhost", "Location", "xml", "point", "loc"], "list": ["string", "i", "entry", "sequence", "table", "result", "later", "l", "set", "all", "record", "detail", "queue", "there", "LIST", "part", "load", "the", "see", "group", "collection", "listed", "data", "li", "parent", "cl", "object", "keep", "cli", "lists", "name", "coll", "tree", "chain", "array", "mentioned", "pair", "we", "range", "stack", "batch"], "url": ["string", "base", "buffer", "ssl", "address", "server", "uri", "resource", "user", "http", "socket", "lr", "l", "URL", "fr", "orb", "reader", "source", "jar", "browser", "connection", "r", "open", "data", "file", "bel", "bb", "io", "sl", "service", "Url", "stream", "b", "err", "f", "plug", "org", "loc"], "br": ["i", "bh", "res", "bridge", "result", "fr", "mr", "dr", "bro", "ler", "arr", "er", "BR", "bar", "rb", "reader", "jar", "browser", "buf", "r", "ch", "Br", "str", "ar", "data", "ob", "body", "bb", "gr", "brush", "io", "yr", "cr", "tr", "bc", "stream", "hr", "b", "bl", "err", "sp", "obj", "ber", "handle", "sr", "img"], "line": ["letter", "string", "zip", "lo", "job", "non", "lf", "response", "lock", "entry", "LINE", "character", "phase", "result", "band", "lr", "l", "shell", "look", "pass", "split", "sync", "part", "source", "rule", "lines", "lc", "up", "connection", "str", "license", "section", "data", "text", "file", "cl", "page", "le", "nl", "log", "row", "inline", "style", "name", "header", "e", "status", "word", "link", "strip", "parse", "Line", "lin", "b", "block", "error", "code", "cell"], "pos1": ["part1", "position0", " posOne", "pos3", "indexOne", "position3", "PosN", "part3", "index2", "pos2", "index0", "position2", "Pos3", "posOne", "POSOne", "position1", "positionOne", "POS3", " pos3", "Pos0", "index1", "POS1", "POSN", " posN", "Pos2", "pos0", "PosOne", " pos2", "part2", "posN", "Pos1"], "bundleSymbolicName": ["bundleSymbigiousString", "bundleSysembuousName", "bundleSymbolicKey", "bundleSymbriticalUrl", "bundleSymbicalPart", "bundleSymbicallyName", "bundleSymbicModule", "bundleSymbicalPath", "bundleSyMBolicName", "bundleSymbriticalname", "bundleSysembuousname", "bundleSymbuousUrl", "bundleSymbriticalWord", "bundleSyMBolicPart", "bundleSymbicalString", "bundleSymbigiousPath", "bundleSymbigiousPart", "bundleSymbuousName", "bundleSysembolicUrl", "bundleSymbularPart", "bundleSymbolicString", "bundleSymbolicPart", "bundleSyembolicModule", "bundleSymbolicInfo", "bundleSyMBolicPath", "bundleSymbicKey", "bundleSymbolicWord", "bundleSymbicalKey", "bundleSyMBolicString", "bundleSymbicalInfo", "bundleSyMBicalName", "bundleSymbillyName", "bundleSyMBicalString", "bundleSymbicName", "bundleSymbicalName", "bundleSyMBicalPath", "bundleSymbigiousName", "bundleSymbillyInfo", "bundleSymbolicname", "bundleSymbularName", "bundleSyembicKey", "bundleSyembolicName", "bundleSymbuousWord", "bundleSymbicalModule", "bundleSysembolicName", "bundleSyembolicKey", "bundleSyMBicalPart", "bundleSysembuousUrl", "bundleSymbularString", "bundleSymbuousname", "bundleSysembuousWord", "bundleSymbillyKey", "bundleSymbolicPath", "bundleSymbicallyUrl", "bundleSymbillyModule", "bundleSyembicName", "bundleSyembicModule", "bundleSysembolicname", "bundleSymbolicUrl", "bundleSymbicallyWord", "bundleSymbicallyname", "bundleSyembicInfo", "bundleSymbicInfo", "bundleSymbolicModule", "bundleSyembolicInfo", "bundleSymbularPath", "bundleSysembolicWord", "bundleSymbriticalName"], "bundleName": ["baffleInfo", "BundleID", "babiInfo", "bpackageInfo", "babiName", "boodleInfo", "bpackagename", "babiDesc", "bpluginType", "bundleType", "bendorInfo", "boodlename", "BundleName", "bridgeName", "bendorID", "rbpluginType", "bblname", "bridgeDesc", "bpluginname", "rbundleType", "bafflename", "BpackageName", "BpackageInfo", "bpackageDesc", "babiname", "bendorName", "Bpackagename", "bpluginName", "bundlename", "bundleDesc", "bendorname", "baffleName", "rbpluginname", "bblID", "bundleID", "bblInfo", "baffleType", "boodleID", "BendorInfo", "rbundleName", "bridgeInfo", "BendorName", "rbpluginInfo", "BendorID", "rbpluginName", "BundleInfo", "Bundlename", "bpackageName", "BundleDesc", "bundleInfo", "bblName", "bridgename", "boodleName", "BpackageDesc", "rbundlename", "bpluginInfo", "rbundleInfo", "bendorType", "Bendorname"], "info": ["index", "string", "base", "zip", "handler", "i", "id", "op", "entry", "by", "py", "end", "result", "api", "child", "fw", "off", "extra", "key", "next", "part", "filter", "type", "inf", "diff", "alias", "data", "file", "ignore", "li", "check", "archive", "object", "INFO", "name", "start", "fo", "image", "available", "link", "gi", "of", "bug", "comment", "parse", "b", "obj", "Info", "def", "tf", "f", "error"]}}
{"id1": "19322946", "id2": "9327525", "code1": "    @Test\n    public void test_lookupType_FullSearch_MatchingWordInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupType/cluster\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":29055,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":29056,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29065,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":29066,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29069,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":29070,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29095,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":29096,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":21013,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Sensor Cluster\\\",\\\"icon\\\":\\\"54_03\\\"},{\\\"itemTypeID\\\":21014,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":32241,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Drive Cluster EDF-285\\\",\\\"icon\\\":\\\"24_11\\\"},{\\\"itemTypeID\\\":5279,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"F-23 Reciprocal Sensor Cluster Link\\\",\\\"icon\\\":\\\"03_09\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11534,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":17340,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11536,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":17333,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11535,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":17345,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6218,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6222,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected LADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6226,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6230,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Multi-Frequency Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6234,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected RADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":7895,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7893,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7914,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7896,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Omni Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7892,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Radar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11537,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":17336,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Gravimetric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6241,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed LADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Magnetometric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6239,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Multi-Frequency Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6225,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed RADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":20238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20244,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20250,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20260,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20240,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20246,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20252,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20262,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":21722,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Sleeper Nanite Cluster\\\",\\\"icon\\\":\\\"55_15\\\"},{\\\"itemTypeID\\\":20242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20248,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20254,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20264,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "code2": "    @Test\n    public void test02_ok() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(chartURL);\n            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);\n            nameValuePairs.add(new BasicNameValuePair(\"ws\", \"getDomainEvolution\"));\n            nameValuePairs.add(new BasicNameValuePair(\"chartTitle\", \"test\"));\n            nameValuePairs.add(new BasicNameValuePair(\"type\", \"chart\"));\n            nameValuePairs.add(new BasicNameValuePair(\"firstDate\", \"20111124\"));\n            nameValuePairs.add(new BasicNameValuePair(\"lastDate\", \"20111125\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParams\", \"type,counting,protocol,unit,proxy,domain,timeScale,period\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParamsValues\", \"chart,volume,all,hits,all,google.com,day,360\"));\n            nameValuePairs.add(new BasicNameValuePair(\"serieTitle\", \"serie\"));\n            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            assertNotNull(entity);\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));\n            System.out.println(reader.readLine());\n            instream.close();\n            assertEquals(\"error :\" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"test_lookupType_FullSearch_MatchingWordInMiddle": ["test_lookupType_FullSearch_MackingMessage", "test_lookupType_FullSearch_MiningWord", "test_lookupType_FullSearch_MoringWords", "test_lookupType_FullSearch_mackingWords", "test_lookupType_FullSearch_MiningMessage", "test_lookupType_FullSearch_MiningWords", "test_lookupType_FullSearch_MatchingMessage", "test_lookupType_FullSearch_MoringWord", "test_lookupType_FullSearch_matchingWord", "test_lookupType_FullSearch_matchingMessage", "test_lookupType_FullSearch_MackingWords", "test_lookupType_FullSearch_mackingWord", "test_lookupType_FullSearch_MatchingWords", "test_lookupType_FullSearch_MoringMessage", "test_lookupType_FullSearch_MackingWord", "test_lookupType_FullSearch_MatchingWord", "test_lookupType_FullSearch_mackingMessage", "test_lookupType_FullSearch_matchingWords"], "url": ["string", "path", "address", "ssl", "server", "uri", "response", "resource", "feed", "user", "entry", "http", "document", "system", "result", "l", "location", "URL", "relation", "client", "twitter", "org", "config", "file", "channel", "https", "text", "web", "object", "page", "context", "conn", "image", "link", "sl", "Url", "position", "bug", "b", "contact", "method", "service", "api"], "connection": ["directory", "Connection", "translation", "handler", "server", "resource", "response", "uri", "builder", "entry", "http", "document", "character", "c", "communication", "j", "socket", "result", "connected", "number", "inner", "con", "driver", "relation", "database", "condition", "password", "client", "session", "use", "proxy", "ion", "component", "which", "application", "collection", "section", "config", "open", "text", "channel", "object", "log", "context", "conn", "or", "image", "function", "link", "position", "connect", "reference", "general", "network", "method", "service", "loc"]}}
{"id1": "6840241", "id2": "14865947", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"copy": ["mop", "server", "Copy", "cmp", "slave", "system", "clip", "write", "clone", "loop", "sync", "cop", "type", "load", "cover", "proxy", "open", "share", "ip", "size", "io", "image", "create", "process", "opy", "transfer", "download"], "source": ["sin", "address", "handler", "i", "input", "server", "resource", "Source", "ie", "slice", "slave", "inner", "result", "se", "si", "ources", "SOURCE", "iter", "session", "use", "reader", "proxy", "seed", "connection", "target", "parent", "data", "channel", "src", "size", "iterator", "null", "start", "e", "image", "this", "stream", "sp", "wrapper", "rice", "ink", "ource", "service", "from"], "sink": ["outsigh", "Sinker", "Source", "pinker", "dsinker", "outsinker", "asink", "dsource", "partsINK", "pink", "sider", "tource", "asigh", "SINK", "pource", "tink", "outsink", "Sink", "outsource", "sinker", "tider", "partsource", "sINK", " sinker", "pINK", "asinker", " sigh", "tinker", "dsink", "asource", "partsinker", "dsider", "partsink", "sigh", "pider"]}}
{"id1": "20091126", "id2": "17190057", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "label": 0, "substitutes": {"copy": ["zip", "Copy", "cmp", "output", "join", "write", "cop", "type", "cp", "source", "up", "proxy", "cat", "upload", "open", "file", "archive", "Cop", "put", "p", "exec", "io", "call", "over", "paste", "process", "transfer", "download"], "in": ["IN", "index", "base", "buffer", "i", "input", "id", "ic", "inner", "l", "ins", "bin", "query", "part", "reader", "source", "login", "min", "old", "diff", "connection", "inc", "work", "data", "file", "config", "or", "again", "name", "m", "image", "In", "a", "url", "lin", "b", "ac", "f"], "out": ["string", "base", "buffer", "temp", "i", "ex", "output", "server", "plain", "OUT", "c", "result", "outs", "o", "off", "write", "content", "source", "cache", "dot", "value", "target", "default", "parent", "data", "file", "channel", "page", "object", "x", "p", "again", "name", "exec", "Out", "image", "io", "exp", "array", "call", "prefix", "a", "url", "ext", "comment", "v", "err", "external", "point"], "inChannel": ["inputChannel", "INchannel", "iniChannel", "inStream", " inchannel", "inputchannel", " inClient", "winChan", "INGate", "inchannel", "inButton", "inputChan", "iniStream", "INChan", "INClient", "outStream", "iniChan", "outchannel", "outChan", "inChan", " inButton", "INButton", "insClient", "insStream", "inputStream", "outButton", "insChannel", "INStream", "winChannel", "winchannel", "INChannel", " inStream", "inClient", " inChan", "insChan", "winStream", "inputGate", "iniGate", "inputButton", "inGate"], "outChannel": [" outContext", "OutStream", "inStream", "outsStream", "OutChannel", "inchannel", "outContext", " outConnection", "OutChan", "outStream", "inContext", "outchannel", "outChan", "outsChan", "inChan", "outputStream", "OutContext", "OutClient", "outClient", "outputchannel", "outsChannel", "outputChannel", "outConnection", "Outchannel", "outputClient", "outputChan", "inConnection", "inClient", "outsConnection", " outStream", " outchannel", " outChan"]}}
{"id1": "5061606", "id2": "15241397", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNequessnecessary", "createSettingsIfNececarily", "createSettingsIfNecccessnecessary", "createSettingsIfNecesnecessary", "createSettingsIfNecccesseless", "createSettingsIfNecccessarily", "createSettingsIfNecessnecessary", "createSettingsIfNecesary", "createSettingsIfNequccessarily", "createSettingsIfNequccessnecessary", "createSettingsIfNecessarily", "createSettingsIfNecccessary", "createSettingsIfNeceseless", "createSettingsIfNecesseless", "createSettingsIfNequessarily", "createSettingsIfNequessary", "createSettingsIfNececnecessary", "createSettingsIfNececeless", "createSettingsIfNequesseless", "createSettingsIfNececary", "createSettingsIfNecesarily", "createSettingsIfNequccesseless", "createSettingsIfNequccessary"], "out": ["index", "path", "i", "ex", "output", "copy", "server", "editor", "user", "timeout", "by", "lock", "net", "plain", "OUT", "socket", "result", "outs", "o", "window", "pool", "write", "off", "bin", "exit", "password", "sync", "client", "at", "source", "cache", "up", "connection", "model", "group", "parent", "data", "file", "channel", "config", "page", "object", "log", "null", "conn", "init", "plugin", "again", "name", "exec", "Out", "io", "writer", "image", "array", "prefix", "a", "flush", "app", "url", "err", "obj", "cookie", "error", "this"], "fSettings": ["rfFs", "sfSetting", "FConfig", "fsettings", "fJs", " fFs", " fettings", "sfsettings", "fsConfig", " fSetting", "fFs", "FSetting", "filesettings", " fJs", "fsFs", "fileSettings", "fettings", "fsSetting", "fSetup", "rfSettings", "FSetup", " fConfig", "fmConfig", "fileettings", "FJs", " fsettings", "rfSetting", "fmSetup", "fileSetting", "Fsettings", "fsSettings", "sfJs", "FSettings", "sfettings", "fConfig", "fmSetting", "sfSettings", "fsSetup", "fSetting", "rfConfig", "fmSettings"], "src": ["path", "string", "base", "sel", "ssl", "sc", "uri", "rc", "lower", "settings", "filename", "ref", "cb", "dest", "fp", "loc", "ins", "prot", "sub", "req", "gb", "rb", "source", "sb", "uc", "ctr", "dist", "str", "config", "file", "tmp", "attr", "route", "text", "storage", "sl", "url", "stream", "ource", "b", "st", "cur", "sr", "img"], "in": ["IN", "index", "path", "sin", "i", "input", "n", "copy", "id", "ini", "gin", "con", "c", "inner", "l", "ins", "s", "bin", "source", "reader", "thin", "login", "connection", "r", "inc", "data", "file", "rin", "init", "again", "image", "In", "kin", "url", "stream", "b", "err", "inn", "f", "win", "din"]}}
{"id1": "5744493", "id2": "19810820", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": [" dofileCopy", " doFileCopy", "newBlockWrite", " doBlockCopy", " dofilecopy", " doFolderProxy", "newBlockcopy", "newFilecopy", " doFolderWrite", "newFileCopy", " dofileWrite", "newBlockProxy", " doBlockProxy", " doFoldercopy", " doFileWrite", "newFileWrite", " doFolderCopy", " dofileProxy", " doBlockcopy", " doFileProxy", "newBlockCopy", "newFileProxy", " doBlockWrite", " doFilecopy"], "in": ["IN", "index", "pin", "base", "i", "input", "id", "ex", "buffer", "lock", "c", "inner", "ins", "bin", "query", "part", "reader", "source", "login", "min", "diff", "inc", "config", "data", "file", "again", "name", "m", "image", "isin", "In", "url", "lin", "b", "err", "inn", "win"], "out": ["string", "base", "buffer", "temp", "server", "output", "copy", "ex", "resource", "user", "pre", "plain", "OUT", "socket", "o", "outs", "off", "write", "part", "source", "cache", "dot", "connection", "target", "default", "file", "page", "conn", "name", "again", "exec", "Out", "io", "writer", "image", "prefix", "ext", "v", "b", "external", "point"], "inChannel": ["binStream", "binSocket", "INSocket", "inSocket", "inputChannel", "INchannel", "inStream", " inchannel", "inputSocket", " inClient", "inchannel", "binChan", "InChan", "inputChan", "Inchannel", "INChan", "outStream", "INClient", "outchannel", "outChan", "inChan", "InChannel", "outSocket", "InStream", "inputStream", "outClient", "binChannel", "INStream", "InSocket", "INChannel", " inStream", "inClient", " inChan", " inSocket"], "outChannel": ["inSocket", "OutStream", "inStream", "againChannel", "againSocket", "intChan", " outButton", "OutChannel", "inchannel", " outContainer", "againChan", "inButton", "OutChan", " outSocket", "outStream", "outContainer", "outchannel", "againStream", "outChan", "inChan", "outSocket", "OutBuffer", "intChannel", "intchannel", "outButton", "inBuffer", "outBuffer", "intButton", " outStream", "inContainer", "OutContainer", " outBuffer", " outchannel", " outChan"], "maxCount": ["MaxLength", " maxLength", "maxcount", "MaxCount", "maxSize", "axcount", "maxLength", "maxSum", "blockCount", " maxcount", "Maxcount", "MaxSum", "MaxSize", "axCount", " maxSum", "axLength", "blockSize", " maxSize", "blockSum", "blockcount", "axSize"], "size": ["capacity", "address", "max", "sum", "fee", "n", "cap", "end", "limit", "volume", "mode", "length", "shift", "time", "en", "offset", "sized", "type", "min", "len", "seek", "data", "small", "empty", "p", "Size", "start", "name", "available", "send", "SIZE", "bytes", "position", "flush", "unit", "shape", "ize", "range", "count", "width", "scale", "transfer", "speed", "loc"], "pos": ["val", "index", "push", "address", "base", "i", "id", "spec", "pose", " position", "slice", "ref", "Pos", "rel", "limit", "o", "slot", "length", "off", "pass", "iter", "offset", "part", "no", "min", "len", "diff", "open", "data", "p", "neg", "po", "start", "port", "pointer", "pid", "position", "unit", "point", "POS", "obj", "count", "os", "block", "pt", "cos", "loc"]}}
{"id1": "10690321", "id2": "19096138", "code1": "    private static void readData() {\n        StringTokenizer sTok;\n        topSet = new HashSet();\n        sTok = new StringTokenizer(tops, \",\");\n        while (sTok.hasMoreTokens()) topSet.add(sTok.nextToken());\n        leftSet = new HashSet();\n        sTok = new StringTokenizer(lefts, \",\");\n        while (sTok.hasMoreTokens()) leftSet.add(sTok.nextToken());\n        rightSet = new HashSet();\n        sTok = new StringTokenizer(rights, \",\");\n        while (sTok.hasMoreTokens()) rightSet.add(sTok.nextToken());\n        farRightSet = new HashSet();\n        sTok = new StringTokenizer(farrights, \",\");\n        while (sTok.hasMoreTokens()) farRightSet.add(sTok.nextToken());\n        vowelSet = new HashSet();\n        sTok = new StringTokenizer(vowels, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            vowelSet.add(ntk = sTok.nextToken());\n            if (maxEwtsVowelLength < ntk.length()) maxEwtsVowelLength = ntk.length();\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        puncSet = new HashSet();\n        sTok = new StringTokenizer(others, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            puncSet.add(ntk = sTok.nextToken());\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet = new HashSet();\n        tibSet = new HashSet();\n        sTok = new StringTokenizer(tibetanConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            tibSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        sanskritStackSet = new HashSet();\n        sTok = new StringTokenizer(otherConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            sanskritStackSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        numberSet = new HashSet();\n        sTok = new StringTokenizer(numbers, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            numberSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet.add(\"Y\");\n        charSet.add(\"R\");\n        charSet.add(\"W\");\n        validInputSequences.put(\"Y\", anyOldObjectWillDo);\n        validInputSequences.put(\"R\", anyOldObjectWillDo);\n        validInputSequences.put(\"W\", anyOldObjectWillDo);\n        sTok = null;\n        top_vowels = new HashSet();\n        top_vowels.add(i_VOWEL);\n        top_vowels.add(e_VOWEL);\n        top_vowels.add(o_VOWEL);\n        top_vowels.add(ai_VOWEL);\n        top_vowels.add(au_VOWEL);\n        top_vowels.add(reverse_i_VOWEL);\n        try {\n            URL url = TibetanMachineWeb.class.getResource(fileName);\n            if (url == null) {\n                System.err.println(\"Cannot find \" + fileName + \"; aborting.\");\n                System.exit(1);\n            }\n            InputStreamReader isr = new InputStreamReader(url.openStream());\n            BufferedReader in = new BufferedReader(isr);\n            System.out.println(\"Reading Tibetan Machine Web code table \" + fileName);\n            String line;\n            boolean hashOn = false;\n            boolean isTibetan = false;\n            boolean isSanskrit = false;\n            boolean ignore = false;\n            while ((line = in.readLine()) != null) {\n                if (line.startsWith(\"<?\")) {\n                    if (line.equalsIgnoreCase(\"<?Consonants?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Other?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Input:Punctuation?>\") || line.equalsIgnoreCase(\"<?Input:Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Tibetan?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Sanskrit?>\")) {\n                        isSanskrit = true;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?ToWylie?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Ignore?>\")) {\n                        isSanskrit = false;\n                        ignore = true;\n                    }\n                } else if (line.startsWith(\"//\")) {\n                    ;\n                } else if (line.equals(\"\")) {\n                    ;\n                } else {\n                    StringTokenizer st = new StringTokenizer(line, DELIMITER, true);\n                    String wylie = null;\n                    DuffCode[] duffCodes;\n                    duffCodes = new DuffCode[11];\n                    int k = 0;\n                    StringBuffer escapedToken = new StringBuffer(\"\");\n                    ThdlDebug.verify(escapedToken.length() == 0);\n                    while (st.hasMoreTokens()) {\n                        String val = getEscapedToken(st, escapedToken);\n                        if (val.equals(DELIMITER) && escapedToken.length() == 0) {\n                            k++;\n                        } else if (!val.equals(\"\")) {\n                            if (escapedToken.length() != 0) {\n                                escapedToken = new StringBuffer(\"\");\n                                ThdlDebug.verify(escapedToken.length() == 0);\n                            }\n                            switch(k) {\n                                case 0:\n                                    wylie = val;\n                                    break;\n                                case 1:\n                                    duffCodes[TM] = new DuffCode(val, false);\n                                    break;\n                                case 2:\n                                    if (!ignore) {\n                                        duffCodes[REDUCED_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 3:\n                                    duffCodes[TMW] = new DuffCode(val, true);\n                                    if (null != duffCodes[TM]) {\n                                        TMtoTMW[duffCodes[TM].getFontNum() - 1][duffCodes[TM].getCharNum() - 32] = duffCodes[TMW];\n                                    }\n                                    if (null != TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32]) throw new Error(\"tibwn.ini is supposed to use the TibetanMachineWeb glyph as the unique key, but \" + val + \" appears two or more times.\");\n                                    TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = duffCodes[TM];\n                                    if (wylie.toLowerCase().startsWith(\"\\\\uf0\")) {\n                                        int x = Integer.parseInt(wylie.substring(\"\\\\u\".length()), 16);\n                                        ThdlDebug.verify((x >= 0xF000 && x <= 0xF0FF));\n                                        NonUnicodeToTMW[x - '\uf000'] = new DuffCode[] { duffCodes[TMW] };\n                                    }\n                                    break;\n                                case 4:\n                                case 5:\n                                case 6:\n                                case 7:\n                                case 8:\n                                case 9:\n                                    if (!ignore) {\n                                        try {\n                                            duffCodes[k - 1] = new DuffCode(val, true);\n                                        } catch (Exception e) {\n                                            System.err.println(\"Couldn't make a DuffCode out of \" + val + \"; line is \" + line + \"; k is \" + k);\n                                        }\n                                    }\n                                    break;\n                                case 10:\n                                    if (!val.equals(\"none\")) {\n                                        StringBuffer unicodeBuffer = new StringBuffer();\n                                        StringTokenizer uTok = new StringTokenizer(val, \",\");\n                                        while (uTok.hasMoreTokens()) {\n                                            String subval = uTok.nextToken();\n                                            ThdlDebug.verify(subval.length() == 4 || subval.length() == 3);\n                                            try {\n                                                int x = Integer.parseInt(subval, 16);\n                                                ThdlDebug.verify((x >= 0x0F00 && x <= 0x0FFF) || x == 0x5350 || x == 0x534D || x == 0x0020 || x == 0x00A0 || x == 0x2003);\n                                                unicodeBuffer.append((char) x);\n                                            } catch (NumberFormatException e) {\n                                                ThdlDebug.verify(false);\n                                            }\n                                        }\n                                        TMWtoUnicode[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = unicodeBuffer.toString();\n                                        char ch;\n                                        if (unicodeBuffer.length() == 1 && UnicodeUtils.isInTibetanRange(ch = unicodeBuffer.charAt(0))) {\n                                            if (null != UnicodeToTMW[ch - '\u0f00'][0] && '\u0f00' != ch && '\u0f02' != ch && '\u0f03' != ch && '\u0f0b' != ch && '\u0f0e' != ch && '\u0f40' != ch && '\u0f42' != ch && '\u0f49' != ch && '\u0f4f' != ch && '\u0f51' != ch && '\u0f53' != ch && '\u0f5e' != ch && '\u0f62' != ch && '\u0f64' != ch && '\u0f67' != ch && '\u0f6a' != ch && '\u0f71' != ch && '\u0f72' != ch && '\u0f73' != ch && '\u0f74' != ch && '\u0f75' != ch && '\u0f76' != ch && '\u0f77' != ch && '\u0f78' != ch && '\u0f79' != ch && '\u0f7a' != ch && '\u0f7c' != ch && '\u0f7e' != ch && '\u0f81' != ch) {\n                                                throw new Error(\"tibwn.ini has more than one TMW fellow listed that has the Unicode \" + val + \", but it's not on the list of specially handled glyphs\");\n                                            }\n                                            UnicodeToTMW[ch - '\u0f00'][0] = duffCodes[TMW];\n                                        }\n                                    }\n                                    break;\n                                case 11:\n                                    if (!ignore) {\n                                        duffCodes[HALF_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 12:\n                                    if (!ignore) {\n                                        DuffCode binduCode = new DuffCode(val, true);\n                                        binduMap.put(duffCodes[TMW], binduCode);\n                                    }\n                                    break;\n                                case 13:\n                                    throw new Error(\"tibwn.ini has only 13 columns, you tried to use a 14th column.\");\n                            }\n                        } else {\n                            if (k == 10) {\n                                throw new Error(\"needed none or some unicode; line is \" + line);\n                            }\n                        }\n                    }\n                    if (k < 10) {\n                        throw new Error(\"needed none or some unicode; line is \" + line);\n                    }\n                    if (!ignore) {\n                        if (null == wylie) throw new Error(fileName + \" has a line ^\" + DELIMITER + \" which means that no Wylie is assigned.  That isn't supported.\");\n                        if (hashOn) {\n                            tibHash.put(Manipulate.unescape(wylie), duffCodes);\n                        }\n                        if (isTibetan) {\n                            StringBuffer wylieWithoutDashes = new StringBuffer(wylie);\n                            for (int wl = 0; wl < wylieWithoutDashes.length(); wl++) {\n                                if (wylieWithoutDashes.charAt(wl) == '-') {\n                                    wylieWithoutDashes.deleteCharAt(wl);\n                                    --wl;\n                                }\n                            }\n                            tibSet.add(wylieWithoutDashes.toString());\n                        }\n                        if (isSanskrit) {\n                            sanskritStackSet.add(wylie);\n                        }\n                        if (null == duffCodes[TMW]) throw new Error(fileName + \" has a line with wylie \" + wylie + \" but no TMW; that's not allowed\");\n                        int font = duffCodes[TMW].getFontNum();\n                        int code = duffCodes[TMW].getCharNum() - 32;\n                        toHashKey[font][code] = Manipulate.unescape(wylie);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"file Disappeared\");\n            ThdlDebug.noteIffyCode();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"readData": ["processdata", "parsedata", "parseDATA", "processData", "readText", "readdata", "initText", "parseText", "processDATA", "processText", "readDATA", "initData", "initdata", "initDATA", "parseData"], "sTok": ["servicesTok", " sEnc", "newKe", "synOtt", "siteLoc", "fsTok", " sVal", "dsIter", "pToken", "dsTu", " sTu", "yourTok", "awsTok", "singleCorp", "servicesTu", "SOrg", "sChat", "awsLoc", "testsKo", "dIter", "sslTok", "sMsg", "obsKe", "sIter", "sDec", "nLex", "fsSk", "sKo", "sLex", "dTok", " sLex", "sslVo", "pTok", "servicesKo", "synIter", " sDoc", "sslIter", "SSel", "sisTok", " sTag", " sPos", " sOrg", "sportsEh", "gsLex", "nLoc", "synTok", "sesTok", "hsIter", "opensEh", "sKe", "sBu", "lsTok", "awsDoc", "sOtt", "newBot", "lsBuild", "sisOtt", "sBuff", "nBu", "pIter", "STok", "seTok", "seToken", "sisTu", "lsKe", "sisChan", "gsTok", "sSel", "testsTok", "syncTok", "syncTu", " sCorp", "dsOtt", "sEh", "gsSk", "sChan", "SBuff", "sUt", "nUt", "sisVal", "sesIter", "syncVo", "sCorp", "nTok", "seBuff", "sOrg", "obsBuild", "sportsBuild", "sEnc", "sOp", "sTag", " sSel", "seSel", " sVo", "awsRec", " sUt", " sOk", "SOk", "yourChat", "awsEnc", " sIv", "obsTok", "submitMsg", "newUt", "sVo", "siteOtt", "opensPop", " sIter", "fsDec", "dsTok", "sPop", "sOk", "sesAk", "sportsPos", "sDoc", "submitTok", "newTok", " sDec", " sOtt", " sKo", " sBot", "sesUk", "servicesLex", "nMsg", "submitBu", " sChan", "singleTok", "singleSk", " sBu", "fsLex", "suIter", "dsLoc", "tLoc", "sTu", "sslTu", "nIter", " sOp", " sMsg", "dLoc", "sToken", "hsSk", "servicesIter", "SToken", "singleMsg", "siteTag", "sUk", " sBuff", " sSk", "sBot", " sToken", "sVal", "dToken", " sPop", "hsVo", "sLoc", "sisIter", "dsUk", " sKe", "yourLoc", "dsVal", "sPos", "opensPos", "sportsKe", "tDoc", "SIter", "tTok", "nOp", "opensTok", "sisBuff", "sSk", "testsTu", " sAk", "hsTok", " sRec", "testsIter", "sportsTok", "sBuild", "synVal", "submitLex", "sAk", "syncIter", "siteIter", "dsVo", "suVo", "dsAk", " sChat", "pLoc", "sRec", " sUk", "sIv", "tIter", " sLoc", "awsIter", " sEh", "gsDec", "siteTok", "suTok", "servicesIv", "nChat", "yourMsg", "sportsPop", "suSk"], "topSet": ["TopHat", "pperHat", "TopMap", " topMap", "TopUnit", "topAdd", "topUnit", "pperMap", "TOPSet", "TOPAdd", "TOPChan", " topHat", " topAdd", " topUnit", "pperSet", "topChan", "TOPUnit", "TopChan", " topChan", "TopAdd", "pperChan", "topHat", "TopSet", "topMap"], "leftSet": ["lawBlock", " leftCollect", "rightKit", "smallSet", " leftHat", "leftKit", "lawCollect", "controlHat", "smallUnit", "controlCollect", "smallKit", " leftBlock", " leftUnit", "controlBlock", "leftUnit", "leftHat", " leftKit", "leftBlock", "leftCollect", "rightUnit", "lawHat", "lawSet", "controlSet"], "rightSet": [" rightMap", "rightsSource", " rightChain", " rightList", "RightSet", "rightsList", "RightSource", "RightGet", "rightGet", "RightUnit", " rightUnit", "rightChain", "rightsSet", "rightSource", "rightsUnit", " rightSource", "rightsChain", "rightList", "RightMap", "rightsGet", "RightList", "RightChain", "rightsMap", "rightMap", "rightUnit", " rightGet"], "farRightSet": ["farLeftList", "farCorrectset", "farrightList", " farRightset", "farrightUnit", "farRightList", "farCorrectSet", "farRightChan", "farrightSet", " farRightList", " farLeftSet", "farCorrectList", " farRightUnit", "farLeftSet", "farLeftset", "farLeftChan", "farRightset", " farRightChan", " farLeftList", "farRightUnit", "farLeftUnit", " farLeftUnit", "farCorrectChan"], "vowelSet": ["voweleMap", "voxelsMap", "voweleList", "vowelsMap", "vowlSet", "vowelSize", "vouelSet", "vowelsList", "vowlSize", "voxelMap", "vouelList", "voulSize", "voulSet", "vowellSize", "vouelSize", "vowellSet", "vowellMap", "vowelsSize", "voweleSet", "vowelMap", "voxelsSet", "vowelList", "vowellList", "vowelsSet", "voxelsList", "voulList", "voxelList", "vowlList", "voxelSet"], "ntk": ["ontku", "ntks", "LTok", "etk", "antku", "gtk", "ctk", "ntr", "ptsk", "LTk", "octg", "ptik", "ontp", "ontak", "ontc", "etK", "ntuk", "ptr", "ontch", "ottwork", "notk", "otkg", "NTok", "otku", "NTc", "etok", "antK", "ontik", "antc", "ntsk", "ontsk", "ontk", "ntik", "montsk", "ntkg", "NTak", "settk", "ntke", "gtok", "NTch", "montk", "ottk", "settke", "ntku", "antk", "ctke", "LTuk", "netk", "ontke", "ntwork", "ntok", "rtK", "otp", "antwork", "ontks", "notks", "untok", "ntek", "settsk", "antok", "ctK", "ontr", "octk", "ottak", "ctsk", "ntp", "antkg", "ntg", "gtke", "LTek", "ptp", "gtsk", "ontK", "octke", "settg", "gtc", "ptks", "etwork", "rtwork", "otk", "NTk", "netok", "ontg", "montK", "ontwork", "untwork", "ntc", "NTwork", "antik", "montke", "NTuk", "ntak", "notK", "ottok", "untk", "untch", "notsk", "gtK", "ontkg", "NTek", "ntK", "ptK", "netc", "octsk", "NTK", "ptk", "rtk", "rtok", "antp", "ntch", "antr", "ontok", "netK"], "maxEwtsVowelLength": ["maxEwtsVowsetLen", "maxEwtsVowelingText", "maxEwtsVowelsId", "maxEwtsVoyellId", "maxEwtsVowellText", "maxEwtsVoyelLength", "maxEwtsVowilLength", "maxEwtsVoyelId", "maxEwtsVowelType", "maxEwtsVowelNumber", "maxEwtsVowetLength", "maxEwtsVoyelLen", "maxEwtsVowetText", "maxEwtsVowsetText", "maxEwtsVowilType", "maxEwtsVoyelType", "maxEwtsVowelingLength", "maxEwtsVowelsLength", "maxEwtsVowellLength", "maxEwtsVowellType", "maxEwtsVowelId", "maxEwtsVoyellType", "maxEwtsVowellId", "maxEwtsVoyellLength", "maxEwtsVowelText", "maxEwtsVowselNumber", "maxEwtsVowellLen", "maxEwtsVowellNumber", "maxEwtsVowelsLen", "maxEwtsVowselLen", "maxEwtsVowelsType", "maxEwtsVowetLen", "maxEwtsVowelingNumber", "maxEwtsVowetNumber", "maxEwtsVowselText", "maxEwtsVowsetLength", "maxEwtsVowilLen", "maxEwtsVowelingLen", "maxEwtsVoyellLen", "maxEwtsVowselLength", "maxEwtsVowelLen", "maxEwtsVowilId", "maxEwtsVowsetNumber"], "puncSet": ["pucSet", " puccGet", "pocList", "pummSet", "PucList", "pucGet", "pummGet", "pocSet", "pascalSet", " puccSet", " puccset", "pocNum", "PucSet", "pucset", "puncGet", "PuncNum", "PuncList", "puncNum", "puccGet", "puccset", " puncGet", "puccSet", "PuncSet", "PucNum", "puncset", "pummset", "pucNum", "pucList", "pascalList", "puncList", " puncset", "pascalNum"], "charSet": ["CharList", "charMap", "inchLet", "characterLet", "charLet", "characterList", "inchMap", "charBlock", "characterMap", " charBlock", "CharBlock", "charList", "characterSet", " charMap", "inchSet", " charList", "CharSet", " charLet", "characterBlock"], "tibSet": ["Tibiet", "tikArray", "TibArray", "tiket", "tivEn", "TobEn", "TibSet", "Tibiset", "tibiet", "tilibet", "TobSet", "TibiArray", "tibset", "tibiset", "Tibset", "tibet", "tikset", "TibiSet", "tobEn", "tilibEn", "tilibSet", "tivet", "tbiSet", "tibArray", "tobSet", "tikSet", "tibEn", "Tibet", "tbiset", "TibEn", "Tobet", "tivSet", "tobet", "tibiSet", "tbiet", "tbiArray", "tibiArray"], "sanskritStackSet": ["sanskritStackset", "sanskriticalStackMap", "sanskritContextset", "sanskritRootMap", "sanskriticalStackSet", "sanskritContextMap", "sanskriticalRootSet", "sanskritHashset", "sanskritContextSet", "sanskriticalStackset", "sanskritHashMap", "sanskriticalRootset", "sanskritStackMap", "sanskritHashSet", "sanskritRootSet", "sanskritRootset", "sanskriticalRootMap"]}}
{"id1": "6988216", "id2": "20924119", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" runClientConnect", "runSimpleSearch", "runSimpleFilter", "runRawQuery", " runRawQuery", " runSimpleSearch", " runRawSearch", " runClientSearch", " runRawConnect", " runBasicQuery", "runSimpleQuery", " runBasicSearch", " runRawFilter", " runSimpleQuery", " runSimpleConnect", " runSimpleFilter", " runClientQuery", " runBasicConnect", "runRawConnect", "runSimpleConnect", " runBasicFilter", "runRawSearch", "runRawFilter", " runClientFilter"], "dummySource": ["dumbOrigin", "dummyType", "puddySource", "dandySite", "puddySourceFile", "duddySource", "duddySourceFile", " dummyOrigin", "pummyContent", "puddySite", "duddyOrigin", " dumbOrigin", "duddyConfig", "pummySite", "dellyContent", "puddyService", "dumbConfig", " dumbConfig", "puddyType", "dundleSource", "daddyService", "daddySource", "dundleConfig", " dumbSource", "duddyType", "duddyContent", "dundleContent", "pummyService", "duddySite", "duddyClient", "daddyClient", "daddyContent", "pummyType", " dummyConfig", "pummySource", "duddyService", "dummyClient", "dandyClient", "dellySource", "pummySourceFile", "pummyClient", "daddyType", "dundleOrigin", " dumbContent", "dummyConfig", "dandySource", "dummyOrigin", "dumbSource", "puddyClient", "dummySite", "daddySite", "daddySourceFile", "puddyContent", "dellyService", "dumbContent", "dummySourceFile", "dandySourceFile", "dummyService", "dellyType"], "os": ["om", "ou", "mos", "i", "css", "oses", "fs", "Os", "acs", "ok", "sys", "op", "ols", "ns", "oa", "ks", "dos", "as", "OS", "o", "bs", "s", "is", "oos", "ms", "ori", "ros", "bos", "ops", "uns", "oc", "nos", "ens", "out", "ows", "object", "es", "conn", "ose", "or", "vs", "ls", "aos", "obs", "oss", "io", "pos", "ss", "ios", "oS", "us", "ox", "ds", "los", "ol", "ps", "osi", "iso", "cos"], "dummyContent": ["duckySource", "duddySource", "dellyContents", "DuckyBody", "DummyBody", "duddyReader", "dumpingContents", "dummyReader", "duddyBody", "dumpingcontent", "dellyContent", "dummyContents", "dumpercontent", " dummyContents", " dummyOutput", " dellyOutput", " dellycontent", "dumpingOutput", "DuckyContent", "DuckyReader", " dellyContent", "duckyBody", "dellyOutput", "dellycontent", "dumperOutput", "DuckySource", "duddyContent", "DummyReader", "dummyBody", " dellyContents", " dummycontent", "duckyContent", "dumpingContent", "DummyContent", "dumperBody", "dumperContents", "dummyOutput", "dummycontent", "duckyReader", "dumperReader", "dumperContent", "DummySource", "dumperSource"], "source": ["string", "info", "sin", "core", "class", "i", "sc", "node", "resource", "uri", "element", "Source", "resources", "site", "slave", "result", "s", " Source", "host", "ources", "SOURCE", "client", "sync", "reader", "use", "cache", "proxy", "seed", "connection", "target", "scope", "parent", "config", "text", "src", "channel", "object", "size", "search", "e", " sources", "sl", "secure", "url", "ser", "stream", "unit", "sn", "ource", "service", "cos", "storage"], "content": ["address", "css", "input", "server", "output", "response", "resource", "clean", "feed", "report", "document", "description", "message", "cont", "version", "comments", "current", "result", "html", "child", "sol", "host", "match", "Content", "cms", "expression", "load", "news", "cover", "activity", "value", "children", "media", "target", "model", "config", "data", "text", "body", "size", "title", "header", "image", "transform", "url", "update", "comment", "music", "xml", "service", "code", "cos"], "qResult": ["queryResult", "iqResult", "kReturn", "qresult", "qReturn", "kRes", "kResult", " qResponse", "queryFilter", "kResults", "QResult", " qResults", "queryRes", "kresult", "QReturn", "qRes", "iqresult", "QResults", "iqResults", "qSource", "rRes", "queryResponse", "iqResponse", "queryResults", "qFilter", " qresult", "rResult", "QFilter", "qResults", "qResponse", "kSource", "queryReturn", "rSource", "kFilter", "querySource", "queryresult", "rresult"], "results": ["response", "res", "resources", "pages", "docs", "vers", "features", "result", "qs", "s", "reports", "ins", "versions", "ries", "errors", "shows", "ids", "items", "its", "users", "lines", "blocks", "members", "children", "runs", "collection", "RESULTS", "data", "models", "objects", "groups", "tests", "rows", "details", "values", "files", "ions", "successful", "events", "Results"], "it": ["ite", "info", "i", "id", "ort", "op", "entry", "ic", "slice", "IT", "ited", "l", "ins", "si", "mit", "in", "iter", "split", "its", "sit", "stat", "which", "not", "the", "r", "ati", "itted", "ip", "p", "init", "lit", "or", "edit", "ci", "iti", "t", "rit", "ITS", "ait", "you", "v", "and", "It", " It", "pit", "list"], "rSrc": ["rAssrc", " rEsRC", "rPssrc", "rPsRC", " rDsrc", "rIsRC", " rSource", "rSsrc", " rEsource", "rDssrc", "rAsrc", " rSsrc", "rPsource", " rDsRC", "rDsource", "RSRC", "RSource", "rSRC", "RIsource", "RSrec", "rEssrc", "RIsRC", "RIsrec", "rEsrc", "rAsRC", "rIsrc", " rEsrc", "rAsource", " rDsource", " rDssrc", "rIsrec", "rIsource", " rEssrc", "rAsrec", "rPsrc", " rSRC", "RSrc", "rEsRC", "rSource", "rEsource", "rDsRC", "rDsrc", "rSrec", "RIsrc"], "rSrcIn": ["rCrcIN", "rSsrcin", "rSvcIn", "rCrcin", "rCrcOut", "rCRCIn", "rSRCin", "rAsrcIn", "rCsrcin", "rCrcIns", "rSrcOut", "rSRCIN", "rSvcIns", "rSsrcIn", "rSrcin", "rSrcIN", "rAsrcOut", "rCsrcOut", "rSourceIn", "rSvcIN", "rCRCIns", "rSRCIns", "rCrcIn", "rCsrcIn", "rAsrcin", "rCRCOut", "rSRCOut", "rSvcOut", "rSrcIns", "rAsRCIn", "rAsRCin", "rSourceIns", "rSourcein", "rCsrcIN", "rSourceOut", "rSRCIn", "rSsrcOut", "rAsRCOut", "rSsrcIN", "rSvcin"], "actualOut": [" actualOUT", "publicOutput", "operatorOut", " ActualIn", " ActualBridge", "eventout", "operatorIn", "publicOut", "operatorout", "illegalIn", "actualIn", "eventOut", "actualWin", "eventOUT", " actualBridge", " actualOutput", "actualout", "assertBridge", "actualOutput", "illegalOUT", "realWin", " actualIn", "actualOUT", "realIn", "actualBridge", "assertIn", "eventIn", "assertOUT", "illegalOutput", "publicIn", "realOut", "operatorOUT", "nexpectedIn", "realout", " ActualOut", " actualWin", "assertOut", " ActualOUT", "illegalOut", " actualout", "nexpectedOut", "publicOUT", "nexpectedWin", "nexpectedout"]}}
{"id1": "5237257", "id2": "13595251", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 1, "substitutes": {"download": ["zip", "release", "output", "register", "report", " downloading", "Download", "run", "select", "load", "upload", "open", "file", "archive", "log", "delete", "submit", "complete", "start", "exec", "pack", "dump", "url", "update", "paste", "process", "transfer"], "fileName": ["FilePath", "resourceCode", "resourceUrl", "resourceName", "fileUrl", " fileCode", "resourceFolder", "FileDirectory", "resourceType", "FileUrl", "FileCode", "fileType", " fileDirectory", " fileType", "fileFolder", "FileType", " fileUrl", "FileFolder", "resourceDirectory", "fileDirectory", "fileCode", "FileName", "resourcePath", " fileFolder"], "filePath": ["FilePath", " fileFile", "resourceName", "resourceLocation", " fileLocation", "FileFile", "filePart", " filePart", "resourcepath", "resourceFile", " filepath", "FilePart", "fileFile", "filepath", "Filepath", "fileLocation", "FileName", "resourcePart", "resourcePath", "FileLocation"], "in": ["IN", "pin", "i", "input", "id", "n", "copy", "resource", "ini", "gin", "on", "con", "inner", "as", "socket", "l", "ins", "bin", "is", "sync", "reader", "source", "up", "login", "inside", "r", "inc", "work", "data", "file", "rin", "x", "init", "issue", "name", "again", "m", "ax", "image", "io", "cgi", "re", "isin", "In", "nin", "spin", "a", "url", "lin", "err", "b", "ac", "cin", "inn", "f", "win", "this", "din"], "out": ["IN", "path", "string", "base", "error", "ex", "output", "n", "copy", "server", "outer", "id", "user", "by", "on", "option", "net", "OUT", "socket", "inner", "outs", "o", "office", "off", "write", "bin", "line", "extra", "password", "sync", "client", "at", "one", "source", "cache", "lib", "up", "file", "x", "log", "null", "conn", "view", "or", "name", "again", "exec", "Out", "writer", "io", "image", "exp", "to", "call", "nin", "In", "prefix", "url", "ext", "obj", "err", "with", "cmd", "this", "point"]}}
{"id1": "12766377", "id2": "8150996", "code1": "    public Document index() throws CrawlingException {\n        log.debug(\"BEGINIG indexing page [code=\" + getCode() + \"] ...\");\n        URL url = null;\n        InputStream in = null;\n        String contentType = null;\n        try {\n            url = new URL(getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath());\n            HttpURLConnection pageContent = (HttpURLConnection) url.openConnection();\n            if (pageContent.getResponseCode() != HttpURLConnection.HTTP_OK) {\n                log.debug(\"page pk[\" + getCode() + \",\" + url.toExternalForm() + \"] is invalid\");\n                return null;\n            }\n            String redireccion = pageContent.getHeaderField(\"location\");\n            if (redireccion != null) {\n                log.debug(\"Page \" + url.toExternalForm() + \" redirected to \" + redireccion);\n                recordLink(redireccion);\n                return null;\n            }\n            contentType = pageContent.getContentType();\n            in = new BufferedInputStream(pageContent.getInputStream(), 32768);\n        } catch (MalformedURLException e) {\n            log.error(\"Invalid page address\", e);\n        } catch (ConnectException e) {\n            if (getServer() != null) {\n                log.error(\"Unable to connect to page: \" + getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath(), e);\n            }\n        } catch (UnknownHostException uhe) {\n            log.warn(\"Unknow host indexing page \" + getURL(), uhe);\n        } catch (IOException e) {\n            log.warn(\"Unable to index page \" + getURL(), e);\n        }\n        Document doc = generateDocument(contentType, in);\n        log.debug(\"END indexing page [code=\" + getCode() + \"]\");\n        return doc;\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 0, "substitutes": {"index": ["info", "address", "online", "server", "report", "document", "project", "fix", "find", "forward", "html", "Index", "write", "query", "read", "post", "install", "type", "cache", "ion", "show", "open", "check", "page", "request", "search", "insert", "edit", "change", "image", "action", "ing", "link", "ping", "update", "include", "connect", " Index", "scan", "process", "network", "external", "download", "office", "display", "list", "view"], "url": ["impl", "string", "path", "address", "base", "ssl", "buffer", "server", "uri", "resource", "feed", "user", "http", "html", "l", "host", "location", "URL", "il", "el", "pl", "fl", "client", "email", "uc", "connection", "ch", "ob", "build", "file", "channel", "cl", "page", "web", "ll", "bel", "log", "href", "or", "coll", " URL", "e", "image", "blog", "link", "db", "sl", "rl", "pull", "Url", "www", "ur", "f", "gl", "org", "api", "loc"], "in": ["IN", "path", "pin", "input", "i", "ex", "serv", "ini", "gin", "on", "con", "socket", "ins", "record", "el", "bin", "is", "source", "reader", "login", "min", "r", "str", "inc", "data", "file", "out", "gen", "conn", "rec", "again", "m", "ax", "image", "In", "nin", "a", "err", "ac", "cin", "inn", "f", "win", "this", "din"], "contentType": ["contentLength", "ContentType", "inputName", " contenttype", "ContentPath", "ContentLength", "pageName", "resourceInfo", " contentInfo", "pageType", "resourceType", " contentPath", "ContentId", "ContentInfo", "pageId", "ContentTypes", "mediaName", "mediaTypes", "Contenttype", "contentInfo", "contentTypes", " contentId", " contentLength", "contentPath", "contentName", "inputType", "pagetype", "contenttype", "mediaType", "contentId", " contentName", "resourceLength", "ContentName", "resourcePath", "inputTypes"], "pageContent": [" pagecontent", "pageConnection", "fileConnection", "PageMessage", "documentMessage", "pagePage", "commentCode", "responseResponse", " webpageResponse", "fileUrl", "documentCode", " pageMessage", "pageConnect", "PageConnect", "linecontent", " pageCode", "pageMessage", " pageLocation", "pageCode", "commentConnection", "lineContent", "documentHeader", "lineLocation", "imageContent", "PageCode", "responsecontent", " pagePage", " webpageConnection", "lineHeader", "imagePage", "imageCode", "imageConnection", " pageResponse", "responseLocation", "fileContent", "documentContent", "pageLocation", "pageUrl", "commentContent", " pageConnection", "PageConnection", "pagecontent", " webpagecontent", "responseHeader", " pageUrl", "PageHeader", "responseContent", "pageHeader", "pageResponse", "fileConnect", "PageUrl", "responseConnection", "PageContent", " webpageContent", " pageHeader", " pageConnect", "commentPage"], "redireccion": ["redirepcions", "redireclional", "redirectation", "redireccation", "redirector", "redirepcation", "redireCCion", "redireccison", "redereccion", "redirectison", "redireCCor", "rederectison", "redirecsion", "redirepcion", "redereccions", "redereccION", "redireclION", "redirecions", "rederection", "redirection", "redereCCion", "redireCCION", "redirecION", "redereccional", "redireccional", "rederectION", "rederections", "redirecsION", "redereccation", "redireccions", "redireCCional", "redireclion", "redirecison", "redirecsison", "rederector", "redirecion", "redereccison", "redereCCional", "redireclions", "redireCCions", "redirectION", "redirepcION", "redirecation", "redereccor", "redereCCION", "redirections", "rederectation", "redereCCions", "redirecsions", "redireCCison", "redireccor", "redireclor", "redireccION", "redirecional", "redireclison"], "doc": ["val", "event", "id", "resource", "Doc", "entry", "docs", "document", "ref", "DOC", "result", "html", "record", "dc", "func", "post", "type", "source", "dir", "up", "lib", "oc", "str", "div", "data", "file", "body", "page", "msg", "desc", "dict", "exp", "word", "db", "pc", "di", "bc", "Document", "module", "api"]}}
{"id1": "18489832", "id2": "16825994", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"downLoadZippedFile": [" doLoadzippedDir", " doLoadZippingDir", " doLoadZippedFiles", " doLoadZedFiles", " doLoadzippedFiles", " doLoadZedFile", " doLoadzippedContent", " doLoadZaggedDir", " doLoadZippedContent", " doLoadZippingFiles", " doLoadzippingFiles", " doLoadZaggedContent", " doLoadZippingContent", " doLoadZaggedFiles", " doLoadZaggedFile", " doLoadZippedFile", " doLoadzippingDir", " doLoadzippingContent", " doLoadzippingFile", " doLoadZippedDir", " doLoadZippingFile", " doLoadzippedFile", " doLoadZedContent", " doLoadZedDir"], "url": ["zip", "event", "base", "ssl", "loader", "i", "server", "uri", "resource", "http", "c", "lr", "l", "URL", "client", "source", "lib", "proxy", "connection", "r", "store", "config", "open", "file", "route", "web", "page", "ll", "log", "or", "image", "link", "sl", "pull", "Url", "update", "bug", "ur", "b", "f", "download"], "destDir": ["tmpDIR", "destDIR", " destFolder", "destDirectory", "outputFolder", "tempDIR", "destdir", " destDirectory", "tmpdir", "DestFolder", "DestFile", " destdir", "destFolder", "tempDir", "destFile", "DestDir", "tmpDir", "outputDIR", "outputDirectory", "tempFile", "tempFolder", "outputDir", " destFile", "outputdir", "DestDIR", "tmpDirectory", "outputFile", " destDIR"], "urlConnection": ["fileConnection", "urlChannel", "webConnect", "httpConnection", "URLChannel", " urlconnection", "httpNetwork", "webconnection", "downloadFactory", "downloadConn", " urlConnect", "httpConn", "URLConnection", "URLConnect", "urlConnect", "urlconnection", "URLconnection", "downloadConnection", "urlFactory", "fileFactory", "webChannel", "webConnection", "urlConn", "urlNetwork", "fileConn", "httpFactory", "fileNetwork", "downloadNetwork", " urlChannel"], "tmpFile": ["mpFile", " tmpPath", " tmpfile", "mpfile", "mpPath", " tmpFiles", "destWorld", "destfile", "partFile", " tmpDir", "zipfile", "tempEntry", "tempPath", "zipFiles", "mpFolder", "TempWorld", "tmpfile", "Tempfile", "TempFile", "partDir", "TempPath", "destEntry", "destFolder", "tmpWorld", " tmpEntry", "mpDir", "tempLine", "mpFiles", "tempDir", "tmpFolder", "destFile", " tmpWorld", " tmpFolder", "destPath", "tmpEntry", "tmpFiles", "tmpDir", "partFolder", "zipFile", " tmpLine", "tempfile", "tempFile", "zipLine", "tempFiles", "tmpPath", "tmpLine", "partfile"], "in": ["IN", "info", "pin", "i", "input", "n", "copy", "ex", "id", "token", "ini", "gin", "con", "c", "inner", "socket", "as", "l", "ins", "arin", "bin", "is", "en", "sync", "source", "reader", "up", "login", "min", "connection", "r", "inc", "work", "data", "rin", "file", "init", "conn", "again", "Out", "ax", "In", "nin", "kin", "a", "pull", "lin", "err", "ac", "cin", "inn", "f", "win", "din"], "out": ["index", "IN", "i", "ex", "output", "n", "copy", "server", "outer", "op", "OUT", "socket", "inner", "o", "outs", "off", "line", "bin", "co", "sync", "client", "at", "one", "no", "source", "up", "connection", "min", "login", "inc", "file", "check", "null", "init", "conn", "again", "name", "exec", "Out", "io", "writer", "call", "nin", "In", "ext", "err", "obj", "cmd", "this", "download", "point"], "localURL": ["baseURL", "remoteFile", "baseUrl", " localCL", "externalUrl", "localUrl", " localFile", " localUrl", "localURI", "localCL", "remoteUrl", "externalAPI", "LocalURL", "baseFile", "localFile", " localURI", " localAPI", "localAPI", "remoteURL", "LocalUrl", "LocalAPI", "externalCL", "remoteURI", "baseURI", "LocalCL", "externalURL"]}}
{"id1": "17296916", "id2": "12586404", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    @Override\n    public List<ProvaSolution[]> run(ProvaService prova, String agent, String key, String src) throws IOException {\n        File file = new File(src);\n        BufferedReader in;\n        InputStream is = null;\n        try {\n            if (!file.exists() || !file.canRead()) {\n                try {\n                    is = Thread.currentThread().getContextClassLoader().getResourceAsStream(src);\n                    in = new BufferedReader(new InputStreamReader(is));\n                } catch (Exception ex1) {\n                    try {\n                        is = RuleReaderImpl.class.getResourceAsStream(src);\n                        in = new BufferedReader(new InputStreamReader(is));\n                    } catch (Exception ex2) {\n                        try {\n                            URL url = new URL(src);\n                            in = new BufferedReader(new InputStreamReader(url.openStream()));\n                        } catch (Exception ex3) {\n                            throw new IOException(\"Cannot read from \" + src);\n                        }\n                    }\n                }\n            } else {\n                FileReader fr = new FileReader(file);\n                in = new BufferedReader(fr);\n            }\n            List<ProvaSolution[]> results = prova.consult(agent, in, key);\n            return results;\n        } finally {\n            if (is != null) is.close();\n        }\n    }\n", "label": 0, "substitutes": {"logging": ["logger", "blogting", "Loging", "loging", "blogger", " logger", "Logting", " logting", "Logger", " loging", "bloging", "blogging", "logting", "Logging"], "wrap": ["nw", "handler", "rap", "self", " wrapped", "lock", "wp", "now", "message", "run", "util", "ad", "bag", "wra", "ws", "use", "cover", "wb", "cache", "binary", "default", "div", "w", "build", "pipe", "war", "work", "web", "h", "get", "p", "widget", "flash", "init", "format", "or", "force", "frame", "image", "box", "word", "stream", "parse", "create", "b", "wire", "wrapper", "we", " Wrap", "sw", "wa", "process", "f", "ow", "handle", "transform", "api"], "buffer": ["base", "loader", "pause", "Buffer", "server", " receive", "copy", "response", "uffer", "feed", "builder", "report", "bridge", "ref", "message", "board", "table", "document", "cb", "result", "shell", "bin", "manager", "pb", "queue", "iter", "uf", "bar", "reader", "cache", "player", "cover", "binary", "buff", "source", "buf", "ob", "surface", " buf", "batch", "BU", "fb", "flash", "bb", "log", "null", "reply", "msg", "template", "header", "frame", "writer", "image", "nb", "layer", "bc", "url", "comment", "b", "reference", "wrapper", "bm", "print", "transfer", " buffers", "code", "view"], "encoding": ["Encet", "decoded", "packoder", "ecoded", "decoder", "enoder", "Encoded", "Encoder", "coder", "Encryption", "coding", "unicode", "encode", "unicoded", "ecryption", "decoding", "encet", "Encoding", "encryption", "packet", "packoding", "coded", "enoded", "enoding", "unicoding", "enode", "ecoder", "cet", "packoded", "decryption", "unicoder", "encoder", "decode", "ecoding", "encoded"], "getEncoding": [" getEncasing", " getEncoded", "getCoded", "getEncoder", "getencoding", " getEncocol", "getEnoding", " getEnoding", "getEnoder", "getEnoded", " getEnoded", "getencocol", "getEnocol", "getCoder", "getencasing", "getencoder", "getCasing", "getCoding", " getEnocol", " getEnasing", "getEncocol", "getEncasing", "getEnasing", "getEncoded", " getEnoder", " getEncoder", "getCocol", "getencoded"], "headers": ["keys", "head", "settings", "http", "ers", "features", "writers", "s", "host", "caps", "rs", "ids", "workers", "content", "ings", "parts", "params", "links", "lines", "strings", "blocks", "ports", "str", "names", "body", "vals", "objects", "options", "h", "plugins", "groups", "breaks", "frames", "header", "dict", "ters", "ppers", "ints", "types", "details", "files", "values", "relations", "fields", "wrapper", "heads", "padding", "properties", "bits"], "is": ["bis", "i", "iss", "lis", "fs", "IS", "isa", "http", "Is", "as", "tis", "api", "bs", "s", "abs", "ins", "ois", "ui", "in", "ms", "ori", "isl", "cms", "its", "ws", "so", "ops", "ais", "bas", "nis", "out", "las", "\u00eds", "es", "has", "or", "js", "ris", "obs", "ists", "io", "oss", "aos", "iris", "ios", "us", "ses", "isi", "sis", "are", "isol", "os", "was", "iso", "mis"], "bos": ["uds", "bis", "base", "mos", "ko", "oses", "fs", "fits", "bh", "zos", "tis", "bones", "outs", "bs", "bo", "obos", "ois", "bin", "oos", "obo", "mobi", "obi", "bes", "flo", "cms", "so", "ws", "ros", "ops", "org", "ubis", "bas", "ob", "bott", "las", "ubs", "bi", "oes", "opus", "aos", "obs", "bots", "home", "oks", "lins", "beans", "ios", "bc", "ses", "osa", "pins", "bot", "shadow", "los", "zo", "abi", "oops", "os", "osi", "bits", "cos", "mis"], "e": ["ite", "ise", "fe", "i", "ee", "ke", "be", "ie", "c", "o", "se", "l", "ception", "ec", "er", "type", "one", "d", "ce", "ale", "je", "ea", "de", "exc", "x", "p", "ae", "E", "ze", "a", "ev", "pe", "me", "err", "f", "error", "oe", "esi", "re"]}}
{"id1": "2461169", "id2": "3266833", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeStringToString", "decodeFileAsStream", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileToStream", "decodeString2String", "decodeFileAsString", "decodeFileAsFiles", "decodeStringToFile", "decodeFile2String", "decodeStringToStream", "decodeFileAsFile", "decodeFileFromString", "decodeString2Stream", "decodeFileFromFile", "decodeFileToString", "decodeFile2File", "decodeString2File", "decodeFileToFiles", "decodeStringToFiles", "decodeString2Files", "decodeFileFromStream", "decodeFile2Files"], "infile": ["minfile", "infp", "outfilename", "infiles", "inFile", "inputfile", " instream", " inbase", " infp", "inputfp", " inFile", "Instream", "minstream", "outfiles", " infilename", "inputfiles", " infiles", "outfp", "Infile", "minFile", "minbase", "InFile", "inbase", "instream", "inputfilename", "infilename", "Inbase"], "outfile": ["outfilename", "outputfile", "inFile", "outFile", "inputfile", "outpath", " outFile", " outpath", "infolder", "outputfolder", "inputFile", "inputpath", " outfolder", "outdatabase", "outfolder", "outputdatabase", "outputfilename", " outdatabase", "inputdatabase", "outputpath", "outputFile", "infilename", " outfilename"], "in": ["IN", "pin", "sin", "i", "input", "inas", "id", "ini", "gin", "into", "ic", "con", "inner", "as", "socket", "ins", "s", "bin", "pass", "is", "reader", "source", "thin", "login", "min", "inside", "r", "inc", "data", "rin", "init", "conn", "again", "m", "re", "isin", "In", "nin", "a", "lin", "err", "b", "ac", "cin", "inn", "win", "din"], "out": ["base", "ou", "job", "ex", "output", "outer", "copy", "timeout", "net", "OUT", "socket", "inner", "outs", "o", "off", "line", "write", "bin", "co", "pass", "exit", "post", "client", "sync", "session", "no", "cache", "one", "lib", "up", "inc", "parent", "work", "file", "channel", "log", "conn", "or", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "In", "obj", "err", "error", "point"], "buffer": ["address", "base", "Buffer", "input", "uffer", "feed", "server", "border", "slice", "limit", "result", "length", "write", "bin", "queue", "offset", "iter", "split", "raw", "type", "reader", "cache", "binary", "source", "seed", "buff", "value", "buf", "wave", "data", "channel", "size", "bb", "null", "bytes", "layer", "flush", "url", "b", "reference", "count", "padding", "transfer", "batch"], "read": ["play", "i", "Read", "feed", "n", "copy", "reading", "id", "add", "ind", "slice", "current", "end", "limit", "run", "se", "find", "length", "write", "reads", "ride", "pass", "sleep", "ad", "iter", "next", "raw", "sync", " count", "select", "allow", "use", "load", "reader", "len", " Read", "r", "seek", "work", "inc", "check", " copy", "ip", "size", "x", "get", "fill", "start", "exec", "io", "lex", "send", "tell", "_", "parse", "connect", "wait", "count", "READ", " write", " skip", "f"], "success": ["path", "roll", "error", "response", "rolling", "continue", "results", "ceed", "xx", "message", "primary", "warning", "better", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "model", "default", "open", "data", "growth", "flash", "null", "cess", "danger", "complete", "again", "status", " successful", "good", "Success", "comment", "positive", "right", "successful", "successfully", "rolled", " succ", "method", "fast", "first", "winner", "initial"]}}
{"id1": "18504192", "id2": "804637", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "info", "base", "buffer", "i", "input", "id", "copy", "ini", "c", "inner", "ins", "bin", "part", "at", "reader", "d", "login", "min", "old", "diff", "inc", "parent", "data", "file", "src", "or", "again", "name", "m", "image", "io", "In", "url", "b", "ac", "inn"], "out": ["string", "base", "temp", "ex", "output", "n", "copy", "c", "OUT", "outs", "o", "dest", "line", "password", "client", "part", "cache", "connection", "target", "w", "inc", "data", "file", "object", "p", "conn", "name", "again", "exec", "Out", "writer", "io", "call", "prefix", "b", "obj", "err", "external", "point"], "source": ["sin", "ssl", "core", "i", "input", "self", "server", "copy", "Source", "settings", "ie", "slice", "slave", "project", "se", "dest", "origin", "ources", "clone", "SOURCE", "iter", "client", "sync", "use", "reader", "proxy", "connection", "target", "scope", "component", "parent", "channel", "src", "size", "get", "null", "start", "writer", "sl", "secure", "stream", "unit", "ource", "service", "from", "view", "storage"], "destination": ["declinated", "dependination", "contining", "declination", "testination", "testinated", " destinations", "dependinator", "declification", "destining", "continator", " destinated", "destinated", "testinator", " destinator", "Destination", "Destinated", "dependification", "Destification", "Destinator", "destification", "contination", "dependinated", "Destining", "declinator", "destinator", "testinations", "continated", "Destinations", "destinations", " destining"]}}
{"id1": "9096319", "id2": "21363911", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "label": 1, "substitutes": {"handleNodeRegainedService": ["handleNodeReginedEvent", "handleNodeReginedService", "handleNoderegainsServices", "handleNodeRegainsEvent", "handleNoderegainedServices", "handleNoderegainedService", "handleNodeRegainingService", "handleNoderegainedEvent", "handleNodeRegainingServices", "handleNodeRegainsService", "handleNodeRegainedEvent", "handleNodeReginedServices", "handleNoderegainsEvent", "handleNodeRegainingEvent", "handleNodeRegainedServices", "handleNoderegainsService", "handleNodeRegainsServices"], "eventID": ["updateid", "issueName", "updateID", "issueid", "issueID", "issueId", "nodeId", "eventid", "serviceid", "nodeTime", "updateId", " eventid", "serviceName", "serviceTime", "eventId", " eventName", "serviceId", "eventName", "updateName", " eventId", "nodeName"], "nodeID": ["resourceID", "eventPath", "nodeResult", "nodeid", "packageID", " nodeResult", "siteId", "nodeRI", " nodeid", "globalid", " nodeName", "nodeId", "eventid", "odeID", "serviceid", "resourceId", "globalPath", " nodeRI", "nodePath", "packageId", "eventKey", " nodeKey", "objectId", "globalId", "objectName", "odeId", "eventResult", "siteName", "sourceID", "eventId", "sourceRI", "sourceId", " nodePath", "eventName", "odeName", "nodeKey", " nodeId", "serviceId", "resourceKey", "objectID", "siteid", "odeRI", "nodeName", "odeResult", "globalID", "objectid", "packageid", "siteID"], "ipAddr": ["ipAddressri", "ipAppr", " ipAttrs", "IPAdder", "ipAddrt", "ipAddressrt", "IPAddrs", "ipAtter", " ipAttr", "ipAddressrs", " ipAppvr", "ipaddress", "ipAddressvr", " ipAttri", "ipAppvr", "ipAttri", "ipaddr", "ipChn", " ipAddrs", " ipApprs", "IPAddr", "IPAddressrt", " ipAdder", "ipaddrs", "ipAder", "ipAddri", " ipAtter", "ipOffrt", "IPAddressn", "IPAddri", "ipAdder", "IPAddrt", "ipAttr", "ipAddvr", "ipadder", "ipAdrs", "ipaddvr", "ipAttrs", "ipApprs", "ipAddrs", "ipOffrs", " ipAddress", "ipAddn", "IPAddressri", "ipOffr", "IPAddressr", " ipAddvr", "IPAddresser", "IPAddressrs", "ipAddressress", "ipAttvr", "ipAdn", " ipAttvr", "ipChr", "ipAddressn", "ipAddressr", "ipCher", "ipAddress", " ipAddri", "ipAddresser", "ipaddri", "ipChrs", "ipOffri", "ipAdr", " ipAppr", "IPAddn"], "serviceID": ["featureID", "resourceID", "skillName", "eventIDs", "serviceIDs", " serviceHandle", "featureIP", "serviceHandle", " serviceX", " serviceNAME", "ServiceName", "ServiceIDs", "skillID", "featureId", "ServiceID", "resourceType", "ServiceIP", "eventX", " serviceName", "ServiceId", "processId", "ServiceHandle", "serverID", "skillNAME", "serviceX", "resourceId", " serviceId", " serviceIP", "ServiceNAME", "serviceName", "serverId", " serviceIDs", "serviceNAME", "eventId", "featureHandle", "processName", "serviceIP", "eventName", "serviceId", "ServiceType", "processID", "serverName", "serverX", "skillId", " serviceType", "serviceType"], "eventTime": ["EventName", "changePoint", "changeTIME", "changeTime", "errorTime", " eventType", "changeType", "EventTim", " eventPoint", "eventTIME", "processName", "processTim", " eventName", "eventName", "eventTim", "processID", "errorTIME", " eventTIME", "processTime", "errorType", "EventID", "EventTime", "eventType", "eventPoint", "errorPoint", " eventTim"], "log": ["event", "info", "path", "lo", "temp", "feed", "output", "lock", "entry", "LOG", "http", "tool", "net", "c", "ge", "l", "host", "pool", "tag", "write", "thread", "pl", "key", "fail", "loop", "type", "stat", "cache", "connection", "debug", "model", "cat", "ch", "w", "config", "level", "crit", "out", "build", "cl", "get", "put", "gen", "conn", "format", "or", "lex", "port", "exp", "blog", "it", "call", "db", "Log", "og", "full", "com", "url", "bug", "pe", "contract", "sign", "plug", "error", "sec", "stop"], "dbConn": ["dbConnection", "logConnect", "bbCon", "dbconn", "cbConnection", "fbCon", "logConn", "fbColl", "dbCt", "DBConnection", "DbConnection", "bbConn", " dbConnect", "DbConn", " dbCt", "logconn", "DbConnect", "DBConn", "fbCt", "dbLoc", "dbConnect", "realCon", "DbCt", "logDb", "databaseConn", " dbDb", "databaseConnection", "realCt", "cbConnect", " dbConnection", "bbconn", "fbConn", "DBConnect", " dbconn", "dbColl", " dbLoc", "realColl", "dbDb", " dbColl", "DbDb", "databaseconn", "bbConnect", "DBCon", "databaseLoc", "cbConn", " dbCon", "Dbconn", "DbLoc", "cbconn", "DBconn", "DBCt", "realConn", "bbConnection", "dbCon"], "outageUpdater": ["outageUtdter", "outageUpdraser", "outageUpdatedratter", "outageAppdator", "outageUprusher", "outageUnaser", "outageUpdrater", "outageUpdrator", "outageUpdatedraser", "outageUpnoster", "outageUpdatarter", "outageUpmter", "outageUpdatATER", "outageUpdarter", "outageUppater", "outageUpdroster", "outageUpnoder", "outageUpdoder", "outageUpdager", "outageUpdatedarer", "outageupdatter", "outageUpdatedATER", "outageUptatable", "outageChdator", "outageUpfatter", "outageUpnager", "outageUpdrarer", "outageUpdatedatter", "outageUnATER", "outageuplater", "outageUpfaser", "outageUpratter", "outageChdroster", "outageUpdrapper", "outageUpdroder", "outageupdaser", "outageAppdter", "outageChdrator", "outageUplusher", "outageAppnter", "outageUplatter", "outageUpparter", "outageUpfater", "outageUpnarer", "outageUpdoster", "outageUpfapper", "outageUpdatedrater", "outageChdoster", "outageUtdatter", "outageUpdrusher", "outageUpdrATER", "outageUpdatedatable", "outageUpdatater", "outageuplusher", "outageUpdatedrapper", "outageUpdatedratable", "outageUpdatatter", "outageUtdarter", "outageUtdatarter", "outageUpdratable", "outageUpdATER", "outageUpdarer", "outageuplaser", "outageAppnager", "outageUtdater", "outageUpdsoster", "outageUdater", "outageUptaser", "outageUppter", "outageChdater", "outageAppnater", "outageUpdusher", "outageUpdatable", "outageUpdatedater", "outageUpdatter", "outageUpdratter", "outageUpdatedrarer", "outageUpndater", "outageUdATER", "outageUpmager", "outageUpdator", "outageUpndarter", "outageUpnter", "outageUplaser", "outageUprater", "outageUpdsator", "outageChdoder", "outageUpnater", "outageUpnaser", "outageUppatter", "outageUppaser", "outageUpdatedapper", "outageUplapper", "outageUpndter", "outageUnarer", "outageAppdager", "outageUpnator", "outageUpmator", "outageupdusher", "outageUplater", "outageUpstager", "outageUpdatedrATER", "outageUpnATER", "outageUdaser", "outageuplatter", "outageUpdsater", "outageUpmater", "outageUppATER", "outageChdrater", "outageUtdatater", "outageUptater", "outageUpstater", "outageUdarer", "outageUnater", "outageAppdater", "outageUpdter", "outageAppnator", "outageUpdatedaser", "outageUptarer", "outageChdroder", "outageUtdatatter", "outageUpdataser", "outageUpdapper", "outageUpstter", "outageupdater", "outageUpstator", "outageUpdaser", "outageUpraser", "outageUpdatarer", "outageUpndatter", "outageUpdsoder", "outageUpdatatable"]}}
{"id1": "9272325", "id2": "3375722", "code1": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "code2": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"sendPost": ["postpost", "doPost", "SendPOST", "postPOST", "sendpost", "dopost", "doMethod", "postMethod", "Sendpost", "doPOST", "sendPOST", "SendMethod", "SendPost", "postPost", "sendMethod"], "reqUrl": ["requEmail", "requestURL", "requestUr", "requestUrl", "requLine", "reqUr", "reqURL", "reqLine", "requestLine", "requestRoute", "requestEmail", "downloadLine", "requRoute", "requURL", " reqURL", " reqUr", "reqRoute", " reqRoute", "reqEmail", "requUrl", "downloadUrl", "downloadEmail", "downloadURL", "requUr"], "parameters": ["parameter", "arameter", "mandeter", "paramsations", "paramseters", "parParameters", "pareters", "mandations", "paramsams", "paramations", "paramsParameters", "mandParameters", "pareter", "parations", "paramParameters", "mandeters", "paramseter", "paramams", "arameters", "aramams"], "urlConn": ["buildConnector", " urlCon", "bbCon", "buildConn", "urlConnection", "httpReg", "buildConnection", "httpconn", "bbConn", "baseConnect", "userConn", "buildCon", "elConn", "blogContainer", "webCon", "logConnection", "reqConn", " urlSync", " urlconn", "urlConnect", "lconn", " urlContainer", "httpCon", "httpExec", "webSync", "elConnect", "urlReg", "logCon", "urlconn", "webContainer", "urlComm", "returnConnection", "httpConnect", "httpSync", " urlInfo", "blogCon", "httpInfo", "httpConnection", "baseConnection", "lConnection", "obConn", " urlConnect", "baseConn", "lConn", "urlContainer", "URLConn", " urlConnection", "returnConn", "userConnect", "webConnection", "bbConnection", "webExec", "logConn", "webConnect", " urlReg", "elCon", "urlInfo", "urlExec", "obReg", "httpConn", "obConnection", "URLConnect", "elConnection", "userConnection", "urlConnector", "webConn", "bbConnector", "URLClose", "blogConnection", "webconn", "userInfo", "urlClose", "logConnect", "webClose", " urlClose", " urlExec", "urlSync", "httpComm", "baseCon", "reqconn", "obConnect", "reqConnection", "urlCon", "returnCon", "URLconn", "reqComm", "httpConnector", "lComm", "returnConnect", "blogConn"], "params": ["string", "Par", "uri", "response", "settings", "http", "res", "pages", "resources", "json", "posts", "l", "s", "apps", "URL", "query", "manager", "database", "req", "parts", "lines", "ams", "bps", "par", "Parameters", "tags", "points", "data", "names", "tmp", "body", "config", "options", "request", "array", "prefix", "bytes", "Url", "_", "rules", "ps", "properties", "Param", "param", "api"], "url": ["string", "path", "base", "ssl", "job", "i", "server", "n", "uri", "resource", "http", "c", "lr", "l", "host", "URL", "orb", "source", "lc", "connection", "r", "ob", "config", "data", "page", "web", "ll", "bel", "log", "conn", "ls", " URL", "Config", "blog", "sl", "rl", "layer", "Url", "www", "ur", "obj", "f", "gl", "api", "loc"], "b": ["buffer", "base", "i", "bf", "emb", "bd", "lb", "c", "l", "bs", "bin", "pb", "gb", "mb", "bar", "rb", "ab", "binary", "wb", "sb", "buff", "buf", "r", "ob", "data", "body", "fb", "bb", "null", "e", "nb", "db", "a", "bytes", "B", "v", "obj", "br", "bl", "ba", "f", "boot"]}}
{"id1": "9096314", "id2": "18046717", "code1": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    private String getFullClassName(URL url, String className) throws Exception {\n        JarInputStream jis = new JarInputStream(url.openStream());\n        ZipEntry zentry = null;\n        while ((zentry = jis.getNextEntry()) != null) {\n            String name = zentry.getName();\n            int lastPos = name.lastIndexOf(\".class\");\n            if (lastPos < 0) {\n                continue;\n            }\n            name = name.replace('/', '.');\n            int pos = -1;\n            if (className != null) {\n                pos = name.indexOf(className);\n                if (pos >= 0 && name.length() == pos + className.length() + 6) {\n                    jis.close();\n                    return (name.substring(0, lastPos));\n                }\n            }\n        }\n        jis.close();\n        return (null);\n    }\n", "label": 0, "substitutes": {"handleNodeLostService": ["handlenodeLostFunction", "handleNodeUnknownFunction", "handleNodeErrorServices", "handleNodelostServer", "handleNodelostFunction", "handlenodeLostServer", "handlenodelostServices", "handlenodelostService", "handleNodeLostServices", "handlenodeLostServices", "handleNodeUnknownServer", "handlenodelostServer", "handlenodelostFunction", "handlenodeLostService", "handleNodeErrorFunction", "handleNodeErrorServer", "handleNodeLostFunction", "handleNodeUnknownService", "handleNodeErrorService", "handleNodelostServices", "handleNodeUnknownServices", "handleNodeLostServer", "handleNodelostService"], "eventID": ["resourceID", "nodeid", "resourceName", "EventName", "EventId", "nodeId", "sessionID", "eventid", "sessionName", " eventType", "documentName", "resourceId", " eventid", "serviceName", "EventType", "sessionId", "eventId", "nodeType", " eventName", "eventName", "serviceId", "resourceid", " eventId", "nodeName", "EventID", "documentId", "eventType", "documentID"], "nodeID": ["NodeID", "resourceID", "nodeid", "networkID", "resourceName", " nodeid", "Nodeid", " nodeInfo", " nodeName", "nodeInfo", "nodeId", "eventid", "networkId", "serviceid", " nodeURL", "resourceId", "NodeId", "networkInfo", "objectId", "serviceName", "objectName", "eventId", "eventName", "serviceId", " nodeId", "resourceid", "objectID", "eventInfo", "NodeURL", "nodeName", "objectid", "eventURL", "nodeURL"], "ipAddr": ["ipAddressri", "epAddrs", " ipAttrs", "ipAddrer", "ipAttrer", "ipAtter", "epaddrer", " ipAttr", "ipAddressrs", "ipAddressp", "ipaddress", "apiAddr", "apiAddri", " ipAddo", "ipaddr", "ipAttri", "apiAttp", " ipAddrs", " ipAdder", "ipaddrs", "apiAddp", "ipAddri", "ipAddo", " ipAtter", " ipChri", " ipChrs", "apiAttri", "ipAdder", "ipAttr", "ipAddl", "ipadder", "ipaddo", "ipChrer", "ipAttrs", "ipChp", "ipAddresso", "ipAddrs", " ipAddress", "ipChl", "ipaddrer", "ipAddressl", " ipAddrer", " ipAtto", "epaddr", "epaddl", " ipChrer", "epaddrs", "epAddl", "apiAddrs", "apiAttr", "ipAddp", "ipAddressrer", "ipAtto", "ipChri", "ipChr", "ipAttress", "ipAddressr", "ipaddl", "epAddr", "ipAddress", " ipAddri", "ipAddresser", "ipaddri", "ipAttp", "apiAttrs", "ipChrs", " ipChr", "epAddrer"], "serviceID": ["featureID", "eventIDs", "serviceIDs", "networkID", " serviceUID", "siteId", "ServiceIDs", "ServiceName", "featureId", "imageUID", "ServiceID", "roleId", "serviceUID", "featureUID", "ServiceIP", " serviceName", "networkid", "eventIP", "ServiceId", "imageId", "eventid", "networkId", "serviceid", "roleid", " serviceId", " serviceIP", "siteIP", "serviceName", "roleIP", " serviceIDs", "eventId", "serviceIP", "eventName", "serviceId", "ServiceType", "siteid", "imageID", " serviceid", "networkName", "eventType", "roleID", " serviceType", "serviceType", "siteID"], "eventTime": [" eventtime", "serverTime", "servertime", "eventInfo", "serverName", "EventInfo", "Eventtime", "serverInfo", "EventName", " eventInfo", "EventTime", "eventtime", " eventName", "eventName"], "log": ["base", "class", "output", "http", "net", "host", "tag", "en", "debug", "model", "crit", "get", "gen", "lex", "it", "url", "bug", "stop", "where", "info", "feed", "lock", "pl", "use", "cache", "proxy", "w", "level", "cl", "exp", "full", "og", "contract", "tool", "event", "path", "job", "entry", "LOG", "ge", "write", "loop", "stat", "cat", "or", "writer", "blog", "low", "sign", "plug", "error", "pg", "cell", "lo", "user", "c", "l", "pool", "thread", "key", "type", "ger", "config", "put", "port", "call", "db", "Log", "pe", "reg", "guard", "f", "sec"], "dbConn": ["dbConnection", "sqlConn", "libconn", "logConnect", "dbconn", "libConn", "logColl", "logConn", "sqlSession", "dbCt", "DbCon", "dbSession", " dbCs", "DbConnection", "dbDr", " dbConnect", "DbConn", " dbCt", "dbCtrl", " dbDr", "dbNC", "dbCo", "DBCs", "DbConnect", "DBConn", "dbCs", " dbCo", "dbConnect", "databaseDr", "sqlCtrl", "sqlNC", "DbCtrl", "DbCt", "DbSession", "sqlCo", "databaseConn", "webNC", "databaseConnection", "DbCs", " dbSession", "webCtrl", " dbNC", "logCtrl", " dbConnection", "libCt", "DBConnect", " dbconn", " dbCtrl", "dbColl", "sqlCt", "webConn", "DbCo", " dbColl", "databaseconn", "DbDr", " dbCon", "Dbconn", "DBCt", "webCt", "sqlconn", "libCon", "DbColl", "dbCon"], "getNextOutageIdStmt": ["getNextOutageIDSMT", "getNextOutageIdCr", "getNextOutageIDStMT", "getNextOutageIDStmt", "getNextOutageIdstmt", "getNextOutageIdCMT", "getNextOutageIdStr", "getNextOutageIdSmt", "getNextOutageIDSnt", "getNextOutageIdSb", "getNextOutageIdSr", "getNextOutageIDStnt", "getNextOutageIDSb", "getNextOutageIdstMT", "getNextOutageIDSmt", "getNextOutageIDStb", "getNextOutageIdCnt", "getNextOutageIdRmt", "getNextOutageIDSr", "getNextOutageIdStb", "getNextOutageIdSnt", "getNextOutageIdstr", "getNextOutageIdRb", "getNextOutageIDStr", "getNextOutageIdstnt", "getNextOutageIdRr", "getNextOutageIdCb", "getNextOutageIdSMT", "getNextOutageIdCmt", "getNextOutageIdRMT", "getNextOutageIdStMT", "getNextOutageIdStnt"], "outageID": ["outageId", "inageID", "OutageID", "OutrageId", "outageSecret", "OutrageID", "OutageName", "OutageId", "outflowId", "outrageSecret", "OutrageHandle", "outrageURL", "outAGESecret", "OutageSecret", "inrageURL", "inageId", "outageHandle", "outagementName", "outageURL", "inageURL", "outAGEID", "outflowHandle", "outAGEURL", "outAGEUID", "outAGEName", "outissueID", "outrageId", "inageUID", "inrageId", "OutrageSecret", "outflowID", "inrageUID", "outflowName", "outagementHandle", "outrageName", "outAGEId", "inrageID", "outageName", "outagingName", "outagingId", "OutrageName", "outagingID", "outageUID", "outissueURL", "outrageHandle", "outrageID", "outissueId", "outagementID", "outagingSecret", "outagementId", "outrageUID", "outissueUID", "OutageHandle"], "seqRS": ["reqRL", "seqRs", "reqRR", "colRS", "sequRC", "structrs", "sequRS", " seqMR", " sequenceMR", "structRS", "colRT", " seqRL", "sequTS", "sequenceRS", " sequenceRT", "sqMR", "invSR", "reqRS", "seqRC", "eqRR", "reqRC", "invRs", "reqRT", "colRR", "seqrs", "eqRT", " seqTS", " seqRC", "sequencers", "sqRT", "sqRC", "sqRS", "structSR", "sequenceSR", "seqRT", "seqRR", "invrs", "colRs", "reqTS", "seqRL", " sequenceRS", "seqTS", " seqRT", "eqRS", "invRS", "sequRL", "seqSR", "sequenceRs", "reqRs", "seqMR", " sequenceRC", "eqRs", "structRs"], "newOutageWriter": ["newoutureReader", "newoutureWrite", "newOutartInfo", "newOutlineWriter", "newOutrageWriter", "newInflowWriter", "newOutflowReader", "newOutrageRW", "newOutageRW", "newInageRW", "newInflowWrit", "newOutrageWrit", "newouturewriter", "newOutpaceRW", "newOutflowwriter", "newExagewriter", "newExlinewriter", "newOutageWrit", "newOutpaceWriter", "newOutissuewriter", "newInageWrite", "newExageWrite", "newoutureInfo", "newExageReader", "newOutpointRW", "newOutageWrite", "newOutpointWriter", "newOutagementWrit", "newoutageInfo", "newOutureInfo", "newOutflowWrite", "newOutureWrite", "newOutflowWrit", "newOutpointReader", "newOutissueReader", "newOutflowWriter", "newOutpaceReader", "newoutageWrite", "newOutageInfo", "newInflowRW", "newOutflowRW", "newInflowWrite", "newOutartWriter", "newoutageReader", "newoutagewriter", "newOutissueWrite", "newOutissueWriter", "newOutagementRW", "newOutrageWrite", "newExlineReader", "newOutlineWrite", "newOutureWriter", "newExageWriter", "newOutagementWriter", "newOutageReader", "newInageWrit", "newOutflowInfo", "newOutagewriter", "newOutpacewriter", "newOutureReader", "newExlineWrite", "newInageWriter", "newOutartRW", "newOutureRW", "newOuturewriter", "newOutpointWrite", "newoutureRW", "newOutagementWrite", "newOutlinewriter", "newOutlineReader", "newoutureWriter", "newoutageWriter", "newoutageRW", "newExlineWriter", "newOutartWrite"]}}
{"id1": "6371589", "id2": "5725177", "code1": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    protected <T> T execute(final HttpMethod method, final String url, Parameters parameters, final Handler<T> handler) throws FoursquareException {\n        HttpURLConnection connection = null;\n        try {\n            switch(method) {\n                case GET:\n                    connection = openConnection(url.concat(\"?\").concat(formEncode(parameters)));\n                    connection.setRequestMethod(\"GET\");\n                    connection.connect();\n                    break;\n                case POST:\n                    connection = openConnection(url);\n                    connection.setRequestMethod(\"POST\");\n                    connection.setDoOutput(true);\n                    connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                    connection.connect();\n                    final OutputStream out = connection.getOutputStream();\n                    out.write(formEncode(parameters).getBytes());\n                    out.flush();\n                    out.close();\n                    break;\n            }\n            final int statusCode = connection.getResponseCode();\n            if (statusCode / 100 != 2) {\n                final Error error = parseBody(connection.getErrorStream(), new ErrorHandler());\n                if (error == null) throw new FoursquareException(connection.getResponseMessage()); else if (\"error\".equals(error.getType())) throw new FoursquareException(error.getMessage()); else if (\"unauthorized\".equals(error.getType())) throw new AuthenticationException(error.getMessage()); else if (\"ratelimited\".equals(error.getType())) throw new RateLimitingException(error.getMessage()); else throw new FoursquareException(connection.getResponseMessage());\n            }\n            return parseBody(connection.getInputStream(), handler);\n        } catch (final IOException e) {\n            throw new FoursquareException(e);\n        } catch (final ParserConfigurationException e) {\n            throw new FoursquareException(e);\n        } catch (final SAXException e) {\n            throw new FoursquareException(e);\n        } finally {\n            if (connection != null) connection.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"insertUser": ["createUser", " insertPerson", " insertUsers", "createUsers", "InsertPerson", "createPassword", "insertUsers", "InsertUser", "InsertPassword", "createPerson", " insertPassword", "insertPerson", "InsertUsers", "insertPassword"], "newUsers": [" newMembers", "path", "newusers", "NEWPeople", "oldusers", "oldUser", "s", "oldPeople", "NewUser", "Newusers", "newPeople", "oldUsers", "NewMembers", "All", "NEWusers", "NEWMembers", " newUser", "Get", " newPeople", "NEWUsers", "NewUsers", "newMembers", "newUser", "_", "New", "this", " newusers", "NewPeople"], "pass": ["push", "mess", "clean", "mail", "act", "col", "pool", "fr", "wd", "en", "fail", "post", "gram", "session", "PASS", "pp", "ress", "Pass", "log", "gen", "row", "ass", "oss", "port", "pos", "cr", "pack", "ss", "access", "sl", "skip", "asses", "pa", "secret", "parse", "conf", "sw", "def", "pas"], "realmPass": ["realmsFail", "realmsPack", "realMLink", "realmPack", "realsmPass", "permPASS", "almsFail", "realmpass", "permPass", "permAuth", "perMPack", "realmConf", "almsPass", "realnmAuth", "realmsPassword", "realarmPassword", "almConf", "palmPass", "realnmSecret", "permPack", "palMFail", "palMPass", "perfAuth", "realfSecret", "almsConf", "realmePass", "realMPassword", "realmPassword", "perMPass", "realsmPack", "reallFail", "realmsTrans", "palMPassword", "realMPass", "permLink", "permSecret", "realarmSecret", "palMpass", "realarmPass", "perfSecret", "perMPassword", "perMLink", "realMFail", "realarmpass", "realmPASS", "realnmPass", "realMpass", "palmFail", "reallPass", "realfPASS", "realmsPass", "realsmLink", "almsTrans", "realarmPASS", "realmsLink", "permPassword", "realsmPassword", "realmSecret", "reallTrans", "realamFail", "perfPASS", "realmeFail", "reallConf", "realmeTrans", "perfPass", "realarmAuth", "realmFail", "palmPassword", "realarmFail", "almTrans", "palmpass", "realamPassword", "almPass", "realfAuth", "almFail", "realfPass", "realmsConf", "realmeConf", "realMPack", "realamPass", "realmLink", "realampass", "realmTrans", "realmAuth", "realnmPASS"], "userDirs": ["UserDirection", "userEdir", "UserDirs", "userIdirection", "userEdirs", "UserIdirs", "UserIdir", "userEdict", "UserIdict", "userDirirs", "userDict", "UserDir", "userIdict", "userDirir", "UserIdirection", "UserDict", "userDir", "userEdirection", "userDirirection", "userDirection", "userIdirs", "userIdir", "userDirict"], "iter": ["ite", "upper", "zip", "sel", "handler", "loader", "i", "itter", "outer", "feed", "n", "master", "http", "ie", "inse", "inter", "oper", "inner", "end", "slice", "walker", "driver", "ter", "ipper", "gener", "keeper", "ler", "exit", "loop", "er", "izer", "its", "reader", "Iterator", "ner", "inc", "ir", "li", "itor", "vis", "icer", "ator", "Iter", "keep", "coll", "chain", "it", "sl", "cher", "parse", "err", "ul", "finder", "imp", "liter", "f", "former", "iv", "enter"], "user": ["resource", "User", "match", "rule", "member", "not", "model", "open", "file", "used", "row", "force", "url", "comment", "custom", "module", "string", "self", "server", "lock", "by", "option", "site", "result", "account", "post", "use", "source", "up", "parent", "route", "page", "object", "plugin", "fill", "name", "e", "full", "person", "theme", "service", "order", "job", "replace", "message", "per", "ru", "record", "line", "using", "er", "session", " result", "users", "other", "group", "request", "u", "or", "creator", "change", "image", "who", "to", "blog", "word", "ver", "update", "valid", "author", "profile", "USER", "current", "project", "character", "manager", "usr", "date", "data", "usa", "log", "human", "me", "from"], "realm": ["realM", "alm", " realp", "Realp", "Realme", "palme", "alf", "palM", "realp", " realme", "elema", "alma", "palms", "realma", " realma", "realf", "RealM", "Realm", " realf", "palm", " realM", "elem", "eleme", "palp", "elef", "alme", "realme", "Realms"], "username": ["resource", "token", "sudo", "month", "whatever", "host", "ident", "database", "uu", "picture", "Password", "component", "nom", " nickname", "attr", "phone", "hello", "title", "family", "ername", "mobile", "url", " password", "string", "address", "subject", "account", "driver", "ame", "begin", "source", "ug", "alias", "sword", "route", "plugin", "name", "nick", "person", "localhost", "consumer", "attribute", "phrase", "direction", "directory", "uri", "mother", "length", "time", "password", "email", "session", "true", "language", "null", "verb", "purpose", " slug", "method", "property", "duration", " hashtag", "character", "profile", "filename", "description", "uid", "slave", "current", "gender", "manager", "su", "usr", "login", "config", "ruby", "nil", "href", "ghost", "rights", "home", "prefix", "role", "human", "auth", "me"], "ph": [" ssh", "rah", "her", "pkg", "pal", " mg", "gh", "bh", "per", "iph", "ht", "kh", "phil", "prot", "php", "mph", "pl", "prof", " arch", " che", " poly", "password", "fam", "ap", " auth", "arch", "uth", "rh", "phi", "eth", "eph", "wh", "hp", "ch", "li", " exp", " sh", " p", "cl", "mm", "h", "oph", "p", "fo", "Ph", "sl", "hi", "th", "sh", "pa", "pe", " guide", "auth", "PH", "pha", "conf", "hw", "aph", "phrase"], "realms": ["alm", "alns", "almes", "realmes", "Realmes", "palmes", "alms", "palms", " realmes", "Realfaces", "realns", "realfaces", "Realns", "Realm", "palm", " realfaces", "palfaces", "Realms", "palns"], "realmName": ["agmPath", "realnNames", "realmN", "workmsCode", "workmName", "realmsPart", "workmCode", "realmePath", "workmsN", "agmsNames", "realmsN", "workmsName", "realmeNames", "realmeName", "agmName", "realmeString", "realcmCode", "realnName", "realrmName", "realnPath", "realrmCode", "realrmPart", "realmsPath", "realmPath", "agmsPath", "realmsNames", "agmString", "agmsString", "realmsName", "workmPart", "agmNames", "realcmName", "workmsPart", "realnString", "realmsCode", "realrmN", "realmCode", "realcmPart", "agmsName", "realmString", "workmN", "realcmN", "realmPart", "realmNames", "realmsString"], "psImpl": ["ptyFactory", "sqlFactory", "psimpl", "psBuilder", "sqlBuilder", "psFactory", " connimpl", " connFactory", "ptyImpl", "ptyBuilder", "ptyimpl", "sqlImpl", "sqlimpl", " connImpl", " connBuilder"], "iterator": ["loader", "outer", "choice", "entry", "sequence", "inter", "inner", "forward", "instance", "walker", "ter", "gener", "ui", "adder", "Iterator", "collection", "li", "append", "ator", "size", "creator", "it", "stream", "random", "former", "enter"]}}
{"id1": "14390569", "id2": "11341711", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"title": ["string", "id", "resource", "itle", "subject", "message", "filename", "description", "version", "html", "layout", "chapter", "alpha", "content", " Title", "part", "type", "license", "section", "data", "text", "body", "itles", "page", "size", "ppa", "format", "msg", "name", "TIT", "header", "desc", "image", "heading", "label", "prefix", "details", "notes", "theme", "url", "summary", "Title", "phrase", "term"], "imageURL": ["fileurl", " imageURI", "fileUrl", "ImageURL", "pictureurl", "pictureURL", "mediaUrl", "fileURL", "ImageUrl", "imgURL", "filePath", " imageUrl", " imageurl", "mediaURL", "imgURI", "fileURI", "pictureURI", "ImagePath", "imagePath", "imageUrl", "mediaURI", "pictureUrl", "imgPath", "imageURI", "ImageURI", "imageurl", "imgUrl"], "jd": ["zdd", "ajdo", "ajb", "jobb", "jdh", "ajdos", " jdom", "jobdo", "jds", " jdd", "argdo", "adjb", "ajD", "jobd", "ssdo", "qd", "argf", "ze", "ssd", "zl", "ssdi", " jdh", "jdd", "jD", "Jdos", "Jf", "Jdo", "jsb", " jds", " jD", " jf", "jdom", " jdo", "jdo", "Je", "jackd", "zb", " jdl", "jackf", "JD", "Jdom", "ajdi", "Jl", "qb", "Jds", "ajf", "jjdh", "qdh", "Jb", "jackdd", "zdo", "jdl", "jf", "argdl", "jdos", "adjdos", " jdi", "adjdo", "ssD", "jdi", "jjd", "zd", "jsdh", " je", "qdo", "ajdh", "jsd", "ajd", "jsdo", "qdom", "jjb", "Jd", "jjdo", "je", "jobD", "zds", "adjd", "jackb", "zf", "argd", "ajdl"], "jl": ["uj", "lu", "lf", "iji", "kl", "NJ", "dj", "lp", "jc", "lb", "wl", "j", "eb", "iol", "fp", "l", "il", "elly", "el", "ld", "hl", "dl", "elt", "syn", "ja", "ji", "oji", "bj", "li", "nl", "ll", "cli", "jon", "jj", "igl", "chal", "bn", "Label", "kj", "label", "zl", "bl", "kel", "JM", "adj", "vd", "lv", "kn"], "icon": [" image", "info", "core", "css", "eye", "n", "token", "note", "resource", "uri", "on", "ic", "fc", "ui", "content", "picture", "ion", "iao", "alias", "Icon", "text", "gn", "img", "pic", " Icon", "size", "plugin", "uni", "bn", "header", "io", "image", "icons", "ann", "action", "label", "artist", "ico", "url", "cn", "png", "cha"], "chooser": ["close", "boosen", "jooses", "Choosen", "Choer", "jooder", " choressor", "jooser", "boressor", "choressor", "Chooser", "choosen", "dialer", "choer", "dialoser", " chooses", "Chooses", "closen", "cler", "dialose", "boose", "choose", "booser", "chooses", " chooder", "Choose", " choose", "clressor", "dialosen", " choosen", "chooder", "joose", "closer", "Chooder"], "jp": [" j", " tmp", " pa", " JM", "j", " pane", "Panel", " ax", " obj", " plugin", "ja", "ji", " dj", " cm", "bj", " js", " cp", " app", " bar", " bridge", " je", " gp", " np", " pic", " sp", " mp", " dock", "JP", " robot"], "jb": ["ajf", " jsb", "ajb", "jsbb", "jf", "djcb", "jcb", "jsb", "qsb", "jbb", " jf", " jbb", "ajsb", "ajcb", "djb", "qcb", "jsd", "djbb", "qf", "djd", " jcb", "qb", "jscb"], "e": ["event", "ee", "ie", "c", "et", "te", "ception", "in", "ec", "ce", "je", "de", "exc", " E", "x", " ate", "ae", "E", "t", " fe", "ctx", "a", "ev", "pe", "v", " Event", "f"], "returnVal": ["ReturnVal", " returnVAL", "replyval", "replyValue", "resultVal", "replyVAL", "ReturnValue", "returnValue", "returnVAL", "resultNum", " returnNum", "resultval", "ReturnVAL", "replyVal", "resultValue", "returnNum", "returnval", " returnValue", "Returnval", "ReturnNum", " returnval"], "file": ["zip", "base", "handler", "http", "document", "picture", "die", "rule", "lib", "model", "build", "get", "force", "files", "url", "comment", "module", "info", "buffer", "lock", "part", "use", "load", "binary", "dir", "live", "work", "parent", "page", "object", "name", "full", "unit", "b", "play", "letter", "path", "directory", "core", "ile", "message", "line", "File", "queue", "book", "show", "body", "image", "io", "function", "future", "auto", "single", "ban", "user", "filename", "fp", "l", "il", "pool", "type", "FILE", "data", "out", "local", "log", "folder", "po", "home", "db", "pe", "parse", "f"], "fileName": ["imagename", "FilePath", "binaryName", "resourceName", "fileUrl", "resourceInfo", "filename", "filePath", "singleInfo", "fileInfo", "fileType", "resourcename", " fileType", " filename", "Filename", "binaryUrl", "singlePath", " filePath", " fileInfo", "binaryPath", "FileType", " fileUrl", "FileInfo", "imagePath", "singleName", "singlename", "imageUrl", "singleType", "resourcePath", "FileName", "imageName", "imageInfo"], "ext": ["xt", "EXT", "path", " extension", "class", "qt", "ex", "ace", "enc", "oct", "version", "eng", "feat", "extra", "txt", "xp", "type", "lib", "ct", "ch", "ension", "fb", "p", "Ext", "format", "name", "desc", "ax", "t", "exp", "word", "alg", " Ext", "pe", "abc", "v", "obj", "f", "phrase", "sec", "orig"], "i": ["info", "bis", "id", "uri", "pi", "ini", "c", "j", "z", "ri", "o", "si", "ui", "is", "ii", "ment", "ti", "phi", "ion", "li", "ip", "mi", "p", "bi", "u", "ai", "ci", "I", "io", "m", "xi", "gi", "di", "a", "v", "y", "ni", "b", "iu", "multi", "mini", "cli", "api"], "doIt": [" doNot", " doit", "hoIt", "doit", " doYou", " doIT", " doWhich", "addNot", "diIt", "skipit", "hoYou", "doIts", "odoIt", "skipIts", "skipIt", "addit", "poIt", "diit", "DOIT", "odoit", "doWhich", "odoIT", "odoWhich", "doIT", " doIts", "DOWhich", "hoit", "poIT", "doYou", "hoIT", "skipIT", "diIts", "DOit", "doNot", "DOIt", "diIT", "addIt", "addIT", "odoNot", "poit", "poYou"], "src": ["impl", "path", "rest", "sel", "ssl", "sc", "input", "cmp", "rc", "slice", "socket", "rel", "fi", "cb", "loc", "fc", "sub", "ff", "ources", "inst", "rs", "split", "gb", "sync", "cdn", "rb", "source", "sb", "uc", "target", "buf", "dist", "r", "upload", "conv", "attr", "tmp", "Dest", "bb", "sq", "storage", "desc", "gz", "sth", "rx", "sup", "sl", "secure", "ctx", "pull", "url", "bc", "us", "stream", "b", "st", "sn", "cur", "ource", "RC", "cos", "img"], "dest": ["rest", "output", "gd", "uv", "cont", "later", "destroy", "trans", "wd", "done", "inst", "dc", "usr", " Dest", "std", "exit", "die", "comb", "cdn", "source", "proc", "wb", "dir", "ctr", "uc", "target", "dist", "config", "route", "Dest", "tmp", "img", "gen", "desc", "dev", "home", "sup", "di", "dep", "prop", "st", "dat", "loc"]}}
{"id1": "5035872", "id2": "16621503", "code1": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "code2": "    public static ArrayList<String> loadURLToStrings(URL url, int maxLines, String userAgent, int timeout) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (userAgent != null && userAgent.trim().length() > 0) {\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n        } else {\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (compatible; astrominer/1.0;)\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n        }\n        connection.connect();\n        return loadURLToStrings(connection, maxLines);\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "src": ["path", "root", "sin", "sel", "input", "sc", "uri", "resource", "copy", "rc", "http", "filename", "slice", "loc", "dest", "s", "inst", "in", "rb", "source", "sit", "sb", "dist", "upload", "config", "data", "file", "conn", "storage", "ls", "image", "sl", "files", "url", "stream", "b", "obj", "st", "iv", "this", "download", "img"], "dst": [" dsts", "Ddest", "ddest", "addest", "fdds", " dcr", "dbds", "dbot", " ddest", "fdst", "adcr", "Dsts", "tdst", "Dcr", "dot", "tdot", "dput", "dbput", "dbst", "dsts", "fdot", "fdput", "Dst", "dcr", "adsts", "tdds", "adst", "tdput", "dds"], "inChannel": ["binStream", "inputChannel", "innerStream", "INchannel", "binchannel", "inStream", "againCamera", "againChannel", " inchannel", "inputchannel", "inMessage", "binConnection", "inchannel", "binChan", "outContext", "outMessage", "againChan", "InChan", "loginChan", "loginChannel", " inMessage", "inputChan", "Inchannel", "INChan", "outStream", "incChan", "inContext", "outchannel", "innerChannel", "incStream", "innerConnection", "inputConnection", "outChan", "againStream", "inChan", "InChannel", "loginCamera", "innerChan", "inputStream", "InStream", "outConnection", "binChannel", "INStream", "inCamera", " inConnection", "INChannel", " inContext", " inStream", "InContext", "inConnection", "incCamera", " inChan", "incChannel", "loginStream", "INConnection", "inputMessage"], "outChannel": [" outContext", "offChannel", "OutStream", "inputChannel", "inStream", "againChannel", "inputchannel", "OutChannel", "inchannel", "outContext", " outConnection", "againChan", "againConnection", "OutChan", "inputChan", " outWriter", "outStream", "inContext", "outchannel", "outQueue", "offWriter", "againStream", "outChan", "inChan", "outputStream", "outputChannel", "outputchannel", "inputStream", "outGate", "inQueue", "outConnection", "againGate", "inWriter", "againQueue", "Outchannel", "againchannel", " outGate", " outQueue", "offContext", "inConnection", "outputChan", "inGate", " outStream", "offChan", "outWriter", " outchannel", " outChan"], "result": ["event", "response", "continue", "results", "ure", "res", "cup", "current", "match", "length", "ault", "done", "pass", "ret", "func", "true", "cache", "use", "diff", "r", "default", "work", "data", "math", "complete", "test", "folder", "or", "status", "card", "function", "success", "array", "false", "comment", "cash", "compl", "future", "err", "successful", "Result", "found", "f", "error", "valid"]}}
{"id1": "12454178", "id2": "8024375", "code1": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"alterar": [" crear", " celebra", " cryar", " cultivAr", " celebrAr", " celebrar", " cultivaran", " cultivar", " crearan", " crea", " cryaran", " celebraran", " cryAr", " creAr", " crya", " cultiva"], "t": ["xt", "qt", "tc", "i", "att", "tm", "n", "ta", "c", "et", "table", "o", "l", "s", "wt", "trans", "rt", "te", "in", "tower", "dt", "nt", "at", "type", "tools", "d", "unt", "ti", "the", "target", "ut", "flat", "x", "p", "ant", "ts", "let", "u", "template", "e", "tp", "tree", "m", "ot", "to", "it", "tw", "T", "tr", "tt", "this", "you", "v", "y", "det", "st", " mt", "tf", "bolt", "f", "pt", "tool"], "stmt": ["ustmt", "strmn", "stau", "strm", " stau", "swmd", "putmd", "Stmm", "spt", " stnt", " stmb", "Stbm", "istmt", "ctgr", "Strm", " stmm", "strmt", "tmt", "Stct", " stpt", "tdb", " stmd", "swbm", "tpt", "istau", "stmd", "putnt", "Stv", "Stmb", "stpt", "strau", "stbm", "stmr", "formmt", "ustau", "swmt", "ctmb", "Stmd", "ctmt", "stv", "istmn", "strdb", "stgr", " stdb", "tmr", " strm", "stct", "Stgr", " stgr", " stbm", "formv", "istdb", "smr", "formrm", "stmm", "ustnt", "Stau", "formmm", " stv", "putmt", "ustmd", "ctct", " stmn", " stmr", "sdb", "stmn", "stmb", "stdb", "Stmt", "putau", "swau", " stct", "smt", "stnt"], "sql": ["where", "zip", "string", "base", "job", "serv", "setup", "lock", "result", "limit", " SQL", "s", "shell", "sol", "query", "database", "dl", "params", "expression", "mt", "stat", "pr", "q", "seed", "up", "ql", "log", "sq", "conn", "insert", "lambda", "ls", "db", "sl", "details", "QL", "url", "plan", "SQL", "printf", "statement", "cmd"], "id_disciplina": ["id_disciini", "id_Disciplineina", "id_disciino", "id_discomplino", "id_disrequINA", "id_distciplinea", "id_disrequini", "id_disciplineissa", "id_distciplini", "id_disciinea", "id_disciplino", "id_disciplineinea", "id_disciplini", "id_disciana", "id_discomplana", "id_discomplinea", "id_disciina", "id_Disciplissa", "id_discomplissa", "id_discomplini", "id_disciplineana", "id_disciplineino", "id_distrequinea", "id_discomplina", "id_distciini", "id_disrequina", "id_distrequINA", "id_disciplINA", "id_distciina", "id_distciplana", "id_Disciplineini", "id_distciplINA", "id_Disciplina", "id_disciINA", "id_distrequina", "id_disciplineina", "id_disciplinea", "id_distciplina", "id_distciino", "id_distrequini", "id_disciplissa", "id_disciplineINA", "id_Disciplineinea", "id_disciplana", "id_disciplineini", "id_Disciplini", "id_distciplino", "id_disguissa", "id_distciana", "id_Disciplineissa", "id_disguinea", "id_disguini", "id_disrequinea", "id_Disciplinea", "id_disguina"], "item": ["event", "info", "order", "index", "article", "i", "id", "server", "entry", "site", "result", "o", "instance", "queue", "items", "er", "bar", "at", "type", "reader", "source", "q", "r", "other", "parent", "data", "seller", "page", "object", "request", "p", "ip", "or", "hop", "name", "edit", "e", "m", "action", "it", "area", "service", "url", "pe", "unit", "v", "container", "Item"]}}
{"id1": "8216539", "id2": "17792212", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileContentAsStr", "getFilecontentInString", "getFilecontentAsText", "getFilecontentInStream", "getFileContentInText", "getFileContentasStream", "getFileContentasStr", "getFileContentInStream", "getFileContentFromStream", "getFileContentasString", "getFilecontentAsStream", "getFileContentFromString", "getFilecontentInStr", "getFileContentAsText", "getFileContentFromText", "getFileContentAsStream", "getFilecontentAsStr", "getFileContentFromStr", "getFileContentInString", "getFileContentInStr", "getFilecontentInText", "getFileContentasText", "getFilecontentAsString"], "filePath": [" fileStr", "FilePath", "baseLocation", "baseUrl", "resourceName", "fileUrl", "resourceLocation", "basePath", "singlepath", "FileStr", "FileUrl", "resourcepath", "singleLocation", "fileName", "singlePath", " filepath", "fileStr", " fileUrl", "baseName", "baseStr", "filepath", "Filepath", "fileLocation", "FileName", "basepath", "singleUrl", "resourcePath", "FileLocation"], "encoding": ["decoded", "enclocking", "Encoded", "languageging", "Encryption", "languagepling", "encging", "decasing", "equoding", "coding", "encpling", "Encging", "decoding", "Encoding", "casing", "languageoding", "encryption", "coded", "equging", "equpling", "Enclocking", "Encpling", "Encasing", "decryption", "languagelocking", "encasing", "equlocking", "encoded", "cryption"], "testURL": ["testingURL", "appurl", "fileUrl", "testingUR", "TestUR", "fileURL", "fileRL", "testRL", "shortTL", "testingRL", "shorturl", "testUrl", "Testurl", "testTL", "testingurl", "testingURI", "appUR", "testUR", "testingUrl", "fileURI", "TestURL", "shortUrl", "appUrl", " testRL", " testTL", " testurl", "shortURL", "testURI", " testURI", "appURL", "testurl", "testingTL", "TestUrl", " testUrl"], "input": ["path", "error", "ou", "ssl", "i", "temp", "output", "resource", "feed", "qa", "enc", "rc", "entry", "http", "element", "op", "ink", "ack", "act", "current", "socket", "inner", "result", "instance", "flow", "bin", "active", "in", "dc", "raw", "form", "client", "type", "reader", "source", "binary", "Input", "connection", "inf", "inside", "upload", "inc", "config", "data", "text", "out", "parent", "through", "file", "acl", "get", "null", "conn", "init", "exec", "image", "but", "pull", "url", "stream", "audio", "ac", "wrapper", "xml", "this", "api", "img"], "sw": ["nw", "SW", "rw", "sk", "sf", "sc", "wr", "rc", "rew", "wp", "now", "fp", "ew", "wt", "sm", "en", "Sw", "wrap", "ws", "sa", "sb", "wb", "sv", "work", "w", "iw", "web", "WS", "aw", "io", "writer", "cr", "rx", "sl", "tw", "ib", " SW", "sh", "stream", "we", "wrapper", "sn", "hw", "ow", "wx", "ww"]}}
{"id1": "14303294", "id2": "22338097", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 1, "substitutes": {"getServerHash": ["getserverSHA", " getServerSalt", "getserverAddress", "getserverSalt", "getServerSalt", "getSecureHash", "getserverHash", "getSecureSalt", "getSecureAddress", "getSessionHash", " getServerAddress", " getSecureSalt", " getSecureAddress", "getServerSHA", "getServerAddress", "getSessionAddress", "getSessionSHA", "getSecureSHA", " getSecureSHA", "getSessionSalt", " getServerSHA", " getSecureHash"], "passwordHash": ["privatePassword", "Passwordhash", "privateHash", " passwordSalt", "PasswordPass", "passwordhash", "passwordCode", " passwordhash", "privatehash", " passwordPassword", " passwordPass", "passwordPassword", " PasswordPass", "PasswordPassword", "privateSalt", " PasswordCode", "PasswordCode", " passwordCode", "passwordSalt", "PasswordHash", " PasswordHash", "passwordPass"], "PasswordSalt": [" passwordSalt", "PASS256", "PASSHash", "password256", "Password256", "passwordSecret", " passwordPassword", "PASSPassword", "PasswordSecret", "passwordPassword", "PASSSalt", "PasswordPassword", " passwordSecret", "passwordSalt", "PasswordHash", " Password256", " PasswordHash", " PasswordSecret", " PasswordPassword"], "hash": ["string", "address", "buffer", "sum", "base", "her", "response", "copy", "user", "message", "kh", "result", "number", "hex", "Hash", "html", "pool", "ash", "key", "content", "password", "cache", "mac", "sha", "value", "build", "work", "data", "check", "h", "size", "search", "row", "log", "dig", "change", "image", "ha", "array", "url", "update", "sh", "auth", "block", "crypt", "error", "code"], "digest": ["Digester", "signester", "digher", "Diger", "hashener", "signest", "integest", "generester", "signer", "generested", " digested", " diger", "signger", " digusher", "mdusher", "hashest", "mdest", "mdested", "hasher", " digger", "digester", "signher", "Digener", "hashester", "Digher", "mdester", "digger", "digested", "integester", " digall", "Digest", " digher", "Digusher", "digener", "digusher", "generall", "diger", "integall", " digester", "Digger", "Digested", "generest", "digall", " digener", "integested"]}}
{"id1": "20310134", "id2": "18696387", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyChannel", "copyChannel", "CopyFile", "copyfile", "transferfile", "transferFiles", "transferChannel", " copyFiles", "Copyfile", " copyChannel", "CopyFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "base", "buffer", "i", "input", "id", "ex", "lock", "ic", "c", "inner", "as", "l", "ins", "bin", "query", "reader", "source", "login", "min", "diff", "inc", "work", "config", "file", "data", "again", "name", "m", "image", "io", "In", "url", "lin", "inn"], "out": ["string", "base", "server", "output", "n", "ex", "resource", "user", "plain", "c", "OUT", "outs", "o", "write", "off", "cache", "dot", "connection", "default", "w", "file", "page", "x", "p", "conn", "again", "name", "exec", "Out", "io", "writer", "image", "call", "prefix", "ext", "v", "b", "external", "point", "img"], "inChannel": ["binStream", "inputChannel", "INchannel", "iniChannel", "binchannel", "inStream", "insConnection", " inchannel", "inchannel", "binChan", "InQueue", "InChan", "loginChan", "loginChannel", "Inchannel", "iniStream", "INChan", "outStream", "inputChan", "iniChan", "outchannel", "outQueue", "inputConnection", "outChan", "inChan", "InGate", "InChannel", "InStream", "inputStream", "insStream", "inQueue", "binChannel", "INStream", "insChannel", "INChannel", " inQueue", "inConnection", " inChan", "insChan", "loginchannel", "binGate", "loginStream", "INConnection", "iniGate", "inGate"], "outChannel": ["netChan", "ouChan", "inStream", "netGate", "netChannel", "outputGate", "OutConnection", "OutChannel", "ouChannel", "inchannel", " outChar", " outConnection", "ouchannel", "OutChan", "ouGate", "outStream", "outChar", "outchannel", "outChan", "inChan", "outputStream", "netStream", "outputchannel", "outputChannel", "outConnection", "Outchannel", " outGate", "inGate", "outputChan", "inConnection", " outStream", "outputChar", "outGate", "inChar", " outchannel", " outChan"]}}
{"id1": "6371607", "id2": "21013026", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    private InputStream getPageStream(String query) throws MalformedURLException, IOException {\n        URL url = new URL(baseUrl + query + \"&rhtml=no\");\n        URLConnection connection = url.openConnection();\n        connection.connect();\n        InputStream in = connection.getInputStream();\n        BufferedInputStream bis = new BufferedInputStream(in);\n        return bis;\n    }\n", "label": 0, "substitutes": {"removeRealm": ["removeLocalM", "removeLocalam", "removeRealme", "removeRelms", "removerealme", "removeRealM", "removeBroadm", "removeLocalms", "delRealm", "removeRelam", "delBroadM", "delRealM", "deleteRealam", "delRealms", "removeScheme", "deleterealM", "removeRelm", "deleteRealm", "removerealM", "removeBroadms", "removeSchem", "removeBroadme", "deleteRealms", "removeLocalm", "deleterealms", "removeRealam", "removerealms", "delBroadms", "removeBroadM", "removeRelM", "removeRealms", "removerealam", "deleterealam", "deleterealm", "removerealm", "removeSchems", "delBroadme", "delRealme", "delBroadm", "removeScheM", "deleteRealM"], "realmIds": ["realmRefs", "realMPathids", "realMIds", "realmIDls", "realMIdls", "realmIDList", "realmRefids", "realmInts", "realmRefls", "realmRefList", "realMPathes", "realmIdos", "realMIdList", "realmIntids", "realmIdList", "realMByIdls", "realmByIds", "realmByIdList", "realMIdes", "realmByIdls", "realmRefes", "realmPathids", "realmByIdes", "realMByIdes", "realmIntes", "realMPathos", "realmIdes", "realMByIdList", "realmPathes", "realMByIds", "realmIDs", "realmIdls", "realmPaths", "realmIntos", "realMPaths", "realmRefos", "realmIDes", "realMIdos", "realmPathos", "realmIdids", "realMIdids"], "psImpl": ["csImpl", " psIter", "epsIter", "cssImpl", "qsimpl", "csimpl", " psimpl", "epsHelper", "dsImpl", " psHelper", "cssExpl", "dsHelper", "psHelper", "psimpl", "dsimpl", "qsHelper", "qsImpl", "psIter", " psExpl", "epsimpl", "cssimpl", "epsImpl", "cssIter", "epsExpl", "csHelper", "psExpl"], "iter": ["ite", "index", "upper", "i", "itter", "outer", "cer", "entry", "ie", "inter", "inner", "end", "limit", "walker", "ter", "gener", "el", "line", "sort", "in", "ler", "next", "loop", "er", "izer", "reader", "ner", "inc", "ir", "page", "ator", "iterator", "Iter", "init", "coll", "e", "it", "cher", "parse", "err", "apper", "finder", "former", "list", "enter", "loc"], "realmId": [" realmnHash", "realmOffset", "realmnOffset", "RealmsID", " realmHash", "realmcId", "realmnId", "realmePath", "ironmaId", "RealmName", "realmrId", "realmName", "realdmConfig", "realmInt", "realmPath", "realmsName", "workmNum", "realmeId", "realmid", "ironmRef", "realmConfig", "ironmID", " realmOffset", "realmID", "realdmId", "workmId", "workfID", "realmNum", " realmnConfig", "workfid", "realmnHash", "RealmID", "realmeName", "realrmId", "realmsId", " realmnId", "ironmId", "ironmaRef", "realmHash", "realmrid", "realrmID", "ironmaInt", "workfNum", "realarmPath", "realamid", "RealmPath", "RealmId", "realmRef", "realmcID", "ironmaID", "realfid", "realmrOffset", "workfId", "realfId", "realarmID", "workmid", "realmsPath", "realrmInt", "realmrID", "realmsID", "realmcRef", "realmeID", "realmaID", "realarmId", "realmrHash", "realmaInt", "realdmOffset", "RealmsId", "realarmName", "realmrNum", "realdmHash", "realmaRef", "ironmInt", "realamNum", " realmConfig", "RealmsName", "realfNum", "realmcInt", "workmID", " realmnOffset", "realfID", "RealmsPath", "realrmRef", "realmnConfig", "realamId", "realmaId", "realmrConfig", "realamID"]}}
{"id1": "22411381", "id2": "14317425", "code1": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"stop": ["remove", "close", "release", "pause", "job", " Stop", "quit", "kill", "setup", "Stop", "reset", "end", "find", "run", "destroy", "save", "sleep", "next", "loop", "operation", "work", "get", "delete", "start", "status", "update", "create", "process"], "task": ["class", "temp", "resource", "master", "run", "patch", "match", "tag", "func", "component", "problem", "worker", "element", "module", "point", "server", "clean", "game", "lock", "ack", "query", "sync", "source", "load", "work", "parent", "channel", "route", "Task", "object", "device", "plugin", "test", "complete", "name", "again", "exec", "link", "this", "unit", "contract", "localhost", "process", "event", "job", "tc", "message", "act", "socket", "session", "request", "pack", "app", "question", "trace", "error", "view", "user", "slave", "table", "project", "instance", "thread", "manager", "key", "form", "type", "date", "target", "ask", "config", "data", "status", "t", "action", "call", "role", "command", "block", "tx"], "con": ["remote", "core", "tc", "Conn", "cc", "server", "resource", "CON", "cf", "clean", "cons", "lock", "ran", "rc", "c", "fc", "ctrl", "col", "Con", "co", "query", " conn", "en", "condition", "client", "sync", "cm", "session", "cp", "cache", "cas", "uc", "ion", "connection", "login", "common", "ch", "inc", "conv", "un", "ca", "config", "xc", "log", "null", "conn", "rec", "row", "ain", "coll", "exec", "ci", "cr", "ann", "db", "pc", "commit", "mc", "ctx", "sql", "bc", "ver", "can", "conf", "cn", "connect", "container", "f", "win", "re"], "s": ["ssl", "sum", "sc", "sf", "n", "sys", "fs", "sg", "ks", "ns", "c", "S", "j", "se", "l", "ins", "bs", "si", "o", "su", "is", "rs", "ws", "sb", "r", "ans", "w", "gs", "h", "p", "es", "sq", "u", "search", "submit", "south", "ls", "js", "e", "m", "rows", "ss", "sl", "a", "sql", "ses", "cs", "ds", "os", "f", "ps"], "result": ["event", "info", "sum", "server", "resource", "response", "uri", "rc", "user", "results", "res", "report", "http", "message", "json", "ge", "table", "instance", "record", "manager", "su", "ret", "session", "source", "cache", "rh", "reader", "ner", "r", "ch", "work", "data", "page", "request", "search", "row", "coll", "e", "status", "runner", "success", "db", "details", "ver", "ser", "comment", "ur", "err", "future", "successful", "Result", "error", "sr", "re", "view"], "url": ["string", "path", "base", "address", "job", "id", "uri", "feed", "http", "lr", "l", "host", "location", "URL", "key", "source", "str", "ob", "file", "route", "object", "request", "href", "ls", "e", "image", "link", "sl", "rl", "pull", "Url", "obj", "f", "hub", "loc"], "i": ["uri", "pi", "ini", "ie", "ic", "c", "ri", "o", "l", "si", "ui", "is", "in", "ii", "ori", "qi", "vi", "d", "phi", "r", "ami", "li", "ip", "h", "p", "bi", "u", "ai", "oi", "ci", "e", "io", "I", "m", "eni", "it", "iri", "xi", "gi", "di", "ib", "a", "isi", "v", "abi", "iu", "f", "cli", "esi", "api"], "b": ["string", "base", "bf", "bd", "bh", "emb", "http", "eb", "lb", "c", "cb", "o", "l", "bs", "orb", "bin", "pb", "bg", "gb", "mb", "abb", "rb", "d", "ab", "sb", "wb", "buff", "lib", "buf", "ob", "body", "fb", "p", "e", "nb", "db", "bytes", "ib", "bc", "B", "bl", "y", "br", "ba", "f"], "bb": ["buffer", "base", "BB", "bf", "feed", "bd", "ok", "eb", "cb", "obb", "gg", "bin", "pb", "key", "char", "gb", "mb", "abb", "rb", "ab", "sb", "buff", "BBC", "ob", "fb", "bi", "bn", "nb", "db", "ib", "bc", "xb", "batch", "dd", "ogg", "boot"], "ll": ["BB", "lf", "kl", "lp", "lb", "wl", "z", "lr", "l", "col", "el", "nn", "LL", "ii", "ld", "dl", "fl", "la", "lla", "lc", "len", "ell", "ql", "cl", "nl", " l", "ls", "vl", "rl", "ln", "bl", "bm", "lv"], "k": ["ak", "sk", "ko", "n", "id", "ok", "ke", "kl", "ck", "ks", "dk", "j", "o", "uk", "K", "key", "ku", "unk", "d", "tk", "pp", "q", "kk", "r", "g", "work", "kid", "p", "x", "u", "m", "kw", "ky", "kin", "ikk", "ka", "f", "kn", "ik"], "s2": ["ws2", "s02", "Stwo", " sII", "STwo", " s4", "u2", "ds4", "s20", " s02", "js10", "utwo", " s10", " s8", " s0", "wstwo", "s8", "sum2", "su02", "wsTwo", " s20", "S5", "dsII", "c02", "su2", "ws5", "js0", "s96", "su1", "sII", "s10", "c2", "S2", "ds2", "s1", " s1", "sum10", " s96", "c1", "SII", "c20", "S4", "su20", "s0", "sTwo", "stwo", "js96", "u5", "sum96", "js2", "s5", "s4", "ds8", "uTwo", "sum0", "S8"]}}
{"id1": "15799935", "id2": "942693", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttPartBody", "saveAttachmentPart", "saveAttPartbody", "saveAttachedBody", "saveAppensionbody", "saveAppachmentPart", "saveAppachmentFile", "saveAppensionBody", "saveAttensionFile", "saveAttPartFile", "saveAttensionBody", "saveAppensionPart", "saveAppensionFile", "saveAttensionPart", "saveAttachmentFile", "saveAppachmentBody", "saveAttachmentbody", "saveAppachmentbody", "saveAttachedPart", "saveAttPartPart", "saveAttachedFile", "saveAttachedbody", "saveAttensionbody"], "context": ["event", "translation", "input", "resource", "definition", "cf", "subject", "document", "message", "c", "version", "concept", "system", "present", "current", "driver", "host", "project", "manager", "center", "queue", "content", "client", "cms", "support", "ce", "reader", "cache", "connection", "component", "media", "Context", "collection", "config", "parent", "ca", "text", "channel", "request", "environment", "template", "coll", "kernel", "mc", "ctx", "community", "processor", "container", "contact", "state", "network", "cca", "service", "view", "front"], "part": ["event", "base", "translation", "Part", "pre", " Part", "message", "per", "place", "phase", "patch", "html", "mission", "PART", "chapter", "parts", "type", "source", "art", "connection", "Parts", "component", "media", "upload", "section", "parent", "file", "body", "channel", "pod", "object", "p", "or", "po", "name", "start", "image", "to", "area", "position", "app", "partial", "plan", "comment", " parts", "state", "block", "service", "from", "point"], "localAttachment": [" localAttment", "localAvention", "localExtacher", "LocalAttail", "LocalAttention", "localArtail", "localInstention", " localAttacement", "localAddail", "LocalAssail", " localExtacement", " localPartension", "localArtment", "LocalAttachment", "localattachment", "localAddachment", " localExtacher", "localInstension", " localExtention", "LocalAssention", " localAttrollment", "localAttachrollment", " localAttention", "localArtention", "localExtachment", "localPartachment", "localPartribution", " localAttribution", "localPartention", "localAttachribution", "localAvacement", "localInstribution", "localAssachment", "localExtention", "localAttention", "localAttacement", "localAttachacher", " localAttacher", "localAttacher", "localattment", " localAttachachment", "localAddrollment", "localattrollment", "localattention", "localAttension", "localAttachacement", " localPartribution", "localAvacher", "localAttribution", "localArtachment", "LocalAssment", "localAttail", "localAssail", "localPartension", " localPartachment", "LocalAssachment", " localAttachrollment", "localAttrollment", " localAttension", "localAttachension", "localAddention", "localAttment", " localExtachment", "localAddment", "localAttachention", "localAvachment", "localAssment", "localAttachachment", "localExtacement", " localPartention", " localAttachention", "localAssention", "LocalAttment", "localInstachment"], "accountId": ["accID", "contractid", "accountInfo", "jobId", "accId", " accountInfo", "AccountID", "contractId", "feedId", "AccountName", "feedid", "jobid", "feedID", "contactId", " accountID", "accInfo", "accid", "contractName", "contactid", " accountName", "accountID", "accountid", "jobID", "AccountId", "Accountid", "feedName", "contactName", "jobName", " accountid", "accountName", "appInfo", "appID", "appId", "appid"], "attachmentId": ["adachmentID", "attentionUrl", "attentionId", "attmissionID", "attociationID", "extachmentSource", "attachmentid", "attensionSource", "atachmentReference", "attlementId", "attmentName", "attociationUrl", "atachmentName", "attmissionId", "addachmentUrl", "attachmentReference", "attensionid", "attptionId", "attptionIndex", "addentionUrl", "attentionInfo", "extensionID", "attentionSource", "adentionID", "atociationId", "attagramId", "attachmentSource", "attptionID", "attlementName", "attentionID", "addentionID", "attachedType", "atociationID", "addachmentId", "attentionType", "attachmentName", "attachedUrl", "attptionInfo", "addachmentID", "adachmentInfo", "extensionId", "attensionID", "addentionId", "extensionid", "addachmentType", "attociationReference", "adentionId", "extensionSource", "attmissionid", "attlementReference", "adachmentIndex", "attmissionSource", "attentionIndex", "atachmentID", "attociationType", "extachmentID", "adachmentId", "attachedId", "extachmentId", "attmentReference", "atachmentId", "addentionType", "attociationName", "attachmentInfo", "adentionInfo", "attensionId", "atociationReference", "attachedID", "attachmentType", "attmentID", "attociationId", "attmentId", "extachmentid", "attlementID", "attachmentUrl", "attachmentID", "attentionid", "attagramIndex", "attagramInfo", "adentionIndex", "attagramID", "atociationName", "attachmentIndex"], "in": ["IN", "info", "pin", "i", "input", "id", "plus", "copy", "ini", "gin", "con", "slice", "inner", "as", "socket", "ins", "bin", "pass", "is", "source", "reader", "load", "up", "login", "inside", "inc", "data", "file", "p", "init", "conn", "or", "again", "image", "it", "In", "nin", "a", "pull", "url", "err", "ac", "cin", "inn", "f", "din"], "saveIn": ["savIn", "writeIN", "saveIN", "savin", "SaveIn", "saveIns", "savAs", "stageAs", "savOut", " saveIN", "aveIn", "writeIn", "stageIns", "writein", "avein", "aveOut", "stageIn", " savein", "writeOut", "savein", "SaveAs", " saveIns", "SaveIns", "SaveOut", "aveIN", " saveOut", "aveAs", "saveOut", "stageOut"], "saveAs": ["copyAs", "writeAs", "SaveIn", "Saveas", "saveas", " saveFile", "createAs", "saveFile", "openAs", "saveAS", "openAt", "writeIn", "copyIn", "writeAS", "createAS", "writeOut", "SaveAs", "copyAS", "SaveAS", "copyas", "SaveOut", "saveAt", " saveAS", " saveas", "createFile", " saveOut", "createAt", "openAS", " saveAt", "openFile", "saveOut"], "out": ["string", "path", "temp", "ex", "output", "copy", "outer", "plus", "OUT", "c", "as", "inner", "o", "outs", "s", "line", "flow", "bin", "off", "client", "sync", "at", "source", "cache", "up", "other", "default", "inc", "data", "file", "page", "null", "conn", "init", "again", "name", "exec", "Out", "io", "writer", "image", "to", "a", "ext", "err", "v", "this"], "copySize": ["openSIZE", "savesize", "saveAddress", "byteLength", "CopySize", "openSize", "opensize", "lesize", "byteAddress", "copysize", "copyTime", "leSize", "openLength", "CopyTime", "saveLength", "bytesize", " copyLength", "copyAddress", " copysize", " copyAddress", " copySIZE", "leLength", "leSIZE", "byteTime", "CopyLength", "copySIZE", "copyLength", "saveSize", " copyTime", "byteSize", "Copysize"], "contentUriString": ["contentUpiStr", "contentIristring", "contentIrisInt", "contentUiniStr", "contentUiniNumber", "contentUrisstring", "contentUuriStr", "contentUuriByte", "contentIrisStr", "contentIriByte", "contentIiString", "contentUriStr", "contentUriUnit", "contentUiniByte", "contentIrisString", "contentIriStr", "contentUridString", "contentIrisUnit", "contentIriString", "contentUrisStr", "contentUrisUnit", "contentUiByte", "contentUriNumber", "contentUridStr", "contentUuriString", "contentUpistring", "contentUristring", "contentUioInt", "contentIiByte", "contentIriNumber", "contentUioStr", "contentUrisInt", "contentUiNumber", "contentUriByte", "contentUiUnit", "contentUuriNumber", "contentUiostring", "contentIrisstring", "contentIriInt", "contentUpiInt", "contentUiStr", "contentUridUnit", "contentIiStr", "contentIiNumber", "contentUioString", "contentIriUnit", "contentUiString", "contentUpiString", "contentUriInt", "contentUrisString", "contentUiniString"], "mSize": ["mName", "cName", "pLength", "iSize", "iLength", "iName", "pName", "cSize", "pCount", "mCount", "cCount", "pSize", "iCount", "mLength", "cLength"], "mContentUri": ["mContentIric", "mContentOUris", "mResourceIric", "mResourceIri", "mContentIris", "mContentUci", "mResourceUris", "mContentUrri", "mContentOUric", "mResourceUric", "mContentUrric", "mContentUric", "mContentOUci", "mContentIci", "mResourceUci", "mContentUrris", "mResourceIris", "mResourceIci", "mContentUrci", "mResourceUri", "mContentOUri", "mContentIri", "mContentUris"], "cv": ["iq", "cu", "core", "cc", "sc", "um", "cf", "rc", "enc", "vm", "uv", "cap", "vr", "c", "fc", "ctrl", "cb", "fp", "co", "pb", "VC", "csv", "nc", "content", "vc", "cm", "cp", "lc", "cover", "auc", "uc", "buf", "sv", "conv", "ca", "xc", "av", "cd", "keep", "vs", "coll", "cr", "CV", "mc", "ctx", "bc", "nv", "v", "ov", "cs", "GV", "vp", "lv", "que", "iv", "vv", "loc"], "uri": ["string", "path", "base", "address", "i", "id", "resource", "pi", "username", "http", "uid", "ri", " URI", "location", " Uri", "query", "ui", "universal", " ur", "qi", "gb", " url", "proxy", " scheme", "data", "route", "oid", "mi", "metadata", "environment", "href", "format", "uni", "ci", "iri", "prefix", "url", "range", "attribute", "cli", "iv", "URI", "api", "point", "storage"]}}
{"id1": "12236729", "id2": "18793482", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["zip", "Copy", "replace", "cmp", "py", "clip", "php", "clone", " copying", "split", " transfer", "sync", "cop", "cp", "diff", "cat", "upload", " dup", " copied", "get", "p", "io", "dump", " Copy", "paste", "transfer", "download"], "inputFile": [" inputDir", "outputfile", "currentFiles", "inputfile", " inputfile", "sourcePath", "outputPath", "sourceFile", "inputPath", "sourceFiles", "inputDir", "currentfile", "sourcefile", "inputFiles", "currentDir", "outputFiles", "outputDir", "currentFile", " inputFiles", " inputPath"], "outputFile": ["referenceFilename", "OutputDirectory", "referenceFile", "outputFilename", "outputfile", "inputFilename", "inputfile", "referencefile", "tempDirectory", " outputDirectory", "inputDir", "OutputDir", "tempDir", " outputfile", " outputDir", "Outputfile", "outputDirectory", "tempfile", "tempFile", "outputDir", "referenceDir", " outputFilename", "OutputFile"], "in": ["IN", "sin", "pin", "i", "input", "id", "n", "ini", "lock", "gin", "into", "con", "inner", "socket", "as", "l", "ins", "s", "bin", "read", "is", "reader", "source", "up", "login", "connection", "min", "inside", "r", "inc", "file", "get", "init", "conn", "again", "e", "image", "In", "nin", "kin", "ln", "a", "pull", "lin", "err", "cin", "inn", "f", "win", "din"], "out": ["i", "temp", "ex", "output", "n", "outer", "plus", "net", "plain", "OUT", "socket", "outs", "o", "write", "off", "bin", "line", "extra", "outside", "post", "sync", "at", "one", "cache", "up", "w", "inc", "parent", "file", "log", "null", "conn", "again", "exec", "Out", "writer", "io", "over", "b", "err", "v", "obj", "error"], "c": ["cu", "i", "id", "n", "cc", "sc", "cf", "rc", "character", "fc", "o", "col", "l", "line", "char", "ec", "cm", "d", "ce", "uc", "lc", "ct", "r", "ch", "cy", "cl", "xc", "x", "p", "cd", "C", "u", "ci", "m", "e", "cr", "pointer", "esc", "pc", "a", "k", "b", "v", "count", "f", "code"]}}
{"id1": "12678045", "id2": "18164929", "code1": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"addQDInformation": ["addQDSinformation", "addKdinformation", "addQdDirectory", "addQDinformation", "addQDSInfo", "addQdInformation", "addQDSInformation", "addQDMDirectory", "addQDMInfo", "addQDMInformation", "addKDDirectory", "addQDInfo", "addKdDirectory", "addKdInformation", "addKDInfo", "addQDMinformation", "addKDInformation", "addQDDirectory", "addKDinformation", "addKdInfo", "addQdinformation", "addQdInfo", "addQDSDirectory"], "qdDate": ["sqdName", "qdModule", "qpDate", "qdAge", "qsModule", "qdxVal", "qdyTime", "qdatDay", "qdTime", "qfData", " qtTime", "qidType", "qtAge", " qsTime", "qdxType", "qfStatus", "qcAge", " qfDate", "sqpName", "qidVal", "qsName", "qtDay", "qdVal", "qdStatus", "qidName", "qdyStatus", " qtAge", "qdName", "qdyDate", "qpName", "qdType", "sqdDate", " qfFile", "sqpVal", "qsTime", " qtDay", " qdStatus", "qtTime", " qdDay", " qdModule", "qtData", "qtStatus", "qdyName", "sqdVal", " qdName", "qdyModule", "qdtName", "qdxName", " qsName", "qtDate", "qcTime", " qfStatus", "qidDate", "qdtTime", "qdDay", " qfData", "qdxDate", " qsModule", "qcDay", "qdatTime", "qfDate", "qdyFile", "qdatAge", "qfFile", "qdatDate", " qdData", "qpVal", "qcDate", " qtDate", " qdTime", "qdtModule", "qdtDate", "sqdType", " qsDate", "qdyData", "qpType", "qdData", "sqpType", "qsDate", "sqpDate", " qdAge", "qtFile"], "qdFile": ["qfFile", "qdaFile", "qdsLog", " qdsFile", "qdxReader", "qdaFolder", "qdBuffer", "qsFile", " qdFolder", "sqdfile", "qdsInfo", "qdsBuffer", "sqdsReader", " qfDir", "qdDir", "qdsFolder", "qdFolder", "qdLog", "qddFile", "qdxFile", "qsReader", " qdsFiles", "qdReader", "qdsDir", " qfInfo", "qdsReader", " qdsFolder", "sqdsDir", "qdfile", " qdFiles", "qdxfile", " qdLog", " qdsLog", "qdsFiles", " qfBuffer", " qdInfo", "qdsfile", "qdsFile", "qfFolder", "qdFiles", "qfBuffer", "qdInfo", " qdBuffer", "qdxDir", "sqdsFile", "qfFiles", "qfInfo", "qdaFiles", "qddBuffer", "qsfile", " qfFile", "sqdFile", "sqdDir", "sqdReader", " qdDir", "qfLog", "qddDir", "sqdsfile", "qfDir", "qdaLog", "qsDir", "qddInfo"], "_qdFileDate": ["_qndFileDesign", "_qdFileName", "_qdfiledate", "_qdfileDesign", "_qdcfileStatus", "_qndFileDate", "_qdBaseName", "_qndTimedate", "_qdcfileDate", "_qdDirectoryDesign", "_qdcFileName", "_qdTimeDesign", "_qdcFileStatus", "_qdBaseUpdate", "_qdDirectoryStatus", "_qndFiledate", "_qdMinStatus", "_qndTimeDate", "_qdFileUpdate", "_qdTimedate", "_qndTimeStatus", "_qdMinDate", "_qdfileName", "_qdMinUpdate", "_qdfileUpdate", "_qdMinName", "_qndTimeDesign", "_qndFileStatus", "_qdFileStatus", "_qdcfileName", "_qdfileDate", "_qdBaseDate", "_qdDirectorydate", "_qdcfileUpdate", "_qdcFileDate", "_qdTimeDate", "_qdfileStatus", "_qdDirectoryDate", "_qdBaseStatus", "_qdFiledate", "_qdTimeStatus", "_qdcFileUpdate", "_qdFileDesign"], "ii": ["index", "ou", "i", "qa", "id", "uri", "ei", "pi", "lu", "ini", "ie", "yi", "ind", "fi", "si", "ui", "ih", "ori", "qi", "vi", "ti", "ji", "chi", "li", "ice", " i", "iii", "II", "bi", "ai", "oi", "uni", "ci", "image", "eni", "zi", "iri", "xi", "di", "gi", "vid", "hi", "jp", "ni", "abi", " iii", "iu", "que", "mini", "inf", "oe", "ix"], "info": ["information", "error", "handler", "job", "i", "qa", "id", "feed", "op", "entry", "ref", "py", "end", "child", "fw", "off", "ui", "extra", "fam", "txt", "part", "buff", "kid", "alias", "data", "li", "ignore", "archive", "h", "object", "init", "INFO", "name", "fo", "af", "home", "opt", "link", "di", "gi", "hi", "ext", "bug", "comment", "conf", "b", "obj", "Info", "abi", "def", "f", "prev", "inf", "api"], "_qdValue": ["_sqdData", "_qdcInfo", "_qdName", "_qdsInfo", "_sqdName", "_qDName", "_qDInfo", "_sqdcData", "_qdData", "_qdsValue", "_sqdValue", "_qdcData", "_qdcValue", "_qdcName", "_qdInfo", "_qdsName", "_sqdcName", "_qdsData", "_sqdcInfo", "_sqdcValue", "_sqdInfo", "_qDValue", "_qDData"], "reader": ["buffer", "loader", "handler", "input", "server", "resource", "uri", "feed", "reading", "rc", "entry", "report", "http", "author", "per", "inner", "library", "ri", "result", "driver", "dr", "manager", "read", "iter", "ler", "er", "client", "source", "player", "r", "ger", "parser", "data", "rar", "row", "rr", "or", "rer", "writer", "io", "worker", "fd", "service", "f", "Reader", "re"], "urlName": ["URLname", "urlArea", "URLKey", " urlInfo", "UrlKey", "URLName", " urlString", "webInfo", "uriInfo", " urlFamily", "URLArea", "UrlFile", "uriFamily", " urlPart", "urlname", "urlInfo", " urlname", "urlFile", "webFamily", " urlKey", "urlString", "UrlArea", "URLString", "URLInfo", "UrlInfo", "UrlName", "urlKey", "UrlPart", "uriName", "urlPart", "webName", " urlArea", " urlFile", "UrlString", "URLPart", "Urlname", "urlFamily", "URLFile"], "url": ["string", "path", "address", "buffer", "ssl", "base", "server", "uri", "resource", "feed", "user", "http", "socket", "l", "large", "host", "URL", "source", "connection", "browser", "r", "open", "data", "channel", "director", "web", "page", "bel", "name", "ball", " URL", "sl", "pull", "Url", "www", "f", "gl"], "stream": ["zip", "handler", "buffer", "input", "resource", "response", "feed", "user", "http", "draft", "per", "socket", "oper", "driver", "s", "trans", "in", "raw", "form", "client", "source", "r", "Stream", "open", "data", "channel", "out", "flash", "row", "control", "coll", "io", "writer", "sl", "v", "ream", "f", "download", "view"], "file": ["buffer", "handler", "loader", "server", "feed", "resource", "ile", "user", "lock", "report", "http", "socket", "fp", "l", "File", "part", "source", "use", "book", "r", " File", "data", "body", "page", "object", "log", "folder", "io", "writer", "db", "files", "parse", "b", "f", "handle"], "line": ["pin", "base", "rule", "row", "style", "force", "frame", "comment", "Line", "string", "buffer", "LINE", " Line", "phase", "band", "shell", "sync", "part", "lines", "lc", "connection", "str", "section", "cl", "page", "le", "nl", "name", "header", "cr", "link", "strip", "lin", "letter", "job", "lf", "response", "entry", "message", "ge", "limit", "se", "look", "day", "el", "split", "one", "no", "body", "inline", "side", "word", "error", "column", "single", "cell", "lo", "user", "l", "pass", "key", "item", "data", "text", "log", "status", "home", "cle", "pe", "parse", "range", "block", "definition"], "_qdDate": ["_sqdData", "_qcdYear", "_qdDay", "_qfData", "_sqdTime", "_qdNumber", "_qndDate", "_qcdData", "_qdsMonth", "_qndDat", "_qfDay", "_qndMonth", "_sqdNumber", "_qndNumber", "_qndData", "_qdsDat", "_qdcTime", "_qdTime", "_QdDat", "_qdDat", "_QdsMonth", "_QdTime", "_qdsNumber", "_qndTime", "_sqdsDate", "_qdcDate", "_sqdsNumber", "_sqdcDate", "_sqdDate", "_qfTime", "_sqdcData", "_sqdsData", "_qcdDate", "_qdData", "_sqdsYear", "_qdsDay", "_qdcData", "_qdsYear", "_QdDate", "_qdsDate", "_qfDate", "_qndYear", "_qdMonth", "_sqdcTime", "_qdcDat", "_qdcDay", "_sqdYear", "_qcdNumber", "_qdsTime", "_qdYear", "_QdsTime", "_QdsDate", "_sqdcDay", "_QdsDat", "_QdMonth", "_sqdDay", "_qdsData", "_qdcMonth"], "pos": ["push", "index", "val", "i", "pres", "n", "spec", "pose", " position", "act", "Pos", "j", "end", "limit", "o", "rel", "length", "col", "all", "off", "pl", "pass", "sort", "in", "offset", "next", "post", "part", "type", "no", "doc", "pr", "min", "len", "nos", "open", "down", "x", "p", "size", "neg", "po", "start", "dev", "port", "pid", "pull", "position", "unit", "POS", "prop", "sp", "os", "mid", "pt", "ps", "block", "axis", "point", "loc"], "projectNum": ["projectHash", "componentFamily", "taskLen", " projectLen", " projectHash", "componentHash", "taskNumber", "projectLen", "projectFamily", "taskName", " projectNumber", "componentNumber", "ProjectNum", "ProjectName", "productNum", "projectName", "taskNum", "productNumber", "ProjectLen", " projectName", " projectFamily", "productHash", "projectNumber", "productFamily", "componentNum", "ProjectNumber"], "value": ["val", "trial", "price", "resource", "response", "vector", "message", "version", "profile", "project", "description", "number", "result", "amount", "key", "Value", "type", "target", "group", "feature", "data", "object", "name", "values", "v", "range", "scale"]}}
{"id1": "5138455", "id2": "11673907", "code1": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"save": ["zip", "output", "copy", "Copy", "run", "Save", "write", "clone", "split", "post", "load", "upload", "store", "file", "append", "put", "apply", "pack", "dump", "files", "create", "parse", "process", "xml", "transfer", "download"], "bytes": ["services", "zip", "buffer", "address", "resources", "tes", "slice", "outs", "bs", "s", "gb", "parts", "its", "rb", "binary", "lines", "blocks", "bps", "buf", "data", "vals", "objects", "ips", "es", "frames", "Bytes", "ls", "pointer", "values", "files", "pins", "words", "os", "bits", "codes", "boot"], "outputFile": ["OutputDirectory", "referenceFile", "outputJar", "outputfile", "responseJar", "inputfile", "referencePath", " outputJar", "OutputF", "responseDir", "inputFile", "outputPath", "targetfile", "outputF", "referencefile", "inputPath", " outputDirectory", "OutputFiles", "targetJar", "inputDir", "targetDir", " outputF", " outputPath", " outputfile", "responseFile", "inputFiles", " outputFiles", " outputDir", "outputFiles", "inputF", "inputDirectory", "outputDirectory", "outputDir", "referenceDir", "OutputFile", "targetFile", "responsefile"], "in": ["IN", "info", "base", "pin", "i", "input", "inas", "n", "copy", "id", "token", "ini", "con", "c", "inner", "as", "s", "ins", "sin", "bin", "pass", "is", "part", "reader", "source", "up", "login", "connection", "inside", "r", "inc", "work", "data", "file", "rin", "ssl", "init", "conn", "again", "m", "exec", "image", "isin", "In", "nin", "a", "url", "b", "err", "cin", "inn", "f", "win", "din"], "out": ["i", "temp", "ex", "n", "output", "copy", "outer", "user", "server", "op", "OUT", "inner", "as", "socket", "outs", "o", "write", "bin", "outside", "post", "sync", "client", "at", "cache", "up", "connection", "inc", "w", "parent", "file", "object", "x", "null", "conn", "init", "again", "exec", "Out", "writer", "io", "exp", "image", "call", "In", "a", "ext", "err", "b", "obj", "f", "error", "this"]}}
{"id1": "1954410", "id2": "6403868", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitExecute", "doExecApply", "submitexecuteApply", "doexecuteute", "doSendRun", "doexecuteRun", "submitexecuteRun", "doSendute", "doexecuteutes", "submitExecApply", "doSendutes", "submitExecutes", "doExecutes", "submitexecuteutes", "submitexecuteute", "doExecRun", "doexecuteApply", "doSendApply", "submitExecRun"], "mapping": [" mapper", " matching", "aminding", "matching", "minding", " minding", "finding", "fatching", "amapping", "fapping", "fapper", "mapper", "amatching", "amapper"], "form": ["feed", "builder", "Form", "formation", "flow", "owner", "pattern", "post", "component", "FORM", "config", "page", "object", "forms", " forms", "control", "format", "submit", "template", "transform", "url", "app", "command", "xml", "dom", "method", "field", "definition"], "request": ["path", "address", "input", "Request", "resource", "server", "self", "user", "uri", "add", "report", "message", "json", "HTTP", "current", "result", "instance", "s", "query", "ware", "queue", "req", "client", "Accept", "session", "reader", "type", "use", "q", "model", "application", "parent", "Reply", "data", "route", "Upload", "object", "requ", "context", "hello", "complete", "submit", "name", "format", "QUEST", "frame", "Bytes", "worker", "call", "pull", "url", "Response", "create", "_", "xml", "method", "this", "re", "view"], "response": ["handler", "server", "resource", "output", "report", "res", "message", "json", "result", "req", "client", "resp", "Resp", "model", "application", "data", "page", "object", "reply", "status", "Response", " Response", "v", "xml", " responses", "view"], "errors": ["mess", " messaging", " mess", " messages", " acc", " managers", " commands", " streams", " payload", " status", " session", " management", " problems", " events", " replies", " Messages", " flashes", " updates", " changes", " error", " messenger", " warnings", " calls", " translations", " this", " logger", " failures", " responses", " logs"], "isMultipart": ["isMultompart", "isMultippedart", "isMultompost", "isMultipage", "isMultiipPart", "isMultipound", "isMultipated", "isMultitart", "isMultipPart", "isMultiart", "isMultippedPart", "isMultIPart", "isMultippedost", "isMultiparts", "isMultiIPPart", "isMultompound", "isMultippage", "isMultIPound", "isMultompPart", "isMultiipart", "isMultIPost", "isMultiipound", "isMultitage", "isMultippated", "isMultiIPart", "isMultippedound", "isMultiage", "isMultIPPart", "isMultipparts", "isMultipost", "isMultippart", "isMultiIPound", "isMultiated", "isMultitated", "isMultiipost", "isMultitarts", "isMultiIPost", "isMultiarts"], "mailInstance": [" mailInst", " mailUsage", "mailinstance", " mailManager", "mailInst", " emailInst", "emailInst", " emailinstance", "fileUsage", "emailManager", "emailInstance", " emailUsage", "fileinstance", " emailInstance", "fileInst", " mailinstance", "emailinstance", "fileInstance", "mailManager", "mailUsage", "fileManager"], "fields": ["keys", "services", "maps", "headers", "input", "locks", "checks", "archives", "forces", "pages", "gets", "comments", "features", "holders", "posts", "qs", "s", "packs", "ids", "params", "parts", "changes", "states", "links", "uploads", "lines", "boxes", "flows", "strings", "loads", "ments", "users", "members", "tags", "data", "classes", "facts", "utils", "objects", "models", "plugins", "groups", "forms", "lists", "atts", "types", "cells", "rows", "details", "files", "dates", "acks", "rules", "words", "events", "properties", "views", "field"], "attachments": ["payments", "achresses", "achment", "attachment", "Attachps", "atters", "attps", "attachlements", "attachresses", "attments", "payresses", "suppees", "achparts", "attions", "extments", "Attachlements", "exters", "Attachions", "attachions", "payment", "Attachers", "achments", "attachers", "suppments", "Attachment", "attachparts", " attachment", "suppment", "attachees", "extions", "attlements", " attachresses", "Attachments", "supplements", "extps", "payparts", "attachps", "attment", "Attachees", "attees", " attachparts"], "items": ["keys", "locks", "pages", "results", "ers", "apps", "ins", "qs", "reports", "ids", "apters", "parts", "its", "links", "lines", "ops", "children", "Items", "orders", "data", "names", "objects", "plugins", "ips", "models", "es", "groups", "phones", "lists", "alls", "types", "rows", "files", "events", "list"], "iter": ["ite", "upper", "zip", "order", "event", "i", "itter", "outer", "master", "http", "slice", "inter", "inner", "oper", "end", "walker", "ter", "gener", "el", "loop", "er", "izer", "Iterator", "reader", "ner", "inc", "file", "ir", "li", "page", "ip", "ator", "iterator", "Iter", "keep", "edit", "coll", "chain", "exp", "it", "skip", "cher", "ver", "ser", "err", "ul", "finder", "former", "altern", "list", "enter", "loc"], "item": ["index", "original", "base", "handler", "temp", "resource", "token", "volume", "art", "file", "get", "example", "coll", "it", "url", "obj", "container", "custom", "element", "info", "server", "site", "result", "all", "next", "post", "source", "load", "up", "section", "page", "object", "ip", "plugin", "complete", "hop", "name", "full", "missing", "attribute", "service", "Item", "storage", "val", "event", "order", "i", "atom", "more", "entry", "slice", "inner", "anything", "er", "reader", "other", "or", "issue", "image", "app", "update", "api", "album", "user", "current", "instance", "extra", "type", "data", "li", "entity", "widget", "folder", "area", "layer"], "aux": ["anc", "ou", "pkg", "lang", "cmp", "axe", "ants", "ru", "sub", "abs", "off", "extra", "uf", "union", "ux", "except", "lc", "uc", "cas", "strings", "auc", "buf", "aff", "alias", " auxiliary", "au", "ups", "data", "etc", "ras", "amp", " Aux", "des", "aw", "aos", "offs", "asc", "af", "packages", "array", "frac", "sup", "prefix", "ox", "fax", "abc", "ext", "imp", "aus"], "part": ["val", "base", "class", "info", "id", "pi", "Part", "user", "add", "pre", "on", " Part", "act", "per", "ref", "join", "html", "l", "patch", "instance", "co", "PART", "joined", "key", "parts", "comp", "fact", "type", "back", "one", "player", "no", "art", "connection", "component", "diff", "ch", "group", "section", "parent", "data", "file", "object", "p", "format", "plugin", "po", "start", "change", "name", "but", "action", "pos", "word", "full", "area", "layer", "pair", "partial", "obj", "b", "and", "block", "f", "step", "error", "field", "element", "list", "point"], "baos": ["Bais", "BAos", "bois", "baOs", "pais", "Baosi", "boo", "bais", "hao", "baot", "boOS", "paOS", "haoss", "BAis", "abaos", "BAo", "hais", " bais", "paot", "BAoS", "BAOs", "Bao", "haos", " baoS", "BAoss", "bao", "baosh", " baot", " baOS", "BaoS", "paos", "BaOs", " bao", "baosi", "BAosh", "baoS", "abais", "BAosi", "Baos", "baOS", "abaosi", "boosh", "paosh", " baoss", "baoss", "abaOs", "boos", "pao", "boot"], "body": ["zip", "string", "translation", "fee", "headers", "output", "resource", "message", "description", "document", "json", "end", "html", "length", "shell", "query", "pass", "content", "parts", "params", "type", "source", "binary", "connection", "value", "media", "common", "data", "text", "options", "object", "size", "flash", "null", "Body", "reply", "name", "header", "template", "tree", "port", "full", "url", "comment", "b", "summary", "state"], "preferencesInstance": ["prefirmsClient", "prefeesInstance", "preferencesinstance", "preffeesClient", "prefferencesInstance", "prefirmsInstance", "prefeesinstance", "preferencesClient", "prefferencesClient", "prefeesClient", "prefirmsinstance", "prefferencesinstance", "prefiesClient", "prefiesinstance", "preffeesinstance", "prefiesInstance", "preffeesInstance"]}}
{"id1": "1235538", "id2": "23335922", "code1": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 1, "substitutes": {"encrypt": ["Encrypt", "encress", "Encress", "Enccrypt", " encress", " encipher", " enccrypt", "decipher", "Encipher", "encipher", "decress", "enccrypt", "deccrypt", "decrypt"], "pass": ["path", "token", "user", "rip", "act", "wd", "key", "fail", "password", "post", "params", "Password", "use", "PASS", "pp", "ress", "ask", "text", "Pass", "request", "ass", "port", "word", "ss", "na", "strip", "pa", "secret", "auth", "parse", "sign", " password", "phrase", "hash", "code", "Secret"], "md": ["gd", "mag", "bd", "df", "od", "Cmd", "amd", "mo", "kg", "ma", "am", "MD", " MD", "sm", "ad", "mb", "mt", "dh", "d", "mac", "mp", "hd", "sha", "pm", "pd", "sd", "mm", "nd", "metadata", "cd", "dig", " Md", "m", "km", "dm", "grad", "mand", "mc", "der", "di", "mod", "rm", "mad", "cmd", "dd"]}}
{"id1": "14598566", "id2": "12172485", "code1": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFileByNIO": ["copyFileByMIF", "copyFileByFileIO", "copyFileByNIP", "copyFileByNio", "copyFilebynIF", "copyFilebyNIO", "copyFileBynIF", "copyFileByFileIF", "copyFileByMio", "copyFileBynIP", "copyFilebynio", "copyFileByFileIP", "copyFilebyNio", "copyFilebyNIP", "copyFileByMIP", "copyFilebynIO", "copyFileByMIO", "copyFileByNIF", "copyFileBynIO", "copyFileByFileio", "copyFilebynIP", "copyFilebyNIF", "copyFileBynio"], "in": ["IN", "index", "base", "buffer", "i", "input", "id", "ex", "copy", "resource", "ini", "c", "inner", "ins", "bin", "part", "at", "reader", "source", "connection", "min", "diff", "login", "inc", "data", "file", "h", "x", "or", "again", "name", "m", "image", "io", "In", "url", "b", "ac", "inn", "din"], "out": ["path", "string", "buffer", "ex", "n", "output", "copy", "resource", "c", "OUT", "project", "dest", "outs", "o", "client", "part", "at", "source", "cache", "connection", "target", "w", "inc", "data", "file", "object", "p", "conn", "name", "again", "exec", "Out", "writer", "io", "image", "to", "prefix", "ext", "v", "b", "external"], "sourceChannel": [" sourcechannel", "srcConnection", "innerStream", "ourceStream", "sourcechannel", "ourceChan", "srcQueue", "ourceConnection", "sinChannel", "Sourcechannel", "sinChan", "sourceQueue", "targetChan", "targetConnection", "SourceStream", " sourceStream", "innerChannel", " sourceConnection", "sourceChan", " sourceChan", "sinStream", " sourceServer", "ourceQueue", "sinServer", "sourceConnection", "innerChan", "ourcechannel", "srcChannel", "sourceStream", "ourceChannel", "SourceChan", "targetchannel", "targetChannel", "SourceChannel", "innerServer", "srcChan", "SourceConnection", "sourceServer", " sourceQueue"], "destinationChannel": ["destributionChan", "destroyingConnection", "destionClient", "destinatorChannel", "destributionContext", "destinationConnection", "destinateChannel", "destinatedChannel", "destributionClient", "destroyingStream", "destinationChan", "destinateStream", "destinationClient", "destinatedChan", "destinationContext", "DestinatorClient", "DestinationConnection", "destributionChannel", "destinatedContext", "DestinationChan", "DestinatorStream", "DestinationChannel", "DestinationContext", "DestinatorContext", "destionChan", "destinatorConnection", "destinatorClient", "destributionStream", "destinatorContext", "DestinationClient", "destinationStream", "DestinationStream", "DestinatorConnection", "DestinatorChannel", "destroyingChannel", "destinateConnection", "DestinatorChan", "destinatorStream", "destionChannel", "destributionConnection", "destinatorChan", "destinatedStream", "destionConnection"]}}
{"id1": "7468819", "id2": "8932510", "code1": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 0, "substitutes": {"run": ["close", "info", "execute", "server", "resource", "exit", "loop", "running", "login", "debug", "build", "work", "open", "check", "get", "test", "start", "exec", "runner", "call", "url", "update", "Run", "process", "download", "stop"], "con": ["close", "non", "pin", "Conn", "fa", "CON", "cf", "rc", "cons", "http", "ran", "on", "pre", "plain", "c", "per", "fc", "act", "ctrl", "sub", "socket", "Con", "co", "en", "sync", "client", "cm", "cp", "ocon", "cache", "cas", "cover", "ct", "connection", "login", "open", "conv", "un", "ca", "cl", "x", "log", "conn", "exec", "rx", "cr", "pc", "ctx", "ver", "bc", "url", "can", "conf", "cn", "connect", "cur", "re"], "encodedPassword": ["deccodedPass", "enoderpassword", "encoderPass", "enoderAccount", "deccodedpassword", "enodedPassword", "encryptedpassword", "encodedPass", "decodedPass", "encryptedPassword", "enodedAccount", "deccodedPassword", "enccodedPass", "enoderPassword", "enccodedPassword", "encodedSecret", "decodedSecret", "encodedpassword", "encapedPassword", "encoderAccount", "encryptedPass", "encoderSecret", "decodedPassword", "encapedPass", "encapedAccount", "enodedPass", "encodedAccount", "encapedpassword", "encryptedAccount", "enoderPass", "enodedpassword", "enccodedpassword", "deccodedSecret", "encoderPassword", "decodedpassword", "enccodedSecret", "encryptedSecret", "encoderpassword"], "encoder": ["decoded", "encode", "decoder", "enoder", "Encoded", "Encoder", "enoded", "decode", "Encode", "decoding", "enoding", "enode", "encoded", "Encoding", "encoding"], "is": ["bis", "sel", "i", "iss", "id", "serv", "IS", "isa", "rc", "res", "Is", "act", "as", "ri", "s", "ins", "il", "rt", "in", "rs", "isl", "its", "was", "ais", "r", "isc", "ir", "src", "out", "get", "es", "has", "conn", "ai", "ris", "rss", "ci", "ls", "rx", "iri", "iris", "ios", "us", "url", "ser", "isi", "stream", "are", "can", "os", "inn", "isu", "ar", "im", "re"], "rd": ["rw", "ud", "dra", "wr", "gd", "bd", "ru", "rost", "rg", "lr", "dr", "rt", "fr", "mr", "rs", "ld", "RD", "rb", "ws", "rh", "d", "reader", "xd", "rod", "rn", "ra", "r", "rex", "nd", "rr", "rss", "rx", "cr", "rob", "fd", "rl", "respond", "stream", "hr", "td", "ds", "rm", "pd", "dd", "Rs"], "line": ["letter", "string", "buffer", "i", "output", "lf", "feed", "entry", "continue", "message", "character", "LINE", "end", "l", "key", "content", "part", "reader", "source", "lines", "lc", "len", "str", "r", "data", "text", "body", "cl", "page", "object", "log", "row", "inline", "style", "name", "header", "link", "strip", "url", "pe", "unit", "comment", "Line", "lin", "err", "error", "re", "code", "cell"], "response": ["string", "respons", "audio", "buffer", "four", "server", "output", "resource", "feed", "more", "serv", "uri", "report", "site", "message", "description", "json", "version", "answer", "memory", "content", "resp", "cover", "binary", "value", "connection", "model", "application", "collection", "default", "wave", "data", "body", "page", "object", "request", "reply", "header", "rss", "tree", "image", "array", "success", "function", "second", "Response", "respond", "secret", "error", "esi"], "lastIteraction": ["last_time", " lastiteraction", " last_time", "lastiterative", " lastiterit", "lastInteraction", "last_it", "lastiteraction", "lastiterit", " last_it", "lastIntertime", "lastinterative", "lastInterit", "lastitertime", " lastiterative", " last_ative", "last_action", "lastinterit", "lastintertime", "lastInterative", "last_ative", " lastitertime", " last_action", "lastinteraction"], "result": ["info", "server", "resource", "user", "lock", "entry", "results", "report", "message", "json", "account", "answer", "query", "pass", "next", "session", "source", "date", "page", "row", "status", "array", "success", "secret", "Result", "error"], "e": ["ite", "fe", "i", "ace", "ee", "n", "element", "ke", "be", "ie", "eb", "c", "j", "o", "se", "l", "s", "te", "ception", "ec", "er", "type", "d", "je", "r", "g", "ea", "de", "exc", "h", "x", "p", "es", "ae", "null", "u", "or", "ne", "eu", "E", "m", "t", "ze", "ev", "a", "pe", "me", "err", "b", "f", "error", "oe", "this", "esi"]}}
{"id1": "19378010", "id2": "10547671", "code1": "    public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException {\n        final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath);\n        final Multimap<String, String> proteins = HashMultimap.create();\n        for (final String query : queries) {\n            HttpURLConnection connection = null;\n            try {\n                final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\");\n                final URL url = new URL(String.format(__urlTempl2, encoded, taxon));\n                connection = (HttpURLConnection) url.openConnection();\n                connection.setConnectTimeout(__connTimeout);\n                connection.setReadTimeout(__readTimeout);\n                connection.setRequestProperty(\"Connection\", \"close\");\n                connection.connect();\n                final InputStream stream = connection.getInputStream();\n                final Document doc = parser.parse(stream);\n                final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET);\n                if (nodes != null) {\n                    final int n = nodes.getLength();\n                    for (int i = 0; i < n; i++) {\n                        final Node node = nodes.item(i);\n                        proteins.put(node.getTextContent().trim(), query.trim());\n                    }\n                }\n            } catch (final Exception ex) {\n                continue;\n            } finally {\n                if (connection != null) connection.disconnect();\n            }\n        }\n        return proteins;\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 0, "substitutes": {"getProteins": ["getPinyin", "getPinyans", "getPetteans", "getPteins", "getProteus", "getProroteins", "getProroteus", "getPteus", "getProteans", "getProtein", "getPteans", "getPinyins", "getPetteus", "getProrotein", "getProroteans", "getPtein", "getPinyus", "getPetteins", "getPettein"], "queries": ["critirements", "acquires", " quences", " quares", " quirements", "queeries", "quares", "critery", " quires", "queares", "criteries", "quences", "acquirements", "acqueries", "acquery", "acquares", "quirements", "queences", "critires", "acquences", "queires", "quires"], "taxon": [" taxonomy", "acton", "Taxion", "actron", "Taxon", " taxron", "taxan", " taxion", "taxON", "taxron", "actON", "producton", "Taxonomy", "productonomy", "productan", "productron", "taxonomy", "action", " taxan", "Taxron", "Taxan", " taxON", "TaxON", "taxion"], "parser": ["string", "base", "Builder", "arser", "loader", "buffer", "self", "handler", "server", "builder", "http", "document", "lp", "library", "se", "instance", "l", "driver", "manager", "er", "paragraph", "session", "reader", "lib", "oder", "root", "p", "context", "plugin", "writer", "worker", "layer", "parse", "b", "xml", "Parser", "pd", "dd"], "xpe": ["exPE", "rxpe", "xPE", "xme", " xfe", "nexpe", "xxme", "xxpex", " xme", "expe", "xpex", "xpa", " xpex", "nexme", "rxme", "exfe", " xPE", "xxpe", " xpa", "rxpex", "nexPE", "rxpa", "xfe", "nexfe", "exme", "xxpa"], "proteins": ["proroteins", "proplein", "Proroteins", "procheis", "Proroteinas", "procheinas", "Protein", "progein", "Proteins", "preteons", "ProroteINS", "Prorotein", "procheins", "preteins", "progeins", "pretein", "prooeinas", "propleINS", "ProteINS", "proteinas", "prooeins", "pregeans", "proteINS", "prooeINS", "propleans", "Proteis", "prorotein", "proroteinas", "pregeons", "propleins", "prooeis", "prooein", "proteis", "progeans", "proroteis", "propleons", "Proteinas", "proteans", "progeons", "preteans", "protein", "propleis", "Proroteis", "proroteINS", "proroteans", "pregeins", "proteons", "pregein", "prochein", "proroteons"], "query": ["iq", "string", "path", "info", "server", "uri", "resource", "id", "timeout", "entry", "json", "qu", "eries", " Query", "tag", "database", "key", "password", "params", "expression", "filter", "type", "source", "q", "value", "scope", "str", "feature", "text", "body", "route", "request", "search", "row", "sq", "Query", "name", "call", "prefix", "sql", "update", "parse", "comment", "question", "command", "scan", "block", "expr", "script", "error", "module", "term"], "connection": ["directory", "Connection", "string", "remote", "handler", "server", "uri", "response", "resource", "timeout", "builder", "http", "message", "con", "c", "communication", "socket", "connected", "current", "document", "location", "driver", "pool", "URL", "relation", "co", "manager", "database", "established", "key", "condition", "password", "client", "session", "source", "cache", "reader", "proxy", "application", "collection", "open", "config", "section", "channel", "parent", "director", "log", "context", "conn", "creator", "or", "ci", "io", "image", "writer", "function", "to", "closed", "link", "db", "ctx", "position", "connect", "wrapper", "container", "state", "statement", "error", "service", "api", "loc"], "encoded": ["enoder", "Encoded", "Encoder", " decrypted", " encoder", "enccoded", "engrypted", " decoded", "Enccoded", " deccoded", " encrypted", "engoded", "enoded", "encrypted", "engcoded", " enccoded", "enrypted", "encoder", " decoder", "Encrypted", "engoder"], "url": ["impl", "string", "path", "ssl", "address", "base", "job", "server", "uri", "resource", "feed", "user", "builder", "http", "l", "location", "URL", "client", "session", "source", "browser", "org", "build", "config", "file", "channel", "web", "page", "log", "conn", "ls", "image", "link", "Url", "www", "b", "service", "api", "loc"], "stream": ["string", "path", "input", "server", "output", "response", "resource", "feed", "user", "document", "result", "record", "trans", "content", "raw", "form", "client", "session", "reader", "source", "media", "Stream", "data", "file", "channel", "body", "out", "object", "request", "row", "context", "coll", "image", "sw", "ream", "xml", "f", "bean", "view"], "doc": ["root", "response", "Doc", "df", "docs", "map", "document", "DOC", "project", "html", " document", "dc", "nt", "d", "proc", "dot", "module", "oc", "div", "md", "data", "text", "body", "file", "desc", "coll", "tree", "m", "dict", "toc", "dec", "db", "pc", "bc", "parse", "xml", "dom", "f", " docs"], "nodes": [" numbers", "enodes", "numbers", "enods", "enons", "Nodes", " nasts", " noms", "Node", "enod", "nod", "Numbers", "sasts", "anodes", "enops", "nops", " nops", "Nod", "soms", "iods", "noms", "ynods", " notes", "Noms", " nod", "iodes", "ynotes", "Nops", "nons", "ynodes", "enotes", "Nasts", "anode", "nods", "anotes", "anoms", "sumbers", "notes", "sodes", "nasts", "enoms", "ions", "ynons", "Notes", "iotes"], "n": ["num", "ns", "net", "c", "j", "z", "number", "o", "l", "length", "s", "nn", "N", "en", "nc", "d", "len", "nl", "x", "p", "ne", "m", "t", "nb", "nin", "ln", "k", "span", "v", "b", "y", "network", "sn", "count", "ng"], "i": ["index", "info", "id", "pi", "uri", "ini", "ie", "slice", "c", "inner", "j", "z", "ri", "o", "end", "l", "si", "shift", "ui", "ii", "in", "key", "qi", "ti", "phi", "chi", "li", "ip", "x", "p", "mi", "bi", "u", "h", "init", "ai", "oi", "ci", "I", "io", "eni", "it", "xi", "di", "gi", "hi", "k", "v", "y", "ni", "b", "multi", "f", "ix"], "node": ["path", "num", "id", "outer", "entry", "document", "slave", "Node", "child", "nn", "key", "content", "cdn", "edge", "one", "type", "load", "value", "component", "parent", "data", "text", "none", "entity", "route", "page", "object", "row", "name", "tree", "e", "card", "label", "word", "link", "ode", "layer", "scene", "missing", "network", "bean", "element"]}}
{"id1": "22411381", "id2": "2910383", "code1": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "code2": "    public String downloadAndOpen(JProgressBar bar) {\n        long size = 0;\n        try {\n            size = photo.getSize();\n        } catch (ServiceException ex) {\n            ex.printStackTrace();\n        }\n        try {\n            bar.setMaximum((int) size);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        bar.setValue(0);\n        image = new File(\"TMP/\" + photo.getTitle().getPlainText());\n        try {\n            if (!image.exists()) {\n                image.createNewFile();\n                image.deleteOnExit();\n                URL url = null;\n                BufferedOutputStream fOut = null;\n                try {\n                    url = new URL(photo.getMediaContents().get(0).getUrl());\n                    InputStream html = null;\n                    html = url.openStream();\n                    fOut = new BufferedOutputStream(new FileOutputStream(image));\n                    byte[] buffer = new byte[32 * 1024];\n                    int bytesRead = 0;\n                    int in = 0;\n                    while ((bytesRead = html.read(buffer)) != -1) {\n                        in += bytesRead;\n                        bar.setValue(in);\n                        fOut.write(buffer, 0, bytesRead);\n                    }\n                    html.close();\n                    fOut.close();\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return image.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"stop": ["remove", "close", "release", "pause", "job", " Stop", "quit", "kill", "setup", "Stop", "reset", "end", "find", "run", "destroy", "save", "sleep", "next", "loop", "operation", "work", "get", "delete", "start", "status", "update", "create", "process"], "task": ["class", "temp", "resource", "master", "run", "patch", "match", "tag", "func", "component", "problem", "worker", "element", "module", "point", "server", "clean", "game", "lock", "ack", "query", "sync", "source", "load", "work", "parent", "channel", "route", "Task", "object", "device", "plugin", "test", "complete", "name", "again", "exec", "link", "this", "unit", "contract", "localhost", "process", "event", "job", "tc", "message", "act", "socket", "session", "request", "pack", "app", "question", "trace", "error", "view", "user", "slave", "table", "project", "instance", "thread", "manager", "key", "form", "type", "date", "target", "ask", "config", "data", "status", "t", "action", "call", "role", "command", "block", "tx"], "con": ["remote", "core", "tc", "Conn", "cc", "server", "resource", "CON", "cf", "clean", "cons", "lock", "ran", "rc", "c", "fc", "ctrl", "col", "Con", "co", "query", " conn", "en", "condition", "client", "sync", "cm", "session", "cp", "cache", "cas", "uc", "ion", "connection", "login", "common", "ch", "inc", "conv", "un", "ca", "config", "xc", "log", "null", "conn", "rec", "row", "ain", "coll", "exec", "ci", "cr", "ann", "db", "pc", "commit", "mc", "ctx", "sql", "bc", "ver", "can", "conf", "cn", "connect", "container", "f", "win", "re"], "s": ["ssl", "sum", "sc", "sf", "n", "sys", "fs", "sg", "ks", "ns", "c", "S", "j", "se", "l", "ins", "bs", "si", "o", "su", "is", "rs", "ws", "sb", "r", "ans", "w", "gs", "h", "p", "es", "sq", "u", "search", "submit", "south", "ls", "js", "e", "m", "rows", "ss", "sl", "a", "sql", "ses", "cs", "ds", "os", "f", "ps"], "result": ["event", "info", "sum", "server", "resource", "response", "uri", "rc", "user", "results", "res", "report", "http", "message", "json", "ge", "table", "instance", "record", "manager", "su", "ret", "session", "source", "cache", "rh", "reader", "ner", "r", "ch", "work", "data", "page", "request", "search", "row", "coll", "e", "status", "runner", "success", "db", "details", "ver", "ser", "comment", "ur", "err", "future", "successful", "Result", "error", "sr", "re", "view"], "url": ["string", "path", "base", "address", "job", "id", "uri", "feed", "http", "lr", "l", "host", "location", "URL", "key", "source", "str", "ob", "file", "route", "object", "request", "href", "ls", "e", "image", "link", "sl", "rl", "pull", "Url", "obj", "f", "hub", "loc"], "i": ["uri", "pi", "ini", "ie", "ic", "c", "ri", "o", "l", "si", "ui", "is", "in", "ii", "ori", "qi", "vi", "d", "phi", "r", "ami", "li", "ip", "h", "p", "bi", "u", "ai", "oi", "ci", "e", "io", "I", "m", "eni", "it", "iri", "xi", "gi", "di", "ib", "a", "isi", "v", "abi", "iu", "f", "cli", "esi", "api"], "b": ["string", "base", "bf", "bd", "bh", "emb", "http", "eb", "lb", "c", "cb", "o", "l", "bs", "orb", "bin", "pb", "bg", "gb", "mb", "abb", "rb", "d", "ab", "sb", "wb", "buff", "lib", "buf", "ob", "body", "fb", "p", "e", "nb", "db", "bytes", "ib", "bc", "B", "bl", "y", "br", "ba", "f"], "bb": ["buffer", "base", "BB", "bf", "feed", "bd", "ok", "eb", "cb", "obb", "gg", "bin", "pb", "key", "char", "gb", "mb", "abb", "rb", "ab", "sb", "buff", "BBC", "ob", "fb", "bi", "bn", "nb", "db", "ib", "bc", "xb", "batch", "dd", "ogg", "boot"], "ll": ["BB", "lf", "kl", "lp", "lb", "wl", "z", "lr", "l", "col", "el", "nn", "LL", "ii", "ld", "dl", "fl", "la", "lla", "lc", "len", "ell", "ql", "cl", "nl", " l", "ls", "vl", "rl", "ln", "bl", "bm", "lv"], "k": ["ak", "sk", "ko", "n", "id", "ok", "ke", "kl", "ck", "ks", "dk", "j", "o", "uk", "K", "key", "ku", "unk", "d", "tk", "pp", "q", "kk", "r", "g", "work", "kid", "p", "x", "u", "m", "kw", "ky", "kin", "ikk", "ka", "f", "kn", "ik"], "s2": ["ws2", "s02", "Stwo", " sII", "STwo", " s4", "u2", "ds4", "s20", " s02", "js10", "utwo", " s10", " s8", " s0", "wstwo", "s8", "sum2", "su02", "wsTwo", " s20", "S5", "dsII", "c02", "su2", "ws5", "js0", "s96", "su1", "sII", "s10", "c2", "S2", "ds2", "s1", " s1", "sum10", " s96", "c1", "SII", "c20", "S4", "su20", "s0", "sTwo", "stwo", "js96", "u5", "sum96", "js2", "s5", "s4", "ds8", "uTwo", "sum0", "S8"]}}
{"id1": "471804", "id2": "14231545", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doFeatureScan", "doFeatureUpdate", "doversionScan", " doversioncheck", "doFeaturecheck", "doVersionUpdate", "doVersionScan", " doVersionUpdate", "doChangecheck", " doVersionScan", " doversionUpdate", "doChangeUpdate", "doChangeScan", "doversionUpdate", "doFeatureCheck", " doVersioncheck", " doversionScan", "doversionCheck", "doChangeCheck", "doVersioncheck", "doversioncheck", " doversionCheck"], "view": ["index", "base", "vol", "http", "window", "fail", "model", "row", "style", "comment", "container", "server", "self", "lock", "by", "html", "query", "ui", "VIEW", "use", "cache", "up", "value", "View", "vis", "page", "object", "edit", "e", "full", "screen", "link", "review", "can", "v", "views", "list", "event", "head", "video", "el", "session", "see", "show", "group", "div", "body", "box", "change", "image", "update", "im", "display", "cell", "sel", "ou", "input", "user", "pool", "layout", "manager", "form", "client", "config", "out", "check", "widget", "port", "ve", "gu", "block", "this"], "url": ["impl", "zip", "string", "path", "base", "buffer", "loader", "ssl", "address", "server", "uri", "resource", "id", "builder", "http", "socket", "rel", "l", "host", "location", "URL", "fr", "length", "email", "source", "browser", "ob", "open", "file", "web", "bb", "ll", "log", "null", "ls", "name", "image", "blog", "link", "sl", "Url", "www", "stream", "bug", "b", "ul", "f", "hub", "gl", "download", "loc"], "in": ["IN", "sin", "buffer", "pin", "input", "bis", "resource", "ini", "con", "socket", "as", "inner", "s", "ins", "is", "reader", "source", "binary", "doc", "login", "inc", "data", "file", "out", "rin", "init", "again", "m", "isin", "In", "nin", "stream", "lin", "b", "err", "ac", "cin", "inn", "win", "din"], "bin": ["IN", "sin", "buffer", "pin", "loader", "input", "border", "ban", "ini", "lock", "gin", "con", "socket", "inner", "run", "arin", "record", "is", "fin", "reader", "binary", "lib", "browser", "login", "ruby", "body", "file", "out", "vin", "oin", "bb", "bi", "init", "bn", "nb", "spin", "bot", "lin", "b", "abi", "cin", "inn", "win", "din"], "line": ["val", "zip", "string", "letter", "pin", "base", "job", "id", "lf", "user", "entry", "LINE", "ge", "end", "l", "look", "jo", "el", "write", "ine", "key", "part", "type", "one", "lines", "lc", "up", "str", "data", "file", "text", "out", "cl", "page", "le", "nl", "ip", "log", "row", "inline", "object", "name", "e", "word", "link", "sl", "pe", "unit", "comment", "Line", "lin", "b", "range", "parse", "block", "definition", "code", "cell"], "version": ["string", "release", "beta", "server", "video", "id", "user", "option", "author", "project", "python", "patch", "driver", "host", "versions", "code", "type", "support", "cover", "date", "value", "model", "feature", "section", "VERSION", "null", "device", "plugin", "format", "name", "dev", "image", "latest", "pull", "ver", "update", "bug", "unit", "position", "secret", "v", "download", "vert", "Version", "vision", "license", "install"], "build": ["info", "release", "job", "feed", "clean", "builder", "lock", "add", "building", "http", "rel", "run", "patch", "lease", "Build", "tag", "follow", "post", "use", "load", "show", "work", "get", "log", "row", "built", "style", "image", "home", "how", "hold", "link", "mount", "pull", "update", "uild", "unit", "bug", "ver", "print", "make", "help", "block", "boot", "install", "valid"]}}
{"id1": "7276377", "id2": "22844377", "code1": "    public static String checksum(URL url, String algorithm) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(algorithm);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex);\n        }\n        byte[] bytes = new byte[4 * 1024];\n        try {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                int nBytesRead = 0;\n                while ((nBytesRead = in.read(bytes)) > 0) {\n                    messageDigest.update(bytes, 0, nBytesRead);\n                }\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm);\n        }\n        byte[] checksumValue = messageDigest.digest();\n        return digestAsString(checksumValue);\n    }\n", "code2": "    public int scrapeForIsbns(URL url) {\n        int matches = 0;\n        Pattern p = Pattern.compile(\"ISBN-10:</strong>\\\\s*(\\\\w{10})\");\n        Matcher m;\n        for (int i = 0; i < RETRIES; i++) {\n            try {\n                InputStream in = url.openStream();\n                BufferedReader br = new BufferedReader(new InputStreamReader(in));\n                String str;\n                while ((str = br.readLine()) != null) {\n                    m = p.matcher(str);\n                    while (m.find()) {\n                        matches++;\n                        outputIsbns.put(m.group(1));\n                        logger.debug(\"Got ISBN: \" + m.group(1));\n                    }\n                }\n                break;\n            } catch (ConnectException e) {\n                logger.warn(\"Connection attempt \" + i + \" failed, trying again. Max retries: \" + RETRIES);\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e1) {\n                }\n            } catch (IOException e) {\n                logger.error(\"Error reading URL stream\", e);\n            } catch (InterruptedException e) {\n                logger.error(\"Interrupted while calling put(Object E)\", e);\n            }\n        }\n        return matches;\n    }\n", "label": 0, "substitutes": {"checksum": ["decums", " checksums", " checksumb", "checksums", "ckssum", "decum", "cksumb", "decsum", "checksumb", "decumb", " checkssum", "cksum", "cksums", "checkssum"], "url": ["string", "path", "address", "ssl", "loader", "base", "server", "uri", "feed", "username", "resource", "user", "id", "http", "filename", "location", "host", "l", "URL", "fr", "manager", "email", "rule", "source", "proxy", "connection", "str", "config", "file", "text", "src", "ll", "href", "or", "name", "image", "sl", "Url", "stream", "ur", "gl", "f", "cert", "service", "download", "loc"], "algorithm": [" algo", "malgebra", "Alignment", "ALgo", " alignment", "allgorithm", " algorith", "malgorith", "exgebra", "malgorithm", "allgo", "exgo", "algo", "algorith", "ALgorith", "allgebra", "exgorithm", "Algo", "exgorith", "ALgebra", "algebra", "malgo", "alignment", "Algebra", " algebra", "Algorithm", "ALgorithm", "allgorith", "Algorith", "malignment"], "messageDigest": ["MessageDigpe", "messageSignse", "MessageMixpe", "MessageDiger", "MessageDester", "MessageDade", "MessageDigester", "MessageDigade", "messageDigpe", "messageRegator", "messagedigess", "MessageDigse", "MessageDigge", "messageDigse", "messagedigest", "MessageDesignator", "messagediger", "MessageDigator", "messagedigester", "messageDer", "messageDse", "messageDigester", "MessageSignge", "MessageDest", "messagedigse", "messageDigade", "messageDpe", "messagedigge", "messageDigess", "MessageDesignest", "MessageMixer", "MessageSignse", "messageRegester", "messageDiger", "messageMixest", "MessageSignest", "messagedigpe", "messageDest", "messageRegess", "messageDester", "messageDesigness", "messageSignester", "MessageDesignester", "messagedigator", "messageMixer", "messageMixpe", "MessageSignester", "messageDge", "messageDigator", "messageMixester", "MessageDigess", "MessageDigest", "MessageMixester", "MessageDesigness", "messageDesignator", "messageDigge", "messageRegest", "messagedigade", "MessageMixest", "messageSignge", "messageDesignester", "messageDesignest", "MessageDse", "messageSignest", "messageDade"], "bytes": ["zip", "buffer", "bles", "limits", "pages", "pieces", "gets", "tes", "resources", "outs", "steps", "bs", "reads", "errors", "items", "parts", "lines", "blocks", "bps", "loads", "eps", "classes", "vals", "objects", "ips", "size", "es", "frames", "Bytes", "resses", "ls", "ones", "vs", "seconds", "cells", "rows", "files", "values", "ipes", "words", "units", "os", "bits", "boot"], "in": ["IN", "impl", "ssl", "i", "input", "ex", "n", "fe", "token", "serv", "ini", "id", "gin", "con", "c", "socket", "as", "inner", "version", "l", "ins", "s", "fr", "bin", "is", "client", "reader", "source", "login", "min", "r", "inc", "data", "file", "out", "rin", "gen", "init", "conn", "again", "m", "isin", "In", "nin", "kin", "a", "stream", "b", "ac", "err", "inn", "f", "win", "din"], "nBytesRead": ["nPartsLoad", "nByteLength", "nFramesRead", " nBytesLoad", "nBytesLength", "nFramesLength", " nBytesWritten", "nPagesLength", "nPagesWritten", "nBytesWritten", "nWordsCount", "nPagesRead", "nByteWritten", "nWordsWritten", "nByteFound", "nByteRead", "nWordsRead", " nByteLoad", "nCharactersRead", " nByteWritten", "nWordsLength", " nByteFound", " nBytesCount", "nCharactersCount", "nPartsRead", "nByteCount", "nCharactersWritten", "nBytesFound", " nByteRead", "nFramesWritten", "nPagesFound", "nBytesCount", "nPartsWritten", " nByteLength", "nByteLoad", " nByteCount", " nBytesLength", "nBytesLoad", "nCharactersLength", "nFramesFound", " nBytesFound"], "checksumValue": ["checksumPath", "checksupString", "checksumberValue", " checksumText", " checkssumPath", "checksummPath", "checkssumText", "checksupData", "checksumberText", " checkssumValue", " checkssumText", "checksramVal", " checkssumArray", " checkssumVal", "checksumString", "checkssumData", "checksumberString", "checksumVal", " checksumVal", "checksummVal", "checksummValue", " checksumString", " checksumPath", "checksupValue", "checksumberData", " checksumArray", "checksumData", "checksupText", " checkssumString", "checksummArray", "checkssumArray", " checkssumData", "checkssumValue", " checksumData", "checksramPath", "checkssumVal", "checksumText", "checksumArray", "checksramValue", "checksramArray", "checkssumString", "checkssumPath"]}}
{"id1": "19549489", "id2": "12172485", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copy": ["zip", "Copy", "move", " copies", "all", "write", "clone", " copying", "split", " transfer", "sync", "cop", "source", "upload", "file", " copied", "Cop", "p", "delete", "io", " move", " Copy", "create", "Transfer", "paste", "transfer", "download"], "sourceFile": ["servicefile", " sourceFILE", "siteFILE", "sourceFILE", "siteDirectory", "SourceDirectory", " sourceFiles", "serviceFile", "resourceFiles", "serviceFilename", "searchfile", "serviceFiles", "searchFiles", "sourceFiles", "resourceFile", "SourceFILE", "SourceFile", "sourceFilename", "searchFile", "siteFiles", " sourceDirectory", "sourcefile", " sourceFilename", "resourceDirectory", "searchFilename", "sourceDirectory", "resourcefile", " sourcefile", "Sourcefile", "SourceFiles", "siteFile"], "destinationFile": ["destinatorfile", "distinatedFile", "distinationFiles", "DestinationFile", "destationfile", "distinatedImage", "distinatedDirectory", "destinatorDirectory", "destinatedImage", "DestinatorFiles", "destinatedDirectory", "destationFiles", "destinationImage", "destinatedDir", "destinationDirectory", "destinatedFile", "destinationfile", "destationDir", "destinatedfile", "distinatedFiles", "distinationDirectory", "destinatorFile", "destinationDir", "destationDirectory", "destinatedFiles", "destinatorImage", "distinationFile", "Destinationfile", "destinatorFiles", "distinationImage", "DestinatorDir", "DestinationFiles", "destationImage", "DestinationDir", "DestinatorFile", "Destinatorfile", "destationFile", "destinatorDir", "destinationFiles"], "sourceFileChannel": ["sourceStreamchannel", " sourceFileContext", "targetLibraryChannel", " sourceFilesConnection", "sourceLinechannel", "sourceLibraryClient", "sourceFilesService", "sourceFileConnection", "targetLibrarySocket", "sourceStreamChannel", "sourceFilesConnection", "sourceLibraryChannel", "sourceDirChannel", "sourceFilesChannel", "sourceFileStream", "sourceStreamService", "sourceDirStream", "sourceLibrarySocket", "sourceDirectoryChan", "ourceFileChannel", "ourceStreamChannel", "sourceFunctionContext", "sourceFileContext", "ourceStreamChan", "ourceStreamchannel", " sourceFilesService", "targetLibraryClient", "sourceFileClient", " sourceFileConnection", "sourceLineSocket", "sourceFunctionConnection", "sourceLineClient", "sourceDirectoryChannel", "sourceFilesContext", " sourceFileService", "sourceLineChan", "sourceDirchannel", "targetLibraryChan", "targetFileChannel", "ourceFilechannel", "sourceFileService", "sourceStreamConnection", "sourceFileSocket", "sourceFunctionService", "sourceDirectoryClient", "sourceDirectorySocket", "sourceLineStream", " sourceFilesContext", "targetFileChan", "sourceStreamStream", "sourceStreamChan", "sourceDirChan", "sourceFileChan", "sourceLineChannel", "sourceFilechannel", "ourceFileChan", "ourceFileStream", "sourceStreamContext", "ourceStreamStream", " sourceFilesChannel", "targetFileClient", "targetFileSocket", "sourceLibraryChan", "sourceFunctionChannel"], "destinationFileChannel": ["destinationDirectoryChannel", "destinatorFileService", "destinationFileClient", "destinationIOClient", "destinationFileService", "destinationFileHandler", "destinatorFileCache", "destinationIOCache", "destinationFilesClient", "destinationFileChan", "destinationFilesChannel", "destinationLineChannel", "destinationFileConnection", "destinationLineHandler", "destinationIOChannel", "destinatorFilesCache", "destinatorFileChannel", "destinatorFileConnection", "destinatorFileClient", "destinationDirectoryChan", "destinationFilesChan", "destinatorFilesClient", "destinationFilesConnection", "destinationLineClient", "destinatorFileChan", "destinationLineChan", "destinationDirectoryHandler", "destinationDirectoryCache", "destinationFilesCache", "destinatorFilesService", "destinationLineConnection", "destinatorFilesConnection", "destinatorFilesHandler", "destinationFileCache", "destinationLineService", "destinatorFileHandler", "destinationDirectoryService", "destinationFilesHandler", "destinationDirectoryConnection", "destinationFilesService", "destinatorFilesChan", "destinationDirectoryClient", "destinatorFilesChannel", "destinationIOService"]}}
{"id1": "255765", "id2": "20588811", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public void run() {\n        long time = System.currentTimeMillis();\n        logger.info(\"Version: \" + version);\n        String hostname = properties.getProperty(\"mercuriushost\");\n        String protocol = properties.getProperty(\"mercuriusprotocol\");\n        String port = properties.getProperty(\"mercuriusport\");\n        String path = properties.getProperty(\"mercuriuspath\");\n        String action = properties.getProperty(\"mercuriusaction\");\n        logger.info(\"Getting Timex Data --- \" + getTimeDifferent(time));\n        String xml = timexfrmk.getUnsynchedSessionsXMLFormat();\n        logger.info(\"Done getting Timex Data --- \" + getTimeDifferent(time));\n        if (timexfrmk.getSessionCount() > 0) {\n            try {\n                logger.info(\"Sending Timex Data to Mercurius --- \" + getTimeDifferent(time));\n                String data = URLEncoder.encode(\"action\", \"UTF-8\") + \"=\" + URLEncoder.encode(action, \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"data\", \"UTF-8\") + \"=\" + URLEncoder.encode(xml, \"UTF-8\");\n                if (isAdminFeedKeySet()) {\n                    data += \"&\" + URLEncoder.encode(\"adminfeedkey\", \"UTF-8\") + \"=\" + URLEncoder.encode(adminfeedkey, \"UTF-8\");\n                    logger.debug(\"Using adminfeedkey to authenticate\");\n                } else {\n                    Authenticator.setDefault(new CustomAuthenticator(user, password));\n                    logger.debug(\"Using user/pwd to authenticate\");\n                }\n                String u = protocol + \"://\" + hostname + \":\" + port + path;\n                logger.debug(\"Posting xml data to: \" + u);\n                URL url = new URL(u);\n                URLConnection conn = url.openConnection();\n                conn.setRequestProperty(\"User-Agent\", \"TimexMercurius/\" + version);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                StringBuffer s = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    s.append(line);\n                }\n                if (s.length() > 0) {\n                    logger.debug(s.toString());\n                    if (s.toString().indexOf(\"Result:\") != -1) {\n                        logger.info(s.toString().substring(s.toString().indexOf(\"Result:\")));\n                        if (s.toString().indexOf(\"Result: Successful\") != -1) {\n                            timexfrmk.updateSessionsStatus();\n                        }\n                    } else {\n                        logger.error(s.toString());\n                    }\n                } else {\n                    logger.info(\"No data returned\");\n                }\n                wr.close();\n                rd.close();\n            } catch (MalformedURLException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (IOException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (Exception e) {\n                logger.error(e);\n                logger.trace(e, e);\n            }\n        } else {\n            logger.info(\"There is nothing to send.  Everything has already been synchronized\");\n        }\n        timexfrmk.close();\n        logger.info(\"Done!!! Total Time: \" + getTimeDifferent(time));\n    }\n", "label": 0, "substitutes": {"f": ["path", "fun", "fe", "sf", "n", "fs", "feed", "cf", "df", "fa", "lf", "bf", "rf", "filename", "c", "ref", "j", "fc", "fp", "fi", "l", "s", "fn", "fr", "ff", "form", "fold", "d", "r", "g", "w", "file", "flat", "h", "x", "p", "name", "folder", "e", "m", "io", "t", "fo", "fm", "function", "F", "fd", "self", "a", "fen", "of", "v", "b", "tf", "inf", "this", "fx"], "in": ["IN", "pin", "ssl", "fa", "token", "ini", "ic", "ins", "bin", "thin", "vin", "get", "gen", "it", "a", "with", "din", "ex", "serv", "lock", "part", "source", "up", "connection", "min", "r", "str", "g", "w", "rin", "again", "exec", "isin", "In", "lin", "b", "v", "inn", "win", "n", "gin", "con", "inner", "socket", "session", "reader", "d", "diff", "p", "init", "or", "m", "image", "nin", "ac", "cin", "fe", "input", "c", "l", "pass", "is", "login", "inc", "config", "data", "rec", "t", "err"], "cbuf": ["cbux", "dbuf", "zbuff", "bbuff", "fbbuf", "cfbuf", "rbuff", "bbull", "cbul", "bcul", "CBuc", "bcuc", "bcull", "CBuf", "CBuff", "zbuu", "cfuf", "fbuc", "bcurs", "dbuc", "rbuc", "cbutf", "rbuu", "cbbuf", "cburs", "CBul", "bault", "bux", "buff", "ebuu", "buf", "cfuc", "rbutf", "rbbuf", "rbull", "bcuf", "bcuff", "bcault", "ebuf", "fbuff", "rbux", "zbuf", "bcur", "ebutf", "cbuff", "rbuf", "rburs", "rbul", "cbull", "cbuc", "bbuf", "cbuu", "cfuff", "fbuf", "zbutf", "dbuff", "ebuff", "bburs", "bcux", "dbur", "cfur", "rbault", "cbur", "cbault"], "read": ["index", "Read", "each", "hex", "run", "ride", "en", "raw", "only", "q", "build", "open", "used", "get", "lex", "it", "readable", "ed", "print", "know", "buffer", "num", "id", "feed", "rc", "add", "report", "oct", "ack", "ind", "end", "find", "sync", "use", "load", "r", "g", "work", "w", "level", "un", " READ", "fill", "name", "bit", "ing", "full", "skip", "connect", " reading", "val", "play", "close", "reading", "ok", "socket", "se", "length", "write", "record", "iter", "sleep", "loop", "er", "allow", "reader", "d", "old", " Read", "bind", "insert", "start", "change", "io", "update", "create", "y", "wait", "repeat", " write", "ink", "error", "view", "valid", "ak", "input", "child", "draw", "reads", "pass", "key", "last", "select", "type", "want", "seek", "inc", "data", "text", "config", "check", "x", "size", "log", "put", "cel", "send", "call", "pe", "k", "parse", "stream", "ize", "count", "READ", "re", "orig"], "totRead": ["octotoLength", "tottedWrite", "TotGet", "tcotClose", "tcotRead", "dottLoad", "octotWrite", " totalBuild", "tottedGet", "tntReader", "tottUse", "octotoRead", "totLink", "totBuild", "towLength", "dottReader", "totoLength", "tazonClose", "tetReading", "toyDraw", "totClose", "totiBuild", " totWrite", "notLoad", "notWrite", "intottBuild", "tottLength", "tottAccept", "totalLoad", "towLoad", "totalLink", " totalWrite", "nottAccept", "towWrite", "nottRead", "totoSearch", "tochRead", "intotLoad", "tottReading", "tottWrite", "toyWrite", "tollRead", "tottedRead", "tottLoad", "octotLength", "TotConnect", "ntotWrite", "tetRead", "TotLoad", "totoUse", "tntRead", "dottUse", "octotReading", "TottConnect", "ntottLoad", "TotSearch", "TotaRead", "totoLoad", "tntLoad", "TotaLoad", "tottClose", "totDraw", "totLength", "towAccept", "TottReading", "tobyRead", "intotClose", "towReading", "totingSearch", "totaDraw", "totoWrite", "TotDraw", "nottLoad", "toyRead", "tcotBuild", "totReading", "totConnect", "octotRead", "ntottWrite", "totalAccept", "totalRead", "totLoad", "tazonBuild", "totalBuild", "tntWrite", "totoRead", "dotRead", "ntotRead", "totingWrite", "ntotLoad", "totReader", "notAccept", "totaRead", " totBuild", "tottSearch", "ntottReader", "notRead", "totingRead", "totWrite", "tazonLoad", "totingGet", "dotLoad", "dotReader", "dotUse", "dottFind", "tobyFind", "TotaWrite", "tochLoad", "tottedFollow", "ntotReader", "intotRead", "intottLoad", "totUse", "totaReading", "totaLoad", "totaWrite", "tcotLoad", "TottReader", "tottReader", "totiRead", "tatRead", "totiWrite", "dottWrite", "toyLoad", "TottFollow", "tottFollow", "tatLoad", "totingConnect", "dotFind", "tochReader", "tottConnect", "dottReading", "intotBuild", "TotReader", "totoFind", "tollLoad", "tochWrite", "tobyUse", "tottDraw", "dottRead", "totaLink", "tobyLoad", "totoConnect", " totalRead", "totingFollow", "TottLoad", "TottWrite", "TotaDraw", "tottRead", "tetWrite", "totFind", "nottWrite", "towRead", "TotReading", "totalWrite", "octotoReading", "tollReading", "tatReader", "tollWrite", "dotReading", "tottFind", "ntottRead", "intottRead", "totiLink", "totFollow", "tetLoad", " totalLink", "tazonRead", "totSearch", "TotFollow", "totGet", "octotoWrite", "TottRead", "TotRead", "totaBuild", "TottGet", " totLink", "intottClose", "totoReading", "tottGet", "TottSearch", "totaReader", "dotWrite", "totAccept", "tottBuild", "tatWrite", "TotWrite"], "out": ["ex", "output", "n", "plus", "outer", "net", "c", "OUT", "socket", "o", "outs", "l", "fn", "s", "off", "bin", "client", "sync", "part", "d", "up", "connection", "r", "g", "w", "inc", "parent", "file", "h", "x", "p", "conn", "init", "again", "exec", "Out", "io", "t", "exp", "writer", "In", "a", "ext", "conf", "v", "b", "err", "obj", "ac"], "i": ["index", "ini", "ic", "ii", "q", "chi", "ci", "I", "eni", "zi", "it", "hi", "iu", "multi", "info", "buffer", "id", "ind", "z", "ui", "ori", "ti", "source", "r", "g", "ip", "mi", "ai", "name", "oi", "e", "b", "v", "ik", "uri", "ei", "yi", "slice", "o", "length", "qi", "one", "ji", "d", "phi", "h", "p", "bi", "u", "init", "start", "m", "io", "di", "y", "ni", "api", "ix", "input", "pi", "ie", "c", "current", "j", "fi", "ri", "l", "si", "is", "key", "my", "data", "li", "x", "xi", "gi", "k", "me", "abi"]}}
{"id1": "8000624", "id2": "20091126", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": ["CopyFile", "copyTo", " transferto", " copyTo", "CopyFrom", "Copyto", "copyto", " copyto", " transferTo", " copyFile", "copyFile", " transferFrom", " transferFile", " copyFrom", "copyFrom"], "dest": ["path", "rest", "class", "temp", "output", "filename", "table", "cont", "later", "destroy", "write", "done", "bin", " Dest", "content", "exit", "txt", "die", "comb", "source", "wb", "target", "dist", "w", "data", "file", "src", "tmp", "Dest", "flat", "object", "delete", "test", "name", "folder", "desc", "opt", "sup", "obj", " destination", "them", "transform", "orig", "img"], "in": ["IN", "pin", "sin", "i", "input", "fa", "n", "id", "plus", "ini", "din", "gin", "con", "inner", "as", "l", "ins", "s", "bin", "pass", "reader", "source", "thin", "lib", "up", "login", "connection", "inside", "r", "wave", "inc", "rin", "vin", "h", "x", "init", "conn", "issue", "again", "m", "ax", "image", "isin", "In", "nin", "kin", "ln", "pull", "lin", "b", "ac", "cin", "inn", "f", "win", "re"], "out": ["pin", "ou", "temp", "ex", "output", "n", "copy", "outer", "i", "timeout", "plus", "user", "net", "OUT", "inner", "socket", "o", "outs", "off", "bin", "outside", "sync", "client", "part", "one", "no", "cache", "lib", "up", "not", "target", "our", "other", "w", "inc", "data", "file", "object", "x", "conn", "or", "again", "name", "exec", "Out", "writer", "io", "image", "call", "nin", "app", "ext", "url", "err", "b", "vert", "this", "external"], "c": ["cu", "buffer", "i", "cc", "sc", "n", "cf", "rc", "enc", "ic", "fc", "cb", "o", "col", "l", "dc", "char", "content", "ec", "cm", "d", "ce", "uc", "lc", "ct", "oc", "r", "ch", "cy", "config", "ca", "cl", "exc", "xc", "x", "p", "C", "u", "arc", "e", "ci", "m", "t", "cr", "pointer", "esc", "pc", "bc", "abc", "comment", "v", "ac", "f", "code"]}}
{"id1": "20929570", "id2": "11377441", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"toMd5": ["toMm7", "toMmd512", "toBd7", "toBd15", "toMm512", "toBmd15", "toMcd15", "toMm15", "toBmd5", "toBd512", "toBd5", "toMcd512", "toMd512", "toMcd7", "toMcd5", "toMd15", "toMmd15", "toMm5", "toBmd512", "toBmd7", "toMmd5", "toMd7", "toMmd7"], "str": ["string", "buffer", "temp", "input", "enc", "result", "s", "fr", "dr", "pass", "in", "char", "txt", "arr", "Str", "source", "r", "STR", "data", "text", "out", "conn", "msg", "name", "e", "exp", "bytes", "tr", "url", "obj", "sp", "b", "err", "st", "br", "kr", "f", "stri", "sr", "sec"], "messageDigest": ["MessageDigester", "moredigested", "messageDested", "messageDigse", "MessageDigetter", "messageGEST", " messageDest", "messageGester", "messageDigester", "messagedigEST", "moredigest", "MessageDigested", "messageDher", "MessageMarkher", "messageDefest", "Messagedigested", "messageMixested", "MessageDefest", "messageDiguster", "messageDefested", "MessageDefested", "messageDuster", "messagedigeter", "messageUploadested", "MessageDigse", "messageMarkher", "messageDeter", "messageDse", "messageDigeter", "messageDefse", "messageDefester", "messageDEST", " messageDester", "messageDest", "messageMixse", "moreDigeter", "messageDigEST", "messagedigested", "messageMixester", "MessageDigest", "moreDigest", "messagedigetter", " messageDigEST", "moredigeter", " messageDEST", "moreDigested", "messageMarkest", "MessageMarketter", "MessageMarkester", "messageUploadEST", "messageMarketter", "MessageDigEST", "messageGuster", "Messagedigest", "MessagedigEST", "moredigester", " messageDuster", "messageDigher", "messageGest", "messageUploadest", "messageDester", "messageDigested", "MessageMarkest", "messageUploadester", "messagedigher", "messageHashest", "messagediguster", "messageDetter", "messagedigest", "messagedigester", " messageDiguster", "messageHashester", "MessageDefse", "messageHashested", " messageDigester", "MessageDefester", "messageMixest", "messageMarkester", "messageDigetter", "moreDigester", "Messagedigester", "MessageDigher", "messageHasheter"], "byteArray": ["bitArray", "resourceIndex", "ByteBuffer", " byteOrder", "wordarray", "byteLength", "ByteAmount", "ByteOrder", "pixelObject", "resourceArray", "ByteLength", "charBuffer", "byteBuffer", "ByteNumber", "wordBuffer", "doublearray", "ByteArray", "bitIndex", "bitObject", "byteAddress", "pixelLength", "charNumber", "pixelArray", "charArray", " byteBuffer", "byteIndex", "charAmount", "bitarray", "doubleArray", " byteAddress", "resourcearray", "byteString", "ByteAddress", "wordString", "doubleBuffer", "bitLength", " byteString", " byteLength", " byteIndex", "byteAmount", "byteObject", "wordArray", " byteAmount", " bytearray", "charLength", "charOrder", "bytearray", "byteOrder", "pixelBuffer", "charObject", "byteNumber", "resourceLength", "charAddress", " byteNumber", "doubleString", "bitBuffer"], "md5StrBuff": ["md5StRef", "md5StrComp", "md2StringDb", "md5strApp", "md2StrRef", "md5STRBuff", "md5StringBuffer", "md5STRRest", "md5StringBuff", "md2StringText", "md5StringDb", "md6Strbuff", "md5strText", "md5StrRest", "md5StText", "md5StrText", "md5StringRest", "md5strbuff", "md5strBuffer", "md5StBuff", "md5StDb", "md5TrBuffer", "md2StrDb", "md2StringBuffer", "md2StringApp", "md5StringRef", "md5TrText", "md5StrRef", "md5Trbuff", "md6StrText", "md5StringText", "md6StrBuff", "md2StrText", "md5Stringbuff", "md5strBuff", "md5TrDb", "md5Strbuff", "md6strBuff", "md2StrComp", "md5StrDb", "md2StringRef", "md2StringComp", "md2StringBuff", "md5StBuffer", "md5StringComp", "md5TrBuff", "md2StringRest", "md2StrApp", "md2StrRest", "md6strbuff", "md5StringApp", "md2StrBuffer", "md6strBuffer", "md5StrApp", "md5StRest", "md6strText", "md5STRBuffer", "md6StrBuffer", "md5StComp", "md5StApp", "md5STRComp", "md2StrBuff", "md5StrBuffer", "md5TrRef"], "i": ["index", "info", "id", "n", "pi", "uri", "mu", "ie", "slice", "c", "inner", "j", "fi", "ri", "o", "l", "length", "si", "ui", "ii", "in", "qi", "part", "ti", "ji", "d", "lc", "phi", "li", "h", "x", "p", "ip", "bi", "u", "ai", "oi", "name", "ci", "I", "e", "io", "it", "xi", "gi", "di", "k", "b", "v", "y", "abi", "iu", "multi", "f", "field", "ix"]}}
{"id1": "7166270", "id2": "12883117", "code1": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "code2": "    public PhoneSetImpl(URL url) throws IOException {\n        BufferedReader reader;\n        String line;\n        phonesetMap = new HashMap();\n        reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        line = reader.readLine();\n        lineCount++;\n        while (line != null) {\n            if (!line.startsWith(\"***\")) {\n                parseAndAdd(line);\n            }\n            line = reader.readLine();\n        }\n        reader.close();\n    }\n", "label": 1, "substitutes": {"issueCommandToServer": [" sendRequestToClient", " sendRequestFromService", " sendCommandToServer", " sendRequestToService", " sendCommandWithService", " sendRequestFromserver", " sendCommandtoService", " sendRequestToserver", " sendCommandFromService", " sendCommandFromClient", " sendCommandToClient", " sendRequestToServer", " sendCommandToserver", " sendCommandWithserver", " sendCommandtoClient", " sendCommandWithServer", " sendCommandFromServer", " sendCommandtoserver", " sendCommandToService", " sendRequestFromClient", " sendRequestFromServer", " sendCommandFromserver", " sendCommandtoServer", " sendCommandWithClient"], "command": ["directory", "event", "string", "address", "buffer", "method", "Command", "execute", "resource", "timeout", "message", "document", "sequence", "description", "version", "argument", "patch", "query", "domain", "pattern", "queue", "password", "operation", "value", "connection", "component", "application", "data", "text", "request", "action", "function", "comm", "menu", "script", "attribute", "cmd", "module", "service", "code"], "changeCapsule": ["changeCapulation", "changeCapesulation", "changeScapure", "changeCorpule", "changeCapesulate", "changeScapsulate", "changeScapole", "changecapsulate", "changeScapsole", "changeCapesule", "changecapsules", "changeCambulate", "changecAPSules", "changeCAPSule", "changecapsule", "changeCapsules", "changeCapules", "changeScapulate", "changecAPSulate", "changeCapsole", "changecAPSule", "changeScapule", "changecapsulation", "changeCambule", "changeCorpulate", "changeScapsule", "changeScapsure", "changeCapesules", "changeCorpure", "changeCambole", "changeCAPSulation", "changeCapole", "changeCAPSulate", "changeCapule", "changeCapsure", "changeCAPSules", "changeCapure", "changeCambure", "changeCorpole", "changeCapulate", "changeCapsulation", "changeCapsulate", "changecAPSulation"], "urlConn": ["serverConn", "httpDec", " urlExec", "urlConnection", " urlOpen", "httpOpen", " urlCo", "urlCo", "httpConnection", "serverDec", "lConnection", "userConn", "urlAuth", "serverCo", "lConnect", "UrlExec", " urlConnect", "urlExec", "httpConn", "serverAuth", "lFs", "urlConnect", "serverConnect", "lConn", "serverConnection", "urlEnc", " urlConnection", "UrlEnc", "UrlConnector", " urlEnc", "urlDec", " urlDec", "userConnect", "httpCo", "httpFs", "userConnection", "urlConnector", "UrlConnect", "urlFs", " urlAuth", "serverExec", "UrlConn", " urlConnector", "serverConnector", "userOpen", "urlOpen", "serverEnc", "UrlAuth", " urlFs", "httpConnect"], "wr": ["nw", "Wr", "rw", "nr", "wp", "NW", "vr", "wl", "wk", "WR", "fw", "wt", "wm", "mr", "wd", "usr", "shr", "Writer", "ws", "rh", "wb", "wh", "r", "w", "war", "wer", "wcs", "conn", "rr", "writer", "rx", "cr", "worker", "tw", "hr", "err", "kr", "wire", "wa", "sw", "RW", "wx", "sr", "raft"], "content": ["string", "buffer", "temp", "server", "output", "resource", "enc", "message", "description", "c", "document", "cont", "json", "child", "write", "password", "Content", "raw", "equ", "source", "activity", "value", "wave", "section", "config", "data", "text", "body", "work", "request", "context", "format", "header", "exec", "array", "esc", "const", "url", "comment", "create", "xml", "script", "method", "code"], "input": ["error", "buffer", "ssl", "temp", "i", "output", "self", "resource", "rc", "ink", "json", "ack", "socket", "inner", "usr", "in", "active", "iter", "raw", "form", "er", "reader", "source", "Input", "inf", "inside", "r", "wave", "w", "inc", "data", "acl", "out", "through", "amp", "request", "keep", "conn", "rr", "init", "rss", "writer", "image", "worker", "ctx", "inch", "pull", "stream", "hr", "audio", "xml", "cur", "element", "enter"], "response": ["string", "buffer", "server", "output", "resource", "feed", "uri", "report", "vector", "site", "message", "json", "onse", "result", "answer", "line", "ception", "resp", "connection", "value", "model", "application", "collection", "wave", "data", "page", "request", "object", "reply", "tree", "image", "writer", "array", "generation", "Response", "respond", " Response", "secret", "reference", "office", "service", "api"], "str": ["letter", "string", "i", "id", "spec", "enc", "result", "l", "line", "fr", "dr", "char", "iter", "arr", "raw", "er", "Str", "type", "pr", "lc", "ner", "r", "div", "STR", "data", "text", "cl", "style", "name", "coll", "exec", "cr", "exp", "dec", "sl", "tr", "url", "hr", "err", "sp", "kr", "br", "st", "obj", "strike", "f", "stri", "list"]}}
{"id1": "23611770", "id2": "22264586", "code1": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"handle": [" work", " fn", " next", " abort", " reload", " loop", " operate", " handler", " transfer", " post", " append", " upload", " redirect", " serve", " execute", " manage", " rename", " transport", " perform", " process", " rewrite", "process", " restart", " shutdown", "transfer", "Handle", " transform", " handles"], "srcChannel": ["srcConnection", "srcchannel", "sourcechannel", "sourceChannel", "sourceClient", "destChan", " srcConnection", "sourceChan", " srcClient", "destClient", "sourceConnection", "destchannel", " srcchannel", "srcClient", "rcClient", "rcChan", " srcChan", "rcChannel", "srcChan", "rcConnection"], "destChannel": ["distChan", "Destchannel", "DestCan", "distchannel", "sourceChannel", "destChan", "descChannel", "DestHandler", "distChannel", "destSocket", "descHandler", "DestChannel", "sourceChan", "destHandler", "destStream", "descCan", "destCan", "DestStream", "destchannel", " destHandler", "srcSocket", " destChan", " destchannel", " destStream", "sourceSocket", "srcChan", "descChan", " destCan", " destSocket", "distStream", "DestChan"], "destOutFile": ["destoutFile", "destInPath", "featTemplatefile", "destPointDir", " destPathDir", "destOutputDirectory", " destOutFiles", "destInFile", "destOutPath", "featOutFiles", "DestInFiles", "destOutfile", "destPathDir", " destPathFile", "destInCode", "destActionFile", "destPointDirectory", " destOutputFile", "tempOutputFile", "destOutFiles", "destOutputfile", "destoutFiles", "destPathFile", "DestOutFiles", "featOutfile", "destLogFile", " destOutputFiles", "DestInDir", " destOutfile", "destOutputSite", " destOutDir", "tempOutputSite", " destOutFilename", "DestOutFile", "DestOutCode", "destLogFilename", "destActionFiles", "DestInDirectory", "destOUTCode", "tempOutDir", "DestOutDir", "destInfile", "DestInFile", "featTemplateFile", "DestOutDirectory", "destLogFiles", "tempOutputFiles", "tempOutputDir", "destOutDir", "destTemplateFiles", "destActionfile", "DestOutFilename", "DestInfile", "destOUTDir", "featOutFile", "destInDir", "destoutDir", "DestInCode", "destOutputFile", " destPathfile", "featOutDir", " destOutPath", "destPathfile", "featTemplateFiles", "destActionDir", "DestInFilename", "destOutputDir", "destOutputFiles", "tempOutFile", "destPathFiles", "destPointFile", "destInFiles", "destOutputPath", " destPathFiles", "destOutCode", "destInDirectory", "tempOutSite", "tempOutFiles", "destoutCode", "DestOutfile", "destOUTSite", "destInFilename", "destOUTFiles", "destInSite", "destTemplateDir", "destOutFilename", "destOUTFile", "destTemplatefile", "destPointFilename", " destOutputPath", "destOutputFilename", "destLogPath", "destOutDirectory", "featTemplateDir", "destOutSite", "destTemplateFile", " destOutputFilename"], "destOutFileCompressed": ["destOutFileSuppressed", "destOutFileExressed", "destOutFilesComplied", "destOutFilesExplied", "destOutFileExposed", "destOutFilesExpression", "destOutFilesCompressed", "destOutFilesExpressed", "destOutFileExported", "destOutLineCompress", "destOutFileExpacted", "destOutFileReposed", "destOutFileRepression", "destOutFilesExpressor", "destOutFileRepacted", "destOutFilesCompress", "destOutFileRepressed", "destOutLineComposed", "destOutFileSuppacted", "destOutFileExpressed", "destOutFileReplied", "destOutFilesExpacted", "destOutFileSupress", "destOutLineRepressor", "destOutLineExposed", "destOutFileExosed", "destOutLineCompressed", "destOutFileSupressed", "destOutLineRepressed", "destOutFilesCompression", "destOutFileCompress", "destOutFilecompacted", "destOutFileSuppress", "destOutLineRepacted", "destOutFileSuposed", "destOutLineExpressor", "destOutFileEncorted", "destOutFileExress", "destOutFilesExported", "destOutLineRepression", "destOutFilesExpress", "destOutLineCompression", "destOutFileSuppressor", "destOutFilesCompressor", "destOutLineExpressed", "destOutFileExpress", "destOutFileCompressor", "destOutFilecompress", "destOutFileEncosed", "destOutFileExpression", "destOutFilesExposed", "destOutFileRepressor", "destOutFilecompressed", "destOutFileComported", "destOutFilesComposed", "destOutFilecompression", "destOutFileCompression", "destOutFileExorted", "destOutFileEncress", "destOutFileSupression", "destOutFileRepress", "destOutLineExpression", "destOutLineCompacted", "destOutFileComplied", "destOutFileExressor", "destOutFileCompacted", "destOutFilecompressor", "destOutLineCompressor", "destOutFileExacted", "destOutFileExpressor", "destOutLineRepress", "destOutFilesComported", "destOutFileExplied", "destOutFileEncressed", "destOutFileComposed", "destOutFilesCompacted"], "out": ["temp", "ex", "output", "n", "copy", "outer", "user", "lock", "resource", "self", "server", "net", "plain", "OUT", "inner", "socket", "o", "outs", "line", "co", "bin", "extra", "key", "post", "client", "sync", "part", "one", "source", "cache", "doc", "up", "connection", "w", "conv", "data", "file", "inc", "parent", "cmd", "log", "null", "conn", "again", "name", "exec", "Out", "io", "image", "exp", "writer", "to", "full", "flush", "ext", "b", "err", "obj", "error", "this", "img"], "in": ["IN", "sin", "pin", "input", "id", "serv", "token", "resource", "ini", "gin", "into", "con", "c", "inner", "socket", "o", "l", "ins", "bin", "pass", "is", "part", "reader", "source", "up", "login", "diff", "min", "connection", "r", "wave", "inc", "config", "data", "rin", "file", "h", "log", "init", "conn", "again", "image", "to", "isin", "In", "nin", "a", "pull", "lin", "b", "err", "ac", "cin", "inn", "f", "win", "din", "img"], "buf": ["val", "path", "info", "buffer", "job", "base", "Buffer", "num", "bf", "input", "bd", "rc", "bh", "map", "cap", "lb", "ref", "cb", "result", "pool", "off", "ff", "feat", "func", "queue", " buffer", "uf", "la", "bag", "cv", "rb", "cas", "uc", "wb", "buff", "lc", "wave", "data", "text", "src", "file", "fb", "config", "bb", "log", "context", "header", "box", "vec", "port", "pos", "bytes", "ctx", "bc", "seq", "b", "v", "br", "bl", "pad", "block", "batch", "cur", "loc"], "len": ["val", "num", "id", "n", "lf", "lock", "pre", "Len", "cap", "ie", "led", "ind", "end", "limit", "l", "length", "line", "el", "en", "ler", "iter", "fl", "fin", "la", "nt", "part", "no", "lc", "min", "data", "li", "body", "lim", "le", "size", "ll", "pos", " length", "sl", "rev", " lang", "ln", "url", "lin", "count", "f", "loc"]}}
{"id1": "2807585", "id2": "23531898", "code1": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 0, "substitutes": {"encodeMd5": ["encodeMf512", "encodeBmd512", "encodeBmd4", "encodeMmd256", "encodeMmd4", "encodeMb256", "encodeBmd256", "encodeMf4", "encodeBd512", "encodeMb512", "encodeMb4", "encodeBd256", "encodeMd512", "encodeMmd5", "encodeBd4", "encodeMb5", "encodeMd256", "encodeMmd512", "encodeMd4", "encodeBd5", "encodeBmd5", "encodeMf256", "encodeMf5"], "key": ["keys", "path", "address", "base", "ace", "id", "self", "token", "message", "wk", "hex", "length", "char", "password", "type", "mac", "seed", "value", "KEY", "data", "text", "Key", "row", "or", "msg", "name", "ring", "word", "prefix", "k", "pair", "secret", "sign", "block", "crypt", "cert", "phrase", "hash", "code"], "md": ["bf", "mag", "bd", "od", "Cmd", "amd", "map", "mo", "ma", "mode", "wd", "MD", "dc", " MD", "ms", "ad", "rpm", "mobi", "docker", "gb", "mb", "git", "mt", "mac", "d", "mp", "hd", "sha", "pm", "pd", "mm", "mi", "metadata", "cd", "dig", "m", "dm", "mand", "mc", "der", "di", "nm", "mod", "rm", "mg", "cmd", "dd", "code"], "bytes": ["keys", "zip", "string", "address", "bles", "buffer", "output", "results", "pieces", "tes", "sequence", "les", "outs", "s", "bs", "parts", "items", "binary", "lines", "blocks", "strings", "bps", "buf", "data", "classes", "body", "objects", "ips", "es", "null", "groups", "Bytes", "vs", "seconds", "rows", "values", "seq", "b", "units", "words", "bits", "boot", "letters"], "result": ["string", "info", "address", "buffer", "root", "reason", "output", "response", "resource", "replace", "entry", "results", "res", "master", "message", "description", "hex", "match", "content", "raw", "source", "expected", "value", "diff", "str", "default", "data", "text", "null", "array", "success", "prefix", "url", "secret", "Result", "hash", "valid"]}}
{"id1": "13720140", "id2": "10361370", "code1": "    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {\n        Property property = new Property(new Long(valueID), userID);\n        String newValue = value;\n        System.out.println(property.getName());\n        if (property.getName().equals(\"Password\")) {\n            try {\n                MessageDigest crypt = MessageDigest.getInstance(\"MD5\");\n                crypt.update(value.getBytes());\n                byte digest[] = crypt.digest();\n                StringBuffer hexString = new StringBuffer();\n                for (int i = 0; i < digest.length; i++) {\n                    hexString.append(hexDigit(digest[i]));\n                }\n                newValue = hexString.toString();\n                crypt.reset();\n            } catch (NoSuchAlgorithmException e) {\n                System.err.println(\"jspShop: Could not get instance of MD5 algorithm. Please fix this!\" + e.getMessage());\n                e.printStackTrace();\n                throw new JspTagException(\"Error crypting password!: \" + e.getMessage());\n            }\n        }\n        property.setValue(newValue);\n    }\n", "code2": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "label": 1, "substitutes": {"modifyProperty": ["modifyproperty", "modateString", "modifiedproperty", "modureProperty", "ModifyAttribute", "modifyString", "modateAttribute", "ModifiedString", "ModifiedAttribute", "modureproperty", "Modifiedproperty", "modureString", "ModifyProperty", "modifiedProperty", "modateProperty", "modifyAttribute", "Modifyproperty", "modifiedAttribute", "modureAttribute", "ModifiedProperty", "modateproperty", "modifiedString", "ModifyString"], "valueID": ["ValueIndex", "ValueID", "propertyid", "ValueId", "propertyIP", "VALUEID", "valueId", "VALUEIndex", "jobId", "jobIP", "contentID", "VALUEid", "valueid", "valueIndex", "ValueIP", "jobid", "Valueid", "valueIP", "jobID", "propertyID", "contentIndex", "contentid", "propertyId"], "value": ["val", "string", "address", "server", "output", "response", "resource", "username", "token", "entry", "message", "description", "document", "result", "number", "key", "pattern", "content", "password", "expression", "Value", "source", "target", "default", "data", "text", "VALUE", "object", "language", "format", "name", "example", "image", "function", "array", "values", "update", "secret", "v", "reference", "command", "padding", "attribute", "phrase", "element", "code"], "userID": [" userId", "userName", "Userid", "authorId", "UserMAC", "authorid", " userMAC", "authorMAC", "userId", "userMAC", " userid", "authorName", " userName", "UserName", "userid", "UserID", "UserId", "authorID"], "property": ["string", "info", "base", "address", "foo", "temp", "resource", "definition", "entry", "option", "message", "profile", "character", "project", "primary", "result", "jo", "key", "password", "expression", "part", "Property", "type", "operation", "connection", "module", "feature", "section", "config", "data", "parent", "tmp", "entity", "variable", "object", "metadata", "p", "prototype", "style", "name", "function", "operator", "prefix", "layer", "position", "update", "this", "pair", "prop", "attribute", "properties", "method", "field", "element", "term"], "newValue": ["nextValue", "currentVal", "newVal", "replaceVal", "oldvalue", "defaultvalue", "currentValue", " newVal", "defaultVALUE", "nextVal", "oldVALUE", " newVALUE", " newvalue", "rawVal", "NewVALUE", "NewVal", "rawVALUE", "defaultValue", "rawValue", "currentvalue", "newString", "replacevalue", "NewValue", "oldVal", "currentVALUE", "nextVALUE", " newString", "nextvalue", "rawString", "replaceVALUE", "oldValue", "defaultVal", "newvalue", "NewString", "replaceValue", "newVALUE"], "crypt": ["ssl", "core", "temp", "cc", "cmp", "copy", "enc", "chip", "con", "c", "python", "hex", "Crypt", "ryption", "prot", "pool", "key", "security", "password", "ec", "comb", "client", "cm", "cp", "mac", "cache", "lib", "binary", "ctr", "ch", "mix", "bec", "conv", "ca", "poly", "utils", " cryptography", "conn", "coll", "chain", "rypt", "cr", "dec", "com", "cook", "auth", "cash", "contract", "coin", "pt", "cmd", "hash", "code"], "digest": ["encress", "Digester", "codress", "designest", " digend", "DigEST", "Diger", "ddest", "signEST", "crist", "signest", "Digress", "signer", "gener", " digist", "digit", "signested", "genested", "crester", "Digoded", "genEST", "cododed", "digester", "ddusher", "digend", "crend", "digested", "Digit", "encester", "crest", "designit", "digress", "Digest", "designester", "digoded", "Digend", "codester", "Digusher", "digusher", "Digist", "diger", "encest", "ddester", "codest", "designusher", "digist", " digester", "genest", "Digested", "encoded", "digEST", "ddit"], "hexString": ["hexBuffer", "cryptArray", "tempSection", "hexArray", "hexSection", "hashStr", "hexstring", "byteBuffer", " hexStr", " hexBuffer", " hexArray", "rexString", "cryptString", " hexSection", "cryptSection", "byteString", "exString", "cryptBuffer", "tempString", "rexBuffer", "hexStr", "hashString", "rexArray", "exBuffer", "tempArray", "exArray", "hashArray", " hexstring", "rexstring", "exstring", "tempBuffer", "byteArray", "byteStr", "hashBuffer"], "i": ["index", "info", "id", "uri", "pi", "mu", "slice", "c", "j", "ri", "o", "l", "s", "si", "ui", "ii", "in", "key", "ti", "d", "phi", "r", "data", "li", "h", "x", "p", "ip", "bi", "u", "init", "oi", "e", "I", "ci", "m", "io", "pos", "it", "xi", "di", "gi", "hi", "k", "v", "b", "abi", "multi", "f", "field", "ix"]}}
{"id1": "4618237", "id2": "15129155", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    public List<String> extractUrlList(String url) throws IOException, XPathExpressionException {\n        LinkedList<String> list = new LinkedList<String>();\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        Tidy tidy = new Tidy();\n        tidy.setErrout(new NullPrintWriter());\n        Document doc = tidy.parseDOM(conn.getInputStream(), null);\n        int len = conn.getContentLength();\n        if (len <= 0) len = 32000;\n        ByteArrayOutputStream bout = new ByteArrayOutputStream(len);\n        PrintStream ps = new PrintStream(bout);\n        tidy.pprint(doc, ps);\n        ps.flush();\n        String content = bout.toString();\n        Pattern p = Pattern.compile(\"(http://[\\\\w\\\\\\\\\\\\./=&?;-]+)\");\n        Matcher m = p.matcher(content);\n        while (m.find()) {\n            list.add(m.group());\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"writeFileToFile": ["writeFileAndFile", "writeFileToChannel", "writeFilesToFile", "writeFileAsFile", "writeFile2Channel", "writeFileAsFiles", "writeFileAndChannel", "writeFile2File", "writeFilesAsChannel", "writeFile2Files", "writeFileToFiles", "writeFilesAsFiles", "writeFile2Stream", "writeFilesAsFile", "writeFileAndStream", "writeFilesToChannel", "writeFileAsStream", "writeFilesToFiles", "writeFileAndFiles", "writeFilesToStream", "writeFileAsChannel", "writeFileToStream", "writeFilesAsStream"], "fin": ["pin", "fat", "fa", "rf", "ini", "fine", "fi", "fp", "inv", "fn", "arin", "Fin", "fr", "rt", "ori", "en", "thin", "file", "rin", "init", "conn", "nir", "ris", "fm", "FIN", "kin", "fd", "ln", "fen", "pins", "lin", "include", "raf", "inn", "f", "inf", "din"], "fout": ["bOut", "rfin", "foff", "boff", " fint", "fOut", " fOut", "Foff", "bout", "Fin", "bin", "FOut", "rfout", " foff", "rfOut", "rfint", "Fout", "fint", "Fint"], "append": ["push", "string", "remove", "pend", "optional", "enc", "add", "end", "opp", "ending", "save", "fail", "password", "only", "except", "ended", "want", "open", "batch", "text", "flat", "null", "adjust", "send", "apply", "pack", "leaf", "app", "ext", "flush", "update", "future", "atten", "printf", "pad", "spread", "padding", "vert", "protect"], "inChannel": ["inputChannel", "innerStream", "INchannel", "inStream", " inchannel", "inchannel", "InChan", "loginChannel", "innStream", "inputChan", "Inchannel", "INChan", "outStream", "outchannel", "innerChannel", "outQueue", "innerConnection", "inputConnection", "outChan", "inChan", "InChannel", "innerChan", "inputStream", "InStream", "innchannel", "inQueue", "INStream", "INChannel", " inQueue", " inStream", "inConnection", "innerchannel", "loginchannel", "loginStream", "INConnection", "innChannel", "INQueue"], "outChannel": ["externalChan", " outContext", "inSocket", "OutStream", "inStream", "externalSocket", "OutChannel", "inchannel", "outContext", "ioStream", "outputSocket", "OutChan", "externalchannel", "outStream", "inContext", "outchannel", "iochannel", "ioChan", "outChan", "inChan", "OutContext", "outputchannel", "outputChannel", "outSocket", "Outchannel", "externalChannel", "outputChan", "ioChannel", " outchannel", " outChan"]}}
{"id1": "7809093", "id2": "11546108", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getContent": ["setContent", "requestBody", "setBody", " getData", "GetOutput", "responseBody", "GetContent", "GetData", " getBody", "requestContent", " getEntity", "GetBody", "setEntity", "GetEntity", "responseContent", "getBody", "getEntity", "responseOutput", "responseEntity", "setData", "getData", "requestEntity", "getOutput", "requestOutput"], "request": ["string", "path", "address", "handler", "input", "Request", "resource", "uri", "server", "user", "http", "report", "message", "current", "result", "instance", "query", "queue", "req", "type", "q", "operation", "connection", "r", "application", "data", "route", "object", "name", "e", "QUEST", "position", "url", "reference", "xml", "method"], "sb": ["buffer", "BB", "sf", "bf", "sk", "usb", "bd", "bh", "vm", "sg", "lp", "lb", "eb", "lab", "cb", "fp", "obb", "bs", "su", "pb", "bg", "gb", "abb", "rb", "sa", "ab", "binary", "wb", "bj", "src", "fb", "bb", "zb", "ls", "nb", "db", "sup", "bt", "ib", "bc", "bp", "b", "xb", "bm", "abi", "bsp", "amb", "SB"], "client": ["remote", "ssl", "handler", "tc", "console", "server", "output", "uri", "resource", "builder", "http", "net", "con", "per", "c", "current", "project", "host", "util", "queue", "session", "ce", "cache", "proxy", "bird", "connection", "application", "default", "config", "channel", "https", "cl", "web", "p", "context", "conn", "plugin", "force", "apache", "call", "app", "url", "Client", "connect", "container", "contact", "cli", "service", "api"], "httpParams": ["HTTPPARums", "httpArums", "httpPARams", "httpPARamas", "httpPerparams", "httpPARam", "HTTPParcs", "httpPamer", "httpPoeters", "httpPreters", "HttpParam", "httpPerams", "httpPARparams", "httpParamas", "httpAram", "httpPARcs", "httpArcs", "HTTPPARams", "HTTPPoamer", "HTTPPARcs", "httpPoparams", "httpPareters", "httpPeram", "HTTPParam", "httpPrams", "HTTPPoeters", "httpParums", "httpParparams", "HTTPParamer", "httpPeramas", "httpArams", "httpPARums", "httpPoams", "httpParcs", "httpPeters", "HttpParams", "httpPoamer", "httpPramer", "HTTPParparams", "HTTPPARam", "HTTPPoparams", "HTTPPareters", "httpPams", "httpParam", "HttpParamas", "httpPrparams", "httpPparams", "HTTPPoams", "httpParamer", "HTTPParums", "HTTPParams", "HttpParparams"], "response": ["server", "resource", "output", "feed", "report", "http", "results", "message", "json", "document", "onse", "result", "relation", "resp", "connection", "model", "application", "collection", "data", "body", "page", "object", "reply", "status", "success", "received", "Response", "respond", "successful", "error", "api", "view"], "entity": ["event", "article", "translation", "address", "node", "agent", "server", "resource", "Entity", "output", "entry", "http", "document", "json", "result", "instance", "company", "content", "ent", "type", "source", "ce", "connection", "component", "media", "model", "application", "collection", "data", "file", "body", "channel", "object", "environment", "conn", "creator", "coll", "e", "writer", "person", "pe", "em", "xml", "element", "api"], "reader": ["ry", "buffer", "loader", "i", "input", "handler", "server", "editor", "feed", "reading", "per", "inner", "ri", "driver", "read", "in", "iter", "ler", "er", "source", "bird", "oder", "ner", "r", "parser", "rar", "iterator", "row", "rr", "rer", "io", "writer", "rx", "worker", "ser", "stream", "Reader"], "line": ["val", "string", "base", "non", "job", "sel", "id", "feed", "lf", "user", "entry", "message", "LINE", "character", "ge", "end", "l", "el", "pass", "key", "iter", "content", "char", "sync", "source", "lines", "lc", "no", "len", "model", "r", "str", "data", "li", "cl", "page", "ip", "le", "inline", "row", "name", "header", "word", "link", "sl", "layer", "url", "unit", "comment", "Line", "lin", "block", "definition", "code", "cell"]}}
{"id1": "4164833", "id2": "12783713", "code1": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"buildDeb": ["builddeb", " rebuildLibrary", "BuildLibrary", " rebuilddeb", "BuildCredit", " builddeb", " rebuildCredit", " buildCredit", " buildLibrary", "Builddeb", "buildLibrary", "buildCredit", "BuildDeb", " rebuildDeb"], "debFile": ["debianFile", "debfile", "DebStyle", "rebFiles", "fbFile", "fbFiles", "DebFolder", "DebFile", "debFiles", "fbFolder", "debFolder", "fbStyle", "debFilename", "Debfile", "bitcoinFiles", "bitcoinfile", "rebFolder", "rebFile", "DebFilename", "bitcoinFilename", "DebFiles", "debianFilename", "debianFiles", "debianfile", "bitcoinFile", "debStyle", "rebStyle"], "controlFile": ["controlFolder", " controlEntry", "controlPath", " controlPage", "ctrlfile", "ControlEntry", "contactFile", "controlEntry", "Controlfile", "ctrlInfo", "controlStream", "configFolder", "configfile", "ctrlFolder", "ControlName", "ctrlEntry", "controlledfile", "controlFiles", "ControlFile", "configInfo", "ctrlFiles", "controlledFolder", "controlfile", "ControlPath", " controlPath", "ctrlPage", "ctrlPath", "contactStream", "ControlFiles", "ctrlFile", " controlStream", " controlName", "contactFiles", "controlledInfo", "configFile", "ctrlStream", "controlInfo", " controlFiles", "controlPage", " controlfile", "controlName", "contactPage", "controlledFile", "ctrlName"], "dataFile": [" dataStore", "dataStream", "Datafile", "dataLog", "dataStore", "datStream", "configLog", "basePath", " dataFiles", "controlStream", " dataPath", "datFile", "configfile", "DataStream", " datafile", "dataPage", "controlFiles", "baseFile", "controlfile", "infoFile", "controlStore", "datafile", "DataLog", "datfile", "DataFile", "DataPath", "configFile", "basefile", "infoFiles", "dataFiles", "datPage", "dataPath", "DataPage", "datLog", "infofile", "infoStore", "configPage", "dataDirectory", "controlDirectory", "DataDirectory", "datDirectory"], "now": ["then", "from", "base", "max", "self", "cmp", "ok", "oa", "current", "later", "length", "set", "off", "day", "created", "time", "next", "post", "load", "after", "seed", "date", "not", "old", "NOW", "default", "small", "timer", "size", "or", "start", "name", "once", "function", " NOW", "always", "Now", "since", "false", "low", "today", "create", "wait", "count", "age", "and", "currently", "ow", "this", "first"], "deb": ["ssl", "ee", "cf", "dp", "dr", "pay", "req", "die", "cm", "cp", "default", "ob", "fb", "bel", "bb", "bank", "nb", "dep", "bug", "raf", "org", "download", "df", "pub", "rib", "library", "priv", "Deb", "work", "av", "exec", "af", "abc", "b", "boot", "budget", "pkg", "sem", "bh", "lab", "debian", "fin", "mb", "allow", "tab", "bang", "diff", "daily", "hide", "aff", "div", "ub", "web", "aud", "dev", "blog", "dec", "ib", "compl", "design", "def", "plug", "error", "ban", "eb", "cb", "obb", "dl", "reb", "cdn", "rb", "cop", "broad", "config", "github", "img", "log", "db", "conf", "loc"], "control": ["event", "address", "core", "input", "output", "copy", "restricted", "feed", "http", "ack", "per", "ctrl", "sub", "child", "length", "co", "manager", "flow", "form", "client", "select", "monitor", "reader", "lib", "broad", "media", "group", "open", "config", "channel", "down", "regular", "ignore", "work", "safe", "own", "conn", "edit", "internal", "exec", "Control", "io", "controller", "controlled", "correct", "url", "stream", "connect", "radio", "error"], "buffer": ["capacity", "base", "address", "border", "server", "uffer", "copy", "resource", "feed", "uri", "entry", "sequence", "slice", "message", "document", "character", "limit", "number", "result", "length", "write", "record", "key", "queue", "iter", "offset", "reader", "cache", "binary", "source", "buff", "value", "buf", "broad", "wave", "file", "channel", "page", "request", "size", "variable", "null", "writer", "array", "layer", "bytes", "url", "flush", "shape", "comment", "reference", "count", "pad", "block", "transfer", "batch"], "read": ["index", "Read", "resource", "each", "run", "set", "off", "ride", "en", "raw", "rate", "build", "open", "get", "it", "readable", "ed", "id", "feed", "add", "ack", "end", "find", "ready", "next", "sync", "use", "load", "value", "work", "level", "pick", "ip", "fill", "skip", "shape", "connect", "play", "close", "core", "reading", "ok", "slice", "length", "write", "flow", "loop", "allow", "reader", "no", "show", "bind", "request", "start", "io", "create", "wait", "scale", "ink", "view", "input", "copy", "child", "draw", "reads", "pass", "key", "select", "type", "ask", "seek", "text", "check", "size", "log", "send", "pull", "parse", "ize", "count", "READ"], "data": ["close", "base", "input", "resource", "video", "feed", "map", "result", "api", "child", "write", "done", "memory", "ui", "extra", "database", "aa", "la", "like", "part", "one", "reader", "cache", "binary", "media", "open", "down", "li", "body", "file", "object", "own", "view", "complete", "image", "writer", "ata", "function", "db", "area", "di", "update", "da", "partial", "ada", "and", "block", "multi", "dat", "error", "pad", "download", "auto", "valid"]}}
{"id1": "11484416", "id2": "5723876", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"moveFile": ["moveDirectory", "MoveFile", "movePath", " moveFiles", " movedFiles", "moveFiles", "MovePath", "MoveFiles", "MoveDirectory", " movedDirectory", " movedFile", " moveDirectory", " movePath", " movedPath"], "orig": ["impl", "remote", "original", "base", "info", "temp", "id", "copy", "loc", "dest", "origin", "Orig", "bin", "ori", "iter", "comb", "rb", "source", "exe", "proxy", "ctr", "old", "buf", "build", "bas", "real", "file", "src", "tmp", "archive", "init", "internal", "folder", "coll", "frame", "image", "raid", "home", "array", "transform", "ext", "obj", "coord", "raf", "f", "prev", "imag", "org", "img"], "target": ["path", "remote", "base", "original", "temp", "resource", "copy", "replace", "master", "project", "current", "join", "Target", "origin", "dest", "result", "prot", "match", "manager", "ret", "next", "nt", "source", "eth", " Target", "build", "arget", "parent", "tmp", "archive", "object", "format", "template", "force", "t", "to", "it", "compatible", "reference", "external", "f", "this", "auto", "platform"], "buffer": ["base", "address", "Buffer", "input", "feed", "copy", "resource", "uffer", "message", "slice", "sequence", "result", "length", "code", "write", "bin", "read", "queue", "iter", "raw", "content", "source", "cache", "binary", "buff", "buf", "wave", "data", "file", "request", "bb", "null", "header", "frame", "bytes", "position", "url", "layer", "b", "reference", "stack", "repeat", "padding", "block", "transfer", "batch"], "bread": ["fif", "zip", "fee", "fe", "four", "num", "feed", "choice", "beat", "grain", "fine", "ble", "eb", "broken", "bee", "robe", "rib", "length", "wake", "rub", "fall", "ffe", "key", "sleep", "fle", "loop", "die", "knife", "str", "div", "meal", "fed", "food", "web", "bb", "wen", "fred", "hello", "bn", "buck", "rows", "good", "bare", "circ", "bat", "fen", "cook", "bc", "brew", "design", "piece", "abi", "cake", "inn", "zero", "batch", "width", "raft"], "fis": ["hIs", "fxis", "hisa", "afos", "qis", "ufils", " fiss", "lfis", "his", "lfiss", "fxIs", " fIs", "afis", "fisa", "lfos", "ufiss", "fxisa", "lfIs", " fisa", "fxos", "ufos", "afIs", "qiss", "fIs", "qos", " fils", "fiss", "qils", "hos", "afiss", "ufis", "fils"], "fos": ["gis", " fros", "fens", "flos", "infaos", "fros", "flens", "gros", " foses", "infos", "Fois", "Fors", "flose", "foss", "flaos", "fois", " foss", "gos", "Foss", " fens", "foses", "flois", "Fos", "Fis", "Fens", "Fros", "infors", "fose", "Fose", "floses", "fors", "Foses", "goss", "faos", "Faos", "flors", "infois", " fose"]}}
{"id1": "742465", "id2": "23620712", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doFeatureScan", "doFeatureUpdate", "doversionScan", " doversioncheck", "doFeaturecheck", "doVersionUpdate", "doVersionScan", " doVersionUpdate", "doChangecheck", " doVersionScan", " doversionUpdate", "doChangeUpdate", "doChangeScan", "doversionUpdate", "doFeatureCheck", " doVersioncheck", " doversionScan", "doversionCheck", "doChangeCheck", "doVersioncheck", "doversioncheck", " doversionCheck"], "view": ["index", "base", "vol", "http", "window", "fail", "model", "row", "style", "comment", "container", "server", "self", "lock", "by", "html", "query", "ui", "VIEW", "use", "cache", "up", "value", "View", "vis", "page", "object", "edit", "e", "full", "screen", "link", "review", "can", "v", "views", "list", "event", "head", "video", "el", "session", "see", "show", "group", "div", "body", "box", "change", "image", "update", "im", "display", "cell", "sel", "ou", "input", "user", "pool", "layout", "manager", "form", "client", "config", "out", "check", "widget", "port", "ve", "gu", "block", "this"], "url": ["impl", "zip", "string", "path", "base", "buffer", "loader", "ssl", "address", "server", "uri", "resource", "id", "builder", "http", "socket", "rel", "l", "host", "location", "URL", "fr", "length", "email", "source", "browser", "ob", "open", "file", "web", "bb", "ll", "log", "null", "ls", "name", "image", "blog", "link", "sl", "Url", "www", "stream", "bug", "b", "ul", "f", "hub", "gl", "download", "loc"], "in": ["IN", "sin", "buffer", "pin", "input", "bis", "resource", "ini", "con", "socket", "as", "inner", "s", "ins", "is", "reader", "source", "binary", "doc", "login", "inc", "data", "file", "out", "rin", "init", "again", "m", "isin", "In", "nin", "stream", "lin", "b", "err", "ac", "cin", "inn", "win", "din"], "bin": ["IN", "sin", "buffer", "pin", "loader", "input", "border", "ban", "ini", "lock", "gin", "con", "socket", "inner", "run", "arin", "record", "is", "fin", "reader", "binary", "lib", "browser", "login", "ruby", "body", "file", "out", "vin", "oin", "bb", "bi", "init", "bn", "nb", "spin", "bot", "lin", "b", "abi", "cin", "inn", "win", "din"], "line": ["val", "zip", "string", "letter", "pin", "base", "job", "id", "lf", "user", "entry", "LINE", "ge", "end", "l", "look", "jo", "el", "write", "ine", "key", "part", "type", "one", "lines", "lc", "up", "str", "data", "file", "text", "out", "cl", "page", "le", "nl", "ip", "log", "row", "inline", "object", "name", "e", "word", "link", "sl", "pe", "unit", "comment", "Line", "lin", "b", "range", "parse", "block", "definition", "code", "cell"], "version": ["string", "release", "beta", "server", "video", "id", "user", "option", "author", "project", "python", "patch", "driver", "host", "versions", "code", "type", "support", "cover", "date", "value", "model", "feature", "section", "VERSION", "null", "device", "plugin", "format", "name", "dev", "image", "latest", "pull", "ver", "update", "bug", "unit", "position", "secret", "v", "download", "vert", "Version", "vision", "license", "install"], "build": ["info", "release", "job", "feed", "clean", "builder", "lock", "add", "building", "http", "rel", "run", "patch", "lease", "Build", "tag", "follow", "post", "use", "load", "show", "work", "get", "log", "row", "built", "style", "image", "home", "how", "hold", "link", "mount", "pull", "update", "uild", "unit", "bug", "ver", "print", "make", "help", "block", "boot", "install", "valid"]}}
{"id1": "647224", "id2": "4750967", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"uploadFile": ["uploadfile", "processFile", "UploadFiles", "UploadDir", " uploadDir", "Uploadfile", "uploadFiles", "uploadDir", " uploadfile", "processDir", "processfile", " uploadFiles", "processFiles", "UploadFile"], "inputFile": ["inputFolder", "targetFolder", "initialFile", "sourceLog", " inputDir", "targetLog", "sourceType", "InputDir", "targetPage", "inputFilename", "inputfile", "sourcePage", " inputfile", " inputType", "sourceFolder", "targetFiles", "initialFilename", "sourceFile", "InputType", "targetfile", "inputLog", "InputFile", " inputFilename", " inputStream", "inputDir", "targetDir", "targetStream", " inputPage", "inputStream", " inputFolder", "inputFiles", "sourcefile", "InputFolder", "inputType", "sourceStream", "targetFilename", " inputLog", "InputFiles", "initialStream", "inputPage", " inputFiles", "initialFolder", "InputStream", "Inputfile"], "targetFile": [" targetFiles", "inputPlace", "targetName", "Targetfile", "sourceDir", "externalPath", "TargetLine", "externalfile", "sourcePath", "TargetPath", "targetPlace", "targetFiles", " targetName", "outputPath", "sourceFile", " targetfile", "targetfile", " targetDir", " targetPlace", "TargetFiles", "inputPath", "TargetDir", "inputDir", "targetDir", "targetPath", "TargetFile", "externalName", "outputFiles", "TargetName", "sourcePlace", "outputName", "outputDir", " targetLine", "outputLine", "targetLine", "externalFile", " targetPath"], "outputFile": ["inputFolder", " targetFiles", "outFolder", "writeUrl", " outputUrl", "outputfile", "outputFolder", " targetQueue", "outPlace", "outFile", "inputfile", "outfile", "OutputFolder", "writePage", "inputUrl", " outputFolder", "currentFolder", "targetFiles", "outputQueue", "outputPlace", "outputPath", "writeFile", "targetfile", "inputPath", " targetDirectory", " outputDirectory", "currentPlace", "inputDir", "targetPath", " outputStream", "OutputDir", " outputPath", "currentfile", "outPath", " outputPage", " outputfile", "outputStream", "inputStream", "inputFiles", " outputFiles", " outputDir", " outputPlace", "outputFiles", "outDirectory", "inputDirectory", "writeStream", "Outputfile", "outputDirectory", "targetDirectory", "outputUrl", "outputDir", "currentFile", "inputQueue", "outputPage", "inputPage", "OutputFile", "targetQueue"], "in": ["IN", "pin", "i", "input", "id", "serv", "ini", "con", "inner", "sub", "ins", "s", "bin", "pass", "is", "read", "reader", "source", "up", "login", "diff", "inside", "r", "inc", "data", "rin", "init", "rec", "issue", "again", "io", "isin", "In", "nin", "kin", "pull", "url", "stream", "lin", "err", "ac", "cin", "inn", "win", "din"], "out": ["base", "console", "ex", "output", "sys", "n", "copy", "user", "lock", "by", "report", "outer", "net", "plain", "table", "OUT", "inter", "inner", "outs", "o", "s", "write", "off", "bin", "co", "sync", "client", "one", "source", "cache", "up", "r", "ger", "inc", "cmd", "file", "data", "page", "log", "conn", "again", "exec", "Out", "io", "writer", "image", "to", "dump", "ext", "err", "println", "print", "state", "error", "this", "point"], "line": ["string", "buffer", "base", "job", "lf", "lock", "entry", "LINE", "limit", "write", "pass", "ine", "char", "split", "sync", "part", "type", "rule", "lines", "lc", "data", "file", "page", "le", "inline", "log", "row", "name", "header", "e", "frame", "word", "link", "url", "pe", "unit", "comment", "lin", "Line", "range", "block", "error", "code", "cell"], "bytes": ["zip", "i", "pages", "tes", "comments", "les", "number", "outs", "steps", "length", "s", "bs", "reads", " lines", "items", "lines", "binary", "blocks", "bps", "len", "eps", "classes", "size", "ips", "es", "groups", "Bytes", "ls", "ones", "cycles", "seconds", "pos", "ines", "rows", "values", "files", "count", " cycles", "units", "words", "os", "bits", "odes", "codes", "code"]}}
{"id1": "2668853", "id2": "12306305", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFiletoFiles", "decodeFileAsStream", "decodeString2file", "decodeFile2Stream", "decodeFiletoFile", "decodeFileToStream", "decodeFiletofile", "decodeFileAsFiles", "decodeFileTofile", "decodeStringToFile", "decodeStringTofile", "decodeStringToStream", "decodeFileAsFile", "decodeString2Stream", "decodeFile2File", "decodeString2File", "decodeFileAsfile", "decodeFiletoStream", "decodeFileToFiles", "decodeFile2file", "decodeStringToFiles", "decodeString2Files", "decodeFile2Files"], "infile": ["minfile", "infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", "inputfp", " inFile", "inputFile", "outfiles", " infilename", "inputfiles", " infiles", "outfp", "minfilename", "minFile", "minfp", "inputfilename", "infilename"], "outfile": ["infp", "outfull", "outputfile", " outfull", "outfilename", "outFile", " outFile", "infolder", "outputfolder", " outfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "outputfull", "Outfull", "Outfolder", "OutFile", "Outfile", "outputFile", "infilename", " outfilename"], "in": ["IN", "pin", "i", "input", "inas", "ex", "ini", "gin", "ic", "con", "inner", "socket", "as", "ins", "s", "bin", "is", "reader", "source", "up", "login", "min", "inside", "r", "inc", "data", "rin", "init", "conn", "again", "m", "e", "image", "re", "In", "nin", "a", "lin", "err", "b", "ac", "cin", "inn", "f", "win", "this", "din"], "out": ["base", "ex", "output", "copy", "outer", "op", "lock", "on", "net", "OUT", "socket", "as", "inner", "outs", "o", "s", "off", "line", "write", "bin", "co", "pass", "exit", "post", "client", "sync", "session", "no", "cache", "lib", "up", "target", "other", "inc", "work", "file", "conn", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "exp", "In", "ext", "b", "obj", "err", "error", "point"], "buffer": ["address", "base", "input", "Buffer", "uffer", "resource", "pause", "border", "server", "feed", "slice", "limit", "result", "length", "bin", "memory", "queue", "offset", "iter", "split", "reader", "source", "binary", "seed", "buff", "value", "buf", "wave", "data", "size", "bb", "null", "row", "bytes", "layer", "flush", "url", "shape", "b", "reference", "padding", "pad", "transfer", "batch"], "read": ["index", "Read", " receive", " r", "run", "ride", " get", "open", " copy", "get", "lex", " send", " check", "id", "feed", "add", "ind", "end", "find", " reach", "next", "sync", "use", "load", " sleep", "r", "work", "fill", "exec", "skip", "connect", " request", "play", " use", "reading", " parse", "limit", "se", "length", "write", "line", "ad", "sleep", "iter", "allow", "reader", " Read", "start", "tell", " load", "wait", " write", "input", "copy", " connect", "current", "reads", "pass", "select", " ride", "seek", "inc", " find", "check", "x", "size", " reader", "send", "k", "parse", "count", "READ"], "success": ["roll", "accept", "job", "response", "rolling", "ok", "continue", "ceed", "results", "warning", "better", "yes", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "selected", "default", "data", "safe", "null", "cess", "danger", "complete", "again", "status", " successful", "full", "correct", "good", "Success", "successful", "successfully", "rolled", "found", " succ", "zero", "error", "fast", "first", "winner", "initial"]}}
{"id1": "3024987", "id2": "6988216", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamForencoded", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_Coding", "testCopy_readerToOutputStream_Coder", "testCopy_readerToOutputStream_encode", "testCopy_readerToOutputStream_Integoder", "testCopy_readerToOutputStream_Coded", "testCopy_readerToOutputStreamForEncode", "testCopy_readerToOutputStream_Integode", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStreamForencode", "testCopy_readerToOutputStream_Encode", "testCopy_readerToOutputStreamForencoder", "testCopy_readerToOutputStream_Code", "testCopy_readerToOutputStreamForEncoder", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStream_Integoded", "testCopy_readerToOutputStreamForEncoded", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStreamForencoding", "testCopy_readerToOutputStreamForEncoding", "testCopy_readerToOutputStream_Integoding", "testCopy_readerToOutputStream_Encoder"], "in": ["IN", "buffer", "i", "input", "n", "inas", "id", "reading", "ini", "entry", "slice", "inner", "ins", "arin", "bin", "pass", "read", "is", "source", "login", "min", "inside", "r", "inc", "data", "rin", "file", "init", "rec", "or", "again", "m", "image", "io", "re", "In", "a", "url", "include", "err", "with", "inn", "win", "Reader", "din"], "reader": ["buffer", "loader", "i", "input", "her", "handler", "feed", "reading", "per", "inner", "driver", "read", "iter", "ler", "er", "source", "ra", "oder", "ner", "r", "parser", "file", "rar", "x", "rr", "or", "rer", "io", "writer", "iner", "rx", "pointer", "worker", "stream", "b", "ink", "Reader"], "baout": ["Baout", "daout", "baparent", "vain", "waOut", "dain", "BaOut", "waout", "aain", "vaOut", "waoutput", "vaout", "vaparent", "BAin", "daOut", "abaOUT", "daOUT", "aaOut", "Baparent", "baoutput", "BAparent", "BAOUT", "BAOut", "baOut", "aaoutput", "bain", "Bain", "wain", "abain", "aaout", "abaout", "abaOut", "baOUT", "BAoutput", "BAout"], "out": ["base", "buffer", "inas", "server", "output", "user", "builder", "ref", "OUT", "inner", "outs", "o", "pool", "line", "write", "arr", "client", "cache", "lib", "up", "inc", "parent", "file", "object", "null", "again", "exec", "Out", "image", "writer", "io", "to", "array", "ext", "obj", "err", "with"], "bytes": ["zip", "string", "css", "output", "pages", "pieces", "tes", "ns", "comments", "android", "les", "outs", "bs", "reads", "content", "parts", "items", "ies", "its", "binary", "lines", "blocks", "strings", "bps", "data", "classes", "body", "text", "objects", "ips", "size", "es", "null", "Bytes", "ls", "ones", "seconds", "cells", "rows", "values", "files", "ipes", "units", "os", "bits", "odes", "codes"]}}
{"id1": "807346", "id2": "2465747", "code1": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 1, "substitutes": {"runScript": ["execCode", "RunCode", " runscript", "execscript", "runscript", "RunScript", "execJS", "execScript", " runJS", "RunJS", "runJS", "runCode", " runCode", "Runscript"], "scriptName": ["scriptNames", " scriptFile", "fileUrl", " scriptPath", "codename", "Scriptname", "scriptUrl", "scriptPath", "filePath", "codePath", "fileName", " scriptNames", "scriptname", " scriptUrl", "codeName", "ScriptName", " scriptname", "ScriptPath", "ScriptFile", "codeNames", "ScriptNames", "ScriptUrl", "scriptFile", "fileFile"], "data": ["index", "string", "info", "base", "buffer", "input", "i", "output", "response", "feed", "results", "message", "json", "result", "number", "html", "api", "write", "layout", "key", "alpha", "content", "split", "raw", "next", "part", "type", "source", "no", "one", "value", "media", "str", "DATA", "div", "batch", "text", "body", "out", "empty", "append", "complete", "format", "start", "name", "template", "action", "ata", "function", "a", "partial", "missing", "script", "dat", "error", "this", "code", "valid"], "url": ["impl", "zip", "path", "base", "buffer", "ssl", "i", "server", "uri", "resource", "id", "feed", "user", "http", "l", "host", "URL", "source", "up", "browser", "connection", "open", "file", "web", "page", "bb", "ll", "log", "bel", "ls", "ball", "image", "sl", "rl", "Url", "www", "stream", "b", "f", "service"], "in": ["IN", "ssl", "buffer", "i", "input", "id", "resource", "serv", "ini", "gin", "socket", "as", "inner", "ins", "s", "bin", "pass", "is", "client", "cms", "reader", "source", "login", "r", "inc", "file", "out", "conn", "In", "fd", "a", "stream", "b", "err", "ac", "with", "inn", "f", "win", "din"], "buffIn": ["BuffIn", "buffIns", "bufIn", "buffOut", "buffedIn", "bufin", "bufIns", "bbIns", "ufIn", "bufferin", "BuffedIn", "bbIn", "bufferIn", "bufOut", "bufferIns", "ufIns", "bbOut", "bufferedIn", "ufin", "BuffIns", "bbin", "BuffOut", "Buffin", "ufedIn", "buffin"], "temp": ["index", "zip", "total", "base", "buffer", "tc", "input", "num", "i", "output", "enc", "c", "current", "tem", "number", "dest", "length", "Temp", "flow", "read", "extra", "char", "iter", "offset", "content", "raw", "type", "source", "cut", "len", " Temp", "div", "tmp", "fake", "empty", "size", "ptr", "test", "cel", "start", "stable", "pointer", "unit", "partial", "wait", "count", "f", "pt", "emp"]}}
{"id1": "11556231", "id2": "3806532", "code1": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"ByURL": ["CreateSSL", "CreateURI", "bySSL", "byUrl", "createSSL", "byURI", "ByUrl", "ByURI", "CreateUrl", "createURL", "createURI", "CreateURL", "createUrl", "BySSL", "byURL"], "urlstr": ["URLname", "URLstr", "urlSTR", "UrlStr", "URLStr", "urlstring", "httpstr", "urlname", " urlname", "Urlstr", " urlstring", "Urlstring", " urlSTR", "httpStr", "URLSTR", "URLstring", "httpstring", "urlStr", "httpSTR", "Urlname", "UrlSTR"], "uri": ["directory", "string", "path", "address", "base", "i", "id", "resource", "absolute", "server", "pi", "username", "http", "filename", "description", "ri", " URI", "location", "host", "URL", "query", "ui", "manager", "database", "domain", "qi", "type", "collection", "text", "route", "file", "href", "image", "io", "iri", "prefix", "Url", "attribute", "URI", "direction"], "url": ["string", "path", "ssl", "address", "loader", "base", "server", "resource", "feed", "id", "user", "http", "system", "l", "location", "host", "URL", "client", "session", "proxy", "file", "channel", "li", "web", "page", "conn", "image", "link", "sl", "Url", "stream", "f", "service", "download", "loc"], "connection": ["directory", "Connection", "handler", "i", "server", "response", "resource", "http", "con", "c", "socket", "connected", "system", "l", "URL", "relation", "database", "client", "application", "collection", "open", "channel", "body", "director", "context", "control", "conn", "or", "io", "writer", "stream", "connect"], "in": ["IN", "i", "input", "ini", "con", "c", "inner", "as", "socket", "ins", "s", "bin", "client", "cms", "login", "r", "inc", "out", "conn", "init", "or", "writer", "In", "kin", "a", "stream", "lin", "connect", "ac", "and", "inn", "f"], "reader": ["buffer", "loader", "i", "input", "handler", "resource", "server", "reading", "rc", "ini", "entry", "inner", "result", "read", "iter", "ler", "er", "client", "ais", "r", "parser", "channel", "out", "row", "conn", "or", "io", "writer", "stream", "wrapper", "Reader"], "is": ["info", "bis", "i", "iss", "lis", "serv", "IS", "fs", "isa", "Is", "as", "ri", "s", "ins", "si", "ui", "rs", "isl", "cms", "ais", "nis", "out", "src", "has", "conn", "or", "ai", "ris", "rss", "ci", "io", "iri", "iris", "ios", "isi", "err", "sp", "os", "was", "im", "sr", "iso", "mis"], "document": ["root", "node", "class", "output", "response", "resource", "docs", "message", "result", " documents", "database", " documentation", "content", "doc", "application", "collection", "config", "parent", "object", "ocument", "m", "writer", "graph", "Documents", "xml", "Document", "element"], "source": ["string", "info", "node", "class", "input", "resource", "Source", "instance", "driver", "SOURCE", "content", "parser", "parent", "file", "src", "text", "object", "language", "context", "stream", "unit", "container", "element", "service"], "name": ["NAME", "string", "base", "node", "root", "info", "id", "resource", "definition", "description", "filename", "instance", "location", "tag", "domain", "key", "type", "value", "parent", "names", "file", "text", "object", "format", "Name", "word", "prefix", "comment", "named", "attribute", "URI", "element", "property"], "namespaceURI": ["Namespacesuri", "namespaceFINE", "namesheeturi", "perspaceduri", "namespacesFINE", "namesistenceFINE", "namespaceNS", "namespaceMI", "nameservingURI", "perspaceGI", "namesheetURI", "namesistenceURI", "perspacedGI", "NamespaceNS", "perspaceURI", "namespaceuri", "namesheetGI", "NamespacesMI", "NamespacesFINE", "NamespacesURI", "NamespaceFINE", "namesferenceURI", "namespacesMI", "nameservinguri", "namespaceduri", "namesferenceMI", "namesistenceMI", "nameservingNS", "namespacedGI", "namespacesURI", "namespacedURI", "perspacedURI", "namespacesuri", "NamespaceMI", "NamespaceURI", "Namespaceuri", "namesferenceFINE", "perspaceuri", "namespaceGI", "namesferenceuri", "namespacedNS", "namesistenceuri"], "qualifiedName": ["localPath", "qualPath", "simplePath", "localname", "qualURI", "localType", "fixedType", "simpleURI", "qualifiedname", " qualifiedname", " qualifiedURI", "simpleName", "fixedPath", "qualifiedType", " qualifiedType", "qualifiedPath", "qualName", "qualifiedURI", "fixedname", " qualifiedPath", "qualname", "fixedName", "simplename"], "data": ["string", "NAME", "base", "class", "info", "buffer", "input", "id", "resource", "output", "node", "message", "description", "comments", "number", "child", "content", "type", "doc", "value", "media", "model", "str", "DATA", "default", "config", "text", "body", "parent", "object", "language", "context", "format", "template", "ata", "property", "stream", "def", "xml", "script", "element", "definition"], "tagName": ["Tagname", "localClass", " tagClass", "TagClass", "TagName", "localname", "tagClass"], "target": ["root", "head", "base", "node", "address", "class", "info", "path", "resource", "NAME", "uid", "Target", "instance", "location", "host", "domain", "next", "component", "parent", "object", "href", "format", "template", "label", "prop", "method", "property"], "elementId": ["objectID", "objectTag", "elementID", "objectId", "nodeid", " elementid", "nodeId", "objectid", "elementTag", " elementID", "nodeID", " elementTag", "nodeTag", "elementid"], "tagname": ["Tagname", "classNAME", "TagNAME", "classname", " tagNAME", "TagName", "className", "tagNAME"], "localName": ["clientname", "qualifiedname", "qualifiedNAME", "localNAME", " localname", "clientNAME", " localNAME", "localname", "clientName"]}}
{"id1": "2381663", "id2": "15757836", "code1": "    @Test(expected = GadgetException.class)\n    public void malformedGadgetSpecIsCachedAndThrows() throws Exception {\n        HttpRequest request = createCacheableRequest();\n        expect(pipeline.execute(request)).andReturn(new HttpResponse(\"malformed junk\")).once();\n        replay(pipeline);\n        try {\n            specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n            fail(\"No exception thrown on bad parse\");\n        } catch (GadgetException e) {\n        }\n        specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n    }\n", "code2": "    private int[] sort(int n) {\n        int[] mas = new int[n];\n        Random rand = new Random();\n        for (int i = 0; i < n; i++) {\n            mas[i] = rand.nextInt(10) + 1;\n        }\n        boolean t = true;\n        int tmp = 0;\n        while (t) {\n            t = false;\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    tmp = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = tmp;\n                    t = true;\n                }\n            }\n        }\n        return mas;\n    }\n", "label": 0, "substitutes": {"malformedGadgetSpecIsCachedAndThrows": ["malformedGadgetSpecIsCachedandthrown", "malformedGadgetSpecIsCachedAndethrows", "malformedGadgetSpecIsCachedandthrows", "malformedGadgetSpecIsCachedAndthrows", "malformedGadgetSpecIsCachedAndThrown", "malformedGadgetSpecIsCachedAndthceptions", "malformedGadgetSpecIsCachedandthceptions", "malformedGadgetSpecIsCachedAndThceptions", "malformedGadgetSpecIsCachedandThrown", "malformedGadgetSpecIsCachedandThrows", "malformedGadgetSpecIsCachedAndethceptions", "malformedGadgetSpecIsCachedAndthrown", "malformedGadgetSpecIsCachedandThceptions", "malformedGadgetSpecIsCachedAndethrown"], "request": ["event", "job", "temp", "input", "Request", "output", "response", "resource", "server", "claim", "http", "report", "message", "result", "instance", "press", "query", "condition", "req", "queue", "er", "client", "q", "proxy", "r", "application", "config", "data", "parent", "p", "context", "complete", "test", "e", "QUEST", "call", "pe", "create", "pair", "trip", "method", "re", "enter"]}}
{"id1": "823074", "id2": "11933797", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"convert": ["CONverting", "subverting", "Conversion", "oconversion", "oconverting", "Converting", "CONversion", "unversion", "CONvert", "conversion", "CONception", "oconverted", " deconverted", "converting", "CONverted", "subvert", "oconvert", "Conception", "unvert", "converted", " deconverting", "subversion", "Converted", "unception", "unverted", "subverted", " deconversion", "conception", "Convert", " deconvert"], "src": ["impl", "string", "path", "sel", "ssl", "sin", "input", "sc", "uri", "resource", "sys", "spec", "rc", "Source", "video", "cmp", "username", "filename", "ref", "slice", "cb", "fp", "fn", "s", "prot", "code", "inst", "feat", "cpp", "req", "gb", "back", "source", "reader", "load", "proc", "sb", "rb", "sit", "buf", "component", "dist", "upload", "SourceFile", "config", "file", "tmp", "Dest", "supp", "attr", "img", "href", "storage", "name", "sth", "gz", "RC", "rl", "ctx", "secure", "url", "scene", "stream", "obj", "st", "stage", "sn", "ource", "download", "loc"], "dest": ["path", "class", "temp", " dst", "cont", "fn", "bin", "dc", "std", "txt", "source", "dir", "lib", "target", "dist", "tmp", "Dest", "null", "test", "home", "di", "obj", " destination", "dat", "disk", "orig", "img"], "in": ["IN", "val", "pin", "i", "input", "ex", "n", "inas", "ini", "as", "ins", "bin", "pass", "is", "reader", "d", "source", "doc", "up", "login", "r", "inc", "data", "file", "io", "t", "isin", "In", "a", "stream", "err", "inn", "ps", "f", "inf", "win", "din"], "p": ["P", "i", "pi", "op", "wp", "pre", "lp", "per", "py", "c", "j", "fp", "o", "l", "s", "pb", "cop", "part", "cp", "d", "pr", "pp", "pm", "r", "g", "parser", "h", "np", "po", "tp", "m", "e", "t", "pc", "jp", "pa", "bp", "pe", "b", "sp", "v", "ps", "f", "pd", "pg"], "ds": ["services", "uds", "ays", "docs", "ants", "dos", "s", "ins", "dp", " DS", "parts", "points", "gs", "els", " props", "des", "ts", "js", "utils", "ths", "ys", "gd", "sys", "df", "lp", "bs", "dc", " ps", "dt", "sync", "lines", "eps", "vs", "ges", "amps", "ipes", "pd", "dd", "sts", "DS", "cons", "ks", "ns", "qs", "ld", "hs", "d", "dist", "ans", "ads", "xs", "models", "plugins", "groups", "tests", "ss", "di", "os", "posts", "styles", "rs", "dl", "tools", "ded", "ups", "data", "vals", "scripts", "Ds", "ls", "obs", "dm", "db", "ils", "nas", "dates", "da", "cs", "words", "dds", "ps", "dat", "icks", " sd"], "format": ["letter", "string", "path", "class", "handler", "spec", "filename", "act", "version", "table", "fp", "fn", "host", "tag", "record", "layout", "feat", "magic", "Format", "pattern", "form", "filter", "at", "type", "source", "part", "model", "parser", "config", "data", "file", "sche", "struct", "ant", "language", "style", "plugin", "template", "name", "frame", "t", "function", "prefix", "fd", "nat", "url", "unit", "atter", "f", "scale", "api"], "hasPixelData": ["hasPixeldata", "showsPixelDATA", "hasPixelDATA", "hasPicturedata", "hasByteSize", "hasByteDATA", "hasByteData", "haspixelData", "hasPixelStyle", " hasPixelSize", "showsByteDATA", "hasPictureSize", " hasPixeldata", "haspixeldata", "showsBytedata", "hasPictureData", "haspixelSize", "showsByteData", "showsPixelData", "showsByteStyle", "hasPixelSize", "hasByteStyle", "showsPixelStyle", "hasBytedata", "showsPixeldata"], "inflate": ["inadequating", "insflode", "insvenating", "inffated", "Inflation", "InFlation", "inflating", "Inflated", "inflATE", "InFlace", "insvenate", "inadequode", "InFlated", "insflate", "infolATE", "infface", "invenode", "InFlate", "inffation", "inflated", "inFlation", "infolode", "infloace", "insvenATE", "infloate", "invenATE", "inFlate", "inadequATE", "insflATE", "infloation", "invenating", "inffate", "insvenode", "inadequate", "Inflace", "inflation", "inflode", "inFlated", "Inflate", "infolate", "inFlace", "infloated", "invenate", "infolating", "inflace", "insflating"], "pxlen": ["pxdata", "xpsize", "pxlin", "pngcount", "mxsize", "campos", "fxlen", "pxl", "pgLen", "axlen", "ppLen", "mxcount", "fxln", "pxlon", "pxln", "pcln", "pglen", "ppl", "pxlength", "ppden", "camln", "txln", "pngsize", "pxpos", "pclon", "camlen", "mxdata", "axln", "axlon", "mxlength", "mxpos", "mxlen", "xplen", "txlin", "pxden", "pxcount", "fxpos", "txlon", "pclin", "pxsize", "fxdata", "pxLen", "mxln", "xpcount", "pgl", "fxLen", "axlin", "pnglen", "xplength", "fxl", "pgden", "fxden", "pclen", "pnglength", "txlen", "pplen", "camdata"], "out": ["step", "server", "output", "copy", "sys", "user", "lock", "OUT", "inter", "outs", "line", "co", "query", "post", "session", "cache", "lib", "up", "group", "store", "parent", "work", "page", "log", "gen", "conn", "again", "Out", "io", "dump", "obj", "v", "err", "state", "pad", "cli", "error", "re", "list", "point"]}}
{"id1": "5951610", "id2": "18097962", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "label": 0, "substitutes": {"testNetworkHTTP": [" testInternetHttp", "testnetworkSSL", " testNetworkHTML", "testnetworkHTML", "testnetworkHTTP", " testInternetSSL", "testInternetSSL", "testNetworkHttp", "testNETHTML", "testNetworkHTML", " testNetworkSSL", " testInternetHTML", "testInternetHttp", "testNETHTTP", "testNetworkSSL", "testInternetHTTP", " testNetworkHttp", "testnetworkHttp", "testNETHttp", " testInternetHTTP", "testInternetHTML", "testNETSSL"], "url": ["ssl", "base", "loader", "resource", "output", "http", "lr", "host", "large", "URL", "lib", "ob", "build", "file", "coll", "sl", "ol", "gl", "org", "impl", "buffer", "server", "feed", "bf", "location", "shell", "pl", "fl", "use", "load", "lc", "connection", "r", "channel", "cl", "page", "nl", "cloud", "control", "rl", "bl", "left", "ul", "tool", "service", "event", "path", "job", "uri", "entry", "mail", "rel", "el", "util", "hl", "email", "group", "web", "ll", "image", "blog", "ml", "Url", "update", "www", "ur", "view", "user", "l", "il", "key", "dl", "config", "github", "text", "log", "ls", "call", "pull", "layer", "loc"], "urlConnection": ["urlComputer", "sslConnector", "webPool", "ulConn", "urlGate", "serviceConnection", "flConnect", " urlFunction", "termComputer", "flConnection", " urlEnvironment", "UrlConnection", " urlPool", "URLConnection", "urlConnect", " urlGate", " urlUnit", "URLconnection", "uriComputer", "urConn", "viewConstruction", " urlContainer", "termConnection", "glConnection", "emailconnection", "ulConnection", "sslUnit", "viewconnection", "resourceConnection", "resourceClient", "numberconnection", "flConnector", " urlClient", "httpConnection", "implEnvironment", "lConnection", " urlComputer", " urlconnection", "blogconnection", "implReference", "lConnect", "urlEnvironment", " urlConnect", "urlReference", "urlFunction", "flconnection", " urlFactory", "urlUnit", "lengthConnection", "htmlConstruction", "lConn", "urlContainer", "urlconnection", "URLConn", "glConn", "ulConnector", "serviceConn", "webConnection", "urlConstruction", "sslConnection", "serviceConnect", "glConnect", "lengthconnection", "implConnection", "glFunction", "viewConnection", "httpComputer", "termConn", " urlConn", "lconnection", "uriUnit", "ulUnit", "resourceconnection", "httpConn", "emailClient", "URLConnect", "urlPool", "sslConn", "urlFactory", "urlConnector", "UrlConnect", "viewConnect", "blogConnection", "htmlConnection", "UrlConn", "urFactory", " urlConnector", "htmlconnection", "urConnection", "emailConnection", "URLPool", "resourceGate", "numberConnect", "UrlContainer", "serviceconnection", " urlReference", "blogConnect", "UrlComputer", "webconnection", "numberConnection", "UrlReference", "flConstruction", "emailConnect", "lengthConstruction", "urFunction", "emailConstruction", "UrlFunction", "uriConnection", "httpUnit", "emailGate", "urlConn", "blogConnector", "numberConnector", "termContainer", "httpFactory", "uriFunction", "httpFunction", "lengthConnect", "urlClient", "UrlEnvironment"], "rd": ["R", "lt", "rw", "bf", "dra", "gd", "wr", "bd", "rf", "lf", "RR", "dj", "ru", "rg", "lr", "dr", "rt", "fr", "wd", "usr", "rs", "ld", "RD", "std", "RL", "arr", "rowd", "nor", "rb", "reader", "rh", "d", "xd", "dh", "rod", "sr", "rid", "erd", "ird", "r", "rn", "DR", "nd", "director", "nl", "rown", " reader", "rr", "dig", "own", "rss", "rand", "addr", "rx", "sth", "rob", "adr", "db", "fd", "rl", "tr", "respond", "td", "hr", "red", "vd", "ds", "bl", "ng", "RW", "pd", "RF", "dd", "Reader"], "line": ["val", "letter", "string", "lo", "sel", "id", "lf", "response", "user", "entry", "LINE", "ge", "end", "number", "loc", "limit", "l", "col", "el", "day", "write", "pass", "ld", "key", "la", "part", "source", "d", "lines", "lc", "login", "len", "data", "li", "file", "cl", "page", "nl", "le", "log", "row", "inline", "ne", "msg", "name", "frame", "status", "word", "link", "sl", "rl", "skip", "unit", "comment", "lin", "Line", "block", "error", "code", "cell"]}}
{"id1": "189963", "id2": "20011285", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRebwrite", "readAndRebrap", "readAndRewwrite", "readAndSwrap", "readAndrewwrite", "readAndRebrite", "readandRewrap", "readandRewrites", "readAndSwwrite", "readandrewrap", "readAndRewrap", "readAndSwrite", "readandrewrites", "readandrewwrite", "readAndRebrites", "readAndRewrites", "readAndrewrite", "readAndSwrites", "readandrewrite", "readAndrewrites", "readAndrewrap", "readandRewwrite", "readandRewrite"], "inFile": [" inSourceFile", "InSourceFile", "oldfile", "outSourceFile", "inputfile", "outfile", " inFiles", "inputFilename", "InFiles", " infile", "infile", "inputFile", "outFiles", "oldFile", "loginFile", " inFilename", "Infile", "inFiles", "inputFiles", "oldFiles", "loginFilename", "loginfile", "loginFiles", "InFile", "oldFilename", "outFilename", "inFilename", "inSourceFile"], "outFile": ["newfile", "outDir", "OutStream", "processFile", "outputFilename", "exFilename", "outputfile", " outfile", "outPlace", "outFILE", "outputFILE", "outfile", "processFilename", "offFILE", "outputPlace", "thisFilename", "outStream", "thisFile", "processPlace", "exfile", "thisFILE", "newDir", "exFILE", "OutDir", "exFile", "processFILE", "newStream", "offPlace", "OutFile", " outStream", "outFilename", "offFilename", "Outfile", " outDir", "outputFile", "newFile", "thisfile", "offFile"], "iis": ["iIS", "Iais", "iIs", "iiris", "iniIs", "iiiss", "iais", "Iis", "ciis", "iiis", " iIs", " iIS", " iais", "ciiss", "Iiss", "ciais", " iiss", "iiss", "iiIS", "iniiss", " iris", "iniis", "ciris", "iniIS", "iniris", "IIS", "iris", "iiIs", "ciIS", "ciIs"], "dcmParser": ["dbmPolicy", "dbmParser", "dmmLoader", "dmissionParser", "dcmInstallation", "dmoduleJar", "dpmLoader", "dmoduleparser", "dhemReader", "dkmParser", "dmissionLanguage", "dCMPlugin", " dpmparser", " dcrParser", "fpmparser", "dhemJar", " dpmPolicy", "dkmPolicy", "dpmParser", "dcmPolicy", "dmissionPlugin", " dcmarser", "dmmPlugin", " dcrPlugin", "DcmInstallation", " dcmLanguage", "dpmHandler", "dmcJar", "dkmPlugin", " dpmParser", "dmoduleReader", " dcrLoader", "fcmReader", "dmissionReader", "dcrParser", "dmcarser", "dbmHelper", "dmLoader", "fpmHandler", "dcrarser", "dhemInstallation", "dmcParser", "dmmparser", "dpmLanguage", "dmodulePlugin", " dcmPolicy", "dpmarser", "dpmReader", "dcmPar", "dpmPar", "dmReader", "dcmparser", "dcrLoader", "dmParser", " dcmLoader", " dcmReader", "fcmparser", "dpmPolicy", "dcrJar", "dcmPlugin", "dpmparser", "fpmReader", "dcmarser", " dpmPlugin", "dbmPlugin", "dpmPlugin", " dpmHelper", "dCMLoader", " dpmLoader", " dpmJar", "dmoduleParser", " dcrReader", "dcmLoader", "fcmParser", "dpmHelper", "dcmReader", " dpmPar", "dCMHandler", "dmPlugin", "dcmJar", "dcrPlugin", "dpmJar", " dcmJar", "fcmHandler", " dcmHelper", "dCMparser", "dcrPar", "DcmParser", " dcmPar", "dcrReader", "fpmParser", " dpmReader", " dcmparser", "dmcPar", " dpmLanguage", "dcmHelper", "dpmInstallation", "dcmHandler", "dCMParser", "dcmLanguage", "dmmParser", "DcmReader", "dCMReader", "dkmHelper", " dcmPlugin", "DcmJar", "dhemParser", " dpmarser"], "ds": ["services", "ys", "uds", "ays", "DS", "iss", "gd", "sys", "Os", "df", "ants", "ns", "tes", "ks", "drivers", "qs", "bs", "s", "ins", "dr", "is", "dc", "rs", "ld", "dt", "parts", "cdn", "sync", "session", "ws", "d", "ros", "eps", "points", "icks", "ads", "data", "gs", "src", "xs", "utils", "vals", "ras", "Ds", "des", "ts", "conn", "vs", "ls", "js", "ss", "db", "ils", "di", "nas", "details", "amps", "Db", "da", "asi", "cs", "dds", "ps", "os", "dat", "pd", "dd", "tx"], "pdReader": ["hdRunner", "pbRunner", "pcReader", "pdRunner", "xdreader", "dsReader", "dsreader", "pbLoader", "hdReader", "hdreader", "dsLoader", "pcLoader", "pbStream", "hdStream", "ddStream", "pcRead", "xdWriter", "ddLoader", "pdLoader", "pdStream", "ddRunner", "pbReader", "hdWriter", "dsRead", "dsWriter", "xdRead", "pcWriter", "xdReader", "hdRead", "hdLoader", "ddReader", "pdreader", "pdRead"], "out": ["ssl", "base", "temp", "output", "net", "as", "s", "in", "at", "lib", "model", "default", "file", "gen", "conn", "Out", "url", "obj", "with", "external", "point", " in", "outer", "ex", "sys", "lock", "builder", "result", "later", "sync", "part", "cache", "up", "oder", "connection", "w", "parent", "store", "page", "object", "device", "again", "name", "exec", "exp", "array", "full", "over", "list", "order", "inner", "outs", "o", "line", "flow", "co", "write", "password", "session", "doc", "diff", "group", "director", "null", "dev", "io", "writer", "image", "to", "word", "cli", "term", "auto", "her", "copy", "user", "OUT", "child", "manager", "pass", "key", "client", "dot", "login", "inc", "down", "data", "db", "layer", "ext", "err", "code", "img"], "dcmEncParam": ["dcmEnParam", "dcmEstParam", "dcmDecParam", "dcmEnParameter", "dcmSecPart", "dcmDecType", "dcmDecPar", "dcmEncType", "dcmEncParameter", "dcmArchParam", "dcmEncPart", "dcmElParameter", "dcmEnPar", "dcmEnPart", "dcmDecArg", "dcmArchArg", "dcmArchParameter", "dcmSecPar", "dcmEnArg", "dcmDecParameter", "dcmDecPart", "dcmSecType", "dcmElParam", "dcmEstPar", "dcmEncPar", "dcmSecParam", "dcmElPar", "dcmEncArg", "dcmElType", "dcmEnType", "dcmEstType", "dcmEstParameter"], "pdWriter": ["dpWrite", "pdOutput", "ddWrite", "pdWriting", "htWriter", "dpReader", "dsReader", "hdReader", "pdWrite", "htWriting", "dpWriting", "PDWrite", "dpWriter", "hdWriter", "dsOutput", "dsWriter", "hdWrite", "htWrite", "PDWriter", "dsWrite", "ddOutput", "PDReader", "ddReader", "htReader", "PDWriting", "ddWriter", "hdOutput"]}}
{"id1": "14093044", "id2": "6501291", "code1": "    @Override\n    public boolean insert(String consulta, boolean autocommit, int transactionIsolation, Connection cx) throws SQLException {\n        filasInsert = 0;\n        if (!consulta.contains(\";\")) {\n            this.tipoConsulta = new Scanner(consulta);\n            if (this.tipoConsulta.hasNext()) {\n                execConsulta = this.tipoConsulta.next();\n                if (execConsulta.equalsIgnoreCase(\"insert\")) {\n                    Connection conexion = cx;\n                    Statement st = null;\n                    try {\n                        conexion.setAutoCommit(autocommit);\n                        if (transactionIsolation == 1 || transactionIsolation == 2 || transactionIsolation == 4 || transactionIsolation == 8) {\n                            conexion.setTransactionIsolation(transactionIsolation);\n                        } else {\n                            throw new IllegalArgumentException(\"Valor invalido sobre TransactionIsolation,\\n TRANSACTION_NONE no es soportado por MySQL\");\n                        }\n                        st = (Statement) conexion.createStatement(ResultSetImpl.TYPE_SCROLL_SENSITIVE, ResultSetImpl.CONCUR_UPDATABLE);\n                        conexion.setReadOnly(false);\n                        filasInsert = st.executeUpdate(consulta.trim(), Statement.RETURN_GENERATED_KEYS);\n                        if (filasInsert > -1) {\n                            if (autocommit == false) {\n                                conexion.commit();\n                            }\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    } catch (MySQLIntegrityConstraintViolationException e) {\n                        System.out.println(\"Posible duplicacion de DATOS\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLNonTransientConnectionException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLDataException e) {\n                        System.out.println(\"Datos incorrectos\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (MySQLSyntaxErrorException e) {\n                        System.out.println(\"Error en la sintaxis de la Consulta en MySQL\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (SQLException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } finally {\n                        try {\n                            if (st != null) {\n                                if (!st.isClosed()) {\n                                    st.close();\n                                }\n                            }\n                            if (!conexion.isClosed()) {\n                                conexion.close();\n                            }\n                        } catch (NullPointerException ne) {\n                            ne.printStackTrace();\n                        } catch (SQLException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"No es una instruccion Insert\");\n                }\n            } else {\n                try {\n                    throw new JMySQLException(\"Error Grave , notifique al departamento de Soporte Tecnico \\n\" + email);\n                } catch (JMySQLException ex) {\n                    Logger.getLogger(JMySQL.class.getName()).log(Level.SEVERE, null, ex);\n                    return false;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException(\"No estan permitidas las MultiConsultas en este metodo\");\n        }\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"insert": ["execute", "replace", "add", " Insert", "write", "save", "post", "select", " inserted", " append", "append", "put", "delete", "submit", "exec", "action", "apply", "it", "commit", "update", "Insert", "create", " insertion", "process", " inserting", "ERT"], "consulta": ["ConsULTar", "consulas", "Consultao", "consributas", "consuncte", "Consultarea", "Consultsa", "consultas", "Consultable", "consultar", "consributa", "consorta", "consultsar", "consultable", "consULTarea", "consunctas", "consultsao", "consunctarea", "consultsarea", "consuncta", "consunctable", "consculable", "consULTao", "conscula", "conscularea", "consultao", "ConsULTa", "consULTe", "consorte", "consultsas", "Consultsable", "consultse", "consulte", "Consultas", "consule", "consular", "consributarea", "ConsULTe", "Consultar", "consculas", "Consultsarea", "consultarea", "Consultsao", "Consultsas", "Consultse", "consortao", "ConsULTas", "consultsa", "consULTas", "consULTa", "consultsable", "consula", "consULTar", "consributao", "Consulte", "consunctao", "Consulta", "consortas"], "autocommit": ["autecomit", "autOComit", "autocommIT", "autocCommit", "autocCommmit", "autrocompmit", "autocompited", "autecommited", "autrocompits", "autocommits", "autocCommitting", "autecommitting", "autrocompIT", "autrocommmit", "autacommits", "autacommitting", "autocCommits", "autocompact", "autocomIT", "autocompit", "autrocommIT", "autOComitting", "autacCommact", "autacommit", "autocommact", "autacCommits", "autOCommitting", "autOComits", "autocomact", "autocleanIT", "autrocommits", "autacCommit", "autecomitting", "autocompmit", "autacommact", "autocommmit", "autocquits", "autOCommits", "autocleanit", "autocCommact", "autocomited", "autecomits", "autocleanits", "autrocommit", "autocomitting", "autocCommited", "autocomits", "autocommited", "autocqumit", "autOCommit", "autocquit", "autocommitting", "autocquitting", "autocompits", "autacCommitting", "autecommits", "autrocompit", "autOCommmit", "autocomit", "autocompIT", "autecomited", "autocleanmit", "autocompitting", "autecommit"], "transactionIsolation": ["transactionISola", "transactionIolate", "transactionEolation", "transactIsolation", "transactIsoli", "transactIoli", "transactionIolation", "transactionEolate", "transactionIsolate", "transactIsolution", "transactionInteroration", "transactionInfoolation", "transactIsolated", "transactionRestolated", "transactionISoration", "transactionIdola", "transactIsola", "transactionISolation", "transactionIsola", "transactionInterola", "transactIsoration", "transactionISolated", "transactionIsolution", "transactIoration", "transactionInfooration", "transactIola", "transactIolate", "transactionRestolate", "transactionInterolate", "transactionInfoolate", "transactionISoli", "transactionEola", "transactionIdoli", "transactionIdolate", "transactionIola", "transactionIsoli", "transactionRestolation", "transactIsolate", "transactionRestoration", "transactionInterolated", "transactionIdolution", "transactionISolution", "transactionEoration", "transactionIdolated", "transactIolation", "transactIolated", "transactionIoration", "transactionIolated", "transactionISolate", "transactionIoli", "transactIolution", "transactionIsoration", "transactionIolution", "transactionIdolation", "transactionInfoolated", "transactionIsolated", "transactionInterolation"], "cx": [" cxc", "dcx", "cax", "lcxf", "ccxx", "mctx", "lcxx", "ccax", "cxx", "mcx", "Cx", "Ctx", "mcxb", "ccx", " cxb", "cxf", "dcxx", "Cxc", "dcax", "lcx", "cxc", " ctx", "Cxb", "mcxc", "ctx", "cxb", "dcxf", "lcax", "ccxf"], "filasInsert": ["filasaInsert", "ilasInsert", "filasERT", "filansImport", "filaisInsert", "ilasinsert", "filAsinsert", "filasDelete", "FilabsERT", "FilaisPut", "filabsERT", "FilaisInsert", "filaInsert", "FilabsUpdate", "filasPut", "FilaisSelect", "filabsUpdate", "filASInsert", "filisAdd", "filasinsert", "filASUpdate", "filaUpdate", "filasaImport", "filisInsert", "FilabsInsert", "FilasUpdate", "ilasAdd", "filasUpload", "filAsAdd", "ilarsInsert", "filAsUpload", "ilarsUpload", "filisinsert", "FilasSelect", "filaisPut", "filAsInsert", "filasUpdate", "filasSelect", "filasImport", "filarsinsert", "filabsInsert", "filaisImport", "FilabsDelete", "filisUpload", "filasAdd", "FilasImport", "filASDelete", "filarsAdd", "FilasPut", "filarsUpload", "filaDelete", "filansPut", "filasaPut", "ilasUpload", "FilasInsert", "FilasERT", "ilarsAdd", "filansInsert", "filaisSelect", "filansSelect", "FilasDelete", "filaERT", "FilaisImport", "filasaSelect", "ilarsinsert", "filarsInsert", "filASERT", "filabsDelete"], "tipoConsulta": ["tipoconsultas", "tipoconsultada", "tipoconsultsada", "tipoconsultsao", "tipoConsulsao", "tipoConsultada", "tipoConsultia", "tipoConsULTation", "tipoconsultation", "tipoConsultsao", "tipoConsultsada", "tipoConsultao", "tipoconsultsation", "tipoconsultsas", "tipoConsulsas", "tipoConsultureao", "tipoConsolida", "tipoconsulta", "tipoConsultas", "tipoconsultia", "tipoConsultureia", "tipoconsultsa", "tipoConsultureas", "tipoConsultsas", "tipoconsultao", "tipoConsulsation", "tipoConsolidas", "tipoConsULTao", "tipoConsULTia", "tipoConsulsada", "tipoConsultsia", "tipoConsulsa", "tipoConsULTada", "tipoConsulturea", "tipoConsolidao", "tipoConsultsation", "tipoConsULTas", "tipoConsultsa", "tipoConsULTa", "tipoConsultation", "tipoConsolidada", "tipoconsultsia"], "execConsulta": ["execConsultsan", "execConultas", "execConsultation", "execconsultsa", "execConsultsas", "execconsulto", "execconsulta", "execconsultsation", "execConulta", "execConsulto", "execConsulsa", "execConsultso", "execConsulsan", "execConsultada", "execConsultsation", "execConULTada", "execConsultan", "execConULTas", "execConULTa", "execconsultsas", "execConsulsada", "execConsULTo", "execConultan", "execConsULTa", "execconsultso", "execConsULTation", "execConsultsa", "execConsulation", "execconsultas", "execConULTan", "execConsultas", "execConultada", "execConsULTada", "execConsulo", "execConsulsas", "execconsultation", "execConsulas", "execConsULTan", "execConsula", "execConsultsada", "execConsULTas"], "conexion": ["conequent", "conexpION", "conexiton", "conexesions", "poseexions", "zonexpions", " conexent", "conexesION", "coneXions", " coneXION", "dosextION", "coneXent", "conexpional", "zonexions", "Colexional", "conexent", "posexione", "coneXone", "coneexiona", "coneexent", "conenexions", "posexions", "zonexpiao", "coneXion", "conextor", "dosexION", "zonexiao", "poseexione", "conequional", " conexor", "conexpion", "coneexione", "coneexif", "conenexione", "conequion", "dosextion", "dosextions", "conextional", "dosexions", "conebif", "dosexiton", " coneXion", "conextION", " conexION", "conextions", "conexif", "coneexiao", " coneXions", "conexiao", "conexpone", "poseexion", "coneXION", "conezions", "coneXiona", "conexpions", " coneexional", " coneexent", "coeexion", " coneexion", "conexession", "coneziton", "zonexpion", " conexional", "coexional", "conenexion", "coexion", "conexions", "conexpiao", "conexpession", "conebion", "zonexion", "conequiona", "coeexiton", "coneexession", "conextiton", "coneexion", "coneXiao", "conebiton", "dosexion", "coneXor", "conebional", "conexione", "Colextion", "conextion", "Colexion", "posexion", "coneexions", "conexional", " coneXor", "conenexional", "conexpiton", "conexiona", "coneexiton", "conexpor", " conexiona", "coexiton", "posexession", "dosextiton", "conexION", "conexor", "conezion", "ColextION", "conenexif", "coneXional", "conenexiton", "coexif", "coneexone", "conexesional", "conezION", "ColexION", " coneexiona", "conexpione", "conexesion", "zonexpone", "poseexession", "zonexone", " conexions", "Colextional", "conexone", "Colexions", "conenexession", "Colextions", "coneexional", "coeexif", "coeexional"], "st": ["rest", "sc", "ust", "ST", "est", "c", "se", "l", "s", "fr", "inst", "ld", "sm", "St", "nt", "mt", "sa", "d", "pr", "sb", "ste", "ct", "sr", "ost", "r", "str", "ut", "ist", "src", "cl", "nd", "h", "p", "put", "start", "sth", "e", "m", "t", "cr", "sl", "tt", "sh", "pe", "b", "sp", "bl", "statement", "f", "pt", "sts"], "MySQL": ["MyLL", "OpenLL", "OpenSSL", "OpenSQL", "OpenConnection", " myLL", " MyConnection", " MyLL", " mySSL", " MySSL", " myConnection", " mySQL", "MyConnection", "MySSL"]}}
{"id1": "21308543", "id2": "16719805", "code1": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyContent", " copiedFile", " copyContent", "transferContent", " copiedFiles", " copyStream", "copyStream", " copiedStream", "transferStream", " copyFiles", " copiedContent", "transferFiles", "copyFiles", "transferFile"], "src": ["remote", "string", "sin", "core", "sel", "path", "input", "sc", "sci", "uri", "resource", "server", "rc", "http", "slice", "filename", "project", "dest", "code", "feat", "inst", "rs", "rb", "source", "sit", "media", "upload", "ruby", "attr", "img", "href", "ls", "js", "image", "url", "scene", "this", "stream", "inf", "ource", "download", "loc"], "target": ["remote", "path", "base", "goal", "fat", "temp", "output", "resource", "master", "project", "rel", "result", "dest", "Target", "large", "prot", "arg", "content", "next", "nt", "type", "source", "eth", "arget", "parent", "text", "out", "director", "object", "name", "effect", "writer", "port", "to", "it", "compatible", "secure", "url", "top", "reference", "tx", "external", "loc"], "ic": ["aic", "i", "cc", "sci", "aci", "enc", "rc", "IC", "c", "ick", "fc", "irc", "mic", "ici", "ec", "vc", "lc", "ct", "voc", "inc", "isc", "acl", "xc", "cl", "ip", "pic", "icc", "ai", "nic", "ci", "exec", "ics", "io", "cit", "it", "pc", "ix", "mc", "ib", "ico", "cci", "iac", "bc", "ac", "cin", "ik", "loc"], "oc": ["anc", "aco", "cc", "sc", "ace", "alloc", "output", "acs", "enc", "rc", "OC", "ocol", "c", "fc", "o", "irc", "mic", "co", "ec", "vc", "uc", "ocr", "voc", "other", "roc", "isc", "xc", "pic", "bb", "oca", "arc", "ci", "exec", "io", "nic", "oci", "toc", "pc", "mc", "soc", "bc", "abc", "AC", "ac", "cs", "iv", "org", "loc"]}}
{"id1": "14191679", "id2": "19251426", "code1": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"EncodeReturn": ["EnccodeData", "EnodedReturns", "EnccodeReturns", "EnodedReturn", "EncodReturn", "EncodeData", "EncodeResult", "EnodeReturns", "EnodedResult", "EnodeReturn", "EncodData", "EnodeResult", "EncodResult", "EnodeData", "EnccodeReturn", "EncodReturns", "EncodeReturns", "EnodedData", "EnccodeResult"], "IOException": ["IOError", "DownloadError", " IOception", "IPException", "DownloadException", "IOception", " IOError", "IPError", "IPception", "Downloadception"], "c": ["cu", "cc", "sc", "n", "cmp", "cf", "enc", "gc", "fc", "l", "dc", "cpp", "nc", "ec", "client", "cp", "ce", "proc", "lc", "d", "ct", "cache", "uc", "r", "ch", "conv", "xc", "p", "cd", "C", "u", "ci", "e", "m", "t", "cr", "chain", "pc", "mc", "b", "y", "ac", "cs", "f", "cur"], "tmpf": ["zipF", "poraryf", "tempfen", "vmF", " tmpfs", "tempcf", " tmpF", "vmf", "tmpcf", "poraryfen", "tmpfd", "tempf", "tempfs", "tempF", "zipfs", "empf", "porarycf", "tmpF", "empF", "empfd", "vmfs", "empfs", "vmcf", "poraryF", "zipf", " tmpfen", " tmpcf", "zipfd", "tmpfen", "tempfd", "tmpfs"], "cw": [" cW", " cwa", "pw", "rcwd", " cwd", "cwe", " cwe", "ffw", "fw", "fwa", " cfw", "psw", "CW", "cW", "pwa", "fws", "lcwb", "cwd", "lcw", "lcwd", "rcwe", "pW", "Cw", " cwb", "cws", "lcwe", "cwa", "rcwb", "cfw", "csw", "Csw", "Cfw", "Cws", "Cwa", " csw", "rcw", "cwb", " cws"], "encdata": ["Enckeys", "encdatabase", "envreader", " enccache", " encdatabase", "secdata", "extdatabase", "envkeys", "envData", "extdat", "installdat", "encreader", "increader", " encdat", "seckeys", "secData", " encroot", "incdata", "envdat", "installdata", "EncData", "enckeys", "installData", " encreader", "Encdata", "extdata", "encdat", "envdata", "envroot", "Encdat", "encroot", "inccache", "installdatabase", "envcache", "encData", "incroot", " encData", "secdat", "extData", "enccache"], "pigdata": ["Pigsla", "pigsla", "pagresults", "Pigdata", "pippdata", "pocdat", "picresource", "Pibresource", "pigData", "pibData", "Pigsresults", "pibresource", "pibdat", "pocresource", "Pigdat", "Pigcache", "Pigla", "pichData", "Pigresource", "pocdata", "picdata", "pagdat", "pigscache", "pagData", "pigresults", "pigsdat", "Pigresults", "pigrData", "pagdata", "pigsdata", "pigrresults", "Pigsdat", "pigsData", "pigrdat", "pocData", "pippcache", "pibdata", "pigsresults", "Pigsdata", "pichcache", "pigcache", "pigrdata", "PigsData", "PibData", "Pigscache", "pippla", "pichla", "pichdata", "pigresource", "pigla", "picData", "picdat", "Pibdata", "PigData", "Pibdat", "pippData", "pigdat"], "pigroute": ["pipelange", "fibrote", "apigrouting", "miarune", "figrote", "apibrouting", "pigerote", "pipelune", "pigrouting", "figroute", "apigrroute", "fibrange", "pibrroute", "pirmouting", "migrote", "pirmroute", "pigrationoute", "pigrationange", "pibroute", "pigrange", "pibrange", "apigrouter", "pigerouting", "pigerune", "fibroute", "pigrroute", "pipelote", "pigrationroute", "pigrationote", "pibrouting", "apibrouter", "pigeroute", "pirmoute", "fibrroute", "figrroute", "piarote", "figrange", "migroute", "miaroute", "pipeloute", "apigroute", "pibrouter", "miarouting", "apibroute", "pigrote", "pirmouter", "pigrationouting", "pigrune", "pibrote", "miarote", "pigrouter", "piarouting", "migrune", "pigrationouter", "pipelroute", "piarune", "piaroute", "apibrroute", "migrouting", "pipelouting"], "fos": ["fops", "pOS", "poes", " fops", "Foes", "refos", "Foc", "refOS", " fOS", "tos", "Fos", "refoes", " foes", "fo", "pops", "pos", "toc", "to", "Fo", " fo", "toes", "fOS", "foes", "refops"], "foc": ["infec", "Fac", "infoc", "infocol", "infic", "Fec", "Focol", " focol", " fac", "Foc", "Fic", "infac", " fec", "focol", "fac", "fec"], "fis": ["cig", "fig", "fi", "infic", "infis", "cic", "Fig", "cics", "Fi", "Fic", "infi", " fi", "cis", "Fis", "fics", " fics", "infics", " fig", "Fics"], "fic": ["Fico", "cfic", " fico", "Fac", "infoc", "cfis", "cfics", "cfoc", "infic", "poc", "rfics", "fisc", "pis", "Foc", " fac", "Fisc", "rfic", "pac", " fisc", "Fic", "fico", "Fis", "pic", "fics", "rfis", " fics", "cfico", "infics", "rfoc", "infisc", "Fics", "fac"]}}
{"id1": "6341264", "id2": "8330057", "code1": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "code2": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"getJarEntry": ["getFolderEntry", "GetJarSource", "GetZipEntry", "loadJarEnt", "getZipentry", "getFolderInfo", "loadZipEntry", "getZipFile", "loadZipEnt", "loadZipFile", "GetJarEntry", "GetJarFile", "getEntryEntry", "getZipSource", "getEntryentry", "loadJarEntry", "getJarEnt", "getJarFile", "getZipInfo", "GetZipSource", "getJarentry", "GetZipFile", "getFolderFile", "getFolderSource", "getJarSource", "loadZipentry", "getEntryEnt", "GetZipInfo", "getZipEntry", "getJarInfo", "getjarEnt", "getjarFile", "getjarentry", "loadJarentry", "GetJarInfo", "getEntryFile", "getjarEntry", "getZipEnt", "loadJarFile"], "jarName": ["javaAlias", " jarId", "javaPath", "JarName", " jarPath", " jarID", " jarUrl", "browserName", "browserUrl", "JarAlias", "browserId", "javaName", " jarAlias", "jarPath", "javaUrl", "jarUrl", "jarAlias", "JarID", "browserAlias", "jarId", "javaId", "javaID", "jarID", "JarPath"], "entry": ["zip", "string", "path", "address", "ry", "ticket", "server", "uri", "id", "resource", "feed", "ie", "filename", "description", "host", "query", "ident", "Entry", "key", "offset", "type", "source", "jar", "connection", "str", "data", "file", "archive", "route", "plugin", "start", "name", "image", "secret", "element", "service", "enter"], "port": ["string", "path", "address", "server", "ort", "uri", "timeout", "version", "project", "limit", "patch", "length", "host", "time", "key", "offset", "password", "type", "delay", "target", "ports", "file", "ip", "name", "pos", "pid", "position", "PORT", "count", "Port", "service", "point", "direction"], "b": ["base", "buffer", "i", "beta", "bf", "emb", "bd", "eb", "lb", "c", "library", "cb", "l", "s", "bs", "obb", "orb", "pb", "mb", "bar", "reb", "abb", "d", "binary", "ab", "wb", "erb", "sb", "buff", "buf", "r", "ob", "fb", "p", "bb", "zb", "e", "nb", "db", "a", "bytes", "ib", "B", "bp", "v", "br", "xb", "f", "boot"], "codebase": [" codebas", "Codebas", "workBase", "corebar", "queb", "workbase", "corebase", " codefull", "workb", "broadb", "corebas", "queBase", "codebar", "CodeBase", "workfull", " codeBase", "broadbase", "quebase", "codebas", "quebas", "Codeb", "Codebase", "broadBase", "codeBase", " codebar", " codeb", "Codebar", "codeb", "broadfull", "coreBase", "codefull"], "protocol": ["Protocol", "Protology", "proport", " protology", "ocolocol", "ocolore", "verbocol", "protport", "predocol", "proocol", "Protport", "ocolurl", "predore", "predurl", "propology", "verbology", " protost", "proturl", "verbost", "prourl", "verburl", "propocol", "propurl", "proology", "predology", "Protore", "protology", "ocolology", "Protost", "propport", "Proturl", " proturl", "protost", "protore"], "x": ["val", "index", "xt", "xxxx", "max", "cross", "xf", "ex", "id", "xa", "xx", "z", "X", "en", "xxx", "xp", "d", "xd", "xes", "w", "work", "xs", "check", "xc", "h", "p", "es", "m", "ax", "lex", "rx", "pos", "exp", "xi", "ctx", "xxxxxxxx", "pe", "v", "y", "dx", "f", "wx", "tx", "fx", "ix", "ww"], "s2": [" sls", "e62", "patter", "xls", "o2", "sii", "s62", "v2", "osecond", "vtwo", "sls", "ptwo", "satter", "qsii", "e2", "v1", " s62", "esecond", "string2", "qsls", "s1", " s1", "qs2", "o62", "vatter", "o1", "ssecond", "e1", "stringtwo", "stwo", "xii", "p1", "qs1", " ssecond", "x1", " sii", "string1", "p2", "stringatter"], "x2": ["ix6", "ix0", "xSecond", "index6", "X1", "x6", "x0", "index2", " xSecond", "index0", "tx2", " x52", "X52", "XSecond", "tx1", "txSecond", "ix1", "index1", " x6", " x1", "X2", "x52", "x1", " x0", "ix2", "tx52"], "downloadHost": ["DownloadHost", " downloadDomain", "urlHost", "transferAddress", "updateAddress", " downloadAddress", "urlPort", "urlhost", "transferRoot", "transferPort", "downloadPath", "updateRoot", " downloadRoot", "updatehost", "urlDomain", "DownloadPath", "writePort", "transferHost", "downloadDomain", " downloadhost", "DownloadAddress", "downloadhost", "writeHost", "writeDomain", "downloadPort", "downloadRoot", " downloadPort", "transferhost", " downloadPath", "writehost", "transferPath", "Downloadhost", "updateHost", "downloadAddress"], "url": ["zip", "base", "ssl", "server", "uri", "resource", "user", "lock", "http", "rel", "j", "l", "il", "URL", "orb", "el", "util", "fl", "source", "jar", "connection", "ob", "build", "file", "li", "web", "ll", "bb", "log", "control", "ls", "ball", "coll", "image", "link", "sl", "rl", "service", "Url", "www", "ur", "obj", "ul", "contact", "f", "gl", "org", "loc"], "jurl": ["Jconnection", "Juri", "jUrl", "jjfile", "nurl", "ajurl", "jjob", "Jurl", "gUrl", "jeturi", "nconnection", "gURL", "jURL", "jetfile", "Jhttp", " jURL", "Jcoll", " jcoll", " jjob", "Jjob", "nURL", "jpURL", "ajuri", "jhttp", "jphttp", "jconnection", "jfile", "JUrl", " jfile", "ajfile", "jjcoll", "gurl", "gconnection", "jeturl", " jhttp", "jjurl", "JURL", "jjURL", "ajURL", "jetURL", "nUrl", "Jfile", "jpjob", "jpurl", "juri", "jcoll"], "je": ["zip", " ze", "jen", "ee", "pse", "ju", "ie", "kee", "py", "j", "se", "jl", "java", "jo", "si", "fr", "su", "la", "elt", "ja", "ji", "jar", "li", "Je", "jj", "ne", "oi", "js", "e", "ze", "jp", "obj", "ni", "opy", "Obj", "oe", "esi"], "is": ["zip", "info", "sin", "address", "i", "lis", "iss", "uri", "self", "IS", "isa", "http", "ie", "Is", "as", "ri", "api", "bs", "s", "il", "si", "ois", "ui", "ii", "ori", "in", "isl", "its", "so", "jar", "ais", "ob", "ir", "nis", "li", "src", "bb", "es", "ai", "ris", "js", "vs", "oss", "isin", "iris", "ios", "ib", "ses", "isi", "are", "obj", "state", "os", "iso", "cos", "mis"], "bis": ["zip", "uds", "sin", "base", "lis", "iss", "i", "uri", "pi", "IS", "usb", "bus", "lock", "serv", "http", "Is", "slice", "inner", "ri", "cb", "obb", "bs", "s", "abs", "ois", "bin", "ori", "bes", "binary", "sb", "bos", "oris", "bps", "connection", "proxy", "ubis", "ob", "ignore", "nis", "fb", "bb", "bi", "afi", "ris", "ls", "obs", "oss", "isin", "iris", "di", "ios", "ses", "obj", "abi", "os", "download", "bits", "boot", "cos", "mis"], "size": ["capacity", "address", "core", "sum", "close", "enc", "rc", "now", "act", "loc", "se", "eng", "mode", "large", "length", "si", "co", "grade", "time", "en", "content", "sized", "sync", "form", "cm", "rate", "use", "len", "small", "body", "cl", "hh", "init", "Size", "cel", "name", "ci", "cr", "send", "esc", "area", "SIZE", "speed", "unit", "shape", "ize", "err", "range", "sn", "scale", "width", "sec", "term", "iz"], "rb": ["bf", "rf", "nr", "rc", "lb", "vr", "eb", " rc", "ru", "cb", "rg", "lr", "obb", "ri", "rub", "orb", "rt", "RB", "pb", "rab", "gb", "reb", "abb", "rh", "sb", "wb", "ra", "erb", "buf", "r", "ob", "ruby", "src", "fb", "bb", "rar", "zb", "rr", "io", "rx", "rob", "cr", "nb", "adr", "area", "rl", "xb", "range", "rd", "sr", "loc"], "chunk": ["schrow", "bone", "chink", "Chunks", "cheunk", "shink", "prow", "CHink", "chunks", " Chunks", "clone", "punky", "clink", "pask", "cloy", "shoy", "cheunc", "chone", "qurow", "cheink", "chunky", "chunc", "CHunc", "boy", "quunk", " chunks", "schunk", "clunk", "shunk", "clunks", "chack", "quask", "Chack", "CHunk", "quunky", " Chunk", "schunky", " chack", " Chack", "chask", "chrow", "Chunk", "punk", "CHunks", "bink", "choy", "clunc", "cheunks", "bunk", "schask", "shone"]}}
{"id1": "20414923", "id2": "7761195", "code1": "    protected int deleteBitstreamInfo(int id, Connection conn) {\n        PreparedStatement stmt = null;\n        int numDeleted = 0;\n        try {\n            stmt = conn.prepareStatement(DELETE_BITSTREAM_INFO);\n            stmt.setInt(1, id);\n            numDeleted = stmt.executeUpdate();\n            if (numDeleted > 1) {\n                conn.rollback();\n                throw new IllegalStateException(\"Too many rows deleted! Number of rows deleted: \" + numDeleted + \" only one row should be deleted for bitstream id \" + id);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"Problem deleting bitstream. \" + e.getMessage(), e);\n            throw new RuntimeException(\"Problem deleting bitstream. \" + e.getMessage(), e);\n        } finally {\n            cleanup(stmt);\n        }\n        return numDeleted;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"deleteBitstreamInfo": ["deletebitStreamINFO", "deleteBitStreaminfo", "deletebitstreamInfo", "deleteBitsystemDetails", "deleteBitstreamDetails", "deleteBitsysteminfo", "deleteBitStreamDetails", "deletebitstreamDetails", "deleteBitsystemINFO", "deletebitStreaminfo", "deleteBitstoreINFO", "deletebitstreamINFO", "deletebitStreamInfo", "deleteBitStreamInfo", "deleteBitstreaminfo", "deleteBitstoreInfo", "deleteBitStreamINFO", "deleteBitstreamINFO", "deletebitstreaminfo", "deleteBitstoreinfo", "deleteBitstoreDetails", "deletebitStreamDetails", "deleteBitsystemInfo"], "id": ["index", "path", "info", "root", "address", "num", "i", "entry", "ref", "uid", "number", "did", "sid", "ide", "ident", "in", "ids", "key", "ad", "offset", "part", "like", "type", "no", "d", "one", "source", "which", "aid", "rid", "kid", "parent", "data", "oid", "x", "ip", "object", "p", "name", "start", "status", "db", "pid", "vid", "url", "ID", "seq", "create", "count", "mid", "error", "Id", "code"], "conn": ["Connection", "Conn", "cc", "server", "serv", "cf", "enc", "rc", "con", "c", "act", "col", "co", "rt", "dc", "nc", "client", "sync", "cm", "nt", "session", "cp", "stat", "pr", "ct", "connection", "ch", "config", "ca", "coll", "ci", "exec", "dn", "cr", "ann", "db", "jp", "mc", "ctx", "sql", "mn", "obj", "connect", "cn", "pg"], "stmt": ["strlt", "strmn", "strm", "shMT", " stMT", "Stmn", "shart", "stpr", " stlt", "strst", "Stst", " stm", "Stdb", "stlt", "strmt", "StMT", " stmd", "stMT", "Stmr", "stm", "strmd", "shmt", "shmd", " start", "sttr", "strtr", "stmr", "Stmd", "start", "strdb", " stdb", "strMT", "Stpr", " stst", "Stm", "strmr", "stst", " stpr", "Start", " stmn", "Stlt", " stmr", "stmn", "strpr", "stdb", "Stmt", "stmd", " sttr", "Sttr"], "numDeleted": [" numDeashed", "numDuleted", "numDeletes", "numDuDelete", "Numdeleted", "numDelleted", "numUndued", " numdeoded", "numNeleted", " numdeleted", "numdeued", "numDeloded", "numDefleted", " numDeased", "Numdeigrated", "numExashed", "numDeflected", "Numdeued", "numNeletes", "numDeoded", "numDefased", "numNelete", "NumDeleted", " numDeletes", " numdeletes", "numExleted", "NumdeDelete", " numDeoded", "numModleted", " numDelected", "numDeDelete", " numdelected", "numDeued", "numdeDelete", "numExletes", "numDeased", "numDellected", "numDefoded", "numMododed", "numModletes", "numDuigrated", " numdeased", " numDelete", "NumDeigrated", "numdeletes", "numdelete", "numdelected", "numUndleted", "numDeigrated", "NumDeued", "numDelected", "numExoded", "numDelete", "numDeashed", "numdeleted", "numDelased", "NumDeDelete", "numdeashed", "numModashed", " numdeashed", "numdeased", "numUndDelete", "numdeoded", "numdeigrated"]}}
{"id1": "4938100", "id2": "21999120", "code1": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "label": 1, "substitutes": {"sha1": ["sha256", "sha64", "SHA64", "hash1", "hash256", "hashOne", " SHA64", "SHAOne", " SHA256", "SHA1", "hash64", " SHA1", " SHAOne", "shaOne", "SHA256"], "text": ["letter", "path", "string", "EXT", "class", "translation", "input", "editor", "output", "token", "Text", "message", "TEXT", " TEXT", "version", "hex", "number", "pattern", "key", "content", "password", "txt", "source", "connection", "value", "str", "config", "data", "object", "struct", "format", "test", "name", "template", "image", "font", "word", "bytes", "url", "ext", "secret", "contract", " Text", "this", "code"], "UnsupportedEncodingException": ["UnsupportedEncodingEx", "UnsupportedEncoderException", "UnsupportedEncasingEx", "UnsupportedEncasingception", "UnsupportedEncodedEx", "UnsupportedEncasingException", "UnsupportedEncodingception", "UnsupportedEncoderEx", "UnsupportedEncodedception", "UnsupportedEncodedException", "UnsupportedEncoderception"], "md": ["editor", "bf", "gd", "mag", "bd", "df", "od", "Cmd", "amd", "map", "message", "mo", "ind", "mode", "ma", "am", "meta", "wd", "MD", " MD", "ms", "ld", "sm", "ad", "mb", "mt", "mac", "d", "mp", "hd", "sha", "pm", "pd", "data", "cmd", "body", "mm", "metadata", "cd", "dig", "m", "dm", "mand", "mc", "di", "nm", "mn", "me", "vd", "rm", "mg", "mad", "mod", "dd", "hash", "code", "valid"], "sha1hash": ["sha256sha", "sha256sum", "wa1sum", "SHA1Hash", "sha256Hash", "sha4hash", "SHA1address", "wa3hex", "sha256hash", "SHA2address", "sha1dash", "sha3dash", "sha001hex", "wa1hex", "sha91check", "SHA2sum", "sha41sum", "sha3hex", "sha001sum", "wa3dash", "SHA1check", "sha41hash", "sha1check", "sha5Hash", "wa1dash", "sha2Hash", "sha1Hash", "sha001hash", "sha91address", "wa3hash", "sha2sha", "sha91hash", "SHA1sha", "sha2address", "wa3sum", "sha001dash", "sha41check", "sha91sum", "sha1address", "sha41address", "wa1hash", "sha3sum", "sha5sum", "SHA2check", "SHA1hash", "sha4sum", "sha2sum", "sha1sha", "sha4hex", "SHA2Hash", "sha2check", "sha2hash", "sha3hash", "sha5hash", "sha4dash", "sha5sha", "SHA2sha", "sha1hex", "SHA1sum", "SHA2hash", "sha1sum"]}}
{"id1": "16550855", "id2": "20306677", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "label": 0, "substitutes": {"readPage": ["readPages", "openpage", "readFile", "openPages", "getFile", "findPage", "getPages", "getPage", "readpage", "findPages", "openFile", "getpage", "findFile", "openPage", "findpage"], "ignoreComments": ["useComments", "includeTags", "includeComments", " ignoreTags", "oreComment", "ignorecomments", "orecomments", "ignoreComment", "oreQuotes", "useTags", " ignoreComment", "useQuotes", "ignoreQuotes", "usecomments", "includeComment", "oreComments", " ignorecomments", "oreTags", "includecomments", " ignoreQuotes", "ignoreTags"], "in": ["IN", "index", "ssl", "buffer", "i", "input", "id", "token", "loader", "user", "ini", "gin", "on", "http", "into", "con", "c", "inner", "socket", "version", "as", "ins", "s", "bin", "is", "client", "reader", "source", "login", "connection", "min", "inside", "r", "inc", "data", "file", "out", "h", "init", "rec", "again", "e", "m", "image", "t", "re", "isin", "it", "In", "nin", "kin", "url", "stream", "lin", "b", "err", "inn", "f", "win", "din"], "inputLine": ["InputText", "incLook", "incL", "InputLook", "requestRow", "inputName", "requestline", "pullLine", "installline", "inputRow", " inputRow", "requestLink", " inputCell", "incLine", "ifLook", "ifline", "InputName", "pullline", "installLook", "imageLine", " inputText", " inputLook", "imageL", "InputLine", "rawLine", "Inputline", "pullLink", "requestLine", "InputLink", "incline", "rawL", "ifLine", " inputName", "ifCo", " inputCo", "inputL", " inputPage", "imageline", "commentline", " inputline", "rawName", "requestLook", "installL", "pullRow", "InputL", "inputCo", "commentLine", "inputCell", "inputText", "inputline", "rawLink", "InputCell", "requestCo", "inputPage", "rawText", "inputLook", " inputL", "commentCell", " inputLink", "installLine", "imageLook", "inputLink", "rawline", "InputPage", "commentPage"], "html": ["article", "base", "temp", "css", "HTML", "output", "bf", "atom", "embed", "gh", "http", "message", "json", "plain", "ht", "result", "hot", "ui", "detail", "strong", "high", "htm", "content", "part", "wrap", "links", "doc", "tml", "source", "live", "show", "str", "data", "attr", "body", "flat", "amp", "war", "web", "h", "page", "flash", "inline", "format", "msg", "title", "template", "rss", "header", "js", "text", "home", "blog", "link", "details", "dump", "url", "tt", "www", "summary", "xml", "tf", "bsp", "f", "hard", "api", "view", "img"]}}
{"id1": "12766394", "id2": "5035872", "code1": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"testReadHelloWorldTxt": ["testReadHelloWorldMtxt", "testReadHelloWordTtxt", "testReadHelloWordMtxt", "testReadHelloWorldFxt", "testReadHelloWordMext", "testReadHelloWordText", "testReadHelloWorldMXT", "testReadHelloWordMxt", "testReadHelloWorldFext", "testReadHelloWorldTtxt", "testReadHelloWorldMext", "testReadHelloWordTxt", "testReadHelloWordMXT", "testReadHelloWorldText", "testReadHelloWorldFtxt", "testReadHelloWorldFXT", "testReadHelloWordTXT", "testReadHelloWorldMxt", "testReadHelloWorldTXT"], "helloWorldIS": [" helloWorldIR", "helloCommunityIDE", " helloWorldIDE", " helloCityIR", "helloCityIR", "helloWorldis", "helloCityIDE", "helloCityIs", "helloWorldIR", "helloWestIR", "helloCityAS", " helloCityAS", "helloWorldIDE", " helloWorldis", "helloCommunityIs", " helloCityIS", "helloWestAS", "helloWestIs", " helloCityIs", "helloWorldIs", "helloCommunityIS", "helloWorldAS", " helloWorldAS", "helloCityis", "helloWestIS", " helloWorldIs", "helloCityIS"], "helloWorldPath": ["officeCommunityLocation", "helloCommunityDir", "helloWebPath", "officeCommunityPATH", "helloWorldDir", "hiWorldUrl", "helloworldCorp", "helloWorldCorp", "helloCommunityName", "officeCommunityPath", "helloworldPath", "helloWorldName", "officeCommunityCorp", " helloWorldName", "helloWallDir", "helloWorldPATH", "helloworldPATH", " helloWorldpath", "hiWorldpath", "helloWorldFile", "helloCommunityLocation", "officeWorldPATH", "helloWebpath", "hiWorldPath", "hiWebpath", "helloWallpath", "hiWorldFile", "officeWorldLocation", "helloWallPath", "helloCommunityCorp", "helloWorldpath", "helloWorldUrl", "officeWorldCorp", " helloWorldDir", "helloCommunityPath", "helloworldLocation", "helloCommunityPATH", "helloWebFile", "officeWorldPath", "hiWebUrl", "helloCommunitypath", "hiWebPath", "hiWebFile", "helloWorldLocation", "helloWebUrl", "helloWallName"], "fileOutputStream": ["fileInputPath", "fileInputStream", "fileOutPath", "fileOutputFile", "fileWriteSteam", "fileWritestream", "resourceInputFile", "FileOutputHandler", "FileInputstream", "FileInputSteam", "fileOutFile", "fileOutSteam", "fileWriteStream", "FileInputFile", "FileInputStream", "resourceOutputStream", "fileOutputstream", "resourceOutputSteam", "resourceOutputFile", "FileOutputstream", "FileOutputSteam", "fileWritePath", "fileoutputstream", "fileoutputHandler", "fileInputFile", "fileOutputHandler", "fileoutputSteam", "resourceInputStream", "resourceOutputPath", "fileWriteFile", "fileInputHandler", "fileOutputPath", "resourceInputSteam", "resourceInputPath", "FileInputHandler", "fileInputstream", "FileOutputFile", "fileOutputSteam", "fileInputSteam", "fileoutputStream", "FileOutputStream", "fileOutStream"], "contentResolver": ["contentRevolves", "contentRevolver", "contentResponseistor", "contentResponseolve", "ContentRolving", "ContentResoser", "contentRoser", "messageResolution", " contentRevolved", "contentRevistor", "ContentRolver", "contentresolver", "contentAbsoser", "contentResultolver", "contentResponseolved", " contentRevolver", "contentResponseolver", " contentRevistor", "contentResolved", "contentAbsolution", "resourceResolution", "contentResoser", "resourceResolver", "ContentRolve", "messageResultolver", "ContentRolution", "resourceRolved", " contentresolves", "messageResultolution", "messageResolve", "contentResolve", "contentAbsolver", "messageResultolve", "resourceResolve", "resourceRolver", "resourceResolved", "contentResolution", "contentResultistor", "ContentResolve", " contentResistor", "contentReslier", "contentResolving", "contentresolve", "contentRevolution", "contentRolved", "contentResultolved", "ContentRoser", "contentresolution", "contentRolves", "contentResolves", "contentresolves", " contentRevolve", "ContentResolver", " contentresolve", "contentResultolution", " contentResolved", "contentRlier", "contentRolver", " contentResolves", "contentRevolve", "messageReslier", "contentAbsolve", "ContentResolving", "messageResultlier", "contentResistor", "contentResultolve", " contentresolution", "contentresolving", "messageResolver", "contentRolve", " contentresolver", "resourceRolve", " contentResolve", "contentresolved", "resourceRolution", "contentRevolved", " contentResolution", "contentRolving", "contentreslier", "contentRolution", "ContentResolution", "contentResultlier"], "content": ["play", "path", "string", "address", "core", "css", "temp", "server", "output", "resource", "response", "feed", "copy", "column", "draft", "message", "version", "json", "cont", "document", "current", "result", "java", "any", "child", "html", "write", "read", "password", "Content", "next", "cache", "load", "lc", "activity", "value", "connection", "media", "model", "children", "default", "work", "config", "data", "text", "file", "body", "parent", "page", "empty", "size", "conn", "fill", "complete", "title", "name", "example", "header", "job", "image", "status", "ontent", "word", "full", "layer", "url", "ext", "update", "comment", "xml", "script", "handle", "code", "valid"]}}
{"id1": "5744493", "id2": "22441244", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": [" dofileCopy", " doFileCopy", "newBlockWrite", " doBlockCopy", " dofilecopy", " doFolderProxy", "newBlockcopy", "newFilecopy", " doFolderWrite", "newFileCopy", " dofileWrite", "newBlockProxy", " doBlockProxy", " doFoldercopy", " doFileWrite", "newFileWrite", " doFolderCopy", " dofileProxy", " doBlockcopy", " doFileProxy", "newBlockCopy", "newFileProxy", " doBlockWrite", " doFilecopy"], "in": ["IN", "index", "pin", "base", "i", "input", "id", "ex", "buffer", "lock", "c", "inner", "ins", "bin", "query", "part", "reader", "source", "login", "min", "diff", "inc", "config", "data", "file", "again", "name", "m", "image", "isin", "In", "url", "lin", "b", "err", "inn", "win"], "out": ["string", "base", "buffer", "temp", "server", "output", "copy", "ex", "resource", "user", "pre", "plain", "OUT", "socket", "o", "outs", "off", "write", "part", "source", "cache", "dot", "connection", "target", "default", "file", "page", "conn", "name", "again", "exec", "Out", "io", "writer", "image", "prefix", "ext", "v", "b", "external", "point"], "inChannel": ["binStream", "binSocket", "INSocket", "inSocket", "inputChannel", "INchannel", "inStream", " inchannel", "inputSocket", " inClient", "inchannel", "binChan", "InChan", "inputChan", "Inchannel", "INChan", "outStream", "INClient", "outchannel", "outChan", "inChan", "InChannel", "outSocket", "InStream", "inputStream", "outClient", "binChannel", "INStream", "InSocket", "INChannel", " inStream", "inClient", " inChan", " inSocket"], "outChannel": ["inSocket", "OutStream", "inStream", "againChannel", "againSocket", "intChan", " outButton", "OutChannel", "inchannel", " outContainer", "againChan", "inButton", "OutChan", " outSocket", "outStream", "outContainer", "outchannel", "againStream", "outChan", "inChan", "outSocket", "OutBuffer", "intChannel", "intchannel", "outButton", "inBuffer", "outBuffer", "intButton", " outStream", "inContainer", "OutContainer", " outBuffer", " outchannel", " outChan"], "maxCount": ["MaxLength", " maxLength", "maxcount", "MaxCount", "maxSize", "axcount", "maxLength", "maxSum", "blockCount", " maxcount", "Maxcount", "MaxSum", "MaxSize", "axCount", " maxSum", "axLength", "blockSize", " maxSize", "blockSum", "blockcount", "axSize"], "size": ["capacity", "address", "max", "sum", "fee", "n", "cap", "end", "limit", "volume", "mode", "length", "shift", "time", "en", "offset", "sized", "type", "min", "len", "seek", "data", "small", "empty", "p", "Size", "start", "name", "available", "send", "SIZE", "bytes", "position", "flush", "unit", "shape", "ize", "range", "count", "width", "scale", "transfer", "speed", "loc"], "pos": ["val", "index", "push", "address", "base", "i", "id", "spec", "pose", " position", "slice", "ref", "Pos", "rel", "limit", "o", "slot", "length", "off", "pass", "iter", "offset", "part", "no", "min", "len", "diff", "open", "data", "p", "neg", "po", "start", "port", "pointer", "pid", "position", "unit", "point", "POS", "obj", "count", "os", "block", "pt", "cos", "loc"]}}
{"id1": "20365090", "id2": "7372311", "code1": "        public HttpResponseExchange execute() throws Exception {\n            HttpResponseExchange forwardResponse = null;\n            int fetchSizeLimit = Config.getInstance().getFetchLimitSize();\n            while (null != lastContentRange) {\n                forwardRequest.setBody(new byte[0]);\n                ContentRangeHeaderValue old = lastContentRange;\n                long sendSize = fetchSizeLimit;\n                if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) {\n                    sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1);\n                }\n                if (sendSize <= 0) {\n                    break;\n                }\n                lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength());\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_RANGE, lastContentRange);\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sendSize));\n                forwardResponse = syncFetch(forwardRequest);\n                if (sendSize < fetchSizeLimit) {\n                    lastContentRange = null;\n                }\n            }\n            return forwardResponse;\n        }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 0, "substitutes": {"execute": [" poll", " future", " work", " pull", " parse", " await", " transfer", " resolve", " async", " open", " flush", " dispatch", " produce", " feed", " refresh", " current", " serve", " fulfill", " perform", " prepare", " initialize", " generate", " end", " proceed", " go", " exec", " ping", " handle", " finish"], "forwardResponse": ["forwardServer", "wardRequest", "publicRequest", "publicResponse", "wardResp", " forwardAnswer", " backwardServer", " backwardRequest", " forwardServer", "wardresponse", " forwardResp", "publicServer", " forwardRequest", "ForwardRequest", "forwardresponse", "Forwardresponse", "forwardView", "forwardRequest", "wardView", " backwardResponse", " forwardresponse", "forwardAnswer", "ForwardResponse", "publicAnswer", "forwardResp", " forwardView", " backwardAnswer", "ForwardView", "wardResponse", "ForwardResp"], "fetchSizeLimit": ["fatchLengthLim", "fetchSizeRange", "fetchLimitGlobal", "faitLimitLock", "fetchsizeLim", "fetchLengthRange", "fetchRangeLimit", "faitSizeBlock", "fatchLengthPosition", "fetchCountRange", "fetchLimitRange", "fetchLengthUnit", "fatchSizeLimited", "fetchCountBlock", "fetchLengthLim", "fatchSizeLimit", "fetchRangePage", "fetchsizeLock", "fatchSizePosition", "fetchSizeUnit", "fetchLengthBlock", "fetchLimitPosition", "faitLimitGlobal", "fatchLengthLock", "fushCountPage", "fetchSizePosition", "faitSizeLimit", "fushSizeUnit", "faitSizeLock", "fetchsizeLimited", "faitLimitLimit", "fatchSizeBlock", "fetchCountLimit", "fetchLengthLock", "fatchSizeLock", "fushSizePage", "fetchsizeBlock", "fetchLengthPosition", "fetchLimitLock", "fetchsizeGlobal", "faitSizeGlobal", "fetchSizeLim", "fetchSizeLimited", "fetchSizeBlock", "fetchRangeUnit", "faitLimitBlock", "fatchSizeLim", "fetchLimitLimit", "fushSizeLimit", "fetchSizeLock", "fetchLimitBlock", "fatchLengthLimit", "fetchLengthGlobal", "fushCountLimit", "fatchLengthLimited", "fetchsizeLimit", "fetchLengthPage", "fatchSizeRange", "fushCountUnit", "fetchSizePage", "fetchCountPosition", "fushCountRange", "fatchLengthRange", "fetchRangeRange", "fetchLengthLimit", "fatchLengthBlock", "fetchCountUnit", "fetchCountPage", "fetchSizeGlobal", "fetchLengthLimited", "fushSizeRange"], "lastContentRange": [" lastSizeRange", "lastCharacterRange", "lastContentRow", "lastMessageResource", "lastContentLine", "latestContentRow", " lastContentArea", " lastHeaderRegion", "latestFileRange", " lastContentInfo", "LastMessageResource", " lastContentResource", "lastMessageSpace", "lastReadRegion", "lastCharacterRegion", "lastHeaderResource", "lastVersionrange", "lastResourceRow", "lastCurrentLine", "lastCharacterOrigin", " lastContentRow", "lastFileRow", "lastMessageRow", "latestContentRange", " lastContentOrigin", " lastReadInfo", "lastVersionRange", "lastCurrentSpace", "lastReadResource", "lastResourceRange", "lastHeaderRange", "latestContentResource", "lastContentInfo", "lastCharacterRow", "LastContentLine", " lastContentrange", "lastResourceRegion", "lastResourcerange", " lastHeaderOrigin", " lastContentSpace", "latestFileResource", "lastContentSpace", "lastSizeRange", "lastResourceSpace", "lastReadRow", "LastContentResource", "lastContentRegion", "lastSizeRegion", "lastResourceArea", " lastSizeArea", "lastSizeSpace", " lastSizeSpace", "lastSizeArea", "lastReadrange", "lastReadSpace", "lastReadRange", "LastContentRange", "LastContentSpace", "lastVersionResource", " lastReadrange", "LastMessageSpace", "lastCurrentRange", " lastSizeRegion", "latestFileRow", "lastFileResource", "lastResourceResource", " lastReadRange", "lastContentResource", "lastHeaderRegion", " lastContentRegion", " lastHeaderRange", "LastMessageLine", "lastHeaderSpace", "lastMessageRange", "lastVersionInfo", "lastReadArea", " lastReadResource", "lastHeaderLine", "lastHeaderRow", "lastResourceInfo", "lastContentrange", "lastHeaderOrigin", " lastHeaderRow", "lastContentOrigin", "LastMessageRange", "lastMessageLine", "lastReadInfo", "lastCurrentResource", "lastResourceOrigin", "lastContentArea", "lastFileRange"], "old": ["val", "from", "string", "original", "base", "past", "list", "add", "now", "OLD", "slice", "current", "inner", "older", "later", "l", "el", "existing", "ld", "last", "la", "form", "client", "part", "less", "after", "expected", "before", "Old", " Old", "diff", "common", "other", "build", "small", "file", "local", "object", "ant", "ore", "format", "or", "plugin", "folder", "normal", "to", "full", "low", "update", "ext", "obj", "future", "and", "prev", "handle", "element", "orig", "arrow", "front"], "sendSize": ["sentLength", "transferRange", "sendSIZE", "drawLength", " sendLen", "writeRange", "endLength", "endSIZE", " sendTime", "sendLength", "loadSize", "forceSIZE", " sendLength", "loadSIZE", "transferSize", "SendStorage", " sendSIZE", "updateSIZE", "endTime", "forceSize", "drawLimit", "sentLimit", "SendSize", "transferLength", "sendOffset", "sendRange", " sendLimit", " sendStorage", "forceLength", "sendLimit", "writeLength", "sendStorage", "pushSIZE", "updateLen", "endEnd", "sendTime", "drawSize", "loadTime", " sendEnd", "SendEnd", "sendEnd", "sentSize", "forceTime", "updateSize", "pushLen", "transferOffset", "loadOffset", "sendLen", "pushTime", "endStorage", "updateLimit", "endLimit", "pushLimit", "endSize", "drawSIZE", "writeSize", "pushLength", "loadRange", "loadLength", "SendLength", "sentSIZE", "writeOffset", "pushSize"]}}
{"id1": "189963", "id2": "14882263", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void UploadActionPerformed(ActionEvent evt) {\n        JFileChooser chooser = new JFileChooser();\n        FileNameExtensionFilter filter = new FileNameExtensionFilter(\"*.jpg\", \"jpg\");\n        chooser.setFileFilter(filter);\n        File dir = new File(System.getProperty(\"user.home\"));\n        chooser.setCurrentDirectory(dir);\n        Component parent = null;\n        int returnVal = chooser.showOpenDialog(parent);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            UserStatus.setText(\"Bitte warten\");\n        }\n        try {\n            Pic.setVisible(false);\n            FTPClient client = new FTPClient();\n            client.connect(\"showus.de\");\n            client.login(\"web2\", \"kcinnay88\");\n            client.enterLocalActiveMode();\n            client.setFileTransferMode(FTPClient.BINARY_FILE_TYPE);\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            int reply = client.getReplyCode();\n            System.out.println(\"Connect returned: \" + reply);\n            FileInputStream in = new FileInputStream(chooser.getSelectedFile().getAbsolutePath());\n            System.out.println(\"Uploading File\");\n            client.storeFile(\"/html/Applet/user/\" + Config.id + \".jpg\", in);\n            client.logout();\n            in.close();\n            System.out.println(\"done\");\n            UserStatus.setText(\"Upload fertig, Bild wird aktuallisiert\");\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            UserStatus.setText(\"Fehler beim Upload\");\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndRebwrite", "readAndRebrap", "readAndRewwrite", "readAndSwrap", "readAndrewwrite", "readAndRebrite", "readandRewrap", "readandRewrites", "readAndSwwrite", "readandrewrap", "readAndRewrap", "readAndSwrite", "readandrewrites", "readandrewwrite", "readAndRebrites", "readAndRewrites", "readAndrewrite", "readAndSwrites", "readandrewrite", "readAndrewrites", "readAndrewrap", "readandRewwrite", "readandRewrite"], "inFile": [" inSourceFile", "InSourceFile", "oldfile", "outSourceFile", "inputfile", "outfile", " inFiles", "inputFilename", "InFiles", " infile", "infile", "inputFile", "outFiles", "oldFile", "loginFile", " inFilename", "Infile", "inFiles", "inputFiles", "oldFiles", "loginFilename", "loginfile", "loginFiles", "InFile", "oldFilename", "outFilename", "inFilename", "inSourceFile"], "outFile": ["newfile", "outDir", "OutStream", "processFile", "outputFilename", "exFilename", "outputfile", " outfile", "outPlace", "outFILE", "outputFILE", "outfile", "processFilename", "offFILE", "outputPlace", "thisFilename", "outStream", "thisFile", "processPlace", "exfile", "thisFILE", "newDir", "exFILE", "OutDir", "exFile", "processFILE", "newStream", "offPlace", "OutFile", " outStream", "outFilename", "offFilename", "Outfile", " outDir", "outputFile", "newFile", "thisfile", "offFile"], "iis": ["iIS", "Iais", "iIs", "iiris", "iniIs", "iiiss", "iais", "Iis", "ciis", "iiis", " iIs", " iIS", " iais", "ciiss", "Iiss", "ciais", " iiss", "iiss", "iiIS", "iniiss", " iris", "iniis", "ciris", "iniIS", "iniris", "IIS", "iris", "iiIs", "ciIS", "ciIs"], "dcmParser": ["dbmPolicy", "dbmParser", "dmmLoader", "dmissionParser", "dcmInstallation", "dmoduleJar", "dpmLoader", "dmoduleparser", "dhemReader", "dkmParser", "dmissionLanguage", "dCMPlugin", " dpmparser", " dcrParser", "fpmparser", "dhemJar", " dpmPolicy", "dkmPolicy", "dpmParser", "dcmPolicy", "dmissionPlugin", " dcmarser", "dmmPlugin", " dcrPlugin", "DcmInstallation", " dcmLanguage", "dpmHandler", "dmcJar", "dkmPlugin", " dpmParser", "dmoduleReader", " dcrLoader", "fcmReader", "dmissionReader", "dcrParser", "dmcarser", "dbmHelper", "dmLoader", "fpmHandler", "dcrarser", "dhemInstallation", "dmcParser", "dmmparser", "dpmLanguage", "dmodulePlugin", " dcmPolicy", "dpmarser", "dpmReader", "dcmPar", "dpmPar", "dmReader", "dcmparser", "dcrLoader", "dmParser", " dcmLoader", " dcmReader", "fcmparser", "dpmPolicy", "dcrJar", "dcmPlugin", "dpmparser", "fpmReader", "dcmarser", " dpmPlugin", "dbmPlugin", "dpmPlugin", " dpmHelper", "dCMLoader", " dpmLoader", " dpmJar", "dmoduleParser", " dcrReader", "dcmLoader", "fcmParser", "dpmHelper", "dcmReader", " dpmPar", "dCMHandler", "dmPlugin", "dcmJar", "dcrPlugin", "dpmJar", " dcmJar", "fcmHandler", " dcmHelper", "dCMparser", "dcrPar", "DcmParser", " dcmPar", "dcrReader", "fpmParser", " dpmReader", " dcmparser", "dmcPar", " dpmLanguage", "dcmHelper", "dpmInstallation", "dcmHandler", "dCMParser", "dcmLanguage", "dmmParser", "DcmReader", "dCMReader", "dkmHelper", " dcmPlugin", "DcmJar", "dhemParser", " dpmarser"], "ds": ["services", "ys", "uds", "ays", "DS", "iss", "gd", "sys", "Os", "df", "ants", "ns", "tes", "ks", "drivers", "qs", "bs", "s", "ins", "dr", "is", "dc", "rs", "ld", "dt", "parts", "cdn", "sync", "session", "ws", "d", "ros", "eps", "points", "icks", "ads", "data", "gs", "src", "xs", "utils", "vals", "ras", "Ds", "des", "ts", "conn", "vs", "ls", "js", "ss", "db", "ils", "di", "nas", "details", "amps", "Db", "da", "asi", "cs", "dds", "ps", "os", "dat", "pd", "dd", "tx"], "pdReader": ["hdRunner", "pbRunner", "pcReader", "pdRunner", "xdreader", "dsReader", "dsreader", "pbLoader", "hdReader", "hdreader", "dsLoader", "pcLoader", "pbStream", "hdStream", "ddStream", "pcRead", "xdWriter", "ddLoader", "pdLoader", "pdStream", "ddRunner", "pbReader", "hdWriter", "dsRead", "dsWriter", "xdRead", "pcWriter", "xdReader", "hdRead", "hdLoader", "ddReader", "pdreader", "pdRead"], "out": ["ssl", "base", "temp", "output", "net", "as", "s", "in", "at", "lib", "model", "default", "file", "gen", "conn", "Out", "url", "obj", "with", "external", "point", " in", "outer", "ex", "sys", "lock", "builder", "result", "later", "sync", "part", "cache", "up", "oder", "connection", "w", "parent", "store", "page", "object", "device", "again", "name", "exec", "exp", "array", "full", "over", "list", "order", "inner", "outs", "o", "line", "flow", "co", "write", "password", "session", "doc", "diff", "group", "director", "null", "dev", "io", "writer", "image", "to", "word", "cli", "term", "auto", "her", "copy", "user", "OUT", "child", "manager", "pass", "key", "client", "dot", "login", "inc", "down", "data", "db", "layer", "ext", "err", "code", "img"], "dcmEncParam": ["dcmEnParam", "dcmEstParam", "dcmDecParam", "dcmEnParameter", "dcmSecPart", "dcmDecType", "dcmDecPar", "dcmEncType", "dcmEncParameter", "dcmArchParam", "dcmEncPart", "dcmElParameter", "dcmEnPar", "dcmEnPart", "dcmDecArg", "dcmArchArg", "dcmArchParameter", "dcmSecPar", "dcmEnArg", "dcmDecParameter", "dcmDecPart", "dcmSecType", "dcmElParam", "dcmEstPar", "dcmEncPar", "dcmSecParam", "dcmElPar", "dcmEncArg", "dcmElType", "dcmEnType", "dcmEstType", "dcmEstParameter"], "pdWriter": ["dpWrite", "pdOutput", "ddWrite", "pdWriting", "htWriter", "dpReader", "dsReader", "hdReader", "pdWrite", "htWriting", "dpWriting", "PDWrite", "dpWriter", "hdWriter", "dsOutput", "dsWriter", "hdWrite", "htWrite", "PDWriter", "dsWrite", "ddOutput", "PDReader", "ddReader", "htReader", "PDWriting", "ddWriter", "hdOutput"]}}
{"id1": "7372311", "id2": "3187685", "code1": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"generateDeviceUUID": ["generateDeviceCuid", "generateDeviceCID", "generateDeviceCMD", "generateDeviceSUMD", "generateDeviceSUID", "generateDeviceCUID", "generateDeviceUID", "generateDeviceSUuid", "generatedeviceUID", "generatedeviceUuid", "generatedeviceUMD", "generatedeviceUUID", "generateDeviceSUUID", "generateDeviceUMD", "generateDeviceUuid"], "md5": ["md95", " MD512", "mand2", "md4", "MD95", "mem5", "md55", " md4", "md75", " md3", "md2", " MD3", " MD75", " md95", " md75", "MD5", "mand95", "mem55", "MD3", " md55", "MD512", "MD2", "MD75", "md3", "mand5", "mand3", " md2", "MD4", "MD55", "md512", " MD2", " md512", " MD5", "mem3", "mem4", "mand4"], "hexString": ["pexBuffer", "hexBuffer", " hexFile", "octStr", "hexArray", "hashList", "hexstring", " hexStr", "hexFile", "stringList", " hexBuffer", "stringString", "pexstring", "stringArray", " hexArray", " hexList", "hashFile", "dumpStr", "octBuffer", "formArray", "pexString", "formBuffer", "hexStr", "hashString", "pexArray", "hexList", "stringFile", "octArray", "hashArray", " hexstring", "octString", "formstring", "formString", "dumpArray", "dumpString", "dumpBuffer"], "digest": ["digse", "Digester", "codests", "DigEST", "indexests", "signest", " digested", "feedense", "signests", "sumested", "signested", "mdest", "Digests", "mdested", "indexest", "mdse", "feedested", "digester", "sumse", "digests", "sumest", "digested", "digense", "Digest", " digense", "codester", "codEST", "sumests", "Digense", "indexester", "mdests", "codest", " digEST", " digester", "indexEST", "feedester", " digests", "Digested", "signse", "feedest", "digEST"], "i": ["index", "id", "uri", "pi", "mu", "slice", "c", "j", "end", "ri", "o", "fi", "l", "length", "s", "si", "shift", "ui", "ii", "qi", "at", "ti", "d", "phi", "r", "li", "h", "x", "p", "bi", "u", "oi", "ai", "ci", "I", "m", "t", "e", "io", "zi", "xi", "di", "gi", "k", "v", "b", "count", "multi", "f"], "uuid": ["suids", "euID", "uids", "suID", "euids", "uID", "euid", "uuids", "uuID", "uuuid", "suid", "uid", "euuid", "suuid"], "runTimeEx": ["runContextObj", "runSizeException", "runTimeExc", "RunTimesException", "runTimesObj", " runTimeExcept", "RunTimesObj", " runtimeException", "runTimeException", "RunTimeOut", " runtimeEx", "runtimeExcept", "RunTimesExc", "RunTimesEx", "runTimesEx", "runtimeException", " runTimeException", "runSizeExcept", "runContextException", "runContextExcept", "runTypeException", "runetimeExcept", "RunTimeEx", "runTimeOut", "RunTimeExc", "runTimesExc", "RunTimesExcept", " runtimeExcept", "runetimeException", "runtimeEx", "runTypeExc", "runetimeEx", "runTypeEx", "RunTimeException", "runtimeExc", "RunTimesOut", "runTimesException", "runTimeExcept", "runSizeObj", "runTimesExcept", "runtimeOut", "RunTimeExcept", "runTimesOut", "runTimeObj", "RunTimeObj", "runContextEx", "runSizeEx", "runTypeOut"]}}
{"id1": "13012591", "id2": "16820041", "code1": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "code2": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "label": 1, "substitutes": {"getPasswordHash": ["getHashHash", "getPasswordhash", " getPasswordSum", "getpasswordSecret", "getStringhash", "getpasswordSum", "getHashhash", "getStringSum", "getHashSum", "getStringHash", "getpasswordhash", " getpasswordSecret", " getpasswordSum", "getStringSecret", " getpasswordHash", " getpasswordhash", " getPasswordSecret", "getPasswordSum", " getPasswordhash", "getHashSecret", "getPasswordSecret", "getpasswordHash"], "password": ["string", "path", "address", "buffer", "input", "token", "username", "user", "message", "confirmed", "number", "account", "wd", "pass", "database", "key", "pattern", "content", "security", " passwords", "Password", "email", "source", "cache", "PASS", "sword", "data", "text", "config", "p", "name", "array", "word", "prefix", "secret", "auth", "words", "padding", "attribute", "crypt", "phrase", "code"], "md": ["pkg", "mu", "gd", "mem", "mag", "arm", "bd", "od", "amd", "map", "mo", "ma", "meta", "dr", "MD", "dc", "ms", " MD", "sm", "ad", "ld", "gb", "material", "cm", "mb", "mt", "dh", "d", "mac", "mage", "mp", "hd", "sha", "pm", "pd", "amp", "mm", "metadata", "dig", "m", "hm", "dm", "db", "mand", "mc", "nm", "alg", "mod", "vd", "bm", "mg", "gm", "cmd", "dd"], "hash": ["index", "square", "address", "total", "sum", "mask", "bh", "ashes", "message", "map", "kh", "hex", "Hash", "html", "number", "match", "length", "host", "query", "ash", "key", "handle", "filter", "cache", "mac", "cover", "dot", "sha", "diff", "build", "data", "body", "check", "carry", "h", "search", "row", "dig", "header", "image", "hed", "array", "ha", "url", "sh", "secret", "count", "block", "batch", "error", "code"], "buf": ["buffer", "pkg", "Buffer", "bf", "cf", "bh", "cap", "aux", "ref", "cb", "fp", "abs", "bin", "ff", "pb", " buffer", "uf", "bag", "cv", "rb", "ab", "cas", "sb", "buff", "va", "book", "conv", "data", "tmp", "src", "fb", "h", "bb", "box", "af", "home", "nb", "array", "db", "ctx", "Buff", "bc", "bp", "b", "v", "br", "abi", "pad", "f", "img"], "i": ["index", "id", "uri", "pi", "mu", "c", "j", "end", "ri", "o", "fi", "l", "s", "length", "si", "ui", "ii", "qi", "vi", "ti", "ji", "d", "phi", "r", "chi", "data", "li", "h", "x", "p", "ip", "bi", "u", "uli", "oi", "ai", "e", "I", "ci", "t", "m", "io", "eni", "it", "xi", "di", "gi", "hi", "k", "v", "b", "abi", "multi", "f", "field"]}}
{"id1": "3558512", "id2": "13946197", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "label": 0, "substitutes": {"serialize": ["erialize", "serialze", "serializable", " serialization", "Serialize", "finalify", "finalize", "serialization", " serializable", "finalized", "normalized", "erialze", "normalify", "erialization", "Serialized", "serialify", "erializable", " serialze", "serialized", "normalize", "normalze", "Serialze", "Serialization", "finalze", "Serialify", "Serializable"], "out": ["string", "buffer", "loader", "temp", "i", "ex", "output", "copy", "server", "report", "filename", "OUT", "o", "outs", "pool", "bin", "content", "raw", "client", "source", "cache", "up", "w", "data", "file", "archive", "parent", "page", "gen", "conn", "name", "exec", "Out", "io", "writer", "image", "dump", "a", "err", "obj", "png"], "parser": ["pillar", "base", "class", "pkg", "arser", "loader", "handler", "server", "copy", "builder", "master", "lp", "per", "as", "system", "instance", "php", "manager", "txt", "er", "cp", "reader", "cache", "pp", "up", "seed", "upload", "parent", "file", "rar", "p", "plugin", "test", "writer", "ss", "worker", "tt", "pe", "parse", "processor", "wrapper", "xml", "Parser"], "on_disk": ["onbootdrive", "onJdrive", "onJdisk", "onbootlock", "onjdrive", "onbootstorage", "on_demand", "onjdisk", "on_drive", "off_disk", "onnetfile", "off_drive", "onbootdisk", "on_storage", "onbookdelete", "on_lock", "onJdemand", "off_lock", "on_space", "onnetdemand", "onbookdisk", "off_storage", "onJlock", "on_delete", "onnetdisk", "onnetspace", "off_delete", "onbookdrive", "onjfile", "off_demand", "onnetdrive", "onjspace", "off_file", "on_file", "off_space"], "in": ["IN", "info", "pin", "i", "input", "inas", "copy", "ini", "con", "c", "socket", "inner", "as", "o", "ins", "bin", "pass", "reader", "thin", "source", "connection", "min", "login", "r", "inc", "data", "file", "rin", "conn", "again", "ax", "In", "kin", "stream", "lin", "ac", "inn", "f", "win", "din"]}}
{"id1": "8430178", "id2": "14502142", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyPath", " copyfile", "CopyFile", "copyfile", "transferfile", "transferFiles", "transferPath", " copyFiles", "CopyPath", "Copyfile", "copyPath", "CopyFiles", "copyFiles", "transferFile"], "source_name": ["src_file", "source_type", "Source_file", "sourceNalias", "src_type", "sourceCname", "src_size", "source_data", "source_uri", " source_path", "sourceNtype", "sourceCalias", "source_size", " source_Name", "source_Name", "source_key", " source_key", "src_uri", " source_names", "source_names", "sourceCtype", "sourceCfile", "source_alias", "source_path", "sourceNfile", "src_name", "sourceNname", "Source_data", "src_alias", "Source_name"], "dest_name": ["destFpath", "destappnames", "destFilefile", " destination_name", "destPmodel", "Dest_name", " destinationFpath", "dest_model", "destappmodel", "destPName", " destinationFname", "target_type", "destFname", "destPpath", "Dest_id", "destRname", "dest_path", "dest_named", "dest_none", " dest_none", "destapptype", "dest_id", " destination_path", "dest_resource", "destPtype", " dest_names", "destJName", "dest_info", "destappname", "destFilelabel", " dest_Name", " dest_type", "dest_Name", "destFresource", "Dest_path", "dest_names", "destRName", "destRpath", "source_Name", "target_names", "dest_word", "destRdefinition", "destFilenamed", " destination_info", "destPnames", "dest_type", "destJword", "source_names", "source_path", " dest_word", "destffile", " destinationFresource", "destfname", " dest_definition", " dest_path", "destFilename", "destFinfo", "destPname", " destination_resource", "destfnamed", "target_name", "dest_file", "destPword", " dest_label", "destJnames", "dest_definition", "Dest_Name", "target_model", " destinationFinfo", "destJname", " dest_named", "dest_label", "destflabel", " dest_file"], "source_file": ["src_file", "source_File", " source_class", "src_stream", "source__file", "ource_file", " source_base", "ource_line", "ource_files", " source_url", "source_base", "sourceffile", "ource_name", "sourcefname", "source__class", "source_cache", " source_cache", " source_File", "source__name", "source_class", "src_files", " source_files", "source_files", "sourcefFile", "sourcefurl", "src_name", "source__base", "source_url", "source_line", "source_stream"], "destination_file": ["destation_folder", "destination4path", "destination_base", "destinationablefiles", "destinate_page", "destination2path", "destination_path", "destination_function", "destination2file", "destination2source", "destention4name", "destation_file", "destention_name", "destination_folder", "destinationablepage", "destention_path", "destention4path", "destation_name", "destination2name", "destination4name", "destination4file", "destination_files", "destinate_file", "destention4file", "destention_source", "destention_file", "destation_files", "destinationablebase", "destination_source", "destinationablefile", "destention4source", "destinate_base", "destination4source", "destation_function", "destination_name", "destination_page", "destinate_files"], "source": ["ite", "index", "remote", "class", "core", "input", "server", "resource", "uri", "copy", "output", "Source", "spec", "master", "resources", "site", "slave", "current", "inner", "result", "dest", "slice", "ources", "via", "SOURCE", "client", "reader", "cache", "load", "proxy", "connection", "target", "diff", "scope", "open", "parent", "config", "file", "src", "local", "object", "get", "search", "view", "name", "start", "image", "secure", "stream", "unit", "ize", "reference", "ource", "service", "from", "single", "storage"], "destination": ["Destina", "testribution", "dependination", "coordension", "coordination", "descinated", "targetinator", "identribution", " destribution", "descination", " destining", "testination", "testinated", "dependinator", "constination", "Destension", "destining", "destension", "coordinated", "variinated", "constribution", "validinated", "identination", "targetinated", " destinated", "constinator", "destinated", "variinate", " destinator", "Destribution", "Destination", "Destinated", " destina", "foreigninator", "testinator", "descinator", "Destinator", "destina", "identina", "variinator", "validination", "dependinated", "validinate", "destinate", "destinator", "foreigninate", "destribution", "Destining", "descension", "targetination", "foreigninated", "coordinator", "identinated", "constining", "foreignination", "variination", "targetinate", "validinator", "dependinate"], "buffer": ["temp", "Buffer", "input", "uffer", "timeout", "sequence", "limit", "window", "pool", "memory", "bin", "queue", "iter", "reader", "cache", "binary", "buff", "buf", "channel", "text", "header", "image", "writer", "flush", "padding", "block", "transfer", "batch"], "bytes_read": ["bytesUnRead", "bytes_Read", "bytesUnset", "Bytes_read", "bytesUnfound", "Bytes_set", "bytesUnread", "Bytes_found", "bytes_set", "Bytes_Read", "bytes_found"], "in": ["IN", "val", "path", "ssl", "input", "fe", "n", "serv", "temp", "resource", "id", "ini", "lock", "token", "con", "inner", "as", "current", "l", "s", "ins", "line", "bin", "is", "read", "session", "reader", "doc", "connection", "login", "min", "r", "inc", "data", "file", "out", "h", "request", "p", "log", "get", "rec", "or", "again", "image", "re", "In", "nin", "a", "url", "stream", "b", "container", "inn", "f", "din"], "response": ["reason", "string", "respons", "server", "output", "uri", "resource", "feed", "reset", "res", "report", "message", "description", "json", "sequence", "onse", "version", "result", "answer", "location", "line", "su", "next", "true", "resp", "value", "model", "r", "application", "data", "text", "body", "object", "request", "offer", "reply", "example", "header", "dict", "status", "image", "success", "received", "update", "Response", "respond", "question", "error", "re", "api", "view"], "parentdir": ["parentdirectory", "parentdiff", "rootlib", "Parentdirectory", "hostdir", "parentlib", "homediff", "hostdirectory", "homefile", "homedir", "parentsfile", " parentDir", "parentsDir", "rootdir", " parentlib", " parentdict", "rootdirectory", "Parentdict", "hostdict", " parentdiff", "Parentdir", "rootfile", "parentfile", "parentDir", "parentsdiff", "homeDir", "partdirectory", "partlib", "parentdict", "parentsdir", "partdir", " parentfile", " parentdirectory", "partfile"]}}
{"id1": "3024970", "id2": "16825994", "code1": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"testCopy_inputStreamToOutputStream": ["testCopy_inputStreamToInputArray", "testCopy_inputStreamToOutputstream", "testCopy_inputStreamToInputFile", "testCopy_inputStreamAndOutputstream", "testCopy_inputStreamToOutArray", "testCopy_inputStreamToOutStream", "testCopy_inputStreamAndInputArray", "testCopy_inputStreamToInputstream", "testCopy_inputStreamAndOutputFile", "testCopy_inputStreamAndOutputArray", "testCopy_inputStreamAndInputFile", "testCopy_inputStreamAndInputStream", "testCopy_inputStreamToOutFile", "testCopy_inputStreamAndOutputStream", "testCopy_inputStreamToOutputFile", "testCopy_inputStreamToOutstream", "testCopy_inputStreamToInputStream", "testCopy_inputStreamAndInputstream", "testCopy_inputStreamToOutputArray"], "in": ["IN", "index", "pin", "ssl", "i", "input", "id", "n", "ex", "token", "ini", "gin", "con", "c", "inner", "as", "ins", "s", "arin", "bin", "query", "is", "read", "pass", "reader", "source", "up", "proxy", "login", "connection", "min", "inside", "r", "inc", "data", "rin", "file", "init", "conn", "again", "image", "isin", "it", "In", "nin", "a", "url", "update", "include", "err", "cin", "inn", "win", "this", "din"], "baout": ["Baout", "paagain", "paOut", " baOUT", "pain", " baart", "baagain", "aaoff", "BaOut", "aain", "paout", "caOUT", "BAin", "baoff", "cain", "aaOut", "BAOUT", "BAOut", "caout", " bain", "baOut", "baart", "paOUT", "BaOUT", "paart", "bain", "caagain", "caOut", "caoff", "BAoff", "Bain", "aaout", "BAart", "BAagain", "baOUT", "BAout"], "out": ["IN", "base", "buffer", "inas", "ou", "ex", "n", "output", "copy", "lock", "OUT", "outs", "o", "pool", "line", "client", "part", "at", "cache", "up", "default", "inc", "parent", "data", "file", "object", "log", "conn", "again", "exec", "Out", "image", "io", "exp", "to", "array", "In", "ext", "b", "obj", "with"], "count": ["info", "base", "max", "head", "ref", "limit", "pool", "code", "weight", "type", "cache", "load", "cond", "counter", "work", "parent", "file", "Count", "check", "start", "name", "call", "process", "found", "error", "from"]}}
{"id1": "807346", "id2": "20851065", "code1": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "code2": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"runScript": ["execCode", "RunCode", " runscript", "execscript", "runscript", "RunScript", "execJS", "execScript", " runJS", "RunJS", "runJS", "runCode", " runCode", "Runscript"], "scriptName": ["scriptNames", " scriptFile", "fileUrl", " scriptPath", "codename", "Scriptname", "scriptUrl", "scriptPath", "filePath", "codePath", "fileName", " scriptNames", "scriptname", " scriptUrl", "codeName", "ScriptName", " scriptname", "ScriptPath", "ScriptFile", "codeNames", "ScriptNames", "ScriptUrl", "scriptFile", "fileFile"], "data": ["index", "string", "info", "base", "buffer", "input", "i", "output", "response", "feed", "results", "message", "json", "result", "number", "html", "api", "write", "layout", "key", "alpha", "content", "split", "raw", "next", "part", "type", "source", "no", "one", "value", "media", "str", "DATA", "div", "batch", "text", "body", "out", "empty", "append", "complete", "format", "start", "name", "template", "action", "ata", "function", "a", "partial", "missing", "script", "dat", "error", "this", "code", "valid"], "url": ["impl", "zip", "path", "base", "buffer", "ssl", "i", "server", "uri", "resource", "id", "feed", "user", "http", "l", "host", "URL", "source", "up", "browser", "connection", "open", "file", "web", "page", "bb", "ll", "log", "bel", "ls", "ball", "image", "sl", "rl", "Url", "www", "stream", "b", "f", "service"], "in": ["IN", "ssl", "buffer", "i", "input", "id", "resource", "serv", "ini", "gin", "socket", "as", "inner", "ins", "s", "bin", "pass", "is", "client", "cms", "reader", "source", "login", "r", "inc", "file", "out", "conn", "In", "fd", "a", "stream", "b", "err", "ac", "with", "inn", "f", "win", "din"], "buffIn": ["BuffIn", "buffIns", "bufIn", "buffOut", "buffedIn", "bufin", "bufIns", "bbIns", "ufIn", "bufferin", "BuffedIn", "bbIn", "bufferIn", "bufOut", "bufferIns", "ufIns", "bbOut", "bufferedIn", "ufin", "BuffIns", "bbin", "BuffOut", "Buffin", "ufedIn", "buffin"], "temp": ["index", "zip", "total", "base", "buffer", "tc", "input", "num", "i", "output", "enc", "c", "current", "tem", "number", "dest", "length", "Temp", "flow", "read", "extra", "char", "iter", "offset", "content", "raw", "type", "source", "cut", "len", " Temp", "div", "tmp", "fake", "empty", "size", "ptr", "test", "cel", "start", "stable", "pointer", "unit", "partial", "wait", "count", "f", "pt", "emp"]}}
{"id1": "7981642", "id2": "14567939", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "label": 1, "substitutes": {"update": ["push", "address", "sum", "replace", "setup", "copy", "user", "UPDATE", "add", "register", "end", "set", "write", "save", "updated", "key", "password", "post", "up", "login", "build", "config", "data", "text", "check", "Update", "append", "put", "h", "u", "delete", "init", "insert", "edit", "change", "exec", "send", "apply", "url", "create", "auth", "sign", "and"], "mail": ["zip", "string", "address", "server", "uri", "id", "username", "user", "lock", "message", "ge", "html", "host", "Email", "company", "password", "gmail", "source", "Mail", "dir", "proxy", "date", "login", "dial", "model", "old", "alt", "group", "md", "value", "gal", "text", "file", "phone", "local", "ip", "msg", "hello", "name", "folder", "m", "who", "label", "mails", "url", "fax", "ul", "contact", "xml", "office", "view", "front"], "email": ["zip", "info", "address", "class", "online", "server", "uri", "n", "username", "note", "id", "message", "ail", "description", "host", "inet", "line", "el", "wd", "Email", "en", "password", "gmail", "cdn", "Mail", "dir", "login", "old", "model", "alt", "md", "text", "file", "archive", "li", "phone", "ip", "log", "hello", "eu", "name", "folder", "addr", "dn", "home", "nick", "mails", "url", "fax", "cn", "xml", "office", "element", "enter"], "pwd": ["Pwd", "hwd", "pWD", "hwa", " ppass", "Pwt", "cpWD", "pwt", "ppass", " pwh", "pwa", "pppass", "cpwt", "PWD", "Ppass", "Pwh", "Pws", "pws", " pWD", " ppassword", " pwa", "pppassword", "hWD", "Pwa", "ppwh", " pws", "pwh", "ppassword", "Ppassword", "cpwd", "hpass", "cpws", "ppwd", " pwt"], "firstname": ["lastnames", "lastName", "firstemail", "casename", " firstName", "newname", " firstpass", " firstemail", "firstuser", "hostname", "firstkey", "lastpass", "casepass", "lastkey", " firstuser", "hostName", "hostkey", "caseemail", "lastuser", "hostemail", "newnames", " firstkey", " firstnames", "newuser", "firstnames", "caseName", "lastemail", "firstName", "firstpass"], "lastname": [" lastaddress", "lastnames", "firstn", "lastName", "firstday", " lastnames", " lastday", "firstaddress", "lastday", "secondname", "secondkey", "fullnames", "firstkey", "fullName", "lastaddress", "secondName", "fullname", "lastkey", " lastName", "lastn", " lastn", "fullday", " lastkey", "firstnames", "secondaddress", "firstName", "fulln"], "connection": ["directory", "Connection", "index", "handler", "cc", "sc", "Conn", "server", "response", "cf", "document", "con", "c", "connected", "communication", "system", "pool", "relation", "management", "manager", "database", "condition", "nc", "client", "session", "lc", "ion", "application", "config", "ca", "h", "object", "context", "conn", "creator", "m", "graph", "function", "db", "di", "bc", "b", "connect", "this", " Connection"], "attrs": ["addras", "atars", " attRs", "atras", "matars", "AttRs", "attps", " attars", "atr", "Attacts", "attks", "Attrs", "matps", "atrs", "addRs", "atks", "atps", "atRS", "addRS", "matrs", "Attars", " attks", "atributes", "attr", "addps", "attras", "Attras", " attributes", "attributes", "addributes", "attRs", "attacts", "atacts", "attRS", "addars", "addr", "addrs", " attacts", " attps", "Attps", "Attr", " attRS", " attr", "addks", "matributes", "Attributes", "attars"], "sha": ["shi", "base", "sum", "pi", "HA", "ma", "volume", "ya", "meta", "si", " SHA", "sm", "alpha", "password", "la", "ua", "sa", "mac", "ema", "va", "ami", "md", "eta", "acl", "ca", "alias", "mm", "h", "lambda", "asha", "ha", "na", "hi", "a", "sh", "pa", "ka", "da", "SHA", "ga", "wa", "pg", "sche"], "digest": ["Digester", "moded", "DigEST", " diggest", "digcode", "mdgest", " digested", "modest", "Diged", "mdest", "Digests", "diggest", "mdested", "Diggest", "digester", "digests", "digested", "mdester", "tagester", "Digest", "tagested", "modests", "diged", "Digcode", "tagcode", " digEST", " digester", " digests", "tagest", "Digested", "modEST", " diged", "digEST", " digcode"], "hash": ["base", "sum", "her", "user", "enc", "bh", "message", "version", "json", "kh", "hex", "Hash", "html", "match", "bin", "ash", "key", "password", "raw", "mac", "rh", "cover", "value", "build", "body", "h", "ag", "dig", "image", "ha", "hed", "array", "url", "sh", "secret", "auth", "block", "code"], "ctx": ["anc", "cu", "pkg", "cc", "tc", "qa", "cmp", "sc", "cf", "rc", "ck", "c", " rc", " c", "ctrl", "cb", "fw", " conn", "client", "cv", "vc", "cp", "cm", "cas", "lc", " context", "ct", "Context", "conv", "config", "ca", "xc", "cl", "context", "sq", "conn", "ci", "cr", "jp", "pc", "mc", "bc", " cs", "cci", "cn", " cx", "cs", "hw", "cca", "tx", "loc"], "newName": ["newAddress", "NewEmail", "Newname", "oldAddress", "newEmail", "newname", "NewAddress", " newEmail", " newAddress", "oldEmail", "NewName", "oldname", " newname"], "oldName": ["OldPath", "oldHome", "OldEmail", "OldAddress", "newAddress", "origEmail", "origPath", "oldEmail", "oldname", " oldHome", " oldAddress", "origName", " oldEmail", "newEmail", "OldHome", "newHome", "oldAddress", "oldPath", "origname", " oldname", "Oldname", " oldPath", "OldName"]}}
{"id1": "255765", "id2": "3184073", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"f": ["path", "fun", "fe", "sf", "n", "fs", "feed", "cf", "df", "fa", "lf", "bf", "rf", "filename", "c", "ref", "j", "fc", "fp", "fi", "l", "s", "fn", "fr", "ff", "form", "fold", "d", "r", "g", "w", "file", "flat", "h", "x", "p", "name", "folder", "e", "m", "io", "t", "fo", "fm", "function", "F", "fd", "self", "a", "fen", "of", "v", "b", "tf", "inf", "this", "fx"], "in": ["IN", "pin", "ssl", "fa", "token", "ini", "ic", "ins", "bin", "thin", "vin", "get", "gen", "it", "a", "with", "din", "ex", "serv", "lock", "part", "source", "up", "connection", "min", "r", "str", "g", "w", "rin", "again", "exec", "isin", "In", "lin", "b", "v", "inn", "win", "n", "gin", "con", "inner", "socket", "session", "reader", "d", "diff", "p", "init", "or", "m", "image", "nin", "ac", "cin", "fe", "input", "c", "l", "pass", "is", "login", "inc", "config", "data", "rec", "t", "err"], "cbuf": ["cbux", "dbuf", "zbuff", "bbuff", "fbbuf", "cfbuf", "rbuff", "bbull", "cbul", "bcul", "CBuc", "bcuc", "bcull", "CBuf", "CBuff", "zbuu", "cfuf", "fbuc", "bcurs", "dbuc", "rbuc", "cbutf", "rbuu", "cbbuf", "cburs", "CBul", "bault", "bux", "buff", "ebuu", "buf", "cfuc", "rbutf", "rbbuf", "rbull", "bcuf", "bcuff", "bcault", "ebuf", "fbuff", "rbux", "zbuf", "bcur", "ebutf", "cbuff", "rbuf", "rburs", "rbul", "cbull", "cbuc", "bbuf", "cbuu", "cfuff", "fbuf", "zbutf", "dbuff", "ebuff", "bburs", "bcux", "dbur", "cfur", "rbault", "cbur", "cbault"], "read": ["index", "Read", "each", "hex", "run", "ride", "en", "raw", "only", "q", "build", "open", "used", "get", "lex", "it", "readable", "ed", "print", "know", "buffer", "num", "id", "feed", "rc", "add", "report", "oct", "ack", "ind", "end", "find", "sync", "use", "load", "r", "g", "work", "w", "level", "un", " READ", "fill", "name", "bit", "ing", "full", "skip", "connect", " reading", "val", "play", "close", "reading", "ok", "socket", "se", "length", "write", "record", "iter", "sleep", "loop", "er", "allow", "reader", "d", "old", " Read", "bind", "insert", "start", "change", "io", "update", "create", "y", "wait", "repeat", " write", "ink", "error", "view", "valid", "ak", "input", "child", "draw", "reads", "pass", "key", "last", "select", "type", "want", "seek", "inc", "data", "text", "config", "check", "x", "size", "log", "put", "cel", "send", "call", "pe", "k", "parse", "stream", "ize", "count", "READ", "re", "orig"], "totRead": ["octotoLength", "tottedWrite", "TotGet", "tcotClose", "tcotRead", "dottLoad", "octotWrite", " totalBuild", "tottedGet", "tntReader", "tottUse", "octotoRead", "totLink", "totBuild", "towLength", "dottReader", "totoLength", "tazonClose", "tetReading", "toyDraw", "totClose", "totiBuild", " totWrite", "notLoad", "notWrite", "intottBuild", "tottLength", "tottAccept", "totalLoad", "towLoad", "totalLink", " totalWrite", "nottAccept", "towWrite", "nottRead", "totoSearch", "tochRead", "intotLoad", "tottReading", "tottWrite", "toyWrite", "tollRead", "tottedRead", "tottLoad", "octotLength", "TotConnect", "ntotWrite", "tetRead", "TotLoad", "totoUse", "tntRead", "dottUse", "octotReading", "TottConnect", "ntottLoad", "TotSearch", "TotaRead", "totoLoad", "tntLoad", "TotaLoad", "tottClose", "totDraw", "totLength", "towAccept", "TottReading", "tobyRead", "intotClose", "towReading", "totingSearch", "totaDraw", "totoWrite", "TotDraw", "nottLoad", "toyRead", "tcotBuild", "totReading", "totConnect", "octotRead", "ntottWrite", "totalAccept", "totalRead", "totLoad", "tazonBuild", "totalBuild", "tntWrite", "totoRead", "dotRead", "ntotRead", "totingWrite", "ntotLoad", "totReader", "notAccept", "totaRead", " totBuild", "tottSearch", "ntottReader", "notRead", "totingRead", "totWrite", "tazonLoad", "totingGet", "dotLoad", "dotReader", "dotUse", "dottFind", "tobyFind", "TotaWrite", "tochLoad", "tottedFollow", "ntotReader", "intotRead", "intottLoad", "totUse", "totaReading", "totaLoad", "totaWrite", "tcotLoad", "TottReader", "tottReader", "totiRead", "tatRead", "totiWrite", "dottWrite", "toyLoad", "TottFollow", "tottFollow", "tatLoad", "totingConnect", "dotFind", "tochReader", "tottConnect", "dottReading", "intotBuild", "TotReader", "totoFind", "tollLoad", "tochWrite", "tobyUse", "tottDraw", "dottRead", "totaLink", "tobyLoad", "totoConnect", " totalRead", "totingFollow", "TottLoad", "TottWrite", "TotaDraw", "tottRead", "tetWrite", "totFind", "nottWrite", "towRead", "TotReading", "totalWrite", "octotoReading", "tollReading", "tatReader", "tollWrite", "dotReading", "tottFind", "ntottRead", "intottRead", "totiLink", "totFollow", "tetLoad", " totalLink", "tazonRead", "totSearch", "TotFollow", "totGet", "octotoWrite", "TottRead", "TotRead", "totaBuild", "TottGet", " totLink", "intottClose", "totoReading", "tottGet", "TottSearch", "totaReader", "dotWrite", "totAccept", "tottBuild", "tatWrite", "TotWrite"], "out": ["ex", "output", "n", "plus", "outer", "net", "c", "OUT", "socket", "o", "outs", "l", "fn", "s", "off", "bin", "client", "sync", "part", "d", "up", "connection", "r", "g", "w", "inc", "parent", "file", "h", "x", "p", "conn", "init", "again", "exec", "Out", "io", "t", "exp", "writer", "In", "a", "ext", "conf", "v", "b", "err", "obj", "ac"], "i": ["index", "ini", "ic", "ii", "q", "chi", "ci", "I", "eni", "zi", "it", "hi", "iu", "multi", "info", "buffer", "id", "ind", "z", "ui", "ori", "ti", "source", "r", "g", "ip", "mi", "ai", "name", "oi", "e", "b", "v", "ik", "uri", "ei", "yi", "slice", "o", "length", "qi", "one", "ji", "d", "phi", "h", "p", "bi", "u", "init", "start", "m", "io", "di", "y", "ni", "api", "ix", "input", "pi", "ie", "c", "current", "j", "fi", "ri", "l", "si", "is", "key", "my", "data", "li", "x", "xi", "gi", "k", "me", "abi"]}}
{"id1": "15241397", "id2": "22320592", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    private static void loadDefaultPreferences() {\n        try {\n            URL url = ClassLoader.getSystemResource(\"OpenDarkRoom.defaults.properties\");\n            preferences.load(url.openStream());\n        } catch (FileNotFoundException e) {\n            log.error(\"Default preferences file not found\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"doGet": ["handlePut", "didGet", "didGET", "didPut", "didget", "doget", " doPut", "doGET", "handleGET", "doPut", "handleget", " doget", "handleGet", " doGET"], "request": ["event", "info", "buffer", "input", "Request", "server", "resource", "uri", "user", "report", "http", "subject", "message", "document", "result", "instance", "query", "queue", "req", "client", "er", "type", "reader", "connection", "application", "data", "web", "object", "context", "complete", "QUEST", "image", "received", "url", "xml", "method", "initial"], "response": ["server", "output", "resource", "report", "results", "site", "message", "document", "json", "version", "onse", "result", "host", "pool", "queue", "next", "client", "session", "resp", "connection", "model", "other", "application", "collection", "wave", "parent", "data", "out", "body", "page", "object", "reply", "status", "image", "writer", "function", "generation", "full", "Response", "respond", "error", "esi", "view"], "rewrittenQueryString": ["rewrittenQuestionStr", "rewwrittenQueryService", "rewrittenQueryArray", "rewrittenRequestList", "rewrittenQueryText", "rewrittenRequestText", "rewrittenUrlText", "rewwrittenRequestStr", "rewrittenPageList", "rewrittenQuestionText", "rewrittenQuestionLine", "rewwrittenRequestText", "rewrittenRequestLine", "rewwrittenQueryArray", "rewrittenqueryLine", "rewrittenQueryLine", "rewrittenPageString", "rewrittenUrlString", "rewwrittenRequestArray", "rewwrittenQueryList", "rewrittenQueryList", "rewwrittenQueryLine", "rewrittenQuestionArray", "rewrittenqueryText", "rewwrittenRequestService", "rewrittenRequestStr", "rewrittenqueryString", "rewwrittenRequestList", "rewrittenQueryStr", "rewrittenUrlLine", "rewrittenRequestString", "rewrittenQuestionString", "rewrittenPageLine", "rewrittenQueryService", "rewrittenPageArray", "rewwrittenRequestLine", "rewwrittenQueryText", "rewrittenqueryService", "rewwrittenQueryStr", "rewwrittenRequestString", "rewrittenRequestArray", "rewrittenQuestionList", "rewrittenRequestService", "rewrittenUrlService", "rewwrittenQueryString", "rewrittenqueryStr"], "rewrittenUrl": ["rewilledJar", "rewmatchedFile", "rewodedURL", "rewedUrl", "rewwrittenurl", "rewwrittenURL", "rewatchedText", "rewardedLocation", "rewmatchedUrl", "rewilledUrl", "rewatchedURL", "rewardedUrl", "rerittenURL", "rewodedLanguage", "RewrittenInt", "rewwrittenUrl", "rewardedInt", "rewwrittenJar", "rewriteURL", "RewwrittenURL", "rewwrittenServer", "rewrittenUr", "rewrapedURL", "rewedUr", "rewodedFile", "RewrittenUr", "rewrittenURL", "Rewrittenurl", "rewcraftedURL", "RewwrittenInt", "rewardedLanguage", "rerittenUr", "RewwrittenLocation", "rewilledInt", "rewrittenLocation", "rerittenFile", "rewatchedServer", "rewwrittenLocation", "rewriteUrl", "RewrittenServer", "Rewwrittenurl", "rerittenUrl", "rewwrittenInt", "rewrapedUrl", "rewrittenLanguage", "RewrittenJar", "RewwrittenFile", "rewardedJar", "rewardedURL", "rewwrittenLanguage", "rewcraftedUrl", "rewriteText", "rewodedUrl", "rewmatchedURL", "rewriteServer", "rewrittenServer", "rewrittenInt", "rewedFile", "rewrittenFile", "rewwrittenText", "rewilledURL", "rewedURL", "RewwrittenText", "RewrittenFile", "RewrittenLocation", "rewrittenurl", "rewrapedUr", "RewwrittenUrl", "rewrapedFile", "RewrittenURL", "rewwrittenUr", "rerittenLanguage", "rewardedUr", "RewwrittenJar", "rewrittenText", "RewwrittenUr", "rewcraftedLocation", "RewrittenText", "rewcraftedUr", "rewatchedUrl", "rewwrittenFile", "rewrittenJar", "rewmatchedurl", "RewrittenUrl", "rewedurl", "RewwrittenServer", "rewardedFile"], "httpURLConnection": [" httpURLConn", "webURLClient", "apacheGEconnection", " httpURConn", "httpURConnect", "httpSSLConnection", "httpUrlConnect", "webURLContext", "httpUrlCode", "HttpChannelConnection", " httpURConnection", "httpURLClient", "apacheURLConnect", "apacheURLFlow", "httpSSLConn", "httpChannelConnection", "httpURIConnection", "httpurlConnect", "httpURIConnect", " httpURLSession", "webURLConnection", "httpUrlConn", "httpURLService", "HttpChannelService", "httpELConnection", " httpUrlConn", " httpURLconnection", "httpStreamCurrent", "httpUrlconnection", "apacheGEConnect", "apacheGEFlow", "apacheURLConnection", "httpELConnect", "httpurlconnection", "httpURLConn", "httpUrlConnection", "httpurlFlow", "httpGEFlow", "httpURLContext", "httpURLFlow", "httpPathSession", " httpStreamconnection", "httpPathConnection", "webSSLConn", "HttpURLConnect", "httpURLCode", "httpStreamConnection", "httpStreamSession", "webSSLClient", " httpURLCurrent", "httpURLConnect", "webURLConn", "httpPathCurrent", "httpSSLContext", " httpStreamSession", "httpurlSession", "httpURService", "httpURConnection", "httpURLCurrent", "httpurlConnection", "httpurlConn", "httpCLConn", "apacheGEConnection", "httpELConn", " httpURConnect", "httpWebConnection", "httpURLconnection", "webSSLContext", "httpUrlService", "HttpChannelconnection", "httpStreamconnection", "HttpURLService", "httpGEConnect", "httpURIFlow", "httpurlCurrent", " httpStreamCurrent", "httpCLConnection", " httpUrlCode", "httpUrlClient", "httpURLSession", "httpURIContext", "webSSLConnection", "httpWebConnect", "httpCLCode", "httpURIClient", "httpurlCode", "apacheURLconnection", "httpURConn", "httpURconnection", "HttpChannelConnect", "httpURIConn", "httpURIconnection", "httpGEConnection", " httpUrlConnection", "httpPathconnection", " httpURLConnect", "HttpURLConnection", "HttpURLconnection", "httpSSLClient", "httpUrlContext", " httpStreamConnection", "httpGEconnection", " httpURLCode", "httpChannelService", "httpChannelConnect", "httpWebConn", "httpChannelconnection"], "header": ["event", "string", "head", "info", "handler", "buffer", "her", "index", "server", "headers", "token", "list", "outer", "entry", "master", "message", "version", "bridge", "character", "document", "author", "result", "driver", "match", "ter", "line", "dr", "key", "iter", "queue", "next", "er", "filter", "part", "back", "rule", "after", "player", "cover", "member", "date", "item", "component", "group", "feature", "section", "default", "data", "channel", "director", "metadata", "Header", "hash", "writer", "function", "second", "layer", "comment", "pair", "consumer", "reference", "block", "attribute", "error", "field", "definition", "column"], "value": ["val", "string", "info", "letter", "server", "entry", "now", "option", "message", "version", "description", "current", "json", "end", "document", "child", "set", "key", "content", "password", "expression", "Value", "type", "item", "media", "model", "default", "sv", "parent", "data", "text", "VALUE", "variable", "object", "get", "language", "format", "hello", "name", "function", "label", "gi", "values", "V", "comment", "v", "attribute", "office", "field", "element", "property", "valid"], "inputStream": ["inputChannel", "inputStreamer", "resourceStream", "InputStreamer", "outputSteam", "inputSteam", "pullSteam", "pullStream", "outputstream", "outputStreamer", "resourcestream", "outputChannel", "pullstream", "InputChannel", "pullStreamer", "resourceChannel", "resourceSteam", "Inputstream", "inputstream", "InputSteam", "InputStream"], "outputStream": ["inputStreamer", "externalSteam", "responseStream", "OutputChannel", "outputSteam", "inputSteam", "externalstream", "OutputStreamer", "responseSteam", "Outputstream", "responseChannel", "OutputSteam", "outputstream", "outputStreamer", "externalStream", "externalStreamer", "OutputStream", " outputChannel", " outputFile", "outputChannel", "responseFile", " outputSteam", "outputFile", "inputstream", "OutputFile"]}}
{"id1": "20751378", "id2": "18696387", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 0, "substitutes": {"hashPassword": ["signPassword", "cryptPass", "signpassword", "signWord", "hashPass", "cryptWord", "cryptpassword", "signPass", "cryptPassword", "hashWord", " hashPass", "hashpassword", " hashWord", " hashpassword"], "password": [" Password", "string", "path", "address", "input", "token", "username", "user", "message", "plain", "python", "description", "number", "wd", "pass", "database", "key", "pattern", "content", "security", " passwords", "Password", "cache", "PASS", "mac", "seed", "sha", "w", "sword", "data", "text", "p", "encrypted", "name", "word", "prefix", "secret", "auth", "command", "words", "padding", "pad", "crypt", "phrase", "code"], "hash": ["index", "root", "square", "base", "hex", "number", "match", "host", "tag", "ash", "mac", "rh", "build", "math", "dig", "format", "style", "msg", "url", "string", "address", "id", "oh", "proof", "result", "html", "security", "cache", "value", "work", "search", "addr", "hed", "array", "secret", "handle", "phrase", "pkg", "replace", "gh", "ashes", "message", "json", "length", "memory", "sha", "alt", "h", "update", "uild", "height", "error", "sum", "her", "ssh", "copy", "user", "version", "kh", "Hash", "pool", "key", "text", "ruby", "check", "put", "log", "ha", "call", "dump", "sh", "auth", "history", "bolt", "mod", "code"], "md": ["gd", "mag", "bd", "od", "df", "Cmd", "amd", "kg", "ma", "am", "meta", "wd", "MD", "ME", " MD", "ms", "sm", "gb", "mb", "mt", "dh", "d", "mac", "xd", "sha", "hd", "pm", "pd", "sd", "mm", "nd", "metadata", "dig", "m", "km", "hm", "dm", "grad", "mand", "mc", "der", "nm", "mod", "vd", "mg", "mad", "f", "cmd", "dd"]}}
{"id1": "14688886", "id2": "6009527", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"populateResources": ["compulateResources", "compulateRelations", "populateRelations", "compulateFiles", "populateFiles", "popureResource", "popureResources", "popractResource", "popractFiles", "populateResource", "compureFiles", "poputeResource", "popractRelations", "popureFiles", "poputeRelations", "compureRelations", "popractResources", "compureResource", "poputeResources", "popureRelations", "poputeFiles", "compulateResource", "compureResources"], "templates": ["Templ", "typl", "tompl", "tempplates", "temppl", "templ", " temures", "temps", "filures", "Templates", "prompl", "tometers", "Temps", "typs", "stemps", " templ", "stemples", "Temens", "stemplates", "promplate", "tempps", "templateps", "tempplate", "Temples", "Temeters", "typlate", "promplates", "filens", "temeters", "filpl", "filplates", "tomplates", "template", "templateplates", "templatepl", "typlates", " temens", "temples", "prometers", "temens", "Temures", "tomplate", "temures", "stempl", "templateples", "Template"], "url": ["string", "path", "base", "ssl", "address", "job", "buffer", "server", "resource", "uri", "feed", "entry", "http", "filename", "html", "l", "il", "location", "URL", "host", "pl", "el", "pattern", "fl", "email", "source", "connection", "r", "ob", "config", "data", "file", "channel", "route", "page", "object", "href", "template", "name", " URL", "e", "image", "link", "sl", "Url", "xml", "f", "service", "download"], "fileName": ["FILEName", "FILELocation", "FileDir", " fileLocation", "fileInfo", "fileType", "fileKey", "resourcename", " filePath", "objectName", "FileInfo", "fileDirectory", " fileSystem", "resourcePart", "resourcePath", "objectSync", "FILETime", "fName", "resourceName", "modelSystem", "fileLength", "folderPath", " fileDirectory", " fileType", " filename", " fileInfo", "fileSync", "modelName", " fileDir", "sourcename", "stringType", " fileLength", "folderPart", "FILESync", "FileString", "filenameFull", "sourceName", "folderName", "objectname", "filenameString", "filenamename", "FileDirectory", "filenameLength", "sourceLength", "fileSystem", "foldername", "fDir", "stringName", "filenameName", "modelLocation", "sourceInfo", "FILEname", " fileKey", "fKey", "FILESystem", "objectTime", "filename", "filePart", "modelname", "filePath", "FileFull", " filePart", " fileString", "fileFull", " fileTime", "Filename", "stringDirectory", "fname", "FileType", "FileKey", "filenameType", " fileFull", "fileString", "fileLocation", "fileTime", "FileName", "fileDir", "sourceString", " fileSync"], "templateResource": [" templateType", "templateRing", "plateRing", "layoutResource", "plateContainer", "templateReader", "xmlType", "templateContainer", "plateContent", "templateType", "eventReader", "xmlRole", "eventUrl", "translationContent", "eventresource", "templateRole", "layoutRing", "privateUrl", "layoutContent", "templateresource", "templateContent", "tempRole", " templateRole", "templateUrl", "privateresource", "privateResource", "copyResource", "copyReader", "translationRing", "eventResource", "xmlFile", "tempFile", "translationResource", "copyUrl", "templateFile", "tempResource", "translationContainer", "copyresource", "plateResource", "layoutContainer", "xmlResource", "tempType", "privateReader", " templateFile"], "is": ["bis", "iss", "lis", "uri", "serv", "IS", "isa", "Is", "as", "ri", "api", "irc", "s", "abs", "in", "ori", "isl", "cms", "its", "ais", "r", "isc", "ir", "out", "src", "nis", "ip", "has", "ris", "rss", "io", "it", "iris", "ios", "ib", "app", "isi", "os", "was", "ar", "im", "iso"], "strBuff": [" strTab", " strbuff", "arrBuff", "stringFlow", "rbuff", "brBuff", "arrBuffer", " strPref", " strText", "strbuff", "arrPref", "rBuff", "strGrab", "brBuffer", "StrBuffer", "rBuffer", "StrTab", "brGrab", "StrBuff", "stringBuff", "StrText", "strBuffer", "strPref", "stringGrab", "StrPref", "stringBuffer", "strText", "strTab", " strBuffer", "strFlow", " strGrab", "arrTab", "Strbuff", "brFlow", " strFlow", "rText"], "br": ["nr", "res", "result", "cb", "fr", "dr", "orb", "mr", "ori", "bro", "arr", "er", "BR", "bar", "rb", "reader", "ctr", "browser", "buf", "sr", "r", "Br", "div", "data", "text", " reader", "gr", "brush", "io", "yr", "cr", "tr", "bc", "stream", "hr", "b", "sp", "bl", "err", "ber", "Reader"], "str": ["string", "cur", "spec", "wr", "sc", "enc", "oct", "line", "fr", "dr", "char", "key", "iter", "arr", "er", "Str", "type", "pr", "lc", "r", "div", "STR", "data", "text", "cl", "p", "star", "style", "or", "name", "coll", "t", "cr", "sl", "tr", "hr", "err", "sp", "kr", "st", "strike", "f", "stri", "sr", "sec"], "images": ["services", "ages", "quarters", "lights", "opens", "pages", "resources", "pieces", "features", "assets", "Images", "bands", "styles", "letters", "ins", "versions", "apps", "people", "picture", "games", "ims", "users", "flows", "boxes", "media", "tags", "inches", "ups", "classes", "xs", "models", "scripts", "plugins", "objects", "ips", "groups", "sites", "stars", "frames", "thumbnails", "image", "videos", "icons", "types", "tests", "holes", "jobs", "rooms", "gallery", "agents", "files", "dates", "photos", "ions", "png", "gif", "words", "events", "views", "shows"], "i": ["index", "mu", "ini", "http", "s", "ii", "in", "chi", "format", "ci", "I", "eni", "it", "hi", "xml", "iu", "multi", "info", "id", "add", "ind", "z", "html", "ui", "ti", "lc", "ip", "mi", "ai", "e", "_", "b", "v", "uri", "ij", "n", "yi", "slice", "qi", "ji", "d", "phi", "diff", "p", "bi", "u", "image", "io", "di", "Url", "app", "y", "ni", "cli", "pi", "ie", "j", "fi", "si", "key", "config", "li", "x", "uni", "xi", "gi", "gu", "f", "this"], "img": ["aut", "info", "att", "input", "gd", "norm", "fig", "map", "ie", "cb", "iframe", "fw", "ff", "inst", "bg", "arr", "icon", "lib", "ch", "aff", "config", "data", "file", "src", "tmp", "li", "fb", "small", "p", "tif", "m", "image", "exp", "ani", "gallery", "sl", "app", "ext", "abc", "hr", "v", "bl", "png", "gif", "ng", "imp", "f", "im", "jpg"], "imgProperty": ["cachePro", "bgImage", "imgImage", " imgPro", "cacheImage", "bgPro", " imgImage", "cacheProperty", "bgProp", "bgProperty", "cacheProp", "imgProp", "imgPro", " imgProp"]}}
{"id1": "4481712", "id2": "1371265", "code1": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "code2": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "label": 1, "substitutes": {"deleteObject": ["saveItem", "deleteItem", "saveObject", "saveDB", " deleteObj", "removeObject", "deleteDB", " deleteItem", " deleteDB", "removeDB", "removeItem", "removeObj", "deleteObj", "saveObj"], "id": ["string", "path", "info", "root", "i", "uri", "resource", "lock", "uid", "sid", "query", "ident", "database", "in", "ids", "key", "type", "source", "rid", "model", "parent", "data", "object", "oid", "ip", "delete", "name", "it", "pid", "sql", "url", "ID", "create", "f", "error", "Id", "api"], "conn": ["Connection", "nw", "ssl", "core", "ou", "Conn", "cc", "server", "n", "serv", "cmp", "cf", "rc", "enc", "lock", "con", "c", "act", "cb", "col", "host", "pool", "co", "rt", "dc", "nc", "ec", "client", "cms", "nt", "cm", "cp", "sync", "cache", "lc", "cond", "ct", "connection", "ch", "cat", "config", "cmd", "ca", "parent", "h", "log", "ai", "po", "coll", "ci", "exec", "cr", "ann", "db", "pc", "mc", "ctx", "sql", "comm", "auth", "conf", "err", "connect", "cn", "ac", "orp", "cli", "error", "cur", "pg", "org", "loc"], "stmt": ["strmn", "stql", "strm", "strmp", "tm", "tmn", "Stmm", "Stmn", "strtx", " stmb", " stm", " stmp", "istmt", " stmit", "pttx", " stmm", "strmt", "tmt", "ptmn", " stmd", "stmp", "Stma", "Stmr", "stmd", "tmm", "stm", "strmd", "stma", " sttx", "Stmp", "dma", "istmr", "stmit", "istmit", "dmt", "dmb", "stmr", "Stmd", "Stmit", "strmi", "strmb", "dm", "Stm", "strmr", "Stmb", "stmm", "ptql", "strmm", " stma", "Stmi", " stql", " stmn", " stmr", "stmn", "stmb", "sttx", "ptmt", "Stmt", "stmi", "istm", " stmi", "strql"], "dbConn": ["dbConnection", "dbconn", "cbConnection", "cbCon", "bbConn", " dbConnect", "bdConnection", "dbConnect", "databaseConn", "databaseConnection", "cbConnect", " dbConnection", "bbconn", " dbconn", "bdCon", "bdConn", "databaseConnect", "bbConnect", "databaseconn", "cbConn", " dbCon", "bdConnect", "bbConnection", "dbCon"], "selfConnection": [" selfconnection", "passReference", "parentconnection", "passConnection", "thisConnection", "SelfConnection", "parentConn", "thisConn", "selfconnection", "SelfConnect", "thisConnect", "selfReference", " selfConn", "Selfconnection", " selfConnect", "passConn", "thisReference", "selfConnect", "selfConn", " selfReference", "thisconnection", "parentConnect", "passConnect", "SelfReference", "SelfConn", "passconnection", "parentConnection"]}}
{"id1": "9096319", "id2": "3375724", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"handleNodeRegainedService": ["handleNodeReginedEvent", "handleNodeReginedService", "handleNoderegainsServices", "handleNodeRegainsEvent", "handleNoderegainedServices", "handleNoderegainedService", "handleNodeRegainingService", "handleNoderegainedEvent", "handleNodeRegainingServices", "handleNodeRegainsService", "handleNodeRegainedEvent", "handleNodeReginedServices", "handleNoderegainsEvent", "handleNodeRegainingEvent", "handleNodeRegainedServices", "handleNoderegainsService", "handleNodeRegainsServices"], "eventID": ["updateid", "issueName", "updateID", "issueid", "issueID", "issueId", "nodeId", "eventid", "serviceid", "nodeTime", "updateId", " eventid", "serviceName", "serviceTime", "eventId", " eventName", "serviceId", "eventName", "updateName", " eventId", "nodeName"], "nodeID": ["resourceID", "eventPath", "nodeResult", "nodeid", "packageID", " nodeResult", "siteId", "nodeRI", " nodeid", "globalid", " nodeName", "nodeId", "eventid", "odeID", "serviceid", "resourceId", "globalPath", " nodeRI", "nodePath", "packageId", "eventKey", " nodeKey", "objectId", "globalId", "objectName", "odeId", "eventResult", "siteName", "sourceID", "eventId", "sourceRI", "sourceId", " nodePath", "eventName", "odeName", "nodeKey", " nodeId", "serviceId", "resourceKey", "objectID", "siteid", "odeRI", "nodeName", "odeResult", "globalID", "objectid", "packageid", "siteID"], "ipAddr": ["ipAddressri", "ipAppr", " ipAttrs", "IPAdder", "ipAddrt", "ipAddressrt", "IPAddrs", "ipAtter", " ipAttr", "ipAddressrs", " ipAppvr", "ipaddress", "ipAddressvr", " ipAttri", "ipAppvr", "ipAttri", "ipaddr", "ipChn", " ipAddrs", " ipApprs", "IPAddr", "IPAddressrt", " ipAdder", "ipaddrs", "ipAder", "ipAddri", " ipAtter", "ipOffrt", "IPAddressn", "IPAddri", "ipAdder", "IPAddrt", "ipAttr", "ipAddvr", "ipadder", "ipAdrs", "ipaddvr", "ipAttrs", "ipApprs", "ipAddrs", "ipOffrs", " ipAddress", "ipAddn", "IPAddressri", "ipOffr", "IPAddressr", " ipAddvr", "IPAddresser", "IPAddressrs", "ipAddressress", "ipAttvr", "ipAdn", " ipAttvr", "ipChr", "ipAddressn", "ipAddressr", "ipCher", "ipAddress", " ipAddri", "ipAddresser", "ipaddri", "ipChrs", "ipOffri", "ipAdr", " ipAppr", "IPAddn"], "serviceID": ["featureID", "resourceID", "skillName", "eventIDs", "serviceIDs", " serviceHandle", "featureIP", "serviceHandle", " serviceX", " serviceNAME", "ServiceName", "ServiceIDs", "skillID", "featureId", "ServiceID", "resourceType", "ServiceIP", "eventX", " serviceName", "ServiceId", "processId", "ServiceHandle", "serverID", "skillNAME", "serviceX", "resourceId", " serviceId", " serviceIP", "ServiceNAME", "serviceName", "serverId", " serviceIDs", "serviceNAME", "eventId", "featureHandle", "processName", "serviceIP", "eventName", "serviceId", "ServiceType", "processID", "serverName", "serverX", "skillId", " serviceType", "serviceType"], "eventTime": ["EventName", "changePoint", "changeTIME", "changeTime", "errorTime", " eventType", "changeType", "EventTim", " eventPoint", "eventTIME", "processName", "processTim", " eventName", "eventName", "eventTim", "processID", "errorTIME", " eventTIME", "processTime", "errorType", "EventID", "EventTime", "eventType", "eventPoint", "errorPoint", " eventTim"], "log": ["event", "info", "path", "lo", "temp", "feed", "output", "lock", "entry", "LOG", "http", "tool", "net", "c", "ge", "l", "host", "pool", "tag", "write", "thread", "pl", "key", "fail", "loop", "type", "stat", "cache", "connection", "debug", "model", "cat", "ch", "w", "config", "level", "crit", "out", "build", "cl", "get", "put", "gen", "conn", "format", "or", "lex", "port", "exp", "blog", "it", "call", "db", "Log", "og", "full", "com", "url", "bug", "pe", "contract", "sign", "plug", "error", "sec", "stop"], "dbConn": ["dbConnection", "logConnect", "bbCon", "dbconn", "cbConnection", "fbCon", "logConn", "fbColl", "dbCt", "DBConnection", "DbConnection", "bbConn", " dbConnect", "DbConn", " dbCt", "logconn", "DbConnect", "DBConn", "fbCt", "dbLoc", "dbConnect", "realCon", "DbCt", "logDb", "databaseConn", " dbDb", "databaseConnection", "realCt", "cbConnect", " dbConnection", "bbconn", "fbConn", "DBConnect", " dbconn", "dbColl", " dbLoc", "realColl", "dbDb", " dbColl", "DbDb", "databaseconn", "bbConnect", "DBCon", "databaseLoc", "cbConn", " dbCon", "Dbconn", "DbLoc", "cbconn", "DBconn", "DBCt", "realConn", "bbConnection", "dbCon"], "outageUpdater": ["outageUtdter", "outageUpdraser", "outageUpdatedratter", "outageAppdator", "outageUprusher", "outageUnaser", "outageUpdrater", "outageUpdrator", "outageUpdatedraser", "outageUpnoster", "outageUpdatarter", "outageUpmter", "outageUpdatATER", "outageUpdarter", "outageUppater", "outageUpdroster", "outageUpnoder", "outageUpdoder", "outageUpdager", "outageUpdatedarer", "outageupdatter", "outageUpdatedATER", "outageUptatable", "outageChdator", "outageUpfatter", "outageUpnager", "outageUpdrarer", "outageUpdatedatter", "outageUnATER", "outageuplater", "outageUpfaser", "outageUpratter", "outageChdroster", "outageUpdrapper", "outageUpdroder", "outageupdaser", "outageAppdter", "outageChdrator", "outageUplusher", "outageAppnter", "outageUplatter", "outageUpparter", "outageUpfater", "outageUpnarer", "outageUpdoster", "outageUpfapper", "outageUpdatedrater", "outageChdoster", "outageUtdatter", "outageUpdrusher", "outageUpdrATER", "outageUpdatedatable", "outageUpdatater", "outageuplusher", "outageUpdatedrapper", "outageUpdatedratable", "outageUpdatatter", "outageUtdarter", "outageUtdatarter", "outageUpdratable", "outageUpdATER", "outageUpdarer", "outageuplaser", "outageAppnager", "outageUtdater", "outageUpdsoster", "outageUdater", "outageUptaser", "outageUppter", "outageChdater", "outageAppnater", "outageUpdusher", "outageUpdatable", "outageUpdatedater", "outageUpdatter", "outageUpdratter", "outageUpdatedrarer", "outageUpndater", "outageUdATER", "outageUpmager", "outageUpdator", "outageUpndarter", "outageUpnter", "outageUplaser", "outageUprater", "outageUpdsator", "outageChdoder", "outageUpnater", "outageUpnaser", "outageUppatter", "outageUppaser", "outageUpdatedapper", "outageUplapper", "outageUpndter", "outageUnarer", "outageAppdager", "outageUpnator", "outageUpmator", "outageupdusher", "outageUplater", "outageUpstager", "outageUpdatedrATER", "outageUpnATER", "outageUdaser", "outageuplatter", "outageUpdsater", "outageUpmater", "outageUppATER", "outageChdrater", "outageUtdatater", "outageUptater", "outageUpstater", "outageUdarer", "outageUnater", "outageAppdater", "outageUpdter", "outageAppnator", "outageUpdatedaser", "outageUptarer", "outageChdroder", "outageUtdatatter", "outageUpdataser", "outageUpdapper", "outageUpstter", "outageupdater", "outageUpstator", "outageUpdaser", "outageUpraser", "outageUpdatarer", "outageUpndatter", "outageUpdsoder", "outageUpdatatable"]}}
{"id1": "2017833", "id2": "11865906", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["string", "base", "sum", "replace", "add", "message", "hex", "Hash", "html", "number", "set", "ash", "sha", "str", "build", "check", "h", "get", "format", "dump", "update", "create", "parse", "print", "block", "crypt", "transform"], "text": ["letter", "string", "path", "EXT", "buffer", "class", "translation", "input", "editor", "output", "token", "Text", "message", "TEXT", " TEXT", "version", "hex", "number", "length", "key", "pattern", "content", "password", "txt", "source", "binary", "value", "str", "data", "out", "object", "struct", "context", "format", "test", "name", "template", "image", "font", "word", "bytes", "url", "ext", "secret", "contract", " Text", "code"], "UnsupportedEncodingException": ["UnsupportedEncgorithmException", "UnsupportedEncodedWarning", "UnsupportedencodingWarning", "UnsupportedEncgorithmception", "Unsupportedencodedception", "UnsupportedencodedWarning", "UnsupportedencodedException", "UnsupportedEncgorithmWarning", "UnsupportedEncasingception", "Unsupportedencodingception", "UnsupportedEncasingException", "UnsupportedEncodingception", "UnsupportedEncodedception", "UnsupportedEncodingWarning", "UnsupportedEncasingWarning", "UnsupportedEncodedException", "UnsupportedencodingException"], "md": ["um", "bf", "gd", "mag", "bd", "od", "amd", "message", "mo", "ind", "ma", "am", "meta", "wd", "MD", " MD", "ms", "ld", "ad", "mb", "mt", "mac", "d", "mp", "hd", "sha", "pm", "mm", "metadata", "dig", "m", "hm", "dm", "mand", "mc", "nm", "mod", "vd", "ds", "bm", "rm", "mg", "mad", "f", "cmd", "dd"], "sha1hash": ["sha256sum", "sha3match", "SHA1h", "SHA1Hash", "ha2sum", "sha256Hash", "sha4hash", "ha2hex", "sha256hash", "shaonehex", "ha1hex", "ha1hash", "sha5hex", "SHA2sum", "sha2hex", "ha2hash", "sha3hex", "ha2match", "sha5Hash", "sha1h", "sha5h", "sha1match", "sha2Hash", "shaonematch", "sha1Hash", "SHA2h", "shaonesum", "sha2match", "sha4Hash", "sha5sum", "sha3sum", "shaonehash", "sha4sum", "SHA1hash", "sha2sum", "sha4hex", "SHA2Hash", "sha2h", "ha1match", "sha2hash", "sha3hash", "sha5hash", "sha256h", "ha1sum", "sha1hex", "SHA1sum", "SHA2hash", "sha1sum", "SHA1hex"]}}
{"id1": "3558512", "id2": "16623181", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"serialize": ["erialize", "serialze", "serializable", " serialization", "Serialize", "finalify", "finalize", "serialization", " serializable", "finalized", "normalized", "erialze", "normalify", "erialization", "Serialized", "serialify", "erializable", " serialze", "serialized", "normalize", "normalze", "Serialze", "Serialization", "finalze", "Serialify", "Serializable"], "out": ["string", "buffer", "loader", "temp", "i", "ex", "output", "copy", "server", "report", "filename", "OUT", "o", "outs", "pool", "bin", "content", "raw", "client", "source", "cache", "up", "w", "data", "file", "archive", "parent", "page", "gen", "conn", "name", "exec", "Out", "io", "writer", "image", "dump", "a", "err", "obj", "png"], "parser": ["pillar", "base", "class", "pkg", "arser", "loader", "handler", "server", "copy", "builder", "master", "lp", "per", "as", "system", "instance", "php", "manager", "txt", "er", "cp", "reader", "cache", "pp", "up", "seed", "upload", "parent", "file", "rar", "p", "plugin", "test", "writer", "ss", "worker", "tt", "pe", "parse", "processor", "wrapper", "xml", "Parser"], "on_disk": ["onbootdrive", "onJdrive", "onJdisk", "onbootlock", "onjdrive", "onbootstorage", "on_demand", "onjdisk", "on_drive", "off_disk", "onnetfile", "off_drive", "onbootdisk", "on_storage", "onbookdelete", "on_lock", "onJdemand", "off_lock", "on_space", "onnetdemand", "onbookdisk", "off_storage", "onJlock", "on_delete", "onnetdisk", "onnetspace", "off_delete", "onbookdrive", "onjfile", "off_demand", "onnetdrive", "onjspace", "off_file", "on_file", "off_space"], "in": ["IN", "info", "pin", "i", "input", "inas", "copy", "ini", "con", "c", "socket", "inner", "as", "o", "ins", "bin", "pass", "reader", "thin", "source", "connection", "min", "login", "r", "inc", "data", "file", "rin", "conn", "again", "ax", "In", "kin", "stream", "lin", "ac", "inn", "f", "win", "din"]}}
{"id1": "15129155", "id2": "19296519", "code1": "    public List<String> extractUrlList(String url) throws IOException, XPathExpressionException {\n        LinkedList<String> list = new LinkedList<String>();\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        Tidy tidy = new Tidy();\n        tidy.setErrout(new NullPrintWriter());\n        Document doc = tidy.parseDOM(conn.getInputStream(), null);\n        int len = conn.getContentLength();\n        if (len <= 0) len = 32000;\n        ByteArrayOutputStream bout = new ByteArrayOutputStream(len);\n        PrintStream ps = new PrintStream(bout);\n        tidy.pprint(doc, ps);\n        ps.flush();\n        String content = bout.toString();\n        Pattern p = Pattern.compile(\"(http://[\\\\w\\\\\\\\\\\\./=&?;-]+)\");\n        Matcher m = p.matcher(content);\n        while (m.find()) {\n            list.add(m.group());\n        }\n        return list;\n    }\n", "code2": "        private long getSize(String url) throws ClientProtocolException, IOException {\n            url = normalizeUrl(url);\n            Log.i(LOG_TAG, \"Head \" + url);\n            HttpHead httpGet = new HttpHead(url);\n            HttpResponse response = mHttpClient.execute(httpGet);\n            if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {\n                throw new IOException(\"Unexpected Http status code \" + response.getStatusLine().getStatusCode());\n            }\n            Header[] clHeaders = response.getHeaders(\"Content-Length\");\n            if (clHeaders.length > 0) {\n                Header header = clHeaders[0];\n                return Long.parseLong(header.getValue());\n            }\n            return -1;\n        }\n", "label": 0, "substitutes": {"extractUrlList": ["extractionUrlList", "extractLocationList", "extractionURLList", "extractTextObject", "extractUrlCollection", "extractionUrlCollection", "extractURLList", "extractUrllist", "extractLocationlist", "extractUrlObject", "extractionURLObject", "extractLocationCollection", "extractTextlist", "extractionUrllist", "extractionURLlist", "extractURLlist", "extractionURLCollection", "extractTextCollection", "extractLocationObject", "extractURLCollection", "extractURLObject", "extractTextList", "extractionUrlObject"], "url": ["string", "path", "address", "base", "ssl", "i", "input", "server", "uri", "resource", "feed", "http", "filename", "html", "l", "location", "host", "URL", "email", "source", "connection", "data", "file", "out", "src", "text", "page", "ll", "href", "name", "image", "sl", "Url", "www", "ur", "obj", "xml", "f", "download"], "list": ["val", "string", "rest", "base", "i", "map", "table", "result", "l", "set", "pool", "all", "code", "detail", "queue", "iter", "arr", "dl", "loop", "LIST", "part", "type", "load", "member", "lc", "live", "item", "str", "listed", "g", "li", "out", "ist", "cl", "ll", "x", "test", "lists", "msg", "coll", "tree", "dict", "e", "chain", "array", "parse", "we", "bl", "left", "batch"], "conn": ["Connection", "Conn", "server", "n", "cf", "enc", "rc", "http", "con", "c", "pub", "cb", "Con", "host", "rt", "dc", "nc", "client", "sync", "nt", "cp", "session", "lc", "sb", "resp", "ct", "connection", "ch", "g", "open", "conv", "rec", "po", "exec", "dn", "ann", "db", "jp", "mc", "ctx", "conf", "cn", "connect", "cli", "cmd", "loc"], "tidy": ["ttrie", "Triage", "ttidi", "Tidy", " trawl", "ttriage", "tick", "ttickle", "Try", "priage", "Tickle", "tractor", "ttidy", "potally", "Trie", "pickle", "trawl", "pidi", "ntickle", "matrawl", "pick", "Totally", "trie", " totally", "pidy", "tickle", "matry", "triage", "matickle", " tickle", "Tick", "ttractor", "totally", " tidi", "Trawl", " triage", "ntidy", "practor", "matidy", " tick", " tractor", "ntriage", "ntrie", "tidi"], "doc": ["val", "index", "id", "n", "Doc", "df", "docs", "document", "c", "DOC", "html", "l", "dc", "d", "up", "oc", "str", "div", "md", "data", "file", "g", "body", "h", "po", "coll", "dict", "pos", "exp", "dec", "db", "di", "obj", "sp", "dom", "xml", "f", "api"], "len": ["val", "lt", "base", "num", "lang", "n", "lf", "Len", "lp", "cap", "limit", "loc", "html", "l", "length", "line", "el", "bin", "lan", "ld", "en", "elt", "fin", "dl", "fl", "part", "lc", "li", "lim", "size", "ll", "lit", "ls", "ann", "pos", " length", "sl", "ln", " lang", "span", "lin", "seq", " Len", "count", "f", "lon"], "bout": ["boff", "aouts", "brOUT", "bbout", "mbin", " bin", "bin", "brin", " bouts", "Bstream", "Bin", "bbOUT", "mbouts", "Bout", " bOUT", "bouts", "brout", "bOUT", "BOUT", "aout", "ain", "Bouts", "bbouts", "mbstream", "astream", "mbout", "bboff", "bbin", "Boff", "bstream", "broff"], "ps": ["pps", "pres", "fs", "pi", "pse", "Ps", "ks", "py", "ns", "qs", "bs", "s", "pl", "ms", "rs", "pr", "pp", "proxy", "ops", "pers", "mp", "par", "eps", "gs", "out", "ips", "ep", "aps", "ts", "vs", "po", "ss", "pa", "pe", "sp", "ds", "cs", "os", "pas", "PS"], "content": ["string", "path", "temp", "input", "output", "response", "resource", "document", "message", "c", "cont", "con", "result", "html", "Content", "raw", "expression", "source", "load", "cover", "activity", "value", "connection", "media", "model", "str", "section", "config", "data", "text", "body", "work", "page", "ontent", "word", "ext", "comment", "xml", "code"], "p": ["P", "i", "n", "pi", "op", "lp", "c", "py", "per", "l", "s", "pattern", "comp", "ap", "cp", "d", "pr", "pp", "q", "mp", "r", "g", "parser", "pro", "rep", "ip", "h", "po", "tp", "e", "t", "jp", "pa", "pe", "b", "sp", "f"], "m": ["om", "tm", "mu", "um", "n", "vm", "M", "c", "ma", "o", "l", "am", "match", "line", "wm", "mr", "perm", "ms", "rem", "sm", "cm", "part", "source", "d", "mp", "pm", "media", "r", "machine", "md", "body", "mm", "h", "mi", "u", "fm", "hm", "dm", "mc", "em", "b", "v", "me", "bm", "rm", "gm", "im"]}}
{"id1": "14567939", "id2": "9099457", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public static String hash(String value) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] md5hash = new byte[32];\n            md.update(value.getBytes(\"iso-8859-1\"), 0, value.length());\n            md5hash = md.digest();\n            return Hex.encodeHexString(md5hash);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"baseHash": ["baseFile", " generateHash", "Basehash", " generateSecret", "baseSecret", " chainFile", "basehash", "BaseHash", " generatehash", " generateFile", "BaseSecret", " chainSecret", "BaseFile", " chainHash", " chainhash"], "name": ["NAME", "path", "base", "class", "string", "address", "id", "n", "resource", "definition", "user", "account", "host", "ame", "key", "part", "type", "member", "alias", "parent", "names", "file", "data", "object", "style", "hello", "Name", "image", "normal", "word", "prefix", "secret", "create", "named", "hash"], "password": ["string", "path", "input", "token", "username", "profile", "account", "stroke", "priv", "wd", "pass", "key", "pattern", "security", "Password", "source", "PASS", "seed", "value", "diff", "sword", "data", "text", "device", "word", "wallet", "prefix", "secret", "auth", "paste", "padding", "words", "attribute", "crypt", "phrase", "hash", "code"], "digest": ["Digester", "signester", "DigEST", "Diger", "decEST", "modested", "signest", "signusher", "Digr", "signer", "modester", " digested", " diger", "modest", "decest", "signger", " digusher", "mdest", " digger", "digester", "digr", "digested", "mdester", "decr", "digger", "decester", "Digest", "moder", "Digusher", "mdEST", "digusher", "diger", "mdr", "Digger", " digester", "Digested", "digEST"]}}
{"id1": "1769771", "id2": "20019847", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyChannel", "copyChannel", "CopyFile", "copyfile", "transferfile", "transferFiles", "transferChannel", " copyFiles", "Copyfile", " copyChannel", "CopyFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "base", "pin", "i", "input", "id", "ex", "lock", "c", "inner", "l", "ins", "bin", "query", "source", "reader", "login", "min", "diff", "inc", "work", "config", "file", "data", "again", "name", "m", "image", "io", "In", "url", "lin", "inn", "f", "win"], "out": ["string", "base", "ex", "n", "output", "server", "resource", "user", "plain", "OUT", "c", "o", "outs", "off", "write", "extra", "cache", "dot", "up", "target", "default", "w", "file", "x", "p", "conn", "name", "again", "exec", "Out", "io", "writer", "image", "call", "prefix", "ext", "v", "b", "external", "point"], "inChannel": ["binStream", "inputChannel", "INchannel", "binchannel", "inStream", " inchannel", "inputchannel", " inClient", "winChan", "binClient", "inchannel", "binChan", "InChan", "Inchannel", "inputChan", "INChan", "outStream", "outchannel", "outChan", "inChan", "InChannel", "insClient", "outClient", "insStream", "InStream", "inputStream", "insChannel", "binChannel", "INStream", "winChannel", "winchannel", "INChannel", " inStream", "InClient", "inClient", " inChan", "insChan", "winStream"], "outChannel": ["outputCh", "inputChannel", "inStream", "inputchannel", "OutConnection", "OutChannel", "inchannel", " outConnection", "nManager", "nChan", "OutChan", "inCh", "inputChan", "outStream", "outchannel", "nChannel", "outChan", "inChan", "inputController", "outputStream", "outputChannel", "outputchannel", "outputController", " outCh", "outConnection", "Outchannel", "nStream", "outCh", " outManager", "inConnection", "outputChan", " outStream", "inManager", "outController", "outManager", "inController", " outchannel", " outChan"]}}
{"id1": "822452", "id2": "11032546", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRebwrite", "readAndRebrap", "readAndRewwrite", "readAndSwrap", "readAndrewwrite", "readAndRebrite", "readandRewrap", "readandRewrites", "readAndSwwrite", "readandrewrap", "readAndRewrap", "readAndSwrite", "readandrewrites", "readandrewwrite", "readAndRebrites", "readAndRewrites", "readAndrewrite", "readAndSwrites", "readandrewrite", "readAndrewrites", "readAndrewrap", "readandRewwrite", "readandRewrite"], "inFile": [" inSourceFile", "InSourceFile", "oldfile", "outSourceFile", "inputfile", "outfile", " inFiles", "inputFilename", "InFiles", " infile", "infile", "inputFile", "outFiles", "oldFile", "loginFile", " inFilename", "Infile", "inFiles", "inputFiles", "oldFiles", "loginFilename", "loginfile", "loginFiles", "InFile", "oldFilename", "outFilename", "inFilename", "inSourceFile"], "outFile": ["newfile", "outDir", "OutStream", "processFile", "outputFilename", "exFilename", "outputfile", " outfile", "outPlace", "outFILE", "outputFILE", "outfile", "processFilename", "offFILE", "outputPlace", "thisFilename", "outStream", "thisFile", "processPlace", "exfile", "thisFILE", "newDir", "exFILE", "OutDir", "exFile", "processFILE", "newStream", "offPlace", "OutFile", " outStream", "outFilename", "offFilename", "Outfile", " outDir", "outputFile", "newFile", "thisfile", "offFile"], "iis": ["iIS", "Iais", "iIs", "iiris", "iniIs", "iiiss", "iais", "Iis", "ciis", "iiis", " iIs", " iIS", " iais", "ciiss", "Iiss", "ciais", " iiss", "iiss", "iiIS", "iniiss", " iris", "iniis", "ciris", "iniIS", "iniris", "IIS", "iris", "iiIs", "ciIS", "ciIs"], "dcmParser": ["dbmPolicy", "dbmParser", "dmmLoader", "dmissionParser", "dcmInstallation", "dmoduleJar", "dpmLoader", "dmoduleparser", "dhemReader", "dkmParser", "dmissionLanguage", "dCMPlugin", " dpmparser", " dcrParser", "fpmparser", "dhemJar", " dpmPolicy", "dkmPolicy", "dpmParser", "dcmPolicy", "dmissionPlugin", " dcmarser", "dmmPlugin", " dcrPlugin", "DcmInstallation", " dcmLanguage", "dpmHandler", "dmcJar", "dkmPlugin", " dpmParser", "dmoduleReader", " dcrLoader", "fcmReader", "dmissionReader", "dcrParser", "dmcarser", "dbmHelper", "dmLoader", "fpmHandler", "dcrarser", "dhemInstallation", "dmcParser", "dmmparser", "dpmLanguage", "dmodulePlugin", " dcmPolicy", "dpmarser", "dpmReader", "dcmPar", "dpmPar", "dmReader", "dcmparser", "dcrLoader", "dmParser", " dcmLoader", " dcmReader", "fcmparser", "dpmPolicy", "dcrJar", "dcmPlugin", "dpmparser", "fpmReader", "dcmarser", " dpmPlugin", "dbmPlugin", "dpmPlugin", " dpmHelper", "dCMLoader", " dpmLoader", " dpmJar", "dmoduleParser", " dcrReader", "dcmLoader", "fcmParser", "dpmHelper", "dcmReader", " dpmPar", "dCMHandler", "dmPlugin", "dcmJar", "dcrPlugin", "dpmJar", " dcmJar", "fcmHandler", " dcmHelper", "dCMparser", "dcrPar", "DcmParser", " dcmPar", "dcrReader", "fpmParser", " dpmReader", " dcmparser", "dmcPar", " dpmLanguage", "dcmHelper", "dpmInstallation", "dcmHandler", "dCMParser", "dcmLanguage", "dmmParser", "DcmReader", "dCMReader", "dkmHelper", " dcmPlugin", "DcmJar", "dhemParser", " dpmarser"], "ds": ["services", "ys", "uds", "ays", "DS", "iss", "gd", "sys", "Os", "df", "ants", "ns", "tes", "ks", "drivers", "qs", "bs", "s", "ins", "dr", "is", "dc", "rs", "ld", "dt", "parts", "cdn", "sync", "session", "ws", "d", "ros", "eps", "points", "icks", "ads", "data", "gs", "src", "xs", "utils", "vals", "ras", "Ds", "des", "ts", "conn", "vs", "ls", "js", "ss", "db", "ils", "di", "nas", "details", "amps", "Db", "da", "asi", "cs", "dds", "ps", "os", "dat", "pd", "dd", "tx"], "pdReader": ["hdRunner", "pbRunner", "pcReader", "pdRunner", "xdreader", "dsReader", "dsreader", "pbLoader", "hdReader", "hdreader", "dsLoader", "pcLoader", "pbStream", "hdStream", "ddStream", "pcRead", "xdWriter", "ddLoader", "pdLoader", "pdStream", "ddRunner", "pbReader", "hdWriter", "dsRead", "dsWriter", "xdRead", "pcWriter", "xdReader", "hdRead", "hdLoader", "ddReader", "pdreader", "pdRead"], "out": ["ssl", "base", "temp", "output", "net", "as", "s", "in", "at", "lib", "model", "default", "file", "gen", "conn", "Out", "url", "obj", "with", "external", "point", " in", "outer", "ex", "sys", "lock", "builder", "result", "later", "sync", "part", "cache", "up", "oder", "connection", "w", "parent", "store", "page", "object", "device", "again", "name", "exec", "exp", "array", "full", "over", "list", "order", "inner", "outs", "o", "line", "flow", "co", "write", "password", "session", "doc", "diff", "group", "director", "null", "dev", "io", "writer", "image", "to", "word", "cli", "term", "auto", "her", "copy", "user", "OUT", "child", "manager", "pass", "key", "client", "dot", "login", "inc", "down", "data", "db", "layer", "ext", "err", "code", "img"], "dcmEncParam": ["dcmEnParam", "dcmEstParam", "dcmDecParam", "dcmEnParameter", "dcmSecPart", "dcmDecType", "dcmDecPar", "dcmEncType", "dcmEncParameter", "dcmArchParam", "dcmEncPart", "dcmElParameter", "dcmEnPar", "dcmEnPart", "dcmDecArg", "dcmArchArg", "dcmArchParameter", "dcmSecPar", "dcmEnArg", "dcmDecParameter", "dcmDecPart", "dcmSecType", "dcmElParam", "dcmEstPar", "dcmEncPar", "dcmSecParam", "dcmElPar", "dcmEncArg", "dcmElType", "dcmEnType", "dcmEstType", "dcmEstParameter"], "pdWriter": ["dpWrite", "pdOutput", "ddWrite", "pdWriting", "htWriter", "dpReader", "dsReader", "hdReader", "pdWrite", "htWriting", "dpWriting", "PDWrite", "dpWriter", "hdWriter", "dsOutput", "dsWriter", "hdWrite", "htWrite", "PDWriter", "dsWrite", "ddOutput", "PDReader", "ddReader", "htReader", "PDWriting", "ddWriter", "hdOutput"]}}
{"id1": "7087108", "id2": "23370621", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["processGet", "didGet", "processGET", "processPut", "doDownload", "didGET", "didDownload", "didPut", " doPut", "doGET", "doPut", " doDownload", " doGET", "processDownload"], "request": ["event", "info", "error", "buffer", "string", "input", "Request", "server", "resource", "uri", "user", "builder", "self", "report", "http", "subject", "message", "json", "version", "project", "current", "result", "forward", "instance", "child", "host", "query", "condition", "req", "client", "type", "reader", "use", "connection", "target", "model", "application", "config", "data", "parent", "route", "web", "object", "context", "complete", "name", "QUEST", "url", "create", "xml", "method", "this", "external", "view"], "response": ["remote", "server", "output", "resource", "report", "http", "results", "message", "document", "site", "version", "json", "result", "content", "client", "cache", "resp", "connection", "model", "application", "wave", "collection", "out", "body", "page", "object", "reply", "example", "status", "writer", "image", "Response", "respond", "reference", "method", "service", "view"], "path": ["directory", "index", "string", "info", "base", "id", "uri", "output", "resource", "http", "message", "filename", "Path", "location", "key", "pattern", "content", "filter", "cache", "dir", "value", "ath", "config", "data", "text", "route", "out", "object", "p", "format", "name", "folder", "image", "url", "PATH", "method", "point"], "file": ["directory", "zip", "info", "base", "handler", "class", "fe", "resource", "uri", "feed", "lock", "http", "filename", "socket", "fp", "l", "child", "File", "part", "source", "use", "rule", "dir", "up", "lib", "connection", "FILE", "work", "data", "out", "route", "local", "le", "object", "h", "log", "name", "folder", "image", "to", "it", "function", "full", "files", "url", "pe", "b", "f"], "in": ["IN", "pin", "i", "input", "id", "serv", "copy", "resource", "ini", "gin", "con", "c", "socket", "as", "inner", "s", "ins", "bin", "is", "source", "thin", "reader", "binary", "login", "r", "inc", "data", "out", "rin", "init", "ax", "isin", "it", "In", "nin", "kin", "stream", "lin", "b", "ac", "cin", "inn", "f", "win", "din"]}}
{"id1": "5759961", "id2": "3945236", "code1": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"saveUser": ["savePerson", "submitUser", "Saveuser", "submitPerson", "submituser", "saveAccount", " savePerson", "saveuser", "SavePerson", "SaveAccount", " saveAccount", "SaveUser", "submitAccount", " saveuser"], "user": ["string", "base", "class", "job", "editor", "self", "resource", "replace", "username", "clean", "tool", "entry", "USER", "author", "profile", "project", "User", "per", "result", "uid", "account", "record", "query", "usr", "content", "password", "one", "use", "rule", "users", "up", "facebook", "module", "book", "model", "group", "parent", "data", "used", "config", "object", "request", "log", "style", "plugin", "or", "name", "creator", "e", "force", "home", "blog", "word", "db", "person", "full", "team", "ver", "app", "bug", "you", "me", "student", "this", "service", "valid"], "digest": ["digert", "Digester", "signester", "DigEST", "Diger", "Digert", "signEST", "genit", "signest", "bigest", "signer", "digge", " diger", " digert", "genge", "digit", "mdit", "bigert", "mdest", "mdge", "genEST", " digge", "digester", "Digit", "biger", "Digge", "Digest", "bigge", "mdEST", "diger", " digEST", "bigester", " digester", "genest", "digEST"], "hash": ["index", "string", "total", "base", "max", "sum", "her", "num", "id", "message", "version", "current", "hex", "Hash", "html", "number", "match", "memory", "query", "ash", "key", "password", "mac", "cache", "sha", "build", "math", "check", "h", "empty", "search", "fill", "image", "array", "db", "full", "url", "update", "count", "block", "code", "depth"], "bigInt": ["largeInt", "hashInt", "bigInteger", "hugeInteger", " bigString", "hugeint", "hashInteger", "bigUrl", "hugeInt", "hashUrl", " bigUrl", "BigString", " bigInteger", "largeint", "bigint", "BigInt", "BigInteger", "Bigint", "hashint", "hugeUrl", "largeInteger", " bigint", "bigString", "largeString"], "hashtext": ["HashTEXT", "Hashword", "ashText", "Hashstring", "ashstring", "ashpath", "sumword", "ashTEXT", "HashText", "sumTEXT", " hashstring", "hashfeed", "Hashfeed", "Hashpath", "sumText", "sumstring", "ashtext", "Hashtext", " hashword", " hashpath", "hashword", "hashstring", "sumtext", " hashText", "sumfeed", "ashword", "ashfeed", " hashTEXT", "hashTEXT", "hashpath", "hashText"]}}
{"id1": "21181542", "id2": "20920051", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"deleteRoleType": ["deleteResourceType", "deleteFunctionType", "deleteResourceTyp", "deleteFunctionTypes", "deleteRoleTypes", "deleteRoleTyp", " deleteroletype", " deleteroleType", " deleteRoletype", "deleteFunctionTyp", " deleteroleTyp", "deleteResourceTypes", "deleteFunctiontype", "deleteroleTypes", " deleteRoleTypes", " deleteroleTypes", " deleteRoleTyp", "deleteRoletype", "deleteroleType", "deleteResourcetype", "deleteroleTyp", "deleteroletype"], "id": ["index", "path", "string", "info", "address", "i", "uri", "lock", "version", "uid", "end", "length", "sid", "ident", "is", "in", "ids", "key", "part", "like", "type", "source", "aid", "connection", "rid", "model", "kid", "section", "parent", "data", "oid", "ip", "object", "request", "name", "start", "edit", "it", "pid", "vid", "url", "ID", "mid", "f", "error", "Id", "code", "view"], "namespaceId": ["nsaceId", "namesplaceInfo", "namespaceInfo", "Namespaceid", "worksspacePath", "namespaceKey", "memberspaceid", "namesentityId", "namesaceID", "workspaceInfo", "asentityInfo", "aspaceName", "namespacesInfo", "namespacesContext", "namespacesKey", "workspacesId", "aspaceInfo", "nspaceInfo", "NamespaceName", "worksspaceId", "namesaceInfo", "namesaceContext", "workspacesType", "namesaneType", "NamespaceId", "namesplaceID", "namesentityName", "namespacedInfo", "membersetId", "membersetid", "workspacesid", "asentityName", "namesenceContext", "namespacesID", "namespacedId", "asentityID", "namespaceid", "namesetName", "nsaceid", "worksspaceInfo", "namesaneName", "namespacesid", "asentityId", "namesplaceId", "namespacedType", "namespaceName", "workspaceContext", "workspaceid", "namespacesPath", "aspaceID", "memberspaceType", "namesaneId", "namesspaceId", "aspaceId", "namespaceID", "namespacesId", "NamespacedType", "namespaceType", "namesplaceid", "namesaneid", "namesetid", "namesentityID", "namesspaceKey", "namesetInfo", "workspacesContext", "NamespaceType", "namesetType", "namesetId", "memberspaceName", "membersetType", "Namespacedid", "nspaceId", "nsaceID", "namesenceType", "namespacesType", "nsaceInfo", "namesetID", "membersetName", "nspaceID", "namespacesName", "workspaceType", "workspaceKey", "namesaceType", "nspaceid", "memberspaceId", "namespaceContext", "namesenceId", "namesaceId", "workspaceId", "namesentityInfo", "namesaceid", "NamespacedId", "namesspacePath", "namesspaceInfo", "namespacedPath", "worksspaceKey", "namesenceid", "namespacePath", "namespacedid", "NamespacedName", "workspacePath", "namespacedName", "namespacedKey"], "removeReferencesInRoleTypes": ["removeReferencesInRoleType", "removeReferencesedInroletypes", "removeReferencesInServiceNames", "removeReferencesInRoleNames", "removeReferencesFromroleTypes", "removeReferencesedInroleType", "removeReferencesInroletypes", "removeReferencesedInroleTypes", "removeReferencesInServiceType", "removeReferencesInRoleRelations", "removeReferencesInRuleNames", "removeReferencesInRuleType", "removeReferencesFromRoleType", "removeReferencesedInRoletypes", "removeReferencesInRuletypes", "removeReferencesFromroleRelations", "removeReferencesInRuleRelations", "removeReferencesInRoletypes", "removeReferencesFromroleNames", "removeReferencesInroleTypes", "removeReferencesFromRoleRelations", "removeReferencesedInRoleNames", "removeReferencesedInRoleTypes", "removeReferencesedInroleNames", "removeReferencesInroleType", "removeReferencesFromRoleTypes", "removeReferencesInroleNames", "removeReferencesInServiceTypes", "removeReferencesInRuleTypes", "removeReferencesInServiceRelations", "removeReferencesedInRoleType", "removeReferencesFromroleType", "removeReferencesInroleRelations", "removeReferencesFromRoleNames"], "permit": ["recmission", "PERmission", "recmit", "permMIT", "recmits", "Permissions", "permissions", "permits", "perit", "Permits", "PerMIT", "Permission", "PERmissions", "Perit", " permits", "recit", "permission", " perit", "permmission", " permission", "permmit", "perMIT", "PERMIT", "Permit", "permmissions", "PERmit"], "exist": ["index", "know", "cmp", "continue", "add", "register", "cont", "icate", "present", "match", "destroy", "draw", "write", "ident", "existing", "fail", "form", "support", "except", "diff", "inc", "ist", "check", "same", "keep", "destruct", "delete", "fill", "start", "edit", "purpose", "apply", "update", "create", "include", "existent", "stick", "existence", "list", "front"], "msgBuf": ["msgEBbox", "messageFUF", "msgCuff", "msgBbuff", "msgPlaf", "msgEBbuf", "msgAraf", "messageAUF", "msgFUF", "msgPlundle", "messageFbuf", "msgFBob", "msgFBuf", " msgLaf", "messageBbuf", "msgCob", "msgEBuf", "msgDBuff", "msgAaf", "msgDBuf", "messageBuff", "messageBbox", "msgBob", "msgFbuf", "msgDuf", " msgBraf", "msgLuff", "msgLaf", " msgFaf", "msgBraf", "messageFuf", "msgBaf", "msgDBUF", "messageBUF", " msgBuff", "msgFuf", "msgFBUF", " msgBbuff", "msgCbuf", " msgFbuf", " msgFbuff", "msgBUF", "msgDbuf", "messageFuff", "messageAbuf", "msgBbox", " msgBaf", " msgFuff", "msgDuff", " msgFuf", "msgLuf", "msgAbuff", " msgLundle", "msgAuf", "msgBbuf", "msgDaf", "msgLob", "msgFundle", "messageFbox", "msgFraf", "msgPluff", "msgLUF", "msgBundle", "msgLundle", " msgLuff", "msgAbuf", "msgFob", "msgEBuff", "msgAob", "msgFbox", "msgFbuff", " msgFraf", " msgLuf", "msgAbox", "messageFob", "msgFuff", "msgAuff", "msgDBbuf", "messageAuff", "msgFaf", "msgCuf", "messageBob", "messageBuf", "msgBuff", "msgAUF", "msgFBuff", "msgPluf", "messageAuf", " msgBundle", " msgBbuf"], "objects": ["keys", "pps", "locks", "cats", "products", "archives", "results", "resources", "ks", "features", "apps", "ins", "kids", "ids", "people", "items", "projects", "parts", "articles", "owners", "links", "organisms", "boxes", "bugs", "lines", "ops", "blocks", "members", "parents", "users", "children", "points", "names", "classes", "roots", "archs", "images", "models", "object", "plugins", "oids", "groups", "phones", "frames", "obs", "jobs", "types", "cells", "actions", "agents", "notes", "files", "relations", "values", "pins", "obj", "os", "properties"], "sqlRightId": [" sqlrightPoint", " sqlrightType", "sqlRestid", " sqlrightid", "sqlRId", "sqlrightId", "sqlRightid", "sqlRestId", "SQLRightID", "sqlRRef", "SQLRightid", "SQLRestRef", "sqlRightPoint", "sqlrightid", "sqlRightRef", "sqlLeftid", "sqlLeftId", " sqlRightid", "sqlRightType", "SQLRestID", "SQLRightRef", "sqlRestRef", "SQLRestId", "sqlRightID", "sqlRestID", "sqlrightType", "sqlrightPoint", "sqlLeftPoint", " sqlRightPoint", " sqlrightId", "SQLRestid", "sqlRid", " sqlRightType", "sqlLeftType", "SQLRightId", "sqlRID"], "sqlParent": [" sqlparent", " sqlRoot", "sqlparent", "qlParent", "suParent", "suparent", "qlparent", "sqlParents", "qlParents", " sqlParents", "suRoot", "sqlRoot", "suParents", "qlRoot"], "sql": ["where", "replace", " msg", "description", " SQL", "s", " db", "dl", "select", " session", "session", " url", "operation", "ql", "acl", "log", "conn", " params", "msg", "delete", "db", "sl", "link", "url", "update", "SQL", "repl", "error"], "pstmt": ["pstatmt", " pstbl", "s", "pstbl", "pcttr", "pctm", "pstmb", "pmtmd", "pctmr", "pstrct", "Delete", " postct", "pndmb", "Psttr", "postct", " postnt", "pmtct", "pStmt", "pctnt", " pstnt", "The", "Pctct", " pstm", "add", "Pstct", "pstm", "postmt", "postnt", " psttr", " pndmb", "pstatnt", "All", "pStct", "pndbl", "pfct", " pstct", "delete", "pctbl", "pmttr", "pndmt", "Pstmd", "pctmd", "_", " pndmt", " postmt", " postmr", "pctmb", "psttr", "pmtbl", "pStm", "pstct", "Security", "pstnt", "pstrm", "pctct", "pstatmr", "Pctmt", " pStct", "pstmd", "Error", " pStm", "pstmr", "Pstmt", " pndct", "pftr", "New", "pmtmb", " pndbl", "pmtmt", "Pctmd", "pSttr", "pctmt", "Pcttr", "pstatct", "pfmd", "pstrtr", " pstmb", "pndct", "postmr", "pfmt", " pStmt", " pstmr", "pstrmt", " pSttr", "this"], "typeGid": ["typeGVname", "linkGVID", "typeGVid", "typeCid", "TypeGID", "TypeGid", "typeGname", "typeGVID", "typeGUname", "typeGoid", "TypeCid", "linkGVid", "linkGid", "linkGVname", "typeAccmin", "typeGVoid", "linkGname", "typegid", "typeWmin", "typeAccid", "TypeCname", "typeAccname", "TypeGname", "typeCID", "typeAccID", "typeGmin", "linkGVoid", "typeCname", "typeCmin", "typeWID", "linkGID", "TypeGmin", "typeWid", "typegID", "typeGUoid", "typeGUid", "typeGID", "TypeCID", "TypeCmin", "linkGoid", "typeWname", "typegoid", "typeGUID", "typegname"], "defaultLevel": ["configMode", "configLevel", " defaultDepth", "DefaultMode", "defaultCl", "DefaultDepth", "configDepth", "configCl", "DefaultCl", "defaultMode", "defaultDepth", " defaultMode", "DefaultLevel", " defaultCl"], "success": ["roll", "accept", "response", "replace", "continue", "results", "message", "warning", "result", "match", "failed", "fail", "resp", "serial", "data", "launch", "submit", "complete", "test", "status", "Success", "reg", "successful", "successfully", "progress", "batch", "error"]}}
{"id1": "11341711", "id2": "4798332", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"makeBackup": ["createBackUp", "makePickup", "makeBackups", "makeCleanUp", "makePickdown", "makeCleanups", "makebackdown", "makeBackdown", "makePickUp", "createbackUp", "makePickups", "createbackups", "createBackup", "makebackUp", "createBackdown", "makebackup", "createbackdown", "makeCleandown", "makeBackUp", "createBackups", "createbackup", "makeCleanup", "makebackups"], "dir": ["directory", "zip", "root", "path", "base", "pkg", "rc", "run", "dest", "manager", "done", "wd", "source", "Dir", "d", "cache", "doc", "up", "diff", "lib", "dist", "group", "build", "work", "config", "store", "file", "ir", "data", "md", "director", "log", "init", "folder", "Directory", "desc", "dict", "io", "name", "db", "DIR", "url", "dep", "module", "download", "direction"], "sourcedir": ["sourcedirs", "sourcesiri", "sodedIR", "seedir", "sodeddir", "sortedIR", "sourcesdir", "ssourcediri", "sourcesir", "sodediri", "sodedir", "sourceddir", "ssourcedIR", "seedIR", "seediri", "sortedirs", "sourcesore", "asourcedIR", "sourcesIR", "ssodedIR", "seeddir", "sortedore", "asourcedir", "sodedore", "sourcediri", "sodedirs", "asourcedirs", "sourcedIR", "asourcedore", "sourcedore", "asortedirs", "sourcesirs", "asortedore", "ssourcedir", "ssourceddir", "ssodeddir", "asortedIR", "asortedir", "ssodedir", "sortedir", "ssodediri"], "destinationdir": ["destinatorfile", "desturationdirection", "destinateDIR", "DestificationDir", "destinatedir", "Destinationdirection", "dominationDIR", "desturationfolder", "Destificationdir", "destinatorDIR", "dominationdir", "destificationfolder", "destinationfolder", "destinationsfile", "Destificationfolder", "Destificationdirection", "destinationdirection", "destinationsDIR", "destificationdirection", "destificationDir", "destinatordir", "destinatefolder", "Destinationfolder", "destinationDIR", "destinationDir", "dominatorDir", "dominatorfile", "dominationfile", "dominationDir", "destinationsdir", "destinatedirection", "destinatefile", "dominatordir", "destificationdir", "Destinationdir", "DestinationDir", "desturationDir", "desturationdir", "dominatorDIR", "destinatorDir", "destinationsDir", "destinationfile", "destinateDir"], "destinationDirEnding": ["destinationDirectoryEnding", "destinationDirENDging", "destinationDirBegining", "destinationDirBeginning", "destinationPathEndging", "destinationDirBeginging", "destinationPathBeginING", "destinationDirectorySignING", "destinationPathBeginging", "destinationDirPassING", "destinationDirBeginING", "destinationPathBegining", "destinationDirectoryEndening", "destinationDirectoryEndING", "destinationDirEndining", "destinationDirEndging", "destinationDirPassging", "destinationDirPassning", "destinationDirectoryEndining", "destinationDirEndening", "destinationDirectorySignening", "destinationDirSignening", "destinationDirSignining", "destinationDirPassing", "destinationDirSignING", "destinationPathBeginning", "destinationDirEndning", "destinationDirectorySigning", "destinationDirLeadING", "destinationDirLeading", "destinationDirLeadening", "destinationDirENDning", "destinationDirEndING", "destinationDirENDING", "destinationPathEndning", "destinationDirectorySignining", "destinationDirENDing", "destinationDirSigning", "destinationPathEnding", "destinationDirBeginining", "destinationDirBeginening", "destinationPathEndING", "destinationDirLeadining"], "files": ["keys", "balls", "index", "services", "locks", "output", "fs", "pages", "docs", "resources", "results", "features", "l", "ins", "Files", "reports", "modules", "errors", "ids", "split", "items", "projects", "its", "uploads", "iles", "users", "lines", "flows", "blocks", "children", "parents", "runs", "strings", "bugs", "names", "classes", "file", "data", "images", "objects", " Files", "models", "ips", "groups", "log", "planes", "ls", "thumbnails", "tests", "types", "rows", "books", "actions", "fields", "rules", "xml", "words", "events", "ps", "sections", "boxes", "links"], "checkdir": ["blockDir", "checkdirectory", "checkd", "calld", "blockdraft", "workdirectory", " checklog", "blockdirectory", "CheckDir", "ckdir", " checkfile", "workdir", "ckDir", "workDIR", "workdraft", "Checkdir", "checkDir", "searchdir", "ckfile", "workfile", " checkDIR", "Checkfile", "lockdir", "searchdirectory", " checkfolder", "workfolder", "calldir", " checkFolder", "workFolder", "ckd", "lockFolder", "checkfolder", "searchDir", " checkd", "checkdraft", "checkFolder", "locklog", "CheckDIR", "checklog", "checkDIR", "lockDir", " checkdirectory", "calldirectory", "ckdirectory", "blockdir", "workDir", "worklog", "ckfolder", "checkfile", "searchdraft", "callfolder", " checkDir"], "date": ["event", "mu", "user", "month", "now", "ge", "ime", "late", "set", "tag", "day", "zone", "time", "ate", "dt", "at", "rate", "d", "doc", "Date", "md", "config", "data", "file", "de", "mate", "open", " Date", "log", "start", "name", "e", "m", "image", "change", "update", "sign", "contact", "state", "age", "dat"], "msec": [" mif", " mSec", "csec", "dseconds", "Msecond", "Mseconds", "mnsec", "css", "lsec", "dsecond", "msecond", " minif", "lseconds", "fmisec", "disec", "fmsecond", "mss", "mnsc", "fmseconds", "rseconds", "csecond", "mseconds", "cseconds", " msc", "lss", "mSec", "mnSec", "rsec", "mnif", "rss", "Msec", " minSec", "msc", " minsc", "mif", " minsec", "lsecond", "Misec", "rsecond", "misec", "dsec", "fmsec"], "checkFile": ["changefile", "workFile", "CheckFile", "workFiles", " checkDirectory", "checkFilename", "CheckDir", " checkfile", " checkFilename", "checkFiles", "checkDir", "ckfile", "workfile", "Checkfile", "checkLine", " checkDir", "controlLine", "changeFilename", "ckFiles", "changeFile", " checkFiles", "controlfile", "controlFile", "changeLine", "ckDirectory", "controlFilename", "CheckFiles", "workDir", "checkDirectory", " checkLine", "checkfile", "CheckDirectory", "ckFile"], "i": ["index", "info", "id", "n", "pi", "uri", "mu", "ini", "ie", "slice", "j", "fi", "ri", "si", "ui", "is", "ii", "key", "qi", "part", "vi", "ti", "ji", "phi", "li", "ip", "x", "p", "bi", "u", "ai", "oi", "ci", "I", "e", "io", "eni", "m", "xi", "di", "gi", "hi", "v", "y", "b", "iu", "multi", "field", "im", "ix"], "f": ["info", "fun", "fe", "sf", "n", "fs", "feed", "cf", "df", "fc", "fi", "j", "fp", "o", "fn", "l", "fr", "fl", "d", "q", "r", "w", "file", "fb", "h", "p", "u", "folder", "e", "m", "t", "F", "fd", "b", "v", "fx"], "g": ["vg", "n", "gd", "gh", "gin", "sg", "gc", "ge", "tg", "rg", "l", "global", "s", "gg", "bg", "gb", "gar", "d", "q", "r", "group", "ger", "w", "erg", "gs", "ig", "file", "gn", "gp", "go", "h", "p", "u", "msg", "e", "m", "t", "G", "gi", "og", "reg", "ga", "gu", "eg", "b", "mg", "ng", "gm", "pg"], "destinationFile": ["destinatorLocation", "DestinationFile", "destationfile", "destinationFilename", "DestificationDir", "destinatorDirectory", "DestationDir", "DestinationFilename", "destiningFile", "destacementDir", "DestificationLocation", "destificationFile", "destacementfile", "destinationDirectory", "destationFilename", "destificationLocation", "destacementFilename", "destinationfile", "destationDir", "destinationLocation", "destinationsFile", "destificationDirectory", "destinatorFile", "DestinationLocation", "Destationfile", "destiningFilename", "destinationDir", "DestificationDirectory", "Destinationfile", "destacementFile", "DestationFile", "DestationFilename", "destiningfile", "destiningDir", "DestinationDir", "destinationsLocation", "destationFile", "destinatorDir", "DestificationFile", "destinationsDir", "destinationsDirectory", "destificationDir", "DestinationDirectory"], "sourceFile": ["srcModule", "SourceDir", "sourceDir", "SourceModule", " sourceDir", " sourceFiles", "srcFile", "ourceFile", "inputFile", "sourceFiles", "ourceFiles", " sourceModule", "inputDir", "SourceFile", " sourceDirectory", "sourcefile", "inputFiles", "ourceDirectory", "srcDir", "sourceModule", "sourceDirectory", " sourcefile", "Sourcefile", "ourceDir", "srcfile", "inputDirectory"], "infile": ["outdir", "inFile", "inputdata", "outstream", "outFile", "inputfile", "diffdir", "indata", " instream", " inFile", "Instream", "winstream", "inputFile", "Inf", "indir", "difffile", "Infile", "diffstream", "outf", "outdata", "winfile", "windir", " indata", "InFile", "instream", "diffFile", "inputf", "inputstream", "inf", "winFile"], "outfile": ["intfile", "outline", " outpage", "outpage", "againpage", " outfunction", "againFile", "intstream", "outstream", "outFile", "inputfile", " outFile", " outstream", "outlive", "inputFile", "exstream", "intlive", "inputfunction", "againstream", "exfile", "Outlive", "Outfunction", "exFile", "againfile", "Outline", "expage", "intFile", " outlive", "Outstream", "OutFile", "inputline", "outfunction", "Outfile", " outline"], "c": ["index", "string", "cu", "id", "n", "rc", "enc", "character", "cont", "z", "end", "o", "col", "l", "in", "char", "ec", "cm", "d", "lc", "uc", "ct", "r", "ch", "cy", "w", "channel", "ice", "xc", "cl", "h", "x", "p", "C", "u", "e", "m", "ci", "t", "cr", "pointer", "esc", "dec", "pc", "a", "abc", "k", "comment", "v", "b", "ac", "code"]}}
{"id1": "18962382", "id2": "7458833", "code1": "    protected void connect() throws SocketException, IOException, LoginFailException {\n        logger.info(\"Connect to FTP Server \" + account.getServer());\n        client = new FTPClient();\n        client.connect(account.getServer());\n        if (client.login(account.getId(), account.getPassword()) == false) {\n            logger.info(\"Fail to login with id=\" + account.getId());\n            throw new LoginFailException(account.getId(), account.getPassword());\n        }\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"connect": ["close", "ssh", "setup", "timeout", "register", "add", "con", "connected", "socket", "run", "Connect", "host", "set", "write", " connection", " reconnect", " disconnect", "select", "sync", "construct", "login", "connection", "open", "config", "bind", "request", "log", "conn", "init", "start", "exec", " login", "link", "access", "ping", "localhost", "auth", " close", "create", "download", "boot", "stop"], "IOException": ["IOEx", "IPException", "SSLException", " IOEx", "SSLEx", "IPEx"], "LoginFailException": ["LoginPassException", "LoginPassCause", "LoginReadception", " LoginFlowEvent", " LoginFailception", "LoginFlowException", "LoginFailception", "LoginWaitExc", "LoginFlowExc", " LoginFlowException", "LoginFailCause", "LoginFailExc", "LoginPassEvent", "LoginPassception", "LoginFailEvent", "LoginFlowception", " LoginFailExc", "LoginFlowEvent", "LoginPassExc", " LoginFailCause", "LoginWaitException", "LoginReadException", "LoginReadEvent", "LoginReadCause", " LoginFlowExc", " LoginFailEvent", "LoginWaitception", " LoginFlowCause", " LoginFlowception", "LoginFlowCause"], "client": ["remote", "ssl", "core", "handler", "ace", "server", "console", "resource", "clean", "http", "net", "con", "c", "socket", "pool", "manager", "friend", "session", "cache", "lib", "proxy", "ce", "connection", "config", "parent", "cl", "web", "request", "local", "conn", "plugin", "port", "call", "pc", "app", "url", "Client", "cn", "container", "cli", "service", "api", "cell"]}}
{"id1": "7945594", "id2": "20519261", "code1": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 1, "substitutes": {"fileDownload": ["filePull", " filedownload", " fileURL", "urlURL", "folderdownload", "folderDownload", "folderURL", "filedownload", "urlDownload", "urlPull", "fileURL", " filePull", "urldownload", "folderPull"], "fAddress": ["sfOrder", "rfMessage", "urlOrder", " fPath", "fEmail", "baddress", "FAddress", "fileAddress", "FAdd", "sfPath", " fMessage", "FLocation", "faddr", "urladdress", "rfaddress", "sfAdd", " fEmail", "fingaddr", "bAdd", "urlAdd", "fingEmail", "sfLocation", "sfaddress", "fileAdd", "bPath", "fOrder", "fPath", "fingAdd", "fMessage", "rfLocation", "faddress", "fLocation", "sfAddress", "bLocation", " fAdd", "baddr", "fingAddress", "urlAddress", "bAddress", "bEmail", "fAdd", "sfMessage", " fOrder", "fileLocation", " faddress", "rfAddress", " fLocation", " faddr"], "destinationDir": ["destributionDur", "destativeDIR", "DestributionDir", "destinatedDar", "declinationDur", "declinatedPath", "destativeArea", "declinatedDar", "DestinationDIR", "destinatedDir", "destinationDirectory", "destinationDar", "destinationDur", "destributionDirectory", "destributionDar", "destinatedPath", "destinePath", "destinationPath", "declinationDar", "destributionDIR", "destineDir", "destinationArea", "DestinationArea", "destippingArea", "DestributionArea", "destinationDIR", "declinationDir", "destinatedDur", "destativeDir", "destippingDir", "destributionPath", "destativeDirectory", "destineDur", "declinationPath", "destineDar", "destippingDIR", "DestinationDir", "destributionArea", "declinatedDir", "DestributionDIR", "DestributionDirectory", "destributionDir", "destippingDirectory", "declinatedDur", "DestinationDirectory"], "slashIndex": ["Slashedindex", "SlashLength", "slashedIndex", "slashLength", "SlashCount", "SlashIndex", "SlashedCount", "slushLength", "slashedCount", "slushIndex", "slargeindex", "slargeLength", "Slashindex", "slushindex", "sllashCount", "slargeCount", "slashedindex", "SlashedLength", "slargeIndex", "slashindex", "sllashindex", "sllashLength", "slashCount", "sllashIndex", "slashedLength", "SlashedIndex"], "periodIndex": ["moneyStart", "moneyindex", "dollarindex", " periodStart", "periodStart", "dollarIndex", " periodindex", "moneyIndex", "moneyOffset", "periodindex", " periodOffset", "dollarOffset", "periodOffset", "dollarStart"], "fileName": [" filePath", "FilePath", "filePath", " fileAddress", "fname", "fPath", "fName", "fileAddress", "FileAddress", "Filename", "FileName", "filename", " filename"], "url": ["path", "string", "base", "ssl", "ou", "server", "uri", "resource", "feed", "user", "http", "c", "socket", "rel", "l", "URL", "uu", "fl", "proxy", "up", "connection", "oc", "str", "ch", "ob", "open", "config", "org", "li", "channel", "web", "page", "ll", "bel", "log", "u", "conn", "image", "re", "blog", "link", "sl", "rl", "Url", "www", "bug", "ur", "ul", "download", "f", "plug", "service", "api", "loc"], "uc": ["anc", "cu", "ou", "tc", "cc", "sc", "um", "rc", "http", "con", "c", "fc", "uu", "nc", "cus", "ec", "union", "lc", "auc", "connection", "oc", "exc", "usc", "u", "conn", "ci", "uci", "ucc", "pc", "mc", "soc", "bc", "com", "stream", "cci", "ac", "UC", "ul", "unc", "hub", "cur"], "in": ["IN", "i", "input", "n", "rc", "ini", "gin", "into", "con", "c", "inner", "socket", "ins", "s", "bin", "is", "reader", "source", "up", "login", "inside", "r", "inc", "data", "conn", "init", "again", "io", "image", "it", "In", "nin", "stream", "lin", "b", "ac", "err", "cin", "inn", "f", "cli", "this", "din"], "file": ["zip", "path", "letter", "base", "class", "fe", "output", "resource", "ile", "filename", "per", "socket", "place", "fp", "o", "l", "line", "File", "source", "rule", "dir", "up", "book", "connection", "FILE", "parent", "data", "page", "log", "name", "folder", "e", "io", "to", "full", "files", "b", "f", "this"], "fos": ["fops", "fileOs", "sfis", "sfOS", "sfo", " fops", "FOs", "FOS", " fOs", " fOS", "Fis", "Fos", "fob", "fOs", "fileops", "fileob", "fo", " fis", " fob", "sfos", "Fops", "Fo", " fo", "fOS", "Fob", "fileos", "fis"], "out": ["string", "ou", "outer", "output", "copy", "net", "plain", "OUT", "inner", "o", "outs", "s", "line", "write", "bin", "sync", "up", "w", "work", "data", "inc", "down", "log", "init", "again", "exec", "Out", "io", "writer", "to", "flush", "update", "err", "b", "block", "f"], "inputLine": ["outputL", "outputRow", "inputRow", " inputRow", " inputBlock", "errorRow", " inputLINE", "outputline", "InputEl", "outputBlock", "inputEl", "InputLine", "Inputline", "errorL", "inputBlock", "InputBlock", "errorLINE", "inputL", "outputEl", "InputChar", " inputline", "InputL", " inputEl", "inputChar", " inputChar", "outputLine", "inputline", "outputChar", "outputLINE", "inputLINE", " inputL", "errorLine"]}}
{"id1": "16820041", "id2": "6008635", "code1": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "code2": "    public boolean referredFilesChanged() throws MalformedURLException, IOException {\n        for (String file : referredFiles) {\n            if (FileUtils.isURI(file)) {\n                URLConnection url = new URL(file).openConnection();\n                if (url.getLastModified() > created) return true;\n            } else if (FileUtils.isFile(file)) {\n                File f = new File(file);\n                if (f.lastModified() > created) return true;\n            }\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"encodePassword": ["enoderpassword", "enodedSecret", "encodeSecret", "enccodeSecret", "enodedPassword", "enccodePassword", "enccodepassword", "enccodeString", "enoderPassword", "enoderString", "encodeString", "enodeSecret", "enoderSecret", "encodepassword", "enodedString", "enodeString", "enodedpassword", "enodePassword", "enodepassword"], "_originalPassword": ["_actualPass", "_origPassword", "_origPass", " _originalSecret", "_OriginalSalt", "_encryptedPass", " _originalPass", "_OriginalPassword", "_originalSecret", "theorigpassword", "_origpassword", "_actualPassword", "theoriginalSalt", " _actualSecret", "_encryptedpassword", "_originalpassword", "theoriginalPassword", "_encryptedSalt", "_origSalt", "_editedSecret", "_encryptedPassword", "theorigPassword", "_originalPass", "_editedPassword", "_OriginalPass", " _actualPassword", " _actualPass", "theoriginalPass", "theorigSalt", "_originalSalt", "_editedPass", "_OriginalSecret", "_actualSecret", "_Originalpassword", "theorigPass", "theoriginalpassword"], "md": ["id", "gd", "mag", "bd", "od", "df", "Cmd", "amd", "mo", "kg", "ma", "meta", "dr", "MD", "dc", " MD", "ld", "sm", "ad", "ms", "gb", "cm", "mb", "mt", "dh", "mac", "d", "mp", "hd", "sha", "pm", "sd", "cmd", "data", "mm", "metadata", "cd", "dig", "m", "hm", "dm", "db", "mand", "mc", "alg", "mn", "mod", "vd", "ph", "pad", "mg", "mad", "pd", "dd", "hash", "code"], "encodedPassword": ["enoderpassword", "encoderPass", "encoredString", "enodedSecret", "enodedPassword", "encryptedpassword", "encidedpassword", "encidedPassword", "encachedString", "encodedString", "encodedPass", "encryptedPassword", "ecryptedPassword", "encachedSecret", "encoredPassword", "enryptedpassword", "encoredSecret", "ecryptedString", "enccodedPass", "encachedPassword", "enoderPassword", "encidedPass", "encapedString", "enccodedPassword", "encodedSecret", "ecodedString", "encodedpassword", "encapedPassword", "enryptedPass", "encryptedPass", "encoderSecret", "encoderString", "encryptedString", "encapedPass", "enoderSecret", "enodedPass", "enodedString", "encryptedSecret", "encapedpassword", "enoderPass", "ecodedPassword", "enccodedpassword", "enodedpassword", "ecodedSecret", "enryptedString", "enryptedPassword", "encoderPassword", "enccodedSecret", "ecryptedSecret", "encidedSecret", "encoderpassword"]}}
{"id1": "8132219", "id2": "17557289", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "inFile": ["inputPlace", " inSourceFile", "InSourceFile", "INfile", "binfile", "outPlace", "inputfile", "outfile", " infile", "infile", "inputFile", "outFiles", "InFilename", " inFilename", "Infile", "inFiles", "inPlace", "inputFiles", "binFiles", "binFile", "INFile", "binPlace", "InFile", "INSourceFile", "inFilename", "inSourceFile", "INFilename"], "outFile": ["againFilename", "outputFilename", "outputfile", "againFile", " outfile", "outPlace", "outfile", "infile", "outFiles", "outputPlace", " outFilename", "inFiles", "againfile", " outFiles", "outputFiles", "againPlace", "outFilename", "inFilename", "outputFile", " outPlace"], "in": ["IN", "index", "pin", "base", "i", "input", "id", "n", "ini", "ic", "c", "inner", "as", "ins", "bin", "is", "part", "like", "reader", "source", "connection", "inc", "work", "data", "file", "config", "rin", "x", "name", "again", "m", "image", "io", "In", "a", "url", "inn", "f", "din"], "out": ["string", "buffer", "ex", "output", "n", "copy", "resource", "user", "Output", "plain", "c", "OUT", "version", "o", "outs", "write", "line", "bin", "client", "part", "cache", "dot", "default", "w", "data", "file", "x", "p", "log", "null", "conn", "name", "exec", "Out", "io", "image", "writer", "to", "call", "prefix", "ext", "v", "b", "obj", "external"], "inChannel": ["sinSocket", "INSocket", "inSocket", "inputChannel", "INchannel", "iniChannel", "inStream", " inFlow", " inchannel", "inputchannel", "inchannel", "INFlow", "sinChannel", "inLanguage", "sinChan", "iniLanguage", "winLanguage", "inputChan", "iniStream", "INChan", "outStream", "outchannel", "outChan", "inChan", "inputStream", "inichannel", "outConnection", "INStream", "winChannel", "winchannel", " inConnection", "INChannel", "inConnection", " inChan", "winStream", "sinFlow", " inSocket", "inFlow", "INConnection", "outLanguage"], "outChannel": [" outContext", "OutStream", "againChannel", "OutConnection", "OutChannel", "inchannel", "outContext", " outConnection", "againPath", "againChan", "OutChan", "outStream", "outchannel", "inPath", "outChan", "inChan", "outPath", "OutContext", "outputchannel", "outputChannel", " outPath", "outConnection", "newStream", "Outchannel", "newChan", "againchannel", "outputChan", "inConnection", " outStream", "newContext", "newChannel", " outchannel", " outChan"]}}
{"id1": "2668853", "id2": "16825994", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFiletoFiles", "decodeFileAsStream", "decodeString2file", "decodeFile2Stream", "decodeFiletoFile", "decodeFileToStream", "decodeFiletofile", "decodeFileAsFiles", "decodeFileTofile", "decodeStringToFile", "decodeStringTofile", "decodeStringToStream", "decodeFileAsFile", "decodeString2Stream", "decodeFile2File", "decodeString2File", "decodeFileAsfile", "decodeFiletoStream", "decodeFileToFiles", "decodeFile2file", "decodeStringToFiles", "decodeString2Files", "decodeFile2Files"], "infile": ["minfile", "infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", "inputfp", " inFile", "inputFile", "outfiles", " infilename", "inputfiles", " infiles", "outfp", "minfilename", "minFile", "minfp", "inputfilename", "infilename"], "outfile": ["infp", "outfull", "outputfile", " outfull", "outfilename", "outFile", " outFile", "infolder", "outputfolder", " outfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "outputfull", "Outfull", "Outfolder", "OutFile", "Outfile", "outputFile", "infilename", " outfilename"], "in": ["IN", "pin", "i", "input", "inas", "ex", "ini", "gin", "ic", "con", "inner", "socket", "as", "ins", "s", "bin", "is", "reader", "source", "up", "login", "min", "inside", "r", "inc", "data", "rin", "init", "conn", "again", "m", "e", "image", "re", "In", "nin", "a", "lin", "err", "b", "ac", "cin", "inn", "f", "win", "this", "din"], "out": ["base", "ex", "output", "copy", "outer", "op", "lock", "on", "net", "OUT", "socket", "as", "inner", "outs", "o", "s", "off", "line", "write", "bin", "co", "pass", "exit", "post", "client", "sync", "session", "no", "cache", "lib", "up", "target", "other", "inc", "work", "file", "conn", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "exp", "In", "ext", "b", "obj", "err", "error", "point"], "buffer": ["address", "base", "input", "Buffer", "uffer", "resource", "pause", "border", "server", "feed", "slice", "limit", "result", "length", "bin", "memory", "queue", "offset", "iter", "split", "reader", "source", "binary", "seed", "buff", "value", "buf", "wave", "data", "size", "bb", "null", "row", "bytes", "layer", "flush", "url", "shape", "b", "reference", "padding", "pad", "transfer", "batch"], "read": ["index", "Read", " receive", " r", "run", "ride", " get", "open", " copy", "get", "lex", " send", " check", "id", "feed", "add", "ind", "end", "find", " reach", "next", "sync", "use", "load", " sleep", "r", "work", "fill", "exec", "skip", "connect", " request", "play", " use", "reading", " parse", "limit", "se", "length", "write", "line", "ad", "sleep", "iter", "allow", "reader", " Read", "start", "tell", " load", "wait", " write", "input", "copy", " connect", "current", "reads", "pass", "select", " ride", "seek", "inc", " find", "check", "x", "size", " reader", "send", "k", "parse", "count", "READ"], "success": ["roll", "accept", "job", "response", "rolling", "ok", "continue", "ceed", "results", "warning", "better", "yes", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "selected", "default", "data", "safe", "null", "cess", "danger", "complete", "again", "status", " successful", "full", "correct", "good", "Success", "successful", "successfully", "rolled", "found", " succ", "zero", "error", "fast", "first", "winner", "initial"]}}
{"id1": "5061606", "id2": "14820302", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNequessnecessary", "createSettingsIfNececarily", "createSettingsIfNecccessnecessary", "createSettingsIfNecesnecessary", "createSettingsIfNecccesseless", "createSettingsIfNecccessarily", "createSettingsIfNecessnecessary", "createSettingsIfNecesary", "createSettingsIfNequccessarily", "createSettingsIfNequccessnecessary", "createSettingsIfNecessarily", "createSettingsIfNecccessary", "createSettingsIfNeceseless", "createSettingsIfNecesseless", "createSettingsIfNequessarily", "createSettingsIfNequessary", "createSettingsIfNececnecessary", "createSettingsIfNececeless", "createSettingsIfNequesseless", "createSettingsIfNececary", "createSettingsIfNecesarily", "createSettingsIfNequccesseless", "createSettingsIfNequccessary"], "out": ["index", "path", "i", "ex", "output", "copy", "server", "editor", "user", "timeout", "by", "lock", "net", "plain", "OUT", "socket", "result", "outs", "o", "window", "pool", "write", "off", "bin", "exit", "password", "sync", "client", "at", "source", "cache", "up", "connection", "model", "group", "parent", "data", "file", "channel", "config", "page", "object", "log", "null", "conn", "init", "plugin", "again", "name", "exec", "Out", "io", "writer", "image", "array", "prefix", "a", "flush", "app", "url", "err", "obj", "cookie", "error", "this"], "fSettings": ["rfFs", "sfSetting", "FConfig", "fsettings", "fJs", " fFs", " fettings", "sfsettings", "fsConfig", " fSetting", "fFs", "FSetting", "filesettings", " fJs", "fsFs", "fileSettings", "fettings", "fsSetting", "fSetup", "rfSettings", "FSetup", " fConfig", "fmConfig", "fileettings", "FJs", " fsettings", "rfSetting", "fmSetup", "fileSetting", "Fsettings", "fsSettings", "sfJs", "FSettings", "sfettings", "fConfig", "fmSetting", "sfSettings", "fsSetup", "fSetting", "rfConfig", "fmSettings"], "src": ["path", "string", "base", "sel", "ssl", "sc", "uri", "rc", "lower", "settings", "filename", "ref", "cb", "dest", "fp", "loc", "ins", "prot", "sub", "req", "gb", "rb", "source", "sb", "uc", "ctr", "dist", "str", "config", "file", "tmp", "attr", "route", "text", "storage", "sl", "url", "stream", "ource", "b", "st", "cur", "sr", "img"], "in": ["IN", "index", "path", "sin", "i", "input", "n", "copy", "id", "ini", "gin", "con", "c", "inner", "l", "ins", "s", "bin", "source", "reader", "thin", "login", "connection", "r", "inc", "data", "file", "rin", "init", "again", "image", "In", "kin", "url", "stream", "b", "err", "inn", "f", "win", "din"]}}
{"id1": "19687456", "id2": "22536033", "code1": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"testReadPerMemberSixSmall": [" testReadPerMemberFourSquare", " testReadPermembersixsmall", " testReadPermembersixSquare", " testReadPermemberSixSmall", " testReadPerMemberFoursmall", " testReadPerMembersixsmall", " testReadPerMemberFourSmall", " testReadPermemberSixsmall", " testReadPerMemberSixsmall", " testReadPerMembersixSmall", " testReadPerMemberSixSquare", " testReadPermembersixSmall", " testReadPermemberSixSquare", " testReadPerMembersixSquare"], "gzin": ["zzin", "zigwith", "zipout", "cigin", "cgiin", "cfginn", "sslin", "cginin", "zlin", "ssldin", "cigIN", "qqdin", "zin", "zzIN", "zlIn", "qqins", "zdin", "zini", "gzout", "gzarin", "znin", "cfgIn", "ziparin", "zigIn", "zzinas", "zins", "gzIn", "ezinas", "syncout", "gtout", "wxarin", "zIN", "cigarin", "zout", "gtnin", "qqIN", "zzdin", "sslinn", "wxIN", "cfgwith", "wxin", "gzdin", "zipin", "cfgin", "cgiinas", "gcIn", "sslIN", "eznin", "zznin", "cgiIN", "ezIN", "gzIN", "zzini", "gtini", "gtin", "zlwith", "ziginn", "gzini", "gzins", "qqin", "qqIn", "wxout", "syncdin", "zzout", "zIn", "zlinn", "zzinn", "zigdin", "ezin", "zipIN", "zigIN", "gznin", "qqout", "cigout", "gzinn", "gcIN", "gcout", "gzinas", "gcin", "syncin", "zigin", "gzwith", "syncins"], "i": ["index", "info", "mu", "n", "pi", "uri", "ie", "c", "j", "fi", "o", "si", "ui", "ii", "ti", "ji", "d", "phi", "chi", "li", "ip", "h", "p", "bi", "u", "ai", "oi", "ci", "I", "m", "e", "io", "zi", "xi", "di", "gi", "hi", "v", "b", "ni", "count", "iu", "multi", "f", "mini", "api"], "count2": ["Count2", "count4", "CountTwo", "count5", "sum1", "name2", "name1", "Count02", " count5", "Count5", "sum2", "countTwo", "Count4", "sum4", "count02", "sumTwo", "Count1", " count4", " countTwo", "name02", " count1", " count02", "name5", "count1"], "count3": ["sum3", "sum5", "cache2", "size3", "count83", "count5", "sum1", "err3", " count5", "count303", "size2", "size83", "size303", " count15", " count83", "cache83", "cache303", "cache3", " count1", "sum15", "err15", "count15", "count1", "err5", " count303", "err1"], "countEnd": ["sizeStart", "refEND", "sizeEnd", "CountStart", "sizeend", "Countend", "lenEnd", "CountEnd", "countend", "refStart", "CountBegin", "countEND", " countEND", "lenend", " countBegin", " countend", "lenBegin", "sizeEND", "countBegin", "refend", "lenEND", "refEnd", "CountEND", "countStart"]}}
{"id1": "647224", "id2": "2668634", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"uploadFile": ["uploadfile", "processFile", "UploadFiles", "UploadDir", " uploadDir", "Uploadfile", "uploadFiles", "uploadDir", " uploadfile", "processDir", "processfile", " uploadFiles", "processFiles", "UploadFile"], "inputFile": ["inputFolder", "targetFolder", "initialFile", "sourceLog", " inputDir", "targetLog", "sourceType", "InputDir", "targetPage", "inputFilename", "inputfile", "sourcePage", " inputfile", " inputType", "sourceFolder", "targetFiles", "initialFilename", "sourceFile", "InputType", "targetfile", "inputLog", "InputFile", " inputFilename", " inputStream", "inputDir", "targetDir", "targetStream", " inputPage", "inputStream", " inputFolder", "inputFiles", "sourcefile", "InputFolder", "inputType", "sourceStream", "targetFilename", " inputLog", "InputFiles", "initialStream", "inputPage", " inputFiles", "initialFolder", "InputStream", "Inputfile"], "targetFile": [" targetFiles", "inputPlace", "targetName", "Targetfile", "sourceDir", "externalPath", "TargetLine", "externalfile", "sourcePath", "TargetPath", "targetPlace", "targetFiles", " targetName", "outputPath", "sourceFile", " targetfile", "targetfile", " targetDir", " targetPlace", "TargetFiles", "inputPath", "TargetDir", "inputDir", "targetDir", "targetPath", "TargetFile", "externalName", "outputFiles", "TargetName", "sourcePlace", "outputName", "outputDir", " targetLine", "outputLine", "targetLine", "externalFile", " targetPath"], "outputFile": ["inputFolder", " targetFiles", "outFolder", "writeUrl", " outputUrl", "outputfile", "outputFolder", " targetQueue", "outPlace", "outFile", "inputfile", "outfile", "OutputFolder", "writePage", "inputUrl", " outputFolder", "currentFolder", "targetFiles", "outputQueue", "outputPlace", "outputPath", "writeFile", "targetfile", "inputPath", " targetDirectory", " outputDirectory", "currentPlace", "inputDir", "targetPath", " outputStream", "OutputDir", " outputPath", "currentfile", "outPath", " outputPage", " outputfile", "outputStream", "inputStream", "inputFiles", " outputFiles", " outputDir", " outputPlace", "outputFiles", "outDirectory", "inputDirectory", "writeStream", "Outputfile", "outputDirectory", "targetDirectory", "outputUrl", "outputDir", "currentFile", "inputQueue", "outputPage", "inputPage", "OutputFile", "targetQueue"], "in": ["IN", "pin", "i", "input", "id", "serv", "ini", "con", "inner", "sub", "ins", "s", "bin", "pass", "is", "read", "reader", "source", "up", "login", "diff", "inside", "r", "inc", "data", "rin", "init", "rec", "issue", "again", "io", "isin", "In", "nin", "kin", "pull", "url", "stream", "lin", "err", "ac", "cin", "inn", "win", "din"], "out": ["base", "console", "ex", "output", "sys", "n", "copy", "user", "lock", "by", "report", "outer", "net", "plain", "table", "OUT", "inter", "inner", "outs", "o", "s", "write", "off", "bin", "co", "sync", "client", "one", "source", "cache", "up", "r", "ger", "inc", "cmd", "file", "data", "page", "log", "conn", "again", "exec", "Out", "io", "writer", "image", "to", "dump", "ext", "err", "println", "print", "state", "error", "this", "point"], "line": ["string", "buffer", "base", "job", "lf", "lock", "entry", "LINE", "limit", "write", "pass", "ine", "char", "split", "sync", "part", "type", "rule", "lines", "lc", "data", "file", "page", "le", "inline", "log", "row", "name", "header", "e", "frame", "word", "link", "url", "pe", "unit", "comment", "lin", "Line", "range", "block", "error", "code", "cell"], "bytes": ["zip", "i", "pages", "tes", "comments", "les", "number", "outs", "steps", "length", "s", "bs", "reads", " lines", "items", "lines", "binary", "blocks", "bps", "len", "eps", "classes", "size", "ips", "es", "groups", "Bytes", "ls", "ones", "cycles", "seconds", "pos", "ines", "rows", "values", "files", "count", " cycles", "units", "words", "os", "bits", "odes", "codes", "code"]}}
{"id1": "18989018", "id2": "21531069", "code1": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "code2": "    public int updateuser(User u) {\n        int i = 0;\n        Connection conn = null;\n        PreparedStatement pm = null;\n        try {\n            conn = Pool.getConnection();\n            conn.setAutoCommit(false);\n            pm = conn.prepareStatement(\"update user set username=?,passwd=?,existstate=?,management=? where userid=?\");\n            pm.setString(1, u.getUsername());\n            pm.setString(2, u.getPasswd());\n            pm.setInt(3, u.getExiststate());\n            pm.setInt(4, u.getManagement());\n            pm.setString(5, u.getUserid());\n            i = pm.executeUpdate();\n            conn.commit();\n            Pool.close(pm);\n            Pool.close(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            Pool.close(pm);\n            Pool.close(conn);\n        } finally {\n            Pool.close(pm);\n            Pool.close(conn);\n        }\n        return i;\n    }\n", "label": 0, "substitutes": {"doSetInput": ["dosetOutput", " doGetContent", "doProcessOutput", "doProcessInput", " doGetText", " doSetContent", "doSetText", "dosetInput", "doGetInput", "doSetContent", " doSetText", "dosetText", "doSetOutput", "doProcessText", "doGetText", " doGetInput", " doGetOutput", " doSetOutput", "doGetContent", "doGetOutput", "dosetContent", "doProcessContent"], "input": ["impl", "IN", "head", "audio", "method", "error", "agent", "temp", "output", " inputs", "resource", "entry", "enter", "remote", "act", "inner", "current", "argument", "project", "present", "instance", "child", "magic", "util", "active", "key", "raw", "form", "client", "install", "select", "expression", "type", "reader", "session", "Input", "q", "inf", "model", "upload", "parser", "config", "inc", "text", "request", "img", "context", "null", "insert", "submit", "exec", "image", "initial", "operator", "pull", "container", "command", "xml", "progress", "field", "element", "definition", "list", "view", "storage"], "monitor": ["directory", "pin", "method", "loader", "handler", "console", "resource", "timeout", "report", "subject", " Monitor", "system", "watch", "wm", "manager", "condition", "mon", "client", "cm", "reader", "Monitor", "pm", "counter", "config", "channel", "timer", " monitors", "out", "mx", "mi", " monitoring", "p", "metadata", "m", "meter", "dm", "mc", "unit", "processor", "summary", "bm", "progress", "state", "mod", "callback", "module", "param"], "root": ["directory", "base", "node", "remote", "server", "resource", "output", "n", "http", "slave", "table", "system", "library", "result", "instance", "location", "host", "manager", "owner", "tx", "cms", "cover", "target", "media", "r", "collection", "work", "config", "parent", "out", "roots", "Root", "store", "archive", "region", "src", "p", "null", "plugin", "or", "folder", "m", "writer", "home", "array", "mount", "container", "process", "this", "storage"], "format": ["event", "base", "class", "string", "temp", "handler", "output", "spec", "filename", "version", "et", "act", "location", "fn", "record", "magic", "util", "Format", "pattern", "form", "filter", "at", "type", "FORM", "model", "feature", "parser", "config", "data", "term", "object", "ant", "style", "plugin", "title", "template", "name", "image", "writer", "function", "transform", "unit", "atter", "f", "attribute", "element", "service", "api"], "source": ["string", "remote", "node", "info", "id", "resource", "output", "spec", "Source", "token", "description", "slice", "inner", "result", "instance", "driver", "via", "SOURCE", "content", "client", "rate", "session", "reader", "use", "rule", "proxy", "connection", "target", "component", "scope", "config", "data", "src", "text", "channel", "parent", "object", "size", "image", "secure", "unit", "reference", "container", "ource", "service", "view", "storage"], "in": ["IN", "index", "pin", "resource", "token", "ini", "on", "ins", "bin", "get", "conn", "it", "container", "element", "ource", "download", "din", "buffer", "id", "read", "connection", "min", "value", "inside", "r", "str", "parent", "again", "name", "isin", "In", "inn", "win", "i", "n", "gin", "slice", "con", "inner", "socket", "session", "reader", "doc", "body", "src", "p", "init", "or", "m", "image", "io", "nin", "update", "version", "c", "pass", "is", "login", "inc", "config", "data", "text", "out", "pull", "include", "err", "f", "from", "img"], "path": ["index", "base", "loader", "resource", "token", "host", "content", "thin", "component", "model", "mount", "PATH", "container", "step", "point", "string", "id", "location", "sync", "part", " filename", "binary", "dir", "value", "str", "ath", "work", "alias", "parent", "route", "object", "name", "walk", "link", "full", " Path", "directory", "remote", "node", "core", "slice", "Path", "password", "session", "reader", "one", "true", "src", " string", "p", "template", "image", "method", "api", "filename", "child", "key", "pattern", "type", "config", "data", "text", "out", "log", "folder", "port", "pointer", "this", "code", "loc"], "s": ["services", "ssl", "i", "sf", "n", "sys", "fs", "spec", "settings", "http", "ns", "slice", "c", "S", "o", "l", "abs", "si", "sharing", "sync", "an", "session", "d", "ws", "sb", "sa", "scope", "r", "sv", "g", "store", " storage", "share", "src", "gs", "h", "stores", "p", "ls", "folder", "m", "e", "js", "ss", "sl", "secure", "sym", "v", "b", "ds", "os", "f", "ps", "service", "space", "storage"], "file": ["directory", "string", "info", "base", "node", "remote", "sf", "resource", "copy", "feed", "ile", "output", "filename", "slice", "fp", "l", "fn", "il", "File", "Image", "content", "icon", "use", "binary", "dir", "up", "lib", "value", "media", "FILE", "store", "section", "data", "archive", " File", "open", "object", "x", "p", "folder", "name", "e", "image", "port", "io", "full", "files", "pe", "unit", "audio", "b", "future", "xml", "f", "storage"], "uri": ["base", "address", "handler", "i", "id", "resource", "pi", "username", "server", "entry", "http", "filename", "uid", "ri", " URI", "location", "URL", "query", "ui", "util", "database", "qi", "rule", "dir", "connection", "data", "text", "route", "term", "object", "uni", "name", "io", "image", "iri", "prefix", "gi", "Url", "range", "abi", "attribute", "cli", "URI", "service", "api", "storage"], "url": ["string", "address", "base", "ssl", "id", "resource", "user", "http", "ref", "rel", "ri", "l", "location", "URL", "fr", "key", "sr", "str", "store", "config", "data", "channel", "src", "text", "object", "name", "image", "io", "link", "sl", "layer", "Url", "ul", "ource"], "cd": ["cc", "gd", "cf", "clean", "rc", "ck", "c", "lab", "cb", "co", "dr", "dc", "cm", "cp", "arch", "ce", "d", "xd", "ct", "CE", "cy", "md", "CD", "ca", "de", "xc", "nd", "CS", "C", "cand", "DC", "ci", "cr", "CR", "CC", "CF", "vd", "cs", "ds", "def", "pd", "dd"], "valid": ["val", "defined", "id", " invalid", "broken", "vari", "current", "Valid", "standard", "present", "all", " Valid", "active", "pattern", "iter", "post", "visible", "value", "legal", "data", "regular", "vals", "local", "empty", "multiple", "style", "complete", "Invalid", "allowed", "stable", "available", "normal", "array", "good", "full", "bad", "compatible", "correct", "supported", "secure", "required", "v", "sign", "missing", "successful", "def", "multi", "acceptable", "cert", "VAL", "list"], "stream": ["string", "handler", "temp", "video", "resource", "feed", "response", "output", "clean", "message", "draw", "flow", "trans", "read", "content", "raw", "form", "client", "reader", "serial", "model", "Stream", "data", "channel", "body", "object", "context", "row", "image", "writer", "v", "container", "sw", "transform"], "document": ["video", "output", "response", "resource", "feed", "Source", "filename", "description", "system", "author", "record", "content", "material", "reader", "doc", "Filename", "Reader", "media", "model", "collection", "parent", "data", "text", "object", "metadata", "style", "ocument", "template", "image", "writer", "io", "_", "xml", "Document", "this"]}}
{"id1": "7872659", "id2": "6470716", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieIndexPath", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndmovieindexfile", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndmovieIndexfile"], "completePath": ["execVol", "correctCorp", " CompleteHome", "execLoader", "execPath", " completeRoot", "CompleteDir", "itepath", "donePath", "CompletePath", "itePath", " completeFile", "progresspath", "completeCh", "completeLoader", "successCh", "completeHome", " completeCorp", "doneVol", "completeVol", "flatCorp", "completepath", "completeMusic", "correctPath", "execpath", "flatPoint", " completeCh", " CompletePath", " completeHome", "completeCorp", "progressPath", "CompleteHome", " CompleteFile", "completePoint", "successPath", "correctRoot", "completeRoot", " CompleteDir", "successMusic", "CompleteFile", "iteCh", "flatPath", "progressVol", "flatRoot", " completeMusic", "progressLoader", "correctPoint", "donepath", " completeDir", "completeDir", "successpath", " completepath", "completeFile", "iteMusic", "doneLoader", " completePoint"], "masterFile": ["MasterFILE", "mastersFILE", "masterPath", "mastersFile", "MasterPath", "configPath", " masterFilename", "masterFILE", " masterName", "mastersPath", "masterFiles", "cacheFiles", "configName", "MasterFile", "cacheFile", "cachePath", "MasterName", "configFile", "cacheFILE", "MasterFiles", "MasterFilename", "mastersFiles", "masterFilename", " masterPath", "configFilename", "masterName"], "CustRatingFileName": ["CustRatingFilesPath", "CustIndexFileVersion", "CustIndexFilesName", "CustRateFilenameSize", "CustRatingFullName", "CustRatingFilesType", "CustRateFileName", "CustRatingClassType", "CustIndexFilesVersion", "CustRatingFilenameDesc", "CustRatingClassName", "CustRatingClassVersion", "CustRatingFilesName", "CustRatingLineType", "CustRatingFileVersion", "CustIndexFilePath", "CustRateFileDesc", "CustRatingFullSize", "CustRatingFilesDesc", "CustRatingFileDesc", "CustIndexFileName", "CustRatingLineVersion", "CustRatingFilenameSize", "CustRatingFilenamePath", "CustRatingLinePath", "CustRatingFilenameName", "CustIndexFilesPath", "CustRatingFullPath", "CustRatingClassPath", "CustIndexFilesType", "CustRatingLineName", "CustRatingFileType", "CustRateFilenamePath", "CustRateFilePath", "CustRatingFileSize", "CustRateFilenameDesc", "CustRateFilenameName", "CustIndexFileType", "CustRatingFilePath", "CustRatingFullDesc", "CustRateFileSize", "CustRatingFilesSize", "CustRatingFilesVersion"], "MovieIndexFileName": ["MovieIndexFilesName", "MovieConfigFolderFile", "MovieConfigFileHandle", "MovieIndexFSize", "MovieIndexFolderVersion", "MovieIndexFname", "MovieIndexFILEName", "MovieIndexClassUrl", "MovieEditFileSize", "MovieConfigFolderHandle", "MovieIndexFileHandle", "MovieIndexFilesname", "MovieIndexFileVersion", "MovieIndexPlaceHandle", "MovieEditFSize", "MovieEditFUrl", "MovieIndexClassname", "MovieIndexFileSize", "MovieEditFname", "MovieIndexFolderFile", "MovieIndexFilesSize", "MovieIndexFilesUrl", "MovieEditFileName", "MovieConfigFileFile", "MovieEditFileUrl", "MovieIndexFolderHandle", "MovieIndexFileFile", "MovieIndexClassName", "MovieIndexFolderName", "MovieIndexFileUrl", "MovieIndexFILEHandle", "MovieIndexFILEFile", "MovieIndexPlaceVersion", "MovieIndexFilename", "MovieIndexClassSize", "MovieConfigFolderName", "MovieIndexFUrl", "MovieEditFilename", "MovieIndexPlaceFile", "MovieConfigFolderVersion", "MovieIndexFName", "MovieIndexFILEVersion", "MovieConfigFileName", "MovieEditFName", "MovieIndexPlaceName", "MovieConfigFileVersion"], "inFile": ["incFile", " inSourceFile", "InSourceFile", "outFile", "outSourceFile", "inputfile", "outfile", "inputSourceFile", " infile", "infile", "inputFile", "incfile", "Infile", "inputF", "InF", "InFile", "outC", "incSourceFile", "incC", "inSourceFile", "inF", " inF"], "inC": [" inCC", "InCC", "innerCI", "inputCC", "outFile", "outF", " inCL", "inputFile", "inputC", "innerC", "outCL", "outCI", "InC", "innerCC", "inCL", "InCI", "outB", "inputF", "inCI", "inCC", "InF", "outCC", "InB", "InFile", "outC", "innerFile", "inB", "InCL", "inF", " inF", " inB"], "outFile1": ["outFId", "outputfile2", "outFName", "againFile2", "outfileName", "outPlace1", "againFile1", "outputfileName", "againC3", "outPathFirst", "againFileFirst", "againCFirst", "outfile1", "outPlace2", "outFile3", "outFileName", "outPlaceId", "outFiles3", "outFiles2", "outPath1", "outFilesFirst", "outfile2", "outPlaceName", "outFileFirst", "againFile3", "againC1", "outputFile1", "againC2", "outputFileName", "outF1", "outputfile1", "outCFirst", "outputFileId", "outFileId", "outputFile2", "outF2", "outFiles1", "outC3", "outputfileId", "outPath3", "outPath2", "outfileId"], "outC1": ["newcOne", "againCOne", "outD8", "outD1", "newc81", "outB8", "newC81", "outDOne", "againB8", "outDFirst", "outc81", "newC1", "outCOne", "newCOne", "againC8", "outcFirst", "outC8", "againBOne", "againC1", "againC2", "outFOne", "outF1", "outCFirst", "outD81", "outC81", "outBOne", "newcFirst", "againB2", "outcOne", "outD2", "againB1", "outF2", "newCFirst", "outB1", "outCFOne", "newc1", "outB2", "outCFFirst", "outCF81", "outF8", "outCF1", "outc1"], "outFile2": ["outputfile2", "outputFile4", "againFile6", "againFile2", "againFile1", "outFiles4", "outLine6", "outDirectory2", "outFile4", "outfile4", "outDirectoryTwo", "outChannel6", "againLine2", "outputFileTwo", "againLine6", "outFiles2", "outFile6", "againFileTwo", "outfileTwo", "outfile2", "outputfileTwo", "outFilesTwo", "outChannel2", "outfile5", "outLineTwo", "outLine1", "againLineTwo", "outputfile5", "outputFile5", "outputFile2", "outFiles6", "outFiles1", "againLine1", "outFile5", "outFileTwo", "outChannelTwo", "outDirectory5", "outChannel1", "outFiles5", "outDirectory4", "outputfile4", "outLine2"], "outC2": ["outFTwo", "outCache2", "outCache4", "outFile4", "outBTwo", "againBTwo", "outFII", "outF4", "OutFII", "againC4", "OutF1", "outB4", "againC1", "againC2", "outF1", "outFileII", "OutF2", "againB4", "againCTwo", "outCTwo", "OutF4", "outC4", "OutC1", "outCacheII", "outCII", "againB2", "outCache1", "OutC2", "againB1", "outF2", "outB1", "OutC4", "outFileTwo", "OutCII", "outB2"], "fileSize": ["resourceSize", "FileSize", "FileSIZE", "FileMode", "fileAddress", "fileLength", "fileMode", "FileLength", " fileSIZE", "imageSIZE", "imageLength", "bufferMode", " fileLength", "bufferLength", "resourceAddress", " fileMode", "imageSize", " fileAddress", "bufferSize", "fileSIZE", "FileAddress", "resourceSIZE"], "totalNoDataRows": ["totalNoPageRows", "totalNoDataCrows", "totalNoPageLrows", "totalNoDataRrows", "totalNoDataCOWS", "totalNoPageLOWS", "totalNoDataChrows", "totalNoDataROWS", "totalNoDataChues", "totalNoDataCows", "totalNoDataCues", "totalNoDataLOWS", "totalNoDataLues", "totalNoDataLows", "totalNoPageLows", "totalNoDataChows", "totalNoPageLues", "totalNoPageRues", "totalNoPageROWS", "totalNoDataLrows", "totalNoPageRrows", "totalNoDataChOWS", "totalNoDataRues"], "mappedBuffer": ["mappingStream", "machedFile", "mapedStream", "mppedStream", "mactedbuffer", "machedBuff", "mppedBuffer", "mppedChannel", "mappedbuffer", "mippedURL", "machedURL", "mashedBuff", "mactedBuffer", "mappedURL", "MachedBuffer", "mppedBuff", "MappingFile", "mappedStream", "mappingFile", "MappedBuff", "MachedBuff", "MappingBuff", "mapedURL", "MachedURL", "mapedBuffer", "mippedBuff", "mashedChannel", "mappingChannel", "mapedBuff", "mappingBuff", "machedBuffer", "machedbuffer", "MappingBuffer", "MachedChannel", "MappingChannel", "MappedChannel", "Machedbuffer", "MappedFile", "mashedBuffer", "mapedFile", "mappingbuffer", "MachedFile", "Mappedbuffer", "mashedFile", "mappingBuffer", "mippedStream", "mappedChannel", "MappedStream", "mactedStream", "MappedURL", "mippedBuffer", "MappedBuffer", "mappedFile", "machedStream", "mactedBuff", "mappedBuff", "machedChannel", "MachedStream"], "startIndex": ["startSection", "stopRow", "endRow", "endIndex", "startingSection", "initInfo", "endInfo", "useindex", "startPoint", " startPoint", " startindex", "endCode", "StartPosition", "useIndex", "endPosition", "startInfo", "StartInfo", "startCode", "startingPoint", "stopindex", " startCode", "startingIndex", "startOffset", "startPosition", " startOffset", "startRow", " startSection", "Startindex", " startRow", "StartOffset", "endSection", " startInfo", "StartIndex", "initindex", "endPoint", "initIndex", "stopIndex", "startingPosition", "useInfo", "stopCode", " startPosition", "usePosition", "initOffset", "endindex", "startindex"], "count": ["index", "total", "order", "max", "sum", "i", "close", "id", "more", "self", "list", "add", "first", "ind", "c", "current", "number", "limit", "find", "child", "length", "pool", "all", "col", "thread", "time", "key", "weight", "follow", "loop", "part", "allow", "type", "cache", "old", "len", "counter", "other", "group", "Count", "size", "keep", "test", "start", "coll", "force", "name", "call", "found", "code", "depth"], "currentMovie": ["parentmovie", " currentPicture", "parentPicture", "currentlyPicture", "CurrentTheme", "currentFilm", " currentmovie", "reportedFilm", "reportedmovie", "thismovie", "defaultMovie", "reportedMovie", "reportedPicture", "validTheme", "currentTheme", "reportedTheme", "thisPicture", "CurrentFilm", "thisMovie", "CurrentMovie", "reportedMusic", "defaultMusic", "reportedImage", "currentlyMusic", "currentImage", "Currentmovie", "currentlyMovie", "validMovie", "currentMusic", " currentFilm", "defaultFilm", "currentmovie", "thisFilm", "validmovie", "validFilm", "currentPicture", " currentMusic", " currentImage", "parentMovie", "parentFilm", "defaultImage"], "movieName": ["movieInfo", "MovieId", "moneyFamily", "movieFamily", "voiceName", "moviename", "filmFamily", "moneyNumber", "voiceInfo", "camname", "Moviename", "MovieFamily", "MovieInfo", " movieInfo", "voicename", "movieId", "filmname", "camFamily", "filmName", "movieNumber", "camName", "MovieNumber", "filmNumber", " movieId", " movieFamily", "MovieName", "voiceId", " moviename", "moneyName"], "customer": [" customeri", "CustomER", "mixer", "Customers", " customER", "Customer", "mixER", "ustomor", "ustomer", "customeri", "Customeri", " customers", "mixor", "ustomER", "ustomers", "customers", "mixers", "Customor", "ustomeri", "customor", "customER"], "rating": ["string", "info", "writing", "id", "resource", "rolling", "reading", "rc", "http", "number", "packing", "rank", "alpha", "score", "Rating", "rate", "type", "reader", "value", "ranking", "r", "feature", "rice", "data", "ruby", "including", "rr", "writer", "ing", "radius", "ring", "url", "comment", "rates", "range", "missing", "padding", "rated", "attribute", "setting", "error", "rage", "RC"], "outBuf1": ["outBuff0", "outBuff1", "outDuff11", "outBuff2", "outBum1", "outFbuf91", "outDuf3", "outBbuf01", "outBbuf3", "outBuffCloud", "outCuff0", "outBaf8", "outBummerCloud", "outKuf2", "outBaftn", "outBbuff3", "outBafCloud", "outFbufOne", "outBuf91", "outBuf3", "outDuf11", "outBufn", "outFufOne", "outBuff11", "outBalth2", "outBaft3", "outBafOne", "outBbuff1", "outDuf1", "outBuf11", "outBaft11", "outBum01", "outKuf1", "outBalth1", "outDuffn", "outBiff1", "outDufn", "outCuf0", "outDuff1", "outBuffn", "outKbuff3", "outBummer1", "outFaf1", "outBufCloud", "outCuff1", "outCuffOne", "outBuff8", "outBaft1", "outBiff01", "outFafOne", "outBbufOne", "outBiff91", "outCufOne", "outFbuf1", "outFbuf01", "outBbuffOne", "outKuf3", "outDuff3", "outBuf0", "outBbuff0", "outBbuf2", "outKbuf3", "outKbuf2", "outKufOne", "outBbuf11", "outKbuf1", "outBummerOne", "outFuf01", "outBbufn", "outCuf1", "outBbuf1", "outBuffOne", "outBuff3", "outFufCloud", "outKbuff1", "outBuf01", "outBumOne", "outBbuf91", "outFuf1", "outFafCloud", "outKbuffOne", "outBaf1", "outKuf8", "outBalth3", "outBuf8", "outBum91", "outBaf3", "outKbuff8", "outFuf91", "outBufOne", "outBbuff8", "outBaf0", "outBiffOne"], "outBuf2": ["outBuff0", "outBuff1", "outFbuffTwo", "outBuf82", "outBuff4", "outBait8", "outBuff2", "outBoff8", "outBbufferB", "outFuf8", "outBbuffer12", "outWBuf200", "outFbuf2", "outBait200", "outBbuffer4", "outWBuff0", "outFufTwo", "outBuf12", "outBuber2", "outBuff12", "outBbuff200", "outFuf2", "outBuf200", "outBufB", "outWBuf4", "outBbuff4", "outBbuffer2", "outFbuf4", "outWBuf2", "outFbuff1", "outFufB", "outFbuff82", "outBbuf4", "outBufTwo", "outWBufTwo", "outBoffTwo", "outWBbuffTwo", "outBbuff1", "outBbufTwo", "outBum82", "outBaitTwo", "outBum2", "outFuf4", "outBuber8", "outFbuff2", "outWBuff8", "outWBuf0", "outBuff8", "outBuf4", "outWBbuff200", "outBuber82", "outBoff200", "outFbuff20", "outBbufB", "outBbuff20", "outBuffTwo", "outFuf82", "outFbufB", "outBbuff2", "outFbuf12", "outBuf0", "outWBuff4", "outBbuff0", "outBbuf2", "outBbuff82", "outBuffB", "outWBbuff2", "outWBuf8", "outBuf20", "outFbuff4", "outBait2", "outBbuffTwo", "outBum20", "outBait4", "outBbuf1", "outFuf12", "outWBuff2", "outFuf1", "outBoff2", "outBait0", "outBum8", "outBbuf12", "outFbuff8", "outBuf8", "outBuber20", "outWBbuff8", "outBbuff8", "outFuf20"], "endOfIndexFile": ["End\n", "endOfLinkFiles", "endofLinkFiles", "endofindexTime", "endedfile", "endofindexFiles", "endOfLinkTime", "endOfindexFile", "endOfImageTime", "endOfIndexfile", "endOfindexfile", "endfile", "endOfLinkDir", "endOfClientFiles", "endOfImageFiles", "endofIndexDir", "endOfIndexTime", "endOfLinkFile", "endOfImageFile", "endOfDatafile", "endofIndexFolder", "endOfClientFile", "endofindexFolder", "endOfImageFolder", "endOfDataDir", "endOfClientTime", " endfile", "endOfindexFolder", "endofIndexFiles", "endOfClientDir", "ended\n", "endofLinkDir", "endofLinkTime", "Endfile", "endOfindexFiles", "endOfIndexFiles", "endOfDataFile", "endofIndexTime", "endofLinkFile", "endOfindexTime", "endOfDataTime", "endOfIndexDir", "endOfIndexFolder", " end\n", "endOfindexDir", "endOfLinkfile", "end\n", "endofIndexFile", "endofindexFile"]}}
{"id1": "22536033", "id2": "7425022", "code1": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"setPayload": ["setMessageContent", "setShipload", "setRawload", "parseShipContent", "parsePayLoad", "setShipLoad", "setPayLoad", " setPayContent", " setPayloads", "setPayContent", "parseShiploads", "setPayloads", "setWorkLoad", "parsePayload", "parseShipload", "setShipContent", "setMessageLoad", "setRawloads", "setWorkloads", " setPayLoad", "setShiploads", "parsePayloads", "setWorkContent", "setRawLoad", "setMessageloads", "parseShipLoad", "setMessageload", "setRawContent", "parsePayContent", "setWorkload"], "fos": ["bis", "cfis", "cfics", "cfoc", "Foc", "bos", "cfos", "boc", "Fis", "Fos", "fics", "bics", " fics", "Fics"], "fis": ["eic", "fIS", "Fib", "foris", "FIS", " fib", "Foc", " fIS", "forib", "Fic", "foric", "fib", "Fis", "fics", " fics", "eis", "forics", "eIS", "Fics", "eoc"], "fic": ["cfic", "elfics", "Fac", "elfik", "cfics", "cfoc", "infic", "Fci", "ufik", " fac", "Foc", "Firc", "elfci", "cfac", "cfirc", "Fic", "infci", "ufic", "fik", "Fos", "ufoc", "fics", "firc", " firc", " fics", "Fik", "ufos", "infics", "infik", " fik", "elfic", "Fics", "fac", "fci"], "foc": ["Fac", " froc", "infoc", "infocol", "Foca", "Focon", "foca", "focon", "infic", "fisc", "infos", "Focol", " focol", " fac", "Foc", "Fisc", "infocon", " fisc", "Fic", " focon", "Fos", "toca", "toc", "infac", "focol", "tic", "Froc", "troc", "infisc", " foca", "fac", "froc"], "Index": ["index", "Loop", "Section", "Connection", "First", "Found", "Position", "Link", "Len", "Offset", "Path", "Exp", "Flag", "X", "Pos", "Width", "Code", "Interest", "Entry", "Rank", "Element", "Content", "Depth", "Value", "Address", "Inf", "Input", "Length", "Weight", "Array", "Page", "Number", "Pull", "Key", " index", "Count", "Instance", "x", "Body", "Mass", "Size", "Stage", "Header", "Dim", "Label", "I", "Url", "Num", "Insert", "ID", "Location", "Start", "Client", "Version", "Counter", "Level", "Order", "Row", "Loc"]}}
{"id1": "3683344", "id2": "16549995", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"genRandomGUID": [" genRandUIP", " genRandomGUuid", " genRandomIGIP", " genRandomGIP", " genRandomGID", " genRandomUUID", " genRandGIP", " genRandomGUIP", " genRandomIGID", " genRandUID", " genRandGuid", " genRandomIGUID", " genRandomIGuid", " genRandomUIP", " genRandomUID", " genRandomGUUID", " genRandUuid", " genRandGID", " genRandomGuid", " genRandUUID", " genRandGUID", " genRandomUuid"], "secure": ["zip", "remote", "close", "ssl", "ssh", "server", "sys", "forced", "timeout", "smart", "weak", "host", " Secure", "active", "security", "password", "client", "allow", "session", "seed", "proxy", "q", "debug", "exclusive", "str", "config", "sensitive", "https", "require", "safe", "encrypted", "force", "stable", "Secure", " insecure", "secret", "random", "deep", "fast", "protect", "sec", "depth"], "valueBeforeMD5": ["valueBeforeMT20", "valueBeforeMC5", "valueBeforeMC3", "valueAfterMD55", "valueAfterMD20", "valueBeforeSHA2", "valueBeforemd8", "valueBeforeMT05", "valueAfterMC3", "valueAfterMD8", "valueBeforeMD85", "valueAfterMS2", "valueAfterMC5", "valueBeforeMT55", "valueBeforeSHA3", "valueBeforeMP2", "valueBeforeMP5", "valueAfterMS1", "valueBeforeMD05", "valueBeforeAMD05", "valueBeforeMD3", "valueBeforeMD20", "valueBeforemd5", "valueAfterMC85", "valueBeforeM1", "valueBeforeM5", "valueBeforeMD8", "valueAfterMC8", "valueAfterMS5", "valueAfterMD3", "valueBeforeMD55", "valueBeforeMC85", "valueAfterMS3", "valueBeforemd85", "valueAfterMD05", "valueBeforeMC8", "valueBeforeMS2", "valueBeforeMR85", "valueBeforemd3", "valueBeforeMR8", "valueBeforeMS5", "valueBeforeSHA1", "valueBeforeM2", "valueAfterMD2", "valueAfterMD85", "valueBeforeMP3", "valueBeforeM3", "valueBeforeMP55", "valueBeforeMR5", "valueBeforeMD2", "valueBeforeMR3", "valueBeforeMT2", "valueAfterMD1", "valueBeforeMT3", "valueBeforeMS1", "valueBeforeMS3", "valueBeforeSHA5", "valueBeforeAMD3", "valueBeforeAMD5", "valueBeforeAMD20", "valueBeforeMT5", "valueBeforeMD1"], "valueAfterMD5": ["valueAfterMP3", "valueAfterHTML05", "valueAfterMP5", "valueAfterMT3", "valueBeforeMDql", "valueAfterDF3", "valueAfterAMD5", "valueAfterMDTE", "valueBeforeMDody", "valueAfterM3", "valueAfterHTML3", "valueAfterDM5", "valueAfterMTql", "valueBeforeASTody", "valueAfterVM5", "valueAfterDF5", "valueAfterMD1", "valueBeforeVM005", "valueAfterAST5", "valueAfterMFTE", "valueAfterAST2", "valueBeforeMD1", "valueAfterAMD005", "valueBeforeAST005", "valueBeforeAST2", "valueBeforeMC3", "valueBeforeMP1", "valueAfterMDody", "valueBeforeVM3", "valueBeforeMDTE", "valueAfterAST3", "valueAfterMC3", "valueAfterDMody", "valueBeforeMP5", "valueBeforeMD3", "valueAfterGM005", "valueAfterHTML5", "valueAfterVM005", "valueAfterVM3", "valueAfterHTMLody", "valueAfterASTody", "valueBeforeMP3", "valueAfterAMD3", "valueAfterMF5", "valueBeforeAST3", "valueAfterMD005", "valueBeforeMPTE", "valueAfterAST512", "valueAfterMP05", "valueAfterMC5", "valueBeforeAST512", "valueAfterHTMLTE", "valueAfterHTML512", "valueAfterM2", "valueBeforeMD05", "valueAfterGM5", "valueAfterMD3", "valueAfterMD05", "valueAfterMT5", "valueAfterMP005", "valueAfterM5", "valueAfterMD512", "valueAfterMC2", "valueAfterMP2", "valueAfterAST005", "valueAfterDF005", "valueAfterDM512", "valueBeforeMD512", "valueBeforeMD005", "valueBeforeMC5", "valueAfterMF3", "valueAfterMC1", "valueAfterM1", "valueBeforeAST5", "valueBeforeVM5", "valueAfterMP1", "valueBeforeMP2", "valueAfterGM3", "valueAfterMPTE", "valueAfterGM2", "valueAfterDM3", "valueAfterMDql", "valueAfterMD2", "valueAfterMCql", "valueBeforeMD2", "valueBeforeMP05", "valueAfterMF05", "valueBeforeMCql"], "md5": ["mand512", "md25", "cmd53", " md1", "md65", "cmd3", "mand2", "cmd2", " md25", " mdkey", "cmd05", "md05", " md3", " md53", "amd5", "cmd1", " MD53", "cmdkey", "md2", "cmd65", " MD3", "md53", "MD5", "mandkey", " md65", "MD25", "amd25", " MD05", "MD512", "amd2", "MD2", "mand65", "md3", " md2", "amd512", "mdkey", "mand5", "mand3", "md512", " md512", " MD5", "cmd5", "cmd512", "md1", "mand1", " md05"], "sbValueBeforeMD5": ["sbValuebeforeND2", "sbValueBeforeMS5", "sbValueBeforeMS2", "sbValueBeforeMT3", "sbValueBeforeND85", "sbValueInsideAMD5", "sbValueBeforeMP25", "sbValueAfterMP5", "sbValueBeforeMP005", "sbValuebeforeMD5", "sbValueAfterMP512", "sbValueBeforeMD2", "sbValueBeforeMR3", "sbValueBeforeMM005", "sbValueBeforemd3", "sbValueBehindMD25", "sbValueAfterMP55", "sbValueBeforeMR5", "sbValueBeforeMC25", "sbValueWithoutMF35", "sbValueBeforeMF3", "sbValueBeforeMS85", "sbValueBeforeMD525", "sbValueBeforeMS512", "sbValuebeforeND3", "sbValueBeforeMD85", "sbValueBeforeAMD5", "sbValueBeforeMP525", "sbValueBeforeMT5", "sbValueBeforeMP05", "sbValueBeforeND525", "sbValueBeforemd2", "sbValueBeforemd5", "sbValueAfterMD005", "sbValueBeforemd05", "sbValueWithoutMD25", "sbValueInsideMD25", "sbValueWithoutMD35", "sbValueBeforemd25", "sbValueBetweenMD2", "sbValueAfterMD512", "sbValueBeforeND5", "sbValueAfterMD5", "sbValueInsideMD05", "sbValuebeforeMD85", "sbValueWithoutMF5", "sbValueBehindMD3", "sbValueBeforeMG25", "sbValueBeforemd305", "sbValueAfterMP005", "sbValueBeforeMP1", "sbValueBehindND525", "sbValueBeforeMD305", "sbValueBeforeMC5", "sbValuebeforeND85", "sbValueBetweenmd305", "sbValueBeforeAMD305", "sbValueAfterMP3", "sbValueBeforeMT55", "sbValueBeforeND3", "sbValueInsideMD5", "sbValueBeforeND2", "sbValueWithoutMF25", "sbValueBeforeMS1", "sbValueBeforeMP305", "sbValueAfterMD1", "sbValueBeforeMM55", "sbValueBetweenMD5", "sbValueBeforeMG3", "sbValueBeforeAMD25", "sbValuebeforeMD3", "sbValueBeforeMG35", "sbValueBetweenmd3", "sbValueBeforeMD25", "sbValueBeforeND25", "sbValueBehindMD5", "sbValueBeforeMD05", "sbValueBehindND25", "sbValueBeforeMR25", "sbValueBeforeAMD512", "sbValueBeforeMM3", "sbValueAfterMP1", "sbValuebeforeND5", "sbValueBeforeMG5", "sbValueBeforeMT005", "sbValueBeforeMC35", "sbValueBeforeMD1", "sbValueBetweenmd2", "sbValueBetweenmd5", "sbValueInsideAMD05", "sbValueWithoutMD5", "sbValueInsideAMD25", "sbValueBeforeMD512", "sbValueBeforeMF25", "sbValueBeforeMD35", "sbValueBehindMD525", "sbValueBeforeMP5", "sbValueBeforeMP3", "sbValueBehindND5", "sbValueAfterMD3", "sbValueBeforeMP512", "sbValueBeforeMP55", "sbValueBehindND3", "sbValueWithoutMD3", "sbValueInsideAMD3", "sbValueBeforeAMD1", "sbValueBeforeMM5", "sbValueBeforeMP2", "sbValueBeforeMF35", "sbValueBeforeAMD2", "sbValueBeforeMD005", "sbValueBeforeMS3", "sbValueBeforeAMD3", "sbValueBeforeMD55", "sbValueBeforeMD3", "sbValueBeforeMF5", "sbValueWithoutMF3", "sbValueBeforeMC3", "sbValueInsideMD3", "sbValuebeforeMD2", "sbValueBeforeMR525", "sbValueBetweenMD305", "sbValueBeforeAMD05", "sbValueBeforeMP85", "sbValueBetweenMD3", "sbValueAfterMD55"], "time": ["cost", "error", "temp", "tz", "duration", "id", "timeout", "month", "year", "clock", "version", "ime", "times", "mode", "length", "host", "sleep", "rate", "type", "money", "seed", "delay", "date", "value", "q", "counter", "work", "timer", "size", "name", "start", "race", "port", "Time", "hour", "random", "etime", "count", "age", "TIME", "speed", "depth"], "rand": ["index", "root", "order", "core", "max", "id", "round", "clean", "rc", "year", "rage", "version", "length", "rank", "ro", "dr", "pattern", "alpha", "Rand", "rate", "type", "rule", "rh", "seed", "delay", "q", "serial", "dist", "r", "pick", "nd", "rr", "risk", "name", "rss", "bit", "raid", "bug", "reg", "right", "range", "random", "count", "ng", "mid", "error", "win", "re", "winner", "depth"], "array": ["integer", "index", "string", "address", "element", "now", "vector", "table", "number", "instance", "all", "record", "database", "arr", "expression", "angle", "cache", "value", "our", "r", "Array", "collection", "section", "sample", "feature", "archive", "object", "row", "ray", "arrow", "image", "function", "area", "a", "app", "bug", "pair", "range", "air", "multi", "batch", "error", "module", "list", "view"], "strTemp": ["drtemp", "drTem", "strFake", "brTem", "strTest", "arrTem", "brVar", "stringTemp", "objtemp", "strTemplate", "arrtemp", " strTemplate", "crTem", "drTemplate", " strVar", "drVar", "objTem", " strFake", "stringTem", "StrTemp", " strTest", " strTem", "brTemp", "crtemp", " strtemp", "stringFake", "objFake", "StrBase", "arrTest", "strVar", " strBase", "arrTemp", "strtemp", "strBase", "crTemplate", "brtemp", "drTemp", "Strtemp", "objTemp", "stringtemp", "arrBase", "crTemp", "strTem", "brTest"], "i": ["index", "info", "id", "n", "pi", "mu", "uri", "ie", "yi", "slice", "c", "j", "z", "ri", "o", "end", "l", "si", "ui", "in", "ii", "key", "ti", "ji", "d", "phi", "li", "ip", "x", "h", "p", "u", "ai", "start", "e", "I", "ci", "io", "eni", "xi", "di", "gi", "hi", "k", "b", "v", "y", "abi", "multi", "f", "field", "ix"]}}
{"id1": "18731843", "id2": "16623181", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doBody": ["doFile", "handleFile", "handleResponse", "handleBytes", "handleBody", "doResponse", " doBytes", " doFile", "doBytes", "DoBody", "DoBytes", "DoFile", " doResponse", "DoResponse"], "req": ["qt", "info", "Request", "resource", "sem", "spec", "serv", "report", "res", "http", "ref", "fr", "query", "comp", "reader", "rh", "proc", "q", "r", "crit", "config", "data", "qq", "src", "request", "requ", "rr", "rec", "conn", "rss", "cgi", "rx", "jp", "respond", "err", "obj", "reg", "def", "this", "download"], "resp": ["val", "respons", "job", "serv", "response", "cmp", "report", "res", "pre", "ref", "result", "cb", "html", "api", "inv", "prot", "ret", "comp", "part", "cache", "Resp", "proc", "r", "data", "exc", "rep", "request", "bb", "p", "reply", "rr", "rec", "pos", "jp", "rev", "respond", "Response", "err", "sp", "b", "obj", "re", "download"], "bis": ["uds", "sin", "usb", "iss", "lis", "bh", "alis", "tis", "obb", "bs", "obos", "bin", "ois", "is", "ori", "obi", "bes", "binary", "sb", "oris", "bps", "ais", "bian", "ubis", "bas", "nis", "fb", "phis", "bb", "bi", "ris", "obs", "isin", "lins", "iris", "ios", "atis", "ses", "pins", "sis", "b", "abi", "los", "os", "bits", "rots", "bid", "boot", "mis"], "bos": ["uds", "mos", "oses", "fits", "bh", "antis", "zos", "tis", "bones", "obb", "bs", "bo", "obos", "ois", "bin", "oos", "obo", "obi", "bes", "ros", "ops", "bps", "ubis", "bas", "bris", "bott", "las", "phis", "bi", "opus", "aos", "obs", "oks", "lins", "ios", "oS", "osa", "lol", "los", "zo", "abi", "oops", "os", "oros", "osi", "bits", "boot"]}}
{"id1": "11341711", "id2": "22611968", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"makeBackup": ["createBackUp", "makePickup", "makeBackups", "makeCleanUp", "makePickdown", "makeCleanups", "makebackdown", "makeBackdown", "makePickUp", "createbackUp", "makePickups", "createbackups", "createBackup", "makebackUp", "createBackdown", "makebackup", "createbackdown", "makeCleandown", "makeBackUp", "createBackups", "createbackup", "makeCleanup", "makebackups"], "dir": ["directory", "zip", "root", "path", "base", "pkg", "rc", "run", "dest", "manager", "done", "wd", "source", "Dir", "d", "cache", "doc", "up", "diff", "lib", "dist", "group", "build", "work", "config", "store", "file", "ir", "data", "md", "director", "log", "init", "folder", "Directory", "desc", "dict", "io", "name", "db", "DIR", "url", "dep", "module", "download", "direction"], "sourcedir": ["sourcedirs", "sourcesiri", "sodedIR", "seedir", "sodeddir", "sortedIR", "sourcesdir", "ssourcediri", "sourcesir", "sodediri", "sodedir", "sourceddir", "ssourcedIR", "seedIR", "seediri", "sortedirs", "sourcesore", "asourcedIR", "sourcesIR", "ssodedIR", "seeddir", "sortedore", "asourcedir", "sodedore", "sourcediri", "sodedirs", "asourcedirs", "sourcedIR", "asourcedore", "sourcedore", "asortedirs", "sourcesirs", "asortedore", "ssourcedir", "ssourceddir", "ssodeddir", "asortedIR", "asortedir", "ssodedir", "sortedir", "ssodediri"], "destinationdir": ["destinatorfile", "desturationdirection", "destinateDIR", "DestificationDir", "destinatedir", "Destinationdirection", "dominationDIR", "desturationfolder", "Destificationdir", "destinatorDIR", "dominationdir", "destificationfolder", "destinationfolder", "destinationsfile", "Destificationfolder", "Destificationdirection", "destinationdirection", "destinationsDIR", "destificationdirection", "destificationDir", "destinatordir", "destinatefolder", "Destinationfolder", "destinationDIR", "destinationDir", "dominatorDir", "dominatorfile", "dominationfile", "dominationDir", "destinationsdir", "destinatedirection", "destinatefile", "dominatordir", "destificationdir", "Destinationdir", "DestinationDir", "desturationDir", "desturationdir", "dominatorDIR", "destinatorDir", "destinationsDir", "destinationfile", "destinateDir"], "destinationDirEnding": ["destinationDirectoryEnding", "destinationDirENDging", "destinationDirBegining", "destinationDirBeginning", "destinationPathEndging", "destinationDirBeginging", "destinationPathBeginING", "destinationDirectorySignING", "destinationPathBeginging", "destinationDirPassING", "destinationDirBeginING", "destinationPathBegining", "destinationDirectoryEndening", "destinationDirectoryEndING", "destinationDirEndining", "destinationDirEndging", "destinationDirPassging", "destinationDirPassning", "destinationDirectoryEndining", "destinationDirEndening", "destinationDirectorySignening", "destinationDirSignening", "destinationDirSignining", "destinationDirPassing", "destinationDirSignING", "destinationPathBeginning", "destinationDirEndning", "destinationDirectorySigning", "destinationDirLeadING", "destinationDirLeading", "destinationDirLeadening", "destinationDirENDning", "destinationDirEndING", "destinationDirENDING", "destinationPathEndning", "destinationDirectorySignining", "destinationDirENDing", "destinationDirSigning", "destinationPathEnding", "destinationDirBeginining", "destinationDirBeginening", "destinationPathEndING", "destinationDirLeadining"], "files": ["keys", "balls", "index", "services", "locks", "output", "fs", "pages", "docs", "resources", "results", "features", "l", "ins", "Files", "reports", "modules", "errors", "ids", "split", "items", "projects", "its", "uploads", "iles", "users", "lines", "flows", "blocks", "children", "parents", "runs", "strings", "bugs", "names", "classes", "file", "data", "images", "objects", " Files", "models", "ips", "groups", "log", "planes", "ls", "thumbnails", "tests", "types", "rows", "books", "actions", "fields", "rules", "xml", "words", "events", "ps", "sections", "boxes", "links"], "checkdir": ["blockDir", "checkdirectory", "checkd", "calld", "blockdraft", "workdirectory", " checklog", "blockdirectory", "CheckDir", "ckdir", " checkfile", "workdir", "ckDir", "workDIR", "workdraft", "Checkdir", "checkDir", "searchdir", "ckfile", "workfile", " checkDIR", "Checkfile", "lockdir", "searchdirectory", " checkfolder", "workfolder", "calldir", " checkFolder", "workFolder", "ckd", "lockFolder", "checkfolder", "searchDir", " checkd", "checkdraft", "checkFolder", "locklog", "CheckDIR", "checklog", "checkDIR", "lockDir", " checkdirectory", "calldirectory", "ckdirectory", "blockdir", "workDir", "worklog", "ckfolder", "checkfile", "searchdraft", "callfolder", " checkDir"], "date": ["event", "mu", "user", "month", "now", "ge", "ime", "late", "set", "tag", "day", "zone", "time", "ate", "dt", "at", "rate", "d", "doc", "Date", "md", "config", "data", "file", "de", "mate", "open", " Date", "log", "start", "name", "e", "m", "image", "change", "update", "sign", "contact", "state", "age", "dat"], "msec": [" mif", " mSec", "csec", "dseconds", "Msecond", "Mseconds", "mnsec", "css", "lsec", "dsecond", "msecond", " minif", "lseconds", "fmisec", "disec", "fmsecond", "mss", "mnsc", "fmseconds", "rseconds", "csecond", "mseconds", "cseconds", " msc", "lss", "mSec", "mnSec", "rsec", "mnif", "rss", "Msec", " minSec", "msc", " minsc", "mif", " minsec", "lsecond", "Misec", "rsecond", "misec", "dsec", "fmsec"], "checkFile": ["changefile", "workFile", "CheckFile", "workFiles", " checkDirectory", "checkFilename", "CheckDir", " checkfile", " checkFilename", "checkFiles", "checkDir", "ckfile", "workfile", "Checkfile", "checkLine", " checkDir", "controlLine", "changeFilename", "ckFiles", "changeFile", " checkFiles", "controlfile", "controlFile", "changeLine", "ckDirectory", "controlFilename", "CheckFiles", "workDir", "checkDirectory", " checkLine", "checkfile", "CheckDirectory", "ckFile"], "i": ["index", "info", "id", "n", "pi", "uri", "mu", "ini", "ie", "slice", "j", "fi", "ri", "si", "ui", "is", "ii", "key", "qi", "part", "vi", "ti", "ji", "phi", "li", "ip", "x", "p", "bi", "u", "ai", "oi", "ci", "I", "e", "io", "eni", "m", "xi", "di", "gi", "hi", "v", "y", "b", "iu", "multi", "field", "im", "ix"], "f": ["info", "fun", "fe", "sf", "n", "fs", "feed", "cf", "df", "fc", "fi", "j", "fp", "o", "fn", "l", "fr", "fl", "d", "q", "r", "w", "file", "fb", "h", "p", "u", "folder", "e", "m", "t", "F", "fd", "b", "v", "fx"], "g": ["vg", "n", "gd", "gh", "gin", "sg", "gc", "ge", "tg", "rg", "l", "global", "s", "gg", "bg", "gb", "gar", "d", "q", "r", "group", "ger", "w", "erg", "gs", "ig", "file", "gn", "gp", "go", "h", "p", "u", "msg", "e", "m", "t", "G", "gi", "og", "reg", "ga", "gu", "eg", "b", "mg", "ng", "gm", "pg"], "destinationFile": ["destinatorLocation", "DestinationFile", "destationfile", "destinationFilename", "DestificationDir", "destinatorDirectory", "DestationDir", "DestinationFilename", "destiningFile", "destacementDir", "DestificationLocation", "destificationFile", "destacementfile", "destinationDirectory", "destationFilename", "destificationLocation", "destacementFilename", "destinationfile", "destationDir", "destinationLocation", "destinationsFile", "destificationDirectory", "destinatorFile", "DestinationLocation", "Destationfile", "destiningFilename", "destinationDir", "DestificationDirectory", "Destinationfile", "destacementFile", "DestationFile", "DestationFilename", "destiningfile", "destiningDir", "DestinationDir", "destinationsLocation", "destationFile", "destinatorDir", "DestificationFile", "destinationsDir", "destinationsDirectory", "destificationDir", "DestinationDirectory"], "sourceFile": ["srcModule", "SourceDir", "sourceDir", "SourceModule", " sourceDir", " sourceFiles", "srcFile", "ourceFile", "inputFile", "sourceFiles", "ourceFiles", " sourceModule", "inputDir", "SourceFile", " sourceDirectory", "sourcefile", "inputFiles", "ourceDirectory", "srcDir", "sourceModule", "sourceDirectory", " sourcefile", "Sourcefile", "ourceDir", "srcfile", "inputDirectory"], "infile": ["outdir", "inFile", "inputdata", "outstream", "outFile", "inputfile", "diffdir", "indata", " instream", " inFile", "Instream", "winstream", "inputFile", "Inf", "indir", "difffile", "Infile", "diffstream", "outf", "outdata", "winfile", "windir", " indata", "InFile", "instream", "diffFile", "inputf", "inputstream", "inf", "winFile"], "outfile": ["intfile", "outline", " outpage", "outpage", "againpage", " outfunction", "againFile", "intstream", "outstream", "outFile", "inputfile", " outFile", " outstream", "outlive", "inputFile", "exstream", "intlive", "inputfunction", "againstream", "exfile", "Outlive", "Outfunction", "exFile", "againfile", "Outline", "expage", "intFile", " outlive", "Outstream", "OutFile", "inputline", "outfunction", "Outfile", " outline"], "c": ["index", "string", "cu", "id", "n", "rc", "enc", "character", "cont", "z", "end", "o", "col", "l", "in", "char", "ec", "cm", "d", "lc", "uc", "ct", "r", "ch", "cy", "w", "channel", "ice", "xc", "cl", "h", "x", "p", "C", "u", "e", "m", "ci", "t", "cr", "pointer", "esc", "dec", "pc", "a", "abc", "k", "comment", "v", "b", "ac", "code"]}}
{"id1": "19584877", "id2": "16048516", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static SVNConfiguracion load(URL urlConfiguracion) {\n        SVNConfiguracion configuracion = null;\n        try {\n            XMLDecoder xenc = new XMLDecoder(urlConfiguracion.openStream());\n            configuracion = (SVNConfiguracion) xenc.readObject();\n            configuracion.setFicheroConfiguracion(urlConfiguracion);\n            xenc.close();\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        }\n        return configuracion;\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFiletoFiles", "encodeFileToFiles", "encodeFiletoFile", "encodeString2File", "encodeString2Stream", "encodeFileToStream", "encodeFileFromStream", "encodeStringToStream", "encodeFileFromFile", "encodeString2String", "encodeFile2Files", "encodeStringToFile", "encodeFile2File", "encodeFileToString", "encodeString2Files", "encodeFiletoString", "encodeStringToString", "encodeFile2Stream", "encodeFiletoStream", "encodeStringToFiles", "encodeFileFromString", "encodeFileFromFiles", "encodeFile2String"], "infile": ["infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", " infp", "inputfp", "inputFile", "outfiles", " infilename", "inputfiles", "Infilename", " infiles", "outfp", "Infile", "InFile", "inputfilename", "infilename", "Infiles"], "outfile": ["newfile", "Outname", "infp", "outfilename", "outputfile", "outFile", "newname", " outFile", "infolder", " outfolder", "outputfolder", "newfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "Outfolder", " outname", "outname", "OutFile", "Outfile", "infilename", "newFile", " outfilename"], "in": ["IN", "base", "pin", "i", "input", "inas", "sin", "id", "ini", "gin", "into", "ic", "con", "inner", "as", "socket", "ins", "s", "bin", "pass", "is", "reader", "source", "thin", "login", "min", "inside", "r", "inc", "data", "rin", "vin", "init", "conn", "again", "m", "image", "re", "isin", "In", "nin", "a", "err", "b", "ac", "cin", "inn", "win", "din"], "out": ["base", "ou", "job", "ex", "output", "outer", "copy", "timeout", "on", "net", "OUT", "socket", "inner", "outs", "o", "off", "write", "bin", "co", "line", "exit", "post", "client", "sync", "session", "no", "cache", "source", "one", "up", "lib", "inc", "parent", "work", "file", "conn", "or", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "In", "err", "obj", "error", "point"], "buffer": ["address", "base", "Buffer", "input", "uffer", "feed", "server", "border", "slice", "limit", "result", "length", "write", "queue", "offset", "iter", "split", "raw", "type", "reader", "cache", "binary", "source", "seed", "buff", "value", "buf", "len", "wave", "data", "fb", "size", "bb", "null", "bytes", "layer", "flush", "url", "b", "reference", "count", "padding", "transfer", "batch"], "read": ["play", "close", "i", "input", "Read", "feed", "n", "copy", "reading", "id", "add", "ind", "slice", "current", "end", "limit", "run", "se", "find", "length", "write", "reads", "ride", "pass", "sleep", "ad", "iter", "next", "raw", "sync", " count", "select", "allow", "use", "load", "reader", " Read", "len", "seek", "work", "inc", "check", " copy", "ip", "size", "x", "get", "fill", "start", "exec", "io", "lex", "send", "tell", "_", "parse", "connect", "wait", "count", "READ", " write", " skip", "f"], "success": ["respons", "roll", "error", "path", "response", "rolling", "continue", "results", "ceed", "modified", "xx", "message", "primary", "warning", "better", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "model", "default", "open", "data", "growth", "flash", "null", "cess", "danger", "complete", "again", "status", " successful", "good", "Success", "comment", "right", "successful", "successfully", "rolled", " succ", "method", "fast", "first", "winner", "initial"]}}
{"id1": "9096319", "id2": "8953394", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    private void update(String statement, SyrupConnection con, boolean do_log) throws Exception {\n        Statement s = null;\n        try {\n            s = con.createStatement();\n            s.executeUpdate(statement);\n            con.commit();\n        } catch (Throwable e) {\n            if (do_log) {\n                logger.log(Level.INFO, \"Update failed. Transaction is rolled back\", e);\n            }\n            con.rollback();\n        }\n    }\n", "label": 1, "substitutes": {"handleNodeRegainedService": ["handleNodeReginedEvent", "handleNodeReginedService", "handleNoderegainsServices", "handleNodeRegainsEvent", "handleNoderegainedServices", "handleNoderegainedService", "handleNodeRegainingService", "handleNoderegainedEvent", "handleNodeRegainingServices", "handleNodeRegainsService", "handleNodeRegainedEvent", "handleNodeReginedServices", "handleNoderegainsEvent", "handleNodeRegainingEvent", "handleNodeRegainedServices", "handleNoderegainsService", "handleNodeRegainsServices"], "eventID": ["updateid", "issueName", "updateID", "issueid", "issueID", "issueId", "nodeId", "eventid", "serviceid", "nodeTime", "updateId", " eventid", "serviceName", "serviceTime", "eventId", " eventName", "serviceId", "eventName", "updateName", " eventId", "nodeName"], "nodeID": ["resourceID", "eventPath", "nodeResult", "nodeid", "packageID", " nodeResult", "siteId", "nodeRI", " nodeid", "globalid", " nodeName", "nodeId", "eventid", "odeID", "serviceid", "resourceId", "globalPath", " nodeRI", "nodePath", "packageId", "eventKey", " nodeKey", "objectId", "globalId", "objectName", "odeId", "eventResult", "siteName", "sourceID", "eventId", "sourceRI", "sourceId", " nodePath", "eventName", "odeName", "nodeKey", " nodeId", "serviceId", "resourceKey", "objectID", "siteid", "odeRI", "nodeName", "odeResult", "globalID", "objectid", "packageid", "siteID"], "ipAddr": ["ipAddressri", "ipAppr", " ipAttrs", "IPAdder", "ipAddrt", "ipAddressrt", "IPAddrs", "ipAtter", " ipAttr", "ipAddressrs", " ipAppvr", "ipaddress", "ipAddressvr", " ipAttri", "ipAppvr", "ipAttri", "ipaddr", "ipChn", " ipAddrs", " ipApprs", "IPAddr", "IPAddressrt", " ipAdder", "ipaddrs", "ipAder", "ipAddri", " ipAtter", "ipOffrt", "IPAddressn", "IPAddri", "ipAdder", "IPAddrt", "ipAttr", "ipAddvr", "ipadder", "ipAdrs", "ipaddvr", "ipAttrs", "ipApprs", "ipAddrs", "ipOffrs", " ipAddress", "ipAddn", "IPAddressri", "ipOffr", "IPAddressr", " ipAddvr", "IPAddresser", "IPAddressrs", "ipAddressress", "ipAttvr", "ipAdn", " ipAttvr", "ipChr", "ipAddressn", "ipAddressr", "ipCher", "ipAddress", " ipAddri", "ipAddresser", "ipaddri", "ipChrs", "ipOffri", "ipAdr", " ipAppr", "IPAddn"], "serviceID": ["featureID", "resourceID", "skillName", "eventIDs", "serviceIDs", " serviceHandle", "featureIP", "serviceHandle", " serviceX", " serviceNAME", "ServiceName", "ServiceIDs", "skillID", "featureId", "ServiceID", "resourceType", "ServiceIP", "eventX", " serviceName", "ServiceId", "processId", "ServiceHandle", "serverID", "skillNAME", "serviceX", "resourceId", " serviceId", " serviceIP", "ServiceNAME", "serviceName", "serverId", " serviceIDs", "serviceNAME", "eventId", "featureHandle", "processName", "serviceIP", "eventName", "serviceId", "ServiceType", "processID", "serverName", "serverX", "skillId", " serviceType", "serviceType"], "eventTime": ["EventName", "changePoint", "changeTIME", "changeTime", "errorTime", " eventType", "changeType", "EventTim", " eventPoint", "eventTIME", "processName", "processTim", " eventName", "eventName", "eventTim", "processID", "errorTIME", " eventTIME", "processTime", "errorType", "EventID", "EventTime", "eventType", "eventPoint", "errorPoint", " eventTim"], "log": ["event", "info", "path", "lo", "temp", "feed", "output", "lock", "entry", "LOG", "http", "tool", "net", "c", "ge", "l", "host", "pool", "tag", "write", "thread", "pl", "key", "fail", "loop", "type", "stat", "cache", "connection", "debug", "model", "cat", "ch", "w", "config", "level", "crit", "out", "build", "cl", "get", "put", "gen", "conn", "format", "or", "lex", "port", "exp", "blog", "it", "call", "db", "Log", "og", "full", "com", "url", "bug", "pe", "contract", "sign", "plug", "error", "sec", "stop"], "dbConn": ["dbConnection", "logConnect", "bbCon", "dbconn", "cbConnection", "fbCon", "logConn", "fbColl", "dbCt", "DBConnection", "DbConnection", "bbConn", " dbConnect", "DbConn", " dbCt", "logconn", "DbConnect", "DBConn", "fbCt", "dbLoc", "dbConnect", "realCon", "DbCt", "logDb", "databaseConn", " dbDb", "databaseConnection", "realCt", "cbConnect", " dbConnection", "bbconn", "fbConn", "DBConnect", " dbconn", "dbColl", " dbLoc", "realColl", "dbDb", " dbColl", "DbDb", "databaseconn", "bbConnect", "DBCon", "databaseLoc", "cbConn", " dbCon", "Dbconn", "DbLoc", "cbconn", "DBconn", "DBCt", "realConn", "bbConnection", "dbCon"], "outageUpdater": ["outageUtdter", "outageUpdraser", "outageUpdatedratter", "outageAppdator", "outageUprusher", "outageUnaser", "outageUpdrater", "outageUpdrator", "outageUpdatedraser", "outageUpnoster", "outageUpdatarter", "outageUpmter", "outageUpdatATER", "outageUpdarter", "outageUppater", "outageUpdroster", "outageUpnoder", "outageUpdoder", "outageUpdager", "outageUpdatedarer", "outageupdatter", "outageUpdatedATER", "outageUptatable", "outageChdator", "outageUpfatter", "outageUpnager", "outageUpdrarer", "outageUpdatedatter", "outageUnATER", "outageuplater", "outageUpfaser", "outageUpratter", "outageChdroster", "outageUpdrapper", "outageUpdroder", "outageupdaser", "outageAppdter", "outageChdrator", "outageUplusher", "outageAppnter", "outageUplatter", "outageUpparter", "outageUpfater", "outageUpnarer", "outageUpdoster", "outageUpfapper", "outageUpdatedrater", "outageChdoster", "outageUtdatter", "outageUpdrusher", "outageUpdrATER", "outageUpdatedatable", "outageUpdatater", "outageuplusher", "outageUpdatedrapper", "outageUpdatedratable", "outageUpdatatter", "outageUtdarter", "outageUtdatarter", "outageUpdratable", "outageUpdATER", "outageUpdarer", "outageuplaser", "outageAppnager", "outageUtdater", "outageUpdsoster", "outageUdater", "outageUptaser", "outageUppter", "outageChdater", "outageAppnater", "outageUpdusher", "outageUpdatable", "outageUpdatedater", "outageUpdatter", "outageUpdratter", "outageUpdatedrarer", "outageUpndater", "outageUdATER", "outageUpmager", "outageUpdator", "outageUpndarter", "outageUpnter", "outageUplaser", "outageUprater", "outageUpdsator", "outageChdoder", "outageUpnater", "outageUpnaser", "outageUppatter", "outageUppaser", "outageUpdatedapper", "outageUplapper", "outageUpndter", "outageUnarer", "outageAppdager", "outageUpnator", "outageUpmator", "outageupdusher", "outageUplater", "outageUpstager", "outageUpdatedrATER", "outageUpnATER", "outageUdaser", "outageuplatter", "outageUpdsater", "outageUpmater", "outageUppATER", "outageChdrater", "outageUtdatater", "outageUptater", "outageUpstater", "outageUdarer", "outageUnater", "outageAppdater", "outageUpdter", "outageAppnator", "outageUpdatedaser", "outageUptarer", "outageChdroder", "outageUtdatatter", "outageUpdataser", "outageUpdapper", "outageUpstter", "outageupdater", "outageUpstator", "outageUpdaser", "outageUpraser", "outageUpdatarer", "outageUpndatter", "outageUpdsoder", "outageUpdatatable"]}}
{"id1": "16232202", "id2": "11562173", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "code2": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "label": 0, "substitutes": {"doPost": ["doingPut", "didPost", "doingPOST", "didPOST", "didPut", " doPOST", " doPut", "doSend", "doPut", "didSend", " doSend", "doPOST", "doingPost", "doingSend"], "request": ["event", "remote", "info", "order", "error", "input", "Request", "server", "resource", "self", "user", "list", "register", "report", "enter", "rf", "subject", "message", "current", "project", "result", "join", "instance", "child", "press", "query", "save", "condition", "req", "queue", "post", "next", "er", "client", "select", "rate", "session", "reader", "type", "use", "q", "load", "application", "upload", "store", "parent", "data", "route", "web", "object", "page", "get", "context", "row", "hello", "complete", "submit", "e", "QUEST", "image", "url", "create", "you", "parse", "xml", "state", "method", "re", "external", "view", "initial"], "response": ["index", "server", "output", "resource", "feed", "serv", "uri", "http", "report", "res", "message", "document", "subject", "site", "onse", "fire", "result", "forward", "shell", "pool", "query", "su", "ception", "en", "next", "exit", "session", "resp", "model", "application", "parent", "de", "body", "page", "environment", "object", "web", "ae", "reply", "complete", "tree", "e", "status", "writer", "image", "re", "Response", " Response", "respond", "we", "wa", "error", "esi", "service", "api", "view"], "cu": ["U", "ou", "tc", "cc", "lu", "cf", "rc", "aca", "ue", "c", "ru", "CU", "co", "du", "su", "ui", "agu", "Cu", "ku", "uu", "VC", "cus", "chu", "vc", "asu", "ce", "lc", "uc", "cy", "tu", "ca", "xc", "usa", "CA", "u", "eu", "uni", "hu", "ci", "coll", "uci", "ucc", "mc", "cum", "cci", "cul", "ac", "CI", "gu", "ul", "UC", "cin", "nu", "cli", "cur", "cca", "loc"], "ud": ["uds", "ou", "um", "uri", "lu", "user", "df", "rc", "od", "ck", "ue", "uv", "ru", "uid", "pub", "du", "su", "ui", "usr", "util", "ku", "uu", "ad", "cus", "uf", "gb", "chu", "asu", "uc", "uda", "ug", "UD", "ut", "upload", "au", "tu", "li", "utils", "udi", "ub", "usa", "usc", "u", "uli", "eu", "ci", "db", "us", "bug", "auth", "ur", "wik", "vd", "gu", "ada", "da", "cli", "pd", "stri", "dd", "storage"], "returnTo": ["exitFrom", "exitTo", "accessFrom", "ReturnFrom", "accessTO", "backto", "outputto", "exitTO", "outputTo", "outputTO", "returnFrom", "backTO", "backTo", "ReturnTo", "Returnto", "backFrom", "returnTO", "exitto", "replyto", "replyTo", "ReturnTO", "outputFrom", "replyFrom", "accessto", "returnto", "accessTo", "replyTO"], "password": ["string", "address", "sum", "mask", "username", "token", "user", "message", "confirmed", "account", "patch", "wd", "key", "params", "Password", "email", "mac", "PASS", "sha", "diff", "login", "sword", "data", "encrypted", "null", "name", "ass", "word", "wallet", "pa", "auth", "secret", "pad", "padding", "crypt", "phrase", "pg", "code"], "md": ["mag", "bd", "df", "managed", "od", "amd", "mo", "ma", "am", "meta", "wd", "MD", "dc", " MD", "rpm", "sm", "ms", "mb", "mt", "mac", "d", "mp", "hd", "sha", "diff", "mm", "cd", " Md", "dig", "m", "dm", "db", "mand", "mc", "mn", "vd", "rm", "mg", "mad", "f", "cmd", "dd", "pg"], "hash": ["total", "base", "sum", "her", "user", "version", "ref", "kh", "confirmed", "hex", "Hash", "number", "tag", "ash", "key", "char", "raw", "no", "mac", "cache", "dot", "rh", "sha", "diff", "h", "row", "dig", "ass", "hed", "array", "db", "url", "sh", "auth", "secret", "block", "code"], "pass": ["push", "string", "sum", "mess", "id", " mess", "user", " mac", "act", "ref", "wd", "key", "fail", " passed", " auth", "mac", "PASS", "phrase", "login", "diff", "r", "ask", "text", "Pass", " def", "gen", "row", "conn", "ass", " login", "pos", "az", "ss", "db", "sl", "strip", "pa", "secret", "auth", " Pass", "conf", "sign", "def", " secret"], "vis": ["class", "att", "qa", "cross", "id", "ex", "spot", "travel", "act", "c", "lab", "miss", "ref", "rib", "host", "press", "mit", "su", "dc", "san", "feat", "visible", "type", "stat", "see", "acc", "nav", "ip", "keep", "style", "lit", "tri", "name", "coll", "nic", "vest", "status", "VIS", "exp", "ravis", "access", "circ", "virt", "vid", "na", "skip", "nat", "secret", "shape", "design", "gu", "sign", "Vis", "wa", "state", "vert", "fac", "view", "mis"]}}
{"id1": "16511008", "id2": "3375718", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "label": 1, "substitutes": {"createNewProfilingMessageSymbol": ["createNewProfilingMsgSymmb", "createNewProfilingMessageSymmbol", "createNewProfilingMsgSyletter", "createNewProfilingMessageSymmb", "createNewProfilingMessageSymletter", "createNewProfilingMessageSyletter", "createNewProfilingMsgSymletter", "createNewProfilingMessageYmbol", "createNewProfilingMessageCymb", "createNewProfilingMsgSymmbol", "createNewProfilingMsgSymbol", "createNewProfilingMessageCymbol", "createNewProfilingMessageYmb", "createNewProfilingMessageCyletter", "createNewProfilingMessageSymb", "createNewProfilingMsgSymb", "createNewProfilingMessageYletter"], "configID": ["ConfigURL", " configId", "ConfigID", " configURL", "ConfigUID", "projectURL", "ConfigId", " configION", "projectId", "configId", "configION", " configUID", "projectION", "configUID", "ConfigION", "projectUID", "projectID", "configURL"], "programMessageSymbolID": ["programMessageSyncmbolID", "programMessageSyncmbolId", "programMessageSyntaxID", "programMessageSymbId", "programMessageSychid", "programMessageSyncmbid", "programMessageSyncmbolIP", "programMessageSyntaxName", "programMessageSyncmbId", "programMessageSymbolid", "programMessageSyncmbolid", "programMessageSyymID", "programMessageSyklName", "programMessageSymbolId", "programMessageSyncmbID", "programMessageSyymName", "programMessageSymbName", "programMessageSymbolName", "programMessageSyncmbIP", "programMessageSyklID", "programMessageSyncmbolName", "programMessageSyntaxId", "programMessageSymbIP", "programMessageSyymId", "programMessageSymbid", "programMessageSyncmbName", "programMessageSyklId", "programMessageSymbID", "programMessageSychId", "programMessageSyntaxid", "programMessageSychID", "programMessageSyymIP", "programMessageSymbolIP"], "profilingMessageSymbol": ["profilingMessageSynPart", "profilingFileSymmbol", "profilingMessageTyPart", "profilingMessageYletter", "profilingFileSymb", "profilingMessageSymb", "profilingMessageSymmb", "profilingFileSymbol", "profilingFileSymmb", "profilingFileSyletter", "profilingMessageCymb", "profilingMessageYmbol", "profilingMessageSymletter", "profilingMessageCyletter", "profilingMessageSynmb", "profilingMessageSymPart", "profilingApplicationSyletter", "profilingApplicationSymmb", "profilingMessageSyletter", "profilingApplicationSymbol", "profilingApplicationSymb", "profilingMessageSyPart", "profilingFileSymletter", "profilingMessageCymbol", "profilingApplicationSymletter", "profilingFileSymPart", "profilingMessageSymmbol", "profilingMessageTymbol", "profilingApplicationSymmbol", "profilingMessageSynmbol", "profilingFileSyPart", "profilingMessageTymb", "profilingMessageYmb"], "connection": ["directory", "Connection", "index", "server", "response", "lock", "document", "con", "c", "connected", "communication", "table", "result", "socket", "driver", "pool", "relation", "si", "manager", "database", "condition", "password", "client", "session", "use", "cache", "cond", "ion", "application", "collection", "section", "config", "machine", "channel", "environment", "log", "context", "conn", "image", "function", "db", "ctx", "sql", "bc", "position", "unit", "connect", "command", "state", "error", "engine", " Connection", "ongo"], "statement": ["directory", "Connection", "string", "agent", "execute", "response", "timeout", "lock", "report", "usage", "message", "document", "table", "library", "result", "ma", "se", "volume", "relation", "si", "pass", "database", "joined", "condition", "ment", "expression", "part", "session", "stat", "mt", "use", "str", "collection", "section", "parser", "out", "study", "conn", "Query", "Statement", "Session", "writer", "function", "commit", "db", "sql", "position", "unit", "comment", "parse", "summary", "connect", "command", "state", "error", "storage"], "resultSet": ["ResultGen", "ResultS", "resultSplit", "resultsSet", "resultsGen", "resultsSource", "dataSet", "resultS", "replySet", " resultS", "resultList", " resultSource", "resultType", " resultType", "resultLine", "resultSource", "replySplit", "ResultLine", "responseRow", " resultGen", "dataList", "dataLine", "responseSet", "ResultSplit", " resultLine", "dataSource", "rowS", "rowSource", "dataRow", "ResultType", "responseList", " resultSplit", "replyList", "rowSet", "rowType", "resultRow", "ResultSource", "resultGen", " resultList", "replyLine", "dataGen", "ResultList", "ResultRow", "ResultSet"], "query": ["index", "reason", "string", "root", "execute", "id", "uri", "lock", "timeout", "report", "message", "description", "table", "result", "join", "qu", "qs", " Query", "eries", "o", "database", "key", "condition", "select", "expression", "filter", "type", "rule", "q", "value", "str", "feature", "ql", "work", "go", "request", "search", "sq", "style", "Query", "name", "send", "function", "call", "sql", "update", "comment", "parse", "question", "command", "scan", "script", "error", "module", "code"], "msg": ["rag", "reason", "pkg", "id", "cmp", "lang", "rr", "op", "var", "sg", "map", "message", "cap", "ge", "ma", "html", "tag", "dr", "mr", "ms", "bg", "bag", "cm", "mt", "doc", "fg", "ug", "str", "g", "md", "ger", "cmd", "text", "gs", "sim", "exc", "agg", "log", "ag", "gen", "Message", "format", "title", "desc", "name", "m", "gr", "status", "e", "gor", "db", "og", "nm", "mn", "comm", "err", "mg", "gm", "error", "phrase", "tool", "cfg", "Msg", "loc"]}}
{"id1": "7087108", "id2": "8320469", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 0, "substitutes": {"doGet": ["processGet", "didGet", "processGET", "processPut", "doDownload", "didGET", "didDownload", "didPut", " doPut", "doGET", "doPut", " doDownload", " doGET", "processDownload"], "request": ["event", "info", "error", "buffer", "string", "input", "Request", "server", "resource", "uri", "user", "builder", "self", "report", "http", "subject", "message", "json", "version", "project", "current", "result", "forward", "instance", "child", "host", "query", "condition", "req", "client", "type", "reader", "use", "connection", "target", "model", "application", "config", "data", "parent", "route", "web", "object", "context", "complete", "name", "QUEST", "url", "create", "xml", "method", "this", "external", "view"], "response": ["remote", "server", "output", "resource", "report", "http", "results", "message", "document", "site", "version", "json", "result", "content", "client", "cache", "resp", "connection", "model", "application", "wave", "collection", "out", "body", "page", "object", "reply", "example", "status", "writer", "image", "Response", "respond", "reference", "method", "service", "view"], "path": ["directory", "index", "string", "info", "base", "id", "uri", "output", "resource", "http", "message", "filename", "Path", "location", "key", "pattern", "content", "filter", "cache", "dir", "value", "ath", "config", "data", "text", "route", "out", "object", "p", "format", "name", "folder", "image", "url", "PATH", "method", "point"], "file": ["directory", "zip", "info", "base", "handler", "class", "fe", "resource", "uri", "feed", "lock", "http", "filename", "socket", "fp", "l", "child", "File", "part", "source", "use", "rule", "dir", "up", "lib", "connection", "FILE", "work", "data", "out", "route", "local", "le", "object", "h", "log", "name", "folder", "image", "to", "it", "function", "full", "files", "url", "pe", "b", "f"], "in": ["IN", "pin", "i", "input", "id", "serv", "copy", "resource", "ini", "gin", "con", "c", "socket", "as", "inner", "s", "ins", "bin", "is", "source", "thin", "reader", "binary", "login", "r", "inc", "data", "out", "rin", "init", "ax", "isin", "it", "In", "nin", "kin", "stream", "lin", "b", "ac", "cin", "inn", "f", "win", "din"]}}
{"id1": "1133123", "id2": "11005804", "code1": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"openConnection": ["openChannel", "closeConnect", "closeConnection", "OpenConnect", "createConnector", "createConn", "closeConnector", "OpenConnection", "openConnect", "createConnection", "OpenConnector", "OpenChannel", "closeChannel", "closeConn", "OpenConn", "openConn", "openConnector", "createChannel", "createConnect"], "url": ["path", "address", "buffer", "ssl", "base", "server", "uri", "resource", "id", "http", "limit", "l", "host", "location", "URL", "el", "iter", "source", "proxy", "connection", "str", "config", "data", "file", "channel", "options", "bel", "ll", "object", "log", "null", "name", "image", "link", "sl", "Url", "f", "this", "service", "loc"]}}
{"id1": "23199071", "id2": "17996547", "code1": "            @Override\n            public InputStream getInputStream() {\n                try {\n                    String url = webBrowserObject.resourcePath;\n                    File file = Utils.getLocalFile(url);\n                    if (file != null) {\n                        url = webBrowserObject.getLocalFileURL(file);\n                    }\n                    url = url.substring(0, url.lastIndexOf('/')) + \"/\" + resource;\n                    return new URL(url).openStream();\n                } catch (Exception e) {\n                }\n                return null;\n            }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 0, "substitutes": {"getInputStream": ["getContentChannel", "getStreamChannel", "getReadChannel", "getStreamstream", "newContentStream", "getReadSteam", "newInputChannel", "getInputChannel", "getContentSteam", "getContentstream", "getStreamStream", "newInputSteam", "getReadstream", "newContentstream", "newInputStream", "getInputstream", "getReadStream", "getInputSteam", "newInputstream", "newContentSteam", "newContentChannel", "getStreamSteam", "getContentStream"], "url": ["string", "path", "base", "address", "remote", "i", "class", "id", "uri", "resource", "server", "feed", "buffer", "user", "http", "resources", "ref", "rel", "lr", "l", "location", "host", "URL", "html", "el", "fr", "in", "fl", "email", "type", "source", "rule", "jar", "dir", "q", "r", "str", "default", "ob", "build", "data", "route", "ssl", "cl", "web", "page", "ll", "bel", "log", "null", "href", "name", "coll", "image", "full", "link", "sl", "rl", "secure", "Url", "pull", "www", "ur", "left", "ul", "download", "f", "gl", "tool", "service", "api", "loc"], "file": ["play", "letter", "path", "info", "base", "class", "job", "fe", "zip", "id", "resource", "uri", "feed", "http", "plain", "place", "fp", "l", "child", "line", "File", "part", "source", "cache", "rule", "dir", "money", "lib", "live", "connection", "use", "model", "FILE", "work", "data", "route", "able", "page", "object", "local", "log", "name", "folder", "e", "image", "db", "full", "files", "unit", "b", "f", "loc"]}}
{"id1": "10936821", "id2": "5035872", "code1": "    @Override\n    public void doIt() {\n        try {\n            Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\");\n            if (mode.equals(\"FTP\")) {\n                FTPClient client = new FTPClient();\n                client.connect(Constants.ftpHost);\n                client.login(Constants.ftpUser, Constants.ftpPass);\n                client.changeDirectory(Constants.ftpDir);\n                File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName);\n                client.download(\"GT99_A09.rar\", ff);\n                client.disconnect(false);\n                Shared.prepareMovements(ff);\n            } else if (mode.equals(\"File\")) {\n                JFileChooser jfc = new JFileChooser();\n                FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\");\n                jfc.setFileFilter(f);\n                int selection = jfc.showOpenDialog(Shared.getMyMainWindows());\n                if (selection == JFileChooser.APPROVE_OPTION) {\n                    Shared.prepareMovements(jfc.getSelectedFile());\n                } else {\n                    return;\n                }\n            }\n            Shared.updateMovements();\n            if (Shared.isHadMovements()) {\n                MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\");\n                msg.show(Shared.getMyMainWindows());\n            } else {\n                MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\");\n                msg.show(Shared.getMyMainWindows());\n            }\n        } catch (Exception ex) {\n            MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex);\n            msg.show(Shared.getMyMainWindows());\n        }\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"doIt": ["runInit", "runit", "DoInit", " doit", "doit", "Doit", "DoSomething", "DoIt", "runIt", "runSomething", " doSomething", " doInit", "doInit", "doSomething"], "client": ["ssl", "class", "resource", "http", "net", "host", "API", "cm", "cp", "ce", "default", "open", "conv", "file", "get", "conn", "force", "ci", "url", "contact", "server", "clean", "end", "cache", "connection", "parent", "cl", "ip", "cloud", "plugin", "Client", "connect", "help", "and", "remote", "close", "i", "con", "act", "per", "socket", "grid", "co", "util", "session", "bird", "web", "request", "p", "secure", "app", "cli", "pg", "api", "cell", "console", "user", "project", "clip", "pool", "config", "https", "local", "port", "call", "simple"], "ff": ["uff", "fe", "sf", "bf", "lf", "feed", "cf", "df", "bd", "fff", "eb", "fi", "eff", "fp", "cb", "flow", "ft", "cpp", "uf", "fl", "mb", "abb", "cp", "back", "pp", "kk", "buff", "eph", "buf", "iff", "aff", "ob", "fb", "cl", "nd", "ef", "bb", "cd", "FF", "af", "upp", "fd", "url", "ph", "fx", "front"], "jfc": ["jFC", "dcf", "jscf", "ffc", " jFC", "Jfe", "fFC", "jbc", "Jbc", "Jxf", "Jcf", "jfe", "Jfc", "jetxf", "JFC", " jcf", "lpc", "lFC", "jetpc", "Jpc", "jetFC", "lfc", "jspc", "dfc", "jpc", "jxf", " jbc", "jetfc", "jcf", "dpc", "dfe", "fcf", "fbc", " jpc", "jsfe", "jsfc", " jxf", "lcf"], "f": ["info", "handler", "fe", "sf", "xf", "lf", "fs", "i", "cf", "df", "rf", "self", "n", "c", "fc", "j", "fp", "l", "s", "filter", "d", "r", "g", "w", "file", "fb", "orf", "h", "p", "fo", "e", "m", "t", "io", "F", "fd", "v", "b", "raf", "fac"], "selection": ["directory", "index", "info", "sel", "ssl", "sc", "choice", "entry", "qua", "option", "slice", "location", "shell", "match", "slot", "si", "management", "election", " selecting", "select", "expression", " selected", "sb", " Selection", "which", "connection", "lection", "selected", "cl", "language", "delete", "edition", "desc", " selections", "ling", "sl", "position", "Se", "ses", "url", "SELECT", "random", "loc"], "msg": ["error", "mess", "pkg", "mu", "lang", "console", "game", "generic", "mail", "sg", "message", "ck", "kg", "html", "global", "s", "mit", "arg", "ms", "bg", "cm", "doc", "live", "cat", "g", "md", "gs", "file", "body", "exc", "get", "Message", "log", "gen", "plugin", "view", "m", "dict", "e", "send", "dm", "db", "link", "og", "bot", "bug", "comm", "conf", "err", "mg", "help", "ng", "gm", "cmd", "gl", "module", "list", "Msg", "img"]}}
{"id1": "22268798", "id2": "1188100", "code1": "    @Override\n    public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException {\n        String uniqueName = path.getBaseName();\n        URL url = buildURL(uniqueName);\n        URLContent content = new URLContent(url, this.getName(), uniqueName);\n        content.setUniqueName(uniqueName);\n        content.setReadable(true);\n        content.setWritable(writable);\n        content.setExists(true);\n        try {\n            URLConnection connection = url.openConnection();\n            String mimeType = connection.getContentType();\n            content.setMimeType(mimeType);\n            content.setWritable(true);\n        } catch (IOException ex) {\n            throw new ContentException(\"unable to obtain mime type of \" + url, ex);\n        }\n        return content;\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["loadContent", "loadcontent", "loadContents", "createContent", "createResource", "loadResource", "buildContent", "buildcontent", "createContents", "buildContents", "buildResource", "createcontent", "getContents", "getResource", "getcontent"], "principal": ["prunctential", "Princincential", "Princunctential", "pricipificate", "pricipipal", "prercipal", "Princinceter", "Princincificate", "prercificate", "Princincipal", "Princunctipal", "Princunctificate", "pricipential", "prunctipal", "pricipeter", "prerceter", "princificate", "princeter", "prercential", "Princuncteter", "pruncteter", "prunctificate", "princential"], "path": ["root", "string", "node", "class", "loader", "info", "resource", "uri", "user", "project", "Path", "instance", "location", "pattern", "next", "client", "part", "source", "ath", "parent", "data", "text", "file", "object", "request", "context", "format", "name", "pointer", "link", "prefix", "PATH", "prop", "method", "property", "api"], "version": ["val", "string", "release", "node", "server", "resource", "json", "project", "current", "versions", "date", "value", "target", "model", "str", "parent", "level", "out", "VERSION", "object", "format", "ver", "v", "Version", " versions", "vision", "depth"], "properties": ["address", "settings", "results", "perties", "resources", "json", "features", "params", "items", "Property", "pro", "data", "classes", "options", "objects", "plugins", "ips", "metadata", "types", "details", "values", "fields", "prop", "state", "ps", "Pro", "property"], "uniqueName": ["uniqueType", "UniquePath", " uniqueTime", "filename", "UniqueKey", "basePath", " uniquename", "filePath", "blockType", " uniquePath", " uniqueKey", "uniqueTime", "uniqueKey", "fileName", " uniqueType", "uniquePath", "UniqueTime", "stringName", "blockPath", "uniquename", "baseKey", "baseName", "UniqueName", "blockName", "stringKey", "Uniquename", "fileTime", "blockKey", "basename", "stringname", "UniqueType", "stringPath"], "url": ["string", "base", "address", "ssl", "server", "uri", "resource", "feed", "user", "http", "html", "location", "l", "host", "URL", "el", "client", "source", "proxy", "build", "ob", "parent", "open", "file", "channel", "web", "object", "ll", "page", "log", "bb", "conn", "name", "coll", "ls", "image", "link", "sl", "layer", "Url", "position", "www", "found", "f", "error", "this", "download", "loc"], "content": ["remote", "address", "core", "temp", "node", "server", "resource", "response", "output", "copy", "user", "cf", "message", "c", "cont", "current", "document", "result", "instance", "child", "host", "lc", "location", "key", "condition", "Content", "client", "cm", "source", "load", "ce", "proxy", "cover", "media", "model", "common", "default", "section", "parent", "config", "file", "ca", "data", "page", "object", "conn", "creator", "reader", "complete", "coll", "change", "image", "full", "const", "layer", "ext", "update", "comment", "create", "handler", "ac", "wrapper", "container", "cache", "this", "code"], "connection": ["directory", "Connection", "string", "handler", "server", "resource", "response", "uri", "http", "character", "con", "c", "connected", "number", "pool", "relation", "database", "client", "session", "reader", "proxy", "application", "open", "config", "data", "channel", "section", "object", "context", "control", "conn", "creator", "coll", "io", "image", "position", "connect", "container", "communication", "loc"], "mimeType": ["mimeInfo", "mimestype", "mimePath", "MimePath", "MIMEPath", "metytype", "mmiveInfo", "mIMEInfo", "MimeType", "mmivetype", "miveType", "mivetype", "metyInfo", "mIMEName", "metyType", "mmiveType", "mangName", "MimeName", "MIMEType", "miveInfo", "mimetype", "mmimeType", "MIMEtype", "mangtype", "MIMEName", "mmimetype", "mangPath", "mIMEType", "mmimeInfo", "mIMEPath", "Mimetype", "mimesName", "mimesPath", "mIMEtype", "mimeName", "mimesType", "mangType"]}}
{"id1": "19810820", "id2": "13516684", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"copyFileChannel": ["copyFilechannel", "transferfileStream", "copyDirectoryChannel", "copyDirectoryChan", "copyDirectorychannel", "copyStreamChan", "copyfileStream", "transferFilechannel", "transferFileChan", "copyDirectoryStream", "copyfileChan", "transferFileStream", "transferFileChannel", "transferfilechannel", "transferfileChan", "copyStreamChannel", "copyfileChannel", "copyFileChan", "copyStreamStream", "copyStreamchannel", "copyFileStream", "transferfileChannel", "copyfilechannel"], "src": ["path", "rest", "sel", "sin", "ssl", "sc", "server", "input", "sys", "rc", "Source", "lower", "slice", "filename", "sub", "dest", "loc", "s", "inst", "func", "rs", "SOURCE", "sync", "client", "sit", "source", "rb", "sb", "dist", "upload", "config", "ruby", "tmp", "sq", "conn", "ls", "sth", "start", "RC", "sup", "sl", "ctx", "url", "ses", "scene", "stream", "b", "st", "cur", "download", "img"], "dst": ["tst", "drc", " dST", "dart", "adrc", "adST", "ddest", "Ddest", "DST", "adput", "stlt", "bart", "bst", "dST", "Dost", "fdst", "dost", " ddest", "bput", "tart", "fdrc", "ldost", "lddest", "ldST", "dput", "bST", "start", "ldst", "fdput", "Dst", "stst", "stST", "blt", "adst", "dlt", " dost", "fdST", "tlt", "brc", "tST"], "preserveModificationTime": ["preserveModifiedFile", "preserveModifyingTime", "preserveModifytime", "preserveModifyTime", "preserveMinificationFile", "preserveMinificationTime", "preserveModationFile", "preserveModifiedtime", "preserveModifiedTime", "preserveModifyingFile", "preserveMinifiedtime", "preserveMinificationtime", "preserveModificationFile", "preserveMinifiedTime", "preserveMinifiedFile", "preserveModificationtime", "preserveModationTime", "preserveModifyingtime", "preserveModationtime"], "inputChannel": ["errorChannel", "fileConnection", " inputConnection", "outputConnection", " inputBuffer", " inputchannel", "inputchannel", "inputSocket", "InputBuffer", "outputBuffer", "outputGate", "imagechannel", "imageGate", "InputQueue", "binaryGate", "binaryChan", "fileChannel", "outputSocket", " inputSocket", " inputConsole", "InputSocket", "outputQueue", " inputCode", "inputChan", " inputQueue", "fileChan", "inputConsole", "inputBuffer", "binarychannel", "inputConnection", " inputStream", "errorChan", "errorCache", "outputCache", "outputStream", "inputCache", "errorStream", "inputStream", "outputchannel", "InputChannel", "requestStream", "requestCode", "Inputchannel", "fileConsole", "binaryChannel", "outputConsole", " inputChan", " inputCache", "outputChan", "InputChan", "inputGate", "inputQueue", "outputCode", "requestChan", "imageChan", "requestChannel", "imageChannel", "inputCode"], "outputChannel": ["Outputchannel", " outputchannel", "outputManager", "OutputQueue", " outputQueue", "OutputChannel", " outputManager", " outputButton", "outputQueue", "inputChan", "outStream", "outchannel", "outChan", "OutputStream", "writeQueue", " outputStream", "writeChannel", "outputStream", "outputchannel", "inputStream", " outputChan", "outputButton", "outButton", "writeStream", "writeManager", "outputChan", "OutputChan", "writeChan", "outChannel", "inputButton", "inputManager"], "length": ["base", "max", "sum", "buffer", "head", "duration", "id", "lock", "sequence", "slave", "current", "end", "result", "volume", "limit", "l", "join", "php", "child", "number", "last", "offset", "next", "form", "part", "session", "type", "load", "delay", "value", "len", "Length", "build", "section", "text", "size", "style", "complete", "start", "available", "full", "pull", "position", "partial", "with", "count", "block", "width"], "total": ["base", "max", "sum", "i", "translation", "duration", "id", "info", "current", "result", "limit", "set", "all", "otal", "done", "failed", "key", "last", "offset", "part", "less", "type", "no", "Total", "len", "used", "size", "complete", "start", "available", "toc", "full", "always", "partial", "count", "found", "multi", "scale", "error", "cur", "valid"]}}
{"id1": "8132219", "id2": "18782385", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "inFile": ["inputPlace", " inSourceFile", "InSourceFile", "INfile", "binfile", "outPlace", "inputfile", "outfile", " infile", "infile", "inputFile", "outFiles", "InFilename", " inFilename", "Infile", "inFiles", "inPlace", "inputFiles", "binFiles", "binFile", "INFile", "binPlace", "InFile", "INSourceFile", "inFilename", "inSourceFile", "INFilename"], "outFile": ["againFilename", "outputFilename", "outputfile", "againFile", " outfile", "outPlace", "outfile", "infile", "outFiles", "outputPlace", " outFilename", "inFiles", "againfile", " outFiles", "outputFiles", "againPlace", "outFilename", "inFilename", "outputFile", " outPlace"], "in": ["IN", "index", "pin", "base", "i", "input", "id", "n", "ini", "ic", "c", "inner", "as", "ins", "bin", "is", "part", "like", "reader", "source", "connection", "inc", "work", "data", "file", "config", "rin", "x", "name", "again", "m", "image", "io", "In", "a", "url", "inn", "f", "din"], "out": ["string", "buffer", "ex", "output", "n", "copy", "resource", "user", "Output", "plain", "c", "OUT", "version", "o", "outs", "write", "line", "bin", "client", "part", "cache", "dot", "default", "w", "data", "file", "x", "p", "log", "null", "conn", "name", "exec", "Out", "io", "image", "writer", "to", "call", "prefix", "ext", "v", "b", "obj", "external"], "inChannel": ["sinSocket", "INSocket", "inSocket", "inputChannel", "INchannel", "iniChannel", "inStream", " inFlow", " inchannel", "inputchannel", "inchannel", "INFlow", "sinChannel", "inLanguage", "sinChan", "iniLanguage", "winLanguage", "inputChan", "iniStream", "INChan", "outStream", "outchannel", "outChan", "inChan", "inputStream", "inichannel", "outConnection", "INStream", "winChannel", "winchannel", " inConnection", "INChannel", "inConnection", " inChan", "winStream", "sinFlow", " inSocket", "inFlow", "INConnection", "outLanguage"], "outChannel": [" outContext", "OutStream", "againChannel", "OutConnection", "OutChannel", "inchannel", "outContext", " outConnection", "againPath", "againChan", "OutChan", "outStream", "outchannel", "inPath", "outChan", "inChan", "outPath", "OutContext", "outputchannel", "outputChannel", " outPath", "outConnection", "newStream", "Outchannel", "newChan", "againchannel", "outputChan", "inConnection", " outStream", "newContext", "newChannel", " outchannel", " outChan"]}}
{"id1": "3409084", "id2": "10540676", "code1": "    protected String getRequestContent(String urlText) throws Exception {\n        URL url = new URL(urlText);\n        HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();\n        urlcon.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream()));\n        String line = reader.readLine();\n        reader.close();\n        urlcon.disconnect();\n        return line;\n    }\n", "code2": "    public static void checkForUpgrade(Event event) throws Exception {\n        ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"applyUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(false);\n        new Command(\"DELETE FROM TBLINSTALLATION WHERE STATUS<>'APPLIED'\").executeNonQuery();\n        String clientAppliedVersion = new Command(\"SELECT MAX(VERSION) FROM TBLINSTALLATION WHERE STATUS='APPLIED'\").executeScalarAsString();\n        if (NullStatus.isNull(clientAppliedVersion)) {\n            clientAppliedVersion = \"20050101\";\n        }\n        String macquery = \"\";\n        String clientMAC = \"\";\n        String clientUNITID = UiUtil.getUNITUID();\n        ArrayList<String> macList = getMacList();\n        for (int i = 0; i < macList.size(); i++) {\n            clientMAC += macList.get(i) + \",\";\n            macquery += \"'\" + macList.get(i) + \"'\";\n            if (i < macList.size() - 1) {\n                macquery += \",\";\n            }\n        }\n        URL urlLICENSEQUERY = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC + \"&tegsoftCOMMAND=LICENSEQUERY\");\n        URLConnection urlConnection = urlLICENSEQUERY.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String commingList = \"\";\n        String line;\n        while ((line = in.readLine()) != null) {\n            commingList += line;\n        }\n        in.close();\n        String licenseArray[] = commingList.split(\"</ROW>\");\n        if (licenseArray.length > 0) {\n            String fields[] = licenseArray[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        Dataset TBLLICENSE = new Dataset(\"TBLLICENSE\", \"TBLLICENSE\");\n        Command command = new Command(\"DELETE FROM TBLLICENSE WHERE UNITUID={UNITUID} AND (NOTES IN (\");\n        command.append(macquery);\n        command.append(\") OR NOTES IS NULL) \");\n        command.executeNonQuery();\n        for (int i = 1; i < licenseArray.length; i++) {\n            String fields[] = licenseArray[i].split(\"</FLD>\");\n            String LICTYPE = fields[0];\n            String UNIQUEKEY = fields[1];\n            String LICKEY = fields[2];\n            DataRow dataRow = TBLLICENSE.addNewDataRow();\n            dataRow.set(\"LICENSENAME\", LICTYPE);\n            dataRow.set(\"LICENSE\", LICKEY);\n            dataRow.set(\"NOTES\", UNIQUEKEY);\n            TBLLICENSE.save();\n        }\n        URL url = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC);\n        urlConnection = url.openConnection();\n        in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String upgradeList = \"\";\n        while ((line = in.readLine()) != null) {\n            upgradeList += line;\n        }\n        in.close();\n        Dataset TBLINSTALLATION = new Dataset(\"TBLINSTALLATION\", \"TBLINSTALLATION\");\n        String upgrades[] = upgradeList.split(\"</ROW>\");\n        if (upgrades.length > 0) {\n            String fields[] = upgrades[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        boolean restartRequired = false;\n        boolean updateAvailable = false;\n        for (int i = 1; i < upgrades.length; i++) {\n            String fields[] = upgrades[i].split(\"</FLD>\");\n            String VERSION = fields[0];\n            String ORDERID = fields[1];\n            String UPGRADETYPE = fields[2];\n            String DESCRIPTION = fields[3];\n            String STATUS = \"UNAPPLIED\";\n            String PRDNAME = \"TegsoftCC\";\n            if (\"TEGSOFTJARS\".equals(UPGRADETYPE) || \"TOBEJARS\".equals(UPGRADETYPE) || \"ALLJARS\".equals(UPGRADETYPE) || \"CONFIGASTERISK\".equals(UPGRADETYPE)) {\n                restartRequired = true;\n            }\n            DataRow dataRow = TBLINSTALLATION.addNewDataRow();\n            dataRow.set(\"ORDERID\", ORDERID);\n            dataRow.set(\"PRDNAME\", PRDNAME);\n            dataRow.set(\"UPGRADETYPE\", UPGRADETYPE);\n            dataRow.set(\"VERSION\", VERSION);\n            dataRow.set(\"STATUS\", STATUS);\n            dataRow.set(\"DESCRIPTION\", DESCRIPTION);\n            TBLINSTALLATION.save();\n            updateAvailable = true;\n        }\n        UiUtil.getDataset(\"TBLINSTALLATION\").reFill();\n        if (restartRequired) {\n            ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(true);\n            ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(true);\n        }\n        if (updateAvailable) {\n            ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(true);\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_4));\n        } else {\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_5));\n        }\n    }\n", "label": 0, "substitutes": {"getRequestContent": ["getResponseContent", "getHttpBody", "readRequestText", "readResponseBody", "getrequestString", "getHttpContent", "getRequestString", "getRequestText", "getResponseBody", "getRequestBody", "getrequestText", "readResponseText", "readResponseString", "readRequestString", "getrequestBody", "readResponseContent", "getrequestContent", "getResponseString", "getHttpText", "getResponseText", "getHttpString", "readRequestBody", "readRequestContent"], "urlText": ["httpText", "urltext", " urlString", "urlTEXT", "resourceContent", "resourcetext", "resourceText", "strContent", "urlString", "httpString", " urltext", "resourceTEXT", "pageString", " urlContent", "strText", "strTEXT", "strtext", " urlTEXT", "urlContent", "pageTEXT", "pageText", "httpTEXT"], "url": ["path", "base", "ssl", "server", "resource", "feed", "uri", "user", "http", "c", "lr", "l", "host", "URL", "fl", "client", "connection", "r", "str", "build", "open", "config", "web", "object", "ll", "page", "log", "conn", "or", "ls", "image", "blog", "full", "sl", "rl", "Url", "bc", "www", "ur", "b", "f", "this", "api"], "urlcon": ["urcon", " urlCon", "urlclient", "webconnect", "httpconn", "httpcon", "webann", "urlann", "webcon", "Urlclient", "httprun", " urlrun", "urconn", "urconst", "URLCon", "webCon", "URLclient", " urlann", " urlconst", "Urlfc", " urlconn", "webenc", "httpann", "httpfc", "urlCon", "Urlcon", "UrlCon", "urlfc", "httpCon", " urlconnect", "httpenc", "urlrun", "urlconnect", "httpclient", "httpconnect", " urlenc", "urlenc", "URLcon", "URLfc", "urlconn", "webconn", "urlconst", "httpconst", "urrun"], "reader": ["buffer", "loader", "i", "input", "editor", "her", "handler", "reading", "ker", "per", "inner", "ri", "result", "keeper", "read", "in", "iter", "ler", "er", "bird", "oder", "ner", "r", "parser", "data", "file", "director", "rar", "row", "rr", "or", "rer", "io", "writer", "rx", "worker", "car", "cher", "layer", "ser", "stream", "finder", "Reader"], "line": ["val", "letter", "string", "buffer", "feed", "response", "user", "entry", "message", "LINE", "end", "pass", "read", "char", "content", "email", "lines", "value", "str", "data", "file", "text", "body", "page", "log", "row", "inline", "name", "link", "lin", "Line", "block", "element", "code", "cell"]}}
{"id1": "5951610", "id2": "1421557", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"testNetworkHTTP": [" testInternetHttp", "testnetworkSSL", " testNetworkHTML", "testnetworkHTML", "testnetworkHTTP", " testInternetSSL", "testInternetSSL", "testNetworkHttp", "testNETHTML", "testNetworkHTML", " testNetworkSSL", " testInternetHTML", "testInternetHttp", "testNETHTTP", "testNetworkSSL", "testInternetHTTP", " testNetworkHttp", "testnetworkHttp", "testNETHttp", " testInternetHTTP", "testInternetHTML", "testNETSSL"], "url": ["ssl", "base", "loader", "resource", "output", "http", "lr", "host", "large", "URL", "lib", "ob", "build", "file", "coll", "sl", "ol", "gl", "org", "impl", "buffer", "server", "feed", "bf", "location", "shell", "pl", "fl", "use", "load", "lc", "connection", "r", "channel", "cl", "page", "nl", "cloud", "control", "rl", "bl", "left", "ul", "tool", "service", "event", "path", "job", "uri", "entry", "mail", "rel", "el", "util", "hl", "email", "group", "web", "ll", "image", "blog", "ml", "Url", "update", "www", "ur", "view", "user", "l", "il", "key", "dl", "config", "github", "text", "log", "ls", "call", "pull", "layer", "loc"], "urlConnection": ["urlComputer", "sslConnector", "webPool", "ulConn", "urlGate", "serviceConnection", "flConnect", " urlFunction", "termComputer", "flConnection", " urlEnvironment", "UrlConnection", " urlPool", "URLConnection", "urlConnect", " urlGate", " urlUnit", "URLconnection", "uriComputer", "urConn", "viewConstruction", " urlContainer", "termConnection", "glConnection", "emailconnection", "ulConnection", "sslUnit", "viewconnection", "resourceConnection", "resourceClient", "numberconnection", "flConnector", " urlClient", "httpConnection", "implEnvironment", "lConnection", " urlComputer", " urlconnection", "blogconnection", "implReference", "lConnect", "urlEnvironment", " urlConnect", "urlReference", "urlFunction", "flconnection", " urlFactory", "urlUnit", "lengthConnection", "htmlConstruction", "lConn", "urlContainer", "urlconnection", "URLConn", "glConn", "ulConnector", "serviceConn", "webConnection", "urlConstruction", "sslConnection", "serviceConnect", "glConnect", "lengthconnection", "implConnection", "glFunction", "viewConnection", "httpComputer", "termConn", " urlConn", "lconnection", "uriUnit", "ulUnit", "resourceconnection", "httpConn", "emailClient", "URLConnect", "urlPool", "sslConn", "urlFactory", "urlConnector", "UrlConnect", "viewConnect", "blogConnection", "htmlConnection", "UrlConn", "urFactory", " urlConnector", "htmlconnection", "urConnection", "emailConnection", "URLPool", "resourceGate", "numberConnect", "UrlContainer", "serviceconnection", " urlReference", "blogConnect", "UrlComputer", "webconnection", "numberConnection", "UrlReference", "flConstruction", "emailConnect", "lengthConstruction", "urFunction", "emailConstruction", "UrlFunction", "uriConnection", "httpUnit", "emailGate", "urlConn", "blogConnector", "numberConnector", "termContainer", "httpFactory", "uriFunction", "httpFunction", "lengthConnect", "urlClient", "UrlEnvironment"], "rd": ["R", "lt", "rw", "bf", "dra", "gd", "wr", "bd", "rf", "lf", "RR", "dj", "ru", "rg", "lr", "dr", "rt", "fr", "wd", "usr", "rs", "ld", "RD", "std", "RL", "arr", "rowd", "nor", "rb", "reader", "rh", "d", "xd", "dh", "rod", "sr", "rid", "erd", "ird", "r", "rn", "DR", "nd", "director", "nl", "rown", " reader", "rr", "dig", "own", "rss", "rand", "addr", "rx", "sth", "rob", "adr", "db", "fd", "rl", "tr", "respond", "td", "hr", "red", "vd", "ds", "bl", "ng", "RW", "pd", "RF", "dd", "Reader"], "line": ["val", "letter", "string", "lo", "sel", "id", "lf", "response", "user", "entry", "LINE", "ge", "end", "number", "loc", "limit", "l", "col", "el", "day", "write", "pass", "ld", "key", "la", "part", "source", "d", "lines", "lc", "login", "len", "data", "li", "file", "cl", "page", "nl", "le", "log", "row", "inline", "ne", "msg", "name", "frame", "status", "word", "link", "sl", "rl", "skip", "unit", "comment", "lin", "Line", "block", "error", "code", "cell"]}}
{"id1": "2676365", "id2": "4830847", "code1": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "code2": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "label": 1, "substitutes": {"reset": [" migrate", "close", "release", "setup", "register", "et", " Reset", "activate", "set", "destroy", " rebuild", "save", " reconnect", " disconnect", "sync", "back", "disable", "delete", "init", "start", "commit", " checkpoint", " restore", "flush", "update", " shutdown", "clear", "stop"], "currentPilot": ["currentPointilot", "currentpacket", "activePilot", "currentCPilot", "activePacket", " currentCPacket", "currentPointacket", "activepacket", " currentCPector", " currentCPilot", "currentPortector", "currentPortacket", "activepistor", "activePistor", "activepiece", "currentPayacket", "currentPiece", "activepilot", "currentpiece", "currentPayistor", "currentpooter", "currentPortooter", "currentPayilot", "currentPointistor", "currentPooter", "currentPector", "currentpistor", "currentPortilot", " currentCPooter", "currentpector", "currentPayiece", "currentpilot", "currentPointiece", " currentPacket", "currentCPector", " currentPector", "currentPistor", "currentPacket", "currentCPooter", "currentCPacket", " currentPooter", "activePiece"], "psta": ["paresta", "jda", "jsta", " pppa", "Pda", " pla", "Pla", "Psa", "Pppa", "jsa", "pasi", "pla", "psa", "pda", "Pasi", "Pste", "parsta", "jste", "pesta", " pasi", "Pesta", "pela", "Psta", " pste", " pda", " psa", "pste", "parsa", "peppa", " pesta", "parasi", "pppa", "pesa"]}}
{"id1": "22431487", "id2": "16825994", "code1": "    public static String doPost(String URL, List<NameValuePair> params) {\n        try {\n            OauthUtil util = new OauthUtil();\n            URI uri = new URI(URL);\n            HttpClient httpclient = util.getNewHttpClient();\n            HttpPost postMethod = new HttpPost(uri);\n            StringBuffer paramString = new StringBuffer();\n            paramString.append(\"OAuth\");\n            for (int i = 0; i < params.size(); i++) {\n                paramString.append(\" \" + params.get(i).getName());\n                paramString.append(\"=\\\"\" + encodeUrl(params.get(i).getValue()) + \"\\\",\");\n            }\n            String xx = paramString.substring(0, paramString.length() - 1);\n            postMethod.addHeader(\"Authorization\", xx);\n            HttpResponse httpResponse = httpclient.execute(postMethod);\n            if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                String strResult = EntityUtils.toString(httpResponse.getEntity());\n                Log.i(\"DEBUG\", \"result: \" + strResult);\n                return strResult;\n            }\n        } catch (Exception e) {\n            Log.i(\"DEBUG\", e.toString());\n        }\n        return null;\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"doPost": [" doPosts", " doRequest", "apiPosts", "formRequest", " doLoop", "formPosts", "apiRequest", "doRequest", "doPosts", "doLoop", "formLoop", "apiPost", "apiLoop", "formPost"], "URL": ["R", "string", "NAME", "HTML", "resource", "GI", "http", "HTTP", "Path", "DB", "UR", "JSON", "File", "API", "METHOD", "Address", "FILE", "Page", "IR", "IO", "WS", "SSL", "Name", "IP", "Base", "CL", "Url", "url", "PATH", "DIR", "ID", "Location", "PORT", "SR", "URI"], "params": ["services", "Par", "server", "pi", "settings", "results", "http", "resources", "json", "features", "api", "apps", "s", "is", "rs", "parts", "changes", "terms", "users", "ams", "strings", "members", "par", "arms", "Parameters", "data", "names", "ras", "options", "request", "ip", "p", "es", "afi", "vs", "name", "ls", "pos", "types", "array", "details", "values", "relations", "url", "pins", "photos", "parse", "words", "ps", "properties", "Param", "param", "list"], "util": ["impl", "string", "U", "mu", "lu", "spec", "utt", "http", "auto", "il", "global", "manager", "ui", "su", "universal", "client", " url", "lib", " u", "internet", "ut", "kit", " utility", "utils", "u", "init", "mut", "io", "url", "Ut", "unit", "general", "iu", "gui", "cli", "anti", "api", "install", "valid"], "uri": ["path", "U", "base", "address", "handler", "PI", "server", "pi", "resource", "absolute", "response", "id", "http", "ri", " URI", "ui", "database", "API", "client", "Manager", "connection", "config", "route", "request", "plugin", "uni", "io", "iri", "Url", "url", "cli", "URI", "service", "api"], "httpclient": ["Httpserver", " httpmethod", " httpapi", "httpserver", "httpconnection", "Httpmethod", "httpsapi", " httpconnection", " httpClient", " httpconfig", "htmlClient", "httpClient", "httpconfig", "Httpapi", "httpmethod", "Httpconnection", "htmlmethod", "httpapi", "HttpClient", "Httpclient", " httpserver", "httpsclient", "httpsconnection", "Httpconfig", "httpsconfig", "htmlclient", "htmlserver"], "postMethod": [" postmethod", "patchMessage", " postFunction", "typeRequest", "POSTMethod", " postPath", "PostMethod", "Postmethod", "postMessage", "postPath", "postFunction", "patchMethod", "PostPath", "POSTFunction", "patchPath", "typemethod", "POSTRequest", "PostFunction", "postmethod", "PostMessage", " postMessage", "typeFunction", "PostRequest", "POSTmethod", "typeMethod", "patchFunction", " postRequest", "postRequest"], "paramString": ["cmString", "errorFile", "errorString", " paramStr", "priStr", "parArray", " paramFile", "ParamBuffer", " paramStream", "ParamList", "ParamService", "paramsString", "memberArray", "cmstring", "ParamArray", "paramBuffer", "parString", "paramStream", "paramstring", " paramArray", "priBuffer", "parFile", "errorBuffer", "paramService", " paramList", "paramsArray", "errorArray", "paramFile", "Paramstring", "memberFile", "priArray", "paramsStr", "paramArray", "ParamFile", " paramstring", "ParamStream", " paramBuffer", "paramsList", "ParamString", "paramStr", "parStream", "memberString", "ParamStr", "paramList", "priString", " paramService", "cmService", "cmArray", "memberstring"], "i": ["index", "info", "id", "n", "pi", "ei", "ini", "ie", "ic", "slice", "c", "j", "z", "ri", "o", "l", "length", "s", "si", "ui", "is", "ii", "ori", "key", "in", "qi", "part", "ti", "ji", "d", "q", "g", "data", "li", "ip", "x", "p", "bi", "u", "oi", "ai", "name", "ci", "I", "e", "m", "io", "eni", "t", "it", "xi", "di", "gi", "hi", "k", "v", "b", "y", "count", "iu", "multi", "f", "cli", "iv", "ix"], "xx": ["xxxx", " XX", "foo", "cc", "xa", "response", "enc", "ck", "json", "act", "uid", "X", "yy", "host", "Code", "zz", "XXX", "pass", "key", "XXXX", "xxx", "ux", "pp", "x", "ant", "header", "ax", "xy", "ss", "xi", "prefix", "xxxxxxxx", "XX", "cn", "vv", "code", "ww"], "httpResponse": ["HttpRequest", "postConnection", "postResponse", " httpConnection", "HttpResp", "httpConnection", "phpresponse", " httpresponse", "hrReply", " httpClient", " httpResp", "httpResp", "phpResp", "httpReply", "httpClient", "hrresponse", "httpRequest", " httpRequest", " httpReply", "Httpresponse", "HttpResponse", "HttpConnection", "HttpClient", "phpResponse", "HttpReply", "postResp", "hrResp", "postRequest", "hrResponse", "phpClient", "httpresponse"], "strResult": ["StrReturn", " strResponse", "drResponse", "StrResult", "StrStatus", "Strresult", "objReturn", "strresult", "drResult", "stringRes", "objResponse", " strRes", "objResult", "strReturn", "strStatus", "drStatus", "stringReturn", "drresult", "stringResult", "stringResponse", "StrResponse", " strresult", "objresult", " strStatus", "strResponse", "strRes", "StrRes", " strReturn"]}}
{"id1": "6159896", "id2": "15362793", "code1": "    public static String md5(String str) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - start\");\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] b = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < b.length; i++) {\n                int v = (int) b[i];\n                v = v < 0 ? 0x100 + v : v;\n                String cc = Integer.toHexString(v);\n                if (cc.length() == 1) sb.append('0');\n                sb.append(cc);\n            }\n            String returnString = sb.toString();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"md5(String) - end\");\n            }\n            return returnString;\n        } catch (Exception e) {\n            logger.warn(\"md5(String) - exception ignored\", e);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - end\");\n        }\n        return \"\";\n    }\n", "code2": "    public static String ReadURL(URL url, boolean textonly) {\n        try {\n            URLConnection uconn = url.openConnection();\n            Object ucont = uconn.getContent();\n            if (ucont instanceof InputStream) return ReadInputStream((java.io.InputStream) ucont, textonly); else return \"\" + ucont;\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"md5": [" md2", "MD7", "md2", "MD4", "sha2", "sha5", "md4", "MD5", "MD2", " md4", "sha4", " md7", "md7", "sha7"], "str": ["string", "buffer", "input", "self", "spec", "result", "s", "fr", "dr", "in", "char", "txt", "arr", "Str", "source", "doc", "strings", "r", "STR", "data", "text", "star", "style", "msg", "name", "e", "m", "exp", "bytes", "tr", "url", "hr", "obj", "sp", "br", "st", "f", "stri", "this", "code"], "md": ["pkg", "bf", "gd", "mem", "mag", "df", "bd", "vm", "Cmd", "amd", "mail", "wd", "MD", " MD", "rpm", "sm", "ld", "gb", "cm", "mb", "git", "dh", "mac", "d", "mp", "hd", "sha", "pm", "pd", "amp", "de", "mm", "cd", "m", "hm", "dm", "db", "di", "mc", "mand", "nm", "vd", "bm", "rm", "mg", "f", "cmd", "gm", "dd", "cfg"], "b": ["bis", "buffer", "base", "bf", "bd", "emb", "lb", "c", "cb", "l", "s", "bs", "pb", "gb", "mb", "reb", "rb", "abb", "d", "binary", "ab", "buff", "wb", "buf", "g", "ob", "body", "fb", "bb", "p", "u", "e", "nb", "db", "bytes", "ib", "bt", "a", "B", "bl", "br", "ba", "f"], "sb": ["buffer", "usb", "sf", "BB", "bf", "sc", "bd", "bh", "sk", "sg", "lb", "lp", "lab", "cb", "lr", "obb", "s", "bs", "kb", "si", "orb", "pb", "bg", "gb", "mb", "abb", "rb", "sa", "wb", "bps", "buf", "sv", "ob", "bj", "tmp", "src", "fb", "ub", "bb", "sq", "zb", "ls", "nb", "ss", "db", "sl", "ib", "bt", "bc", "B", "bp", "sp", "xb", "bsp", "acc", "cca", "SB"], "i": ["val", "index", "id", "n", "pi", "uri", "ini", "ie", "c", "j", "z", "fi", "o", "ri", "l", "s", "si", "ui", "ii", "in", "key", "qi", "vi", "ti", "phi", "g", "li", "h", "x", "p", "ip", "bi", "u", "ai", "oi", "e", "I", "ci", "t", "io", "it", "xi", "di", "gi", "a", "k", "y", "abi", "multi", "f", "ix"], "v": ["val", "vg", "n", "vol", "uv", "c", "j", "o", "l", "s", "vt", "vi", "vc", "cv", "d", "cover", "q", "va", "value", "qv", "r", "sv", "g", "conv", "av", "h", "x", "p", "u", " vi", "vs", "e", "m", "t", "ev", "ver", "k", "V", "ve", "vd", "nv", "ov", "tv", "lv", "vp", "f", "iv", "vv"], "cc": ["cu", "tc", "sc", "cmp", "cf", "rc", "enc", "ck", "c", " c", "fc", "cb", "co", "dc", "ec", "cv", "vc", "ce", "lc", "uc", "ct", " CC", "ch", "inc", "ca", " ecc", "cl", "C", "cel", "coll", "ci", "esc", "ucc", "sup", "CC", "bc", "cci", "cn", "cs", "lv", "acc", "cca", "code"], "returnString": [" returnArray", "returnstring", "returnArray", "resultstring", "resultLine", "returnLine", "resultStr", "resultArray", "ReturnLine", "ReturnString", "Returnstring", "ReturnArray", " returnLine", "returnStr", " returnstring", " returnStr", "ReturnStr", "resultString"]}}
{"id1": "5682569", "id2": "411595", "code1": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 0, "substitutes": {"metodo1": [" metato3", " metando2", " metodo8", " utando3", " metodo2", " metando8", " utodo1", " utodo2", " utodo3", " utando1", " metango1", " utando8", " metodo3", " metando3", " metando1", " metato2", " metango2", " metato8", " metango3", " metato1", " metango8", " utando2", " utodo8"], "temp": ["index", "tc", "mag", "clean", "pre", "modified", "c", "current", "tem", "z", "j", "result", "length", "Temp", "dest", "iter", "offset", "txt", "type", "source", "cache", "lc", "cut", "diff", "default", "alt", "parent", "level", "data", "tmp", "flat", "fake", "empty", "p", "null", "test", "cel", "stable", "status", "t", "font", "prefix", "partial", "v", "count", "f", "mini", "emp"], "flagDesordenado": ["flagDesORDenad", "flagDesordeniato", "flagDesordainido", "flagDesideredainar", "flagDesordienada", "flagDesordencad", "flagDesideredenar", "flagDesideredainada", "flagDesordenad", "flagDesordenada", "flagDesordENano", "flagDesideredainido", "flagDesideredenada", "flagDesordENada", "flagDesordencada", "flagDesordennado", "flagDesordinado", "flagDesORDENada", "flagDesordainada", "flagDesordernar", "flagDesORDenado", "flagDesordENado", "flagDesordENad", "flagDesordienad", "flagDesordeniad", "flagDesordienado", "flagDesordenido", "flagDesideredainado", "flagDesordennada", "flagDesORDenano", "flagDesordencado", "flagDesordeniado", "flagDesordernato", "flagDesordencano", "flagDesordienato", "flagDesordennato", "flagDesordeniar", "flagDesORDENado", "flagDesordainado", "flagDesordeniano", "flagDesordinato", "flagDesordennaban", "flagDesideredenado", "flagDesordenar", "flagDesordinada", "flagDesordernad", "flagDesideredenido", "flagDesordeniaban", "flagDesordeniada", "flagDesordeniido", "flagDesORDENad", "flagDesORDenada", "flagDesordenaban", "flagDesordinaban", "flagDesordenato", "flagDesordernido", "flagDesORDENano", "flagDesordernada", "flagDesordainar", "flagDesordenano", "flagDesordernado"], "i": ["index", "info", "id", "n", "pi", "uri", "mu", "list", "ini", "site", "slice", "c", "j", "ri", "l", "si", "ui", "ii", "key", "qi", "part", "ti", "ji", "source", "lc", "load", "phi", "diff", "chi", "data", "li", "ip", "x", "p", "mi", "bi", "u", "init", "cli", "oi", "ai", "start", "ci", "I", "e", "io", "eni", "image", "it", "xi", "gi", "di", "hi", "k", "b", "v", "ni", "left", "abi", "iu", "multi", "f", "mini", "api", "ix"], "tabla": ["taglas", "Tabla", "ablo", "tabela", " tabela", " tabula", "tagela", "tablelas", "tagula", "cellela", "tableela", "taglo", " tablas", "taga", "tablela", "taba", "Tablo", "abla", "tablea", "cellna", "Tabula", " taba", "tabna", "Taba", "Tabela", "tablas", "abula", "tagla", "ablas", " tabna", "tagna", "tabula", "tablo", "Tablas", " tablo", "cellla", "cellula", "abela"]}}
{"id1": "21489105", "id2": "15904772", "code1": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 1, "substitutes": {"md5": ["dig3", "md25", " mddown", " md68", "mandql", "dig68", " md25", "mdql", "digdown", "md4", "mand68", " md4", "sha4", "sha512", "mand25", " mdql", " md3", "dig4", " md53", "digql", "dig5", "md2", "sha2", "dig53", "md53", "MDdown", "MD5", "md68", "dig2", "dig25", "MD512", "MD3", "MD2", "md3", " md2", "mand5", "MD4", "md512", "sha5", " md512", "MD53", "mddown", "mand4"], "message": ["string", "path", "address", "buffer", "mess", "resource", "response", "uri", "token", "username", "definition", "mail", "document", "sequence", "primary", "json", "plain", "description", "large", "content", "password", "email", "source", "binary", "connection", "value", "application", "default", "data", "file", "body", "text", "object", "request", "metadata", "Message", "hello", "msg", "header", "e", "image", "word", "layer", "me", "sign", "essage", "phrase", "hash", "code"], "base64": [" base62", "base62", "source5", " base32", "Base8", "Base62", "source8", "bas32", "base5", "base32", " base5", "base8", "Base5", "bas64", "Base32", " base8", "source64", "base65", "bas62", "bas65", "Base64", "Base65", " base65"], "digest": ["defester", "digse", "Digester", "labgest", " digse", " diggest", "DigEST", "mdesting", "generate", "defesting", " digested", "digss", "generests", "Digse", "defss", "mdest", "mdested", "diggest", "mdss", "Diggest", "mdse", "generse", "digester", "mdate", "digests", "mdester", "digested", " digate", "Digesting", "Digest", "labester", "labest", "defest", " digss", "mdests", "digate", " digEST", " digester", " digests", "Digested", "generest", "labEST", "Digss", "digEST", "digesting"], "digestData": ["digestDATA", "digestdata", "diggestData", "longestedData", "longestedArray", "longestedPart", "digESTdata", "digestPart", "digESTPart", "digesterData", "digestedDATA", " digestText", "longestPart", "digestBody", "digesterDATA", "digESTBody", " digestedDATA", "digesteddata", " digestDATA", "digesterText", "longestDATA", "digestedArray", "longestArray", " digestedText", "digestArray", "digestedData", "digESTData", " digestedPart", "diggestPart", "longestedDATA", "digestText", "digestedText", "digesterPart", "digestedPart", " digestedBody", "digesterBody", " digestedData", "diggestDATA", " digesteddata", "digesterdata", "digesterArray", " digestdata", "digestedBody", "longestData", "diggestArray", " digestBody", " digestPart"], "enc": ["anc", "ssl", "core", "emb", "rc", "oct", "ack", "act", "c", "et", "fc", "eng", "ew", "ENG", "dc", "Enc", "en", "nc", "ec", "ent", "mac", "lc", "uc", "ENC", "oder", "ct", "acc", "lib", "inc", "conv", "data", "ens", "exc", "conn", "cel", "coll", "e", "dec", "env", "esc", "alg", "bc", "ac", "cod", "cur", "sec", "code", "loc"]}}
{"id1": "19307120", "id2": "5951961", "code1": "    public static String sendPost(String url, String param) {\n        String result = \"\";\n        try {\n            URL httpurl = new URL(url);\n            HttpURLConnection httpConn = (HttpURLConnection) httpurl.openConnection();\n            httpConn.setRequestProperty(\"Accept-Language\", \"zh-CN\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            PrintWriter out = new PrintWriter(httpConn.getOutputStream());\n            out.print(param);\n            out.flush();\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n            in.close();\n        } catch (Exception e) {\n            MsgPrint.showMsg(e.getMessage());\n        }\n        return result;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"sendPost": ["postpost", "executeSub", "doPost", "executePost", "executePOST", "sendpost", "postPOST", "postSub", "dopost", "executepost", "doSub", "doPOST", "sendPOST", "sendSub", "postPost"], "url": ["string", "path", "ssl", "address", "base", "remote", "server", "uri", "resource", "feed", "http", "html", "l", "host", "location", "URL", "source", "connection", "file", "route", "page", "ll", "ls", "name", "link", "full", "sl", "Url", "bug", "www", "ur", "hub", "service", "api", "loc"], "param": ["string", "path", "address", "base", "info", "temp", "input", "resource", "output", "arm", "Parameter", "patch", "arg", "query", "extra", "password", "params", "ram", "part", "source", "proc", "connection", "prom", "par", "config", "data", "channel", "page", "object", "p", "name", "meter", "comment", "question", "Param", "error", "phrase"], "result": ["reason", "string", "buffer", "output", "response", "resource", "user", "results", "report", "res", "message", "json", "description", "current", "answer", "match", "ret", "grade", "extra", "params", "true", "load", "expected", "date", "value", "our", "default", "feature", "work", "data", "request", "msg", "test", "status", "home", "runner", "success", "array", "function", "comment", "err", "Result", "found", "error", "valid"], "httpurl": ["baseURL", "baseUrl", "workconn", "httpcf", "workurl", "httpconn", "phpconn", "workcf", " httpconfig", " httpcf", "baseconfig", "phpconfig", " httpconn", "phpURL", "workURL", "baseurl", "phpcf", "httpURL", "phpUrl", "httpUrl", "phpurl", " httpUrl", "httpconfig", " httpURL"], "httpConn": ["urlConnection", " httpConnection", "perConn", "httpsConnection", " httpCon", "webConnect", "perConnect", "httpsCon", "HttpExec", "httpconn", "httpConnection", "phpConnection", "HttpCon", "Httpconn", "phpconn", "webCon", "perExec", "urlConnect", " httpExec", "urlCon", " httpconn", "httpConnect", "httpsconn", "httpsConn", "httpCon", "httpExec", "HttpConnection", "phpConn", "webConnection", "phpConnect", "webConn", "urlConn", "HttpConn", "urlconn", " httpConnect", "webconn", "HttpConnect", "perconn"], "out": ["temp", "ex", "output", "n", "copy", "plus", "outer", "user", "net", "plain", "OUT", "inner", "socket", "outs", "o", "write", "flow", "pass", "extra", "key", "password", "connection", "r", "w", "inc", "parent", "file", "h", "p", "log", "null", "conn", "init", "again", "Out", "io", "writer", "exp", "word", "dump", "prefix", "In", "flush", "b", "err", "f", "cli"], "in": ["IN", "pin", "i", "input", "id", "serv", "ini", "gin", "into", "ic", "con", "inner", "as", "ins", "s", "bin", "read", "is", "reader", "login", "min", "r", "inc", "rin", "conn", "rec", "init", "again", "re", "isin", "In", "kin", "nin", "stream", "lin", "b", "err", "ac", "cin", "inn", "f", "win", "din"], "line": ["letter", "string", "pin", "job", "i", "sel", "id", "lf", "response", "user", "entry", "continue", "message", "LINE", "character", "ge", "end", "l", "record", "key", "char", "source", "reader", "lines", "lc", "model", "str", "r", "data", "file", "text", "cl", "page", "ip", "le", "log", "row", "inline", "name", "e", "cr", "word", "link", "sl", "pe", "unit", "comment", "Line", "lin", "me", "block", "code", "cell"]}}
{"id1": "13783898", "id2": "8150996", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFiletoFiles", "encodeFileToFiles", "encodeFiletoFile", "encodeString2File", "encodeString2Stream", "encodeFileToStream", "encodeFileFromStream", "encodeStringToStream", "encodeFileFromFile", "encodeString2String", "encodeFile2Files", "encodeStringToFile", "encodeFile2File", "encodeFileToString", "encodeString2Files", "encodeFiletoString", "encodeStringToString", "encodeFile2Stream", "encodeFiletoStream", "encodeStringToFiles", "encodeFileFromString", "encodeFileFromFiles", "encodeFile2String"], "infile": ["infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", " infp", "inputfp", "inputFile", "outfiles", " infilename", "inputfiles", "Infilename", " infiles", "outfp", "Infile", "InFile", "inputfilename", "infilename", "Infiles"], "outfile": ["newfile", "Outname", "infp", "outfilename", "outputfile", "outFile", "newname", " outFile", "infolder", " outfolder", "outputfolder", "newfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "Outfolder", " outname", "outname", "OutFile", "Outfile", "infilename", "newFile", " outfilename"], "in": ["IN", "base", "pin", "i", "input", "inas", "sin", "id", "ini", "gin", "into", "ic", "con", "inner", "as", "socket", "ins", "s", "bin", "pass", "is", "reader", "source", "thin", "login", "min", "inside", "r", "inc", "data", "rin", "vin", "init", "conn", "again", "m", "image", "re", "isin", "In", "nin", "a", "err", "b", "ac", "cin", "inn", "win", "din"], "out": ["base", "ou", "job", "ex", "output", "outer", "copy", "timeout", "on", "net", "OUT", "socket", "inner", "outs", "o", "off", "write", "bin", "co", "line", "exit", "post", "client", "sync", "session", "no", "cache", "source", "one", "up", "lib", "inc", "parent", "work", "file", "conn", "or", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "In", "err", "obj", "error", "point"], "buffer": ["address", "base", "Buffer", "input", "uffer", "feed", "server", "border", "slice", "limit", "result", "length", "write", "queue", "offset", "iter", "split", "raw", "type", "reader", "cache", "binary", "source", "seed", "buff", "value", "buf", "len", "wave", "data", "fb", "size", "bb", "null", "bytes", "layer", "flush", "url", "b", "reference", "count", "padding", "transfer", "batch"], "read": ["play", "close", "i", "input", "Read", "feed", "n", "copy", "reading", "id", "add", "ind", "slice", "current", "end", "limit", "run", "se", "find", "length", "write", "reads", "ride", "pass", "sleep", "ad", "iter", "next", "raw", "sync", " count", "select", "allow", "use", "load", "reader", " Read", "len", "seek", "work", "inc", "check", " copy", "ip", "size", "x", "get", "fill", "start", "exec", "io", "lex", "send", "tell", "_", "parse", "connect", "wait", "count", "READ", " write", " skip", "f"], "success": ["respons", "roll", "error", "path", "response", "rolling", "continue", "results", "ceed", "modified", "xx", "message", "primary", "warning", "better", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "model", "default", "open", "data", "growth", "flash", "null", "cess", "danger", "complete", "again", "status", " successful", "good", "Success", "comment", "right", "successful", "successfully", "rolled", " succ", "method", "fast", "first", "winner", "initial"]}}
{"id1": "19206412", "id2": "6756635", "code1": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"md5String": ["md5Str", "md6string", "md6Str", " md5Bytes", "md512String", " md512Bytes", "md5string", "md5Bytes", "md4String", "md4Str", "md6Bytes", " md512string", "md4string", " md5Str", "md512string", " md5string", "md512Str", "md6String", "md4Bytes", " md512Str", "md512Bytes", " md512String"], "str": ["string", "self", "enc", "result", "s", "fr", "dr", "pass", "char", "txt", "arr", "er", "Str", "doc", "strings", "sr", "r", "STR", "data", "text", "out", "star", "msg", "name", "e", "dict", "exp", "re", "bytes", "tr", "url", "hr", "obj", "sp", "err", "kr", "st", "br", "f", "stri", "this"], "md": ["mk", "mu", "um", "sum", "cmp", "mag", "bd", "df", "od", "Cmd", "amd", "mail", "map", "mo", "ma", "am", "wd", "MD", " MD", "ld", "sm", "ms", "ad", "rpm", "mb", "mt", "dh", "d", "mac", "mp", "hd", "pm", "pd", "data", "mm", "metadata", "cd", " Md", "dig", "m", "hm", "dm", "db", "mand", "mc", "mod", "me", "vd", "mg", "cmd", "dd", "code"], "hash": ["index", "base", "address", "sum", "her", "id", "chip", "kh", "hex", "Hash", "html", "number", "host", "memory", "bin", "ash", "key", "char", "arr", "filter", "part", "cache", "rh", "dot", "sha", "diff", "value", "body", "check", "h", "search", "header", "image", "ha", "array", "tr", "ver", "url", "sh", "range", "print", "count", "block", "f", "error", "code"], "hexChars": ["hexchars", "hashChashes", "hexKhashes", "hexChashes", "hexCharases", "hexCharashes", "hashchacters", "hexChash", "hexCashes", "hexCharacters", " hexchats", "hashChARS", "hexCHars", "hexCHARS", "hexchARS", " hexchARS", "hexchacters", " hexChats", "hexKhars", "hashchases", "hashChases", "hexCharars", "hexKhARS", "hexChats", "hexChases", "hexchashes", "hashchars", "hexchases", " hexchars", "hexchats", "hexChacters", "hexCars", "hexKhash", "hexCharARS", "hashCHARS", "hashchARS", "hashChacters", "hexCash", "hexCHacters", "hashCHashes", "hashChars", "hexCharats", "hexCARS", "hexCHashes", "hashCHash", "hashChash", " hexchashes", "hexCHats", " hexChashes", "hexCHash", " hexChARS", "hexChARS", "hashCHars", "hexCHases"], "res": ["string", "css", "pres", "RES", "response", "cons", "results", "RS", "vers", "result", "s", "bs", "abs", "ret", "Res", "rs", "req", "arr", "cache", "resp", "ros", "pers", "r", "ress", "data", "out", "vals", "rex", "ras", "rus", "des", "es", "vs", "ris", "rss", "rows", "ss", "rez", "details", "rev", "bytes", "Rs", "us", "resolution", "err", "reg", "rules", "cs", "Result", "ps", "Results", "re"], "i": ["index", "info", "base", "id", "uri", "pi", "mu", "temp", "ie", "c", "j", "ri", "o", "l", "length", "si", "ui", "ii", "in", "qi", "part", "ti", "ji", "d", "phi", "diff", "li", "h", "x", "ip", "p", "bi", "u", "oi", "ai", "e", "I", "ci", "m", "io", "it", "xi", "gi", "di", "a", "hi", "k", "b", "v", "y", "abi", "iu", "multi", "f", "field", "code", "ix"]}}
{"id1": "18339787", "id2": "7425022", "code1": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 0, "substitutes": {"reload": ["reffill", "preresh", "overload", "refloading", "preloading", "overloading", "refill", "refload", "prefill", "reloading", "refresh", "overresh", "reresh", "preload", "overfill"], "currentDate": ["newDate", "newUpdate", " currentTime", "reportedTime", "currentKey", "newKey", "reportedDay", " currentUpdate", " currentDay", "CurrentName", "reportedName", "currentName", "currentUpdate", "CurrentKey", "CurrentDay", "CurrentDate", "currentDay", "newDay", "CurrentUpdate", " currentName", "reportedDate", "currentTime", " currentKey", "CurrentTime"], "xpath": ["Xprop", "xstream", " xstream", " xprop", "XPath", "axpath", "exPath", "lexPath", " xparent", " xp", "lexstream", "xath", "exstream", "lexparent", "xp", "txstream", "Xcase", "txpath", " xcase", "axPath", "xPath", "Xath", "exath", "exparent", " xPath", "exp", "exprop", "axath", "xcase", "Xpath", " xath", "Xp", "xparent", "xprop", "expath", "Xstream", "lexpath", "axcase", "txPath"], "docBuilderFactory": ["documentBuildF", "docBuilder2", "documentBuilderFactory", "docBuilderInterface", "projectbuilderInterface", "projectbuilderFactor", "docbuilderFactor", "docManagerInterface", "docManagerFactor", "docbuilderService", "docBuilderFactor", "docBuild2", "docBuilderService", "documentBuildService", "documentBuildFactory", "docBuildFactory", "docbuilder2", "docbuilderFactory", "projectbuilderFactory", "docBuildInterface", "docBuilderF", "projectBuilderInterface", "docBuildFactor", "docManager2", "docbuilderInterface", "documentBuilderF", "projectbuilder2", "docBuildService", "docbuilderF", "projectBuilderFactory", "docManagerFactory", "documentBuilderService", "projectBuilder2", "projectBuilderFactor", "docBuildF"], "docBuilder": ["documentParser", "xmlBuild", "DocBuild", "fileBook", "documentBuild", "docBook", "docbuilder", " docBuild", "Docbuilder", "documentBuilder", " docBook", "fileFactory", "fileBuild", "docFactory", " docFactory", "documentBook", "xmlParser", "DocBuilder", "documentFactory", "xmlBuilder", "DocParser", "docBuild", "documentbuilder", "docParser", "xmlbuilder", "fileBuilder"], "conn": ["Connection", "path", "ssl", "loader", "Conn", "server", "serv", "enc", "lock", "http", "con", "c", "socket", "cb", "l", "URL", "nc", "client", "nt", "cm", "cp", "session", "lc", "uc", "ct", "connection", "ch", "conv", "config", "channel", "out", "body", "log", "coll", "ci", "exec", "ann", "db", "ctx", "Url", "conf", "connect", "cn", "cli", "cmd", "api", "loc"], "url": ["impl", "string", "path", "ssl", "base", "loader", "server", "feed", "resource", "uri", "serv", "http", "l", "host", "URL", "fr", "client", "connection", "str", "build", "ob", "config", "data", "file", "channel", "web", "bel", "ll", "log", "ls", "coll", "image", "blog", "db", "sl", "Url", "www", "err", "f", "gl", "org", "download"], "xml": ["zip", "event", "path", "root", "node", "address", "temp", "input", "atom", "feed", "response", "http", "json", "document", "wl", "html", "wt", "php", "el", "layout", "content", "arr", "txt", "email", "reader", "doc", "date", "children", "model", "config", "data", "file", "page", "request", "x", "log", "context", "rss", "tree", "example", "image", "writer", "apache", "ml", "graph", "update", "stream", "parse", "dom", "events", "office", "element"], "exchangeRateDate": ["excurrencyRateDate", "exchangeFactorDuration", "exchangeRateTime", "exchangeTimeTime", "exchangeTimeFile", "exchangeWeightDate", "exchangeFactorTime", "expireRateDate", "excurrencyRateFile", "exchangeWeightFormat", "expireRateKey", "exchangeRatingPrice", "exchangePriceFormat", "exchangeRatingKey", "expireRatePrice", "expirePricePrice", "expirePriceFormat", "excurrencyRateDuration", "exchangeRateDuration", "exchangePriceDate", "exchangeRateFormat", "exchangeFactorFile", "exchangeRateKey", "excurrencyRateTime", "exchangeRateFile", "expireRateFormat", "exchangeTimeDuration", "excurrencyTimeFile", "exchangeWeightPrice", "exchangePriceKey", "exchangeRatingDate", "exchangeWeightKey", "exchangePricePrice", "excurrencyTimeDuration", "expirePriceDate", "exchangeRatingFormat", "excurrencyTimeTime", "exchangeFactorDate", "exchangeRatePrice", "exchangeTimeDate", "expirePriceKey", "excurrencyTimeDate"], "currenciesNode": ["curriesDocument", "contractrenciesDocument", "curriesRoot", "comportsElement", "currenciesArray", "contractrenciesRoot", "cururrenciesRoot", "curatorsNode", "cururrenciesArray", "curratesDocument", "curcurrencyElement", "contracturrenciesNode", "curportsNode", "curitiesContainer", "courrenciesNode", "currenciesPath", "contracturrenciesBlock", "curcurrencyPath", "cururrenciesnode", "comrenciesBlock", "corenciesArray", "curatorsnode", "curlationsBlock", "curriesNode", "currenciesContainer", "courrenciesContainer", "curratesNode", "currenciesElement", "curitiesnode", "curriesBlock", "comrenciesElement", "curratesRoot", "cururrenciesContainer", "contracturrenciesRoot", "currenciesBlock", "cururrenciesBlock", "cururrenciesDocument", "currenciesRoot", "corenciesnode", "curportsPath", "curitiesArray", "courrenciesnode", "curportsBlock", "currenciesDocument", "curlationsPath", "comrenciesPath", "corenciesNode", "curatorsArray", "curcurrencyBlock", "comportsPath", "curcurrencyNode", "contracturrenciesDocument", "cururrenciesNode", "corenciesContainer", "curlationsNode", "contractrenciesBlock", "comportsNode", "curratesBlock", "curportsElement", "contractrenciesNode", "currenciesnode", "curatorsContainer", "curitiesNode", "comportsBlock", "curlationsElement", "courrenciesArray", "comrenciesNode"], "currencies": ["charries", " curums", "locrencies", "chales", "scheurrencies", "chcoins", "carcoins", " curries", "locales", "cururrency", "scherency", " curacters", "chrencies", "currency", "perums", "locurrency", "urums", "charurrencies", "uracters", "cururrencies", "perrencies", "curacters", "curales", "curversions", " cururrencies", "carrencies", "carales", "perversions", "churrency", "charrencies", "scheries", "curcoins", "curries", "charrency", " currency", "curums", "loccoins", "carurrency", "urversions", "peracters", "urrencies", "scherencies", " curversions"], "i": ["index", "info", "id", "n", "pi", "uri", "mu", "yi", "slice", "c", "j", "z", "ri", "o", "fi", "l", "end", "si", "ui", "ii", "in", "qi", "ti", "ji", "lc", "q", "phi", "r", "chi", "g", "li", "ip", "x", "p", "bi", "u", "ai", "oi", "start", "ci", "e", "I", "t", "io", "m", "eni", "it", "xi", "gi", "di", "hi", "b", "v", "y", "abi", "iu", "multi", "f"]}}
{"id1": "13644374", "id2": "15810440", "code1": "    public byte[] getBytesFromUrl(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toByteArray(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"getBytesFromUrl": ["getBytesfromString", "getbytesFormURL", "getbytesFromRoute", "getBytesFormRoute", "getBytesfromRoute", "getBytesfromURL", "getBytesfromUrl", "getbytesFromUrl", "getBytesViaURL", "getbytesFormRoute", "getBytesFromString", "getBytesFromURL", "getbytesFromString", "getBytesViaString", "getbytesFormUrl", "getbytesFromURL", "getBytesFormString", "getbytesFormString", "getBytesFormURL", "getBytesViaUrl", "getBytesViaRoute", "getBytesFormUrl", "getBytesFromRoute"], "url": ["path", "string", "address", "buffer", "base", "i", "server", "uri", "resource", "http", "json", "ref", "result", "l", "location", "host", "URL", "key", "email", "source", "connection", "str", "data", "route", "page", "request", "href", "name", "sl", "Url", "ur", "xml", "download", "method", "service", "api", "loc"], "get": ["i", "execute", "resource", "http", "gets", "json", "find", "set", "query", "read", "client", "handle", "like", "use", "load", "build", "open", "body", "request", "put", "GET", "start", "Get", "e", "exec", "send", "call", "pull", "update", "create", "parse", "cli", "method", "service", "api"], "response": ["error", "server", "output", "resource", "feed", "http", "report", "json", "message", "document", "onse", "result", "content", "resp", "connection", "application", "wave", "data", "body", "out", "page", "request", "object", "reply", "e", "tree", "status", "success", "full", "received", "Response", "respond", "f", "method", "api"], "entity": ["event", "info", "translation", "node", "server", "resource", "Entity", "output", "element", "entry", "http", "json", "document", "message", "result", "instance", "el", "content", "security", "ent", "ale", "resp", "connection", "model", "collection", "data", "file", "body", "page", "object", "metadata", "environment", "null", "e", "image", "action", "person", "pe", "xml", "this", "api"]}}
{"id1": "8119563", "id2": "21489105", "code1": "    protected boolean checkLink(URL url) {\n        try {\n            URLConnection connection = url.openConnection();\n            connection.connect();\n            return true;\n        } catch (IOException e) {\n            MsgLog.error(\"DapParser.checkLink(): IOException: \" + e.toString());\n            return false;\n        }\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 0, "substitutes": {"checkLink": ["loadlink", "CheckLink", "loadLink", "CheckLine", " checkConnect", "CheckConnect", "loadConnect", " checklink", "checkLine", "Checklink", " checkLine", "checkConnect", "loadLine", "checklink"], "url": ["string", "address", "base", "class", "ssl", "server", "uri", "resource", "entry", "http", "socket", "instance", "l", "location", "host", "URL", "client", "source", "proxy", "str", "open", "config", "file", "route", "page", "object", "null", "conn", "or", "name", " URL", "image", "link", "sl", "Url", "element", "service", "loc"], "connection": ["Connection", "handler", "i", "server", "uri", "response", "resource", "timeout", "builder", "http", "character", "c", "connected", "socket", "communication", "l", "relation", "database", "client", "ion", "application", "open", "config", "data", "channel", "object", "conn", "io", "image", "writer", "function", "link", "position", "unit", "b", "connect", "network", " Connection", "loc"]}}
{"id1": "20991673", "id2": "12078471", "code1": "    public NodeId generateTopicId(String topicName) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"No SHA support!\");\n        }\n        if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName);\n        md.update(topicName.getBytes());\n        byte[] digest = md.digest();\n        NodeId newId = new NodeId(digest);\n        return newId;\n    }\n", "code2": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "label": 0, "substitutes": {"generateTopicId": ["generatedTopicInfo", "generatedtopicName", "generateTopicsID", "generateTopicsId", "generatetopicInfo", "generatedTopicId", "generateTopicID", "generatetopicId", "generatedtopicId", "generateTopicsName", "generatedTopicName", "generatedTopicID", "generatetopicName", "generateTopicsInfo", "generatetopicID", "generateTopicName", "generateTopicInfo", "generatedtopicID", "generatedtopicInfo"], "topicName": [" topicType", "channelType", "topicId", "Topicname", "TopicNames", " topicNames", "topicInfo", " topicname", "topname", "channelName", "topName", "channelPath", " topicId", "channelId", "topId", " topicInfo", "TopicKey", "topicKey", " topicKey", "subjectType", "subjectPath", "channelKey", "TopicInfo", "topicPath", "topicType", "topicname", "topNames", "subjectName", "topicNames", "subjectId", "TopicId", "channelInfo", " topicPath", "TopicName"], "md": ["pkg", "editor", "id", "ud", "gd", "mag", "bd", "df", "od", "Cmd", "amd", "mo", "ma", "am", "meta", "dr", "MD", "dc", " MD", "ld", "sm", "ad", "ms", "mb", "cm", "mt", "dh", "mac", "d", "mp", "hd", "sha", "pm", "pd", "mm", "metadata", "dig", "po", "m", "km", "dm", "mand", "mc", "vd", "rm", "mg", "cmd", "dd", "hash"], "digest": ["Digester", "DigEST", " diggest", "dested", "signEST", "decEST", "cdest", "signest", "dest", " digested", "decest", "dighed", "signests", "cdgest", "cdester", "mdest", "mdested", "Digests", "diggest", "Diggest", "digester", "digests", "mdester", "digested", "dester", "Digest", "cdEST", "decests", " dighed", "dhed", " digEST", " digester", "digEST", "mdhed"], "newId": ["nextID", "NewID", " newID", "nextId", "NewInfo", " newInfo", "newID", "NewId", " newid", "Newid", "nextid", "newInfo", "nextInfo", "newid"]}}
{"id1": "3401153", "id2": "19739421", "code1": "    private String getHTML(String pageURL, String encoding, String dirPath) throws IOException {\n        StringBuilder pageHTML = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(pageURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"MSIE 7.0\");\n            connection.connect();\n            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), encoding));\n            String line = null;\n            while ((line = br.readLine()) != null) {\n                pageHTML.append(line);\n                pageHTML.append(\"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            connection.disconnect();\n        }\n        if (dirPath != null) {\n            File file = new File(dirPath);\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file));\n            bufferedWriter.write(pageHTML.toString());\n            bufferedWriter.close();\n        }\n        return pageHTML.toString();\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"getHTML": ["updateHTML", "loadJSON", "createHTML", "createJSON", "loadPage", "getJSON", "getURL", "loadURL", "updateJSON", "updateURL", "updatePage", "getPage", "createPage", "loadHTML", "createURL"], "pageURL": ["baseURL", "baseUrl", "Pageurl", " pageurl", " pageURI", "pageURI", "basePath", "PageURL", "PagePath", "pageUrl", "badurl", "badURL", "badUrl", " pageUrl", "pageurl", "PageURI", "PageUrl", "pagePath", "baseURI", " pagePath", "badURI"], "encoding": ["encension", "decoder", "Encoded", "Encoder", "encaging", "caging", "decasing", "coding", "enaging", "contoder", "decoding", "enasing", "Encoding", "contoding", "casing", "Encaging", "coded", "enoded", "enoding", "Encasing", "contension", "encoder", "decension", "contasing", "encasing", "encoded", "Encension"], "dirPath": ["zipPath", "zippath", "buildPath", "DirPath", "buildFile", "directoryLocation", "dirDir", "zipPoint", "dirLocation", "folderPath", " dirDir", "DirFile", "folderpath", "dirPoint", "Dirpath", "directoryPath", "directorypath", "dirpath", "dirFile", "folderFile", "DirLocation", "directoryPoint", " dirLocation", " dirpath", "DirDir", "directoryDir", "DirLog", "directoryFile", "directoryLog", "zipFile", "dirLog", "folderPoint", "buildLog"], "pageHTML": ["pageHTTP", "sectionURL", " pageHTTP", "siteURL", "pagehtml", "codeHTML", "rowHTML", "resultHTML", " pagehtml", " pageURI", "pageURI", "PageURL", "resulthtml", "PageHTML", "codeWriter", "siteHTML", "siteURI", "PageJSON", "siteUrl", "pageBody", "codehtml", "pageUrl", "rowhtml", "codeUrl", "resultWriter", " pageJSON", "resultURL", "PageHTTP", "pageJSON", "resultJSON", " pageUrl", "Pagehtml", "PageBody", "pageWriter", " pageBody", "sectionBody", "PageURI", "resultUrl", "sectionHTML", "rowJSON", "rowURL", "PageUrl", " pageWriter", "sectionHTTP"], "connection": ["directory", "Connection", "string", "handler", "server", "uri", "response", "resource", "user", "builder", "timeout", "http", "character", "con", "c", "socket", "connected", "number", "o", "cb", "pool", "relation", "manager", "database", "condition", "password", "union", "client", "session", "reader", "cache", "uc", "proxy", "ion", "application", "collection", "section", "config", "bec", "text", "body", "open", "org", "director", "channel", "log", "context", "conn", "or", "ci", "io", "function", "db", "ctx", "position", "bc", "b", "connect", "wrapper", "communication", "loc"], "url": ["Connection", "string", "path", "address", "base", "ssl", "server", "uri", "feed", "user", "builder", "http", "l", "location", "URL", "client", "browser", "build", "channel", "page", "web", "log", "conn", "coll", "image", "function", "link", "sl", "Url", "update", "stream", "connect", "contact", "f", "plug", "loc"], "br": ["bh", "bridge", "result", "cb", "lr", "fr", "dr", "keeper", "mr", "ori", "bro", "ler", "arr", "BR", "rb", "reader", "pr", "ctr", "ocr", "buf", "ner", "sr", "r", "ch", "Br", "str", "ob", "src", "body", " reader", "io", "cr", "cro", "tr", "bc", "stream", "hr", "b", "bl", "err", "Reader"], "line": ["letter", "string", "base", "lf", "response", "column", "entry", "message", "character", "c", "ge", "LINE", "end", "l", "el", "pass", "ine", "char", "key", "sync", "lines", "lc", "up", "r", "str", "data", "text", "li", "cl", "page", "object", "le", "inline", "row", "style", "name", "frame", "word", "link", "sl", "pe", "unit", "comment", "Line", "lin", "b", "block", "code", "cell"], "e": ["ise", "fe", "i", "ace", "ee", "be", "ie", "ue", "c", "se", "o", "te", "ception", "en", "die", "ec", "er", "type", "one", "ce", "je", "r", "ea", "exc", "x", "p", "es", "ae", "or", "E", "force", "ze", "ev", "pe", "ve", "err", "f", "error", "oe", "Exception", "esi", "re"], "file": ["zip", "path", "base", "buffer", "handler", "output", "feed", "ile", "resource", "lock", "http", "filename", "per", "socket", "result", "fp", "l", "File", "angle", "reader", "source", "dir", "book", "FILE", "data", "body", "page", "h", "le", "log", "null", "name", "folder", "io", "writer", "db", "files", "pe", "b", "f"], "bufferedWriter": ["buffilledWriter", "ufaredWriting", "uferedWriter", "buffaredWriting", "bufferedFile", "BuffererWriter", "buffererReader", "BufferedWriter", "buffedWriting", "bufferingFile", "uferedWriting", "BufferedWrite", "BuffererFile", "BuffererWrite", "bufferedWrite", "ufaredwriter", " bufferingW", "buffinedReader", "BufferedFile", " bufferingFile", "buffenedWriter", "bufferedWriting", "buffererWrite", "buffererFile", " bufferedW", "buffilledWriting", "buffererWriter", "buffenedW", "buffaredwriter", " bufferingReader", "buffinedWriter", "BufferedReader", "buffedWriter", "buffaredWriter", "bufferedReader", " bufferingWriter", "ufaredWriter", "buffilledwriter", "bufferingReader", "buffinedFile", "uferedwriter", "buffenedFile", "buffenedReader", "BuffererReader", "bufferedW", "bufferingWrite", " bufferedReader", " bufferedFile", "bufferedwriter", "buffedwriter", "buffinedWrite", "bufferingWriter", "bufferingW", "buffererW"]}}
{"id1": "2668853", "id2": "8932510", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFiletoFiles", "decodeFileAsStream", "decodeString2file", "decodeFile2Stream", "decodeFiletoFile", "decodeFileToStream", "decodeFiletofile", "decodeFileAsFiles", "decodeFileTofile", "decodeStringToFile", "decodeStringTofile", "decodeStringToStream", "decodeFileAsFile", "decodeString2Stream", "decodeFile2File", "decodeString2File", "decodeFileAsfile", "decodeFiletoStream", "decodeFileToFiles", "decodeFile2file", "decodeStringToFiles", "decodeString2Files", "decodeFile2Files"], "infile": ["minfile", "infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", "inputfp", " inFile", "inputFile", "outfiles", " infilename", "inputfiles", " infiles", "outfp", "minfilename", "minFile", "minfp", "inputfilename", "infilename"], "outfile": ["infp", "outfull", "outputfile", " outfull", "outfilename", "outFile", " outFile", "infolder", "outputfolder", " outfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "outputfull", "Outfull", "Outfolder", "OutFile", "Outfile", "outputFile", "infilename", " outfilename"], "in": ["IN", "pin", "i", "input", "inas", "ex", "ini", "gin", "ic", "con", "inner", "socket", "as", "ins", "s", "bin", "is", "reader", "source", "up", "login", "min", "inside", "r", "inc", "data", "rin", "init", "conn", "again", "m", "e", "image", "re", "In", "nin", "a", "lin", "err", "b", "ac", "cin", "inn", "f", "win", "this", "din"], "out": ["base", "ex", "output", "copy", "outer", "op", "lock", "on", "net", "OUT", "socket", "as", "inner", "outs", "o", "s", "off", "line", "write", "bin", "co", "pass", "exit", "post", "client", "sync", "session", "no", "cache", "lib", "up", "target", "other", "inc", "work", "file", "conn", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "exp", "In", "ext", "b", "obj", "err", "error", "point"], "buffer": ["address", "base", "input", "Buffer", "uffer", "resource", "pause", "border", "server", "feed", "slice", "limit", "result", "length", "bin", "memory", "queue", "offset", "iter", "split", "reader", "source", "binary", "seed", "buff", "value", "buf", "wave", "data", "size", "bb", "null", "row", "bytes", "layer", "flush", "url", "shape", "b", "reference", "padding", "pad", "transfer", "batch"], "read": ["index", "Read", " receive", " r", "run", "ride", " get", "open", " copy", "get", "lex", " send", " check", "id", "feed", "add", "ind", "end", "find", " reach", "next", "sync", "use", "load", " sleep", "r", "work", "fill", "exec", "skip", "connect", " request", "play", " use", "reading", " parse", "limit", "se", "length", "write", "line", "ad", "sleep", "iter", "allow", "reader", " Read", "start", "tell", " load", "wait", " write", "input", "copy", " connect", "current", "reads", "pass", "select", " ride", "seek", "inc", " find", "check", "x", "size", " reader", "send", "k", "parse", "count", "READ"], "success": ["roll", "accept", "job", "response", "rolling", "ok", "continue", "ceed", "results", "warning", "better", "yes", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "selected", "default", "data", "safe", "null", "cess", "danger", "complete", "again", "status", " successful", "full", "correct", "good", "Success", "successful", "successfully", "rolled", "found", " succ", "zero", "error", "fast", "first", "winner", "initial"]}}
{"id1": "807346", "id2": "9257487", "code1": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "code2": "    public static boolean downloadFile(String from, String to, ProgressMonitor pm) {\n        try {\n            FileOutputStream out = new FileOutputStream(to);\n            URL url = new URL(from);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int read = 0;\n            while ((read = in.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n                if (pm != null) pm.addToProgress(read);\n            }\n            out.close();\n            in.close();\n        } catch (Exception e) {\n            Installer.getInstance().getLogger().log(StringUtils.getStackTrace(e));\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"runScript": ["execCode", "RunCode", " runscript", "execscript", "runscript", "RunScript", "execJS", "execScript", " runJS", "RunJS", "runJS", "runCode", " runCode", "Runscript"], "scriptName": ["scriptNames", " scriptFile", "fileUrl", " scriptPath", "codename", "Scriptname", "scriptUrl", "scriptPath", "filePath", "codePath", "fileName", " scriptNames", "scriptname", " scriptUrl", "codeName", "ScriptName", " scriptname", "ScriptPath", "ScriptFile", "codeNames", "ScriptNames", "ScriptUrl", "scriptFile", "fileFile"], "data": ["index", "string", "info", "base", "buffer", "input", "i", "output", "response", "feed", "results", "message", "json", "result", "number", "html", "api", "write", "layout", "key", "alpha", "content", "split", "raw", "next", "part", "type", "source", "no", "one", "value", "media", "str", "DATA", "div", "batch", "text", "body", "out", "empty", "append", "complete", "format", "start", "name", "template", "action", "ata", "function", "a", "partial", "missing", "script", "dat", "error", "this", "code", "valid"], "url": ["impl", "zip", "path", "base", "buffer", "ssl", "i", "server", "uri", "resource", "id", "feed", "user", "http", "l", "host", "URL", "source", "up", "browser", "connection", "open", "file", "web", "page", "bb", "ll", "log", "bel", "ls", "ball", "image", "sl", "rl", "Url", "www", "stream", "b", "f", "service"], "in": ["IN", "ssl", "buffer", "i", "input", "id", "resource", "serv", "ini", "gin", "socket", "as", "inner", "ins", "s", "bin", "pass", "is", "client", "cms", "reader", "source", "login", "r", "inc", "file", "out", "conn", "In", "fd", "a", "stream", "b", "err", "ac", "with", "inn", "f", "win", "din"], "buffIn": ["BuffIn", "buffIns", "bufIn", "buffOut", "buffedIn", "bufin", "bufIns", "bbIns", "ufIn", "bufferin", "BuffedIn", "bbIn", "bufferIn", "bufOut", "bufferIns", "ufIns", "bbOut", "bufferedIn", "ufin", "BuffIns", "bbin", "BuffOut", "Buffin", "ufedIn", "buffin"], "temp": ["index", "zip", "total", "base", "buffer", "tc", "input", "num", "i", "output", "enc", "c", "current", "tem", "number", "dest", "length", "Temp", "flow", "read", "extra", "char", "iter", "offset", "content", "raw", "type", "source", "cut", "len", " Temp", "div", "tmp", "fake", "empty", "size", "ptr", "test", "cel", "start", "stable", "pointer", "unit", "partial", "wait", "count", "f", "pt", "emp"]}}
{"id1": "4629990", "id2": "22603577", "code1": "    private String logonToServer(FTPClient ftpClient, String ftpAddress, int noRetries) {\n        String remoteHomeDir = null;\n        noRetriesSoFar = 0;\n        while (true) {\n            try {\n                ftpClient.connect(ftpAddress, ftpPort);\n                int reply = ftpClient.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftpClient.disconnect();\n                    throw new IOException();\n                }\n                if (!ftpClient.login(user, password)) {\n                    throw new IOException();\n                }\n                remoteHomeDir = ftpClient.printWorkingDirectory();\n                msgEntry.setAppContext(\"logonToServer()\");\n                msgEntry.setMessageText(\"Logged into FTP server \" + ftpAddress + \":\" + ftpPort + \" as user \" + user);\n                logger.logProcess(msgEntry);\n                break;\n            } catch (IOException e) {\n                logoutAndDisconnect(ftpClient);\n                if (noRetriesSoFar++ < noRetries) {\n                    waitBetweenRetry();\n                    notifyAndStartWaitingFlag = false;\n                } else {\n                    notifyAndStartWaitingFlag = true;\n                    errEntry.setThrowable(e);\n                    errEntry.setAppContext(\"logonToServer()\");\n                    errEntry.setAppMessage(\"Unable to login after \" + (noRetriesSoFar - 1) + \" retries. Max Retries.\\n\" + \"Address:\" + ftpAddress + \"\\n\" + \"User:\" + user);\n                    errEntry.setSubjectSendEmail(\"Unable to login to \" + ftpAddress + \" after \" + (noRetriesSoFar - 1) + \" retries.\");\n                    logger.logError(errEntry);\n                    break;\n                }\n            }\n        }\n        return remoteHomeDir;\n    }\n", "code2": "    public static String getFileContentFromPlugin(String path) {\n        URL url = getURLFromPlugin(path);\n        StringBuffer sb = new StringBuffer();\n        try {\n            Scanner scanner = new Scanner(url.openStream());\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                sb.append(line + \"\\n\");\n            }\n            scanner.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"logonToServer": ["logOnToRemote", "logontoGuest", "logonToGuest", "logonFromServer", "logontoRemote", "logonTOClient", "logOnToServer", "logOnFromRemote", "logonFromClient", "logonToClient", "logonTOServer", "logontoClient", "logonFromGuest", "logOnFromGuest", "logonTORemote", "logOnFromServer", "logonToRemote", "logonTOGuest", "logontoServer", "logonFromRemote", "logOnToClient", "logOnToGuest", "logOnFromClient"], "ftpClient": ["ctcpClient", "ftcpPort", "ftpaCenter", "ctpAPI", " ftpcContext", "ftbCloud", "ftpcAddress", "ftapCenter", "ctpAddress", "ftbclient", "ctpConnect", "ftcClient", "ftpPort", " ftpaServer", "ftcpServer", "ftcConnection", "ftpiServer", " ftpaclient", " ftbClient", "ftnClient", "ftcpClient", "ftcContext", "ftpcCloud", "ftsConnect", " ftpaPort", " ftpServer", "ftpCloud", "ftpConnect", "ftpcServer", "ftnAPI", "ftcServer", "ftpaCloud", "ctcpAPI", "ftprPort", "ftpcContext", "ftprClient", "ftpaClient", "ftsServer", "ftsPort", "ctcpAddress", "ftapclient", " ftpaCenter", "ftpcClient", "ftbPort", "ctpClient", "ftsClient", "ftpcConnection", "ftpAPI", "ctpPort", "ftpaclient", "ftpContext", " ftpConnection", " ftpclient", "ftcpAPI", "ftpaServer", " ftpContext", "ftcpConn", "ftpcConnect", "ftpaConn", " ftpCenter", " ftbCloud", " ftpCloud", "ftcpContext", "ftcpAddress", " ftpConn", " ftbConn", "ftcpclient", " ftbclient", "ctcpConnect", "ctcpConn", "ftpiAPI", "ftpcPort", "ftpServer", "ftpcclient", "ftpaPort", " ftpPort", "ftapServer", "ctpConn", "ftnAddress", "ftcpCenter", " ftpaClient", "ftpConn", "ftpcConn", "ftpiClient", " ftpcClient", "ftbConn", "ctpServer", "ftnServer", "ftbClient", "ftcpConnect", "ftpaAddress", "ftcpConnection", "ftprclient", "ctcpServer", " ftpcConnection", "ftpclient", "ftpiAddress", "ctcpPort", "ftapClient", "ftpCenter", " ftpcServer", "ftpConnection"], "ftpAddress": ["ftcpPort", "ftoAddress", "ftrAdd", "ctpAddress", "ftlPort", "ftcpAlias", "ftapAddress", "ftnpAddress", "ftpPort", "ftcpEntry", " ftpaddress", "ftrAddress", "ctcpURL", "ftapaddress", "ftfaddress", "ftapAlias", "ctcpAdd", "ftpURL", "ctoaddress", "ftpAdd", "ftwpAddress", "fttpEntry", "ftwpPort", "ctcpAddress", "ftcpInterface", "ctpaddress", "ctoPort", "ctpPort", "ftapPort", "fttpAddress", "ftoaddress", "ftpAlias", "ftfPort", "ctpInterface", "ftfInterface", "ftcpAddress", "ftlAddress", "ftnpaddress", "ftnpPort", "ftpaddress", " ftpPort", "ftfAddress", "ftportAddress", "ftrPort", "ftportaddress", "ctpURL", " ftcpAddress", "ctpAdd", "ftcpURL", "ctcpInterface", "fttpaddress", "fttpPort", "ftoPort", "ftfEntry", " ftpAlias", "ctcpEntry", "ftrInterface", "ctcpaddress", " ftcpPort", " ftcpAlias", "ftcpAdd", "ftwpaddress", "ftnpURL", "ftladdress", "ctoAddress", "ctpEntry", "ctcpPort", "ftportPort", "fttpURL", "ftfAdd", "ftpEntry", " ftcpaddress", "ftpInterface", "ftcpaddress", "ftportAlias"], "noRetries": ["noExtries", " noPatrys", "noRetry", " noRetry", "noretrys", "noExtrys", "noPatrys", "noRetrys", "noPatries", "noretries", " noRetriers", "noTrys", "noPatry", "noPatrying", "noPatriers", " noRetrying", "noTry", " noPatrying", "noretrying", "noEntrying", " noPatry", "noExtry", " noRetrys", "noEntriers", " noPatries", "noRetriers", "noEntries", "noTries", "noTrying", "noRetrying", "noExtrying", " noPatriers", "noretriers", "noEntrys"], "remoteHomeDir": ["RemoteRootDir", "remoteRootDirectory", "remoteRootPath", " remotehomeFolder", "remoteHostDir", "RemoteRootPath", "remoteHostDirectory", " remoteHomeDirectory", "remoteHostFile", "remoteRootFolder", "RemoteHomeFile", "remoteRootDir", "RemoteHomeDir", "remoteHostFolder", " remotehomeDirectory", "RemoteHomePath", "RemoteHomeDirectory", "remotehomeDirectory", "RemoteRootDirectory", " remotehomeDir", "remoteHomePath", " remoteHomeFile", "remoteHomeFile", "remotehomeFile", "remotehomeFolder", "remotehomeDir", "remotehomePath", "remoteWorkingDirectory", "remoteHomeDirectory", " remotehomeFile", "remoteWorkingFile", "remoteHomeFolder", "remoteWorkingPath", "remoteRootFile", "remoteWorkingDir", " remoteHomeFolder", "RemoteRootFile", "remoteHostPath"], "noRetriesSoFar": ["noRetrySoFar", "noRetriesTooFar", "noRetryingSoMuch", "noRetrysSoFar", "noRetriessoFurther", "noRetriesStillFurther", "noRetriesSOMuch", "noRetriessofar", "noRetrysSOfar", "noRetrysSOFurther", "noRetriesStillFar", "noRetriesTooMuch", "noRetryingSofar", "noRetriesToofar", "noRetriesSOFurther", "noRetrySOFar", "noRetrysSoFurther", "noRetriesSinceFar", "noRetryingsoFar", "noRetryingSoFar", "noRetriesSoFurther", "noRetriesSoMuch", "noRetrysSOFar", "noRetryingsoMuch", "noRetriesSOFar", "noRetriesSOfar", "noRetrySOfar", "noRetrySofar", "noRetriessoMuch", "noRetrysSofar", "noRetriesSofar", "noRetryingsofar", "noRetriesStillfar", "noRetriessoFar", "noRetriesSincefar"], "reply": ["from", "reason", "info", "dy", "base", "address", "server", "feed", "response", "rc", "user", "report", "message", "py", "result", "answer", "write", "ret", "ply", "queue", "next", "post", "sync", "resp", "connection", " replied", "len", "Reply", " replies", "request", "status", "lie", "send", "call", "link", "prefix", "ping", "bot", "respond", "comment", "state", "count", "repl", "error", "service", "code", "ix"]}}
{"id1": "12428013", "id2": "4629990", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    private String logonToServer(FTPClient ftpClient, String ftpAddress, int noRetries) {\n        String remoteHomeDir = null;\n        noRetriesSoFar = 0;\n        while (true) {\n            try {\n                ftpClient.connect(ftpAddress, ftpPort);\n                int reply = ftpClient.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftpClient.disconnect();\n                    throw new IOException();\n                }\n                if (!ftpClient.login(user, password)) {\n                    throw new IOException();\n                }\n                remoteHomeDir = ftpClient.printWorkingDirectory();\n                msgEntry.setAppContext(\"logonToServer()\");\n                msgEntry.setMessageText(\"Logged into FTP server \" + ftpAddress + \":\" + ftpPort + \" as user \" + user);\n                logger.logProcess(msgEntry);\n                break;\n            } catch (IOException e) {\n                logoutAndDisconnect(ftpClient);\n                if (noRetriesSoFar++ < noRetries) {\n                    waitBetweenRetry();\n                    notifyAndStartWaitingFlag = false;\n                } else {\n                    notifyAndStartWaitingFlag = true;\n                    errEntry.setThrowable(e);\n                    errEntry.setAppContext(\"logonToServer()\");\n                    errEntry.setAppMessage(\"Unable to login after \" + (noRetriesSoFar - 1) + \" retries. Max Retries.\\n\" + \"Address:\" + ftpAddress + \"\\n\" + \"User:\" + user);\n                    errEntry.setSubjectSendEmail(\"Unable to login to \" + ftpAddress + \" after \" + (noRetriesSoFar - 1) + \" retries.\");\n                    logger.logError(errEntry);\n                    break;\n                }\n            }\n        }\n        return remoteHomeDir;\n    }\n", "label": 1, "substitutes": {"polishOff": [" synchronipeOn", " synchroniceOn", " polishDown", " polishOn", " synchroniceOff", " synchronishingOn", " polishingOn", " synchronishingOffline", " synchroniceDown", " synchronishingOff", " synchronipeOffline", " synchronishOn", " synchronishingDown", " synchroniceOffline", " synchronipeOff", " synchronishDown", " synchronishOff", " polishingOff", " synchronishOffline", " synchronipeDown", " polishOffline", " polishingOffline", " polishingDown"], "monitor": ["directory", "reason", "handler", "core", "loader", "duration", "username", "timeout", "master", "report", "message", "clock", "oper", "program", "watch", "number", "driver", "match", "thread", "manager", "sm", "condition", "period", "mon", "client", "cm", "stat", "member", "Monitor", "component", "pm", "counter", "config", "timer", "body", "object", "widget", "log", "mor", "control", "conn", "or", "m", "meter", "image", "port", "controller", "dm", "runner", "don", "status", "function", "mc", "cher", "umi", "update", "unit", "processor", "consumer", "container", "annot", "progress", "state", "method", "callback", "module"], "from": ["remote", "path", "address", "string", "base", "ou", "server", "uri", "id", "username", "resource", "user", "by", "add", "vol", "origin", "host", "code", "owner", "form", "part", "at", "email", "source", "ce", "type", "back", "connection", "component", "small", "route", "channel", "actor", "size", "or", "about", "start", "name", "front", "action", "who", "prefix", "since", "false", "url", "left", "range", "with", "From", "contact", "attribute", "org", "loc"], "to": ["remote", "info", "address", "base", "server", "uri", "token", "until", "resource", "eto", "user", "by", "into", "site", "version", "ref", "table", "o", "dest", "location", "su", "database", "TO", "key", "two", "type", "source", "so", "value", "target", "connection", "file", "To", "out", "go", "size", "reply", "about", "name", "po", "io", "pos", "toc", "prefix", "full", "url", "top", "range", "left", "with", "repl"], "renameTo": ["renributeTarget", " RenseTO", "renAMEWill", "renameFor", "renamelFor", "reageto", "renewTarget", " renameFrom", "reageTo", "reageTO", " RenseFor", "renamelOf", "renewFrom", "renewTo", "renameWill", "renamWill", "renamFor", "reameTo", "renamelTo", "relameTarget", " RenameFor", "renameUrl", " RenameTo", "renalToken", " RenameOf", "relenameTo", "renalFrom", "renalTO", "relameFrom", "renAMEto", "renseTO", " renameTarget", "renamTarget", "renameto", "relalTarget", "renAMETarget", " renAMEFrom", "relameUrl", "relenameUrl", " RenameTO", "renenameto", "renamelTO", " RenAMETo", "relenameto", "renalTarget", "relameto", "renameFrom", "renameOf", "renokeTO", "renenameTo", "renAMETO", "renAMEUrl", "renoketo", "renributeTo", "renameTO", "reameTO", "rennameTarget", "relalTo", "relameTo", "renamTo", "renageToken", " RenAMEFor", "renameTarget", "renageto", "reameto", "renameToken", "renalto", "reageToken", "reameToken", "relalto", "relalFrom", "rennameFrom", "rennameto", "renageTo", "renAMEToken", "renAMETo", "renseTo", "renokeUrl", " RenameTarget", "renokeFor", " RenameWill", " RenAMETarget", " RenAMEWill", "renributeFor", " RenseTo", "renAMEFrom", "renageTO", "renalTo", "renseFor", "renseOf", "renokeFrom", "renokeTo", " renAMETarget", " renAMETo", "renenameTarget", "renokeOf", "renenameFrom", "renenameUrl", "renAMEFor", "relenameFrom", " RenseOf", "renributeWill", "rennameTo"], "ftpClient": ["ctcpClient", "ftpControl", "ftiServer", "ftlCommunity", "ftpCan", "ftpsContainer", " ftpiClient", "ftmResource", " ftapiClient", " ftpiChannel", " ftiClient", "ftpsClass", " ftoServer", "ftcpCloud", "ftpContainer", "ftcClient", "fttpClass", " ftnServer", "ftpGuest", "ftoCan", "ftcpServer", "ftpiServer", "ftpcHelper", "fttpStream", "ftpcContainer", " ftpoClient", "ftpcControl", "ftfpClient", " fttpContainer", "ftmChannel", "ftpChannel", "ftlClient", "ftnClient", "ftcpClient", " fttpControl", "ftfpChannel", "ftmClient", " ftpControl", "ftpcCloud", " ftpGuest", "aftpClient", " ftpoCloud", "ftcpResource", " ftpServer", " ftpiServer", "ftfpCloud", " ftlCenter", "ftpCloud", "afttClient", "ctpChannel", "ftpiHost", "ftpcServer", "fttStream", "ftbrStream", "ftcServer", "fttpControl", " ftlConnection", "ctcpResource", "ftlConnection", "ftapiHelper", " ftpChannel", " ftiServer", "ctpResource", " fttpClient", " ftpCan", "fttpHost", "fttpCan", "ftpcClient", "ftpsClient", "ctpClient", "ftbServer", "ftpcConnection", " ftapiServer", " fticlient", "ftcpHelper", "ftoClient", "ctcpChannel", "fttpServer", " ftpoCenter", " ftpConnection", " ftpclient", "afttStream", "ftapiCloud", "ftcpChannel", " ftiGuest", "ftnHost", " ftpCenter", "ftpiChannel", "fticlient", " ftpCloud", "ftapiClient", "ftpoCloud", "ftcpclient", "ftcclient", "ftcpCommunity", " ftlCommunity", "ftpoClient", " ftoCan", " ftpHelper", "ftpServer", "ftbCan", " fttpClass", "ftfpServer", "ftiGuest", "fttpClient", "ftpCommunity", "fttClient", "ftcpCenter", "fttpContainer", "ftoHost", " ftpContainer", "aftpStream", "ftpiClient", " ftpClass", "ftfClient", "ftpcCommunity", " ftpiHost", "ftoServer", "ctpServer", "ftfCenter", " ftlClient", "ftmServer", "ftnServer", "ftpcClass", "ftpsControl", " ftnClient", "ftbClient", "ftlCenter", " ftpHost", "ftcpConnection", " ftapiHelper", "ftpHost", "ctcpServer", " ftoHost", "ftpResource", "ftbHost", "ftpoCenter", "ftpclient", " ftpCommunity", "ftcGuest", "ftfpResource", "ftpStream", "ftfpCenter", "ftpCenter", "ftiClient", " ftoClient", "fttpChannel", "ftpClass", "ftpHelper", "ftpcCenter", " ftapiCloud", " ftnHost", "ftfCloud", "ftapiServer", "ftpConnection", "ftcpHost", "ftcpGuest", "ftbrClient"], "ftpHolder": ["fttpChook", "ftpChard", "ftphook", "ftpWolder", "ftpSholder", "ftpholder", "fttpHolder", "fttpHook", "ftpWorkolder", "ftpChander", "ftpcHolder", "ftpHold", "fttpHander", "ftpHook", "ftpcHather", "ftpHard", "ftphold", "fttpHard", "ftpWorkold", "ftpWorkholder", "ftphather", "ftpShook", "ftpShard", "ftpWold", "ftpcHholder", "ftpHander", "ftpcHold", "ftpHholder", "ftpCholder", "fttpChander", "ftpWorkather", "ftphard", "ftpShander", "ftphander", "fttpChard", "ftpcWolder", "ftpcWather", "ftpHather", "ftphholder", "ftpWholder", "ftpcWold", "ftpcWholder", "ftpWather", "ftpChook", "fttpCholder"], "iter": ["ite", "index", "info", "i", "itter", "id", "outer", "entry", "http", "inter", "inner", "oper", "result", "limit", "walker", "end", "ter", "set", "ipper", "gener", "in", "next", "er", "collect", "izer", "its", "Iterator", "ener", "reader", "ner", "inc", "file", "ir", "ip", "ator", "iterator", "Iter", "keep", "size", "init", "or", "coll", "e", "chain", "it", "skip", "cher", "ver", "ser", "over", "err", "finder", "f", "former", "iv", "list", "enter", "loc"], "element": ["optional", "output", "token", "ee", "resource", "document", "number", "match", "Element", "ele", "content", "member", "component", "empty", "style", "coll", "comment", "container", "module", "server", "option", "result", "owner", "next", "part", "value", "connection", "section", "parent", "page", "object", "variable", "plugin", "header", "e", "attribute", "service", "event", "article", "letter", "node", "editor", "atom", "entry", "per", "inner", "line", "el", "er", "email", "reader", "or", "cell", "input", "et", "instance", "child", "key", "expression", "type", "item", "activity", "data", "text", "entity", "environment", "folder", "action", "layer", "air", "this", "definition"]}}
{"id1": "13563706", "id2": "18782385", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["handlePut", "didGet", "didGET", "didPut", "didget", "doget", " doPut", "doGET", "handleGET", "doPut", "handleget", " doget", "handleGet", " doGET"], "request": ["event", "remote", "info", "string", "buffer", "input", "Request", "server", "resource", "user", "report", "message", "document", "current", "result", "instance", "query", "queue", "req", "client", "type", "connection", "model", "application", "config", "data", "object", "p", "complete", "QUEST", "image", "frame", "url", "Response", "create", "xml", "attribute", "method", "view"], "response": ["index", "reason", "server", "output", "resource", "feed", "report", "http", "res", "message", "results", "site", "document", "onse", "subject", "result", "json", "description", "location", "pool", "query", "client", "resp", "connection", "model", "application", "collection", "body", "object", "reply", "header", "status", "writer", "image", "re", "Response", "respond", " Response", "wa", "error", "service", "api", "view"], "selectedPage": ["lectedButton", "selectionpage", "selectedButton", " selectedAction", "namedpage", "lectedpage", "electedLine", "namedFile", "lectedSite", "selectionHour", "selectionLine", "selectionFile", " selectedItem", "selectionItem", "selectedLine", "selectedSite", "selectedpage", "lectedFile", "namedLine", "selectedFile", " selectedHour", " selectedFile", "electedPage", "selectionButton", "lectedPage", "namedPage", "lectedItem", " selectedButton", "selectionPage", "selectedAction", "electedpage", " selectedpage", "selectedHour", "selectionAction", "lectedAction", "lectedLine", " selectedSite", "lectedHour", "electedButton", "namedSite", " selectedLine", "selectedItem"], "page": ["handler", "resource", "document", "number", "rule", "model", "phone", "row", "url", "sp", "office", "module", "menu", "point", "address", "server", "site", "result", "account", "location", "html", "pl", "cache", "pp", "proxy", "connection", "section", "parent", "channel", "route", "ip", "plugin", " Page", "unit", "peer", "article", "node", "message", "per", "ge", "record", "queue", "Page", "ice", "p", "language", "change", "image", "position", "photo", "display", "pg", "view", "fe", "user", "profile", "project", "instance", "child", "pool", "layout", "client", "type", "item", "je", "po", "port", "me", "age", "block", "f"], "portalRequest": ["portialQuery", "portALUser", "portailResponse", "PortortalOrder", "PortortalEvent", "portpalAccess", "portailRequest", "portALResponse", "PortortalAccess", "portialRequest", "portalQuery", "portortalResponse", "portelRequest", " portialQuery", "PortortalUser", "portortalPage", "portortalUser", "portugalResponse", "portallingPage", "portalPage", "PortortalResponse", "portugalRequest", " portalQuery", "PortortalPage", "portortalOrder", "PortalEvent", " portialPage", "portugalOrder", "portalAccess", "portpalRequest", " portalResponse", " portialResponse", "PortalUser", "portALRequest", "portallServer", "portortalAccess", "portortalEvent", "PortalAccess", "portallUser", "portallingRequest", "portugalUser", "portialPage", "portbalQuery", "portortalServer", "portelCommand", "portelPage", "PortalPage", "PortalOrder", "PortortalServer", "portalUser", "PortalCommand", "portallRequest", "portpalResponse", "PortalServer", "portelResponse", "portailUser", "PortalResponse", "portallResponse", "portortalRequest", "portialResponse", "portpalPage", "portbalPage", "portallingAccess", " portalPage", "portailOrder", "portallingResponse", "portalServer", "PortortalRequest", " portialRequest", "portugalEvent", "portalResponse", "portugalServer", "portALEvent", "portbalResponse", "portelQuery", "PortortalCommand", "portalCommand", "portalOrder", "portallingCommand", "PortalRequest", "portalEvent", "portbalRequest", "portortalCommand"], "pageProp": ["PageProp", "agePro", "resourceProperty", "projectPro", "pageprop", "pluginPro", "Pageprop", "peerStr", "resourceProp", "ageProp", "pageObj", "pageProperty", " pageStr", "parentObj", "PageProperty", "PageStr", "pageStr", "pluginprop", "PagePro", "parentProperty", "PageObj", "peerProperty", " pageProperty", "ageProperty", "peerPro", "resourceprop", "projectprop", "pagePro", " pagePro", "projectProp", "projectProperty", "parentProp", "ageprop", "pluginProperty", " pageObj", "resourcePro", "peerProp", "parentPro", "pluginProp"], "possiblePage": ["possiblePages", "pablePages", "possiblepage", "puredPage", "possibilityLine", "Possibilitypage", "possiblyPages", "PossiblyGroup", "PossibilityLine", "possibleLine", "permanentLine", "possibleOrder", "PossiblyPage", "pablepage", "PossibleOrder", "possibleItem", "PossiblyItem", "Possiblepage", "puredpage", "PossibleGroup", "possiblyItem", "permanentpage", "puredItem", "PossiblyOrder", "PossibleItem", "patchingpage", "patchingItem", "possiblypage", "patchedOrder", "patchedpage", "PossiblyLine", "pableLine", "PossiblePage", "permanentPage", "PossibilityPage", "PossiblePages", "possibilityPage", "possibleGroup", "PossibleLine", "PossibilityPages", "patchingPage", "possiblyLine", "possiblyOrder", "patchingGroup", "Possiblypage", "permanentOrder", "possiblyGroup", "pablePage", "patchedLine", "possibilityPages", "puredGroup", "possiblyPage", "patchedPage", "possibilitypage"], "property": ["integer", "string", "address", "class", "uration", "duration", "resource", "perties", "character", "profile", "maximum", "table", "project", "result", "number", "set", "key", " Property", "expression", "Property", "type", "binary", "value", "feature", "section", "config", "data", "entity", "object", "p", "variable", "language", "name", "header", "notation", "t", "function", "operator", "label", "prefix", "layer", "prop", "future", "binding", "properties", "attribute", "f", "term"], "referer": ["rere", "redber", "reiner", "Referers", "refender", "Referer", "affere", "referen", " refre", " refber", "reerer", "diffender", "differer", "rederer", "Refre", "defere", "defber", "Refber", " refender", "afferer", "diffrer", "Refeline", "afferen", "Refrer", "rerer", "refiner", " referen", " refere", "refber", "Refiner", "redrer", "redeline", "refeline", "defender", " refeline", "Refender", "diffiner", "Referen", "refrer", "ferers", " referers", " refiner", "frer", " refrer", "ferer", "fere", "reere", "refre", "deferer", "referers", "affrer", "refere", "Refere", "defrer"], "e": ["event", "fe", "i", "ee", "ie", "message", "o", "se", "ception", "ele", "er", "type", "one", "d", "see", "ea", "de", "exc", "p", "es", "ae", "null", "or", "E", "a", "ed", "this", "me", "err", "f", "error", "eme", "element", "esi"]}}
{"id1": "22503685", "id2": "732800", "code1": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 0, "substitutes": {"readGeoParserResult": ["readGeoWalkerResult", "readGeoparserReport", "readGeoReaderResult", "readGeoReaderReport", "readGeoParserOutput", "readGeOReaderReport", "readGeoWalkerReport", "readGeOParserReport", "readGeoReaderOutput", "readGeOParserOutput", "readGeoparserResult", "readGeoparserResults", "readGeoWalkerOutput", "readGeoReaderResults", "readGeOReaderResults", "readGeoWalkerResults", "readGeoParserReport", "readGeOReaderResult", "readGeOReaderOutput", "readGeoparserOutput", "readGeoParserResults", "readGeOParserResults", "readGeOParserResult"], "recordContent": ["resourceContents", " recordText", "recordText", "reportContent", "recordMessage", "RecordText", "resourceContent", "resourceText", "reportText", "recordBody", "RecordContent", "RecordMessage", "reportMessage", "RecordFile", "resourceFile", " recordBody", " recordMessage", "RecordBody", " recordFile", "recordFile", "reportBody", " recordContents", "recordContents", "RecordContents"], "getGazeteerIds": ["getGazeteerHostes", "getGazeteersIdes", "getGazeteerConfigxs", "getGazeteerNeedes", "getGazeteerNeeders", "getGazeteerLogls", "getGazeteersLogings", "getGazeteersIds", "getGazeteerHostings", "getGazeteersLogxs", "getGazeteerLogs", "getGazeteerIders", "getGazeteerTextings", "getGazeteerConfigings", "getGazeteerIdings", "getGazeteersLogls", "getGazeteersLogers", "getGazeteerNeeds", "getGazeteerHosts", "getGazeteerLogxs", "getGazeteersIdls", "getGazeteerHosters", "getGazeteerIdes", "getGazeteersIders", "getGazeteerTextls", "getGazeteerIdxs", "getGazeteerConfigs", "getGazeteersIdxs", "getGazeteerIdls", "getGazeteersLogs", "getGazeteerLogings", "getGazeteerNeedings", "getGazeteerLogers", "getGazeteerTextxs", "getGazeteersLoges", "getGazeteerConfigls", "getGazeteerTexts", "getGazeteerLoges", "getGazeteersIdings"], "ret": ["gt", "info", "fun", "Ret", "att", "bf", "replace", "mem", "sys", "results", "res", "ref", "vet", "result", "rg", "match", "arg", "rt", "feat", "ft", "usr", "iter", "arr", "part", "nt", "resp", "Return", "len", "str", "alt", "ut", "group", "default", "rets", "data", "out", "g", "r", "get", "ll", "reply", "hash", "dict", "t", "status", "array", "opt", "ext", "obj", "reg", "det", "Result", "RET", "repl", "f", "re", "list"], "retries": ["Retries", "altrys", "altrying", "RETrying", " retrying", "altries", "retry", "RETried", "RETries", "retrys", "altried", " retrys", "trys", "tried", "RETrys", "Retrys", "retrying", " retry", "Retry", "trying", "tries", "Retrying", "retried"], "reqPre": ["reqpre", "resppre", "refPost", "reqPost", "respPre", "refPlan", " requestPref", " reqPref", "requestPre", " reqPost", "respPost", " requestPost", "requestPost", "requestPref", " requestpre", "requestpre", "refpre", "reqPlan", " requestPre", "reqPref", "respPlan", " reqpre", "requestPlan", "refPre"], "outputFormat": ["OutputVersion", "OutputType", "outputType", "outputVersion", "inputSettings", "reportVersion", "reportFormat", "inputVersion", "reportType", "reportSettings", "inputType", "OutputSettings", "inputFormat", "OutputFormat", "outputSettings"], "doc": ["event", "info", "resource", "response", "Doc", "df", "http", "docs", "document", "DOC", "project", "result", "html", "record", "dr", "dc", "part", "git", "up", "date", "str", "feature", "md", "data", "file", "text", "body", "div", "page", "h", "style", "msg", "desc", "coll", "m", "e", "po", "home", "pos", "db", "di", "mc", "bc", "bug", "parse", "b", "xml", "f", "Document", "tx", "api"], "url": ["string", "path", "base", "info", "address", "buffer", "ssl", "server", "uri", "resource", "response", "id", "entry", "http", "document", "ref", "result", "html", "l", "location", "URL", "orb", "source", "connection", "browser", "str", "r", "data", "file", "channel", "page", "request", "web", "name", "e", "sl", "Url", "b", "f", "element", "org", "api"], "reader": ["info", "handler", "buffer", "input", "uri", "resource", "feed", "rc", "http", " parser", "instance", "read", "tx", "iter", "er", "oder", " readers", "r", "parser", "data", "file", "rr", "or", "writer", "io", "stream", "Reader"]}}
{"id1": "6304373", "id2": "4417943", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    public void test() {\n        try {\n            String query = \"* <http://xmlns.com/foaf/0.1/workplaceHomepage> <http://www.deri.ie/>\" + \"* <http://xmlns.com/foaf/0.1/knows> *\";\n            String url = \"http://sindice.com/api/v2/search?qt=advanced&q=\" + URLEncoder.encode(query, \"utf-8\") + \"&qt=advanced\";\n            URL urlObj = new URL(url);\n            URLConnection con = urlObj.openConnection();\n            if (con != null) {\n                Model model = ModelFactory.createDefaultModel();\n                model.read(con.getInputStream(), null);\n            }\n            System.out.println(url);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrMempl", "uploadOrDeleteMediaOrTemplateporary", "uploadOrDeleteMediaOrTemFiles", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrTemplateplates", "uploadOrDeleteMediaOrtempl", "uploadOrDeleteMediaOrMemporary", "uploadOrDeleteMediaOrtemplates", "uploadOrDeleteMediaOrMemFiles", "uploadOrDeleteMediaOrTemplatepl", "uploadOrDeleteMediaOrtemFiles", "uploadOrDeleteMediaOrTemplateFiles", "uploadOrDeleteMediaOrtemporary", "uploadOrDeleteMediaOrTemporary", "uploadOrDeleteMediaOrMemplates"], "action": ["event", "error", "resource", "element", "lock", "now", "site", "act", "version", "ction", "activation", "flow", "active", "next", "ACTION", "what", "part", "type", "operation", "activity", "item", "section", "parent", "flash", "environment", "style", "plugin", "format", "test", "effect", "name", "change", "status", "controller", "function", "call", "commit", "actions", "url", "Action", "state", "step", "method", "module", "service", "api", "view"], "object": ["directory", "article", "event", "string", "address", "class", "node", "letter", "self", "resource", "lock", "ject", "now", "subject", "document", "version", "project", "system", "current", "mode", "o", "instance", "number", "host", "thread", "zone", "part", "email", "not", "target", "module", "model", "group", "none", "parent", "objects", "oid", "environment", "request", "edit", "image", "function", "full", "url", "obj", "office", "element", "service", "auto"], "numElements": [" numElem", "numEllement", "numEllem", "numelem", "numelement", " numEodes", "numEllements", "numGelement", "numGelements", "numeodes", "numGeodes", " numeodes", " numelement", "numelements", "numElem", " numelem", "numEodes", "numGelem", "numElodes", " numelements"], "req": ["base", "builder", "report", "res", "html", "ro", "mr", "usr", "util", "next", "params", "use", "load", "resp", "r", "g", "parent", "log", "verb", "msg", "gr", "ctx", "update", "conf", "err", "obj", "xml", "module"], "session": ["event", "ession", "temp", "resource", "response", "token", "lock", "http", "site", "document", "subject", "system", "result", "instance", "global", "thread", "manager", "security", "client", "sa", "cache", "use", "connection", "browser", "scope", "shared", "local", "request", "flash", "h", "context", "Session", "test", "image", "person", "ctx", "ESSION", "sp", "container", "state", "service"], "ftp": ["FTp", " ftcp", "ftcp", "FTP", "ftP", "ftc", "ttc", " ftP", "ttP", " ftc", "FTc", "FTcp", "ttp", "ttcp"], "user": ["string", "info", "path", "base", "class", "self", "ee", "username", "lock", "by", "mail", "USER", "profile", "author", "per", "User", "project", "result", "system", "account", "html", "admin", "current", "match", "record", "pass", "usr", "post", "er", "client", "type", "use", "users", "rule", "member", "facebook", "connection", "browser", "module", "other", "group", "shared", "config", "data", "used", "parent", "usa", "page", "log", "creator", "name", "e", "image", "home", "db", "person", "full", "ver", "url", "bug", "auth", "comment", "state", "error", "custom", "this", "hash", "view"], "links": ["base", "headers", "Link", "pages", "results", "mail", "posts", "html", "styles", "ids", "linked", "items", "email", "lines", "members", "images", "flash", "log", "groups", "Links", "tree", "image", "link", "details", "actions", "mails", "url", "menu"], "folders": ["anchers", "anchors", "handries", "filors", "handers", "filages", "filers", "handages", "filries", "foldages", "anchries", "handors", "foldries", "anchages", "foldors"], "folder": ["directory", "zip", "path", "letter", "address", "editor", "uri", "resource", "id", "division", "document", "filename", "slice", "project", "volume", "location", "layout", "zone", "database", "two", "picture", "email", "fold", "source", "dir", "connection", "scope", "upload", "sample", "level", "archive", "flat", "region", "ignore", "append", "device", "plugin", "home", "area", "theme", "layer", "url", "future", "Folder", "command", "network", "menu", "element", "license", "enter"], "server": ["directory", "string", "remote", "ssl", "address", "node", "resource", "uri", "username", "outer", "token", "master", "Server", "site", "filename", "version", "socket", "slave", "system", "inner", "account", "location", "host", "manager", "database", "client", "email", "type", "source", "reader", "seed", "connection", "value", "page", "device", "status", "port", "erver", "url", "ser", "localhost", "peer", "network", "scale", "engine", "service", "enter"], "login": ["string", "path", "info", "pin", "ssl", "resource", "skin", "username", "lock", "sudo", "mail", "site", "bridge", "filename", "profile", "socket", "account", "shell", "layout", "pass", "database", "picture", "email", "users", "connection", "Login", "group", "machine", "config", "journal", "log", "plugin", "name", "status", "blank", "blog", "label", "access", "url", "auth", "secret", "consumer", "cookie", "network", "basic", "service"], "password": ["directory", "string", "token", "username", "mask", "timeout", "sudo", "division", "filename", "profile", "slave", "volume", "account", "manager", "pass", "database", "pattern", " passwords", "picture", "security", "Password", "email", "PASS", "connection", "alias", "sword", "language", "device", "plugin", "name", "ass", "word", "worker", "access", "strip", "photo", "secret", "auth", "cookie", "padding", "basic", "phrase", "column"], "fileTransferFolder": ["fileTransferPath", "FileUploadfolder", "mediaTransferFolder", "fileUploadTheme", "fileImportFolder", "fileAccessFolder", "fileImportServer", "fileUploadPath", "fileTransferfolder", "mediaUploadServer", "fileTransformPath", "FileTransferPath", "fileUploadServer", "fileTransferServer", "mediaUploadfolder", "FileTransferTheme", "FileUploadFolder", "fileTransformfolder", "fileUploadfolder", "fileTransferTheme", "mediaTransferfolder", "FileUploadPath", "mediaUploadDirectory", "FileUploadTheme", "fileUploadDirectory", "fileImportfolder", "fileUploadFolder", "mediaTransferDirectory", "fileImportDirectory", "fileTransferDirectory", "fileAccessfolder", "FileTransferfolder", "fileAccessPath", "fileTransformFolder", "fileAccessTheme", "FileTransferFolder", "mediaUploadFolder", "fileTransformTheme", "mediaTransferServer"], "liveFolder": ["PreviewLocation", " liveDirectory", "PreviewFolder", "Livefolder", "PreviewDirectory", "Previewfolder", "livefolder", "LiveLocation", "LiveFolder", "LiveDirectory", " livefolder", "liveDirectory", "liveLocation", " liveLocation"], "servers": ["serServer", "servations", " serls", "serls", "servServer", "Serations", "SerServer", " serations", "Servers", "serations", "servls", " serServer", "servvers", "Serls"], "message": ["string", "path", "address", "buffer", "mess", " messages", "response", "resource", "mail", "document", "description", "manager", "content", "email", "member", "module", "application", "body", "page", "request", "flash", "Message", "log", "msg", "header", "status", "image", "array", "details", "url", "update", "summary", "error", "element", "menu"]}}
{"id1": "8515891", "id2": "12246545", "code1": "    protected String readUrl(String svnUrl) throws IOException {\n        URL url = new URL(svnUrl);\n        URLConnection uc = url.openConnection();\n        if (url.getProtocol().equals(\"https\")) {\n            String userPassword = user + \":\" + password;\n            String encoding = new sun.misc.BASE64Encoder().encode(userPassword.getBytes());\n            uc.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        InputStream is = null;\n        String in = null;\n        try {\n            is = uc.getInputStream();\n            in = read(is);\n        } finally {\n            try {\n                is.close();\n            } catch (Exception e) {\n            }\n        }\n        return in;\n    }\n", "code2": "    public void load(String url) throws IOException {\n        this.url = url;\n        int col = url.indexOf(':');\n        if (col > 1 && col < 5) {\n            load(new URL(url).openStream());\n        } else {\n            if (new File(url).exists()) {\n                System.out.println(\"Loading JAD from file : \" + url);\n                FileInputStream fin = new FileInputStream(url);\n                try {\n                    load(fin);\n                } finally {\n                    fin.close();\n                }\n            } else {\n                InputStream in = getClass().getResourceAsStream(url);\n                if (in != null) {\n                    System.out.println(\"Loading JAD from classpath : \" + url);\n                    load(in);\n                } else {\n                    throw new IOException(\"\\\"\" + url + \"\\\" was found in file system or classpath\");\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"readUrl": ["ReadQuery", "getUrl", "processURL", "getQuery", "processPage", "readPage", "getURL", "ReadURL", "getPage", "processUrl", "readQuery", "readURL", "processQuery", "ReadPage", "ReadUrl"], "svnUrl": ["svlURL", " svnURL", " svNEl", "svbUrl", "svbUr", " svNUr", "svNUrl", "svnEl", " svnFile", "svcnStr", "svNStr", "svbFile", " svNFile", "svpnFile", " svNURL", " svnStr", "svnStr", " svnEl", "svnUr", "svlEl", "svnFile", "svbURL", "svcnURL", "svNFile", "svNEl", "svpnUrl", " svnUr", "svlUrl", "svcnUrl", "svNUr", "svlStr", "svnURL", " svNStr", "svcnEl", "svpnURL", "svpnUr", " svNUrl", "svNURL"], "url": ["path", "ssl", "server", "uri", "resource", "feed", "user", "http", "c", "fc", "l", "URL", "util", "client", "up", "connection", "r", "ob", "open", "config", "cl", "web", "page", "bb", "log", "context", "conn", "blog", "sl", "pull", "Url", "bc", "www", "stream", "bug", "ur", "b", "ul", "f", "plug", "cur", "this", "org", "loc"], "uc": ["anc", "cu", "ssl", "tc", "cc", "sc", "uri", "cf", "rc", "http", "con", "c", "fc", "co", "ec", "client", "cp", "cas", "up", "auc", "connection", "ocr", "lc", "oc", "roc", "uca", "cl", "ub", "usc", "conn", "coll", "exec", "uci", "userc", "ucc", "pc", "mc", "us", "soc", "bc", "cci", "bug", "ac", "connect", "UC", "ul", "hub", "cur", "loc"], "userPassword": ["userSecret", "currentSecret", " userSecret", "currentPassword", " userpassword", "usePass", " userAuth", "userPass", "currentpassword", "userpassword", " userPass", "usepassword", "UserPassword", "UserPass", "userAuth", "useAuth", "Userpassword", "UserAuth", "useSecret", "usePassword", "currentPass"], "encoding": ["encording", "enoder", "Encoded", "Encoder", " encoder", "Encording", "enasing", "Encoding", "engoded", "enoded", "enoding", "engasing", " encoded", "engoding", " encording", "Encasing", "encoder", "enording", "encasing", "encoded", "engoder"], "is": ["info", "bis", "i", "iss", "id", "uri", "fs", "IS", "lis", "isa", "serv", "ie", "Is", "as", "ri", "irc", "ins", "s", "abs", "si", "ois", "ui", "ms", "ori", "isl", "its", "ws", "ais", "isc", "ir", "out", "src", "nis", "ip", "es", "has", "iso", "init", "vs", "ls", "ris", "ci", "it", "iris", "ios", "us", "ib", "isi", "are", "cs", "os", "was", "api"], "in": ["IN", "string", "pin", "edIn", "i", "id", "inas", "input", "reading", "ini", "gin", "into", "con", "inner", "atin", "ins", "arin", "line", "bin", "read", "raw", "source", "reader", "login", "inside", "inc", "rin", "out", "oin", "vin", "rec", "again", "m", "re", "isin", "In", "nin", "pc", "kin", "cin", "inn", "f", "tin", "din"]}}
{"id1": "18544890", "id2": "6866575", "code1": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 0, "substitutes": {"get": ["remote", "info", "list", "resource", "gets", "json", "end", "find", "match", "query", "next", "select", "load", "cache", "debug", "show", "data", "GET", "start", "Get", "send", "call", "pull", "update", "create", "download"], "url": ["string", "path", "address", "base", "ssl", "server", "uri", "id", "resource", "feed", "http", "location", "host", "l", "URL", "key", "queue", "email", "source", "rule", "date", "connection", "str", "file", "route", "page", "ll", "href", "name", "ls", "image", "sl", "layer", "Url", "www", "ur", "f", "service", "download", "loc"], "lat": ["play", "base", "address", "id", "game", "loc", "late", "l", "length", "location", "grid", "offset", "la", "at", "live", "street", "alt", "west", "gal", "data", "out", "league", "route", "local", "las", "Lat", "home", "pos", "port", "tile", "height", "bot", "range", "distance", "width", "point"], "lon": ["val", "lag", "base", "online", "fat", "lang", "vel", "on", "lb", "number", "l", "location", "length", "off", "lan", "offset", "ino", "la", "live", "len", "level", "nl", "log", "pos", "depth", "ln", "layer", "position", "lin", "left", "range", "ng", "land", "width", "loc"], "count": ["val", "index", "total", "base", "sum", "num", "id", "n", "more", "timeout", "c", "limit", "number", "length", "all", "code", "amount", "pool", "time", "follow", "offset", "part", "type", "scroll", "load", "cache", "len", "level", "file", "Count", "size", "log", "name", "force", "age", "found", "f", "batch", "error", "list", "depth"], "req": ["temp", "rf", "cf", "http", "ref", "fit", "rt", "fail", "cp", "proc", "q", "ctr", "build", "fb", "conn", "gr", "worker", "jp", "respond", "hr", "wx", "org", "download", "qt", "server", "serv", "pub", "query", "next", "post", "cache", "pr", "r", "work", "requ", "rr", "test", "exec", "exp", "grad", "wa", "pkg", "sem", "bur", "ok", "ru", "socket", "fr", "orb", "dq", "fin", "request", "p", "io", "rob", "ver", "ur", "def", "plug", "cmd", "cur", "fe", "Request", "res", "c", "cb", "form", "client", "rb", "resp", "https", "check", "require", "sq", "rx", "call", "ctx", "pull", "tr", "cook", "ext", "conf", "err", "reg", "f", "loc"], "gl": ["sel", "fe", "console", "ogl", "rg", "l", "GL", "il", "gg", "fr", "global", "pl", "cal", "el", "bs", "gel", "hl", "bg", "fl", "gb", "berg", "cm", "gold", "lc", "browser", "gall", "g", "ger", "gal", "las", "lim", "gn", "cl", "bel", "ll", "nl", "groups", "go", "img", "coll", "ml", "Gl", "sl", "rl", "gi", "gre", "ang", "lol", "ga", "bl", "ul", "gm", "fx", "list", "view", "loc"], "br": ["bh", "res", "bridge", "result", "lr", "fr", "dr", "mr", "bro", "ler", "arr", "BR", "bar", "rb", "reader", "pr", "ctr", "browser", "buf", "r", "ch", "Br", "str", "div", "body", "gr", "brush", "io", "yr", "cr", "tr", "bc", "stream", "hr", "b", "sp", "bl", "err", "ber", "ar", "sr", "img"], "line": ["letter", "string", "sel", "lo", "base", "lf", "entry", "LINE", "ge", "end", "l", "look", "jo", "el", "fr", "co", "ine", "char", "key", "ino", "sync", "rule", "source", "lines", "lc", "live", "str", "data", "file", "text", "cl", "le", "page", "nl", "log", "row", "inline", "style", "ne", "name", "e", "pos", "cle", "word", "link", "sl", "pe", "unit", "comment", "lin", "Line", "bl", "block", "code", "cell"]}}
{"id1": "6190356", "id2": "19134229", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForOldM3", " hashPasswordForOldMD3", " hashPasswordForOldmd3", " hashPasswordForNewM5", " hashPasswordForOldmd5", " hashPasswordForOldM512", " hashPasswordForNewM3", " hashPasswordForOldMC5", " hashPasswordForOldM4", " hashPasswordForOldMD4", " hashPasswordForOldMC3", " hashPasswordForOldM5", " hashPasswordForNewMD5", " hashPasswordForOldmd4", " hashPasswordForNewM512", " hashPasswordForNewMD3", " hashPasswordForNewMD4", " hashPasswordForOldmd512", " hashPasswordForNewM4", " hashPasswordForOldMD512", " hashPasswordForOldMC512", " hashPasswordForNewMD512", " hashPasswordForOldMC4"], "password": [" Password", "string", "path", "address", "buffer", "input", "token", "username", "message", "result", "account", "wd", "pass", "key", "pattern", "content", " passwords", "Password", "PASS", "seed", "value", "sword", "data", "text", "p", "encrypted", "name", "array", "word", "wallet", "auth", "secret", "words", "padding", "pad", "crypt", "phrase", "hash", "code"], "md": ["um", "gd", "mag", "bd", "df", "clean", "od", "vm", "Cmd", "amd", "managed", "mo", "ind", "ma", "am", "meta", "wd", "MD", "dc", " MD", "rpm", "mb", "mt", "mac", "d", "mp", "hd", "pm", "cmd", "mm", "metadata", "cd", "dig", "m", "hm", "km", "dm", "grad", "mand", "mc", "di", "nm", "mod", "vd", "rm", "f", "pd", "dd", "pg"], "messageDigest": ["MessageDigester", "messageAddester", "MessageDigse", "messageDigse", "messagedigest", "messageModse", "MessageModse", "messageAddest", "messagedigester", "MessageDigEST", "messageDse", "messageDigester", "MessageModEST", "messagedigEST", "MessageAddEST", "messagedigse", " messageDigester", " messageModests", "messageDEST", " messageModest", "messageModests", "messageModester", "messageDest", "messageModest", "MessageAddester", "messageAddEST", " messageDigests", "MessageModester", "messageDester", "messagedigests", "MessageAddse", " messageModester", "messageModEST", "messageDigEST", "MessageAddest", "MessageModest", "messageAddse", "MessageDigest", " messageModEST", "messageDigests", "messageAddests", " messageDigEST"], "hexString": ["tempStr", "transformString", "hexBuffer", " hexFile", "octStr", "hexArray", "hexSection", "hexstring", " hexStr", "transformStr", "hexFile", "transformArray", " hexBuffer", "stringString", "stringArray", " hexArray", " hexFunction", "sumStr", " hexSection", "octBuffer", "hashSection", "crossString", "crossFunction", "tempString", "sumstring", "sumFile", "hexStr", "hashString", "hexFunction", "octArray", "crossstring", "hashService", " hexService", "hashArray", " hexstring", "octString", "tempFile", "sumString", "stringSection", "stringService", "tempstring", "tempFunction", "hexService", "transformBuffer", "crossStr"], "i": ["index", "info", "id", "n", "pi", "uri", "slice", "c", "j", "fi", "ri", "o", "l", "length", "s", "si", "ui", "ii", "qi", "ti", "ji", "d", "phi", "r", "li", "h", "x", "p", "ip", "bi", "u", "oi", "ai", "e", "I", "ci", "t", "m", "io", "xi", "di", "a", "k", "v", "b", "multi", "f", "ix"], "hex": ["letter", "string", "path", "sex", "temp", "ex", "cmp", "oct", "http", " Hex", "character", "json", "result", "length", "host", "shift", "digit", "char", "alpha", "pattern", "raw", "form", "comp", "utf", "rh", "cache", "binary", "buff", "serial", "str", "default", "none", "data", "text", "he", "rex", "h", "ip", "pex", "null", "lit", "format", "hello", "bit", "exp", "pack", "transform", "full", "hack", "pixel", "cookie", "nexus", "zero", "batch", "hash", "orig"]}}
{"id1": "13981689", "id2": "3536332", "code1": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"md5Hash": ["md5String", "md512hash", "md6hash", "md5Sum", " MD6Hash", "md6Hash", " MD6Sum", "md512String", "md4Hash", "md5hash", " MD6hash", " MD5hash", "md4String", " MD5Sum", "md512Hash", " MD5String", " MD6String", "md4Sum", "md512Sum", "md6Sum", "md6String", " MD5Hash", "md4hash"], "src": ["string", "info", "ssl", "input", "sc", "uri", "Source", "rc", "dest", "s", "length", "URL", "inst", "SOURCE", "gb", "Str", "rb", "source", "lib", "sb", "buf", "str", "RGB", "SourceFile", "data", "file", "text", "ruby", "SB", "tmp", "ptr", "href", "msg", "Bytes", "RC", "sup", "sl", "buster", "bytes", "Url", " source", "obj", "b", "inf", "img"], "md": ["editor", "gd", "mag", "bd", "od", "amd", "mo", "ind", "kg", "ma", "wd", "MD", " MD", "ms", "ad", "material", "mb", "mac", "d", "mp", "hd", "rod", "pm", "pd", "mm", "metadata", "cd", "dig", "m", "km", "dm", "ss", "db", "di", "mc", "mand", "mod", "vd", "rm", "mad", "f", "cmd", "dd", "hash", "code"]}}
{"id1": "9954926", "id2": "12236729", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"simulate": ["Simulator", "animure", "animulate", "simulation", "Simure", "animulation", "Simulation", "imulate", "simure", "imure", "imulation", "simulator", "Simulate", "animulator", "imulator"], "out": ["base", "temp", "output", "resource", "pre", "plain", "net", "window", "bin", "in", "raw", "lib", "tmp", "gen", "conn", "Out", "comment", "obj", "external", "point", "string", "info", "buffer", "outer", "ex", "sys", "server", "lock", "report", "result", "post", "part", "cache", "up", "w", "parent", "store", "page", "object", "again", "name", "exp", "full", "flush", "list", "con", "outs", "o", "write", "line", "flow", "co", "exit", "session", "group", "null", "io", "writer", "word", "state", "cli", "error", "view", "copy", "user", "now", "OUT", "table", "pool", "key", "client", "down", "data", "log", "db", "prefix", "dump", "err"], "file": ["path", "base", "buffer", "handler", "loader", "address", "fe", "output", "resource", "ile", "feed", "report", "message", "filename", "socket", "fp", "l", "line", "in", "File", "queue", "source", "cache", "rule", "book", "connection", "FILE", "collection", "data", "le", "page", "log", "name", "port", "full", "files", "url", "pe", "stream", "unit", "b", "f"], "obtainUserReputationRequest": ["obtainUserReputedrequest", "obtainUserReputationrequest", "obtainUserComputationEntry", "obtainUserRepigrationQuery", "obtainUserReputationInput", "obtainUserRepurityEntry", "obtainUserRepulationRequest", "obtainUserRelentionrequest", "obtainUserComputeInfo", "obtainUserRepulationResponse", "obtainUserReputeInput", "obtainUserAnnigrationRequest", "obtainUserRepulationInput", "obtainUserReputationEntry", "obtainUserReputionrequest", "obtainUserReputationQuery", "obtainUserComputeEntry", "obtainUserRepigrationRequest", "obtainUserRepigrationrequest", "obtainUserComputeInput", "obtainUserRepentionResponse", "obtainUserComputeRequest", "obtainUserRelentionGrant", "obtainUserComputationInput", "obtainUserAnnutationResponse", "obtainUserRepigrationInfo", "obtainUserReputeInfo", "obtainUserRepentionrequest", "obtainUserReputablerequest", "obtainUserReputedRequest", "obtainUserRepositoryrequest", "obtainUserAnnutationRequest", "obtainUserRepositoryRequest", "obtainUserRepurationResponse", "obtainUserReputedResponse", "obtainUserRelentionRequest", "obtainUserComputationrequest", "obtainUserRepentionGrant", "obtainUserRelutationResponse", "obtainUserReputeRequest", "obtainUserComputerequest", "obtainUserComputationResponse", "obtainUserReputionRequest", "obtainUserComputationRequest", "obtainUserReputeResponse", "obtainUserRepurityResponse", "obtainUserReputeEntry", "obtainUserRelutationRequest", "obtainUserRepurityRequest", "obtainUserAnnutationGrant", "obtainUserRepurationQuery", "obtainUserAnnigrationGrant", "obtainUserReputionGrant", "obtainUserRepigrationResponse", "obtainUserAnnigrationResponse", "obtainUserReputeQuery", "obtainUserRepurityInput", "obtainUserRepurationRequest", "obtainUserRepigrationGrant", "obtainUserComputeResponse", "obtainUserAnnutationQuery", "obtainUserReputerequest", "obtainUserRelutationGrant", "obtainUserReputedGrant", "obtainUserRepositoryResponse", "obtainUserReputableResponse", "obtainUserRepurationGrant", "obtainUserRepentionRequest", "obtainUserRelentionResponse", "obtainUserReputableRequest", "obtainUserReputeGrant", "obtainUserRepulationEntry", "obtainUserReputationGrant", "obtainUserReputionResponse", "obtainUserComputationInfo", "obtainUserRepositoryInfo", "obtainUserAnnigrationQuery", "obtainUserReputationInfo", "obtainUserRelutationrequest"], "obtainUserReputationResponse": ["obtainUserReputeRequest", "obtainUserReputeResp", "obtainUserRepurationResp", "obtainUserRepositoryResponse", "obtainUserExputationRequest", "obtainUserReputeResponse", "obtainUserExpositoryResponse", "obtainUserExputationResponse", "obtainUserExpositoryResp", "obtainUserExputationResp", "obtainUserRepositoryResp", "obtainUserRepositoryRequest", "obtainUserRepurationRequest", "obtainUserRepurationResponse", "obtainUserReputationResp", "obtainUserExpositoryRequest"], "rateUserRequest": ["rateUsageForce", "rateLineCustomer", "gradeLinerequest", "rateServiceFunction", "RateFileQUEST", "rateFileCommand", "rateuserQUEST", "rateUrequest", "rateFileUser", "ratedUsagerequest", "rateUSERForce", "gradeUserRequest", "RateUserQUEST", "rateApplicationQuery", "rateUSERrequest", "rateWordRequest", "rateUError", "rateURequest", "rateMachinerequest", "rateUCustomer", " rateUserQUEST", " rateuserRequest", "rateClientGrant", "rateFileQUEST", "rateUserReturn", "rateUsageUser", "RateUserrequest", "rateLineRequest", "rateHumanResult", "rateUsageReturn", " rateUserrequest", "rateCustomerForce", "featureMachinerequest", "rateClientrequest", "rateWordError", "issueCustomerForce", "rateFileResult", "rateUserVersion", "ratedUserFunction", "rateUsagerequest", "rateServiceCommand", "rateLineResponse", "rateUSERQUEST", "rateFileResponse", "rateLineQuery", "rateUsRequest", " rateApplicationResponse", "featureUserVersion", "rateUserQuery", "rateApplicationUser", "rateUserForce", "rateUserResult", "ratePostrequest", "rateMachineRequest", " rateUserUser", "rateFileRequest", "rateUsageResponse", "rateMachineVersion", "ratedUserQUEST", "issueUserQUEST", "ratedFileCommand", "ratedFileRequest", "rateUForce", "rateLineQUEST", "ratedFileQuery", "ratePostResponse", "ratedUsageRequest", "rateWordCustomer", "rateMachineResult", "RateFilerequest", "rateServiceRequest", "rateFileFunction", "issueUserReturn", "rateuserResponse", "rateFilerequest", " rateuserResponse", "ratedUserQuery", " rateApplicationUser", "rateuserRequest", "rateWordrequest", "gradeLineRequest", "rateUSERRequest", "ratedUsageQUEST", "gradeUserrequest", "rateWordQuery", "rateLineGrant", " rateuserQUEST", "issueUserRequest", "RateUserResponse", "rateClientRequest", "gradeUserError", "issueCustomerRequest", "rateUFunction", "rateUserQUEST", "rateUserFunction", "ratedFileFunction", "rateApplicationRequest", "ratedUserRequest", "RateUserRequest", "featureUserrequest", " rateUserQuery", "featureUserRequest", " rateClientRequest", "rateLinerequest", "rateUResponse", "ratedUsageQuery", "rateUserUser", " rateApplicationRequest", " rateClientGrant", "ratePostRequest", "rateUsReturn", "rateUQuery", "rateFileVersion", "ratedUserForce", "issueCustomerReturn", "rateUsageQUEST", "rateLineError", "rateUQUEST", "rateUserrequest", "rateUserGrant", " rateUserGrant", "rateUserError", "rateCustomerQUEST", "issueUserForce", "rateFileQuery", "rateHumanrequest", "rateUCommand", "featureUserResult", "featureMachineRequest", "gradeUserCustomer", "gradeLineError", "featureMachineVersion", " rateuserrequest", "rateHumanRequest", "rateUserCustomer", "RateFileRequest", "rateUsageRequest", "rateUsForce", "rateUserCommand", " rateClientrequest", "ratedUserrequest", "rateUsageQuery", "rateApplicationResponse", "rateHumanVersion", "gradeLineCustomer", "rateCustomerReturn", "ratedUserCommand", " rateApplicationQuery", "rateUsageGrant", "RateFileResponse", "rateServiceQuery", "featureMachineResult", "ratePostQUEST", "issueCustomerQUEST", "rateUsQUEST", "ratedUsageForce", "rateCustomerRequest", "rateuserrequest"], "rateUserResponse": ["rateCustomStatus", "rateuserData", " rateFileResult", " rateUserReference", "rateClientResponse", "rateCustomerReference", "rateUsersResponse", "RateTimeStatus", "rateTimeResp", "rateuserresponse", "rateUsersStatus", "rateUserResp", "rateApplicationResp", "rateUsersRequest", "rateFileResult", "rateUserReply", "rateFileResponse", "rateCustomerResponse", " rateApplicationResponse", "rateuserResp", "rateTimeCustomer", " rateUResponse", "rateUserResult", "rateUsersResource", "rateClientResp", "RateTimeResp", "RateTimeResponse", "rateUResp", "rateFileStatus", " rateUserReply", "RateUserCustomer", "rateUserData", "rateuserReference", "rateuserResponse", " rateUReply", " rateFileResponse", "rateClientCustomer", "rateFileresponse", " rateUserresponse", "rateCustomerResp", " rateUserData", "RateUserResponse", "rateCustomResp", "RateUserRequest", " rateApplicationData", "rateTimeStatus", "rateuserReply", " rateUserResp", "rateCustomerResource", "rateUResponse", "RateUserResource", "rateUsersResp", "rateApplicationReference", " rateFileResp", "rateCustomResponse", "rateUresponse", " rateUResp", "rateFileResp", "rateUserResource", " rateApplicationResp", " rateApplicationReference", "rateUserresponse", " rateUresponse", "rateTimeResponse", " rateUserStatus", "rateCustomerData", "RateUserStatus", "rateUserStatus", "rateUserCustomer", "rateUserReference", "rateApplicationResponse", "rateUReply", "RateUserResp", "rateFileReply", " rateUserResult", "rateClientStatus", "rateCustomCustomer", "rateApplicationData", "rateuserResult", "rateuserStatus", "rateUsersResult", "RateTimeCustomer", "rateCustomerRequest", " rateFileStatus"], "fis": ["bis", "Fris", "sfis", " fris", " fiss", "fris", "biss", "sfIs", "sfiss", " fIs", "FIs", "bris", "Fis", "bIs", "fIs", "fiss", "Fiss", "sfris"], "br": ["buffer", "wr", "res", "bridge", "ref", "result", "lr", "bs", "fr", "dr", "ler", "bro", "arr", "fin", " bio", "BR", " tr", " fr", "reader", "rb", "pr", "browser", "buf", "r", "ch", "Br", "str", "ob", "body", "bed", "gr", "brush", "io", "cr", "tr", "bc", "bp", "hr", "b", "sp", "err", "bl", "sw", "ber", "Reader"], "call": ["play", "calling", "string", "info", "roll", "buffer", "push", "cu", "input", "sc", "output", "response", "called", "claim", "user", "ck", "message", "ack", "c", "result", "loc", "line", "co", "query", "flow", "throw", "type", "use", "load", "doc", "charge", "str", "cat", "ell", "work", "data", "text", "body", "phone", "check", "cl", "request", "invoke", "msg", "name", "e", "url", "fax", "Call", "address", "comment", "Line", "create", "contact", "xml", "cod", "f", "callback", "voice", "code", "cell"]}}
{"id1": "17538992", "id2": "530882", "code1": "    public static boolean check(String urlStr) {\n        try {\n            URL url = new URL(urlStr);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            urlConnection.setConnectTimeout(2000);\n            urlConnection.getContent();\n        } catch (Exception e) {\n            logger.error(\"There is no internet connection\", e);\n            return false;\n        }\n        return true;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"check": ["info", "close", "resource", "checks", "ok", "find", "run", "match", " checking", "checking", "load", "login", " Check", "work", "CHECK", "get", "test", "complete", "start", "exec", " checks", "call", "link", "update", "Check", "process", "checked"], "urlStr": ["httpText", "urlSTR", "URLName", " urlString", "httpName", "URLStr", " urlstr", "httpstr", " urlName", "urlName", "resourceText", "urlString", "httpString", "resourcestr", "URLString", " urlSTR", "urlstr", "httpStr", "urlText", "resourceString", " urlText", "URLSTR", "httpSTR", "resourceStr"], "url": ["impl", "string", "base", "ssl", "address", "server", "resource", "uri", "feed", "user", "http", "c", "l", "host", "URL", "client", "connection", "browser", "str", "r", "build", "open", "config", "data", "channel", "page", "object", "ll", "web", "log", "conn", "ls", " URL", "image", "blog", "sl", "layer", "Url", "www", "b", "obj", "f"], "urlConnection": [" urlC", "Urlconnection", "URLContainer", "httpconnection", "newConnection", "urlSocket", "urlC", "httpconn", "httpConnection", " urlConfig", "UrlConfig", " urlconnection", "URLUrl", "httpContainer", "sslconnection", " urlSocket", "newUrl", "UrlConnection", "urlUrl", "URLConnection", " urlconn", "urlContainer", "httpC", "urlconnection", "URLconnection", "httpSocket", "sslconn", "urlConfig", "newContainer", "UrlSocket", "newconnection", "httpUrl", "sslConnection", "urlconn", "httpConfig", "sslC"]}}
{"id1": "15129155", "id2": "13657103", "code1": "    public List<String> extractUrlList(String url) throws IOException, XPathExpressionException {\n        LinkedList<String> list = new LinkedList<String>();\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        Tidy tidy = new Tidy();\n        tidy.setErrout(new NullPrintWriter());\n        Document doc = tidy.parseDOM(conn.getInputStream(), null);\n        int len = conn.getContentLength();\n        if (len <= 0) len = 32000;\n        ByteArrayOutputStream bout = new ByteArrayOutputStream(len);\n        PrintStream ps = new PrintStream(bout);\n        tidy.pprint(doc, ps);\n        ps.flush();\n        String content = bout.toString();\n        Pattern p = Pattern.compile(\"(http://[\\\\w\\\\\\\\\\\\./=&?;-]+)\");\n        Matcher m = p.matcher(content);\n        while (m.find()) {\n            list.add(m.group());\n        }\n        return list;\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 0, "substitutes": {"extractUrlList": ["extractionUrlList", "extractLocationList", "extractionURLList", "extractTextObject", "extractUrlCollection", "extractionUrlCollection", "extractURLList", "extractUrllist", "extractLocationlist", "extractUrlObject", "extractionURLObject", "extractLocationCollection", "extractTextlist", "extractionUrllist", "extractionURLlist", "extractURLlist", "extractionURLCollection", "extractTextCollection", "extractLocationObject", "extractURLCollection", "extractURLObject", "extractTextList", "extractionUrlObject"], "url": ["string", "path", "address", "base", "ssl", "i", "input", "server", "uri", "resource", "feed", "http", "filename", "html", "l", "location", "host", "URL", "email", "source", "connection", "data", "file", "out", "src", "text", "page", "ll", "href", "name", "image", "sl", "Url", "www", "ur", "obj", "xml", "f", "download"], "list": ["val", "string", "rest", "base", "i", "map", "table", "result", "l", "set", "pool", "all", "code", "detail", "queue", "iter", "arr", "dl", "loop", "LIST", "part", "type", "load", "member", "lc", "live", "item", "str", "listed", "g", "li", "out", "ist", "cl", "ll", "x", "test", "lists", "msg", "coll", "tree", "dict", "e", "chain", "array", "parse", "we", "bl", "left", "batch"], "conn": ["Connection", "Conn", "server", "n", "cf", "enc", "rc", "http", "con", "c", "pub", "cb", "Con", "host", "rt", "dc", "nc", "client", "sync", "nt", "cp", "session", "lc", "sb", "resp", "ct", "connection", "ch", "g", "open", "conv", "rec", "po", "exec", "dn", "ann", "db", "jp", "mc", "ctx", "conf", "cn", "connect", "cli", "cmd", "loc"], "tidy": ["ttrie", "Triage", "ttidi", "Tidy", " trawl", "ttriage", "tick", "ttickle", "Try", "priage", "Tickle", "tractor", "ttidy", "potally", "Trie", "pickle", "trawl", "pidi", "ntickle", "matrawl", "pick", "Totally", "trie", " totally", "pidy", "tickle", "matry", "triage", "matickle", " tickle", "Tick", "ttractor", "totally", " tidi", "Trawl", " triage", "ntidy", "practor", "matidy", " tick", " tractor", "ntriage", "ntrie", "tidi"], "doc": ["val", "index", "id", "n", "Doc", "df", "docs", "document", "c", "DOC", "html", "l", "dc", "d", "up", "oc", "str", "div", "md", "data", "file", "g", "body", "h", "po", "coll", "dict", "pos", "exp", "dec", "db", "di", "obj", "sp", "dom", "xml", "f", "api"], "len": ["val", "lt", "base", "num", "lang", "n", "lf", "Len", "lp", "cap", "limit", "loc", "html", "l", "length", "line", "el", "bin", "lan", "ld", "en", "elt", "fin", "dl", "fl", "part", "lc", "li", "lim", "size", "ll", "lit", "ls", "ann", "pos", " length", "sl", "ln", " lang", "span", "lin", "seq", " Len", "count", "f", "lon"], "bout": ["boff", "aouts", "brOUT", "bbout", "mbin", " bin", "bin", "brin", " bouts", "Bstream", "Bin", "bbOUT", "mbouts", "Bout", " bOUT", "bouts", "brout", "bOUT", "BOUT", "aout", "ain", "Bouts", "bbouts", "mbstream", "astream", "mbout", "bboff", "bbin", "Boff", "bstream", "broff"], "ps": ["pps", "pres", "fs", "pi", "pse", "Ps", "ks", "py", "ns", "qs", "bs", "s", "pl", "ms", "rs", "pr", "pp", "proxy", "ops", "pers", "mp", "par", "eps", "gs", "out", "ips", "ep", "aps", "ts", "vs", "po", "ss", "pa", "pe", "sp", "ds", "cs", "os", "pas", "PS"], "content": ["string", "path", "temp", "input", "output", "response", "resource", "document", "message", "c", "cont", "con", "result", "html", "Content", "raw", "expression", "source", "load", "cover", "activity", "value", "connection", "media", "model", "str", "section", "config", "data", "text", "body", "work", "page", "ontent", "word", "ext", "comment", "xml", "code"], "p": ["P", "i", "n", "pi", "op", "lp", "c", "py", "per", "l", "s", "pattern", "comp", "ap", "cp", "d", "pr", "pp", "q", "mp", "r", "g", "parser", "pro", "rep", "ip", "h", "po", "tp", "e", "t", "jp", "pa", "pe", "b", "sp", "f"], "m": ["om", "tm", "mu", "um", "n", "vm", "M", "c", "ma", "o", "l", "am", "match", "line", "wm", "mr", "perm", "ms", "rem", "sm", "cm", "part", "source", "d", "mp", "pm", "media", "r", "machine", "md", "body", "mm", "h", "mi", "u", "fm", "hm", "dm", "mc", "em", "b", "v", "me", "bm", "rm", "gm", "im"]}}
{"id1": "16550855", "id2": "19549577", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 1, "substitutes": {"readPage": ["readPages", "openpage", "readFile", "openPages", "getFile", "findPage", "getPages", "getPage", "readpage", "findPages", "openFile", "getpage", "findFile", "openPage", "findpage"], "ignoreComments": ["useComments", "includeTags", "includeComments", " ignoreTags", "oreComment", "ignorecomments", "orecomments", "ignoreComment", "oreQuotes", "useTags", " ignoreComment", "useQuotes", "ignoreQuotes", "usecomments", "includeComment", "oreComments", " ignorecomments", "oreTags", "includecomments", " ignoreQuotes", "ignoreTags"], "in": ["IN", "index", "ssl", "buffer", "i", "input", "id", "token", "loader", "user", "ini", "gin", "on", "http", "into", "con", "c", "inner", "socket", "version", "as", "ins", "s", "bin", "is", "client", "reader", "source", "login", "connection", "min", "inside", "r", "inc", "data", "file", "out", "h", "init", "rec", "again", "e", "m", "image", "t", "re", "isin", "it", "In", "nin", "kin", "url", "stream", "lin", "b", "err", "inn", "f", "win", "din"], "inputLine": ["InputText", "incLook", "incL", "InputLook", "requestRow", "inputName", "requestline", "pullLine", "installline", "inputRow", " inputRow", "requestLink", " inputCell", "incLine", "ifLook", "ifline", "InputName", "pullline", "installLook", "imageLine", " inputText", " inputLook", "imageL", "InputLine", "rawLine", "Inputline", "pullLink", "requestLine", "InputLink", "incline", "rawL", "ifLine", " inputName", "ifCo", " inputCo", "inputL", " inputPage", "imageline", "commentline", " inputline", "rawName", "requestLook", "installL", "pullRow", "InputL", "inputCo", "commentLine", "inputCell", "inputText", "inputline", "rawLink", "InputCell", "requestCo", "inputPage", "rawText", "inputLook", " inputL", "commentCell", " inputLink", "installLine", "imageLook", "inputLink", "rawline", "InputPage", "commentPage"], "html": ["article", "base", "temp", "css", "HTML", "output", "bf", "atom", "embed", "gh", "http", "message", "json", "plain", "ht", "result", "hot", "ui", "detail", "strong", "high", "htm", "content", "part", "wrap", "links", "doc", "tml", "source", "live", "show", "str", "data", "attr", "body", "flat", "amp", "war", "web", "h", "page", "flash", "inline", "format", "msg", "title", "template", "rss", "header", "js", "text", "home", "blog", "link", "details", "dump", "url", "tt", "www", "summary", "xml", "tf", "bsp", "f", "hard", "api", "view", "img"]}}
{"id1": "5836744", "id2": "22442270", "code1": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"read": ["index", "close", "input", "Read", "execute", "copy", "resource", "reading", "add", "find", "run", "write", "next", "reader", "load", "source", "open", "data", "check", "get", "start", "exec", "send", "call", "readable", "update", "stream", "create", "parse", "include", "connect", "wait", "process", "READ", "transfer", "error", "download"], "name": ["index", "path", "string", "NAME", "info", "class", "address", "base", "id", "n", "resource", "uri", "filename", "end", "host", "ame", "code", "time", "key", "content", "client", "part", "type", "source", "no", "value", "connection", "str", "default", "alias", "parent", "data", "file", "names", "body", "object", "size", "x", "root", "null", "style", "Name", "e", "image", "start", "action", "word", "prefix", "stream", "f", "named", "from"], "status": ["index", "ssl", "error", "base", "id", "server", "response", "continue", "gc", "json", "site", "result", "code", "si", "active", "fail", "Status", "exit", "content", "sync", "STAT", "score", "stat", "source", "type", "rate", "use", "sb", "login", "value", "stats", "size", "complete", "msg", "header", "success", "full", "uses", "update", "speed", "wait", "stage", "state", "width", "cli", "method", "service", "api"], "url": ["string", "path", "address", "base", "ssl", "buffer", "server", "uri", "id", "feed", "user", "http", "rel", "l", "host", "URL", "source", "browser", "ob", "open", "data", "file", "channel", "web", "object", "bel", "ls", "ball", "image", "blog", "sl", "hub", "Url", "www", "stream", "b", "obj", "f", "plug", "gl"], "in": ["IN", "index", "ssl", "buffer", "i", "input", "id", "resource", "token", "inas", "cf", "ini", "gin", "version", "socket", "as", "inner", "ins", "el", "bin", "pass", "fr", "part", "session", "source", "reader", "binary", "login", "connection", "r", "inc", "config", "out", "get", "init", "conn", "again", "m", "image", "isin", "In", "nin", "fd", "stream", "inn", "f", "din"]}}
{"id1": "11952735", "id2": "13063241", "code1": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["downloadStream", " copyfile", "CopyFile", "copyfile", " copyStream", "CopyStream", "CopyFolder", "copyStream", "copyFolder", " copyFolder", "Copyfile", "downloadfile", "downloadFolder", "downloadFile"], "sourceName": ["ourceAddress", "targetName", " sourceString", "SourceAddress", "Sourcename", " sourceAddress", "targetFile", "sourceFile", "targetname", "SourceFile", "SourceString", "destFile", "ourceString", "sourcename", " sourceNames", "ourceNames", "ourceName", "sourceNames", "targetChannel", "SourceChannel", "SourceName", "sourceString", "sourceAddress", "SourceNames", "destname"], "destName": ["tempname", "tempName", "inationname", "DestPath", "inationPath", "tempPath", "DestNAME", "slaveNAME", "resultNAME", "Destname", "destPath", "inationNAME", "outerName", "DestName", "outerNAME", "inationName", "tempNAME", "slaveName", "resultName", "destNAME", "destname"], "sourceChannel": [" sourceGate", "sourceContext", " sourcechannel", "inputChannel", "srcchannel", "ourceStream", "sourcechannel", "ourceChan", "inputchannel", "parentName", "sourceManager", "ourceConnection", "srcStream", " sourceManager", "Sourcechannel", "destChan", " sourceSocket", "ourceGate", "singlechannel", "SourceStream", " sourceStream", "sourceChan", "ourceSocket", "singleConnection", " sourceChan", "destStream", "sourceConnection", "srcSocket", "ourceManager", "destchannel", "parentContext", "srcContext", "parentchannel", "inputStream", "singleChannel", "ourcechannel", "srcManager", "ourceContext", "parentChannel", "srcChannel", "sourceStream", "ourceChannel", "singleStream", "sourceSocket", "SourceChan", "ourceName", "inputGate", "srcChan", "SourceChannel", "sourceGate", " sourceConnection", "srcName"], "destChannel": ["destroychannel", "destBody", "destroyChan", " destAlias", " destinationAlias", " destConfig", "Destchannel", "DestConfig", "destAlias", "sourcechannel", "DestConnection", "destConfig", "destChan", " destConnection", "targetChan", " destinationchannel", "targetConnection", "DestChannel", "sourceChan", " destinationChan", "destroyChannel", "DestAlias", "sourceConnection", "destchannel", " destinationConfig", " destChan", "destroyBody", " destchannel", "DestBody", " destinationChannel", "targetchannel", "destConnection", "targetChannel", " destinationBody", " destinationConnection", "DestChan"], "wasOk": ["wasAz", "casok", " wasNone", "successfullyCry", "wasOK", "wereNone", "wasCry", "successfullyObj", "wereOK", "wasNone", " wasok", "wasok", "wereAz", "wasObj", " wasAz", "successfullyOk", " wasCry", "wereok", "WasOK", "successfullyNone", "wereObj", " wasOK", "WasNone", "wereOk", " wasObj", "wereCry", "WasOk", "casOk", "casAz", "casOK"]}}
{"id1": "20375440", "id2": "23620712", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "srcFile": [" srcfile", "sourceDir", "rcFile", " srcDir", "destfile", "srcFiles", "rcfile", "sourcePath", "rcPath", "sourceFile", "rcFiles", "sourceFiles", "destFiles", " srcFiles", "srcPath", "destDir", "sourcefile", "srcDir", " srcPath", "srcfile"], "destFile": ["DestPath", "destfile", "DestFile", "restFile", "tempPath", "targetPlace", "targetFiles", " destFiles", "targetfile", "destFiles", "restPlace", "DestPlace", "DestFiles", " destfile", " destPath", "restfile", "destPath", "Destfile", "restFiles", "tempfile", "tempFile", "tempFiles", "destPlace", "targetFile"], "src": ["impl", "ssl", "sel", "loader", "sc", "input", "cmp", "sys", "self", "rc", "slice", "cb", "sub", "loc", "bs", "ources", "inst", "func", "in", "rs", "req", "client", "gb", "sync", "rb", "source", "ws", "proc", "sb", "construct", "stat", "reader", "dist", "upload", "config", "conv", "sq", "conn", "start", "sup", "sl", "secure", "ctx", "url", "ser", "stream", "cur", "sr", "sec", "RC", "img"], "dest": ["path", "rest", "ssl", "class", "temp", "output", "slave", "end", "result", "destroy", "trans", "ui", "dc", "usr", " Dest", "std", "comb", "cdn", "cp", "source", "d", "proc", "wb", "ws", "thin", "wh", "target", "dir", "dist", "div", "de", "Dest", "tmp", "out", "des", "null", "test", "desc", "dev", "writer", "home", "opt", "sup", "stream", "obj", "ds", "dat", "this", "transform", "img"], "buffer": ["string", "info", "capacity", "address", "Buffer", "input", "uffer", "copy", "feed", "base", "message", "slice", "number", "result", "limit", "length", "write", "bin", "memory", "key", "queue", "iter", "raw", "offset", "source", "cache", "reader", "buff", "value", "buf", "wave", "data", "channel", "request", "size", "row", "null", "header", "writer", "bytes", "position", "flush", "layer", "b", "reference", "block", "transfer", "batch"], "read": ["play", "index", "close", "i", "input", "Read", "feed", "id", "n", "reading", "copy", "ok", "add", "ind", "slice", "end", "find", "number", "run", "limit", "length", "se", "write", "reads", "ride", "pass", "key", "sleep", "iter", "next", "raw", "sync", "select", "allow", "reader", "load", "d", "use", "no", "not", "show", "default", "build", "work", "open", "data", "level", "text", "seek", "check", "pick", "ip", "x", "get", "size", "fill", "start", "exec", "send", "skip", "k", "parse", "shape", "b", "connect", "create", "wait", "count", "READ", "block"]}}
{"id1": "62362", "id2": "3801655", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 1, "substitutes": {"convert": ["CONverting", "subverting", "Conversion", "oconversion", "oconverting", "Converting", "CONversion", "unversion", "CONvert", "conversion", "CONception", "oconverted", " deconverted", "converting", "CONverted", "subvert", "oconvert", "Conception", "unvert", "converted", " deconverting", "subversion", "Converted", "unception", "unverted", "subverted", " deconversion", "conception", "Convert", " deconvert"], "src": ["impl", "string", "path", "sel", "ssl", "sin", "input", "sc", "uri", "resource", "sys", "spec", "rc", "Source", "video", "cmp", "username", "filename", "ref", "slice", "cb", "fp", "fn", "s", "prot", "code", "inst", "feat", "cpp", "req", "gb", "back", "source", "reader", "load", "proc", "sb", "rb", "sit", "buf", "component", "dist", "upload", "SourceFile", "config", "file", "tmp", "Dest", "supp", "attr", "img", "href", "storage", "name", "sth", "gz", "RC", "rl", "ctx", "secure", "url", "scene", "stream", "obj", "st", "stage", "sn", "ource", "download", "loc"], "dest": ["path", "class", "temp", " dst", "cont", "fn", "bin", "dc", "std", "txt", "source", "dir", "lib", "target", "dist", "tmp", "Dest", "null", "test", "home", "di", "obj", " destination", "dat", "disk", "orig", "img"], "in": ["IN", "val", "pin", "i", "input", "ex", "n", "inas", "ini", "as", "ins", "bin", "pass", "is", "reader", "d", "source", "doc", "up", "login", "r", "inc", "data", "file", "io", "t", "isin", "In", "a", "stream", "err", "inn", "ps", "f", "inf", "win", "din"], "p": ["P", "i", "pi", "op", "wp", "pre", "lp", "per", "py", "c", "j", "fp", "o", "l", "s", "pb", "cop", "part", "cp", "d", "pr", "pp", "pm", "r", "g", "parser", "h", "np", "po", "tp", "m", "e", "t", "pc", "jp", "pa", "bp", "pe", "b", "sp", "v", "ps", "f", "pd", "pg"], "ds": ["services", "uds", "ays", "docs", "ants", "dos", "s", "ins", "dp", " DS", "parts", "points", "gs", "els", " props", "des", "ts", "js", "utils", "ths", "ys", "gd", "sys", "df", "lp", "bs", "dc", " ps", "dt", "sync", "lines", "eps", "vs", "ges", "amps", "ipes", "pd", "dd", "sts", "DS", "cons", "ks", "ns", "qs", "ld", "hs", "d", "dist", "ans", "ads", "xs", "models", "plugins", "groups", "tests", "ss", "di", "os", "posts", "styles", "rs", "dl", "tools", "ded", "ups", "data", "vals", "scripts", "Ds", "ls", "obs", "dm", "db", "ils", "nas", "dates", "da", "cs", "words", "dds", "ps", "dat", "icks", " sd"], "format": ["letter", "string", "path", "class", "handler", "spec", "filename", "act", "version", "table", "fp", "fn", "host", "tag", "record", "layout", "feat", "magic", "Format", "pattern", "form", "filter", "at", "type", "source", "part", "model", "parser", "config", "data", "file", "sche", "struct", "ant", "language", "style", "plugin", "template", "name", "frame", "t", "function", "prefix", "fd", "nat", "url", "unit", "atter", "f", "scale", "api"], "hasPixelData": ["hasPixeldata", "showsPixelDATA", "hasPixelDATA", "hasPicturedata", "hasByteSize", "hasByteDATA", "hasByteData", "haspixelData", "hasPixelStyle", " hasPixelSize", "showsByteDATA", "hasPictureSize", " hasPixeldata", "haspixeldata", "showsBytedata", "hasPictureData", "haspixelSize", "showsByteData", "showsPixelData", "showsByteStyle", "hasPixelSize", "hasByteStyle", "showsPixelStyle", "hasBytedata", "showsPixeldata"], "inflate": ["inadequating", "insflode", "insvenating", "inffated", "Inflation", "InFlation", "inflating", "Inflated", "inflATE", "InFlace", "insvenate", "inadequode", "InFlated", "insflate", "infolATE", "infface", "invenode", "InFlate", "inffation", "inflated", "inFlation", "infolode", "infloace", "insvenATE", "infloate", "invenATE", "inFlate", "inadequATE", "insflATE", "infloation", "invenating", "inffate", "insvenode", "inadequate", "Inflace", "inflation", "inflode", "inFlated", "Inflate", "infolate", "inFlace", "infloated", "invenate", "infolating", "inflace", "insflating"], "pxlen": ["pxdata", "xpsize", "pxlin", "pngcount", "mxsize", "campos", "fxlen", "pxl", "pgLen", "axlen", "ppLen", "mxcount", "fxln", "pxlon", "pxln", "pcln", "pglen", "ppl", "pxlength", "ppden", "camln", "txln", "pngsize", "pxpos", "pclon", "camlen", "mxdata", "axln", "axlon", "mxlength", "mxpos", "mxlen", "xplen", "txlin", "pxden", "pxcount", "fxpos", "txlon", "pclin", "pxsize", "fxdata", "pxLen", "mxln", "xpcount", "pgl", "fxLen", "axlin", "pnglen", "xplength", "fxl", "pgden", "fxden", "pclen", "pnglength", "txlen", "pplen", "camdata"], "out": ["step", "server", "output", "copy", "sys", "user", "lock", "OUT", "inter", "outs", "line", "co", "query", "post", "session", "cache", "lib", "up", "group", "store", "parent", "work", "page", "log", "gen", "conn", "again", "Out", "io", "dump", "obj", "v", "err", "state", "pad", "cli", "error", "re", "list", "point"]}}
{"id1": "21316706", "id2": "7843322", "code1": "    @Override\n    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        if ((url == null) || (proxy == null)) {\n            throw new IllegalArgumentException(Messages.getString(\"luni.1B\"));\n        }\n        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);\n    }\n", "code2": "    public void run(IAction action) {\n        int style = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell().getStyle();\n        Shell shell = new Shell((style & SWT.MIRRORED) != 0 ? SWT.RIGHT_TO_LEFT : SWT.NONE);\n        GraphicalViewer viewer = new ScrollingGraphicalViewer();\n        viewer.createControl(shell);\n        viewer.setEditDomain(new DefaultEditDomain(null));\n        viewer.setRootEditPart(new ScalableFreeformRootEditPart());\n        viewer.setEditPartFactory(new TableEditPartFactory());\n        viewer.setContents(getContents());\n        viewer.flush();\n        int printMode = new PrintModeDialog(shell).open();\n        if (printMode == -1) return;\n        PrintDialog dialog = new PrintDialog(shell, SWT.NULL);\n        PrinterData data = dialog.open();\n        if (data != null) {\n            PrintGraphicalViewerOperation op = new PrintGraphicalViewerOperation(new Printer(data), viewer);\n            op.setPrintMode(printMode);\n            op.run(selectedFile.getName());\n        }\n    }\n", "label": 0, "substitutes": {"openConnection": ["openconnection", "createconnection", "openConnector", "initConnect", "createConnect", "createConnector", " openConnector", "openConnect", "createConnection", " openConnect", "initconnection", "initConnector", "initConnection", " openconnection"], "url": ["string", "path", "ssl", "base", "address", "loader", "server", "uri", "resource", "user", "http", "ref", "socket", "library", "lr", "l", "host", "URL", "client", "email", "source", "connection", "str", "default", "ob", "file", "channel", "web", "object", "page", "log", "null", "or", "ls", "name", "image", "io", "port", "link", "db", "sl", "layer", "Url", "f", "service"], "proxy": ["zip", "address", "ssl", "base", "server", "uri", "resource", "http", "pse", "socket", "project", "library", "instance", "child", "host", "pool", "manager", "clone", "client", "friend", "roxy", "source", "cache", "lib", "connection", "config", "parent", "web", "ip", "object", "page", "p", "io", "port", "pointer", "Proxy", "fax", "pa", "pe", " proxies", "service"]}}
{"id1": "13783898", "id2": "8747840", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFiletoFiles", "encodeFileToFiles", "encodeFiletoFile", "encodeString2File", "encodeString2Stream", "encodeFileToStream", "encodeFileFromStream", "encodeStringToStream", "encodeFileFromFile", "encodeString2String", "encodeFile2Files", "encodeStringToFile", "encodeFile2File", "encodeFileToString", "encodeString2Files", "encodeFiletoString", "encodeStringToString", "encodeFile2Stream", "encodeFiletoStream", "encodeStringToFiles", "encodeFileFromString", "encodeFileFromFiles", "encodeFile2String"], "infile": ["infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", " infp", "inputfp", "inputFile", "outfiles", " infilename", "inputfiles", "Infilename", " infiles", "outfp", "Infile", "InFile", "inputfilename", "infilename", "Infiles"], "outfile": ["newfile", "Outname", "infp", "outfilename", "outputfile", "outFile", "newname", " outFile", "infolder", " outfolder", "outputfolder", "newfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "Outfolder", " outname", "outname", "OutFile", "Outfile", "infilename", "newFile", " outfilename"], "in": ["IN", "base", "pin", "i", "input", "inas", "sin", "id", "ini", "gin", "into", "ic", "con", "inner", "as", "socket", "ins", "s", "bin", "pass", "is", "reader", "source", "thin", "login", "min", "inside", "r", "inc", "data", "rin", "vin", "init", "conn", "again", "m", "image", "re", "isin", "In", "nin", "a", "err", "b", "ac", "cin", "inn", "win", "din"], "out": ["base", "ou", "job", "ex", "output", "outer", "copy", "timeout", "on", "net", "OUT", "socket", "inner", "outs", "o", "off", "write", "bin", "co", "line", "exit", "post", "client", "sync", "session", "no", "cache", "source", "one", "up", "lib", "inc", "parent", "work", "file", "conn", "or", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "In", "err", "obj", "error", "point"], "buffer": ["address", "base", "Buffer", "input", "uffer", "feed", "server", "border", "slice", "limit", "result", "length", "write", "queue", "offset", "iter", "split", "raw", "type", "reader", "cache", "binary", "source", "seed", "buff", "value", "buf", "len", "wave", "data", "fb", "size", "bb", "null", "bytes", "layer", "flush", "url", "b", "reference", "count", "padding", "transfer", "batch"], "read": ["play", "close", "i", "input", "Read", "feed", "n", "copy", "reading", "id", "add", "ind", "slice", "current", "end", "limit", "run", "se", "find", "length", "write", "reads", "ride", "pass", "sleep", "ad", "iter", "next", "raw", "sync", " count", "select", "allow", "use", "load", "reader", " Read", "len", "seek", "work", "inc", "check", " copy", "ip", "size", "x", "get", "fill", "start", "exec", "io", "lex", "send", "tell", "_", "parse", "connect", "wait", "count", "READ", " write", " skip", "f"], "success": ["respons", "roll", "error", "path", "response", "rolling", "continue", "results", "ceed", "modified", "xx", "message", "primary", "warning", "better", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "model", "default", "open", "data", "growth", "flash", "null", "cess", "danger", "complete", "again", "status", " successful", "good", "Success", "comment", "right", "successful", "successfully", "rolled", " succ", "method", "fast", "first", "winner", "initial"]}}
{"id1": "2168610", "id2": "1508930", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "label": 0, "substitutes": {"update": ["ite", "event", "where", "index", "address", "id", "resource", "response", "replace", "timeout", "UPDATE", "add", "lock", "http", "message", "version", "current", "end", "result", "run", "patch", "set", "draw", "instance", "write", "save", "grade", "database", "updated", "sync", "handle", "use", "load", "up", "date", "connection", "diff", "value", "build", "open", "config", "inc", "text", "check", "Update", "get", "put", "delete", "insert", "complete", "edit", "name", "change", "fill", "status", "send", "apply", "family", "pull", "position", "bug", "unit", "create", "future", "range", "state", "width", "error", "view"], "o": ["ou", "online", "n", "od", "oa", "c", "mo", " O", "bo", "co", "ono", "oo", "one", "so", "ion", "connection", " object", "ob", "none", "oid", "object", "p", "conn", "or", "oi", "po", "e", "m", "t", "ao", "k", "O", "obj", "os", "f", "office", "oe"], "contact": ["event", "info", "address", "cc", "ace", "feed", "choice", "cmp", "entry", "report", "character", "act", "project", "concept", "result", "account", "cart", "match", "relation", "co", "company", "content", "form", "client", "sync", "email", "lc", "date", "connection", "charge", "model", "collection", "work", "config", "phone", "check", " Contact", "object", "control", "campaign", "lead", "product", "coll", "front", "call", "fax", "contract", "connect", "f", "office", "conference", "communication", "Contact", "point", "cell"], "pst": ["lpsh", " psc", " post", "wpsh", "Pct", "psh", "prost", "wptd", "spst", "epcr", "preste", "prST", "psp", "pste", "spct", "Pdd", "Psp", "lpST", " pcr", " psp", "preut", "pdd", " psts", "opst", "prste", "post", "Post", "prest", "wpcr", "Pcr", "pct", "psts", "lpsts", "psl", "prdd", "pstd", " pste", "spste", "opsts", " put", "pcr", "prsp", "PST", "prsc", "prect", "Psc", " pdd", "psc", "wpst", "epST", "pST", "Pst", "prtd", "lpcr", "lptd", "opste", "Pste", " ptd", "prsts", "prsl", "lpsta", "lpst", "opct", "pssl", "prsta", "psta", "sput", "prcr", "epst", "Psts", " psh", " pct", "epsts", "pssts", "prst", "psst", "put", "ptd", " psta", " pST", "prct", " psl"]}}
{"id1": "6304373", "id2": "15797402", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrMempl", "uploadOrDeleteMediaOrTemplateporary", "uploadOrDeleteMediaOrTemFiles", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrTemplateplates", "uploadOrDeleteMediaOrtempl", "uploadOrDeleteMediaOrMemporary", "uploadOrDeleteMediaOrtemplates", "uploadOrDeleteMediaOrMemFiles", "uploadOrDeleteMediaOrTemplatepl", "uploadOrDeleteMediaOrtemFiles", "uploadOrDeleteMediaOrTemplateFiles", "uploadOrDeleteMediaOrtemporary", "uploadOrDeleteMediaOrTemporary", "uploadOrDeleteMediaOrMemplates"], "action": ["event", "error", "resource", "element", "lock", "now", "site", "act", "version", "ction", "activation", "flow", "active", "next", "ACTION", "what", "part", "type", "operation", "activity", "item", "section", "parent", "flash", "environment", "style", "plugin", "format", "test", "effect", "name", "change", "status", "controller", "function", "call", "commit", "actions", "url", "Action", "state", "step", "method", "module", "service", "api", "view"], "object": ["directory", "article", "event", "string", "address", "class", "node", "letter", "self", "resource", "lock", "ject", "now", "subject", "document", "version", "project", "system", "current", "mode", "o", "instance", "number", "host", "thread", "zone", "part", "email", "not", "target", "module", "model", "group", "none", "parent", "objects", "oid", "environment", "request", "edit", "image", "function", "full", "url", "obj", "office", "element", "service", "auto"], "numElements": [" numElem", "numEllement", "numEllem", "numelem", "numelement", " numEodes", "numEllements", "numGelement", "numGelements", "numeodes", "numGeodes", " numeodes", " numelement", "numelements", "numElem", " numelem", "numEodes", "numGelem", "numElodes", " numelements"], "req": ["base", "builder", "report", "res", "html", "ro", "mr", "usr", "util", "next", "params", "use", "load", "resp", "r", "g", "parent", "log", "verb", "msg", "gr", "ctx", "update", "conf", "err", "obj", "xml", "module"], "session": ["event", "ession", "temp", "resource", "response", "token", "lock", "http", "site", "document", "subject", "system", "result", "instance", "global", "thread", "manager", "security", "client", "sa", "cache", "use", "connection", "browser", "scope", "shared", "local", "request", "flash", "h", "context", "Session", "test", "image", "person", "ctx", "ESSION", "sp", "container", "state", "service"], "ftp": ["FTp", " ftcp", "ftcp", "FTP", "ftP", "ftc", "ttc", " ftP", "ttP", " ftc", "FTc", "FTcp", "ttp", "ttcp"], "user": ["string", "info", "path", "base", "class", "self", "ee", "username", "lock", "by", "mail", "USER", "profile", "author", "per", "User", "project", "result", "system", "account", "html", "admin", "current", "match", "record", "pass", "usr", "post", "er", "client", "type", "use", "users", "rule", "member", "facebook", "connection", "browser", "module", "other", "group", "shared", "config", "data", "used", "parent", "usa", "page", "log", "creator", "name", "e", "image", "home", "db", "person", "full", "ver", "url", "bug", "auth", "comment", "state", "error", "custom", "this", "hash", "view"], "links": ["base", "headers", "Link", "pages", "results", "mail", "posts", "html", "styles", "ids", "linked", "items", "email", "lines", "members", "images", "flash", "log", "groups", "Links", "tree", "image", "link", "details", "actions", "mails", "url", "menu"], "folders": ["anchers", "anchors", "handries", "filors", "handers", "filages", "filers", "handages", "filries", "foldages", "anchries", "handors", "foldries", "anchages", "foldors"], "folder": ["directory", "zip", "path", "letter", "address", "editor", "uri", "resource", "id", "division", "document", "filename", "slice", "project", "volume", "location", "layout", "zone", "database", "two", "picture", "email", "fold", "source", "dir", "connection", "scope", "upload", "sample", "level", "archive", "flat", "region", "ignore", "append", "device", "plugin", "home", "area", "theme", "layer", "url", "future", "Folder", "command", "network", "menu", "element", "license", "enter"], "server": ["directory", "string", "remote", "ssl", "address", "node", "resource", "uri", "username", "outer", "token", "master", "Server", "site", "filename", "version", "socket", "slave", "system", "inner", "account", "location", "host", "manager", "database", "client", "email", "type", "source", "reader", "seed", "connection", "value", "page", "device", "status", "port", "erver", "url", "ser", "localhost", "peer", "network", "scale", "engine", "service", "enter"], "login": ["string", "path", "info", "pin", "ssl", "resource", "skin", "username", "lock", "sudo", "mail", "site", "bridge", "filename", "profile", "socket", "account", "shell", "layout", "pass", "database", "picture", "email", "users", "connection", "Login", "group", "machine", "config", "journal", "log", "plugin", "name", "status", "blank", "blog", "label", "access", "url", "auth", "secret", "consumer", "cookie", "network", "basic", "service"], "password": ["directory", "string", "token", "username", "mask", "timeout", "sudo", "division", "filename", "profile", "slave", "volume", "account", "manager", "pass", "database", "pattern", " passwords", "picture", "security", "Password", "email", "PASS", "connection", "alias", "sword", "language", "device", "plugin", "name", "ass", "word", "worker", "access", "strip", "photo", "secret", "auth", "cookie", "padding", "basic", "phrase", "column"], "fileTransferFolder": ["fileTransferPath", "FileUploadfolder", "mediaTransferFolder", "fileUploadTheme", "fileImportFolder", "fileAccessFolder", "fileImportServer", "fileUploadPath", "fileTransferfolder", "mediaUploadServer", "fileTransformPath", "FileTransferPath", "fileUploadServer", "fileTransferServer", "mediaUploadfolder", "FileTransferTheme", "FileUploadFolder", "fileTransformfolder", "fileUploadfolder", "fileTransferTheme", "mediaTransferfolder", "FileUploadPath", "mediaUploadDirectory", "FileUploadTheme", "fileUploadDirectory", "fileImportfolder", "fileUploadFolder", "mediaTransferDirectory", "fileImportDirectory", "fileTransferDirectory", "fileAccessfolder", "FileTransferfolder", "fileAccessPath", "fileTransformFolder", "fileAccessTheme", "FileTransferFolder", "mediaUploadFolder", "fileTransformTheme", "mediaTransferServer"], "liveFolder": ["PreviewLocation", " liveDirectory", "PreviewFolder", "Livefolder", "PreviewDirectory", "Previewfolder", "livefolder", "LiveLocation", "LiveFolder", "LiveDirectory", " livefolder", "liveDirectory", "liveLocation", " liveLocation"], "servers": ["serServer", "servations", " serls", "serls", "servServer", "Serations", "SerServer", " serations", "Servers", "serations", "servls", " serServer", "servvers", "Serls"], "message": ["string", "path", "address", "buffer", "mess", " messages", "response", "resource", "mail", "document", "description", "manager", "content", "email", "member", "module", "application", "body", "page", "request", "flash", "Message", "log", "msg", "header", "status", "image", "array", "details", "url", "update", "summary", "error", "element", "menu"]}}
{"id1": "12085127", "id2": "14191679", "code1": "    public final void navigate(final URL url) {\n        try {\n            EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url);\n            final URLConnection connection = url.openConnection();\n            final InputStream is = connection.getInputStream();\n            navigate(url, is);\n            is.close();\n        } catch (final IOException e) {\n            EncogLogging.log(EncogLogging.LEVEL_ERROR, e);\n            throw new BrowseError(e);\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 0, "substitutes": {"navigate": [" Navig", "ajigating", "ajigate", "ivigate", " Navigation", "navigated", "Navigating", "avigating", "ajig", "ivigation", "avigation", "navigating", "ivigated", " Navigating", "Navigate", "Navig", "Navigation", "avigate", " Navigate", "navig", "ajigation", "ivigating", "navigation", "avigated", "Navigated"], "url": ["article", "address", "base", "job", "ssl", "i", "server", "uri", "resource", "feed", "id", "user", "entry", "http", "c", "html", "l", "host", "location", "URL", "account", "fr", "follow", "client", "source", "rule", "str", "r", "org", "build", "config", "file", "route", "page", "object", "ll", "web", "plugin", "e", "image", "blog", "link", "sl", "Url", "position", "www", "bug", "obj", "f", "gl", "element", "service", "api"], "connection": ["Connection", "handler", "i", "server", "resource", "response", "uri", "cf", "http", "ie", "character", "con", "c", "socket", "connected", "l", "database", "condition", "client", "session", "lc", "proxy", "which", "application", "open", "channel", "page", "context", "conn", "or", "coll", "ci", "io", "link", "position", "bc", "unit", "b", "connect", "wrapper", "communication", "loc"], "is": ["info", "bis", "i", "iss", "lis", "serv", "fs", "IS", "isa", "gets", "Is", "as", "api", "ins", "bs", "abs", "il", "s", "ui", "ii", "in", "isl", "its", "was", "ops", "ais", "isc", "ir", "ip", "es", "ai", "ris", "ci", "io", "iris", "ils", "ios", "us", "ib", "isi", "cs", "os", "isu", "im", "iso", "mis"]}}
{"id1": "12454178", "id2": "18974466", "code1": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"alterar": [" crear", " celebra", " cryar", " cultivAr", " celebrAr", " celebrar", " cultivaran", " cultivar", " crearan", " crea", " cryaran", " celebraran", " cryAr", " creAr", " crya", " cultiva"], "t": ["xt", "qt", "tc", "i", "att", "tm", "n", "ta", "c", "et", "table", "o", "l", "s", "wt", "trans", "rt", "te", "in", "tower", "dt", "nt", "at", "type", "tools", "d", "unt", "ti", "the", "target", "ut", "flat", "x", "p", "ant", "ts", "let", "u", "template", "e", "tp", "tree", "m", "ot", "to", "it", "tw", "T", "tr", "tt", "this", "you", "v", "y", "det", "st", " mt", "tf", "bolt", "f", "pt", "tool"], "stmt": ["ustmt", "strmn", "stau", "strm", " stau", "swmd", "putmd", "Stmm", "spt", " stnt", " stmb", "Stbm", "istmt", "ctgr", "Strm", " stmm", "strmt", "tmt", "Stct", " stpt", "tdb", " stmd", "swbm", "tpt", "istau", "stmd", "putnt", "Stv", "Stmb", "stpt", "strau", "stbm", "stmr", "formmt", "ustau", "swmt", "ctmb", "Stmd", "ctmt", "stv", "istmn", "strdb", "stgr", " stdb", "tmr", " strm", "stct", "Stgr", " stgr", " stbm", "formv", "istdb", "smr", "formrm", "stmm", "ustnt", "Stau", "formmm", " stv", "putmt", "ustmd", "ctct", " stmn", " stmr", "sdb", "stmn", "stmb", "stdb", "Stmt", "putau", "swau", " stct", "smt", "stnt"], "sql": ["where", "zip", "string", "base", "job", "serv", "setup", "lock", "result", "limit", " SQL", "s", "shell", "sol", "query", "database", "dl", "params", "expression", "mt", "stat", "pr", "q", "seed", "up", "ql", "log", "sq", "conn", "insert", "lambda", "ls", "db", "sl", "details", "QL", "url", "plan", "SQL", "printf", "statement", "cmd"], "id_disciplina": ["id_disciini", "id_Disciplineina", "id_disciino", "id_discomplino", "id_disrequINA", "id_distciplinea", "id_disrequini", "id_disciplineissa", "id_distciplini", "id_disciinea", "id_disciplino", "id_disciplineinea", "id_disciplini", "id_disciana", "id_discomplana", "id_discomplinea", "id_disciina", "id_Disciplissa", "id_discomplissa", "id_discomplini", "id_disciplineana", "id_disciplineino", "id_distrequinea", "id_discomplina", "id_distciini", "id_disrequina", "id_distrequINA", "id_disciplINA", "id_distciina", "id_distciplana", "id_Disciplineini", "id_distciplINA", "id_Disciplina", "id_disciINA", "id_distrequina", "id_disciplineina", "id_disciplinea", "id_distciplina", "id_distciino", "id_distrequini", "id_disciplissa", "id_disciplineINA", "id_Disciplineinea", "id_disciplana", "id_disciplineini", "id_Disciplini", "id_distciplino", "id_disguissa", "id_distciana", "id_Disciplineissa", "id_disguinea", "id_disguini", "id_disrequinea", "id_Disciplinea", "id_disguina"], "item": ["event", "info", "order", "index", "article", "i", "id", "server", "entry", "site", "result", "o", "instance", "queue", "items", "er", "bar", "at", "type", "reader", "source", "q", "r", "other", "parent", "data", "seller", "page", "object", "request", "p", "ip", "or", "hop", "name", "edit", "e", "m", "action", "it", "area", "service", "url", "pe", "unit", "v", "container", "Item"]}}
{"id1": "9824814", "id2": "17792212", "code1": "    public void run() {\n        if (status == COMPLETE) {\n            return;\n        }\n        waitRandom();\n        RandomAccessFile file = null;\n        InputStream inputStream = null;\n        boolean success = false;\n        URL url = null;\n        try {\n            BeatportAccessor beatportAccessor = new BeatportAccessor();\n            if (sessionCookies == null) {\n                sessionCookies = beatportAccessor.getSessionCookies(user, password);\n            }\n            url = new URL(new BeatportAccessor().getTrackDownloadUrl(downloadId, sessionCookies));\n            log.info(\"Open (DownloadWorker.run): \" + url);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", BeatportAccessor.userAgent);\n            connection.setRequestProperty(\"Cookie\", sessionCookies);\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                log.error(\"Unexpected response from server: \" + connection.getResponseCode());\n                error();\n                return;\n            }\n            if (connection.getContentType().indexOf(\"text\") >= 0) {\n                log.error(\"Tried to request: \" + url.toString());\n                log.error(\"Unexpected file content type from server: \" + connection.getContentType());\n                log.error(\"Server replied:\\n\" + getContentAsString(connection));\n                error();\n                return;\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                log.error(\"Invalid content length: \" + connection.getContentLength());\n                error();\n                return;\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            } else if (size != contentLength) {\n                changeTotal(0, contentLength - size);\n            }\n            if (new File(tmpFileName(fileName)).exists()) {\n                if (!new File(tmpFileName(fileName)).delete()) {\n                    throw new Exception(\"Could not delete file: \" + tmpFileName(fileName));\n                }\n            }\n            file = new RandomAccessFile(tmpFileName(fileName), \"rw\");\n            file.seek(downloaded);\n            inputStream = connection.getInputStream();\n            if (started == 0) {\n                started = System.currentTimeMillis();\n                time = started;\n            }\n            statusChangedObserver.statusChanged(status);\n            byte buffer[] = new byte[MAX_BUFFER_SIZE];\n            while (status == DOWNLOADING) {\n                if (size - downloaded < MAX_BUFFER_SIZE) {\n                    buffer = new byte[(int) (size - downloaded)];\n                }\n                int read = inputStream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                changeTotal(read, 0);\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                stopped = System.currentTimeMillis();\n                status = COMPLETE;\n            }\n            statusChangedObserver.statusChanged(status);\n            stateChanged();\n            success = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            error();\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n            if (success) {\n                try {\n                    if (!new File(tmpFileName(fileName)).renameTo(new File(fileName))) {\n                        throw new Exception(\"Rename Failed\");\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error moving temp file \" + tmpFileName(fileName) + \" file: \" + fileName, e);\n                }\n            } else {\n                try {\n                    new File(tmpFileName(fileName)).delete();\n                } catch (Exception e) {\n                    log.error(\"Error deleting erroneous temp file: \" + tmpFileName(fileName), e);\n                }\n            }\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                log.error(\"Error closing input stream of: \" + url + \" / \" + fileName, e);\n            }\n        }\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"run": ["play", "close", "release", "execute", "server", "register", "loop", "use", "running", "runs", "build", "open", "un", "check", "launch", "test", "start", "exec", "call", "worker", "update", "create", "Run", "process", "download", "stop"], "file": ["handler", "loader", "resource", "http", "rule", "lib", " files", "model", " File", "get", "force", "files", "download", "server", "feed", "lock", "result", "source", "cache", "binary", "use", "parent", "channel", "page", "object", "le", "unit", "b", "service", "directory", "play", "path", "remote", "letter", "ile", "mail", "message", "File", "queue", "email", "session", "reader", "upload", "body", "web", "image", "writer", "future", "single", "input", "filename", "fp", "il", "pool", "form", "type", "FILE", "application", "wave", "data", "text", "entity", "check", "put", "log", "folder", "port", "db", "pull", "stream", "f"], "inputStream": ["outputWriter", "inputFile", "InputWriter", " inputBuffer", "outputStream", "inputWriter", "InputBuffer", "outputBuffer", " inputFile", "InputStream", "outputFile", "inputBuffer", "InputFile", " inputWriter"], "url": ["zip", "string", "path", "address", "ssl", "server", "uri", "resource", "id", "feed", "user", "response", "http", "lr", "location", "host", "l", "URL", "client", "email", "session", "source", "proxy", "config", "data", "channel", "text", "page", "object", "web", "ll", "log", "conn", "ls", " URL", "image", "blog", "link", "sl", "pull", "Url", "position", "www", "service", "ur", "org", "download", "loc"], "beatportAccessor": ["beatportProcessrator", "beatportAccessutor", "beatpointProcessutor", "beatpointProcession", "beatportAdaptor", "beatportProcession", "beatportPassor", "beatportCollecter", "beatportPassors", "beatportProcessutor", "beatpointAccessors", "beatportCollectors", "beatportPassutor", "beatportsProcessor", "beatportProcessors", "beatportsAccessor", "beatportCreatutor", "beatportAccession", "beatpointAccession", "beatpointAccessutor", "beatportsProcesser", "beatportAccesser", "beatpointProcessors", "beatportAdapter", "beatportProcessor", "beatportCreators", "beatportCollectrator", "beatportsAccessors", "beatportAccessors", "beatportAdaptrator", "beatportCollector", "beatportAccessrator", "beatportsAccessrator", "beatportsProcessrator", "beatportPassion", "beatpointProcessor", "beatportCreation", "beatportAdaptors", "beatpointAccessor", "beatportsProcessors", "beatportsAccesser", "beatportProcesser", "beatportCreator"], "sessionCookies": ["sessionCys", "sessionCooky", "sessioncookies", "sessionCookles", "sessionCs", "essioncooky", "sessionCries", " sessionCries", "sessioncookys", "sessionConfigie", "SessionCookies", "sessionChries", "essionCookie", " sessionCy", "sessionCes", "sessionChys", "sessionGus", " sessionCookys", "sessionCles", "sessionChes", " sessionCookes", "sessionCookie", "sessionCie", "sessionChies", "sessioncookie", "sessionConfigys", "sessionGuies", "sessionCookys", " sessionCies", " sessionCys", "essionCooky", "sessionCies", "Sessioncookys", "Sessioncookests", "sessionGuys", "sessionConfigles", "SessionCooks", " sessionCookries", "essioncookies", "Sessioncooks", "sessioncooks", "sessionCookests", "sessionConfigies", "essioncookie", "essioncookles", "essionCookies", "SessionCookys", " sessionCes", "sessionCookes", "Sessioncookies", "sessionConfigy", "essionCookles", "sessioncookests", "sessionCy", "sessioncookries", "sessionCookries", "sessionCooks", "sessioncookes", " sessionCooky", "sessionConfigries", "sessioncookles", "sessionCests", "SessionCookests", "sessionGuests", "sessioncooky"], "connection": ["index", "handler", "resource", "http", "number", "volume", "URL", "database", "condition", "which", "component", "problem", "context", "conn", "bug", "statement", "Connection", "info", "server", "builder", "driver", "location", "query", "proxy", "ion", "machine", "section", "channel", "page", "object", "link", "connect", "service", "directory", "event", "remote", "translation", "reason", "uri", "response", "entry", "message", "slice", "socket", "relation", "password", "session", "reader", "collection", "or", "io", "image", "function", "position", "wrapper", "error", "callback", "communication", "user", "character", "description", "c", "connected", "current", "version", "l", "client", "application", "config", "out", "log", "call", "command", " Connection", "loc"], "contentLength": ["ContentWidth", "responseLen", "ContentType", "mediaWidth", " contentLimit", "contentCount", "ContentLength", "Contentlength", " contentlength", "resourceType", "ContentLimit", "resourceText", "contentType", "contentlength", "contentLimit", " contentType", "mediaLimit", "mediaCount", " contentWidth", "contentText", "mediaLength", " contentText", "ContentLen", "medialength", "responseLength", "responselength", "resourceCount", "mediaType", " contentLen", "ContentText", "resourceLen", " contentCount", "resourceLength", "contentWidth", "contentLen", "ContentCount", "responseType"], "size": ["capacity", "address", "total", "sum", "fee", "server", "timeout", "version", "confirmed", "number", "any", "length", "large", "weight", "content", "password", "security", "sized", "offset", "form", "source", "cache", "value", "needed", "data", "small", "body", "used", "empty", "Size", "name", "SIZE", "bytes", "position", "ize", "count", "state", "scale", "width", "error", "speed", "code", "storage"], "downloaded": ["feed", "response", "http", "HTTP", "s", "open", "Error", "Url", "_", "this"], "status": ["job", "id", "server", "kill", "lock", "mode", "result", "active", "queue", "Status", "stat", "source", "session", "cache", "date", "login", "complete", "name", "action", "wait", "process", "progress", "stage", "state", "speed", "code", "stop"], "success": ["ssl", "accept", "response", " successfully", "continue", "results", "warning", "result", " Success", "done", "failed", "fail", "content", "load", " successes", "data", "complete", " successful", "full", " succeeds", "good", "Success", "successful", "progress", "found", " succ", " results", "initial"]}}
{"id1": "4686922", "id2": "7458833", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourceAsResource", "extractResourcesToFile", "extractResourceInfile", "extractResourceToResource", "extractResourcesAsFiles", "extractResourceInResource", "extractResourceToFiles", "extractResourcesAsFile", "extractResourcesToFiles", "extractResourcesToResource", "extractResourceInFiles", "extractResourcesAsfile", "extractResourceTofile", "extractResourceInFile", "extractResourcesTofile", "extractResourceAsFile", "extractResourceAndfile", "extractResourcesAsResource", "extractResourceAndResource", "extractResourceAndFile", "extractResourceAsFiles", "extractResourceAndFiles", "extractResourceAsfile"], "resourcePath": ["ResourceId", "resourceUrl", "servicepath", "ResourceUrl", " resourceUrl", " resourcepath", "resourceFolder", "sourcePath", " resourceId", "sourcepath", "resourcepath", "Resourcepath", "sourceUrl", "resourceId", "serviceFolder", "sourceId", "stringpath", "ResourcePath", "servicePath", "stringFolder", "stringPath", " resourceFolder"], "dest": ["path", "class", "temp", "output", "resource", "resources", "filename", "project", "result", "later", "sac", "destroy", "done", "trans", " Dest", "content", "txt", "die", "comb", "source", "wb", "target", "dist", "default", "store", "config", "data", "file", "src", "Dest", "tmp", "flat", "de", "route", "desc", "folder", "home", "sup", "const", "contract", "prop", " destination", "transfer", "img"], "in": ["IN", "sin", "i", "input", "plus", "resource", "n", "id", "ini", "din", "gin", "con", "c", "inner", "as", "socket", "ins", "arin", "bin", "pass", "is", "like", "reader", "source", "thin", "up", "login", "connection", "inside", "r", "inc", "file", "rin", "init", "rec", "conn", "again", "image", "isin", "In", "nin", "kin", "url", "lin", "b", "cin", "inn", "f", "win", "this", "re"], "out": ["i", "temp", "ex", "output", "copy", "n", "server", "outer", "norm", "user", "auto", "net", "OUT", "socket", "o", "outs", "ins", "s", "all", "off", "co", "bin", "outside", "sync", "client", "at", "one", "source", "cache", "lib", "up", "w", "inc", "parent", "file", "null", "conn", "again", "exec", "Out", "io", "writer", "image", "ax", "In", "a", "app", "ext", "err", "b", "obj", "cookie", "f", "this", "boot", "cos"]}}
{"id1": "11049257", "id2": "21999120", "code1": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "code2": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "label": 1, "substitutes": {"generate": ["Generate", " genating", "Generating", "validation", "generating", " genation", "GenerATE", " genATE", "validate", "generATE", " genate", "Generation", "validating", "validATE", "generation"], "secure": ["ite", "zip", "remote", "ssl", "protect", "express", "ssh", "server", "sys", "secondary", "socket", "weak", " securely", "host", "security", "password", "client", "session", "proxy", "quiet", "debug", "config", "sensitive", "https", "encrypted", "sq", "force", "stable", "Secure", " insecure", "service", "secret", "deep", " secured", "sr", "sec"], "sep": ["spepel", "ensept", "seep", " sepel", "ensepent", "perseep", "spept", " seep", " sepa", "sepent", " sepent", "persep", "ensepel", " sept", "spepent", "sept", "persepa", "SEb", " seb", "SEep", "sepel", "perseb", "sepa", "ensep", "seb", "SEp", "SEpa", "spep"], "messagedigest": ["messageddigher", "messagighse", "messagedagester", "messagigist", "messagedimest", "messagagher", "messagighEST", "messagedligress", "messagedigress", "messagedimester", "messagedighest", "messagedligester", "messagigester", "messagedigester", "messagedagest", "messagedaghest", "messagedegester", "messagedigEST", "messagedigist", "messagedigse", "messagigest", "messagedligest", "messagaghest", "messagedighEST", "messagedimist", "messageddigester", "messagedimress", "messagedagist", "messagedighester", "messagedligse", "messagigress", "messagagress", "messagigher", "messageddigest", "messagighester", "messagedagher", "messagagse", "messagedagse", "messagedegher", "messagedligist", "messagagest", "messagagist", "messagedighse", "messagedagress", "messagagester", "messagagEST", "messagedegest", "messagedeghest", "messagighest", "messagedigher", "messageddighest", "messagigse", "messagedagEST", "messagedligEST", "messagigEST"], "stringbuffer": ["groupbuffer", "serialbuffer", "serialbuff", "defaultbuf", "ringsource", "linebuff", "stringbuf", "numberbuf", "arraybase", "ringmanager", "stringbuff", "binarybuff", "linequeue", "defaultqueue", "serialcache", "numberbuilder", "groupbuf", "Stringbuilder", "numberaddress", "stringqueue", "writebuff", "stringbuilder", "stringboard", "binarybuf", "systembuffer", "systembuff", "filemanager", "stringmanager", " stringbuff", "defaultbuffer", "binarythrow", "serialboard", "stringcache", " stringbuf", "stringsource", "stringaddress", "filesource", "jsonbuf", "numberqueue", "writethrow", "stringurl", "stringthrow", "filecache", "groupuffer", "fileurl", "Stringbase", "arraybuffer", "binarybuffer", " stringqueue", " stringboard", " stringthrow", "arraybuilder", "groupaddress", "systemqueue", "linebuf", "writebuf", "numberbuffer", "functionqueue", "jsonaddress", " stringaddress", "stringbase", "numberbase", " stringuffer", "ringurl", " stringmanager", "linebuffer", "stringuffer", "systembuf", "filebuff", " stringsource", "Stringbuf", "functionbuffer", "ringbuffer", "arraybuf", "functionbuff", "jsonbuffer", "writebuffer", " stringcache", "Stringbuffer", "filebuffer", "functionbuf", " stringurl", "jsonuffer", "fileboard", "defaultaddress"], "stringbuffer2": ["stringloaderII", " stringBuffer3", "stringbuffer5", " stringfb20", " stringcomment002", "stringbuffer52", " stringcache12", "doubleBuffer1", "finalbufferTwo", "stringbarTwo", " stringcache02", "stringcomment2", "stringbufferAll", "stringbufCache", "stringfb8", "doublebuffer4", "doubleBufferTwo", "stringbar5", " stringbuffer32", " stringBuffer2", "stringbufTwo", "stringbar2", "doubleBuffer4", "stringbuf4", " stringcommentTwo", "listloopL", "listloop02", " stringreader64", "stringpageTwo", " stringbufferTwo", "listbuffer2", " stringloop2", "stringcopy62", "stringbuffer82", " stringbuffer20", " stringBuffer52", "stringBuffer2", "stringbuilder10", "stringcommentTwo", "stringbuff1", "stringfbTwo", " stringloop200", "stringbuffer20", " stringbuffer82", " stringBuffer4", " stringcode2", "stringbuffer200", "doubleBuffer2", "stringbuffer12", "stringpage02", " stringfbCache", "objectbuffer62", "stringreader64", " stringbuffer3", " stringcache2", "stringbuffer4", "stringqueue2", "stringbufferTwo", "finalbuffTwo", " stringreaderII", "stringbufferL", "stringbuilder2", " stringbuffer002", "stringbuff4", "stringbuf3", "stringbufferCache", "stringfb200", "stringserverType", "stringcodeTwo", " stringbuffer64", "stringloader2", "stringviewTwo", "stringbuff5", "stringloop8", "stringcode32", "stringcache10", " stringloop8", "finalbuff5", " stringreaderTwo", "stringbuf5", "stringBuffer52", "stringbuff8", "stringbase4", "stringfb2", "stringufferTwo", "stringbreak4", "stringbuffer02", "stringbuffer8", "stringloopTwo", "stringloop200", "stringufferII", "stringuffer2", "stringcomment82", "stringpageL", " stringcodeTwo", "listbuffer02", "stringbuffer10", "stringpage2", " stringfb2", "objectbuff2", " stringbuffer52", "stringloaderTwo", " stringbufferII", "stringuffer64", "listloopTwo", "stringloop02", "doublebuffer1", "stringqueue5", "doublebuffer52", "stringbase2", " stringbufferAll", "stringserver2", "stringbreak3", "stringcache12", "stringserver5", " stringbuffer8", "listbufferL", "stringbufAll", "stringbuff62", " stringcomment82", "stringbase3", "stringbreak1", "stringbuf20", "doubleBuffer52", "stringbuf2", "stringserver002", "objectbuff5", "stringbuf52", "stringfb20", "stringbufType", "stringreader2", "stringbuffer64", "stringfbAll", " stringbuffer4", "finalbuffer2", "stringbuffAll", " stringbuffer10", "stringBuffer1", " stringcache10", "stringBufferTwo", "finalbuff2", "stringbuffer3", "stringbuf82", "stringbuf002", "stringcache02", "stringbuffer32", "stringbuffer62", "stringbreak2", "stringbuffCache", "stringcomment002", " stringbuffer12", "finalbuffType", "stringBuffer4", " stringcode5", "listbufferTwo", "stringloader64", "stringreaderII", "objectbuffer5", "stringbuff10", "finalbuffer5", "stringcopy2", " stringbuffer02", "stringview4", "stringbuffType", "stringview2", "stringbuff3", "doublebuffer3", "stringbufferType", "listloop2", "stringbuffL", "stringview52", "stringcopy5", " stringbufferCache", " stringfbAll", "stringcode2", " stringreader2", "stringbuff20", "stringbufferII", "stringbase52", "stringbuffer002", " stringbuffer5", "stringbuff200", "stringserver82", "stringcache2", "objectbuffer2", " stringcomment2", "stringbuff32", "stringserverTwo", "stringbuff2", "doublebufferTwo", "stringBuffer3", "doublebuffer2", "stringloopL", "stringbuilder02", " stringbuffer200", "stringbuff12", "stringbuilder12", "stringreaderTwo", "stringbuffTwo", "stringbar32", "finalbufferType", "stringfbCache", " stringcode32", " stringloopTwo", "stringbuff02", "stringloop2", "objectbuff62", "stringqueue62", "doubleBuffer3", "stringcode5"], "inetaddress": ["tunaccount", "etaccount", "tunimage", "inetaccount", "netaddress", "iotaccount", "iotAddress", "netAddress", "netaddr", "iotimage", "inethost", "ethost", "nethost", "inetimage", "networkAddress", "networkhost", "etaddress", "networkaddr", "iotaddress", "etimage", "inetAddress", "tunaddress", "etaddr", "networkaddress", "etAddress", "tunAddress", "inetaddr"], "l": ["lang", "n", "lf", "kl", "lp", "lb", "c", "tl", "z", "lr", "length", "el", "dl", "d", "lc", "r", "li", "al", "nl", "ll", "p", "u", "ls", "m", "t", "sl", "rl", "ln", "b", "v", "lv", "f", "L"], "l1": ["sl5", "l7", "ll81", "L2", "Lx", "il5", "L1", "llone", "L7", "ll1", "il51", "cl2", "lOne", "clOne", "lc1", " l5", " l7", " lone", "l2", "sl51", " l51", "sl1", "L81", "sl2", "ll2", "l81", "l5", " l81", "lcx", " l2", "cl1", "il1", " lOne", " lx", "Lone", "lone", "slOne", "lc2", "lx", "l51", "lc7"], "abyte0": ["abytes8", "iterator8", "umbo0", "gmentkeeper", "abytes1", "abyte000", "iterator0", "gmentzero", " arrayzero", "gment0", "omei", "ome0", "ome1", "abytej", " arraykeeper", "umboj", "abasekeeper", "abyte50", "omej", "byte8", "abyte1", "umboi", "umbo1", "bytej", "byte1", "iterator000", "abytekeeper", "iterator1", "abasezero", "abytezero", "byte000", "abase50", "abytes0", "abyte8", " array50", "gment50", "bytei", "abase0", "abytes000", "byte0", "abytei", " array0"], "stringbuffer1": ["stringview1", "doubleBuffer1", "StringBuffer8", "stringlayer1", "stringviewFirst", "stringBuffer2", " stringview81", "stringbuff1", "doublebufferOne", "stringlayer81", "doubleBuffer2", " stringbuffer3", "stringuffer3", "stringuffer1", "stringbuilder2", "stringBuffer81", "stringbuf3", " stringview1", "stringbuffer01", "stringbuilder1", "StringBuffer1", "stringbuff8", "stringviewone", "stringufferFirst", "Stringbuffer11", "stringbuffer8", "stringbuffer81", "stringuffer2", "stringlayerFirst", "doublebuffer1", "stringuffer81", "stringview81", "stringbuilder11", "doubleBufferOne", " stringbufferone", "doublebuffer81", " stringbuffer01", "Stringbuffer2", "stringbufferOne", "stringBufferOne", " stringuffer3", "stringBuffer1", "stringufferone", "stringbuff01", "stringbuffer3", "stringbuilder8", "Stringbuffer8", "stringuffer01", "stringbufferone", " stringbufferFirst", " stringbuffer81", "stringBuffer8", "stringbuff11", "stringbuff3", "stringbufferFirst", " stringviewFirst", "Stringbuffer1", " stringviewone", " stringuffer01", "StringBuffer11", "stringbuf01", "stringufferOne", "stringbuffer11", "StringBuffer2", "doubleBuffer81", "stringbuff2", "stringbuf1", "doublebuffer2", "stringBuffer11", "stringlayerone", " stringuffer1"], "i": ["index", "id", "uri", "pi", "n", "ini", "ie", "yi", "ind", "slice", "c", "z", "ri", "o", "fi", "si", "ui", "ii", "in", "ori", "qi", "vi", "ji", "ti", "d", "phi", "li", "ip", "x", "p", "h", "mi", "u", "bi", "oi", "ai", "ci", "I", "io", "e", "eni", "xi", "di", "gi", "hi", "k", "v", "y", "abi", "iu", "f", "ix"], "j": ["job", "n", "jet", "note", "ij", "dj", "json", "jc", "c", "ie", "z", "o", "jl", "length", "jo", "si", "ii", "aj", "qi", "ja", "ji", "d", "ch", "g", "bj", "li", "x", "p", "journal", "jj", "J", "js", "e", "kj", "jp", "k", "ali", "b", "v", "obj", "adj", "oj", "f", "jack", "ix", "cell"], "s": ["services", "string", "bis", "ssl", "sports", "n", "fs", "http", "results", "ns", "c", "S", "as", "o", "ins", "qs", "bs", "styles", "abs", "is", "series", "ms", "rs", "hs", "ings", "parts", "states", "its", "ws", "lines", "sb", "strings", "r", "sv", "g", "str", "gs", "xs", "h", "p", "es", "south", "u", "ts", "sites", "hes", "ls", "js", "e", "m", "sets", "tests", "t", "seconds", "resses", "ss", "a", "us", "ches", "ses", "ions", "b", "v", "words", "os", "f", "ps"]}}
{"id1": "1508930", "id2": "12883117", "code1": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "code2": "    public PhoneSetImpl(URL url) throws IOException {\n        BufferedReader reader;\n        String line;\n        phonesetMap = new HashMap();\n        reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        line = reader.readLine();\n        lineCount++;\n        while (line != null) {\n            if (!line.startsWith(\"***\")) {\n                parseAndAdd(line);\n            }\n            line = reader.readLine();\n        }\n        reader.close();\n    }\n", "label": 1, "substitutes": {"httpRequestByPOST": ["httpPostBypost", "httpPostWithPut", "httpRequestNoPOST", "httpPostWithpost", "httpRequestAsPOST", "httpPostByGET", "httpRequestWithpost", "httpPostWithGET", "httpRequestAsGET", "httpRequestAspost", "httpRequestByPut", "httpRequestWithPOST", "httpRequestNopost", "httpRequestAsPut", "httpRequestWithGET", "httpRequestBypost", "httpPostByPut", "httpRequestWithPut", "httpPostByPOST", "httpRequestByGET", "httpRequestNoGET", "httpPostWithPOST", "httpRequestNoPut"], "url": ["string", "path", "address", "base", "ssl", "server", "uri", "resource", "username", "id", "http", "json", "html", "location", "host", "l", "URL", "domain", "queue", "email", "date", "connection", "str", "file", "route", "page", "request", "name", "Url", "www", "download", "api"], "timeout": ["ssl", "max", "duration", "until", "token", "resource", "blocking", "socket", "limit", "length", "URL", "time", "sleep", "password", "cache", "delay", "connection", "out", "page", "size", "Timeout", "cookie", "wait", "random", "method"], "params": ["services", "Par", "server", "settings", "http", "results", "resources", "json", "posts", "api", "apps", "query", "password", "parts", "source", "terms", "ams", "Parameters", "data", "attr", "names", "ras", "options", "ip", "request", "details", "relations", "pins", "prop", "words", "ps", "properties", "Param", "param", "list"], "response": ["string", "reason", "server", "output", "resource", "feed", "more", "uri", "report", "res", "site", "message", "json", "result", "answer", "location", "content", "next", "resp", "connection", "value", "model", "str", "application", "collection", "data", "page", "request", "object", "reply", "example", "tree", "status", "image", "array", "full", "Response", "respond", "service", "api"], "httpClient": ["httpContract", "HttpPost", "httpServer", "serverPost", " httpStore", "serverServer", "HttpServer", "httpStore", "serverContract", "serverStore", "HttpStore", "HttpContract", "httpsServer", "httpsPost", "httpsContract", "httpsClient", "HttpClient", "serverClient", " httpServer"], "httpPost": ["httpPOST", "HttpRequest", "htmlDo", "httpsDo", " httppost", "httpspost", "HttpPost", "ttpThread", " httpDo", "HttpPOST", "HttpPut", "httpAdd", "HttpAdd", "httpDo", "HttpThread", " httpAdd", "httpPut", "htmlPut", "ttpRequest", "httpThread", "ttpDo", "htmlPost", "Httppost", "httpRequest", " httpThread", " httpRequest", "ttpPost", "httpsPost", "HttpDo", "httpsPOST", "httpsAdd", "htmlPOST", " httpPOST", "httpsPut", "httppost"], "serverResponse": ["serverStatus", "statusResponse", " serverStatus", "erverResp", "httpServer", "statusClient", "ServerResponse", "erverServer", "serverSession", "serverServer", "httpResp", " serverSession", "httpSession", "erverResponse", "erverClient", " serverClient", "httpStatus", "statusStatus", "ServerServer", "serverResp", "serverClient", " serverResp", "statusResp", "ServerClient", "statusSession", "httpResponse", "ServerResp"], "statusLine": ["resourceCode", "statusCode", "StatusLine", "StatusL", "syncEntity", "resourceLine", "resourcePass", "statusLink", "responseLink", "contentLine", "statusEntity", "httpCode", "errorError", "serverPage", "statusNode", "StatusNode", "errorLink", "errorCode", "statusLin", "StatusPage", "responseCode", "statusPass", "contentPage", "syncLin", "StatusPass", "serverNode", "statusL", "StatusLink", "progressLine", "statusError", "progressCode", "syncCode", "progressEntity", "responseLin", "contentFile", "httpLine", "responseError", "StatusError", "httpPass", "StatusCode", "statusFile", "httpL", "progressLin", "contentNode", "statusPage", "serverFile", "responseEntity", "serverLine", "syncLine", "responseLine", "StatusFile", "errorLine", "resourceL"], "inputStream": ["inSteam", "inStream", "inputContent", "inputStreamer", "InputBuffer", "InputStream", "inContent", "inputSteam", "InputReader", " inputstream", "tempStream", "pullSteam", "loadSteam", " inputContent", "inputBuffer", "pullStream", " inputSteam", "inReader", "tempContent", "InputContent", " inputStreamer", "pullBuffer", "inBuffer", "loadContent", "pullReader", "loadStream", "instream", "tempSteam", "Inputstream", "inputstream", "InputSteam", "loadStreamer", "tempStreamer"], "inputReader": ["regularStreamer", "requestReader", " inputBuffer", "inputStreamer", "outputBuffer", "outputBuilder", "readerStream", "requestBuilder", "inputBuilder", " inputBuilder", "inputBuffer", "outputStreamer", "requestBuffer", "readerStreamer", "outputStream", "readerER", "regularReader", "requestStream", "outputER", "readerReader", "outputReader", "regularER", "inputER", "regularStream"], "bufferedReader": ["bufferedRead", "BufferingStream", "buffererReader", "BufferedWriter", " buffaredRead", "bufferedContainer", "bufferingRead", "BufferingWriter", "buffererWriter", " buffaredStream", " buffaredWriter", "buffaredStream", " buffaredReader", "BufferedReader", "buffedWriter", "buffaredWriter", "buffaredRead", "bufferingStream", " bufferedStream", "buffedRead", "BufferedStream", "bufferingReader", "buffererStream", "bufferedWriter", "buffaredReader", "BufferedContainer", "buffaredContainer", "buffererContainer", "bufferingContainer", " bufferedRead", "BufferingReader", "buffedStream", "bufferedStream", "BufferingContainer", "bufferingWriter", " bufferedWriter", "buffedReader"], "buffer": ["string", "translation", "base", "loader", "pause", "Buffer", "audio", "output", "uffer", "resource", "copy", "builder", "feed", "server", "report", "message", "document", "slave", "result", "limit", "iter", "queue", "loop", "bar", "type", "reader", "cache", "binary", "source", "sb", "buff", "buf", "wave", "surface", "ob", "data", "ignore", "out", "fb", "page", "request", "background", "bb", "null", "row", "header", "writer", "image", "array", "layer", "b"], "line": ["letter", "string", "base", "i", "lf", "feed", "column", "entry", "message", "character", "LINE", "end", "number", "l", "el", "pass", "char", "iter", "content", "key", "sync", "source", "lines", "lc", "str", "data", "file", "text", "body", "liner", "cl", "page", "ip", "object", "le", "inline", "row", "name", "header", "e", "link", "sl", "unit", "comment", "Line", "lin", "parse", "block", "code", "cell"], "lastErrorCode": ["lastSuccessCause", "lastSuccessCode", "lastWarningInfo", " lastHeaderInfo", "currentStatusCode", "lastErrorInfo", "lastWarningName", "currentStatusMessage", "lastStatusCause", "lastHttpCode", "lastStatusText", "lastStatusCode", "currentErrorText", "currentErrorCause", "lastStatusName", "lastHeaderCode", "lastHeaderName", "lastHttpCause", "lastHeaderInfo", "lastStatusInfo", " lastErrorName", " lastHeaderMessage", "lastErrorText", "lastHttpMessage", "lastStatusMessage", "lastErrorName", "lastSuccessMessage", "lastSuccessText", "currentStatusCause", "currentErrorMessage", "lastWarningCode", "currentStatusText", "lastHttpText", "lastHeaderMessage", "currentErrorCode", " lastHeaderCode", "lastWarningMessage", " lastErrorInfo", "lastErrorCause", " lastHeaderName"], "lastErrorMessage": ["lastWarningException", "lastCodeMessage", " lastWarningDetails", "lastErrorDescription", " lastErrorSummary", " lastWarningStatus", "lastWarningStatus", "lastErrorStatus", " lastErrorException", "lastWarningDescription", " lastWarningMessage", " lastErrorDescription", "lastWarningDetails", "lastStatusStatus", "lastErrorSummary", " lastHeaderException", "lastHeaderCode", "lastCodeException", "lastHeaderException", " lastErrorDetails", " lastHeaderSummary", "lastStatusDetails", " lastHeaderMessage", "lastStatusMessage", "lastWarningCode", "lastHeaderSummary", "lastErrorException", "lastHeaderMessage", "lastCodeCode", "lastCodeSummary", "lastStatusDescription", " lastWarningDescription", " lastHeaderCode", "lastWarningMessage", "lastWarningSummary", "lastErrorDetails", " lastErrorStatus"]}}
{"id1": "20375440", "id2": "15409512", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "srcFile": [" srcfile", "sourceDir", "rcFile", " srcDir", "destfile", "srcFiles", "rcfile", "sourcePath", "rcPath", "sourceFile", "rcFiles", "sourceFiles", "destFiles", " srcFiles", "srcPath", "destDir", "sourcefile", "srcDir", " srcPath", "srcfile"], "destFile": ["DestPath", "destfile", "DestFile", "restFile", "tempPath", "targetPlace", "targetFiles", " destFiles", "targetfile", "destFiles", "restPlace", "DestPlace", "DestFiles", " destfile", " destPath", "restfile", "destPath", "Destfile", "restFiles", "tempfile", "tempFile", "tempFiles", "destPlace", "targetFile"], "src": ["impl", "ssl", "sel", "loader", "sc", "input", "cmp", "sys", "self", "rc", "slice", "cb", "sub", "loc", "bs", "ources", "inst", "func", "in", "rs", "req", "client", "gb", "sync", "rb", "source", "ws", "proc", "sb", "construct", "stat", "reader", "dist", "upload", "config", "conv", "sq", "conn", "start", "sup", "sl", "secure", "ctx", "url", "ser", "stream", "cur", "sr", "sec", "RC", "img"], "dest": ["path", "rest", "ssl", "class", "temp", "output", "slave", "end", "result", "destroy", "trans", "ui", "dc", "usr", " Dest", "std", "comb", "cdn", "cp", "source", "d", "proc", "wb", "ws", "thin", "wh", "target", "dir", "dist", "div", "de", "Dest", "tmp", "out", "des", "null", "test", "desc", "dev", "writer", "home", "opt", "sup", "stream", "obj", "ds", "dat", "this", "transform", "img"], "buffer": ["string", "info", "capacity", "address", "Buffer", "input", "uffer", "copy", "feed", "base", "message", "slice", "number", "result", "limit", "length", "write", "bin", "memory", "key", "queue", "iter", "raw", "offset", "source", "cache", "reader", "buff", "value", "buf", "wave", "data", "channel", "request", "size", "row", "null", "header", "writer", "bytes", "position", "flush", "layer", "b", "reference", "block", "transfer", "batch"], "read": ["play", "index", "close", "i", "input", "Read", "feed", "id", "n", "reading", "copy", "ok", "add", "ind", "slice", "end", "find", "number", "run", "limit", "length", "se", "write", "reads", "ride", "pass", "key", "sleep", "iter", "next", "raw", "sync", "select", "allow", "reader", "load", "d", "use", "no", "not", "show", "default", "build", "work", "open", "data", "level", "text", "seek", "check", "pick", "ip", "x", "get", "size", "fill", "start", "exec", "send", "skip", "k", "parse", "shape", "b", "connect", "create", "wait", "count", "READ", "block"]}}
{"id1": "4168534", "id2": "5049453", "code1": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "code2": "    private BingResponse queryBing(BingRequest request) throws BingException {\n        try {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Searching through bing...\");\n            }\n            String query = request.getQuery();\n            query = URLEncoder.encode(query, \"UTF-8\");\n            URL url = new URL(\"http://api.bing.net/json.aspx?\" + \"AppId=\" + request.getAppId() + \"&Query=\" + query + \"&Sources=\" + request.getType().toString());\n            URLConnection connection = null;\n            if (useProxy) {\n                if (proxyType == null) {\n                    throw new BingException(\"Please set a proxy first before trying to connect through a proxy\", new Throwable());\n                }\n                connection = ProxyWrapper.getURLConnection(url.toString(), proxyType.toString(), proxyHost, proxyPort);\n            } else {\n                connection = new URL(url.toString()).openConnection();\n            }\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            String response = builder.toString();\n            ResponseParser parser = new ResponseParser();\n            parser.getError(response);\n            return parser.getResults(response);\n        } catch (MalformedURLException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        } catch (IOException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        }\n    }\n", "label": 0, "substitutes": {"insertSmsInf": ["insertJsmsInf", "insertSmsinf", "insertSmbConf", "insertSMSInf", "insertSmbInf", "insertSmesConf", "insertSmbinf", "insertJsmsInfo", "insertSmesInf", "insertJsMSConf", "insertSmesinf", "insertSMSInfo", "insertSmesInfo", "insertJsmsConf", "insertJsMSInfo", "insertSmbInfo", "insertJsMSInf", "insertJsmsinf", "insertSMSConf", "insertSmsConf", "insertSmsInfo", "insertSMSinf", "insertJsMSinf"], "sms": ["esms", "installms", " smn", "pMs", "dsmb", "scheessions", "esmes", " smes", "smes", "infs", " sails", "scheails", "sMs", "pms", "ismn", "sls", "esls", "pessions", "smb", "pails", "jsms", " sessions", "jsls", "inmn", "dsmes", "scheMs", "installbm", "ismos", " sbm", "inms", "isfs", "installmes", "installMs", "jsmes", "sails", "esmb", "inmos", " sMs", "smn", "smos", "jsmb", "isms", " smos", "esbm", " sfs", "sessions", "dsls", "sbm", "schems", "dsms", "sfs", "esMs"], "smsId": ["gmsID", "snsId", "snsUrl", "smsUrl", "smeID", "spsid", "snsid", "esnsID", "SmeUrl", "gnsId", "smeUrl", "smsInfo", "esnsid", "snsInfo", "spsInfo", " snsid", "SmeID", "sMSid", "snsKey", "esmsId", "sssid", " snsInfo", " smsInfo", "spsId", "smesUrl", "slsId", "scsId", "SmsUrl", "slsid", "smesID", "Smeid", "smeId", "sssId", "sMSKey", "snsName", "smsName", "esmsid", "scsID", "gnsid", "esnsId", "gnsID", "snsID", "smesId", " snsName", " smsName", "esnsKey", "sssID", "smsKey", "smsID", "smesid", "gmsId", "smesInfo", "gmsid", "spsName", "sMSId", " snsId", "sMSID", "SmsId", "scsid", "smeid", "esmsKey", "smesName", "scsKey", "esmsID", "slsID", "smsid", "SmeId", " smsid", "SmsID", "Smsid"], "conn": ["Connection", "close", "ou", "core", "Conn", "cc", "server", "n", "cf", "rc", "enc", "lock", "con", "c", "act", "pub", "cb", "col", "pool", "co", "dc", "nc", "client", "cms", "cm", "nt", "cp", "session", "cache", "pr", "lc", "uc", "ct", "connection", "sync", "ch", "cat", "config", "conv", "ca", "log", "po", "coll", "ci", "exec", "cr", "ann", "oci", "db", "pc", "mc", "ctx", "sql", "conf", "reg", "connect", "cn", "obj", "cli", "error", "pg", "org", "loc"], "pstmt": ["psttt", "pStmr", "postatt", " pstmn", "pmtm", "Pstmn", "pfm", "pmtnm", "pfbt", "pctbt", " pstmd", "pctm", "pthmn", "pstmb", "pngbt", "pstdt", "pctmr", "pthmt", "pstdb", "prestm", "pctatt", "psthmt", " pestdb", "pktmt", "Pctbt", "pngmd", "pctnt", "pStmt", " pstnt", "pngmt", "prestmd", " pstm", "Psttt", "pStmb", "pctmn", "pstm", " pestmt", "pestdb", "postmd", "pstrdb", " pfm", "postmt", "psthmb", "pktdt", "pctorp", "pestmb", "pstmn", "prestmt", "pmtdb", " pfmt", "pstatt", " postm", "prestatt", "Pstmd", "pctmd", " postmd", "pctmb", " postmt", " pestmr", "pktmd", "pstnt", "pfmn", " pestmb", "pstrm", "pSttt", "Pctmt", " pfnm", "pmtnt", "pthmd", "pestmt", "Pstm", " pktmd", " pstnm", "pktmn", "Pstdb", "pctnm", "psthmd", "pstmd", "Pctdb", "pstmr", "Pstmt", "pfnt", " postatt", " pfnt", " pstdt", "pstbt", " pktmn", "pngmb", "pmtmb", " pestorp", "psthdb", "pstrmn", "pthdt", " pstdb", "pfdb", "pmtmt", "Pctm", "psthmr", "psthtt", "Pcttt", "Pctmd", " pktmt", "Pctmn", "pctmt", "Pstmr", "pstorp", "pfmd", "pstnm", "pmtorp", "pestmr", "Pctmb", "psthdt", "psthmn", " pstmb", "postm", "Pstbt", "Pctmr", "pcttt", " pstatt", "pfmt", "pctdb", "pestorp", " pstmr", "pstrmt", " pstorp", "pfnm", "Pstmb", "pfmb", " pktdt"], "buffer": ["string", "info", "base", "Buffer", "server", "uffer", "copy", "resource", "builder", "http", "message", "document", "program", "result", "window", "shell", "bin", "memory", "database", "pb", "key", "queue", "iter", "raw", "uf", "bar", "cache", "binary", "sb", "buff", "book", "buf", "build", "text", "BU", "file", "fb", "IO", "append", "flash", "object", "log", "null", "page", "request", "template", "header", "writer", "FFER", "array", "function", "layer", "url", "bc", "comment", "b", "print", "block", "batch", "re", "code", "view"], "index": ["val", "path", "info", "base", "address", "i", "num", "input", "step", "list", "id", "add", "ind", "version", "slice", "end", "number", "find", "instance", "join", "length", "Index", "match", "digit", "key", "alpha", "offset", "weight", "condition", "cache", "connection", "diff", "value", "default", "inc", "section", "config", "level", "open", "append", "x", "size", "search", "style", "change", "pos", "array", "position", "update", "include", "connect", "block", "width", "batch", "error", "field", "column", "point", "loc"], "ex": ["event", "sex", "class", "temp", "expl", "rap", "aux", "ic", "con", "su", "ception", "tx", "Exc", "six", "nex", "exit", "except", "ignore", "de", "rex", "exc", "x", "pex", "es", "name", "js", "example", "ax", "lex", "exec", "exp", "rx", "Ex", "com", "ext", "app", "obj", "err", "error", "EX", "re", "external"]}}
{"id1": "886783", "id2": "20426057", "code1": "    private static void doGet(LNISoapServlet lni, String itemHandle, String packager, String output, String endpoint) throws java.rmi.RemoteException, ProtocolException, IOException, FileNotFoundException {\n        String itemURI = doLookup(lni, itemHandle, null);\n        URL url = LNIClientUtils.makeDAVURL(endpoint, itemURI, packager);\n        System.err.println(\"DEBUG: GET from URL: \" + url.toString());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setDoInput(true);\n        fixBasicAuth(url, conn);\n        conn.connect();\n        int status = conn.getResponseCode();\n        if (status < 200 || status >= 300) {\n            die(status, \"HTTP error, status=\" + String.valueOf(status) + \", message=\" + conn.getResponseMessage());\n        }\n        InputStream in = conn.getInputStream();\n        OutputStream out = new FileOutputStream(output);\n        copyStream(in, out);\n        in.close();\n        out.close();\n        System.err.println(\"DEBUG: Created local file \" + output);\n        System.err.println(\"RESULT: Status=\" + String.valueOf(conn.getResponseCode()) + \" \" + conn.getResponseMessage());\n    }\n", "code2": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "label": 0, "substitutes": {"doGet": ["DoGet", "toGet", "DoGET", "Doget", "doget", " doPut", "doGET", "doPut", "DoPut", "toGET", " doget", "toPut", " doGET", "toget"], "lni": ["lti", "Lti", "rni", "lii", "iolni", " lii", " lti", "rti", "rii", "Lni", "ldi", " ldi", "iolii", "Ldi", "Lii", "rdi", "ioldi", "iolti"], "itemHandle": ["Itemhandle", " itemhandle", " itemHand", "pagehandle", "pageURI", " itemHandler", "ItemHand", "ItemHandler", " itemFile", "itemsFile", "pageAddress", "ItemAddress", "itemsHandler", "itemsHandle", "itemHand", "ItemFile", "pageHandle", "itemHandler", "itemFile", "itemAddress", "itemsHand", "ItemURI", " itemAddress", "itemhandle", "ItemHandle"], "packager": ["packageatter", "packatter", "paramagers", "paramaging", "Packaging", "installagers", "paramager", "ackagger", "installenger", "packagger", "packageaging", "Packager", "ackaging", "packaging", "paramenger", "importager", "importenger", "installager", "importagers", "ackager", "importaging", "packageager", "Packatter", "ackatter", "packageagger", "installaging", "packagers", "Packagger", "packenger"], "output": ["string", "path", "address", "buffer", "online", "input", "console", "response", "resource", "outer", "four", "Output", "document", "filename", "message", "profile", "version", "ilo", "il", "write", "written", "queue", "source", "connection", "target", "debug", "model", "application", "config", "file", "page", "web", "environment", "log", "null", "control", "format", "header", "generated", "image", "prefix", "reference", "summary", "xml", "office", "module", "external"], "endpoint": ["Endocol", "Endpoints", "restPoint", " Endpoints", " endbase", "endpath", "restpath", " Endocol", "EndPoint", " endocol", "endpoints", "endedpoint", " endpoints", "endedpath", " Endpoint", "endbase", "endend", "Endend", "Endbase", "endocol", " Endbase", "Endpoint", "restend", "restpoint", "endPoint", "endedend", "endedPoint", "Endpath"], "ProtocolException": ["ProtInterfaceFailure", "ProtoException", "ProtocolFailure", "ProtportException", "InterocolBase", "ProtportBase", "InterportFailure", "ProtocolBase", "ProtInterfaceHandler", "ProtoFailure", "ProtoBase", "InterocolFailure", "ProtInterfaceBase", "InterportException", "ProtInterfaceException", "ProtocolHandler", "ProtoHandler", "ProtportHandler", "InterportBase", "InterocolHandler", "ProtportFailure", "InterocolException", "InterportHandler"], "IOException": ["IOError", "SecurityEx", "SecurityException", "IOEx", " IOEx", "RemoteException", "RemoteEx", " IOError", "SecurityError", "RemoteError"], "FileNotFoundException": ["FileNotAvailableError", "FileNotfoundError", "FileNotAvailableException", "FileIsAvailableException", "FileIsFoundError", "FileNotFoundExcept", "FileNotFoundError", "FileIsAvailableError", "FileIsAvailableExcept", "FileIsFoundExcept", "FileNotAvailableExcept", "FileNotfoundException", "FileIsFoundException", "FileNotfoundExcept"], "itemURI": ["itemURL", " itemRI", "containeruri", "objectURL", " itemURL", "ItemRI", "objectURI", "ItemUrl", " itemUrl", "itemuri", "containerURI", "objectUrl", " itemuri", "Itemuri", "objecturi", "ItemURI", "containerURL", "containerRI", "itemUrl", "itemRI", "ItemURL"], "url": ["impl", "zip", "path", "ssl", "address", "base", "job", "i", "server", "uri", "resource", "id", "user", "entry", "http", "c", "l", "location", "host", "URL", "il", "el", "key", "client", "source", "connection", "ob", "file", "channel", "li", "page", "object", "web", "ll", "log", "bb", "ls", "coll", "image", "io", "db", "sl", "rl", "Url", "www", "stream", "ur", "f", "hub", "method", "org", "download", "loc"], "conn": ["Connection", "close", "ssl", "core", "Conn", "server", "n", "serv", "cf", "enc", "rc", "http", "con", "c", "socket", "act", "connected", "cb", "oa", "col", "fn", "co", "rt", "dc", "en", "nc", "fail", "ec", "client", "sync", "nt", "cm", "cp", "uc", "ct", "connection", "not", "ch", "open", "conv", "config", "ca", "ai", "po", "coll", "ci", "exec", "io", "oss", "ann", "dn", "db", "pc", "ctx", "sql", "auth", "conf", "err", "connect", "cn", "adj", "orp", "sn", "cli", "error", "api"], "status": ["index", "zip", "reason", "sex", "class", "ssl", "id", "server", "response", "method", "pre", "site", "message", "json", "version", "warning", "current", "result", "api", "si", "grade", "active", "content", "Status", "fail", "sync", "cm", "score", "stat", "type", "rate", "source", "date", "login", "str", "level", "size", "msg", "header", "ity", "success", "prefix", "received", "err", "stage", "state", "xml", "progress", "cli", "error", "sr", "code", "ix"], "in": ["IN", "pin", "i", "input", "n", "id", "ini", "gin", "con", "inner", "socket", "o", "ins", "bin", "reader", "source", "up", "login", "min", "inside", "r", "inc", "data", "rin", "init", "or", "again", "rx", "io", "isin", "In", "nin", "a", "pull", "stream", "lin", "cin", "inn", "win", "din"], "out": ["ou", "temp", "ex", "copy", "n", "self", "user", "plus", "outer", "gin", "on", "net", "plain", "OUT", "o", "outs", "line", "co", "bin", "off", "extra", "client", "sync", "at", "doc", "cache", "lib", "up", "min", "ch", "inc", "parent", "w", "file", "log", "again", "exec", "Out", "writer", "io", "exp", "ext", "err", "obj", "this", "img"]}}
{"id1": "6379126", "id2": "8778962", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"gerarTutorialPage": ["riarTravispage", "riarTutorialDir", "riarTinyDir", "riarTravisPage", "riarTourElement", "riartourpage", "riartourPage", "riartourElement", "riarTinypage", "riartutorialPage", "riarTourpage", "riarTourDir", "riartutorialpage", "riartourDir", "riarTutorialpage", "riarTinyPage", "riarTutorialElement", "riartutorialDir", "riarTravisElement", "riarTinyElement", "riarTutorialPage", "riartutorialElement", "riarTravisDir", "riarTourPage"], "indexDir": ["IndexDIR", "includeTier", "IndexDir", "zipDir", "includeDir", "includeDIR", "indexDIR", "indexTier", "IndexTier", "zipDIR", "zipTier", "indexJar", "includeJar", "IndexJar", "zipJar"], "cssDir": ["fontDIR", "codesLen", "ssDar", "ssUrl", "cssUrl", "cssDIR", "catsDoc", "ssDb", "ssDir", "piecesDie", "fontD", "gzDIR", "piecesDir", "cssD", "ssDIR", "javascriptDb", "cssLen", "CSSLen", "ssD", "cssDb", "javascriptDIR", "CSSDoc", "cssDie", "javascriptDir", "CSSDb", "codesDoc", "piecesDIR", "piecesD", "cssDar", "cssDirectory", "CSSDar", "gzDir", "javascriptDar", "ssDie", "CSSDIR", "fontDie", "cssDoc", "fontDir", "codesDir", "CSSUrl", "catsLen", "catsDir", "ssDirectory", "gzUrl", "gzDirectory", "CSSDir", "CSSDirectory"], "capDir": ["casDir", "casdir", "apsVol", "Capdir", "casVol", "CapDirectory", "capdir", "apsdir", "apsDirectory", "CapVol", "capVol", "capDirectory", "apsDir", "casDirectory", "CapDir"], "licDir": ["libdir", "lifdir", "lifManager", "volDir", "libDir", "libDoc", "voldir", "licDoc", "volDoc", "licManager", "lifDoc", "lifDir", "licdir", "volManager", "libManager"], "midDir": ["casDir", "casdir", "middir", "limdir", "limTier", "mindDir", "limDir", "casTier", "limDIR", "minddir", "midDIR", "midTier", "casDIR", "mindTier", "mindDIR"], "filesDir": ["FilesFolder", "FilesDir", "imagesDir", "FilesFile", "filesFolder", "filesFile", "stylesDirectory", "filesVol", "imagesFile", "ballsVol", "stylesDIR", "filesDirectory", "locksDir", "filesDIR", "imagesDirectory", "opensDIR", "ballsDir", "locksDIR", "opensDirectory", "opensDir", "stylesDur", "imagesFolder", "filesPos", "ballsPos", "stylesDir", "filesDur", "videosFolder", "opensDur", "videosFile", "FilesDirectory", "pagesVol", "locksDirectory", " filesVol", "pagesPos", " filesPos", "locksDur", "videosDirectory", "pagesDir"], "videosDir": ["imagesDir", "videoFile", " videosDirectory", " videosFile", "videoUrl", "videosUrl", " videosDb", "imagesDb", "videoDb", "viewsFile", "viewsDir", " videosUrl", "viewsUrl", "videosFile", "viewsDirectory", "videosDb", "videoDir", "videoDirectory", "videosDirectory"], "imagensDir": ["imagersDirectory", "imgensDir", "imagenJar", "imagenciesDir", "imagensJar", " imagersJar", " imagersDirectory", " imagensFile", "imagenDir", " imagensDirectory", "imagenDirectory", "imagenciesDirectory", "imagentsJar", "imagensDIR", "imagensFile", "imagersFile", " imagersDir", "imagensDirectory", "imagenFile", "imgentsDirectory", "imgensDIR", "imagersDIR", "imagentsDir", "imgensDirectory", "imgentsFile", "imagentsDirectory", "imagersDir", "imgentsDIR", " imagersFile", "imagenciesFile", "imagenciesDIR", "imgensFile", " imagensJar", "imagentsFile", "imgentsDir", "imagersJar", "imagentsDIR"], "local": ["directory", "where", "path", "total", "base", "remote", "personal", "temp", "defined", "pal", " Local", "self", "username", "managed", "user", "lock", "Local", "relative", "http", "json", "current", "inner", "present", "standard", "l", "location", "global", "pass", "util", "active", "part", "back", "d", "valid", "dir", "serial", "specified", "shared", "upload", "data", "file", "tmp", "small", "input", "same", "request", "p", "log", "safe", "name", "internal", "home", "available", "initial", "prefix", "LOC", "localhost", "partial", "Location", "conf", "state", "basic", "loc"], "srcCss1": ["srcCass81", "srcRss0", "srcCrss1", "srcCass2", "srcCpe4", "srcCss81", "srcCpe1", "srcCfg2", "srcCse11", "srcRss11", "srcRss81", "srcPcss1", "srcRcss81", "srcCrss3", "srcCcss2", "srcCss11", "srcRcss11", "srcCass11", "srcPcss3", "srcRcss1", "srcPss1", "srcPssPre", "srcCass1", "srcCcss4", "srcCrss11", "srcRcss2", "srcCass3", "srcPss2", "srcCfg1", "srcCcss0", "srcPss4", "srcCcss11", "srcCass0", "srcCssPre", "srcCse1", "srcCfgPre", "srcPcss2", "srcCcss3", "srcCpe2", "srcCcss1", "srcRss2", "srcRss1", "srcCse0", "srcCcss81", "srcCpePre", "srcCfg4", "srcPss81", "srcCrss81", "srcCse2", "srcCcssPre", "srcCss0", "srcPcss4", "srcRcss0", "srcPcssPre", "srcPcss81", "srcCrss2", "srcPss3"], "destCss1": ["destCcss3", "destCrss1", "destCass2", "destCfg0", "destPss3", "destCxxCard", "destPcss3", "destCrss2", "destPss81", "destCrss81", "destCass3", "destCrss3", "destPss0", "destCss0", "destCrss0", "destCcss0", "destPcss81", "destCfg3", "destCss81", "destCcss2", "destCfg1", "destCxx1", "destCxx2", "destCassCard", "destPcss1", "destPss2", "destCcssCard", "destPcss0", "destPcssCard", "destCssCard", "destCxx3", "destPssCard", "destPcss2", "destCass81", "destCass1", "destPss1", "destCcss1", "destCcss81", "destCfg2"], "srcCss2": ["srcCross52", "srcCssL", "srcChessTwo", "srcAccss2", "srcCrss1", "srcCng27", "srcCng2", "srcAcss1", "srcCfg3", "srcCcss27", "srcCass2", "srcCfg2", "srcPcssL", "srcPcss1", "srcUss2", "srcCcss2", "srcCass4", "srcChess1", "srcPcss3", "srcPss1", "srcCcssTwo", "srcCcss52", "srcUcssB", "srcAcss4", "srcCcssL", "srcAccss52", "srcPcss27", "srcChessB", "srcCass1", "srcCcss4", "srcChess2", "srcCfgTwo", "srcUss1", "srcUssTwo", "srcCass52", "srcAccss4", "srcAccss1", "srcCross2", "srcPss2", "srcCfg1", "srcCross1", "srcUcssTwo", "srcCfgB", "srcCss52", "srcCrssL", "srcCssTwo", "srcCrss27", "srcPss27", "srcUcss1", "srcAcss52", "srcCcssB", "srcPcss2", "srcCross4", "srcCcss3", "srcCcss1", "srcAcss2", "srcCssB", "srcUcss2", "srcCfgL", "srcCss27", "srcCrss2", "srcPssL", "srcUssB", "srcPss3", "srcCng1", "srcCrss3"], "destCss2": ["destNcss1", "destNcss2", "destNcssB", "destCfgB", "destCcssB", "destCcss3", "destNcss3", "destCcss4", "destNcss32", "destCest1", "destCss32", "destCssB", "destNss2", "destCestB", "destNss72", "destCest3", "destNss3", "destNss32", "destCess72", "destCess4", "destCfg3", "destCfg32", "destNss4", "destCess1", "destNss1", "destCfg1", "destCcss2", "destNcss72", "destNcss4", "destCss72", "destCfg4", "destCcss32", "destCest2", "destCess32", "destCfg72", "destCess2", "destNssB", "destCcss1", "destCcss72", "destCfg2"], "srcCss3": ["srcRcssThird", "srcCsh183", "srcClass93", "srcCcss2", "srcRcss1", "srcCass1", "srcCcss4", "srcRcss2", "srcPss2", "srcRss4", "srcPcss2", "srcClass15", "srcCsh2", "srcScstyle93", "srcCstyleAND", "srcScss2", "srcCss93", "srcCstyle3", "srcCass2", "srcPcss3", "srcRss3", "srcRcss3", "srcCstyle93", "srcCsh3", "srcCass3", "srcRcss4", "srcCcss3", "srcCcss1", "srcRss1", "srcCcssAND", "srcRssThird", "srcCcss93", "srcCfg2", "srcScstyle15", "srcCcssThird", "srcCshThird", "srcRss183", "srcClass2", "srcCfg1", "srcPss6", "srcScss93", "srcCsl183", "srcCstyle15", "srcCrss6", "srcScss3", "srcCcss15", "srcScss15", "srcCass4", "srcPss3", "srcCrss3", "srcRcss183", "srcCsl2", "srcCsl3", "srcCfg3", "srcCrssAND", "srcScstyle2", "srcPssAND", "srcScstyle3", "srcPcss6", "srcCcss183", "srcCslThird", "srcCcss6", "srcCss15", "srcCss183", "srcClass3", "srcRss2", "srcCstyle6", "srcCfg4", "srcPcssAND", "srcCssAND", "srcCstyle2", "srcCssThird", "srcCrss2"], "destCss3": ["destCstyle03", "destCass43", "destCss03", "destNss43", "destCss43", "destNcss2", "destCcss3", "destPcss03", "destCstyle3", "destScrss6", "destCrss6", "destCross3", "destNcss3", "destCass2", "destCja183", "destPss3", "destCja2", "destPcss3", "destCrss2", "destCss183", "destCass3", "destCcss183", "destCja3", "destCrss3", "destCstyle43", "destNss2", "destCross2", "destScss3", "destPcss53", "destNss3", "destCcss43", "destCross03", "destScrss2", "destCstyle2", "destCcss2", "destCcss6", "destCss53", "destScss6", "destPss53", "destScrss3", "destCcss03", "destPss2", "destCja6", "destCross53", "destNcss43", "destScss183", "destCstyle53", "destScss2", "destPcss2", "destScrss183", "destPss03", "destCrss183", "destCcss53"], "srcCss4": ["srcCass2", "srcCrss1", "srcPcssFour", "srcPcss1", "srcCcss2", "srcPss1", "srcCass1", "srcCcss4", "srcCassFour", "srcCssFour", "srcPss2", "srcPss4", "srcCrssFour", "srcCcssFour", "srcPcss2", "srcCcss1", "srcCrss4", "srcPcss4", "srcPssFour", "srcCrss2", "srcCass4"]}}
{"id1": "189963", "id2": "9449064", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRebwrite", "readAndRebrap", "readAndRewwrite", "readAndSwrap", "readAndrewwrite", "readAndRebrite", "readandRewrap", "readandRewrites", "readAndSwwrite", "readandrewrap", "readAndRewrap", "readAndSwrite", "readandrewrites", "readandrewwrite", "readAndRebrites", "readAndRewrites", "readAndrewrite", "readAndSwrites", "readandrewrite", "readAndrewrites", "readAndrewrap", "readandRewwrite", "readandRewrite"], "inFile": [" inSourceFile", "InSourceFile", "oldfile", "outSourceFile", "inputfile", "outfile", " inFiles", "inputFilename", "InFiles", " infile", "infile", "inputFile", "outFiles", "oldFile", "loginFile", " inFilename", "Infile", "inFiles", "inputFiles", "oldFiles", "loginFilename", "loginfile", "loginFiles", "InFile", "oldFilename", "outFilename", "inFilename", "inSourceFile"], "outFile": ["newfile", "outDir", "OutStream", "processFile", "outputFilename", "exFilename", "outputfile", " outfile", "outPlace", "outFILE", "outputFILE", "outfile", "processFilename", "offFILE", "outputPlace", "thisFilename", "outStream", "thisFile", "processPlace", "exfile", "thisFILE", "newDir", "exFILE", "OutDir", "exFile", "processFILE", "newStream", "offPlace", "OutFile", " outStream", "outFilename", "offFilename", "Outfile", " outDir", "outputFile", "newFile", "thisfile", "offFile"], "iis": ["iIS", "Iais", "iIs", "iiris", "iniIs", "iiiss", "iais", "Iis", "ciis", "iiis", " iIs", " iIS", " iais", "ciiss", "Iiss", "ciais", " iiss", "iiss", "iiIS", "iniiss", " iris", "iniis", "ciris", "iniIS", "iniris", "IIS", "iris", "iiIs", "ciIS", "ciIs"], "dcmParser": ["dbmPolicy", "dbmParser", "dmmLoader", "dmissionParser", "dcmInstallation", "dmoduleJar", "dpmLoader", "dmoduleparser", "dhemReader", "dkmParser", "dmissionLanguage", "dCMPlugin", " dpmparser", " dcrParser", "fpmparser", "dhemJar", " dpmPolicy", "dkmPolicy", "dpmParser", "dcmPolicy", "dmissionPlugin", " dcmarser", "dmmPlugin", " dcrPlugin", "DcmInstallation", " dcmLanguage", "dpmHandler", "dmcJar", "dkmPlugin", " dpmParser", "dmoduleReader", " dcrLoader", "fcmReader", "dmissionReader", "dcrParser", "dmcarser", "dbmHelper", "dmLoader", "fpmHandler", "dcrarser", "dhemInstallation", "dmcParser", "dmmparser", "dpmLanguage", "dmodulePlugin", " dcmPolicy", "dpmarser", "dpmReader", "dcmPar", "dpmPar", "dmReader", "dcmparser", "dcrLoader", "dmParser", " dcmLoader", " dcmReader", "fcmparser", "dpmPolicy", "dcrJar", "dcmPlugin", "dpmparser", "fpmReader", "dcmarser", " dpmPlugin", "dbmPlugin", "dpmPlugin", " dpmHelper", "dCMLoader", " dpmLoader", " dpmJar", "dmoduleParser", " dcrReader", "dcmLoader", "fcmParser", "dpmHelper", "dcmReader", " dpmPar", "dCMHandler", "dmPlugin", "dcmJar", "dcrPlugin", "dpmJar", " dcmJar", "fcmHandler", " dcmHelper", "dCMparser", "dcrPar", "DcmParser", " dcmPar", "dcrReader", "fpmParser", " dpmReader", " dcmparser", "dmcPar", " dpmLanguage", "dcmHelper", "dpmInstallation", "dcmHandler", "dCMParser", "dcmLanguage", "dmmParser", "DcmReader", "dCMReader", "dkmHelper", " dcmPlugin", "DcmJar", "dhemParser", " dpmarser"], "ds": ["services", "ys", "uds", "ays", "DS", "iss", "gd", "sys", "Os", "df", "ants", "ns", "tes", "ks", "drivers", "qs", "bs", "s", "ins", "dr", "is", "dc", "rs", "ld", "dt", "parts", "cdn", "sync", "session", "ws", "d", "ros", "eps", "points", "icks", "ads", "data", "gs", "src", "xs", "utils", "vals", "ras", "Ds", "des", "ts", "conn", "vs", "ls", "js", "ss", "db", "ils", "di", "nas", "details", "amps", "Db", "da", "asi", "cs", "dds", "ps", "os", "dat", "pd", "dd", "tx"], "pdReader": ["hdRunner", "pbRunner", "pcReader", "pdRunner", "xdreader", "dsReader", "dsreader", "pbLoader", "hdReader", "hdreader", "dsLoader", "pcLoader", "pbStream", "hdStream", "ddStream", "pcRead", "xdWriter", "ddLoader", "pdLoader", "pdStream", "ddRunner", "pbReader", "hdWriter", "dsRead", "dsWriter", "xdRead", "pcWriter", "xdReader", "hdRead", "hdLoader", "ddReader", "pdreader", "pdRead"], "out": ["ssl", "base", "temp", "output", "net", "as", "s", "in", "at", "lib", "model", "default", "file", "gen", "conn", "Out", "url", "obj", "with", "external", "point", " in", "outer", "ex", "sys", "lock", "builder", "result", "later", "sync", "part", "cache", "up", "oder", "connection", "w", "parent", "store", "page", "object", "device", "again", "name", "exec", "exp", "array", "full", "over", "list", "order", "inner", "outs", "o", "line", "flow", "co", "write", "password", "session", "doc", "diff", "group", "director", "null", "dev", "io", "writer", "image", "to", "word", "cli", "term", "auto", "her", "copy", "user", "OUT", "child", "manager", "pass", "key", "client", "dot", "login", "inc", "down", "data", "db", "layer", "ext", "err", "code", "img"], "dcmEncParam": ["dcmEnParam", "dcmEstParam", "dcmDecParam", "dcmEnParameter", "dcmSecPart", "dcmDecType", "dcmDecPar", "dcmEncType", "dcmEncParameter", "dcmArchParam", "dcmEncPart", "dcmElParameter", "dcmEnPar", "dcmEnPart", "dcmDecArg", "dcmArchArg", "dcmArchParameter", "dcmSecPar", "dcmEnArg", "dcmDecParameter", "dcmDecPart", "dcmSecType", "dcmElParam", "dcmEstPar", "dcmEncPar", "dcmSecParam", "dcmElPar", "dcmEncArg", "dcmElType", "dcmEnType", "dcmEstType", "dcmEstParameter"], "pdWriter": ["dpWrite", "pdOutput", "ddWrite", "pdWriting", "htWriter", "dpReader", "dsReader", "hdReader", "pdWrite", "htWriting", "dpWriting", "PDWrite", "dpWriter", "hdWriter", "dsOutput", "dsWriter", "hdWrite", "htWrite", "PDWriter", "dsWrite", "ddOutput", "PDReader", "ddReader", "htReader", "PDWriting", "ddWriter", "hdOutput"]}}
{"id1": "5061606", "id2": "10385815", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNequessnecessary", "createSettingsIfNececarily", "createSettingsIfNecccessnecessary", "createSettingsIfNecesnecessary", "createSettingsIfNecccesseless", "createSettingsIfNecccessarily", "createSettingsIfNecessnecessary", "createSettingsIfNecesary", "createSettingsIfNequccessarily", "createSettingsIfNequccessnecessary", "createSettingsIfNecessarily", "createSettingsIfNecccessary", "createSettingsIfNeceseless", "createSettingsIfNecesseless", "createSettingsIfNequessarily", "createSettingsIfNequessary", "createSettingsIfNececnecessary", "createSettingsIfNececeless", "createSettingsIfNequesseless", "createSettingsIfNececary", "createSettingsIfNecesarily", "createSettingsIfNequccesseless", "createSettingsIfNequccessary"], "out": ["index", "path", "i", "ex", "output", "copy", "server", "editor", "user", "timeout", "by", "lock", "net", "plain", "OUT", "socket", "result", "outs", "o", "window", "pool", "write", "off", "bin", "exit", "password", "sync", "client", "at", "source", "cache", "up", "connection", "model", "group", "parent", "data", "file", "channel", "config", "page", "object", "log", "null", "conn", "init", "plugin", "again", "name", "exec", "Out", "io", "writer", "image", "array", "prefix", "a", "flush", "app", "url", "err", "obj", "cookie", "error", "this"], "fSettings": ["rfFs", "sfSetting", "FConfig", "fsettings", "fJs", " fFs", " fettings", "sfsettings", "fsConfig", " fSetting", "fFs", "FSetting", "filesettings", " fJs", "fsFs", "fileSettings", "fettings", "fsSetting", "fSetup", "rfSettings", "FSetup", " fConfig", "fmConfig", "fileettings", "FJs", " fsettings", "rfSetting", "fmSetup", "fileSetting", "Fsettings", "fsSettings", "sfJs", "FSettings", "sfettings", "fConfig", "fmSetting", "sfSettings", "fsSetup", "fSetting", "rfConfig", "fmSettings"], "src": ["path", "string", "base", "sel", "ssl", "sc", "uri", "rc", "lower", "settings", "filename", "ref", "cb", "dest", "fp", "loc", "ins", "prot", "sub", "req", "gb", "rb", "source", "sb", "uc", "ctr", "dist", "str", "config", "file", "tmp", "attr", "route", "text", "storage", "sl", "url", "stream", "ource", "b", "st", "cur", "sr", "img"], "in": ["IN", "index", "path", "sin", "i", "input", "n", "copy", "id", "ini", "gin", "con", "c", "inner", "l", "ins", "s", "bin", "source", "reader", "thin", "login", "connection", "r", "inc", "data", "file", "rin", "init", "again", "image", "In", "kin", "url", "stream", "b", "err", "inn", "f", "win", "din"]}}
{"id1": "15051083", "id2": "23677147", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 0, "substitutes": {"getMessageDigest": ["getmessageDigests", "getmessageDigature", "getmessageDigest", "getmessagedigest", "getMessagedigester", "getMessageDesignature", "getMessageHashature", "getmessageDigester", "getMessageDigester", "getMessageDesignester", "getmessagedigature", "getMessageHashester", "getMessagedigature", "getMessageHashests", "getMessageDigature", "getMessagedigests", "getMessageDesignests", "getMessagedigest", "getMessageHashest", "getmessagedigester", "getmessagedigests", "getMessageDigests", "getMessageDesignest"], "digest": ["Digester", "signester", "hexex", "hexests", "DigEST", "Diger", "sandesting", " Digeter", " Dighed", " digeter", " Diger", " Digester", "signest", "Digex", " digested", " diger", "dighed", "hexEST", "Dighed", "signiter", "digex", " digEST", "signested", "Digests", " digger", "feedested", "digester", "signesting", "greatiter", "Digeter", " Digest", "digested", "digests", "sandest", "digger", "greatester", "sandester", "Digesting", "Digest", " digex", " dighed", "digeter", "sandested", "diger", " Digger", "Digger", " digester", "Digiter", "greatest", "greatested", "feedester", "hexest", " digests", "Digested", "feedest", "digiter", "digEST", "digesting"], "node": ["event", "remote", " Node", "root", "address", "index", "path", "self", "n", "resource", "server", "uri", "document", " nodes", "Node", "instance", "location", "child", "global", "one", "source", " parent", "connection", "module", "component", "config", "parent", "route", "entity", "local", "object", "name", "internal", " child", "ode", " namespace", " source", "network", " annotation", "odes", "element", "point"], "external": ["remote", "ex", "n", "resource", "outer", "secondary", "intern", "ternal", "instance", "account", "global", " External", "outside", "client", "source", "binary", "target", "international", "out", "export", "https", "local", "object", "environment", " remote", "multiple", " global", "External", "internal", "name", "e", "tern", "Intern", "reference", "network", " foreign", "foreign", "element"], "messageDigest": ["messageModested", " messageDigger", "messageMarkest", " messageDigesting", " messageHashest", "messageDigger", "MessageDigester", "messageDigenge", "messageDesignested", "messageDesignger", "messageDested", "messageHashesting", "messagedigest", "messagedigester", "messageDigester", "MessageSignenge", "messageHashester", " messageHashesting", "messageHashested", " messageDigester", "MessageSignested", "messageMarkested", "MessageDigested", "messageSignenge", "messageDigesting", " messageDesignested", "MessageSignest", "messageModester", "messageDest", "messageModest", "messageMarkester", " messageHashested", "messageDigested", " messageDesignester", " messageDigested", "messageSignester", "messageDester", "messagedigger", "messagedigested", "MessageSignester", "messageMarkenge", " messageHashester", "messageSignested", "messageModesting", "messageDenge", "MessageDigest", " messageDesignger", "messageDesignester", "messageDesignest", "messageSignest", "messageDesignesting", "MessageDigenge", "messageHashest", " messageDesignest"]}}
{"id1": "771802", "id2": "4716110", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"createOutputStream": ["createInputFile", " createByteStream", " createInputStream", " createByteSteam", " createOutputReader", " createOutputSteam", " createOutputFile", " createInputReader", "createOutputFile", " createIOSteam", " createByteReader", "createInputSteam", " createIOFile", " createInputFile", "createInputReader", "createOutputReader", "createInputStream", " createIOStream", "createOutputSteam", " createByteFile", " createIOReader", " createInputSteam"], "inFile": ["incFile", "inStream", "inputfile", "outfile", "infile", "inputFile", "outFiles", "sourceFile", "incfile", "outStream", "sourceFiles", "incStream", "insFiles", "inFiles", "insStream", "sourcefile", "inputFiles", "insfile", "incFiles", "inputStream", "sourceStream", "insFile"], "outFile": [" outDirectory", "workFile", "outDir", "inTime", " outfile", "inputTime", "inputfile", "outTime", "outfile", "workfile", "infile", "inputFile", "targetfile", "outStream", "inputDir", "workingDirectory", "workingfile", "targetStream", "inDir", "workTime", "outDirectory", "targetDirectory", "workDir", " outStream", "workingFile", "workingStream", "targetFile"], "k_blockSize": ["k_blockCount", "k_byteCount", "k_byteInfo", "k_lockCount", "k_blocksCount", "k_byteLength", "k_bitInfo", "k_blocksLen", "k_byteLen", "k_lockCode", "k_blocksLength", "k_BlockSize", "k_lockLength", "k_BlockCount", "k_byteCode", "k_blockInfo", "k_lineInfo", "k_lockSize", "k_blocksSize", "k_BlockCode", "k_bitCount", "k_byteSize", "k_blockCode", "k_bitSize", "k_BlockLength", "k_blockLength", "k_lineCount", "k_lineSize", "k_blockLen", "k_lockLen"], "byteCount": ["byteLength", "blockLength", "ByteLength", "byteLen", " bytecount", "ByteLen", "ByteSize", " byteSum", "characterLength", "flushcount", "characterCount", "blockCount", "byteSum", "flushCount", "ByteSum", "ByteCount", " byteSize", "blockSize", "flushLength", " byteLength", "Bytecount", "blockSum", "characterSize", "characterLen", " byteLen", "flushSize", "bytecount", "byteSize"], "buf": ["base", "buffer", "border", "Buffer", "bf", "alloc", "feed", "rc", "bh", "cap", "cb", "loc", "result", "feat", "queue", "uf", "la", "bag", "cv", "rb", "cas", "buff", "len", "data", "config", "src", "tmp", "fb", "exc", "append", "background", "brace", "vec", "font", "ucc", "fd", "bytes", "ctx", "flush", "Buff", "seq", "b", "batch", "cmd", "img"], "ofp": ["OFnp", "Ofnp", "afl", "Oft", "ofl", "oft", "OFtp", "oftp", "OFt", "OFp", "ofnp", "OFl", "fortp", "afp", "OFc", "Ofl", "forp", "afc", "fort", "Ofc", "forc", "Oftp", "Ofp", "ofc", "afnp"], "zos": ["zip", "css", "tz", "zyk", "fits", "zy", "bos", "zar", "zers", "zona", "js", "gz", "enos", "zi", "lins", "zin", "zl", "uz", "ZA", "zo", "liquid", "utils", "ogl", "iffs", "dylib", "ZI", "hz", "z", "bs", "modules", "rons", "packs", "za", "bes", "zig", "zx", "nox", "zb", "oS", "lol", "webkit", "nz", "los", "zen", "zag", "cfg", "zn", "cos", "budget", "core", "oses", "zes", "robe", "iframe", "outs", "soon", "zh", "ws", "ossus", "owicz", "forge", "ses", "jas", "ozo", "os", "osi", "kos", "zer", "oda", "obb", "zon", "ros", "ops", "inos", "ls", "obs", "rez", "bitcoin", "zik", "abi"], "osw": ["osnow", "esnow", "osfw", "osssw", "bsw", "ossd", "esfw", "lsws", " osow", "ossfw", "osd", "osy", " osww", "isd", " osfw", "osww", "essw", "ossy", "esd", "iswd", "bsws", "esww", "osow", "bx", "bswo", "lsw", "ossow", "oswo", "oswd", "lswo", "isy", "bwo", "isnow", "ossw", "lsx", "bsx", "ossnow", "issw", "esy", "ossww", "esw", "oshell", "osx", "osshell", "esow", "osswd", "bws", "eswd", "ishell", "osws", "eshell", "isw"], "bw": ["bbew", "bbws", "fbw", "bsw", "owu", "bbwh", " baw", "bbz", "fbwd", "bbw", "lbwh", "lw", "owa", "lbx", "fwh", "lwa", "bwu", "oaw", "bW", "abw", "fw", "bbwa", "fwa", "fr", "bwe", " bew", "Bew", "ebwe", "Bwa", " bz", "ebwd", " bwu", "bx", "lsw", " bws", "bew", " bwa", "Bw", "bbwu", " bwh", "lbr", "Bws", "abwd", "abwe", "lbws", "ebw", "lbwa", "fbW", "bwa", "fsw", "lbsw", "fbwe", "bwd", "bz", "lbw", "lbz", "ebW", "bws", "bwh", "baw", "ow", "bbaw", "abW", "lx", "fx"], "zot": ["Ziot", "jori", "Zor", "azit", " ziot", "zerori", "azita", "jot", "zerot", " zor", "Zot", "zeros", "zerott", "Zott", "azot", "ziot", "azott", "zor", "zerit", "Zit", "zerita", "jit", " zori", "zita", "jos", "zott", "aziot", "Zita", "azor", "zori"], "ifp": [" ifl", " iff", " ifb", "ipp", " ifi", "ifl", "Iff", "ipl", "ifc", "ifb", "IFc", "iff", "ipc", "ipb", "IFi", "IFf", " ifc", "Ifc", "ifi", "Ifp", "IFl", "IFb", "IFp", "Ifi"], "zis": ["jisi", "zip", "zeiss", "jis", "zib", "zipits", "xis", "xit", "zais", "zIS", "Zip", " zib", "xits", "xisi", "jits", "Ziss", "zenis", "Zits", " zIS", "ziss", "zeis", "zenIS", "zipiss", "zipis", "zeip", "xais", " zais", "xib", "zisi", "xIS", "zipip", "zeits", "Zis", "jit", "zenais", " zisi", "zenib", " zits", "zits"], "isr": ["ispr", "rispr", "isrc", "ISsr", "risr", " iscr", " isrs", "irpr", "ISrc", "isssr", "IScr", "isrb", "irrb", "ISr", " issr", "iscr", "isscr", "risrb", "risrc", "ISpr", "issr", "irr", "isrs", "ISrb", "ISrs", "irrc", "issrs"], "br": [" BR", "obl", "bh", "HR", "rib", "ibr", "lr", "fr", " dr", "mr", "rs", "shr", "bro", "obi", "arr", "BR", "bar", " fr", "rb", "ctr", "browser", "ocr", "r", "ch", "Br", "str", "ob", "div", " Br", "body", "ibl", "yr", "gr", "cro", "tr", "bc", "bp", "hr", "b", "kr", "bl", "err", "sp", "bsp", "ber", "sr", "img"], "zit": ["jita", "zip", "jite", "zeIT", "jic", "zite", "jIT", " zi", "zenits", "zipita", "zitter", "zipits", " zite", "xit", "xith", "zIT", "zipite", "zic", " zip", "zeith", "ji", "zenith", "zeitter", "jits", "zith", " zith", "zenitter", "jip", "zeita", "zenit", "zi", "zipitter", "zipip", " zic", "xi", "zipith", "jith", "zipIT", "zeits", "zeit", "jit", "zita", "xic", " zits", "zits", "zipit"]}}
{"id1": "13783898", "id2": "2668634", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFiletoFiles", "encodeFileToFiles", "encodeFiletoFile", "encodeString2File", "encodeString2Stream", "encodeFileToStream", "encodeFileFromStream", "encodeStringToStream", "encodeFileFromFile", "encodeString2String", "encodeFile2Files", "encodeStringToFile", "encodeFile2File", "encodeFileToString", "encodeString2Files", "encodeFiletoString", "encodeStringToString", "encodeFile2Stream", "encodeFiletoStream", "encodeStringToFiles", "encodeFileFromString", "encodeFileFromFiles", "encodeFile2String"], "infile": ["infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", " infp", "inputfp", "inputFile", "outfiles", " infilename", "inputfiles", "Infilename", " infiles", "outfp", "Infile", "InFile", "inputfilename", "infilename", "Infiles"], "outfile": ["newfile", "Outname", "infp", "outfilename", "outputfile", "outFile", "newname", " outFile", "infolder", " outfolder", "outputfolder", "newfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "Outfolder", " outname", "outname", "OutFile", "Outfile", "infilename", "newFile", " outfilename"], "in": ["IN", "base", "pin", "i", "input", "inas", "sin", "id", "ini", "gin", "into", "ic", "con", "inner", "as", "socket", "ins", "s", "bin", "pass", "is", "reader", "source", "thin", "login", "min", "inside", "r", "inc", "data", "rin", "vin", "init", "conn", "again", "m", "image", "re", "isin", "In", "nin", "a", "err", "b", "ac", "cin", "inn", "win", "din"], "out": ["base", "ou", "job", "ex", "output", "outer", "copy", "timeout", "on", "net", "OUT", "socket", "inner", "outs", "o", "off", "write", "bin", "co", "line", "exit", "post", "client", "sync", "session", "no", "cache", "source", "one", "up", "lib", "inc", "parent", "work", "file", "conn", "or", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "In", "err", "obj", "error", "point"], "buffer": ["address", "base", "Buffer", "input", "uffer", "feed", "server", "border", "slice", "limit", "result", "length", "write", "queue", "offset", "iter", "split", "raw", "type", "reader", "cache", "binary", "source", "seed", "buff", "value", "buf", "len", "wave", "data", "fb", "size", "bb", "null", "bytes", "layer", "flush", "url", "b", "reference", "count", "padding", "transfer", "batch"], "read": ["play", "close", "i", "input", "Read", "feed", "n", "copy", "reading", "id", "add", "ind", "slice", "current", "end", "limit", "run", "se", "find", "length", "write", "reads", "ride", "pass", "sleep", "ad", "iter", "next", "raw", "sync", " count", "select", "allow", "use", "load", "reader", " Read", "len", "seek", "work", "inc", "check", " copy", "ip", "size", "x", "get", "fill", "start", "exec", "io", "lex", "send", "tell", "_", "parse", "connect", "wait", "count", "READ", " write", " skip", "f"], "success": ["respons", "roll", "error", "path", "response", "rolling", "continue", "results", "ceed", "modified", "xx", "message", "primary", "warning", "better", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "model", "default", "open", "data", "growth", "flash", "null", "cess", "danger", "complete", "again", "status", " successful", "good", "Success", "comment", "right", "successful", "successfully", "rolled", " succ", "method", "fast", "first", "winner", "initial"]}}
