{"id1": "20275821", "id2": "14819747", "code1": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "label": 0, "substitutes": {"getAttribute": ["createFeature", " getFile", "GetFeature", "setAttributes", "Getattribute", " getFeature", "setAtt", " getAtt", " getAttributes", "getFeature", "GetFile", "setAttribute", "createAttribute", "getattribute", "createattribute", "getAttributes", "GetAttribute", "setattribute", "getAtt", "getFile", " getattribute", "createFile", "createAttributes", "createAtt"], "url": ["connection", "sl", "f", "loc", "name", "version", "socket", "email", "ur", "el", "base", "class", "log", "ssl", "lc", "page", "conn", "cache", "user", "l", "bug", "client", "address", "Url", "proxy", "URL", "source", "image", "api", "request", "path", "object", "context", "config", "server", "uri", "route", "http", "c", "file", "resource", "host", "link", "rl", "string", "il"], "con": ["connection", "open", "cur", "ver", "login", "f", "cn", "version", "fl", "socket", "un", "ca", "rev", "non", "ex", "en", "ec", "pc", "rc", "log", "ssl", "fun", "lc", "plain", "per", "conn", "cache", "user", "conf", "can", "cr", "fn", "Con", "ran", "client", "sub", "cc", "run", "db", "connect", "uc", "CON", "cf", "ch", "exec", "ocon", "cl", "close", "conv", "http", "c", "func", "file", "fa", "com", "co", "on", "coll", "ctrl", "cm", "cover", "ln", "re", "fc", "bc", "ob", "cons"], "response": ["connection", "answer", "version", "ception", "error", "reason", "respond", "body", "received", "Response", "status", "successful", "size", "output", "success", "reply", "respons", "image", "value", "request", "next", "number", "code", "uri", "server", "route", "http", "xx", "function", "index", "message", "result", "resource", "length", "onse", "json", "resp", "site"], "redirect": ["rdication", "Redocol", "Redirect", "radocol", "rerirection", "undirect", "rdirect", "reriff", "rediff", "Redirection", "rdocol", "radirection", "undiff", "undred", " redred", "redication", "rerirect", "rerred", " rediff", "redred", " redirection", "radirect", "rdirection", "undirection", "redocol", "Redication", "redirection", "radication"], "location": ["feature", "connection", "localhost", "region", "loc", "data", "layout", "origin", "error", "remote", "reference", "language", "type", "layer", "local", "direction", "position", "format", "description", "content", "href", "LOC", "collection", "address", "path", "filename", "object", "document", "uri", "route", "null", "file", "message", "Location", "resource", "link", "directory", "length", "area", "string"]}}
{"id1": "9802073", "id2": "17190057", "code1": "    public void testAutoCommit() throws Exception {\n        Connection con = getConnectionOverrideProperties(new Properties());\n        try {\n            Statement stmt = con.createStatement();\n            assertEquals(0, stmt.executeUpdate(\"create table #testAutoCommit (i int)\"));\n            con.setAutoCommit(false);\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (0)\"));\n            con.setAutoCommit(false);\n            con.rollback();\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (1)\"));\n            con.setAutoCommit(true);\n            con.setAutoCommit(false);\n            con.rollback();\n            con.setAutoCommit(true);\n            ResultSet rs = stmt.executeQuery(\"select i from #testAutoCommit\");\n            assertTrue(rs.next());\n            assertEquals(1, rs.getInt(1));\n            assertFalse(rs.next());\n            rs.close();\n            stmt.close();\n        } finally {\n            con.close();\n        }\n    }\n", "code2": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "label": 0, "substitutes": {"testAutoCommit": ["testAutoDebite", "testSyncCommIT", "testAutoDebit", "testAutoComit", "testSyncDebits", "testSyncDebIT", "testAutoComite", "testAutoDebits", "testAutoCommite", "testAutoDebIT", "testAutoommits", "testAutoommit", "testSyncCommits", "testAutoComIT", "testAutoCommits", "testSyncDebit", "testAutoommite", "testAutoommIT", "testAutoCommIT", "testSyncDebite", "testSyncCommit", "testSyncCommite", "testAutoComits"], "con": ["lock", "pool", "class", "win", "common", "ctx", "ocon", "close", "pen", "conv", "c", "com", "co", "coll", "ctrl", "sql", "fc", "cur", "session", "m", "syn", "pub", "en", "pc", "log", "conn", "cache", "conf", "client", "context", "Connection", "bc", "act", "union", "ver", "cn", "util", "un", " conn", "ct", "cr", "pre", "fn", "ran", "cc", "cond", "connect", "config", "n", "platform", "an", "crit", "tc", "cas", "mc", "col", "connection", "fac", "ca", "sync", "non", "min", "gen", "rc", "pr", "can", "Con", "db", "uc", "CON", "cf", "cl", "core", "Conn", "cm", " CON", "ac"], "stmt": ["Stnt", "estmt", "rmd", " stbl", "slur", " stmb", "Stmn", " stmn", "STmb", "estMT", "STbl", "stMT", "STnt", " stor", "estmb", "Stmt", " stnt", "rorp", "Stor", "Stpt", " storp", "stmp", "stmd", "STMT", "ctmp", "Stb", " stm", " stpt", " stMT", "Stmb", "STmt", " stb", "ctmb", "STsp", " stmd", " stur", "rb", "Stbl", "STm", "slmp", "slmn", "estsp", "storp", " stmp", " stsp", "stbl", "ctor", "Storp", "stmn", "STmp", "stor", "stm", "slmt", "Stm", "STpt", "stpt", "stmb", "Stmp", "Stmd", "stb", "stsp", "stnt", "rmt", "stur", "Stur", "ctmt"], "rs": [" rc", "mr", "reader", "RC", " RS", "rows", "RS", "eers", "sc", "ins", "ubs", "results", "Rs", "acks", "vers", "relations", "rc", "cs", " sr", "ls", "pr", "cr", "r", "ra", "repl", "runs", "rr", "rys", " r", "ras", "row", "hs", "hr", " res", "ars", "xs", "rd", "errors", "rt", "ps", "ris", "sr", "src", "rss", "ry", "ros", "res", " results", " Rs", "ges", "ms", "rl", " rows", "ows", "rx"]}}
{"id1": "19113613", "id2": "8150996", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"copy": ["save", "get", "archive", "rm", "create", "put", "type", "change", "sync", "p", "download", "opy", "move", "load", "Cop", "share", "zip", "clip", "cop", "paste", "cat", "Copy", "process", "delete", "update", "transfer", "ssh", "split", "clone", "upload", "replace", "cp", " cp", "write"], "in": ["reader", "bin", "connection", "login", "f", "data", "sin", "name", "get", "ins", "pin", "cin", "min", "In", "base", "plugin", "inside", "kin", "part", "inner", "again", "win", "old", "din", "work", "IN", "client", "this", "ini", "i", "image", "init", "inc", "project", "url", "update", "config", "n", "thin", "inn", "c", "as", "id", "index", "a", "ic", "lin", "on", "input", "token", "diff"], "out": ["x", "connection", "bin", "app", "ext", "outside", "name", "point", "self", "version", "at", "remote", "p", "ex", "outs", "one", "base", "page", "conn", "b", "again", "output", "cache", "vert", "goal", "part", "user", "line", "work", "root", "err", "dot", "o", "off", "client", "OUT", "this", "external", "call", "block", "image", "init", "inc", "project", "path", "exec", "object", "parent", "outer", "v", "other", "no", "n", "group", "null", "io", "net", "c", "up", "resource", "input", "with", "Out", "obj", "option"], "source": ["feature", "missing", "iter", "sin", "alt", "family", "name", "force", "origin", "type", "reference", "from", "secure", "base", "direction", "ource", "position", "component", "class", "status", "format", "size", "SOURCE", "dest", "subject", "secret", "service", "proxy", "project", "parent", "url", "attribute", "view", "uri", "unit", "route", "pe", "scope", "ce", "id", "prefix", "src", "resource", "Source", "internal", "use", "username", "site"], "target": ["wrong", "alt", "current", "name", "point", "force", "origin", "master", "arget", "reference", "detail", "top", "direction", "base", "format", "component", "output", "goal", "alias", "root", "dest", "address", "service", "cat", "template", "value", "project", "path", "parent", "pattern", "next", "url", "tail", "config", "route", "null", "Target", "prefix", "src", "resource", "about", "host", "token", "home", "site"], "files": ["pages", "f", "images", "data", "sections", "blocks", "s", "ins", "groups", "results", "Files", "cells", "items", "ls", "models", "obs", "features", "flows", "apps", "tools", "lines", "assets", "objects", "filename", "iles", "classes", "names", "ions", "keys", "jobs", "ports", "links", "users", "plugins", "resources", "docs", "fs", "children"], "file": ["le", "f", "data", "current", "name", "it", "File", "el", "layer", " File", "load", "fe", "local", "letter", "base", "binary", "per", "future", "page", "part", "b", "entity", "l", "line", "single", "e", "lib", "entry", "live", "child", "ile", "feed", "path", "filename", "object", "parent", "url", "uri", "unit", "folder", "id", "function", "item", "FILE", "resource", "dir", "fp", "directory", "string"], "inCh": ["INChannel", "INChan", " inChannel", "outCH", "InChan", "inch", "InCh", " inChan", "INCh", "outch", " inch", "Inch", "outChan", "inChannel", "INCH", "InCH", "inChan", " inCH", "outChannel", "InChannel", "inCH"], "outCh": ["outputCh", "outputChan", "outCH", "OutCh", "inch", "OutChan", "outch", "outChan", " outChannel", "inChannel", "Outch", "OutChannel", "inChan", "outputch", " outch", "outputCH", "outChannel", "inCH", " outCH", "OutCH"]}}
{"id1": "23296117", "id2": "19747399", "code1": "    public static void extractNativeLib(String sysName, String name, boolean load, boolean warning) throws IOException {\n        String fullname = System.mapLibraryName(name);\n        String path = \"native/\" + sysName + \"/\" + fullname;\n        URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n        if (url == null) {\n            if (!warning) {\n                logger.log(Level.WARNING, \"Cannot locate native library: {0}/{1}\", new String[] { sysName, fullname });\n            }\n            return;\n        }\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        File targetFile = new File(getExtractionDir(), fullname);\n        OutputStream out = null;\n        try {\n            if (targetFile.exists()) {\n                long targetLastModified = targetFile.lastModified();\n                long sourceLastModified = conn.getLastModified();\n                if (targetLastModified + 1000 > sourceLastModified) {\n                    logger.log(Level.FINE, \"Not copying library {0}. Latest already extracted.\", fullname);\n                    return;\n                }\n            }\n            out = new FileOutputStream(targetFile);\n            int len;\n            while ((len = in.read(buf)) > 0) {\n                out.write(buf, 0, len);\n            }\n            in.close();\n            in = null;\n            out.close();\n            out = null;\n            targetFile.setLastModified(conn.getLastModified());\n        } catch (FileNotFoundException ex) {\n            if (ex.getMessage().contains(\"used by another process\")) {\n                return;\n            }\n            throw ex;\n        } finally {\n            if (load) {\n                System.load(targetFile.getAbsolutePath());\n            }\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n        logger.log(Level.FINE, \"Copied {0} to {1}\", new Object[] { fullname, targetFile });\n    }\n", "code2": "    @Before\n    public void setUp() throws Exception {\n        connectionDigestHandler = new ConnectionDigestHandlerDefaultImpl();\n        URL url = null;\n        try {\n            url = new URL(\"http://dev2dev.bea.com.cn/bbs/servlet/D2DServlet/download/64104-35000-204984-2890/webwork2guide.pdf\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        }\n        try {\n            uc = url.openConnection();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"extractNativeLib": ["extractnativeLib", "extractNativelib", "extractednativeLib", "extractLibraryLib", "extractRemoteLib", "extractedNativeLib", "extractLibraryLibrary", "extractnativelib", "extractednativelib", "extractnativeLibrary", "extractednativeLibrary", "extractRemoteLibrary", "extractedNativeLibrary", "extractedNativelib", "extractNativeLibrary", "extractLibrarylib", "extractRemotelib"], "sysName": [" sysPath", "libPath", "sysPath", "systemTitle", "systemPath", " sysDir", "libname", "sysTitle", "ysPath", "ysname", "sysFull", "SysFull", " sysname", "Sysname", "SysPath", "libName", "systemname", "systemFull", "libTitle", "SysName", "ysName", "sysname", "systemName", "sysDir", "systemDir", "SysDir", " sysFull", " sysTitle"], "name": ["connection", "data", "type", "na", "nam", "label", "base", "plugin", "part", "cache", "loader", "size", "root", "key", "source", "filename", "system", "no", "nice", "Name", "n", "number", "default", "file", "title", "word", "prefix", "id", "resource", "named", "nm", "string", "NAME", "username"], "load": ["lock", "save", "open", "loaded", "start", "get", "force", "play", "create", " reload", "sync", "ck", "download", "dump", "launch", "set", "rc", "add", "copy", "require", "check", "LOAD", "loader", "loading", "cache", "include", "callback", "l", "zip", "pull", "test", "call", "comment", "oad", "parse", "cli", "pack", "init", "loads", "close", "cl", "delete", "read", "null", "Load", "hack", "fail", "skip", "link", "leaf", "progress", "push", "write", "use", "wait", "remove"], "warning": ["Warning", "ew", "error", "alert", "ww", "fw", "auto", "WARN", "web", "only", "warn", "wild", "misc", "acl", "loader", "loading", "notice", "blocking", "success", "watch", "random", "lang", "external", "comment", " warnings", "war", "wa", "breaking", "ws", "aw", "weak", "message", "WARNING", "resource", "initial", "fp", "leaf", "generation", " warn"], "fullname": ["realpath", "fulbase", " fullnode", "fullbase", "realName", "fullNAME", "flatpath", "fullpath", " fullnamed", " fullbase", "fulName", "Fullname", "FullNAME", " fullName", "fullybase", "flatName", "fullyName", " fullkey", "fulkey", " fullNAME", "fullykey", "fullypath", "flatnamed", "fullnode", "Fullnode", "realnamed", "Fullpath", " fullnumber", "fulname", "realname", "fullName", "realNAME", " fullpath", "fulpath", "Fullnumber", "FullName", "fullynumber", "Fullnamed", "fullyname", "fullnumber", "fullnamed", "flatname", "fulnode", "fullkey"], "path": ["full", "data", "type", "method", "filter", "enc", "str", "base", "log", "part", "loader", "text", "cache", "work", "root", "key", "pointer", "image", "api", "parent", "object", "filename", "pattern", "context", "config", "uri", "code", "route", "file", "id", "PATH", "ath", "Path", "resource", "link", "ref", "location", "string"], "url": ["connection", "sl", "f", "loc", "org", "fl", "channel", "ur", "download", "log", "base", "ll", "ssl", "bb", "blog", "loader", "l", "fr", "address", "Url", "lib", "URL", "source", "image", "service", "api", "lr", "config", "uri", "server", "http", "file", "impl", "src", "resource", "www", "coll", "bel", "link", "location", "rl", "string", "serv", "ob", "il"], "conn": ["connection", "nt", "open", "lock", "cb", "loc", "cn", "reg", "org", "socket", "nc", "channel", "session", "ct", "sync", "dn", "enc", "ann", "rc", "log", "ssl", "conf", "l", "err", "client", "cmp", "cli", "init", "ctx", "connect", "ch", "api", "config", "n", "conv", "rt", "io", "net", "c", "Conn", "http", "coll", "con", "fp", "cp", "Connection", "serv", "ob", "resp", "act"], "in": ["reader", "bin", "connection", "lock", "login", "f", "data", "socket", "s", "ins", "pin", "sync", "cin", "min", "In", "ie", "ssl", "inside", "kin", "b", "inner", "again", "part", "cache", "win", "din", "r", "pre", "IN", "err", "client", "pull", "ini", "this", "i", "source", "init", "image", "inc", "child", "nin", "request", "exec", "like", "config", "n", "inn", "c", "file", "up", "id", "index", "a", "src", "ic", "on", "lin", "input", "con", "resource", "ac", "gin", "serv"], "targetFile": [" targetDirectory", "argetClass", "hostDir", "sourceDir", "resourceDir", "hostStream", " targetFolder", "TargetDir", "argetFiles", "targetDir", "sourceDirectory", " targetPath", " targetfile", "targetStream", "sourceFiles", "TargetDirectory", "targetfile", "resourcefile", "TargetStream", " targetLine", "argetfile", "TargetClass", "argetFile", "hostFile", "targetPath", " targetStream", "Targetfile", "sourcePath", "targetClass", "hostfile", "targetFiles", " targetDir", "sourcefile", " targetClass", "TargetPath", "argetPath", "TargetFile", "targetDirectory", "sourceLine", "targetLine", "resourceLine", "sourceFolder", "resourceFile", "TargetFiles", "sourceFile", "argetFolder", "resourceDirectory", " targetFiles", "targetFolder"], "out": ["connection", "bin", "lock", "app", "ext", "login", "doc", "socket", "at", "error", "sync", "ex", "one", "plain", "log", "page", "cache", "again", "output", "inner", "w", "part", "user", "cmd", "writer", "line", "err", "o", "client", "key", "OUT", "temp", "off", "call", "comment", "source", "block", "init", "image", "inc", "exec", "outer", "parent", "sum", "default", "n", "group", "null", "server", "io", "net", "post", "file", "up", "prefix", "co", "result", "resource", "on", "target", "token", "exp", "Out", "obj", "option", "buf"], "targetLastModified": ["targetFirstMODed", "targetFirstModed", "targetLastModed", "targetLastPedIFIED", "targetFirstMinified", "targetLastModocked", "targetFirstMODified", "targetFirstMinIFIED", "targetLastPedamed", "targetLastMODamed", "targetLastMODified", "targetLastMODIFIED", "targetFirstModamed", "targetLastMinIFIED", "targetLastModamed", "targetLastMified", "targetLastModIFIED", "targetFirstModIFIED", "targetLastSemocked", "targetLastMocked", "targetFirstMODification", "targetFirstMined", "targetLastMODocked", "targetLastSemified", "targetFirstModification", "targetLastMed", "targetFirstModocked", "targetLastMification", "targetLastSemification", "targetLastPeded", "targetLastMinified", "targetFirstModified", "targetLastMinamed", "targetLastPedified", "targetLastMODed", "targetFirstMinamed", "targetFirstMODocked", "targetLastModification", "targetLastSemed", "targetLastMined", "targetLastMODification"], "sourceLastModified": ["sourceFirstMODified", "sourceLastImated", "sourceLastmoded", "sourceLastmodIFIED", "sourceFirstMODated", "sourceFirstMODIFIED", "sourceLastMODed", "sourceLastModed", "sourceLastImed", "sourceLastMated", "sourceLastImified", "sourceFirstMODed", "sourceLastMODated", "sourceFirstModated", "sourceFirstMODification", "sourceFirstModIFIED", "sourceFirstModification", "sourceLastMODified", "sourceLastModated", "sourceLastMODIFIED", "sourceLastMed", "sourceLastModIFIED", "sourceLastMined", "sourceLastModification", "sourceLastImification", "sourceLastmodified", "sourceLastMinIFIED", "sourceLastMification", "sourceLastMified", "sourceFirstModed", "sourceLastMinified", "sourceFirstModified", "sourceLastMODification"], "len": ["nt", "bin", "le", "sl", "iter", "f", "data", "fl", "lim", "el", "body", "min", "en", "str", "lc", "part", "size", "num", "lon", "l", "line", "val", "err", "lf", "count", "z", "limit", "no", "cl", "n", "li", "net", "id", "pos", "lin", "fin", "Len", "length", "ln", "ler", "end"]}}
{"id1": "13644374", "id2": "4716110", "code1": "    public byte[] getBytesFromUrl(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toByteArray(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"getBytesFromUrl": ["getbytesFormUrl", "getBytesFormString", "getBytesFromString", "getBytesFromRoute", "getbytesFormRoute", "getbytesFormString", "getbytesFormURL", "getBytesfromUrl", "getBytesfromRoute", "getBytesFormURL", "getBytesFromURL", "getBytesViaString", "getbytesFromUrl", "getBytesfromString", "getBytesViaRoute", "getBytesViaUrl", "getBytesFormUrl", "getBytesFormRoute", "getBytesfromURL", "getbytesFromRoute", "getbytesFromString", "getBytesViaURL", "getbytesFromURL"], "url": ["connection", "sl", "data", "loc", "name", "email", "ur", "method", "download", "str", "xml", "base", "page", "href", "l", "key", "address", "Url", "i", "URL", "buffer", "service", "source", "api", "request", "path", "server", "uri", "route", "http", "resource", "result", "host", "ref", "location", "json", "string"], "get": ["open", "start", "create", "method", "put", "handle", "body", "send", "load", "find", "set", "gets", "query", "e", "client", "pull", "call", "service", "i", "cli", "build", "parse", "api", "request", "Get", "exec", "like", "GET", "update", "read", "http", "resource", "execute", "use", "json"], "response": ["full", "connection", "f", "data", "tree", "error", "respond", "method", "body", "application", "received", "Response", "status", "page", "output", "content", "success", "e", "reply", "feed", "api", "request", "object", "document", "server", "http", "wave", "message", "result", "resource", "out", "report", "onse", "json", "resp"], "entity": ["connection", "data", "el", "body", "info", "event", "xml", "model", "page", "node", "output", "instance", "content", "ale", "collection", "e", "translation", "this", "entry", "image", "Entity", "api", "object", "environment", "document", "server", "null", "pe", "person", "http", "metadata", "file", "message", "action", "resource", "result", "security", "json", "ent", "element", "resp"]}}
{"id1": "20011285", "id2": "22560224", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"copy": ["save", "get", "rm", "create", "type", "py", "change", "sync", "opy", "download", "move", "load", "log", "share", "zip", "clip", "cop", "paste", "cat", "Copy", "delete", "update", "transfer", "file", "split", "clone", "upload", "link", "replace", "cp", " cp", "write", "apply"], "sourceFile": ["slaveFile", "sourcePlace", "ourceFiles", " sourcePage", " sourceFolder", "targetFile", "apiFILE", "sourcePage", "sampleFilename", "SourceBook", "sourceDir", "apiFilename", "sampleFILE", "slaveFILE", "ourceTime", "ourceDirectory", " sourceFiles", "siteFILE", "SourceDir", "targetDir", "sourceDirectory", "sourceSourceFile", " sourceSourceFile", "SourceFile", "sourceFiles", "apiFile", " sourceFILE", "sampleFiles", "ourceFolder", "sourceFilename", "Sourcefile", "sourceTime", "ourceBook", "ourcefile", " sourcePlace", "sourceBook", "targetPage", "ourcePlace", "sourceFILE", "siteFilename", "ourceSourceFile", "targetFiles", "sourcefile", "slaveFiles", " sourceDir", "slaveFilename", "targetDirectory", "SourceTime", " sourceFilename", " sourceBook", "SourceFiles", "sampleFile", "ourceFile", "sourceFolder", "ourcePage", " sourceDirectory", "SourcePlace", "SourceSourceFile", " sourceTime", "apiFiles", "siteFiles", " sourcefile", "SourceDirectory", "siteFile", "targetFolder"], "destinationFile": ["destinatingFILE", "targetinationFile", "targetinationFolder", "distinationFILE", "dominatorFile", " destinatingFile", "targetinationFiles", "dominatorfile", "destinatorfile", " destinatingfile", "distinationfile", "destinatingFile", "destinatingDirectory", "dominationfile", "dominationFiles", "destinatedFiles", " destinatingFiles", "destructionFolder", "desturationFiles", "DestinationSourceFile", "destinatingSourceFile", "destuationFolder", "destinatorFILE", "distructionFolder", "DestinatingFiles", "dominationPath", "destinationDirectory", "distinationFile", "dominatorFiles", "destuationFile", "destinatorSourceFile", "destructionFILE", "destwayFiles", "destinatingFiles", "distinationFolder", "targetinatedfile", "destructionfile", "DestinationFiles", "destinationSourceFile", "destinateFile", "distructionFILE", "destinatingPath", "destinatingFolder", "destuationFILE", "targetinationfile", "destinatorDirectory", " destinationfile", "dominationFile", "destwayFile", "desturationDirectory", "destructionFile", "distructionfile", "destuationfile", "destinatorFolder", "DestinatingDirectory", "DestinationFile", "dominatorFILE", "destinatingfile", "destwayFILE", "targetinatedFile", " destinationFolder", "DestinatingFile", " destinationFiles", "destinatefile", "DestinatingSourceFile", "destinatorFiles", "dominationFILE", "destinatedFile", "desturationFile", "targetinatedFiles", "destinateFiles", "destwayfile", "destinatedFolder", "DestinationDirectory", "destinationFolder", "desturationSourceFile", "targetinatedFolder", "destinationPath", "destinateFolder", "destinatedfile", "distructionFile", "destinationfile", "dominatorPath", "destinatorPath", "destinationFILE", "destinatorFile", "destinationFiles", "destinatePath", " destinatingFolder"], "tmp": ["meta", "data", "current", "sup", "stuff", "tp", "rm", "handler", "slice", "py", "array", "st", "p", "fb", "bb", "page", "cache", "part", "tab", "files", "mb", "txt", "img", "csv", "zip", "apps", "ppa", "e", "vm", "dest", "pp", "temp", "rb", "list", "sp", "storage", "cmp", "db", "mo", "t", "api", "v", "pty", "mp", "flat", "mm", "folder", "split", "pos", "np", "params", "amp", "upload", "po", "obj", "diff", "dat", "dir", "area", "media", "ip", "nb", "buf"], "f": ["x", "full", "inf", "df", "ff", "fl", "handler", "g", "m", "p", "info", "j", "fe", "xf", "u", "b", "rf", "conf", "F", "l", "r", "fn", "fi", "e", "fr", "o", "tf", "lf", "this", "d", "fx", "t", "cf", "v", "io", "c", "file", "fa", "af", "fd", "uf", "bf", "fp", "fo", "fc", "fb", "fs"], "i": ["x", "ji", "ij", "y", "si", "start", "name", "ti", "ri", "s", "m", "p", "j", "info", "pi", "ie", "ix", "hi", "lc", "I", "di", "u", "b", "multi", "bi", "qi", "l", "fi", "e", "o", "key", "d", "ci", "h", "xi", "v", "oi", "ui", "li", "n", "uri", "ii", "io", "c", "in", "id", "index", "iu", "vi", "ai", "gi", "ip"], "source": ["connection", "reader", "sl", "current", "get", "si", "start", "force", "slice", "from", "stream", "secure", "ge", "grade", "ie", "base", "ource", "component", "cache", "wrapper", "e", "SOURCE", "client", "back", "this", "service", "storage", "proxy", "parent", "view", "uri", "server", "core", "null", "io", "scope", "ce", "id", "src", "resource", "input", "target", "Source", "result", "diff", "slave", "use", "site"], "destination": ["combination", "combinating", "estination", "destinating", "estinating", "destinated", "combinate", "combinator", "combinated", " destinated", " destation", "generinator", "Destination", "Destation", "estinate", "Destinator", "Destinate", "partation", "estinator", "partinated", "Destinated", "Destinating", "generination", "partination", "destinator", "destinate", "generinated", "destation", "generinate", " destinator", "partinator"]}}
{"id1": "19944975", "id2": "3266833", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["WriteReport", " writeConfig", "saveSection", "saveConfiguration", "WriteConfig", "saveReport", " writeSection", "WriteConfiguration", "writeSection", "WriteSection", "writeConfig", "saveConfig", " writeReport", "writeReport"], "out": ["reader", "connection", "ext", "name", "at", "pool", "inas", "m", "sync", "ex", "outs", "xml", "dump", "plain", "base", "conn", "w", "again", "output", "user", "inner", "writer", "line", "IN", "err", "password", "key", "flush", "client", "OUT", "o", "temp", "external", "list", "lib", "this", "init", "project", "path", "parent", "filename", "object", "exec", "config", "server", "io", "c", "file", "scope", "prefix", "resource", "res", "window", "report", "exp", "Out", "string", "write", "obj"], "url": ["connection", "open", "sl", "f", "data", "org", "channel", "stream", "web", "xml", "base", "ll", "ssl", "page", "conn", "b", "l", "r", "address", "Url", "service", "URL", "source", "image", "feed", "api", "path", "object", "config", "server", "uri", "io", "http", "file", "resource", "location", "rel", "string", "ob"], "in": ["reader", "bin", "isin", "login", "f", "data", "socket", "inas", "s", "ins", "pin", "stream", "cin", "cms", "min", "In", "xml", "is", "inside", "copy", "ssl", "kin", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "inc", "nin", "n", "inn", "c", "as", "file", "id", "a", "lin", "resource", "input", "ac", "gin", "serv"]}}
{"id1": "15745420", "id2": "15166511", "code1": "    private void download(String address, String localFileName) throws UrlNotFoundException, Exception {\n        String ext = G_File.getExtensao(address);\n        if (ext.equals(\"jsp\")) {\n            throw new Exception(\"Erro ao baixar pagina JSP, tipo negado.\" + address);\n        }\n        File temp = new File(localFileName + \".tmp\");\n        if (temp.exists()) temp.delete();\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            try {\n                URL url = new URL(address);\n                conn = url.openConnection();\n                in = conn.getInputStream();\n            } catch (FileNotFoundException e2) {\n                throw new UrlNotFoundException();\n            }\n            out = new BufferedOutputStream(new FileOutputStream(temp));\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n        } catch (UrlNotFoundException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        File oldArq = new File(localFileName);\n        if (oldArq.exists()) {\n            oldArq.delete();\n        }\n        oldArq = null;\n        File nomeFinal = new File(localFileName);\n        temp.renameTo(nomeFinal);\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"download": ["save", "open", "data", "archive", " Download", "handle", "load", "gz", "dump", "release", "binary", "copy", "register", "output", "zip", "source", "process", "exec", " downloading", "update", "transfer", "Download", " upload", "upload", "append", " transfer"], "address": ["localhost", "region", "data", "name", "point", "email", "type", "remote", "reference", "array", "mode", "base", "position", "page", "output", "content", "ace", "key", "Address", "pointer", "service", "source", "image", "port", "request", "path", "object", "order", "attribute", "config", "number", "enter", "uri", "server", "route", "ress", "prefix", "index", "message", "resource", "target", "host", "location", "addr", "string", "ip"], "localFileName": ["localImageSize", "localFilenameNames", "localStreamname", "localStreamName", "localFilePath", "localSourceFileNames", " localPageSize", "localFilenameName", "localFilesInfo", "LocalSourceFileLocation", "globalFileName", " localFileType", " localPageInfo", "LocalFileType", "localFilenameType", "localfileNames", " localFilePath", "localFileLocation", " localFileInfo", " localFilename", "localFilesAddress", "localSourceFileLocation", "LocalFileNames", "localImageInfo", "globalSourceFileName", "localfileLocation", "localFilesPath", "LocalSourceFileType", "localSourceFileAddress", "localfileName", " localPlacePath", " localPageName", "localFileInfo", "localPlaceName", "localPagePath", "LocalFileName", "localDirAddress", "globalSourceFileAddress", "globalFilePath", " localFileLocation", "localPageSize", "localDirName", "localSourceFileInfo", " localPlacename", "localStreamPath", "globalFileAddress", "localPlacePath", "localPlacename", "localPageName", "localPagename", " localPlaceLocation", "localImageName", " localPlaceName", "globalFileInfo", "localFilename", "localFileType", "localDirPath", "LocalSourceFileName", "localFileAddress", "globalSourceFileInfo", "localFileSize", "globalSourceFilePath", "localSourceFileName", "localFileNames", "localfileType", "localFilenameLocation", "localSourceFilePath", "localSourceFileSize", "localPageLocation", " localPageType", "localDirInfo", "localStreamLocation", "localPageInfo", " localFileSize", "LocalFileLocation", "localFilesName", "localPageType", "localSourceFileType", "localImageType", "LocalSourceFileNames", "localPlaceLocation"], "ext": ["x", "extra", "app", "f", "data", "alt", "name", "type", "expl", "info", "ex", "enc", "str", "fort", "prot", "req", "format", "Ext", "text", "txt", "content", "EXT", "zip", "err", "xp", "dist", "xt", "test", "fx", "path", "config", "file", "word", "ect", "exp", "qt", "addr", "string"], "temp": ["full", "pipe", "lock", "er", "iter", "data", "f", "it", "loc", "Temp", "mount", "tp", "session", "stable", "emp", "p", "ex", "clean", "wp", "local", "base", "Tem", "ht", "cache", "wrap", "output", "wl", "txt", "w", "tem", "zip", "old", "porary", "this", "test", " temporary", "source", "template", "api", "t", "parent", "v", "form", "store", "server", "unit", "null", "empty", "flat", "original", "memory", "file", "folder", "c", "valid", "input", "fake", "home", "cp", "now", "tmp"], "out": ["connection", "bin", "lock", "login", "name", "socket", "s", "sync", "ex", "outs", "not", "In", "plain", "log", "ssl", "copy", "b", "again", "output", "w", "inner", "part", "Output", "writer", "line", "and", "err", "password", "o", "client", "off", "OUT", "key", "this", "call", "i", "cli", "lib", "image", "init", "inc", "or", "exec", "outer", "parent", "other", "server", "null", "io", "net", "file", "up", "prefix", "on", "con", "exp", "Out", "write", "obj"], "conn": ["connection", "nt", "open", "nn", "cn", "socket", "nc", "ct", "sync", "enc", "ll", "ssl", "b", "cache", "cmd", "l", "fr", "client", "Url", "URL", "ci", "init", "cli", "connect", "ch", "inc", "uc", "exec", "close", "config", "n", "conv", "server", "Conn", "c", "func", "impl", "coll", "ai", "con", "fp", "cm", "cp", "Connection", "ac", "obj", "act"], "in": ["connection", "reader", "bin", "lock", "isin", "login", "f", "data", "get", "it", "socket", "s", "ins", "pin", "sync", "cin", "min", "In", "is", "kin", "part", "inner", "again", "win", "by", "r", "din", "l", "IN", "client", "pull", "ini", "i", "cli", "source", "init", "image", "inc", "nin", "or", "lib", "exec", "n", "inn", "up", "id", "index", "lin", "input", "con", "diff", "ac"], "url": ["connection", "open", "sl", "cdn", "f", "loc", "channel", "socket", "layer", "web", "ll", "ssl", "base", "ls", "blog", "b", "l", "r", "client", "Url", "i", "URL", "source", "image", "db", "path", "n", "uri", "server", "http", "file", "impl", "www", "bel", "host", "rl", "string", "ob"], "buffer": ["offset", "bin", "reader", "border", "uffer", "iter", "sequence", "data", "batch", "slice", "reference", "layer", "buff", "Buffer", "binary", "position", "bb", "cache", "b", "bytes", "flush", "FFER", "row", "padding", "comment", "block", "value", "limit", "feed", "transfer", "read", "number", "null", "memory", "wave", "message", "uf", "queue", "input", "result", "pad", "length", "slave", "buf"], "numRead": ["numWrite", "nBuild", "numberBuild", "numberRead", "Numread", "nWritten", "NumWrite", " numBuild", "commonWrite", "commonRead", "NumReader", "nRead", "nWrite", "umWrite", "numread", "numberread", "umWritten", " numReader", "numberWritten", "nread", " numWrite", "NumRead", "commonWritten", "commonReader", "numBuild", "umRead", " numread", "NumWritten", "numReader"], "numWritten": ["numWrite", "multiwritten", "Numwritten", "numberRead", "multiWritten", "multiWrite", "multiWrit", "NumWrite", "numOutput", " numWrit", "numberWrite", "numberWritten", "numberOutput", " numWrite", "NumRead", " numwritten", " numOutput", "NumWritten", "numwritten", "NumWrit", "NumOutput", "numWrit"], "oldArq": ["OldAcquest", "oldDarq", "OldArch", "oldDarque", "oldParq", "oldArp", "OldAcqs", "OldArqu", "oldDarch", "oldARg", " oldParque", "oldParque", "OldARQ", "oldArQ", "oldAcqs", "oldParg", "OldArque", "oldArtque", "OldAcQ", "OldArquest", "oldAcquest", "OldArqs", "oldAcq", "oldARquest", "oldarg", "OldARch", "oldARch", "oldArque", "oldArg", " oldArg", "OldARp", "oldarq", "oldArtquest", "oldARqs", "oldAcque", "oldARque", "oldArqu", "OldArQ", "oldArquest", "oldArtqs", "oldarque", "oldARq", "OldArq", " oldParq", "oldArtQ", "OldAcq", "oldARp", "OldARq", "OldARqu", "oldarQ", "oldAcp", "oldARQ", "oldarqu", " oldParg", "oldArtq", "oldarch", "oldArtp", " oldArque", "OldArp", "OldARque", " oldArQ", "oldArch", "oldDarqu", "oldParQ", " oldParQ", "oldARqu", "oldArqs", "oldAcQ"], "nomeFinal": ["nomesfinal", "nomenFin", "nomefinal", "nomenFinal", "navefinal", " nomefinal", "nomesFin", "naveFinal", " nomeFin", " nomesFinal", "noefinal", "nukeFin", "Nomesfinal", "nomesFinal", " nomesFin", "nukeFinal", "nomenfinal", "NomeFinal", "Nomefinal", "NomesFinal", " nomesfinal", "nukefinal", "noeFinal", "nomeFin"]}}
{"id1": "20365090", "id2": "15166511", "code1": "        public HttpResponseExchange execute() throws Exception {\n            HttpResponseExchange forwardResponse = null;\n            int fetchSizeLimit = Config.getInstance().getFetchLimitSize();\n            while (null != lastContentRange) {\n                forwardRequest.setBody(new byte[0]);\n                ContentRangeHeaderValue old = lastContentRange;\n                long sendSize = fetchSizeLimit;\n                if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) {\n                    sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1);\n                }\n                if (sendSize <= 0) {\n                    break;\n                }\n                lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength());\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_RANGE, lastContentRange);\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sendSize));\n                forwardResponse = syncFetch(forwardRequest);\n                if (sendSize < fetchSizeLimit) {\n                    lastContentRange = null;\n                }\n            }\n            return forwardResponse;\n        }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"execute": [" ping", " await", " proceed", " end", " initialize", " handle", " poll", " current", " open", " refresh", " go", " feed", " finish", " parse", " serve", " dispatch", " generate", " async", " exec", " perform", " produce", " work", " flush", " prepare", " future", " fulfill", " pull", " transfer", " resolve"], "forwardResponse": ["wardView", " forwardresponse", "ForwardView", "Forwardresponse", " forwardServer", "forwardresponse", "ForwardResp", " backwardAnswer", "forwardAnswer", "forwardResp", "wardRequest", "ForwardResponse", "ForwardRequest", "publicServer", " forwardRequest", "publicResponse", " forwardResp", " forwardView", "wardResponse", "publicAnswer", "publicRequest", "forwardRequest", " backwardServer", "forwardView", " backwardRequest", "forwardServer", "wardResp", " backwardResponse", "wardresponse", " forwardAnswer"], "fetchSizeLimit": ["fatchLengthRange", "faitLimitLimit", "faitSizeBlock", "fetchCountRange", "fetchLimitLimit", "fetchsizeLimit", "fatchSizeRange", "fetchLengthLim", "faitSizeLimit", "fatchSizePosition", "faitLimitLock", "fetchRangeUnit", "fetchRangeRange", "fetchLengthLimit", "fetchCountUnit", "faitSizeGlobal", "faitSizeLock", "fetchsizeBlock", "fetchLengthUnit", "fushSizePage", "fatchSizeLock", "fatchSizeLim", "fushCountPage", "fetchsizeGlobal", "fetchSizeLimited", "fatchLengthLimited", "fatchSizeBlock", "fushCountRange", "fetchSizeGlobal", "fetchSizeUnit", "fatchLengthBlock", "fetchLimitGlobal", "fetchsizeLock", "fetchLengthPosition", "fetchCountBlock", "fetchLimitLock", "fatchLengthLim", "fatchLengthLock", "fetchLengthLock", "fetchsizeLimited", "fetchSizeRange", "fetchRangeLimit", "fetchLengthGlobal", "fushSizeUnit", "fetchCountPosition", "fetchsizeLim", "fetchLimitRange", "fetchSizePosition", "fetchCountPage", "faitLimitGlobal", "faitLimitBlock", "fetchSizeLock", "fetchSizeLim", "fushSizeLimit", "fatchSizeLimited", "fetchLengthRange", "fetchLengthLimited", "fatchLengthLimit", "fetchLengthBlock", "fushCountLimit", "fushCountUnit", "fetchLengthPage", "fushSizeRange", "fetchRangePage", "fetchLimitBlock", "fetchLimitPosition", "fetchSizePage", "fetchSizeBlock", "fatchSizeLimit", "fetchCountLimit", "fatchLengthPosition"], "lastContentRange": ["lastContentArea", "lastReadRegion", "lastCharacterOrigin", "lastResourceInfo", "lastContentSpace", "lastFileRow", "lastSizeRange", " lastContentInfo", " lastSizeArea", " lastHeaderRegion", "lastSizeRegion", "lastResourceRegion", "lastContentRegion", "LastContentResource", "lastCharacterRegion", "lastHeaderRegion", "lastHeaderRange", "lastResourceRange", "lastCharacterRow", "lastResourceRow", "lastContentLine", "lastMessageLine", "lastCharacterRange", "lastReadRange", " lastReadInfo", "lastContentInfo", "lastContentRow", "LastContentSpace", "lastSizeArea", "lastReadArea", " lastSizeRegion", "lastVersionResource", "lastReadSpace", "latestContentRange", " lastContentResource", "LastMessageResource", "lastContentOrigin", "lastContentResource", "lastResourcerange", "lastFileRange", " lastSizeSpace", "lastResourceResource", " lastContentRow", "lastHeaderResource", "lastMessageSpace", "LastContentRange", " lastSizeRange", "LastMessageRange", "lastHeaderRow", "lastResourceOrigin", " lastHeaderOrigin", "lastReadInfo", "lastSizeSpace", "lastResourceArea", " lastContentArea", "lastContentrange", "LastMessageLine", "LastMessageSpace", "LastContentLine", "lastReadResource", "latestContentResource", " lastReadResource", "lastFileResource", " lastReadrange", "latestFileResource", "lastCurrentResource", "lastHeaderOrigin", "lastCurrentSpace", "lastHeaderLine", "lastReadrange", "latestFileRow", "latestContentRow", " lastContentrange", " lastContentSpace", "lastMessageRange", "lastCurrentLine", " lastContentRegion", " lastHeaderRow", " lastContentOrigin", "lastMessageResource", "lastVersionInfo", "lastCurrentRange", " lastHeaderRange", "lastVersionrange", "lastMessageRow", "latestFileRange", "lastHeaderSpace", "lastReadRow", " lastReadRange", "lastResourceSpace", "lastVersionRange"], "old": ["full", "ext", "current", "ant", "later", "slice", "low", "el", "from", "handle", "after", "to", "past", "local", "base", "plugin", "orig", "prev", "ld", "format", "OLD", "older", "Old", "part", "add", "inner", "less", "future", "l", "val", " Old", "and", "before", "la", "normal", "expected", "client", "list", "common", "build", "arrow", "or", "object", "form", "other", "small", "update", "front", "original", "element", "folder", "existing", "file", "last", "ore", "diff", "string", "obj", "now"], "sendSize": ["endSIZE", "sendSIZE", " sendSIZE", "forceTime", "endLength", "endStorage", "drawSize", "writeLength", "loadSIZE", "updateSize", " sendTime", "drawSIZE", "drawLength", "pushLength", "sentSize", "drawLimit", "loadOffset", "SendSize", "forceSIZE", "writeSize", "sendLen", "endTime", "SendEnd", "endEnd", "sendEnd", "pushSize", "forceLength", "pushLimit", "sendTime", "SendLength", "loadTime", " sendStorage", " sendLimit", " sendLen", "forceSize", "updateLimit", "endLimit", "sendLimit", "endSize", "writeOffset", "SendStorage", "loadRange", " sendEnd", "updateSIZE", "pushSIZE", "sendOffset", " sendLength", "pushTime", "pushLen", "writeRange", "transferSize", "sendRange", "sentSIZE", "sentLength", "transferOffset", "transferLength", "sentLimit", "sendStorage", "transferRange", "sendLength", "loadLength", "loadSize", "updateLen"]}}
{"id1": "21308543", "id2": "12172485", "code1": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", " copiedContent", " copyStream", "copyStream", "transferContent", " copyFiles", "copyContent", " copiedFile", "transferStream", "transferFiles", " copiedStream", " copyContent", "transferFile", " copiedFiles"], "src": ["inf", "sin", "loc", "remote", "slice", "sc", "stream", "inst", "download", "rc", "feat", "ource", "ls", "img", "href", "rs", "ruby", "dest", "rb", "this", "source", "image", "js", "project", "path", "filename", "attr", "url", "code", "uri", "server", "core", "sit", "http", "sci", "scene", "upload", "sel", "resource", "input", "string", "media"], "target": ["nt", "director", "loc", "name", "it", "master", "arget", "effect", "remote", "type", "reference", "secure", "to", "top", "prot", "base", "fat", "text", "output", "goal", "content", "writer", "eth", "dest", "temp", "external", "source", "port", "project", "path", "parent", "large", "object", "next", "url", "Target", "resource", "out", "result", "compatible", "rel", "arg", "tx"], "ic": ["icc", "pic", "iac", "ici", "loc", "it", "ct", "irc", "cin", "enc", "ics", "aic", "ec", "pc", "rc", "ix", "lc", "cci", "isc", "acl", "ico", "i", "ci", "cc", "vc", "inc", "nic", "exec", "ik", "IC", "xc", "ick", "cl", "voc", "mic", "io", "cit", "c", "sci", "aci", "ai", "mc", "ac", "fc", "ip", "bc", "ib"], "oc": ["abc", "pic", "AC", "arc", "loc", "org", "toc", "iv", "alloc", "sc", "irc", "oca", "enc", "ec", "pc", "rc", "cs", "bb", "isc", "roc", "output", "o", "oci", "ci", "cc", "vc", "uc", "anc", "nic", "exec", "xc", "other", "voc", "mic", "OC", "io", "c", "ocr", "co", "acs", "ocol", "soc", "aco", "mc", "ac", "ace", "bc", "fc"]}}
{"id1": "4223002", "id2": "21608109", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    public static boolean loadContentFromURL(String fromURL, String toFile) {\n        try {\n            URL url = new URL(\"http://bible-desktop.com/xml\" + fromURL);\n            File file = new File(toFile);\n            URLConnection ucon = url.openConnection();\n            InputStream is = ucon.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            ByteArrayBuffer baf = new ByteArrayBuffer(50);\n            int current = 0;\n            while ((current = bis.read()) != -1) {\n                baf.append((byte) current);\n            }\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baf.toByteArray());\n            fos.close();\n        } catch (IOException e) {\n            Log.e(TAG, e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"getPasswordMD5": ["getPasswordMAC256", "getPasswordSHA5", "getPasswordMAC5", "getPasswordMD512", "getPasswordMD256", "getpasswordMD512", "getPasswordMac1", "getPasswordMAC1", "getPasswordSHA512", "getPasswordMac512", "getpasswordMD1", "getPasswordMac256", "getpasswordSHA1", "getpasswordMD256", "getPasswordSHA256", "getPasswordMAC512", "getPasswordMac5", "getPasswordSHA1", "getpasswordSHA256", "getpasswordMD5", "getpasswordSHA5", "getpasswordSHA512", "getPasswordMD1"], "algorithm": ["Alest", " algorith", "calgorithm", "algebra", " alrator", "aggo", "Alignment", "Algo", "fgorithm", "Algorithm", "Alrator", "omalgo", "calgebra", "alm", " alm", "fgo", "Algorith", "alest", "fgebra", "gegorithm", "agrator", "omalgorithm", "geest", " alignment", "fgorith", "alrator", "calgorith", "alger", "algo", "omalphabet", " algo", "aggorithm", "Alger", "gem", "Alphabet", " alphabet", "Alm", "alignment", "agignment", "omalgorith", "Algebra", "alphabet", "algorith", "geger", "calgo", " alger", " alest"], "messageDigest": ["messagedigester", " messagedigEST", "messageModString", "phrasedigested", "phraseDigest", " messagedigest", "phrasedigest", "messageDigested", "phraseDigester", "MessageModested", "messagedigested", "messageDigester", "MessageModester", "messageModEST", "MessageModEST", "messageMDEST", "phrasedigester", "messageMDester", "messageDigString", "MessageDigest", "phraseDigested", "MessageDigested", "messagedigest", "MessageDigEST", "messageDEST", "messagedigString", " messageDigEST", "messageModester", "phraseDigEST", "messageDested", " messageDigString", "messageModested", "phrasedigEST", "messageMDString", " messagedigString", "MessageModest", "messageDigEST", "messageMDest", " messagedigester", "messageModest", " messageDigester", "MessageDigester", "messageDester", "messagedigEST", "messageDest"], "hexString": ["checkString", "hashStr", "hexstring", "hexArray", "hexLine", " hexArray", " hexStream", " hexBuffer", "shortstring", "textStream", "textArray", "checkStr", "hexBuffer", "shortArray", "hashFunction", "byteStream", "hexStream", "hashString", "byteArray", "checkFunction", "hexFunction", "textLine", " hexStr", "hashBuffer", "textBuffer", "byteString", "textString", " hexFunction", "hexStr", "byteLine", " hexstring", "shortString", "textstring", " hexLine", "checkBuffer", "shortBuffer"], "i": ["x", "volume", "f", "si", "ti", "ri", "s", "type", "slice", "m", "p", "j", "info", "pi", "ix", "hi", "I", "bi", "u", "b", "di", "multi", "l", "r", "fi", "e", "o", "key", "abi", "d", "ci", "t", "h", "xi", "v", "oi", "ui", "mi", "n", "li", "uri", "zi", "ii", "io", "c", "in", "id", "index", "a", "chi", "mu", "ai", "gi", "phi", "end"]}}
{"id1": "21316706", "id2": "18989018", "code1": "    @Override\n    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        if ((url == null) || (proxy == null)) {\n            throw new IllegalArgumentException(Messages.getString(\"luni.1B\"));\n        }\n        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);\n    }\n", "code2": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "label": 0, "substitutes": {"openConnection": ["openConnector", " openConnector", "openConnect", "createConnect", "createConnector", " openConnect", "initConnect", "initConnection", "createConnection", "initConnector", "createconnection", "openconnection", "initconnection", " openconnection"], "url": ["connection", "sl", "f", "name", "socket", "channel", "email", "layer", "web", "str", "base", "ssl", "log", "ls", "library", "page", "user", "loader", "l", "client", "address", "Url", "URL", "source", "image", "service", "db", "port", "or", "path", "object", "lr", "default", "server", "uri", "null", "io", "http", "file", "resource", "host", "link", "ref", "string", "ob"], "proxy": ["connection", "manager", "socket", "pool", "Proxy", " proxies", "p", "web", "base", "ssl", "library", "page", "cache", "instance", "zip", "client", "address", "fax", "pointer", "lib", "service", "source", "port", "child", "project", "parent", "object", "config", "friend", "uri", "server", "pse", "io", "http", "pe", "clone", "pa", "resource", "host", "ip", "roxy"]}}
{"id1": "9275622", "id2": "22977189", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["moveFolder", "copyFiles", " copyfile", "copyFolder", "transferFile", "transferFolder", "moveFiles", "transferfile", " copyFiles", " copyFolder", "transferFiles", "movefile", "copyfile", "moveFile"], "_file1": ["_files1", "_files01", "_File2", "_fileone", "_resourceOne", "_mail2", "_file0", "_resource1", "_fFirst", "_resourceone", "_zip1", "_zipFirst", "_fileOne", "_zipOne", "_file01", "_fone", "_fOne", "_File0", "_f1", "_mail1", "_File01", "_mail0", "_File1", "_mail01", "_zipone", "_files2", "_files0", "_resourceFirst", "_fileFirst"], "_file2": ["_files4", "_filesecond", "_Filesecond", "_File5", "_File2", "jfile1", "_file4", " _filesTwo", " _files3", "jmodelsecond", "_model1", "_model5", "_file5", "_modelsecond", "_files3", "_file3", "jfile5", "_play2", "jfilesecond", " _file3", "_playTwo", "jmodel1", "jmodel5", "_play1", "_model2", "_playsecond", "_filesTwo", "_fileTwo", "_File1", "_play5", " _files4", "_files2", "_play4", " _file4", " _fileTwo", "jfile2", "_play3", "jmodel2", " _files2"], "fis": ["fiss", "infiss", "lfais", "lfi", "afis", "cfos", " fris", "afais", "cfiss", "lfis", "cfas", "Fils", " fais", "infils", "afiss", "fi", "Fas", "Fis", " fi", "fils", "infos", "Fiss", "fas", " fiss", "afi", " fils", "lfiss", "Fos", "fris", "Fris", "fais", "cfis", "cfris", "infis", " fas"], "fos": ["infaos", "Fo", "fus", "infus", "Foos", "Foses", "foses", "infios", "feos", "floes", "goses", "Fus", "info", " foos", "fOS", "flis", "infros", "gis", "Faos", "Fros", " fus", "gos", "feoses", "foes", "pis", "Fios", "Fis", "infoos", "infos", "fros", "poes", " faos", "pOS", "feus", "fios", "Fos", "pos", "feis", "foos", " fo", "flOS", " fios", "los", "lis", "faos", "lOS", "flos", "fo", " fros", "loes", "gus"], "canalFuente": ["canalBuence", "canalCraencia", "canaledBuje", "canaledBuze", "canalKuze", "canallBuente", "canallFuente", "canalBuento", "canalFuze", "canalsBuence", "canaledBuente", "canalSuente", "canalFuento", "canallBuence", "canalsFuente", "canalBuente", "canalBuje", "canalSuje", "canalFUje", "canaledFuente", "canalSuestro", "canaledFuestro", "canallFuze", "canalsFuence", "canalsBuento", "canalFUestro", "canalFuencia", "canalKuence", "canalsFuencia", "canalFUente", "canalBuencia", "canaledBuestro", "canaledFuje", "canalKuento", "canalsFuento", "canalFuje", "canallBuze", "canallFuence", "canalsBuencia", "canaledFuze", "canalBuestro", "canallFuencia", "canalKuente", "canalKuencia", "canalFuence", "canalFUencia", "canalSuze", "canalCraence", "canalsBuente", "canalFUze", "canalCraente", "canalCraento", "canalFUence", "canalBuze", "canallBuencia", "canalFuestro"]}}
{"id1": "23611770", "id2": "16623181", "code1": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"handle": [" post", " transport", " abort", "Handle", " process", " reload", " append", " redirect", " handles", " rewrite", " execute", " handler", " fn", " shutdown", " rename", " transform", " serve", " manage", "process", "transfer", " upload", " perform", " loop", " work", " restart", " next", " transfer", " operate"], "srcChannel": ["rcClient", "sourceChan", "rcConnection", "destClient", "sourceClient", " srcchannel", "destChan", "sourceChannel", "rcChan", "sourceConnection", " srcConnection", "srcClient", "srcChan", "sourcechannel", "srcchannel", "rcChannel", "destchannel", " srcClient", "srcConnection", " srcChan"], "destChannel": ["DestStream", "srcSocket", "sourceChan", " destHandler", " destSocket", " destStream", "Destchannel", "destStream", "DestCan", "descCan", "distStream", "distChannel", "destChan", "sourceChannel", "distChan", "DestChannel", "destCan", "descHandler", " destchannel", "srcChan", "destSocket", "DestHandler", " destChan", " destCan", "descChan", "destHandler", "sourceSocket", "distchannel", "destchannel", "descChannel", "DestChan"], "destOutFile": ["destPathfile", "destPointFile", "DestInFile", "destOutputFile", "tempOutSite", "destTemplatefile", "destOutSite", "destOutputSite", "destInDir", "DestInDirectory", "destInDirectory", "destoutDir", "destoutCode", " destOutfile", "destLogFilename", "tempOutDir", "DestInFiles", "destoutFiles", " destOutPath", "destPathFile", "DestOutfile", "destPathFiles", "destOutfile", "featOutFile", "featTemplatefile", "destActionfile", "destPointDir", " destOutputPath", "destOutDir", "destOUTCode", "destInFile", "featTemplateFiles", " destOutputFile", "DestInFilename", "featTemplateFile", "destInPath", " destPathFiles", " destOutputFilename", "destOUTSite", " destOutDir", "featOutFiles", "destOUTFile", " destOutputFiles", "destOutFiles", "destPathDir", "destOUTFiles", " destPathDir", "featOutDir", "destOUTDir", "tempOutFiles", "destOutputfile", "DestOutDirectory", "destLogFiles", "destOutputPath", "destInfile", "DestOutFile", "DestOutCode", "tempOutputFiles", "DestInCode", "tempOutputDir", "DestOutFiles", "DestOutFilename", "destInCode", "destOutputDirectory", "DestInfile", "destActionFile", "destInSite", " destOutFilename", "destInFiles", "destOutCode", " destPathFile", "destoutFile", "tempOutFile", " destPathfile", "destLogFile", "tempOutputSite", "destPointFilename", "DestInDir", "destTemplateFile", "destOutputDir", "destOutFilename", "destLogPath", "featTemplateDir", "destActionDir", "featOutfile", "destPointDirectory", "destTemplateDir", "destOutputFiles", "destInFilename", "destOutPath", "tempOutputFile", "destTemplateFiles", " destOutFiles", "destActionFiles", "destOutputFilename", "DestOutDir", "destOutDirectory"], "destOutFileCompressed": ["destOutFileSupression", "destOutFilesExported", "destOutFilesCompacted", "destOutFilesCompressor", "destOutFileExressor", "destOutLineCompressor", "destOutLineExpressed", "destOutFileEncressed", "destOutFilesComposed", "destOutLineExpression", "destOutFileExressed", "destOutFileExposed", "destOutFileSuppressed", "destOutFileExplied", "destOutLineCompacted", "destOutFilesExplied", "destOutFileExpression", "destOutFilesExpress", "destOutFileRepressed", "destOutLineRepressor", "destOutFileExpressed", "destOutLineCompress", "destOutFilecompressed", "destOutFileSuposed", "destOutFileExress", "destOutLineRepressed", "destOutLineRepression", "destOutFileSupressed", "destOutFilesCompression", "destOutFilesComplied", "destOutFileRepression", "destOutFilesExposed", "destOutFileExacted", "destOutFileSuppressor", "destOutLineRepacted", "destOutFileExpacted", "destOutFileComposed", "destOutFilecompression", "destOutFileEncorted", "destOutFileSuppacted", "destOutFileCompress", "destOutFileExosed", "destOutFileExpress", "destOutFileComplied", "destOutFileReposed", "destOutFilesCompressed", "destOutFileExported", "destOutFilecompress", "destOutFileEncress", "destOutFileSupress", "destOutLineExpressor", "destOutFilesCompress", "destOutLineExposed", "destOutLineRepress", "destOutLineCompression", "destOutFileCompression", "destOutFilesExpression", "destOutFileRepressor", "destOutFilesExpressed", "destOutFileCompacted", "destOutFilesExpressor", "destOutFileExorted", "destOutLineCompressed", "destOutFilesComported", "destOutLineComposed", "destOutFileReplied", "destOutFilesExpacted", "destOutFileComported", "destOutFileSuppress", "destOutFilecompacted", "destOutFilecompressor", "destOutFileRepacted", "destOutFileExpressor", "destOutFileRepress", "destOutFileCompressor", "destOutFileEncosed"], "out": ["full", "lock", "bin", "connection", "extra", "ext", "data", "doc", "name", "self", "socket", "error", "sync", "to", "ex", "outs", "one", "plain", "log", "copy", "conn", "w", "b", "output", "user", "again", "inner", "img", "part", "cache", "line", "writer", "cmd", "err", "o", "flush", "client", "OUT", "temp", "this", "key", "source", "image", "inc", "outer", "exec", "parent", "n", "conv", "post", "null", "io", "net", "server", "up", "file", "co", "resource", "exp", "Out", "obj"], "in": ["reader", "bin", "connection", "isin", "sin", "f", "login", "into", "data", "socket", "ins", "pin", "to", "cin", "min", "In", "log", "is", "part", "b", "inner", "again", "rin", "conn", "img", "win", "din", "l", "r", "IN", "err", "o", "pull", "ini", "source", "init", "image", "inc", "nin", "h", "config", "pass", "inn", "c", "up", "wave", "id", "file", "a", "lin", "token", "input", "con", "diff", "resource", "ac", "gin", "serv"], "buf": ["job", "cur", "cb", "bd", "seq", "data", "loc", "ff", "batch", "pool", "buff", "info", "Buffer", "cap", "bh", "rc", "log", "bl", "feat", "bb", "lc", "base", "b", "vec", "br", "num", "bytes", "box", "text", "val", "bag", "off", "la", "rb", "buffer", "block", "map", "ctx", "port", "uc", "lb", "path", "v", "context", "config", "cv", "func", "wb", "wave", "file", "pos", "src", "uf", "cas", "queue", "header", "bf", " buffer", "input", "ref", "pad", "result", "fb", "bc"], "len": ["nt", "lock", "le", "sl", "iter", "f", "data", "loc", "fl", "lim", "el", "rev", "body", "cap", "min", "en", "ind", " length", "ie", "ll", "lc", "part", "size", "num", "l", "line", "val", "pre", " lang", "lf", "la", "count", "limit", "url", "no", "li", "n", "led", "id", "pos", "lin", "fin", "Len", "length", "ln", "ler", "end"]}}
{"id1": "8385785", "id2": "20663364", "code1": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 0, "substitutes": {"MD5": [" MD8", "MP4", "SHA512", "MP8", "MP512", "MD8", " MD512", "MD4", "SHA4", "SHA8", "MP5", "MD512", "SHA5", " MD4"], "text": ["ext", " TEXT", "data", "name", "version", "str", " Text", "hex", "letter", "class", "binary", "format", "output", "contract", "txt", "content", "bytes", "EXT", "password", "key", "this", "secret", "buffer", "test", "source", "image", "template", "Text", "editor", "path", "struct", "object", "pattern", "url", "config", "number", "code", "in", "word", "prefix", "message", "token", "TEXT", "input", "length", "string", "font"], "UnsupportedEncodingException": ["UnsupportedEncodedception", "UnsupportedEncagingATION", "UnsupportedEncasingException", "UnsupportedEncagingException", "UnsupportedencodedException", "UnsupportedEncodedATION", "UnsupportedEncodingATION", "UnsupportedEncodingception", "UnsupportedencodingATION", "UnsupportedEncodedException", "UnsupportedencodingException", "UnsupportedEncagingception", "UnsupportedEncasingception", "UnsupportedencodedATION", "UnsupportedEncasingATION", "Unsupportedencodedception", "Unsupportedencodingception"], "md": ["meta", "df", "bd", "vd", "data", "mag", "mg", "manager", "cd", "rm", "wd", "method", "dd", "m", "body", "ma", " MD", "mt", "mode", "me", "match", "ld", "dig", "di", "mb", "mac", "cmd", "dm", "docker", "d", "MD", "mo", "mod", "hash", "amd", "mp", "code", "rpm", "metadata", "mm", "pm", "valid", "message", "sha", "cm", "bf", "mc", "ms", "pd", "mand", "pg", "od", "hd", "nm", "Cmd", "ad"], "md5hash": ["mddownsum", "md5Hash", "mand53html", "md5kh", "md2html", "md6hash", "md6kh", "md25hash", "md6Hash", " md6hex", "md25Hash", "md53hash", "md2sum", " md5Hash", "md2hash", "md4Hash", "mand5html", "md2version", "md53html", "md6hex", " md6Hash", " md6sum", " md5hex", "md25html", " md5kh", "md5version", "md5hex", "md2kh", "md53Hash", "md6sum", "md53version", "mand5Hash", "md5sum", " md6kh", "md4hash", "md5html", "mand53version", "md4hex", "md8sum", "md25version", " md6hash", "md8hex", "mddownHash", "md2Hash", "mddownkh", "mand53hash", "mddownhash", "mand5hash", " md5sum", "md8Hash", "md4sum", "mand53Hash", "md8hash", "mand5version"]}}
{"id1": "14650352", "id2": "14598566", "code1": "    boolean checkIfUserExists(String username) throws IOException {\n        try {\n            URL url = new URL(WS_URL + \"/user/\" + URLEncoder.encode(username, \"UTF-8\") + \"/profile.xml\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.connect();\n            InputStream is = conn.getInputStream();\n            is.close();\n            return true;\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"checkIfUserExists": ["checkIfuserexists", "checkIfUserExist", "checkIfUserContes", "checkIfUserContist", "checkIfuserexes", "checkIfUserContisting", "checkIfUserListing", "checkIfUserLists", "checkIfUserExisting", "checkIfUserLes", "checkIfUserexists", "checkIfuserexist", "checkIfUserexist", "checkIfuserExisting", "checkIfuserexisting", "checkIfuserExists", "checkIfUserContists", "checkIfuserExes", "checkIfUserList", "checkIfUserExes", "checkIfuserExist", "checkIfUserexisting", "checkIfUserexes"], "username": ["ame", "profile", "login", "data", "family", "name", "email", "uu", "database", "method", "me", "sudo", "description", "u", "user", "text", "account", "password", "key", "address", "subject", "nick", "ername", "staff", "mobile", "path", "filename", "role", "uri", "USER", "title", "users", "token", "uid", "home", "directory", "auth", "string"], "url": ["connection", "sl", "f", "loc", "org", "fl", "channel", "ur", "web", "aur", "base", "ssl", "ll", "ls", "log", "bb", "user", "b", "blog", "page", "l", "client", "address", "Url", "URL", "build", "feed", "api", "uc", "path", "object", "server", "uri", "browser", "http", "file", "impl", "resource", "www", "host", "string"], "conn": ["connection", "nt", "open", "cur", "cb", "loc", "cn", "org", "cos", "nc", "ct", "p", "dn", "ns", "enc", "os", "ann", "rc", "ssl", "lc", "ls", "cs", "conf", "dc", "cli", "ci", "ctx", "connect", "ch", "cf", "h", "close", "n", "conv", "rt", "Conn", "c", "http", "co", "ai", "con", "cp", "Connection", "col", "act"], "is": ["app", "ens", "ais", "Is", "iss", "isl", "it", "cos", "ins", "bs", "ori", "info", "has", "os", "isa", "IS", "ls", "isc", "abs", "css", "err", "its", "i", "api", "bis", "ui", "vs", "ris", "as", "in", "iso", "act", "iris", "ai", "ss", "us", "ios", "ms", "serv", "ip", "fs", "isi"]}}
{"id1": "2396191", "id2": "8667872", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksfromURLSafe", "getLinksFromUrlfast", "getLinksFromSSLSafe", "getLinksFromURLSafe", "getLinksFromURLSlow", "getLinksfromURLFast", "getLinksFromUrlFast", "getLinksFromSSLfast", "getLinksFromSSLSlow", "getLinksFromStringfast", "getLinksfromURLSlow", "getLinksfromUrlSafe", "getLinksFromStringSafe", "getLinksFromUrlSafe", "getLinksFromStringSlow", "getLinksfromUrlSlow", "getLinksFromUrlSlow", "getLinksFromStringFast", "getLinksfromUrlFast", "getLinksFromURLfast", "getLinksfromURLfast", "getLinksFromSSLFast", "getLinksfromUrlfast"], "p_url": ["p_link", "p__name", "tp_root", "p__resource", "p25layer", "pklink", "pe_config", "pipfile", "x_domain", "x_resource", "ekurl", "p64page", "p_html", "x_service", "e_link", "pfpath", "tp24root", "p64path", " p_resource", "pfroot", "pamhtml", "p6config", "p9resource", "p64line", " p_line", "pipurl", "p_file", "e_layer", " p_name", "p9url", "p_path", "p6root", "p24file", "pxurl", "pklayer", "p_name", "p_resource", "p25url", "p24link", "pkhtml", "pfurl", "p24root", "pffile", "p_service", "p_line", "p25html", "pe_root", "p_layer", "pe_url", "pamlink", "pamlayer", "e_url", "pamurl", "pxline", "p__url", "p25link", "p64url", "tp_url", "p_config", "e_html", "tp24link", "p_root", "pfline", "p24url", "p6line", "p9service", "tp_file", "p9domain", "tp24url", "pkurl", "pxconfig", "p_domain", "pxroot", " p_page", "pflink", "tp_link", "ekhtml", "piplink", " p_path", "pe_line", "tp24file", "eklayer", "piproot", "p6url", "eklink", "pfpage", "p_page", "p__path"], "x_url": ["x_log", "x_resource", " x_resource", "p_host", "p_conn", " x_ssl", "p_loc", "x_ssl", " x_log", "x_loc", "x_host"], "x_conn": ["x___conn", "x___con", "x___db", "x_conv", "p_client", "p_db", "wx_con", "x_con", "wx_conv", "x_cat", "p_conn", "p_con", "x_client", "wx_cat", "wx_conn", "x_db", "x___client"], "x_is_reader": ["x_ismlmanager", "x_is_pointer", "x_is_manager", "x_is_stream", "x_is_draft", "x_ismlstream", "x_is_resource", "x_ismlreader", "x_is_writer", "x_ismldraft"], "x_reader": ["cross8url", "x_parser", "x67url", "x24reader", "X_stream", "X_result", "x24result", "x67root", "x8reader", "cross_reader", "cross8reader", "x67reader", "x24parser", "cross_root", "x24stream", "cross8parser", "x8parser", "cross8root", "x67parser", "cross_parser", "x_stream", "X_reader", "x8url", "cross_url", "X_parser", "x8root"], "x_line": ["x__link", "p_link", "xingcell", "x24line", "ex_record", "x_record", "xx_line", "x_comment", "x__line", "x24lin", "x24comment", "xx_lin", "xingline", "xingrecord", "xingpage", "ex_line", "x24link", "p_line", "xx_link", "ex_page", "p_page", "x__url", "xx_comment", "x__page", "x_lin", "x_cell", "ex_cell"], "e": ["le", "er", "f", "y", "oe", "eps", "error", "edge", "ze", "eur", "g", "el", "m", "body", "ente", "p", "se", "ge", "ae", "fe", "ec", "eb", "event", "en", "ie", "me", "match", " E", "b", "he", "entity", "je", "r", "line", "l", "engine", "E", "o", "d", "ne", "entry", "t", "driver", "exec", "ev", "v", "ue", "te", "code", "n", "eve", "pe", "c", "eu", "file", "ce", "ele", "es", "ea", "re", "esi", "ace", "ee", "end", "element"], "x_match": ["p_matched", "p__match", "e_matched", "xammatch", "p_match", "xamreplace", "x_tag", "x_pattern", "x___meet", "x__match", "ax5case", "e___matched", "xamslice", "e___meet", "xjmatch", "e_match", "e_check", "x5info", "xJmember", "ext_search", " x__replace", "x___matched", "x___check", "x5match", "x_member", "ext_match", "ax_info", "x__replace", " x__slice", "x_check", "xlpattern", "ax_link", "x___match", " x_slice", "xlgroup", "ax5link", "xltag", "xJmatch", "ax5match", "x_replace", "extJsearch", "ext_member", "x__url", "x_info", "xjurl", "xjpattern", "xamcase", "x__matched", "xjmatched", "extJmember", "xJsearch", "xlmatch", "xlsearch", "x_matched", "x5case", "extJmatch", "ax_match", " x_date", "extJpattern", "p__url", "x_case", "xJpattern", "xldate", "x_date", "ax_case", "xlmember", " x_tag", " x_group", "e___match", " x_case", "p_pattern", " x_replace", "x_group", " x__match", "p__matched", "x__pattern", "x_search", "x_meet", "x__slice", "ax5info", "p__pattern", "x5link", "e___check", "x_slice", "e_meet", "x__case", " x__case", "ext_pattern"], "x_dir": [" x_file", "x6dir", "x_group", "xneturl", "xnetfile", "xnetdir", "x6group", "x_file", "x6file", " x_group", "x6url", "xnetgroup"], "x_root": ["x7directory", "x7root", "x7alias", "x_directory", "xml_root", "xml_path", "xml_directory", "xml_alias", "x_path", "x7path", "x_alias"], "x_links": [" x_points", "x_lines", " x_lines", "x_ids", "x67links", "x_points", " x_ids", "x67lines", "x67ids", "x67points"], "x_texts": ["x_pathes", "x_textches", "x_pathches", "x_logls", "x_textes", "x_urls", "x_loges", "x_urlls", "x_urles", "x_textls", "x_logches", "x_logs", "x_urlches", "x_paths", "x_pathls"], "x_buf": ["x1buff", "y__buf", "x_wb", "X_buff", "ex_tmp", "x__tmp", "x64buf", "x64bag", "x_cb", "x___uf", "x_buff", "X_buffer", "y__bag", "x1tmp", "ex_buff", "ex__tmp", "x__cb", "ex_cb", "x64uf", "ex__buf", "y_uf", "x___buf", "x_tmp", "ex__buff", "x_buffer", "x_bag", "ex_buf", "x64rc", "x__bag", "y__uf", "y_rc", "x__wb", "y_buf", "X_buf", "x__buf", "ex__cb", "y__rc", "x_rc", "y_bag", "x_uf", "x__buffer", "x___rc", "x1cb", "X_wb", "x1buf", "x__uf", "x__rc", "x___bag", "x__buff"], "x_matches": ["x_morting", "x_Matches", "x_matchcks", "x_matchchers", "x_matchting", "x_batures", "xKmatoms", "x_attched", "x_matchers", "xKtextoms", "x_calhes", "x_patched", "x_batches", "x_patchers", "x_attches", "x_morhes", "x_matoms", "xKtexthes", "x_pathes", "x_matures", "x__mathes", "x_calings", "xKtextings", "x_matting", "x__matures", "x_matchings", "x_locches", "x_locting", "x_patcher", "x_matings", "x_Mathes", "x_matchches", "xKtextches", "x_Matcher", "x_matchhes", "x_matcks", "x_morched", "x_Matures", "xKmatings", "x_Matchers", "x_patcks", "x_textings", "x__matchers", "x_calches", "x_matched", "x_attcks", "x_atthes", "xKmathes", "xKmatches", "x_mathes", "x_caloms", "x_batchers", "x_loches", "x_matchched", "x_texthes", "x_textches", "x_morches", "x_patches", "x_matchoms", "x__matches", "x_locched", "x_bathes", "x_textoms", "x_matchcher", "x_matcher"], "x_page": ["X_line", "xerfeed", "x67loc", "xerlink", "xerpage", "xerline", "ex_loc", "tx_page", "x_feed", "X_page", "tx_link", "x67link", "ex_link", "tx_feed", "x_path", "tx_line", "X_path", "x_file", "x_loc", "ex_file", "ex_page", "X_url", "x67page", "x67file"], "x_link": ["xpubloc", " x_target", "xpubline", "x_target", "xpublink", "ex_link", "xpubtarget", " x_loc", "x_loc", "ex_url", "ex_line", "ex_page"], "i": ["x", "ji", "f", "y", "si", "it", "ti", "ri", "iv", "p", "j", "info", "pi", "k", "ori", "ie", "ix", "hi", "I", "di", "u", "b", "multi", "bi", "qi", "r", "o", "key", "ini", "count", "ci", "z", "xi", "v", "oi", "ui", "n", "li", "uri", "zi", "ii", "io", "c", "in", "id", "index", "a", "chi", "iu", "eni", "ai", "gi", "phi"]}}
{"id1": "6871529", "id2": "6613944", "code1": "    private boolean readUrlFile(String fullUrl, PrintWriter out) {\n        try {\n            URL url = new URL(fullUrl);\n            String encoding = \"gbk\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), encoding));\n            return fileEditor.pushStream(out, in, fullUrl, false);\n        } catch (Exception e) {\n        }\n        return false;\n    }\n", "code2": "    public static String installOvalDefinitions(final String xml_location) {\n        InputStream in_stream = null;\n        try {\n            URL url = _toURL(xml_location);\n            if (url == null) {\n                in_stream = new FileInputStream(xml_location);\n            } else {\n                in_stream = url.openStream();\n            }\n        } catch (IOException ex) {\n            throw new OvalException(ex);\n        }\n        Class<OvalDefinitions> type = OvalDefinitions.class;\n        OvalDefinitions object = _unmarshalObject(type, in_stream);\n        String pid = _getDatastore().save(type, object);\n        return pid;\n    }\n", "label": 0, "substitutes": {"readUrlFile": ["readURLFile", "readUrlStream", "openUrlFiles", "readURLStream", "openURLStream", "openURLFile", "readurlfile", "readurlFiles", "readurlFile", "readFilefile", "readURLFiles", "openUrlfile", "readFileFile", "openURLfile", "readURLfile", "openURLFiles", "readUrlfile", "openUrlFile", "readFileFiles", "readUrlFiles", "readFileStream", "openUrlStream", "readurlStream"], "fullUrl": ["fullPath", " fullURL", "FullPage", "Fullurl", "completeURL", "completePage", "shorturl", "completeUrl", "shortURL", "rawUrl", "shortUrl", "shortPath", "rawURL", "completeUr", "FullUr", "FullUrl", "FullURL", "rawurl", " fullPath", "rawPage", "fullPage", " fullurl", "FullPath", " fullPage", "fullurl", " fullUr", "completeurl", "fullUr", "fullURL"], "out": ["reader", "connection", "bin", "login", "data", "name", "outs", "log", "cache", "w", "again", "output", "user", "inner", "content", "writer", "line", "IN", "err", "o", "flush", "client", "OUT", "temp", "buffer", "i", "source", "image", "inc", "parent", "filename", "raw", "server", "io", "file", "result", "resource", "report", "Out", "string", "write", "obj"], "url": ["connection", "open", "sl", "f", "stream", "web", "xml", "ll", "base", "ssl", "log", "bb", "ls", "blog", "b", "page", "user", "zip", "l", "Url", "buffer", "URL", "source", "image", "service", "feed", "uri", "server", "browser", "io", "http", "up", "file", "ball", "www", "resource", "bel", "rl", "string"], "encoding": ["encoded", "encasing", " encoder", "coded", "Encoding", "encode", "Encaching", "enaching", " encasing", "encoder", "enoded", "caching", "encaching", "casing", "coding", "coder", "enoding", "Encasing", "Encode", "enasing", "code", " encode", "Encoded", "Encoder"], "in": ["reader", "bin", "connection", "login", "f", "data", "doc", "s", "ins", "body", "stream", "In", "xml", "str", "rec", "part", "b", "inner", "rin", "win", "din", "r", "IN", "err", "client", "ini", "i", "source", "inc", "nin", "n", "io", "inn", "c", "file", "a", "resource", "input", "con", "serv"]}}
{"id1": "481364", "id2": "10212189", "code1": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 0, "substitutes": {"downloadFiles": ["DownloadImages", "downloadFile", "uploadItems", "processFiles", "DownloadFiles", "uploadImages", "downloadImages", "uploadFiles", "DownloadFile", "DownloadItems", "uploadFile", "downloadItems", "processImages", "processFile", "processItems"], "downloadFilesWorker": ["downloadFilesWorkER", "downloadFilesPoolER", "downloadFilesPooler", "downloadFilesLinkler", "downloadFilesLinkers", "downloadPhotosPooller", "downloadFilesPoolers", "downloadPhotosPoolers", "downloadFilesLinkER", "downloadFilesLinker", "downloadPhotosWorkers", "downloadPhotosPoolER", "downloadFilesWER", "downloadFilesWorkler", "downloadFilesWorkers", "downloadPhotosWorker", "downloadFilesPooller", "downloadPhotosPooler", "downloadFilesWer", "downloadFilesWler", "downloadFilesWers", "downloadPhotosWorkER", "downloadPhotosWorkler"], "startDownloadDate": ["startUploadData", "startFileDate", "startFileTime", " startDownloadMark", " startDownloadDay", "StartDownloadData", "startReviewData", "startFileMark", "StartReviewData", " startDownloadStatus", "startUploadMark", "startInstallYear", "startInstallTime", "startUploadTime", "startDownloadYear", "startReviewDate", " startDownloadTime", "startPullData", "StartReviewYear", "startUploadDate", "startImportDay", "StartReviewTime", "startPullTime", "startDownloadTime", "startInstallDay", "StartReviewDate", " startUploadData", "startImportDate", " startUploadTime", " startUploadDate", "StartDownloadTime", "startImportStatus", "startDownloadDay", " startUploadMark", "startUploadDay", "startImportTime", "startInstallDate", "startFileData", "startDownloadData", " startUploadStatus", "StartDownloadYear", "startReviewYear", "startDownloadMark", "startUploadStatus", "startPullDate", "startPullMark", "StartDownloadDate", "startUploadYear", "startInstallData", "startDownloadStatus", " startUploadDay", "startReviewTime", " startDownloadData", "startInstallStatus"], "refreshSpeed": ["defractionStep", "defractionSpeed", "defractionScore", "refractionSpeed", "refreshStep", "refractionScore", "defreshStyle", "refetchStyle", "refetchSpeed", "defreshScore", "defractionStyle", "refetchScore", "refetchStep", "refillStep", "refractionStyle", "refillSpeed", "refillScore", "defreshStep", "defreshSpeed", "refractionStep", "refillStyle", "refreshStyle", "refreshScore"], "lastDate": ["firstDay", " lastTime", "firstTime", "LastDate", " lastData", "lastTime", " lastDay", "LastData", "lastDay", "lastData", "LastTime", "firstData", "firstDate", "LastDay"], "totalSizeRead": [" totalSizeREAD", "totalNameRead", "totalUrlReader", "totalUrlREAD", "totalsizeRead", "totalSizeEx", "totalTimeWritten", "totalSectionReader", "totalsizeWritten", "totalNameNeed", "totalNumberWritten", "totalsizeEx", "totalSectionWritten", "TotalSizeNeed", "totalSectionRead", "TotalSizeRead", "TotalNumberEx", "totalNumberNeed", "totalSizeNeed", "totalSizeWritten", "totalNumberEx", "totalNumberReader", "totalTimeRead", "TotalSizeEx", "totalStringWritten", "totalTimeEx", "TotalSizeWritten", " totalNumberREAD", "totalNumberREAD", "totalUrlWritten", "totalNameWritten", "TotalNumberNeed", "totalStringNeed", "totalSizeREAD", " totalSizeReader", "totalSectionREAD", " totalNumberReader", "TotalNumberRead", "totalStringRead", " totalSizeWritten", " totalNumberWritten", "totalSizeReader", "totalUrlRead", "TotalNumberWritten"], "totalNumberRead": ["totalnumberFound", "totalAmountread", " totalNumberWrite", " totalSizeWrite", "totalnumberread", " totalNumberFound", " totalnumberWritten", "totalSizeFound", "totalNumWritten", " totalNumberread", "totalNumRead", "totalAmountWritten", "totalLengthWrite", "totalNumberWritten", "totalStringread", "totalLengthread", "totalnumberRead", "totalSizeread", " totalnumberread", "totalNumFound", "totalSizeWritten", "totalNumberFound", " totalnumberRead", "totalAmountRead", "totalLengthWritten", "totalNumberread", "totalStringWritten", "totalNumread", "totalSizeWrite", " totalSizeread", "totalAmountWrite", "totalNumberWrite", "totalStringRead", " totalSizeWritten", " totalNumberWritten", "totalLengthRead", "totalnumberWritten", " totalnumberFound"], "photo": ["job", "username", "pic", "profile", "login", "opus", "data", "phone", "widget", "ickr", "lo", "audio", "slice", "language", "pin", "layer", "info", "gal", "phot", " photographer", "gallery", "sharing", "album", "copy", "picture", "page", "video", "jp", "pixel", "instance", " photograph", "l", " photos", "collection", "journal", "member", "single", "avi", "la", "vision", "entry", "image", "api", "large", " photography", "project", "filename", "facebook", "document", "camera", "friend", "person", "room", "photos", "favorite", "item", " Photo", "Photos", "cover", "record", "result", "jpg", "Flickr", "voice", "Photo", "json", "trial", "media", "obj", "student", "license", "opa"], "url": ["open", "sl", "loc", "name", "org", "channel", "socket", "stream", "web", "download", "ssl", "position", "page", "conn", "user", "l", "client", "address", "Url", "URL", "source", "image", "api", "path", "response", "system", "config", "document", "uri", "server", "http", "file", "resource", "www", "out", "contact", "link", "host", "location", "string"], "connection": ["reader", "director", "loc", "channel", "socket", "handler", "database", "session", "stream", "body", "info", "web", "application", "control", "position", "conn", "l", "client", "connected", "URL", "which", "image", "connect", "api", "or", "response", "context", "document", "uri", "server", "io", "http", "c", "in", "function", "uno", "con", "out", "directory", "Connection", "communication", "bc"], "dis": ["reader", " Dis", "data", "loc", "channel", "dl", "DIS", "det", "body", "to", "non", "Dis", "info", "web", "mor", "se", "rec", "di", "conn", "pre", "dist", "fr", "normal", "service", "lib", "ws", "api", "or", "ui", "no", "io", "http", "file", "pos", "des", "resource", "res", "con", "out", "dir", "pro", "coll", "re", "serv", "de", "device"], "fos": ["phOS", "fis", "Foses", "foses", "bos", " fis", "fose", "FOS", "Fops", "fOS", "Fose", "fou", " fose", "Faos", "paos", " foses", "boses", "fops", "Fis", "phaos", "bis", " faos", "pou", "pOS", "bops", "Fos", "pos", "phos", "phou", "faos", "bose", "Fou", " fops", "baos"], "b": ["be", "job", "bin", "cb", "f", "bit", "batch", "gb", "bs", "boot", "p", "buff", "eb", "xb", "binary", "base", "bl", "bb", "B", "mb", "br", "bytes", "l", "r", "e", "rb", "buffer", "emb", "bar", "db", "lb", "ba", "v", "n", "ab", "c", "pb", "split", "wb", "sb", "bf", "nb", "ob"], "sizeRead": ["SizeRead", "scaleRead", "sizeWalk", "sizeWrite", "izeUse", "sizeIn", "nowRead", "stringWrite", "stringReader", "externalFind", " sizeLoad", "sizeLoad", "sizeReader", "stringFind", " sizeReader", "sizePass", "lengthRead", " sizeWalk", "izePass", "lengthPass", "lengthFind", "externalRead", " sizeWrite", "SizeUse", "scaleWalk", " sizeUse", "nowReader", "SizeIn", "SizeFind", "externalWrite", "SizeWalk", "nowFind", "izeReader", "nowLoad", "izeIn", " sizeFind", "sizeFind", "izeRead", " sizeIn", "sizeUse", "lengthReader", "stringRead", "lengthLoad", " sizePass", "scaleFind", "externalReader"], "totalDiffTime": ["finalDiffCount", "totalDistRate", "finalDiffTime", "totalDistCount", "totalChangeTime", "totalDiffTimes", "partialDiffTimes", "totalDeltaCount", "totalDeltaSpeed", "totalDiffRate", "totaldiffSpeed", "totaldiffTime", "totaldiffCount", "finaldiffRate", "totalDiffSpeed", "finaldiffCount", "totalDistSpeed", "partialDiffSize", "totaldiffSize", "partialDiffTime", "finalDiffRate", "totalDiffSize", "totalChangeTimes", "totalDiffCount", "finaldiffTime", "totalDeltaRate", "finalDiffSpeed", "totaldiffTimes", "totalChangeSize", "totalDeltaTime", "totalDistTime", "totaldiffRate", "finaldiffSpeed"], "totalSpeed": ["TotalDiff", " totalRate", "TotalTime", " totalspeed", "tspeed", " totalTime", "completeSpeed", "totalAverage", "completeRate", "totalspeed", "tRate", "tSpeed", "TotalSpeed", "validAverage", "completeAverage", "completeDiff", "totalTime", "validRate", "totalDiff", "validDiff", "TotalRate", "validSpeed", "totalRate", "Totalspeed", "TotalAverage", "tTime"], "list": ["full", "ul", "layout", "lp", "fl", "pool", "batch", "complete", "table", "slice", "low", "type", "array", "cont", "st", "p", "stack", "not", "load", "detail", "gallery", "set", "bl", "status", "ls", "page", "part", "all", "l", "left", "collection", "see", "la", "best", "test", "source", "entry", "live", "cli", "object", "cl", "lists", "li", "view", "code", "LIST", "queue", "coll", "record", "result"]}}
{"id1": "9805906", "id2": "15580610", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 1, "substitutes": {"dump": ["save", "df", "f", "data", "info", "download", "load", "copy", "all", "files", "zip", "Dir", "export", "flush", " dumped", "ump", "db", " dumps", "update", " dumping", "transfer", "store", "println", "diff", "dir", "out", "ln"], "source": ["connection", "iter", "sin", "ources", "current", "start", "s", "slice", "remote", "from", "stream", "se", "base", "ource", "SOURCE", "address", "this", "service", "parent", "view", "uri", "server", "core", "unit", "http", "file", "series", "src", "scene", "resource", "input", "Source", "slave", "string", "use", "site"], "target": ["office", "connection", "it", "force", "master", "arget", "effect", "database", "table", "to", "settings", "base", "top", "output", "goal", "alias", "root", "dest", "address", "pointer", "template", "port", "project", "path", "parent", "object", "large", "next", "platform", "null", "file", "Target", "enemy", "src", "follow", "resource", "out", "result", "host", "replace"], "is": ["ens", "ais", "Is", "iss", "isl", "s", "oss", "bs", "ins", "bos", "ori", "info", "has", "ics", "im", "gets", "isa", "IS", "ls", "cs", "abs", "was", "obs", "ops", "oses", "its", "i", "mis", "ws", "or", "nis", "bis", "ois", "ui", "ists", "ps", "ris", "io", "as", "in", "iso", "iris", "es", "ai", "opens", "us", "ios", "lis", "ip", "ses", "isi"], "os": ["ens", "ais", "ues", "oa", "cos", "ds", "oos", "s", "bs", "oss", "boot", "bos", "ori", "ips", "outs", "ows", "cs", "ies", "obs", "ops", "oses", "o", "its", "i", "OS", "or", "Os", "oes", "vs", "ose", "ps", "io", "osi", "as", "pos", "aos", "acs", "ros", "ss", "es", "los", "ios", "us", "ols", "nos", "fs", "ks", "dos"], "done": ["did", "once", "current", "loaded", "data", "Done", "later", "made", "complete", "started", "got", "due", "after", "ready", "one", "disabled", "finished", "odo", "future", "die", "part", "enabled", "expected", "defined", "doing", "confirmed", "next", "nice", " finished", "checked", "dad", "empty", "yes", "last", "running", "gone", "none", " Done", "foo", "progress", "always", "de", "dirty"]}}
{"id1": "15500892", "id2": "18164929", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandGID", "getRandomGuid", "getRandomIGuid", "getRandGUID", "getRandGuid", "getRandomUID", "getRandUuid", "getRandomGCuid", "getRandomIGUID", "getRandomGCid", "getRandomGid", "getRandomGID", "getRandUUID", "getRandUid", "getRandomIGID", "getRandomUUID", "getRandomUuid", "getRandUID", "getRandomUid", "getRandGid", "getRandomGCID", "getRandomIGid", "getRandomGCUID"], "secure": ["active", "https", "secondary", "force", "depth", "session", "allow", "remote", "seed", "encrypted", "exclusive", "timeout", "smart", "ssl", "require", "zip", "deep", "random", "pure", "sensitive", "secret", "external", "proxy", " insecure", "service", "sec", "confirmed", "config", "server", "protect", "weak", "Secure", "ce", "unsigned", "sr", "debug", "safe", "host", "security", "use", "stable"], "md5": ["md2", " MD2", "md500", " md500", " md3", "cmd512", "MDql", "MD5", "MD500", " md512", "MD11", "MD512", "md512", " MD500", "md11", " mdql", "cmdql", " MD11", " md2", "MD2", " MD3", "mdql", " MD5", "cmd5", "cmd3", " md11", "md3", "MD3"], "sbValueBeforeMD5": ["sbValueAfterMS95", "sbValueBeforeMD3", "sbValueBeforeMC5", "sbValueAfterMS55", "sbValueBeforeMP1", "sbValueBeforeD65", "sbValueAfterMP3", "sbValueAfterMD95", "sbValueAfterMS65", "sbValueBeforeMP3", "sbValueAfterMS5", "sbValueBeforemd25", "sbValueBeforeAMD3", "sbValueBeforeMAC0", "sbValueBeforeMS95", "sbValueBeforemd3", "sbValueBeforemd375", "sbValueBeforeDER1", "sbValueGivenMD375", "sbValueBeforeAMD5", "sbValueBeforeDER20", "sbValueBeforeMS512", "sbValueBeforeSHA1", "sbValueBeforeMP7", "sbValueBeforeMS375", "sbValueBeforeDER55", "sbValueBeforeMD55", "sbValueBeforeMI5", "sbValueBeforeD5", "sbValueBeforeMAC55", "sbValueBeforeMS20", "sbValueGivenmd512", "sbValueGivenmd3", "sbValueAfterMD20", "sbValueBeforeMS5", "sbValueBeforemd95", "sbValuebeforeMD005", "sbValueBeforeMD75", "sbValueBeforeDER005", "sbValueAfterMD7", "sbValueBeforeSHA5", "sbValueAfterMS75", "sbValueBeforeMS7", "sbValueBeforeMD7", "sbValueAfterMD0", "sbValueBeforeMI3", "sbValueAfterMS25", "sbValueBeforeMR25", "sbValueBeforeDER5", "sbValueAfterMD25", "sbValueBeforeAMD1", "sbValueBeforeMS75", "sbValuebeforeSD5", "sbValueBeforeSD005", "sbValueAfterMP1", "sbValueAfterMP7", "sbValueAfterMS0", "sbValueAfterMS20", "sbValueBeforeAMD20", "sbValueBeforeMS25", "sbValuebeforeSD20", "sbValueAfterMS1", "sbValueAfterMD1", "sbValueBeforeMD20", "sbValueBeforeMD1", "sbValueBeforeMD95", "sbValueBeforeDER0", "sbValueBeforemd65", "sbValuebeforeMD5", "sbValueBeforeMS65", "sbValueBeforeMI20", "sbValueBeforeMS55", "sbValueGivenMD3", "sbValueBeforeMI1", "sbValueAfterMD75", "sbValueBeforeMS0", "sbValueBeforeMAC5", "sbValueBeforeMI7", "sbValuebeforeSD005", "sbValueBeforeSD1", "sbValueBeforeMD0", "sbValueGivenMD512", "sbValueBeforeDER3", "sbValueBeforeD3", "sbValueAfterMP5", "sbValueBeforeD75", "sbValueBeforeMD512", "sbValueGivenmd5", "sbValueBeforeSD20", "sbValueAfterMD55", "sbValueBeforeMD25", "sbValuebeforeSD1", "sbValueAfterMD3", "sbValueBeforeMD65", "sbValueGivenmd375", "sbValueBeforemd75", "sbValuebeforeMD20", "sbValueGivenMD5", "sbValueAfterMD65", "sbValueBeforeMP5", "sbValueBeforeMD005", "sbValueBeforemd5", "sbValueBeforeMS3", "sbValueAfterMS3", "sbValueBeforeMD375", "sbValueBeforeSHA20", "sbValueBeforeMAC3", "sbValueAfterMD5", "sbValueBeforeMC3", "sbValueBeforeMS1", "sbValuebeforeMD1", "sbValueBeforeMR95", "sbValueBeforeMC375", "sbValueBeforeMC512", "sbValueBeforemd512", "sbValueBeforeMR3", "sbValueBeforeSD5", "sbValueBeforeSHA005", "sbValueBeforeMR5"], "time": ["offset", "etime", "loc", "name", "version", "times", "depth", "error", "type", "slice", "cost", "seed", "mode", "tim", "timeout", "event", "counter", "Time", "user", "size", "clock", "year", "TIME", "work", "random", "tz", "race", "count", "money", "value", "ime", "speed", "date", "rate", "duration", "delay", "id", "timer", "hour", "host", "length", "start"], "rand": ["rh", "rol", "reg", "version", "depth", "q", "risk", "error", "type", "range", "seed", "clean", "rank", "min", "gen", "winner", "bot", "rc", "rule", "rage", "mid", "win", "cr", "r", "root", "year", "raid", "max", "chance", "random", "lang", "rr", "Rand", "count", "serial", "order", "round", "ng", "rate", "delay", "id", "ro", "index", "right", "res", "pick", "alpha", "bit"], "valueBeforeMD5": ["valueBeforeMP53", "valueBeforeMD85", "valueBeforeMC3", "valueAfterAMD53", "valueBeforeMP2", "valueBeforeMD3", "valueBeforemd3", "valueBeforeMP5", "valueInsideMD3", "valueBeforeMC5", "valueBeforeMP3", "valueBeforeMD53", "valueAfterMD53", "valueInsideMD2", "valueInsideMD85", "valueBeforeAMD3", "valueBeforemd5", "valueBeforeAMD5", "valueBeforemd85", "valueBeforeAMD53", "valueAfterAMD5", "valueBeforeMC2", "valueBeforeMD2", "valueAfterMD3", "valueBeforeMC85", "valueAfterAMD3", "valueBeforeAMD2", "valueInsideMD5", "valueAfterMD2", "valueBeforemd2", "valueAfterAMD2"], "array": ["feature", "app", "error", "data", "vector", "archive", "batch", "allow", "arr", "range", "Array", "audio", "database", "pair", "any", "binary", "expression", "sample", "cache", "instance", "section", "collection", "shape", "angle", "address", "row", "list", "storage", "image", "value", "api", "arrow", "air", "object", "our", "number", "view", "function", "message", "result", "record", "integer", "area", "string", "element", "ray"], "sb": ["SB", " SB", "BB", "bm", "cb", "sl", "ob", "sg", "nn", "si", "lp", "bj", "gb", "s", "sbm", "bs", "sth", "bt", "eb", "lab", "bh", "xb", "bl", "binary", "kb", "bb", "rob", "mb", "sv", "bp", "ruby", "rb", "sq", "buffer", "abb", "lb", "stab", "zb", "lr", "sa", "pb", "ab", "wb", "nb", "src", "bsp", "bf", "sf", "orb", "usb", "obb", "fb", "bc", "ib", "buf"], "j": ["x", "job", "ji", "ij", "f", "y", "jj", "bj", "q", "g", "p", "k", "ie", "pr", "jp", "br", "num", "part", "l", "aj", "ja", "e", "key", "o", "dy", "d", "i", "z", "ch", "js", "J", "v", "li", "code", "n", "ii", "uj", "c", "jo", "index", "jl", "adj", "out", "length", "obj", "end"], "b": ["x", "be", "bin", "BB", "job", "cb", "f", "y", "bit", "bs", "p", "k", "eb", "binary", "bb", "bi", "B", "br", "mb", "l", "bug", "e", "bc", "rb", "d", "i", "bar", "db", "lb", "n", "ab", "c", "pb", "a", "bf", "orb", "fb", "nb", "ib", "ob"], "valueAfterMD5": ["valueBeforeMD7", "valueAfterMP3", "valueAfterVM7", "valueAfterMP5", "valueBeforeMP2", "valueBeforeMD3", "valueBeforeMP5", "valueAfterMD7", "valueBeforeMP3", "valueBeforeMP7", "valueAfterVM5", "valueAfterMP7", "valueAfterAMD5", "valueAfterVM2", "valueBeforeMD2", "valueAfterMD3", "valueAfterAMD3", "valueAfterVM3", "valueAfterMD2", "valueAfterMP2", "valueAfterAMD7", "valueAfterAMD2"]}}
{"id1": "255765", "id2": "14191679", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"f": ["x", "inf", "df", "name", "ff", "self", "fen", "s", "g", "m", "p", "j", "fe", "fun", "b", "w", "rf", "F", "l", "r", "fn", "fi", "e", "tf", "fr", "lf", "fold", "this", "d", "fx", "feed", "t", "cf", "path", "h", "filename", "of", "v", "form", "n", "io", "flat", "c", "file", "function", "fa", "folder", "a", "fd", "bf", "sf", "fp", "fo", "fm", "ref", "fc", "fs"], "in": ["lock", "login", "data", "str", "vin", "is", "ssl", "b", "w", "win", "IN", "err", "d", "source", "t", "exec", "c", "it", "socket", "session", "g", "ins", "pin", "m", "fe", "inner", "rin", "init", "nin", "or", "thin", "up", "fa", "gin", "reader", "p", "cin", "In", "part", "with", "r", "ini", "image", "inc", "config", "n", "con", "serv", "connection", "bin", "isin", "get", "ex", "min", "gen", "rec", "again", "l", "din", "v", "pass", "inn", "a", "ic", "lin", "token", "input", "diff", "ac"], "cbuf": ["bault", "bcault", "bbull", "cbull", "bcurs", "CBuff", "rbux", "cbuu", "zbutf", "bcull", "dbuc", "bcuf", "CBuc", "bcux", "zbuu", "cbault", "cfuff", "buff", "dbuff", "rbul", "bbuff", "CBuf", "cfur", "cfuc", "rbbuf", "rbutf", "cburs", "rbull", "rburs", "zbuff", "ebutf", "cbur", "CBul", "ebuff", "ebuf", "rbuu", "dbuf", "bcul", "fbuc", "cbul", "rbuf", "cbuff", "bcuff", "bux", "rbault", "bburs", "cbutf", "fbbuf", "ebuu", "buf", "fbuf", "bcuc", "rbuff", "cbuc", "cbux", "dbur", "cfuf", "cfbuf", "bcur", "fbuff", "bbuf", "rbuc", "cbbuf", "zbuf"], "read": ["iter", "data", "name", "type", "put", "know", "only", "find", "reads", "orig", "loop", "w", "work", "val", "d", "buffer", "select", "want", "fill", "close", "update", "io", "cel", "length", "report", "print", "re", "end", "wait", "READ", "open", "it", "socket", "Read", "error", "allow", "g", "play", "stream", "se", "load", "en", "ind", "log", " write", "ok", "key", "bind", "call", "count", "parse", "build", "level", "oct", "id", "last", "record", "insert", "use", "start", "bit", "x", "reader", "ride", "un", "create", "send", "add", "check", " READ", "old", "r", "each", "ak", "seek", "run", "lex", "ing", "feed", "connect", "inc", "config", "raw", "valid", "full", "er", "readable", "y", "get", "q", "ack", "change", "sync", "k", "used", "hex", "rc", "text", "size", "num", "child", " Read", "reading", "view", "pass", "pe", "ink", "repeat", "index", "ed", "input", "ize", "skip", " reading", "sleep", "draw", "write"], "totRead": ["ntottReader", "tottDraw", "TotaRead", "ntottLoad", "tobyFind", "tollRead", "toyDraw", "totoRead", "TotLoad", "tottFind", "totaLink", "ntotLoad", "tollLoad", "octotoRead", "tottReader", "tcotLoad", "tntRead", "dotReader", "tottLength", "dotWrite", "totoUse", "tottClose", "dottFind", "ntottRead", "octotoWrite", "totalWrite", "totingGet", " totalLink", "totingSearch", "tottSearch", "tottedRead", "nottLoad", "dottLoad", "totLength", "tobyRead", " totalBuild", "ntotReader", "tollReading", "tottedWrite", "totalLoad", "totaReader", "TotSearch", "notLoad", "tochReader", "TottLoad", " totalRead", "tottAccept", "tottConnect", "totiRead", "towAccept", "tatWrite", "tatReader", "TottGet", "totGet", "tottRead", "TottReading", "totoWrite", "TottReader", "tazonClose", "totiBuild", "tetReading", "octotRead", "TottFollow", "tottFollow", "TotConnect", "TotReader", "notWrite", "tntReader", "octotLength", "totoSearch", "totoLength", "tntWrite", "totaBuild", "tatRead", "tottLoad", "intottRead", "totalAccept", "tottReading", "totingRead", "totFollow", "TotWrite", "totDraw", "tntLoad", "TottWrite", "totalRead", "towWrite", "toyRead", "dottUse", "totSearch", "tetLoad", "tottUse", "tottedFollow", "nottRead", "TottRead", "dottReading", "dotReading", "tcotClose", "TottSearch", "totoReading", "tobyUse", "totLink", "TotReading", "totalLink", "towReading", "ntottWrite", "TotGet", "tottedGet", "tetWrite", "totBuild", "tochWrite", "totoFind", "totReader", "totingConnect", "towRead", "totingFollow", "dotRead", "dottReader", "TotaWrite", "intottClose", "tobyLoad", "toyWrite", "totoConnect", "intotBuild", "totAccept", "intotRead", "tazonBuild", "notAccept", "dotLoad", "toyLoad", "totWrite", " totBuild", "TottConnect", "towLoad", "tochLoad", "tazonRead", "TotRead", "TotaLoad", " totWrite", "totoLoad", "totaLoad", "totiLink", "tottWrite", "totClose", "octotoLength", "dotFind", "tetRead", "intotLoad", "octotReading", "ntotRead", "tottBuild", "totalBuild", "towLength", "tollWrite", "tochRead", "octotoReading", "intotClose", "totaDraw", "TotaDraw", "totLoad", "totaWrite", " totalWrite", "nottWrite", "tazonLoad", "tcotRead", "totaRead", "TotDraw", "totingWrite", "tottGet", "totUse", "ntotWrite", "totConnect", "intottLoad", "intottBuild", "totFind", "totiWrite", "dottWrite", "octotWrite", "tatLoad", "notRead", "tcotBuild", "nottAccept", "dotUse", "totReading", "totaReading", "dottRead", "TotFollow", " totLink"], "out": ["x", "connection", "bin", "ext", "socket", "s", "g", "sync", "p", "ex", "outs", "In", "conn", "b", "w", "output", "again", "part", "conf", "l", "r", "fn", "writer", "err", "plus", "o", "off", "client", "OUT", "d", "init", "inc", "t", "h", "exec", "parent", "v", "outer", "n", "io", "net", "c", "file", "up", "a", "exp", "ac", "Out", "obj"], "i": ["data", "current", "name", "ie", "me", "is", "bi", "b", "o", "d", "buffer", "source", "h", "xi", "uri", "io", "c", "gi", "length", "si", "it", "g", "m", "ori", "ind", "ix", "I", "u", "key", "abi", "init", "z", "yi", "mi", "ui", "li", "id", "ai", "start", "x", "ti", "my", "j", "info", "p", "one", "hi", "ei", "multi", "qi", "r", "fi", "e", "ini", "ci", "api", "ik", "oi", "zi", "ii", "ni", "iu", "eni", "phi", "ip", "ji", "y", "ri", "q", "slice", "pi", "k", "di", "l", "v", "index", "chi", "ic", "input"]}}
{"id1": "11484416", "id2": "13063241", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"moveFile": [" movedDirectory", " moveDirectory", "MoveFiles", " movedFiles", "moveFiles", "MoveDirectory", " movedPath", " movedFile", " moveFiles", "movePath", "moveDirectory", " movePath", "MovePath", "MoveFile"], "orig": ["bin", "iter", "ext", "Orig", "f", "loc", "org", "origin", "archive", "ctr", "remote", "raf", "array", "ori", "info", "comb", "base", "prev", "copy", "img", "old", "coord", "raid", "dest", "imag", "temp", "rb", "exe", "proxy", "source", "real", "init", "image", "build", "bas", "original", "file", "folder", "id", "impl", "src", "transform", "frame", "coll", "home", "internal", "obj", "buf", "tmp"], "target": ["nt", "f", "current", "it", "force", "origin", "manager", "master", "archive", "arget", "remote", "reference", "auto", "to", "base", "prot", "format", "copy", "match", "eth", "dest", "temp", "this", "ret", "external", "source", "build", "template", "t", "project", "path", "parent", "object", "next", "platform", "original", "Target", "resource", "join", "result", "replace", "compatible", " Target", "tmp"], "buffer": ["bin", "iter", "uffer", "sequence", "data", "batch", "reference", "slice", "layer", "buff", "stack", "Buffer", "binary", "base", "position", "copy", "bb", "cache", "b", "bytes", "content", "address", "padding", "source", "block", "feed", "request", "url", "transfer", "read", "code", "raw", "null", "repeat", "file", "wave", "message", "frame", "header", "result", "resource", "input", "queue", "length", "write", "buf"], "bread": ["ffe", "rows", "bat", "fen", "batch", "robe", "piece", "fle", "ble", "fall", "good", "web", "rub", "div", "fe", "eb", "zero", "str", "fine", "fed", "bn", "loop", "bb", "die", "beat", "cook", "num", "zip", "wake", "bare", "key", "circ", "design", "bc", "abi", "meal", "feed", "cake", "raft", "brew", "choice", "fred", "food", "wen", "bee", "width", "hello", "inn", "knife", "buck", "grain", "sleep", "fee", "length", "fif", "rib", "four", "broken"], "fis": ["fiss", "lfos", "afis", "ufiss", "hIs", "fisa", " fisa", "his", "qils", "lfis", "fIs", " fIs", "fxIs", "fxis", "fxisa", "afiss", "afos", "afIs", "fxos", "qos", "fils", "hisa", "qiss", " fiss", "lfIs", "ufils", " fils", "lfiss", "qis", "ufis", "hos", "ufos"], "fos": ["infaos", " foss", "flens", "Foses", "foses", "flois", "fose", "flose", "Fose", "gros", "Fois", "Faos", "gis", "flaos", "Fros", " fose", "flors", "floses", "gos", "Fens", " foses", "Fis", "infos", "infois", "fors", "fros", "Foss", "goss", "foss", " fens", "Fos", " fros", "fois", "faos", "flos", "Fors", "fens", "infors"]}}
{"id1": "10504714", "id2": "23152865", "code1": "    private MediaWikiResult getFromUri(String url) throws OntologyServiceException {\n        try {\n            logger.info(\"getting \" + url);\n            HttpURLConnection connection = (java.net.HttpURLConnection) new URL(url).openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"OntoCat-\" + Math.random());\n            BufferedInputStream bin = new BufferedInputStream(connection.getInputStream());\n            JAXBContext jaxbContext = JAXBContext.newInstance(\"uk.ac.ebi.ontocat.mediawiki.jaxb\");\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n            return (MediaWikiResult) unmarshaller.unmarshal(bin);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new OntologyServiceException(e);\n        }\n    }\n", "code2": "    protected JavaFileObject open(String className) throws IOException {\n        JavaFileObject fo = getClassFileObject(className);\n        if (fo != null) return fo;\n        String cn = className;\n        int lastDot;\n        while ((lastDot = cn.lastIndexOf(\".\")) != -1) {\n            cn = cn.substring(0, lastDot) + \"$\" + cn.substring(lastDot + 1);\n            fo = getClassFileObject(cn);\n            if (fo != null) return fo;\n        }\n        if (!className.endsWith(\".class\")) return null;\n        if (fileManager instanceof StandardJavaFileManager) {\n            StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;\n            fo = sfm.getJavaFileObjects(className).iterator().next();\n            if (fo != null && fo.getLastModified() != 0) {\n                return fo;\n            }\n        }\n        if (className.matches(\"^[A-Za-z]+:.*\")) {\n            try {\n                final URI uri = new URI(className);\n                final URL url = uri.toURL();\n                final URLConnection conn = url.openConnection();\n                return new JavaFileObject() {\n\n                    public Kind getKind() {\n                        return JavaFileObject.Kind.CLASS;\n                    }\n\n                    public boolean isNameCompatible(String simpleName, Kind kind) {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public NestingKind getNestingKind() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Modifier getAccessLevel() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public URI toUri() {\n                        return uri;\n                    }\n\n                    public String getName() {\n                        return url.toString();\n                    }\n\n                    public InputStream openInputStream() throws IOException {\n                        return conn.getInputStream();\n                    }\n\n                    public OutputStream openOutputStream() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Writer openWriter() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public long getLastModified() {\n                        return conn.getLastModified();\n                    }\n\n                    public boolean delete() {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            } catch (URISyntaxException ignore) {\n            } catch (IOException ignore) {\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"getFromUri": ["getfromPUUrl", "getfromUri", "getFromURuri", "getFromRuri", "getfromUUrl", "getFromRuuri", "getFromURI", "getFromPUri", "getFromURri", "getFromPUUrl", "getfromUuri", "getfromPUuri", "getFromPURI", "getFromRuUrl", "getFromRuRI", "getFromURUrl", "getfromURI", "getFromUuri", "getFromUUrl", "getFromURRI", "getfromPURI", "getfromPUri", "getFromPUuri"], "url": ["full", "sl", "loc", "data", "name", "ri", "email", "type", "ur", "language", "layer", "info", "download", "str", "base", "ll", "rule", "ls", "ssl", "page", "href", "l", "address", "Url", "buffer", "URL", "i", "source", "image", "feed", "build", "proxy", "request", "path", "filename", "lr", "server", "uri", "route", "http", "file", "id", "src", "result", "resource", "www", "host", "location", "string", "username"], "connection": ["channel", "socket", "handler", "database", "j", "application", "position", "conn", "b", "part", "section", " Connection", "writer", "collection", "translation", "password", "client", "proxy", "service", "i", "connected", "image", "db", "connect", "condition", "which", "response", "object", "ion", "character", "context", "config", "number", "relation", "uri", "server", "io", "http", "c", "in", "function", "index", "con", "directory", "network", "Connection", "communication", "use", "bc"], "bin": ["border", "login", "sin", "data", "channel", "socket", "container", "database", "pin", "body", "brain", "bn", "bot", "binary", "base", "plugin", "bb", "bi", "conn", "b", "inner", "output", "win", "din", "ruby", "ran", "bean", "bc", "abi", "buffer", "lib", "spin", "bon", "ban", "bis", "inn", "in", "file", "src", "input", "bit"], "jaxbContext": ["jaxaContext", "japaText", "jjbContext", "japaSupport", "jjbChannel", "jaxfbContext", "jaxeSupport", "jaxfText", "japbSupport", "jaxfbcontext", "jjfcontext", "jjfText", "jaxbText", "jaxfbChannel", "jaxfContext", "jaxaSupport", "jjfChannel", "jaxpContext", "jaxfChannel", "jjbText", "jaxfbText", "jaxecontext", "jaxaText", "jaxbcontext", "japaContext", "japbText", "jaxeText", "japacontext", "japbcontext", "jjfContext", "japbContext", "jaxeContext", "jjbcontext", "jaxbChannel", "jaxpcontext", "jaxpText", "jaxpChannel", "jaxfSupport", "jaxbSupport", "jaxfcontext", "jaxacontext"], "unmarshaller": ["unmarshalers", "unmarshallingender", "unmarshallsers", "unmarshallsiner", "unmarshaler", "unmarshallER", "unmarshdaler", "unmarshulletter", "unmarshalliner", "unmarshdalender", "unmarshuller", "unmarshalleder", "unmarshALLers", "unmarshallers", "unmarshdaletter", "unmarshullender", "unmarshaliner", "unmarshALLER", "unmarshalletter", "unmarshulleder", "unmarshallingeder", "unmarshALLer", "unmarshalER", "unmarshallinger", "unmarshALLiner", "unmarshallingetter", "unmarshdaleder", "unmarshallser", "unmarshallsER", "unmarshallender"]}}
{"id1": "22977189", "id2": "13063241", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"in": ["reader", "bin", "isin", "er", "f", "login", "data", "socket", "g", "ins", "cin", "min", "In", "is", "inside", "b", "inner", "again", "win", "r", "din", "IN", "err", "plus", "ini", "this", "i", "source", "init", "image", "inc", "nin", "url", "n", "read", "pass", "inn", "c", "up", "as", "id", "lin", "input", "con", "ln", "re", "gin"], "out": ["ext", "data", "name", "self", "at", "pool", "outs", "w", "b", "err", "flow", "o", "flush", "off", "exec", "default", "io", "as", "point", "error", "log", "page", "conn", "cache", "inner", "output", "query", "key", "client", "call", "init", "outer", "parent", "up", "word", "app", "f", "plain", "copy", "part", "r", "writer", "temp", "this", "inc", "n", "raw", "prefix", "Out", "obj", "connection", "bin", "s", "sync", "ex", "user", "again", "password", "OUT", "list", "comment", "block", "object", "server", "file", "a", "window", "write", "editor", "strip"], "line": ["lock", "sl", "f", "data", "name", "char", "str", "letter", "log", "rule", "lc", "inline", "page", "text", "content", "l", "cell", "lines", "lf", "key", "column", "row", "comment", "i", "style", "block", "source", "entry", "feed", "value", "Line", "character", "url", "next", "cl", "code", "pass", "unit", "pe", "c", "file", "id", "LINE", "word", "message", "lin", "header", "link", "string", "write", "end"]}}
{"id1": "5682569", "id2": "9398454", "code1": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"metodo1": [" utando1", " metando3", " utodo3", " metodo2", " utodo2", " utando2", " utando8", " metato8", " metango2", " metato1", " metodo3", " metodo8", " metando1", " metango3", " utodo8", " metato2", " metando8", " utodo1", " utando3", " metando2", " metango1", " metato3", " metango8"], "temp": ["offset", "iter", "alt", "f", "current", "data", "mag", "Temp", "modified", "mini", "type", "stable", "emp", "p", "partial", "j", "clean", "status", "lc", "cache", "txt", "tem", "pre", "font", "dest", "test", "count", "source", "z", "t", "parent", "v", "default", "level", "tmp", "empty", "null", "flat", "c", "index", "prefix", "tc", "cel", "cut", "diff", "result", "fake", "length"], "flagDesordenado": ["flagDesordencad", "flagDesordernada", "flagDesordeniano", "flagDesORDENad", "flagDesordinato", "flagDesordennada", "flagDesordienado", "flagDesORDenano", "flagDesordencada", "flagDesORDENano", "flagDesideredenar", "flagDesordinado", "flagDesordernar", "flagDesordencado", "flagDesordeniado", "flagDesordeniada", "flagDesordienada", "flagDesordienad", "flagDesordeniad", "flagDesordenido", "flagDesordernad", "flagDesordainar", "flagDesordinaban", "flagDesordenar", "flagDesordeniido", "flagDesordinada", "flagDesordainado", "flagDesordainada", "flagDesordenano", "flagDesordeniaban", "flagDesordienato", "flagDesideredenado", "flagDesideredainar", "flagDesordenaban", "flagDesordainido", "flagDesordeniato", "flagDesordernato", "flagDesideredenido", "flagDesordenada", "flagDesordernido", "flagDesordennado", "flagDesordencano", "flagDesORDENada", "flagDesORDenad", "flagDesORDenada", "flagDesordenato", "flagDesordenad", "flagDesordernado", "flagDesideredainada", "flagDesordeniar", "flagDesideredenada", "flagDesordENada", "flagDesORDenado", "flagDesordennato", "flagDesordENad", "flagDesordENado", "flagDesORDENado", "flagDesordennaban", "flagDesideredainido", "flagDesordENano", "flagDesideredainado"], "i": ["x", "ji", "f", "data", "si", "it", "start", "ti", "ri", "mini", "slice", "j", "p", "info", "pi", "k", "load", "ix", "hi", "lc", "I", "bi", "u", "b", "di", "multi", "part", "qi", "l", "left", "e", "key", "ini", "abi", "source", "ci", "init", "image", "cli", "api", "list", "xi", "oi", "v", "ui", "mi", "li", "n", "uri", "ii", "io", "c", "ni", "id", "index", "iu", "chi", "mu", "eni", "ai", "gi", "phi", "diff", "ip", "site"], "tabla": ["tabela", "cellla", "abla", "cellna", "tagela", " tablo", "tagula", "tablela", "tableela", "tagla", "Tablas", " tabula", "tabula", "abula", " taba", "tabna", "cellela", "tablo", "Tabula", "tablelas", "Tablo", "Tabla", "taglas", "Taba", "tablas", "ablas", " tabna", " tablas", "abela", " tabela", "Tabela", "tagna", "taga", "taba", "cellula", "tablea", "taglo", "ablo"]}}
{"id1": "12306305", "id2": "364438", "code1": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"doCopyFile": ["DoCopfile", "DoCopFile", "DoCopyFiles", "docopyfile", "doCopyDirectory", "doCopDirectory", "doTransferFiles", "DoCopyfile", "doCopyFiles", "docopyFile", "doTransferDirectory", "doCopFiles", "DoCopyDirectory", "doTransferFile", "docopyFiles", "DoCopyFile", "doCopfile", "doCopFile", "DoCopFiles", "DoCopDirectory", "doCopyfile", "doTransferfile", "docopyDirectory"], "srcFile": ["rcDir", "rcFile", "destfile", "rcDirectory", " srcPage", "srcFilename", "srcDirectory", " srcPath", "srcFiles", "sourcePage", " srcFilename", "sourceDir", "srcPage", "destDir", "instfile", "accessFile", "sourceDirectory", " srcDir", "sourceFiles", " srcFiles", "instFile", "accessPage", "instDir", "rcfile", " srcDirectory", "destPath", "accessPath", "destFilename", "sourcefile", "instPage", "srcPath", "destFiles", "srcfile", " srcfile", "sourceFile", "destPage", "accessFilename", "rcPage", "srcDir"], "destFile": ["DestFile", "optFile", " DestFile", "destfile", "homeFile", "srcFiles", "srcDirectory", "targetFile", "homeDir", " destTime", "DestPage", "sourceDir", "sourcePage", "destDir", "srcTime", "optSourceFile", " Destfile", "descFilename", "descFolder", " destPath", "DestTime", " destDir", "DestFiles", "destTime", "flatFile", "sourceDirectory", "homeFiles", "destSourceFile", "targetSourceFile", "srcSourceFile", "Destfile", "targetfile", "restFile", " destSourceFile", "DestDir", "flatFolder", " destFilename", "descFile", " destFolder", "flatFilename", " destFiles", " DestTime", " destDirectory", " DestDir", "restSourceFile", "destPath", "targetPath", "destTitle", " destTitle", "targetFiles", "destFilename", "destFolder", "restDirectory", "DestDirectory", "flatTitle", "optfile", "targetDirectory", " destfile", "restTime", "destFiles", "srcfile", " destPage", "descTitle", "optPath", "sourceFile", "destPage", "homefile", "destDirectory", "srcDir"], "preserveFileDate": ["preserveDirectoryTime", "preservingFilesDate", "preservingFilesSince", "preserveFilesDay", "preserveUnitSince", "preserveTimeDay", "preserveDirectoryDay", "preservingFilesdate", "preserveFileSince", "preservingFileDate", "preservedFileDay", "preserveFilesdate", "preserveFilesDate", "preserveTimeTime", "preserveFiledate", "preserveDirectoryDate", "preservingFileSince", "preserveFilesTime", "preserveTimedate", "preserveLinedate", "preservedTimeTime", "preserveLineSince", "preserveFilesSince", "preservedFileTime", "preserveDirectorydate", "preservedTimedate", "preserveTimeDate", "preservedFiledate", "preservedTimeDate", "preservedTimeDay", "preservedFileDate", "preserveUnitdate", "preserveFileTime", "preservingFiledate", "preserveUnitDate", "preserveFileDay", "preserveLineDate"], "input": ["active", "reader", "connection", "open", "current", "data", "self", "channel", "socket", "error", "audio", "stream", "event", "binary", "copy", "conn", "inner", "instance", "client", "address", "temp", "this", "buffer", "i", "source", "image", "child", "feed", "request", "api", "parent", "exec", "form", "context", "url", "config", "view", "null", "io", "in", "file", "up", "upload", "out", "internal", "Input", "ip"], "output": ["connection", "office", "current", "version", "ilo", "channel", "socket", "put", "audio", "operation", "application", "download", "control", "copy", "video", "again", "writer", "flow", "o", "address", "console", "external", "source", "image", "child", "feed", "oper", "parent", "response", "outer", "environment", "next", "other", "object", "config", "unit", "null", "core", "io", "file", "queue", "out", "ou", "target", "write", "Output", "four"]}}
{"id1": "13720140", "id2": "15018553", "code1": "    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {\n        Property property = new Property(new Long(valueID), userID);\n        String newValue = value;\n        System.out.println(property.getName());\n        if (property.getName().equals(\"Password\")) {\n            try {\n                MessageDigest crypt = MessageDigest.getInstance(\"MD5\");\n                crypt.update(value.getBytes());\n                byte digest[] = crypt.digest();\n                StringBuffer hexString = new StringBuffer();\n                for (int i = 0; i < digest.length; i++) {\n                    hexString.append(hexDigit(digest[i]));\n                }\n                newValue = hexString.toString();\n                crypt.reset();\n            } catch (NoSuchAlgorithmException e) {\n                System.err.println(\"jspShop: Could not get instance of MD5 algorithm. Please fix this!\" + e.getMessage());\n                e.printStackTrace();\n                throw new JspTagException(\"Error crypting password!: \" + e.getMessage());\n            }\n        }\n        property.setValue(newValue);\n    }\n", "code2": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"modifyProperty": ["modifiedproperty", "modureString", "ModifyProperty", "modifyString", "Modifiedproperty", "modateAttribute", "modifiedString", "modateString", "modateProperty", "ModifiedProperty", "Modifyproperty", "modateproperty", "ModifyString", "modureAttribute", "modifyproperty", "modifyAttribute", "modifiedAttribute", "modifiedProperty", "modureProperty", "modureproperty", "ModifyAttribute", "ModifiedString", "ModifiedAttribute"], "valueID": ["jobIP", "jobid", "propertyID", "VALUEid", "propertyid", "VALUEIndex", "propertyId", "propertyIP", "jobId", "valueid", "Valueid", "ValueIndex", "ValueId", "ValueID", "contentIndex", "valueId", "contentID", "VALUEID", "jobID", "valueIndex", "valueIP", "contentid", "ValueIP"], "value": ["values", "data", "name", "reference", "command", "language", "string", "array", "expression", "format", "description", "text", "output", "content", "val", "password", "key", "address", "secret", "padding", "source", "entry", "image", "example", "response", "phrase", "object", "pattern", "v", "attribute", "update", "default", "number", "document", "server", "code", "function", "message", "result", "resource", "Value", "target", "token", "VALUE", "element", "username"], "userID": [" userid", "userName", " userName", "authorMAC", "UserMAC", "authorID", "UserId", " userMAC", "userid", "Userid", "UserName", "userMAC", " userId", "authorId", "userId", "authorName", "UserID", "authorid"], "property": ["prop", "connection", "feature", "profile", "Property", "data", "name", "type", "method", "operation", "layer", "p", "pair", "info", "variable", "field", "definition", "expression", "base", "position", "part", "entity", "term", "section", "password", "key", "address", "temp", "this", "style", "entry", "project", "parent", "object", "attribute", "character", "update", "config", "prototype", "metadata", "jo", "function", "primary", "prefix", "module", "message", "operator", "resource", "result", "properties", "foo", "string", "option", "element", "tmp"], "newValue": ["defaultvalue", "newVALUE", "nextVALUE", "newString", "oldVALUE", " newVALUE", "nextValue", "NewString", "rawVal", "replaceVALUE", " newString", " newvalue", "replaceValue", "oldValue", "NewVal", "nextvalue", "nextVal", "replaceVal", "rawString", "defaultVALUE", "newvalue", "defaultVal", "currentvalue", "rawVALUE", " newVal", "newVal", "oldVal", "currentVALUE", "currentValue", "rawValue", "defaultValue", "NewValue", "oldvalue", "NewVALUE", "currentVal", "replacevalue"], "crypt": ["pool", "ctr", "pt", "python", "ca", "cash", "dec", "bec", "enc", "comb", "ec", "utils", "hex", "binary", "prot", "ssl", "copy", "cache", "conn", "cook", "contract", "mac", "cmd", "cr", "Crypt", "ryption", "password", "key", "client", "temp", "mix", "cmp", "lib", "cc", "poly", "rypt", "ch", "chain", "hash", "code", "conv", "core", "c", "com", "coin", " cryptography", "coll", "cm", "con", "security", "auth", "cp", "chip"], "digest": ["digress", "encoded", "signEST", "designit", "Digist", "genested", "cododed", "gener", "digit", "DigEST", "crester", "digoded", "Digester", "Digusher", "Digend", "codester", "crist", "digested", "genest", "ddusher", "designest", "designester", "digester", "digEST", "digist", "ddest", "ddester", "Digoded", " digist", "crest", " digend", "Digested", "digend", "signested", "diger", "digusher", "signer", "encest", "Diger", "crend", "codress", "genEST", "signest", "Digit", "codest", "encress", "designusher", "Digress", " digester", "Digest", "encester", "ddit"], "hexString": ["rexArray", "hashStr", "hexstring", "hexArray", " hexArray", "exArray", "byteBuffer", " hexBuffer", "exstring", "rexBuffer", "tempArray", "exBuffer", "cryptBuffer", "hexBuffer", "tempSection", "hashArray", "hashString", "rexString", "byteArray", "tempBuffer", "cryptArray", "hexSection", "tempString", " hexStr", "cryptSection", "hashBuffer", "exString", "byteString", "byteStr", "hexStr", " hexstring", " hexSection", "rexstring", "cryptString"], "i": ["x", "f", "data", "si", "it", "ti", "ri", "s", "slice", "m", "p", "j", "info", "pi", "k", "field", "ix", "hi", "I", "di", "u", "b", "multi", "bi", "l", "r", "e", "key", "o", "abi", "d", "ci", "init", "h", "xi", "v", "oi", "ui", "li", "uri", "ii", "io", "c", "in", "id", "index", "mu", "pos", "gi", "phi", "ip"]}}
{"id1": "1180878", "id2": "22410173", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchURLdata", "frieveURLData", "fetchHTTPDATA", "frieveUrldata", "fetchHTTPdata", "fetchJSONdata", "frieveUrlData", "fetchUrldata", "frieveUrlDATA", "fetchJSONDATA", "fetchHTTPData", "frieveURLdata", "frieveURLDATA", "fetchUrlData", "fetchURLDATA", "fetchUrlDATA", "fetchJSONData"], "url": ["connection", "sl", "f", "loc", "data", "name", "fl", "ur", "gl", "el", "download", "xml", "base", "ssl", "ls", "html", "page", "user", "text", "href", "l", "address", "Url", "URL", "source", "image", "feed", "api", "path", "filename", "view", "uri", "server", "http", "file", "src", "resource", "www", "host", "location", "string", "username"], "proxyHost": ["ProxyDomain", "proxyHead", "baseHost", " proxyAddress", "serverAddress", "proxyAddress", "cacheHost", "serverPath", "remoteDomain", " proxyhost", "baseAddress", "cachePort", "proxyhost", "cachehost", "ProxyAddress", "proxyServer", "ProxyHead", "baseHead", "baseDomain", "ProxyHost", " proxyServer", "remoteHead", "Proxyhost", "cacheAddress", "ProxyPort", "remoteHost", "proxyDomain", "ProxyPath", "serverServer", "ProxyServer", "serverHost", "proxyPath", " proxyPath", "remoteAddress"], "proxyPort": [" proxyAddress", "httpHost", "proxyAddress", "cacheHost", "cachePort", "ProxyAddress", " proxyport", "Proxyport", "httpPort", "proxyServer", "httpServer", "ProxyHost", "proxyport", " proxyServer", "cacheAddress", "ProxyPort", "ProxyServer", "httpAddress", "cacheport"], "con": ["login", "ls", "win", "go", "common", "ocon", "exec", "xc", "close", "pen", "conv", "c", "com", "co", "on", "ctrl", "out", "fan", "re", "fc", "open", "cur", "socket", "pin", "syn", "pub", "en", "pc", "canon", "conn", "cache", "conf", "don", "sub", "fa", "ai", "cone", "bc", "cons", "x", "act", "ver", "f", "cn", "fl", "un", "remote", "ec", "per", "fun", "part", "cr", "pre", "ran", "ci", "cc", "run", "connect", "inc", "n", "http", "an", "cas", "mc", "cp", "connection", "fac", "ca", "change", "sync", "min", "gen", "rc", "rec", "can", "Con", "uc", "CON", "cf", "ch", "cl", "func", "cm", "ac"], "is": ["isin", "ais", "Is", "iss", "get", "si", "it", "cos", "isl", "ri", "does", "s", "oss", "bs", "p", "info", "has", "state", "ori", "cms", "ics", "os", "im", "ie", "isa", "IS", "cs", "isc", "conn", "abs", "was", "can", "ops", "ar", "its", "i", "sp", "mis", "isu", "ws", "api", "or", "js", "il", "ci", "bis", "vs", "ir", "ps", "ris", "as", "in", "iso", "act", "id", "iris", "are", "es", "ai", "out", "us", "ios", "lis", "serv", "fs", "ib", "isi"], "u": ["ul", "su", "f", "q", "un", "ur", "m", "p", "ut", "ru", "os", "user", "b", "U", "conn", "l", "o", "client", "lu", "yu", "fu", "i", "uc", "api", "h", "v", "ui", "ue", "uri", "uv", "cu", "io", "c", "http", "file", "up", "hu", "iu", "uci", "ou", "us", "nu", "tu"], "proxy": ["x", "connection", "f", "force", "socket", "phone", "pool", "Proxy", "type", "create", "pin", "XY", " proxies", "remote", "p", "web", "timeout", "fe", "pc", "ssl", "prot", "copy", "cache", "wrapper", "xy", "zip", "l", "cop", "plus", " Proxy", "client", "address", "bean", "lib", "port", "api", "config", "server", "uri", "pse", "pe", "http", "c", "shadow", "clone", "pa", "resource", "host", "ip", "roxy"], "baos": ["abros", "calos", "BAis", "hao", "pao", "caas", "boOS", "BAros", "caos", "hais", "bao", "BAos", "haos", "paos", "aOS", "bolos", "bais", "pais", "baOs", "Bais", "abis", "caOS", "abOs", "BaOs", "boas", "haOS", "BAOS", "alos", "paOS", "BAOs", "baOS", "boos", "Baros", "aas", "baas", "aos", "baros", "Baos", "balos", "BAo", "abos"]}}
{"id1": "6625074", "id2": "3683344", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "label": 1, "substitutes": {"SHA1": ["SHA256", " SHA256", "HAOne", "sha256", "HA384", "SHA384", "HA1", "sha1", "shaOne", " SHA384", "SHAOne", "sha384", "HA256", " SHAOne"], "text": ["ext", "data", "name", "string", "str", "hex", "plain", "class", "letter", "format", "output", "contract", "txt", "content", "bytes", "translation", "password", "test", "buffer", "source", "image", "value", "template", "Text", "editor", "path", "struct", "object", "pattern", "context", "config", "transfer", "code", "in", "word", "message", "token", "TEXT", "input", "out", " Text", "obj", "font"], "sha1hash": ["sha_hash", "sha81log", "sha256text", "sha256password", "sha256Hash", "sha2hex", "sha1sum", "sha1hex", "ha2hex", "ha1Hash", "shaOneHash", "shaOnehash", "sha_Hash", "SHA2Hash", "ha1sum", "SHA1text", "sha6hash", "SHA1log", "SHA1cap", "sha6Hash", "sha1text", "sha6log", "shaOnetext", "SHA2log", "SHA1password", "sha_sum", "sha6cap", "ha1hex", "sha2log", "sha2cap", "SHA1Hash", "SHA2cap", "sha81cap", "sha2sum", "sha1password", "sha1cap", "ha2hash", "ha2sum", "ha1hash", "SHA1hash", "sha81Hash", "shaOnepassword", "sha2Hash", "sha1Hash", "sha81hash", "ha2Hash", "SHA2hash", "sha2hash", "sha_hex", "sha256hash", "sha1log"], "md": ["meta", "df", "bd", "vd", "f", "mag", "cd", "rm", "gb", "wd", "dd", "m", "ma", " MD", "mt", "dig", "ld", "mb", "mac", "hm", "cmd", "dm", "um", "sm", "d", "MD", "mo", "cf", "hash", "amd", "mp", "rpm", "metadata", "mm", "pm", "sha", "mc", "nd", "ms", "pd", "od", "ad", "hd", "nm", "de", "editor", "pkg"]}}
{"id1": "23118425", "id2": "21489105", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"encrypt": [" Encrypt", " Enccrypt", "Enccrypt", "Encrypt", "Encrypted", "encipher", " Encipher", "enrypt", " Encrypted", "enipher", "enrypted", "enccrypt", "encrypted", "Encipher"], "plaintext": ["broadtext", "protectedText", " plainsource", "flatstring", "flattext", "broadText", "broadstring", "flatdata", "flatstruct", " plainstruct", "protectedtext", "protectedstruct", "plainsource", " plainText", "flatsource", "plaindata", "plainText", " plainstring", "plainstring", "protecteddata", "broadsource", "plainstruct", " plaindata", "flatText"], "md": ["meta", "bd", "vd", "data", "mag", "mg", "cd", "wd", "mad", "dd", "m", "ma", " MD", "mt", "dig", "kg", "ld", "mb", "ph", "am", "mac", "hm", "cmd", "dm", "material", "dc", "d", "MD", "db", "mo", "mod", "amd", "mp", "code", "metadata", "mm", "pm", "dh", "mu", "message", "sha", "mem", "mc", "ms", "od", "mand", "pd", "hd", "nm", "pg", "Cmd", "ad", "pkg"], "raw": ["full", "channel", "ack", " hex", "stream", "array", "partial", "dec", "clean", "RAW", "enc", "load", "shared", "local", "hex", "binary", "wrap", "Raw", "instance", "content", "rew", "row", "buffer", "block", "image", "pack", "feed", "response", "serial", " RAW", "empty", "null", "ng", "original", "unsigned", "message", "input", "custom", "initial", "def", "unknown", "buf"], "hash": ["rh", "full", "data", "version", "array", "hex", "base", "log", "html", "cache", "text", "mac", "her", "kh", "password", "key", "secret", "crypt", "buffer", "row", "block", "image", "build", "value", "response", "h", "url", "sum", "code", "empty", "id", "message", "sha", "header", "ash", "auth", "Hash", "string"]}}
{"id1": "7911686", "id2": "13516684", "code1": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", " copyfile", "moveFiles", "transferFile", "moveResource", "transferfile", " copyFiles", "copyResource", " copyResource", "transferFiles", "transferResource", "movefile", "copyfile", "moveFile"], "source": ["connection", "reader", "sin", "ources", "start", "origin", "remote", "ins", "reference", "from", "stream", "slice", "sync", "ie", "base", "ource", "inside", "inner", "size", "SOURCE", "service", "proxy", "image", "parent", "object", "server", "file", "src", "resource", "input", "Source", "target", "internal", "use", "site"], "destination": ["dominated", "destinated", "restout", "deinate", "dominate", "resturation", "testinated", "Destination", "testout", "deinator", "deination", "restination", "Destinator", "Destinate", "Destout", "desturation", "domination", "deinated", "destout", "Destinated", "testuration", "testination", "dominator", "destinator", "destinate", "restinated", "Desturation"], "in": ["reader", "bin", "lock", "connection", "isin", "sin", "f", "data", "login", "name", "issue", "socket", "channel", "ins", "pin", "m", "cin", "info", "min", "In", "pc", "ie", "base", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "client", "pull", "ini", "i", "init", "image", "inc", "nin", "like", "url", "config", "n", "null", "io", "inn", "c", "as", "file", "id", "up", "a", "input", "con", "record", "gin"], "out": ["connection", "bin", "extra", "ext", "app", "outside", "data", "name", "channel", "at", "sync", "ex", "outs", "In", "plain", "copy", "conn", "b", "again", "output", "cache", "w", "vert", "cmd", "with", "writer", "IN", "err", "o", "off", "client", "OUT", "temp", "this", "call", "i", "lib", "init", "user", "inc", "nin", "parent", "outer", "of", "exit", "no", "url", "n", "null", "io", "net", "c", "up", "file", "id", "ou", "exp", "Out", "gin", "write", "obj"]}}
{"id1": "14324112", "id2": "14303294", "code1": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "code2": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "label": 1, "substitutes": {"innerProcess": ["innerprocess", "middleAccept", " innerMethod", " outerMethod", " innerAccept", "middleMethod", "middleprocess", "innerMethod", " outerAccept", "innerAccept", " innerprocess", "middleProcess", " outerProcess", " outerprocess"], "curi": ["luni", "numi", "lciri", "cuid", "Ciri", "biri", "lcri", "bURI", "cuni", "nuri", "lumi", "cui", "ctiri", "cacheuri", "funi", "cdu", "fri", " cuni", "furi", "CURI", "ctURI", "requuni", "ciri", "cURI", "requiri", "cturi", "luid", "ucURI", "buri", " cdu", "cacheui", " cui", "Cui", "cachedu", "cdirectory", " cuid", "requumi", " cURI", "ctuid", "lri", " cdirectory", "ucuri", "uciri", "lcui", "fURI", "lURI", "liri", "Cri", "fcri", " couri", "ldirectory", "lcURI", "Curi", " ciri", "fcumi", "firi", "Couri", "cacheURI", "Cdu", "cumi", "bdirectory", "ucuni", " cri", "lcuri", "couri", "luri", "requuri", "fui", "fcURI", " cumi", "lcouri", "cri", "fcuri", "nri", "nURI"], "maxsize": ["axize", "axsize", "totalsize", "Maxsize", "MaxSIZE", " maxSIZE", " maxname", "lastsize", "minSize", "defaultsize", "axSize", "MAXname", "MaxSize", " maxscale", "lastSize", "totalize", "maxname", "totalscale", "MAXSIZE", "minsize", "maxSIZE", "maxaddress", " maxSize", "Maxscale", "Maxname", "maxSize", "maxscale", "lastaddress", "minaddress", "Maxize", " maxaddress", " maxize", "defaultize", "MAXsize", "maxize", "defaultSize", "totalSize", "MAXSize"], "regexpr": ["replayor", "rerePr", "perepr", "regexpl", "pegexPr", "REgexr", "regexpp", "refgexpp", "regexexpr", "regexpect", "requpr", "refgexPr", "regexPR", "refgexpl", "egexpr", "egexPr", "rentaxexpr", "rereexpr", "reqor", "pegexexpr", "rerePR", "regexr", "rerexpr", "replaypt", "reuxpr", "rentaxPR", "replexexpr", "requpect", "REgexpr", "reuxpl", "REqpr", "egexps", "replexPR", "replaypr", "equpect", "REgexor", "regexpt", "perePR", "rerexps", "requPr", "rexpr", "resexPr", "reuxPr", "REgexpt", "replexpl", "refplexpp", "pereexpr", "resexps", "regexps", "REqor", "refplexpr", "refgexpr", "resexpr", "refplexpl", "rexpl", "rerexPr", "replexpr", "regexPr", "rentaxpr", "reuxpp", "REqpt", "pegexpr", "rexPr", "replexPr", "refplexPr", "resexpect", "replexpp", "rerexpect", "reqpr", "rerepr", "pegexPR", "egexpect", "perePr", "rexpp", "requps", "regexor", "replayr", "equps", "equPr", "equpr", "reqr", "rentaxPr", "REqr", "reqpt"], "cs": ["ts", "cn", "cos", "sc", "TS", "ds", "ca", "GC", "bs", "ences", "ins", "acks", "sync", "ns", "cms", "ics", "str", "ec", "pc", "lc", "ls", "cells", "cache", "css", "cr", "rs", "wcs", "ras", "ks", "cc", "ci", "ctx", "qs", "cf", "js", "ces", "spec", "ch", "cl", "gs", "ps", "c", "ce", "acs", "cks", "tc", "coll", "cas", "cm", "mc", "CS", "ches", "cons", "ms", "cp", "cus", "fs", "Cs", "acts"], "digest": ["signEST", "signusher", "returnEST", " diger", "DigEST", "diggest", "Digester", "Digusher", " digusher", "shaher", "shaest", "returnester", "digester", "digEST", "returnest", "signester", "shaer", " digEST", "digher", "returngest", "diger", "digusher", "Diggest", "Diger", "signest", "Digher", "shaEST", " digester", "Digest", " diggest", " digher"], "s": ["sl", "su", "f", "si", "session", "g", "groups", "services", "sets", "sync", "p", "ns", "str", "summary", "ls", "cells", "u", "b", "w", "sv", "l", "r", "single", "o", "lines", "strings", "d", "i", "S", "ws", "t", "js", "h", "v", "n", "ps", "details", "c", "params", "states", "sb", "ss", "ms", "string"], "m": ["bm", "gm", "f", "machine", "rm", "g", "p", "arm", "im", "b", "text", "imm", "am", "M", "wm", "mac", "l", "r", "dm", "ym", "um", "sm", "i", "d", "mo", "t", "h", "tm", "v", "mi", "n", "mm", "pm", "cm", "mc", "fm", "ms", "nm"]}}
{"id1": "18731843", "id2": "2461169", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"doBody": ["DoBytes", " doFile", "DoFile", "DoBody", "handleBody", "handleBytes", "doResponse", "handleResponse", " doBytes", "doBytes", "handleFile", " doResponse", "doFile", "DoResponse"], "req": ["rh", "reader", "data", "reg", "q", "respond", "qq", "comp", "info", "download", "proc", "sem", "rec", "conn", "jp", "r", "query", "err", "fr", "rr", "this", "requ", "request", "spec", "Request", "config", "http", "cgi", "src", "rss", "crit", "resource", "res", "def", "report", "ref", "qt", "serv", "obj", "rx"], "resp": ["job", "cb", "Resp", "data", "respond", "rev", "comp", "p", "download", "Response", "proc", "rec", "prot", "bb", "jp", "b", "part", "cache", "r", "pre", "val", "err", "exc", "reply", "rr", "respons", "ret", "cmp", "sp", "api", "request", "response", "rep", "pos", "result", "res", "ref", "report", "inv", "re", "html", "serv", "obj"], "bis": ["bin", "isin", "ais", "sin", "iss", "bes", "bs", "boot", "ori", "rots", "os", "bh", "binary", "obos", "is", "bian", "atis", "bi", "lins", "bb", "b", "obs", "bits", "phis", "ubis", "abi", "pins", "bid", "mis", "nis", "bas", "uds", "ois", "alis", "fb", "bps", "tis", "ris", "iris", "oris", "sb", "sis", "los", "ios", "usb", "lis", "obb", "obi", "ses"], "bos": ["bott", "osa", "lol", "bin", "oS", "opus", "fits", "las", "bes", "oos", "bs", "boot", "os", "bh", "lins", "obos", "bi", "obs", "bits", "antis", "ops", "oses", "phis", "oks", "ubis", "abi", "bris", "mos", "bas", "ois", "uds", "obo", "oops", "tis", "bps", "osi", "oros", "aos", "bo", "ros", "los", "ios", "zo", "zos", "obb", "obi", "bones"]}}
{"id1": "62362", "id2": "4973095", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public Wget2(URL url, File f) throws IOException {\n        System.out.println(\"bajando: \" + url);\n        if (f == null) {\n            by = new ByteArrayOutputStream();\n        } else {\n            by = new FileOutputStream(f);\n        }\n        URLConnection uc = url.openConnection();\n        if (uc instanceof HttpURLConnection) {\n            leerHttp((HttpURLConnection) uc);\n        } else {\n            throw new IOException(\"solo se pueden descargar url http\");\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["conception", " deconvert", "Convert", "converting", "subvert", "unversion", " deconverting", "CONverting", "unvert", "CONvert", "unception", "Conversion", " deconverted", "unverted", "subverted", "Converted", "conversion", " deconversion", "CONverted", "subversion", "oconvert", "CONversion", "converted", "Conception", "Converting", "CONception", "subverting", "oconversion", "oconverted", "oconverting"], "src": ["reader", "username", "cb", "sin", "loc", "RC", "name", "sn", "gb", "s", "sc", "slice", "cpp", "stream", "st", "secure", "inst", "download", "sth", "load", "gz", "proc", "sys", "rc", "SourceFile", "ssl", "component", "ource", "prot", "req", "feat", "video", "img", "href", "fn", "dist", "back", "rb", "cmp", "source", "storage", "ctx", "path", "spec", "filename", "attr", "stage", "url", "config", "code", "uri", "sit", "file", "impl", "Dest", "upload", "sel", "scene", "sb", "input", "resource", "Source", "fp", "ref", "rl", "string", "obj", "buf", "tmp", "supp"], "dest": ["bin", " destination", "cont", " dst", "class", "orig", "di", "txt", "img", "fn", "dist", "temp", "std", "dc", "test", "lib", "source", "disk", "path", "null", "Dest", "target", "dir", "dat", "home", "obj", "tmp"], "in": ["reader", "bin", "inf", "isin", "login", "f", "data", "doc", "inas", "ins", "pin", "stream", "ex", "In", "is", "win", "r", "din", "val", "IN", "err", "ini", "d", "i", "source", "inc", "t", "n", "pass", "ps", "inn", "io", "as", "up", "file", "a", "input"], "p": ["f", "lp", "tp", "s", "g", "py", "m", "j", "pi", "wp", "pc", "per", "pr", "jp", "b", "part", "op", "l", "bp", "pre", "cop", "e", "r", "parser", "o", "pp", "d", "i", "sp", "t", "h", "v", "ps", "pe", "c", "P", "pm", "np", "pa", "po", "fp", "pd", "cp", "pg", "pb"], "ds": ["data", "dl", "dd", "services", "groups", "ys", "cs", "ls", "ld", "tools", "d", " props", "js", "ded", "xs", "uds", "ps", "ils", "ges", "tests", "pd", "ads", " sd", "df", "lp", "ups", "ins", "bs", "Ds", "os", "sys", "sts", "obs", "rs", "dds", "dm", "nas", "gd", "hs", "points", "ipes", "qs", "DS", "styles", "des", "ss", "ks", "dos", "cons", "ts", "vals", "eps", "els", "icks", "da", "ns", "parts", " ps", "dist", " DS", "posts", "dc", "scripts", "ths", "dates", "vs", "gs", "ays", "dat", "docs", "dt", "s", "sync", "utils", "ans", "di", "words", "models", "lines", "db", "dp", "ants", "amps", "plugins"], "format": ["tag", "data", "f", "layout", "sche", "scale", "name", "version", "at", "ant", "handler", "type", "table", "language", "filter", "letter", "feat", "class", "plugin", "model", "part", "magic", "fn", "parser", "atter", "style", "source", "template", "t", "api", "spec", "struct", "filename", "pattern", "path", "form", "url", "config", "unit", "Format", "file", "function", "act", "prefix", "fd", "frame", "record", "host", "fp", "string", "nat"], "hasPixelData": ["hasPicturedata", "hasPictureSize", "hasByteData", " hasPixeldata", "hasPixeldata", "showsPixelDATA", "hasPixelSize", "hasPixelStyle", "showsByteStyle", " hasPixelSize", "showsBytedata", "hasByteStyle", "showsPixeldata", "showsByteData", "hasPictureData", "hasByteSize", "showsByteDATA", "hasByteDATA", "showsPixelData", "haspixeldata", "hasBytedata", "hasPixelDATA", "haspixelSize", "haspixelData", "showsPixelStyle"], "inflate": ["insflATE", "invenATE", "inflode", "inffated", "inFlated", "InFlace", "Inflace", "invenate", "insflate", "inflated", "inadequating", "inFlace", "insflating", "infolating", "infolATE", "inadequATE", "invenode", "inadequode", "insflode", "inffation", "infloated", "insvenATE", "invenating", "inffate", "inFlate", "inadequate", "inflating", "InFlated", "infolode", "infface", "Inflated", "Inflate", "InFlation", "inflation", "Inflation", "infloace", "insvenating", "insvenode", "infolate", "InFlate", "inflATE", "inflace", "infloate", "insvenate", "infloation", "inFlation"], "pxlen": ["mxlen", "fxdata", "mxpos", "campos", "pclon", "axln", "ppl", "txlen", "fxLen", "pxdata", "pxsize", "pngcount", "xpsize", "pxpos", "txln", "xpcount", "ppLen", "txlin", "mxdata", "camdata", "camln", "mxln", "axlen", "pcln", "pnglength", "pglen", "pxden", "fxden", "txlon", "pgLen", "pxl", "pxlength", "pxlon", "axlon", "pclin", "camlen", "pgden", "pxln", "mxcount", "pngsize", "fxln", "pgl", "mxlength", "mxsize", "axlin", "pclen", "fxl", "pxcount", "fxpos", "pxLen", "fxlen", "xplen", "pnglen", "ppden", "pxlin", "xplength", "pplen"], "out": ["lock", "point", "error", "session", "state", "outs", "gen", "dump", "sys", "log", "copy", "page", "cache", "user", "again", "output", "conn", "line", "work", "query", "err", "OUT", "list", "lib", "cli", "step", "parent", "v", "store", "server", "group", "post", "io", "up", "co", "inter", "pad", "re", "Out", "obj"]}}
{"id1": "17580775", "id2": "23246123", "code1": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "code2": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "label": 1, "substitutes": {"runInternal": ["doSync", "runExternal", "processInternal", "processImpl", " runImpl", " runSync", "runImpl", "doInternal", " runExternal", "processSync", "runSync", "doImpl", "doExternal", "processExternal"], "connection": ["statement", "current", "version", "machine", "channel", "container", "creator", "operation", "wrapper", "section", "service", "source", "default", "c", "function", "message", "resource", "directory", "option", "volume", "socket", "error", "session", "handler", "log", "position", "lc", "description", "cache", "inner", "entity", "engine", "client", "connected", "port", "builder", "environment", "character", "context", "document", "Connection", "communication", "use", "reader", "loc", "database", "remote", "command", "expression", "component", "collection", "image", "connect", "config", "relation", "con", "location", "graph", "body", "layer", "application", "timeout", "event", "translation", "password", "proxy", "condition", "entry", "request", "driver", "object", "ion", "server", "index"], "visited": ["Vised", "viewITED", "viewited", "Visitted", "Visalled", "viewed", "viewitted", "VISITED", "invitted", "VISalled", "VisITED", "visalled", "VISitted", "invalled", "invited", "invITED", "VISed", "vised", "Visited", "visITED", "visitted", "VISited"], "startTimeStamp": ["startLineEstng", "startLineEstamps", "startTimeStamped", "startLineStamp", "startTimeestamp", "startTimeStng", "startLineStamps", "startTimestng", "startTimeestng", "startLineStamped", "startTimeestamped", "startTimeEstamp", "startTimeEstamps", "startLineEstamp", "startLineEstamped", "startLineStng", "startTimestamped", "startTimeEstamped", "startTimestamp", "startTimeEstng", "startTimeStamps", "startTimeestamps", "startTimestamps"], "delayedProgress": ["elayedContent", "eladedStatus", "delivedProgress", "elayedProgress", "delivedStatus", "delayedContent", "eladedContent", "deladedComplete", "elayedStatus", "elayedComplete", "delayedStatus", "deladedContent", "deladedProgress", "delayedComplete", "deladedStatus", "deliverStatus", "deliverContent", "delivedComplete", "deliverComplete", "deliverProgress", "eladedComplete", "eladedProgress", "delivedContent"], "conn": ["nt", "open", "cb", "loc", "cn", " con", "channel", "nc", "ct", "sync", "enc", "ann", "rc", "ssl", "lc", "ls", "l", "att", "client", "comm", "dc", "connected", "cli", "ci", "cc", "db", "connect", "ch", "cf", "ctx", "h", "exec", "uc", "config", "conv", "n", "io", "Conn", "c", "http", "cmp", "co", "con", "mc", "cp", "Connection", "ad", "obj", "act"], "fileName": ["urlArea", "FilePath", "imageName", " fileSpace", "imagename", "fileSpace", "imagePath", "contentSpace", "urlName", "fileKey", " fileKey", "contentName", " filePath", "imageSpace", "FileKey", "FileArea", "filePath", "filename", "urlKey", "FileName", "urlPath", "fileArea", "contentPath", " fileArea", " filename", "contentname"], "disp": ["prop", "Dispend", "disap", "dispp", "defpend", "propr", "Dispose", "dispart", "interpp", "schepatch", " dispr", "detP", "Dispatch", "prope", "Dispr", "disps", "dispr", "dispe", "dispatch", "detp", "broadps", "disP", "broadpend", "scheap", "detpp", "schepe", "Disp", "dispose", "Disps", " dispe", "defp", "interpatch", "Dispe", "Dispp", "Disap", "interp", "schep", "interP", "Dispart", " dispose", "defps", "broadp", "dispend", "defpart", "interap", "interpe", "detpatch", "DisP", "propose", "broadpart"], "p": ["f", "loc", "y", "pat", "point", "lp", "at", "tp", "q", "vp", "g", "m", "after", "j", "pi", "pl", "pr", "part", "b", "jp", "op", "r", "l", "pre", "bp", "e", "patch", "o", "pp", "d", "i", "sp", "t", "api", "ap", "h", "v", "n", "ping", "pe", "c", "P", "rep", "index", "pa", "np", "pos", "po", "col", "ip", "end"], "response": ["data", "version", "ception", "radius", "error", "complete", "respond", "body", "timeout", "en", "received", "Response", "status", "prot", "model", "description", "page", "successful", "output", "success", "collection", "reply", "respons", "reset", "pointer", "found", "image", "value", "api", "feed", "request", "path", "next", "code", "uri", "server", "http", "function", "id", "index", "message", "result", "resource", "json", "resp", "site"], "contentType": ["ContentLength", " contentTyp", " contentName", "documentType", "contentName", " contentLength", "messageInfo", "documentName", "messageLen", "ContentLen", "contentLength", "ContentInfo", "ContentType", "ContentTyp", "messageType", "messageLength", "ContentName", "documentTyp", "contentInfo", " contentInfo", "documentLength", "contentTyp"], "contentEncoding": ["loadEncasing", "contentEnasing", "contentencoding", "contentLocoding", "contentDecoder", "loadEncryption", "contentEncoder", "contentEReading", "ContentDecoder", "contentDecoding", "contentCasing", "ContentEncocol", "ContentEncReading", "loadEnaring", "contentDecocol", "contentEncaring", "contentencReading", "loadEnasing", "contentEnryption", "contentDecReading", "contentEoder", "contentLocryption", "contentencocol", "ContentDecoding", "contentCaring", "contentEncryption", "contentCryption", "contentEoding", "contentEncocol", "contentencoder", "ContentEncoder", "ContentDecocol", "contentEncReading", "loadEncaring", "contentCoding", "ContentEncoding", "ContentDecReading", "loadEncoding", "loadEnryption", "contentEocol", "contentEnaring", "contentLocasing", "loadEnoding", "contentLocaring", "contentEncasing", "contentEnoding"], "contentLen": ["ContentLength", "ContentSl", "activityLength", "contentSl", "ContentSize", "activityLen", "Contentlen", "resourceLength", " contentLength", "activitySl", "contentSize", "resourceSize", "activitySize", "ContentLen", "contentLength", " contentlen", "resourceLen", " contentSize", "contentlen", "resourcelen", " contentSl"], "is": ["iss", "isl", "ub", "it", "version", "un", "ot", "isp", "not", "os", "im", "IS", "ys", "isc", "can", "igh", "ig", "mis", "ion", "ync", "net", "are", "ss", "out", "us", "ios", "ip"], "url": ["sl", "org", "channel", "socket", "email", "string", "layer", "download", "str", "status", "ssl", "log", "page", "user", "text", "client", "address", "Url", "service", "URL", "source", "image", "buffer", "feed", "path", "context", "config", "document", "server", "uri", "http", "file", "resource", "host", "link", "location", "json", "html", "username"], "loadNext": ["loadsLast", "checkPrevious", "loadingLast", "loadLast", "checkLast", "loadPrevious", "loadingNext", "checkNext", "loadsPrevious", "loadFirst", "loadsFirst", "loadingFirst", "loadingPrevious", "loadsNext", "checkFirst"], "itemsLoadedPartially": ["itemsLoadippedpartials", "itemsLoadedPartally", "itemsLoadippedpartial", "itemsLoadedPARTally", "itemsLoadedPARTials", "itemsLoadippedPartials", "itemsLoadedCopial", "itemsLoadedpartials", "itemsLoadedpartial", "itemsLoadedCopials", "itemsLoadedpartially", "itemsLoadedCopially", "itemsLoadedpartally", "itemsLoadippedPartally", "itemsLoadippedPartial", "itemsLoadedPARTial", "itemsLoadippedpartally", "itemsLoadippedpartially", "itemsLoadippedPartially", "itemsLoadedCopally", "itemsLoadedPartial", "itemsLoadedPartials", "itemsLoadedPARTially"]}}
{"id1": "14567939", "id2": "3945236", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"baseHash": ["basehash", " generateHash", " chainSecret", "BaseFile", "BaseSecret", " generateSecret", " generateFile", "Basehash", " chainhash", " chainFile", "baseFile", "baseSecret", " generatehash", " chainHash", "BaseHash"], "name": ["ame", "data", "type", "create", "definition", "base", "class", "part", "user", "alias", "account", "key", "member", "normal", "address", "secret", "style", "image", "path", "parent", "hash", "object", "names", "Name", "n", "hello", "file", "id", "word", "prefix", "resource", "host", "named", "string", "NAME"], "password": ["wallet", "profile", "data", "wd", "seed", "words", "text", "Password", "account", "key", "paste", "secret", "crypt", "padding", "source", "sword", "value", "path", "PASS", "hash", "pattern", "phrase", "attribute", "code", "pass", "priv", "word", "prefix", "token", "input", "diff", "security", "auth", "stroke", "string", "device", "username"], "digest": ["mdest", "moder", "modested", "signusher", "decEST", " diger", "DigEST", "Digester", "Digusher", "modester", "digested", "mdr", " digusher", "digester", "digEST", "mdEST", "mdester", " digger", "digger", "decest", "signester", "digr", "Digested", "Digger", "diger", "digusher", "signer", "Diger", "modest", "signest", "signger", "Digr", "decr", " digested", "decester", " digester", "Digest"]}}
{"id1": "9261777", "id2": "8625346", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"source": ["missing", "sl", "sin", "data", "start", "name", "force", "session", "slice", "options", "seed", "secure", "se", "info", "shared", "sort", "base", "rule", "ource", "copy", "sample", "text", "size", "inner", "zip", "query", "single", "SOURCE", "address", "dest", "service", "style", "parse", "image", "proxy", "comment", "template", "request", "spec", "project", "path", "parent", "url", "config", "view", "uri", "unit", "null", "empty", "flat", "original", "in", "scope", "file", "id", "index", "prefix", "src", "resource", "target", "result", "Source", "input", "token", "string", "use", "element", "strip", "site"], "destination": ["coordinator", "databaseinations", "Destignment", "databaseinated", "homeinator", "dominations", "dominated", "Desturation", "destension", " destension", "destinating", "destinated", "coordination", "domuration", " destinating", "distinated", " destinate", " destinated", "coordinating", "Destinations", "databaseuration", "distination", "dependinated", "Destination", " destipping", "destinations", "Destinator", "Destinate", "desturation", "domination", "dependension", "destipping", "dependipping", "coordinate", "databaseination", "dependination", "Destinated", "Destinating", "destinator", "homeinated", "homeignment", "destinate", "distension", " destignment", "homeination", " destinator", "distipping", "destignment"], "is": ["ens", "ais", "Is", "iss", "isl", "get", "sin", "cos", "ri", "s", "oss", "ins", "bs", "ori", "info", "se", "ics", "ie", "isa", "IS", "isc", "abs", "obs", "was", "ops", "zip", "ar", "i", "ci", "mis", "init", "api", "or", "nis", "ois", "bis", "ui", "close", "ir", "osi", "io", "ris", "in", "as", "iso", "id", "act", "iris", "src", "ic", "are", "eni", "es", "ai", "out", "us", "ios", "lis", "sis", "ii", "esi", "serv", "ip", "fs", "ib", "ob", "isi"], "os": ["oS", "ens", "ais", "oa", "cos", "socket", "ot", "oss", "s", "bs", "ds", "boot", "bos", "ori", "ol", "sys", "ow", "ls", "oise", "ies", "obs", "op", "ops", "oses", "ends", "o", "i", "OS", "or", "js", "mos", "Os", "oes", "vs", "ose", "io", "osi", "as", "pos", "aos", "acs", "ros", "ss", "out", "us", "ios", "los", "ou", "es", "so", "nos", "fs", "ks", "ob", "dos"], "buffer": ["reader", "border", "uffer", "iter", "sequence", "data", "channel", "batch", "slice", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "position", "copy", "bb", "page", "b", "size", "bytes", "writer", "address", "flush", "padding", "image", "limit", "value", "feed", "url", "transfer", "number", "server", "read", "null", "wave", "header", "queue", "result", "pad", "string", "buf"], "length": ["full", "reader", "offset", "lock", "volume", "ob", "sequence", "division", "get", "data", "point", "depth", "slice", "type", "range", "Length", "partial", "load", "power", "match", "position", "part", "size", "weight", "section", "lower", "l", "left", "distance", "line", "shape", "key", "address", "row", "count", "style", "block", "limit", "value", "feed", "quote", "object", "of", "character", "age", "url", "width", "number", "code", "level", "duration", "split", "ring", "id", "index", "len", "last", "total", "string", "start", "end", "strip"]}}
{"id1": "2396191", "id2": "20851065", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksfromURLSafe", "getLinksFromUrlfast", "getLinksFromSSLSafe", "getLinksFromURLSafe", "getLinksFromURLSlow", "getLinksfromURLFast", "getLinksFromUrlFast", "getLinksFromSSLfast", "getLinksFromSSLSlow", "getLinksFromStringfast", "getLinksfromURLSlow", "getLinksfromUrlSafe", "getLinksFromStringSafe", "getLinksFromUrlSafe", "getLinksFromStringSlow", "getLinksfromUrlSlow", "getLinksFromUrlSlow", "getLinksFromStringFast", "getLinksfromUrlFast", "getLinksFromURLfast", "getLinksfromURLfast", "getLinksFromSSLFast", "getLinksfromUrlfast"], "p_url": ["p_link", "p__name", "tp_root", "p__resource", "p25layer", "pklink", "pe_config", "pipfile", "x_domain", "x_resource", "ekurl", "p64page", "p_html", "x_service", "e_link", "pfpath", "tp24root", "p64path", " p_resource", "pfroot", "pamhtml", "p6config", "p9resource", "p64line", " p_line", "pipurl", "p_file", "e_layer", " p_name", "p9url", "p_path", "p6root", "p24file", "pxurl", "pklayer", "p_name", "p_resource", "p25url", "p24link", "pkhtml", "pfurl", "p24root", "pffile", "p_service", "p_line", "p25html", "pe_root", "p_layer", "pe_url", "pamlink", "pamlayer", "e_url", "pamurl", "pxline", "p__url", "p25link", "p64url", "tp_url", "p_config", "e_html", "tp24link", "p_root", "pfline", "p24url", "p6line", "p9service", "tp_file", "p9domain", "tp24url", "pkurl", "pxconfig", "p_domain", "pxroot", " p_page", "pflink", "tp_link", "ekhtml", "piplink", " p_path", "pe_line", "tp24file", "eklayer", "piproot", "p6url", "eklink", "pfpage", "p_page", "p__path"], "x_url": ["x_log", "x_resource", " x_resource", "p_host", "p_conn", " x_ssl", "p_loc", "x_ssl", " x_log", "x_loc", "x_host"], "x_conn": ["x___conn", "x___con", "x___db", "x_conv", "p_client", "p_db", "wx_con", "x_con", "wx_conv", "x_cat", "p_conn", "p_con", "x_client", "wx_cat", "wx_conn", "x_db", "x___client"], "x_is_reader": ["x_ismlmanager", "x_is_pointer", "x_is_manager", "x_is_stream", "x_is_draft", "x_ismlstream", "x_is_resource", "x_ismlreader", "x_is_writer", "x_ismldraft"], "x_reader": ["cross8url", "x_parser", "x67url", "x24reader", "X_stream", "X_result", "x24result", "x67root", "x8reader", "cross_reader", "cross8reader", "x67reader", "x24parser", "cross_root", "x24stream", "cross8parser", "x8parser", "cross8root", "x67parser", "cross_parser", "x_stream", "X_reader", "x8url", "cross_url", "X_parser", "x8root"], "x_line": ["x__link", "p_link", "xingcell", "x24line", "ex_record", "x_record", "xx_line", "x_comment", "x__line", "x24lin", "x24comment", "xx_lin", "xingline", "xingrecord", "xingpage", "ex_line", "x24link", "p_line", "xx_link", "ex_page", "p_page", "x__url", "xx_comment", "x__page", "x_lin", "x_cell", "ex_cell"], "e": ["le", "er", "f", "y", "oe", "eps", "error", "edge", "ze", "eur", "g", "el", "m", "body", "ente", "p", "se", "ge", "ae", "fe", "ec", "eb", "event", "en", "ie", "me", "match", " E", "b", "he", "entity", "je", "r", "line", "l", "engine", "E", "o", "d", "ne", "entry", "t", "driver", "exec", "ev", "v", "ue", "te", "code", "n", "eve", "pe", "c", "eu", "file", "ce", "ele", "es", "ea", "re", "esi", "ace", "ee", "end", "element"], "x_match": ["p_matched", "p__match", "e_matched", "xammatch", "p_match", "xamreplace", "x_tag", "x_pattern", "x___meet", "x__match", "ax5case", "e___matched", "xamslice", "e___meet", "xjmatch", "e_match", "e_check", "x5info", "xJmember", "ext_search", " x__replace", "x___matched", "x___check", "x5match", "x_member", "ext_match", "ax_info", "x__replace", " x__slice", "x_check", "xlpattern", "ax_link", "x___match", " x_slice", "xlgroup", "ax5link", "xltag", "xJmatch", "ax5match", "x_replace", "extJsearch", "ext_member", "x__url", "x_info", "xjurl", "xjpattern", "xamcase", "x__matched", "xjmatched", "extJmember", "xJsearch", "xlmatch", "xlsearch", "x_matched", "x5case", "extJmatch", "ax_match", " x_date", "extJpattern", "p__url", "x_case", "xJpattern", "xldate", "x_date", "ax_case", "xlmember", " x_tag", " x_group", "e___match", " x_case", "p_pattern", " x_replace", "x_group", " x__match", "p__matched", "x__pattern", "x_search", "x_meet", "x__slice", "ax5info", "p__pattern", "x5link", "e___check", "x_slice", "e_meet", "x__case", " x__case", "ext_pattern"], "x_dir": [" x_file", "x6dir", "x_group", "xneturl", "xnetfile", "xnetdir", "x6group", "x_file", "x6file", " x_group", "x6url", "xnetgroup"], "x_root": ["x7directory", "x7root", "x7alias", "x_directory", "xml_root", "xml_path", "xml_directory", "xml_alias", "x_path", "x7path", "x_alias"], "x_links": [" x_points", "x_lines", " x_lines", "x_ids", "x67links", "x_points", " x_ids", "x67lines", "x67ids", "x67points"], "x_texts": ["x_pathes", "x_textches", "x_pathches", "x_logls", "x_textes", "x_urls", "x_loges", "x_urlls", "x_urles", "x_textls", "x_logches", "x_logs", "x_urlches", "x_paths", "x_pathls"], "x_buf": ["x1buff", "y__buf", "x_wb", "X_buff", "ex_tmp", "x__tmp", "x64buf", "x64bag", "x_cb", "x___uf", "x_buff", "X_buffer", "y__bag", "x1tmp", "ex_buff", "ex__tmp", "x__cb", "ex_cb", "x64uf", "ex__buf", "y_uf", "x___buf", "x_tmp", "ex__buff", "x_buffer", "x_bag", "ex_buf", "x64rc", "x__bag", "y__uf", "y_rc", "x__wb", "y_buf", "X_buf", "x__buf", "ex__cb", "y__rc", "x_rc", "y_bag", "x_uf", "x__buffer", "x___rc", "x1cb", "X_wb", "x1buf", "x__uf", "x__rc", "x___bag", "x__buff"], "x_matches": ["x_morting", "x_Matches", "x_matchcks", "x_matchchers", "x_matchting", "x_batures", "xKmatoms", "x_attched", "x_matchers", "xKtextoms", "x_calhes", "x_patched", "x_batches", "x_patchers", "x_attches", "x_morhes", "x_matoms", "xKtexthes", "x_pathes", "x_matures", "x__mathes", "x_calings", "xKtextings", "x_matting", "x__matures", "x_matchings", "x_locches", "x_locting", "x_patcher", "x_matings", "x_Mathes", "x_matchches", "xKtextches", "x_Matcher", "x_matchhes", "x_matcks", "x_morched", "x_Matures", "xKmatings", "x_Matchers", "x_patcks", "x_textings", "x__matchers", "x_calches", "x_matched", "x_attcks", "x_atthes", "xKmathes", "xKmatches", "x_mathes", "x_caloms", "x_batchers", "x_loches", "x_matchched", "x_texthes", "x_textches", "x_morches", "x_patches", "x_matchoms", "x__matches", "x_locched", "x_bathes", "x_textoms", "x_matchcher", "x_matcher"], "x_page": ["X_line", "xerfeed", "x67loc", "xerlink", "xerpage", "xerline", "ex_loc", "tx_page", "x_feed", "X_page", "tx_link", "x67link", "ex_link", "tx_feed", "x_path", "tx_line", "X_path", "x_file", "x_loc", "ex_file", "ex_page", "X_url", "x67page", "x67file"], "x_link": ["xpubloc", " x_target", "xpubline", "x_target", "xpublink", "ex_link", "xpubtarget", " x_loc", "x_loc", "ex_url", "ex_line", "ex_page"], "i": ["x", "ji", "f", "y", "si", "it", "ti", "ri", "iv", "p", "j", "info", "pi", "k", "ori", "ie", "ix", "hi", "I", "di", "u", "b", "multi", "bi", "qi", "r", "o", "key", "ini", "count", "ci", "z", "xi", "v", "oi", "ui", "n", "li", "uri", "zi", "ii", "io", "c", "in", "id", "index", "a", "chi", "iu", "eni", "ai", "gi", "phi"]}}
{"id1": "19810820", "id2": "4852691", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"copyFileChannel": ["transferFileChan", "transferfileChannel", "transferFileChannel", "copyDirectoryChannel", "copyStreamChannel", "copyDirectoryStream", "transferFileStream", "copyFileChan", "copyStreamStream", "copyStreamchannel", "copyFilechannel", "transferfileStream", "transferFilechannel", "copyDirectorychannel", "copyFileStream", "transferfileChan", "copyfileStream", "copyfilechannel", "copyStreamChan", "transferfilechannel", "copyDirectoryChan", "copyfileChannel", "copyfileChan"], "src": ["cur", "sl", "sin", "loc", "sup", "RC", "s", "sc", "slice", "stream", "sync", "st", "inst", "download", "sth", "sys", "rc", "ssl", "ls", "conn", "b", "img", "lower", "rs", "dist", "ruby", "SOURCE", "client", "dest", "rb", "sq", "sub", "source", "ctx", "path", "filename", "url", "config", "server", "tmp", "sit", "func", "scene", "upload", "sel", "sb", "input", "Source", "start", "ses", "rest"], "dst": ["fdst", "dost", "Dost", "tst", " dost", "adst", "adST", " ddest", "tart", "tlt", "dST", "fdput", "fdST", "lddest", "ddest", "drc", "stST", "ldst", "DST", "brc", "bST", "dlt", "bput", "bart", "dput", "adput", "Dst", " dST", "Ddest", "stlt", "adrc", "bst", "stst", "tST", "dart", "fdrc", "ldST", "ldost", "start", "blt"], "preserveModificationTime": ["preserveModifyingFile", "preserveModifyingtime", "preserveModifiedtime", "preserveModifiedTime", "preserveModifytime", "preserveModifiedFile", "preserveModificationtime", "preserveModationtime", "preserveMinifiedTime", "preserveMinifiedtime", "preserveModationFile", "preserveMinifiedFile", "preserveMinificationtime", "preserveModifyingTime", "preserveMinificationTime", "preserveModifyTime", "preserveModificationFile", "preserveMinificationFile", "preserveModationTime"], "inputChannel": [" inputSocket", "outputCode", "outputConnection", "imageChan", "binaryChannel", " inputStream", "fileConnection", "outputStream", "outputConsole", "Inputchannel", "outputChan", "errorStream", "requestCode", "inputCode", " inputCode", " inputchannel", "requestChannel", " inputChan", "InputChannel", " inputQueue", "inputSocket", "fileChannel", "errorChannel", "errorChan", "binarychannel", " inputConsole", "errorCache", "requestStream", "InputBuffer", "imageGate", "inputGate", "inputConnection", "fileChan", "imagechannel", " inputCache", "outputBuffer", "outputSocket", "inputChan", "InputSocket", "outputchannel", "outputGate", "outputQueue", "requestChan", "inputBuffer", " inputConnection", "inputStream", "inputCache", "binaryGate", "imageChannel", "InputChan", "fileConsole", "inputchannel", "inputQueue", "outputCache", " inputBuffer", "binaryChan", "InputQueue", "inputConsole"], "outputChannel": ["inputButton", "outputStream", "outputButton", "outStream", "outputChan", "OutputChannel", " outputStream", "OutputQueue", "OutputStream", "outchannel", "writeStream", " outputchannel", " outputButton", " outputChan", "writeQueue", "OutputChan", "outChan", "writeChan", "inputManager", "writeManager", "inputChan", "outputchannel", " outputQueue", "outputQueue", "Outputchannel", "outputManager", "inputStream", "outButton", " outputManager", "writeChannel", "outChannel"], "length": ["full", "lock", "offset", "volume", "sequence", "current", "session", "complete", "type", "head", "Length", "partial", "load", "base", "position", "with", "part", "text", "size", "section", "l", "max", "pull", "buffer", "count", "style", "build", "block", "limit", "child", "value", "form", "next", "sum", "width", "number", "duration", "delay", "id", "php", "len", "last", "result", "join", "available", "slave", "start", "end"], "total": ["full", "offset", "cur", "current", "scale", "error", "complete", "toc", "type", "partial", "info", "used", "set", "base", "part", "all", "otal", "size", "multi", "less", "done", "max", "translation", "key", "found", "count", "i", "limit", "no", "sum", "duration", "id", "Total", "len", "last", "valid", "result", "available", "failed", "always", "start"]}}
{"id1": "14758866", "id2": "20920051", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getResourceAsStream": ["getResourcesasFile", "getResourceASStream", "getResourceasFile", "getResourceToString", "getResourceasStream", "getResourcesasSteam", "getResourcesAsFile", "getResourcesasString", "getResourceToSteam", "getResourceAsString", "getResourcesAsStream", "getResourcesAsSteam", "getResourcesasStream", "getResourceASString", "getResourceASSteam", "getResourceToFile", "getResourceASFile", "getResourceToStream", "getResourceAsSteam", "getResourceasSteam", "getResourceAsFile", "getResourcesAsString", "getResourceasString"], "name": ["full", "connection", "ame", "data", "version", "type", "remote", "info", "ip", "str", "base", "part", "cache", "time", "size", "domain", "alias", "key", "address", "source", "path", "parent", "filename", "object", "hash", "Name", "config", "uri", "names", "memory", "file", "id", "prefix", "word", "resource", "named", "location", "string", "NAME", "username"], "inputStream": [" inputstream", "inputSteam", "cachestream", "currentBody", "InputConnection", " inputBody", "currentstream", "InputChannel", "InputStream", "currentStream", " inputChannel", "cacheSteam", "pullChannel", "inputBody", "pullConnection", "inputConnection", "cacheStream", "pullStream", "pullSteam", "inputFeed", "InputFeed", " inputConnection", "Inputstream", "inputChannel", "currentSteam", "InputBody", "cacheFeed", "InputSteam", "inputstream", " inputSteam", " inputFeed"], "in": ["reader", "bin", "data", "socket", "ins", "m", "In", "rec", "log", "inner", "din", "r", "IN", "err", "buffer", "source", "image", "path", "exec", "read", "c", "src", "input", "re", "Out"], "out": ["lock", "bin", "msg", "data", "point", "error", "pool", "state", "outs", "ex", "gen", "proc", "dump", "ger", "sys", "log", "copy", "page", "part", "conn", "user", "output", "cache", "cmd", "r", "line", "writer", "pre", "err", "query", "key", "client", "flush", "OUT", "temp", "list", "buffer", "cli", "bar", "outer", "object", "group", "server", "raw", "io", "up", "file", "params", "println", "inter", "window", "debug", "ref", "Out", "obj"], "url": ["full", "connection", "https", "open", "sl", "f", "data", "loc", "org", "socket", "ur", "gl", "remote", "stream", "web", "download", "event", "base", "log", "ssl", "page", "cache", "b", "user", "l", "r", "left", "client", "address", "pull", "Url", "service", "URL", "source", "image", "feed", "api", "path", "object", "update", "config", "li", "server", "uri", "route", "browser", "http", "file", "resource", "result", "coll", "bel", "location", "rel", "string", "ob"], "remoteName": ["fullPath", "localPath", "Remotename", "remoteUrl", "fullname", "fullKey", "remotename", "RemoteUrl", "RemotePath", "localUrl", " remotePath", "RemoteKey", "remotePath", " remoteUrl", "localKey", "remoteKey", "fullName", "RemoteName", " remoteKey", " remotename"], "localName": ["remoteFile", "locString", "locName", "globalString", "locname", "localPath", "LocalKey", " localname", "localFile", "LocalPath", "locUrl", "LocalName", "remoteUrl", " localKey", "locPath", "localString", " localString", "remotename", "localUrl", "globalFile", "remotePath", " localUrl", " localFile", "localKey", "remoteKey", "globalname", "globalName", "globalKey", "globalPath", "localname", "remoteString", " localPath", "Localname"], "host": ["localhost", "loc", "hard", "database", "head", "type", "remote", "format", "conn", "domain", "address", "proxy", "hop", "service", "driver", "path", "h", "config", "arch", "server", "uri", "http", "Host", "prefix", "src", "header", "target", "dir", "home", "addr", "string", "ip", "username"], "prot": ["prop", "family", "channel", "addr", "pt", "lat", "proc", " plat", "ssl", "ht", "conn", "part", " proto", "Prot", "txt", "att", "password", "client", " protocol", "cli", "api", "col", "pattern", "config", "conv", "platform", "pass", "afi", "cert", "pos", "prefix", "ocol", "stat", "ios", "pro", "ref", "def", "rel", "serv", " protocols", "rot", "nat"], "port": ["f", "version", "point", "phone", "PORT", "type", "slice", "allow", "p", "pi", "timeout", "position", "direction", "future", "pr", "time", "size", "Port", "patch", "password", "address", "service", "hop", "proxy", "ort", "select", "value", "limit", "project", "path", "pid", "width", "number", "server", "uri", "pass", "file", "ports", "index", "priority", "target", "length", "string", "ip", "rest"], "cacheFile": ["remoteFile", "CacheDirectory", "basefile", "outputConnection", "localfile", " cacheLine", " cachefile", "cacheConnection", "proxyHandle", "localFile", "outputFile", "baseFile", "CacheDir", "achePlace", "cacheMessage", "storageFile", "cacheDirectory", " cacheDir", "cacheLine", "remoteUrl", "fakeFile", "sessionDir", " cacheFiles", "localDir", "tempDir", "acheFiles", "sessionFiles", "cacheUrl", "tempfile", "fakeUrl", "storageFiles", "localFiles", "cacheHandle", "Cachefile", "cachePlace", "storagePlace", "proxyfile", "cacheFiles", " cacheHandle", "CacheUrl", "cachefile", "proxyDir", "fakeLine", "tempHandle", "remoteLine", "outputMessage", " cachePlace", "baseMessage", "CacheFile", " cacheConnection", "remotefile", "outputfile", "acheFile", "fakefile", " cacheMessage", "sessionUrl", "cacheDir", " cacheDirectory", " cacheUrl", "CacheFiles", "proxyFile", "localDirectory", "baseConnection", "tempFile", "sessionFile"], "urlConnection": ["URLconnection", "sslFile", "URLConnection", "slCode", "urlconnection", "slChannel", "httpCode", " urlFile", "cacheConnection", "cachePool", "cacheConn", "downloadEntry", "downloadConnection", " urlconnection", "webConnect", "fileConnection", "URLResponse", " urlChannel", " urlConnect", "urlPool", "slConnection", "cacheConnect", "fileConn", "urlEntry", "sslConnection", "urlPart", "filePart", "fileConnect", "downloadconnection", "slCommand", "sslResponse", "httpChannel", " urlCommand", "httpPool", "httpCon", "urlCon", "urlResponse", "urlConnect", "sslConn", "httpConnect", "downloadFile", " urlCode", "URLConn", "sslConnect", "urlCommand", " urlPool", "urlChannel", "httpconnection", "URLCon", "sslEntry", "urlCode", "sslconnection", "urlConn", " urlConn", "URLConnect", "httpResponse", " urlPart", "webconnection", " urlEntry", "URLPart", "webConnection", "httpCommand", "httpConn", "webCon", "urlFile", "httpConnection"], "httpURLConnection": ["httpCLConnector", "httpCLConnection", "httpREConnection", "httpSLCode", "upperRTransaction", "httpURLCode", "httpRNode", "upperRNode", " httpLLConstruction", "httpSLConnection", "httpRLConnector", "httpHTTPFunction", "httpREStatement", "httpHTTPQuery", "httpURQuery", "httpCLConnect", "httpSLconnection", "httpurlConnection", "httpRLClient", "httpURLConn", "httpMconnection", "upperURLNode", "httpWSNode", "httpLLconnection", "httpURNode", "httpBLQuery", "httpLLConnection", " httpUrlFunction", "httpUrlconnection", "httpDOMconnection", " httpUrlConnection", "httpMLFunction", "cacheURLClient", "httpUrlConnection", " httpHTTPConnection", " httpURLconnection", "httpRLConnection", "urlUrlClient", "httpBLFunction", "httpDateconnection", "httpURFunction", " httpLLConn", "cacheURLConnection", "httpBLOperation", "upperURLConnection", "httpREConstruction", "httpurlconnection", "httpurlStatement", "urlUrlStatement", "httpFormConnection", "httpURLFunction", "shortURLConnection", "httpREconnection", "httpMLconnection", "httpREClient", "upperURLconnection", "urlURLconnection", "httpRLConnect", "httpURLOperation", " httpHTTPQuery", "cacheURLConnect", "cacheUrlClient", "httpHTTPOperation", "httpWSTransaction", "httpURLClient", "httpMCode", "currentURLCode", "upperURLTransaction", "httpBLConnection", " httpUrlconnection", "httpUROperation", "shortSLConnection", " httpURLConn", "shortSLconnection", "httpURConnection", "httpURLNode", " httpLLConnection", "shortSLConnect", "httpUrlConnect", "httpFormConnect", "httpDateConstruction", "currentURLConnection", " httpHTTPFunction", "httpCLClient", "httpURLConstruction", " httpLLconnection", "httpURLconnection", "httpFormconnection", "httpURLStatement", "httpUrlFunction", "httpHTTPConnection", "httpSLConnect", " httpURLQuery", "urlUrlconnection", "httpWSconnection", " httpURLConnect", "currentURLconnection", "shortURLConnect", " httpURLOperation", "httpDOMFunction", "httpRConnection", "httpURTransaction", "currentURLConnect", "urlURLStatement", "httpDOMConnect", "httpUrlConnector", "httpMLConnect", "cacheUrlConnector", "httpDOMConnection", "httpUrlStatement", " httpURLFunction", " httpURLConstruction", "urlUrlConnection", "upperRconnection", "httpREConn", "urlURLClient", "httpMLConnection", "httpURconnection", "httpURLQuery", "httpLLConn", "httpURLConnector", " httpUrlConnect", "httpUrlClient", "urlURLConnection", "httpURLTransaction", "cacheURLConnector", "httpRLconnection", "httpurlClient", "httpLLConstruction", "cacheUrlConnect", "shortURLconnection", "httpWSConnection", " httpHTTPOperation", "httpDateConnection", "cacheUrlConnection", "httpRTransaction", "httpRconnection", "httpMConnection", "httpURLConnect", "upperRConnection", "httpDateConn", "httpMConnect"], "responseCode": ["statusStatus", "ResponseMessage", "statusCount", "ResponseCode", "statusType", "ResponseStatus", "replyMessage", "ResponseType", "statusCode", "replyType", "responseStatus", "replyCode", "ResponseCount", " responseMessage", "statusMessage", " responseStatus", "replyCount", "responseCount", "responseType", "responseMessage", " responseType"], "lastModified": ["lastModed", "lastMODIFIED", " lastMODined", "lastMinified", "lastEdIFIED", "New", "nextMODified", " lastModied", "lastEdified", "lastModIFIED", "lastmoded", "nextMODed", "lastMODied", "nextModIFIED", "nextMODied", "nextModied", "lastmodIFIED", " lastModined", " lastMODied", " lastMODIFIED", "lastEded", "lastmodified", "_", "lastMODified", "lastMinIFIED", " lastMODified", "lastmodied", "lastModied", "lastMinied", "this", "lastMODification", "lastmodification", "nextModification", "nextMODIFIED", "lastEdification", "lastMODed", " lastModIFIED", "lastModined", "s", "nextModified", "lastModification", "lastMinined", "lastMODined", "nextMODification", "nextModed"]}}
{"id1": "21491791", "id2": "22536033", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"run": ["job", "app", "create", "worker", "command", "fork", "log", "loop", "all", "work", "spawn", "test", "call", "build", "process", "exec", "code", "unit", "func", "runner", "running", "execute", "invoke", "Run", "start", "apply"], "input": ["active", "connection", "readable", "data", "audio", "worker", "stream", "state", "control", "conn", "user", "loader", "inner", "text", "instance", "work", "flow", "parser", "client", "address", "source", "storage", "image", "entry", "feed", "request", "driver", "form", "context", "config", "iterator", "reading", "raw", "read", "view", "io", "in", "file", "up", "index", "resource", "out", "initial", "internal", "Input"], "output": ["connection", "office", "job", "data", "later", "put", "operation", "application", "web", "letter", "log", "control", "page", "cache", "writing", "user", "text", "writers", "console", "temp", "source", "image", "response", "path", "filename", "parent", "environment", "object", "exit", "outer", "config", "document", "unit", "file", "index", "generated", "written", "queue", "resource", "out", "target", "network", "Writer", "write", "Output", "end"], "reader": ["er", "manager", "ri", "handler", "book", "worker", "audio", "stream", "rator", "loader", "inner", "wrapper", "r", "rer", "parser", "client", "row", "ner", "oder", "entry", "source", "image", "builder", "driver", "request", "system", "context", "reading", "read", "server", "view", "author", "io", "owner", "in", "resource", "riter", "slave", "Reader", "peer"], "writer": ["connection", "ew", "office", "er", "data", "manager", "wan", "writ", "worker", "creator", "maker", "writing", "inner", "w", "wrapper", "her", "r", "engine", "work", "writers", "ter", "player", "ner", "entry", "ws", "war", "wa", "builder", "driver", "or", "outer", "rw", "request", "author", "wr", "wire", "wb", "nw", "wer", "word", "written", "riter", "out", "Writer", "write", "editor"], "pump": ["Pump", "mumps", "ppumper", "prumper", "prdump", "dmp", "Pprint", "pdump", "Pam", "Pumper", "pamp", "dump", "Pmp", "pmp", "camp", "pumping", "pram", "hump", "ppump", "Pamp", "humps", "ppumps", "mumper", " pdump", " pumping", "cumper", "pprint", "cump", "mprint", " pam", " pumps", "pumps", " pumper", "humper", "Pdump", "Pumps", " pmp", "prump", "pam", "pumper", "hprint", "dumps", " pamp", "mump", "ppumping", "Pumping", "cumping", "dumper"], "counter": ["const", "offset", "ener", "er", "keep", "Counter", "current", "ver", "ception", "sequence", "version", "master", "worker", "seed", "layer", "ger", "zero", "comment", "center", "loop", "page", "keeper", "loader", "instance", "num", "clock", "walker", "inner", "r", "collection", "rew", "ter", "trace", "currency", "row", "pointer", "count", "entry", "ner", "continue", "step", "starter", "race", "cookie", "builder", "outer", "parent", "second", "order", "url", "lr", "enter", "number", "hello", "server", "consumer", "code", "author", "repeat", "index", "timer", "result", "inter", "progress", "processor", "now", "runner", "meter"], "buffer": ["uffer", "iter", "data", "channel", "batch", "reference", "layer", "buff", "Buffer", "binary", "base", "position", "page", "text", "loader", "address", "entry", "source", "limit", "port", "url", "document", "server", "file", "message", "uf", "queue", "header", "resource", "length", "buf"], "off": ["offset", "open", "offs", "oa", "opt", "ff", "down", "head", "low", "auto", "Off", "info", "eno", "OFF", "set", "art", "less", "inner", "left", "own", "flow", "o", "of", "ui", "offer", "ord", "pos", "on", "fail", "out", "Offset", "ref", "unknown", "area", "addr", "start", "end", "now"], "len": ["lock", "bin", "lt", "elt", "loc", "name", "fl", "lim", "el", "body", "layer", "en", "gen", "log", "ll", "lc", "ld", "lan", "all", "size", "lon", "l", "line", "val", "lf", "den", "count", "lib", "limit", "url", "width", "li", "n", "in", "pos", "fd", "lin", "on", "fin", "lit", "Len", "ref", "length", "ln", "ler", "end"], "rd": ["rh", "rn", "RD", "red", "rm", "ds", "dd", "adr", "rod", "ru", "ind", "rc", "ld", "rob", "rf", "cr", "r", "rs", "val", "ra", "raid", "fr", "dr", "rb", "rr", " r", "d", "db", "hr", "rw", "lr", "dra", "ord", "rt", "nr", "rand", " prod", "fd", "rss", "RR", "xd", "nd", "rid", "rl", "ud", "rx"]}}
{"id1": "16079868", "id2": "8588992", "code1": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public ActionForward perform(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String status = null;\n        HttpSession session = request.getSession();\n        ReportingBean reportingBean = null;\n        NewConceptBean conceptBean = null;\n        String conceptName = null;\n        String primitive = null;\n        MessageResources errorMessages = MessageResources.getMessageResources(\"com.apelon.apps.dts.treebrowser.resources.error_messages\");\n        LogonUtilities logonUtilities = new LogonUtilities();\n        if (logonUtilities.checkSession(session, status, reportingBean, errorMessages)) {\n            reportingBean = (ReportingBean) session.getAttribute(\"reportingBean\");\n            if ((reportingBean.getMessageHtml().indexOf(\"Classify\")) == -1) {\n                reportingBean.setReportingHtml(\"\");\n            }\n            conceptBean = (NewConceptBean) session.getAttribute(\"newConceptEntity\");\n            conceptName = request.getParameter(\"conceptName\");\n            primitive = request.getParameter(\"primitive\");\n            if (primitive == null) {\n                primitive = \"false\";\n            }\n            conceptBean.setConceptName(conceptName);\n            conceptBean.setPrimitive(primitive);\n            String namespace = conceptBean.getConceptNamespace();\n            if (namespace == null) {\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_3\"));\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n                return (mapping.findForward(status));\n            }\n            String[] roleMods = request.getParameterValues(\"some_or_all\");\n            String[] roleGrps = request.getParameterValues(\"role_group\");\n            Vector roles = conceptBean.getRoles();\n            RoleBean[] roleCons = new RoleBean[roles.size()];\n            roles.copyInto(roleCons);\n            if (roleMods != null && roleGrps != null && roleCons != null) {\n                if (roleCons.length == roleMods.length && roleCons.length == roleGrps.length) {\n                    for (int i = 0; i < roleCons.length; i++) {\n                        roleCons[i].setSomeOrAll(roleMods[i]);\n                        roleCons[i].setRoleGroup(roleGrps[i]);\n                    }\n                }\n            }\n            session.setAttribute(\"newConceptEntity\", conceptBean);\n            NewConceptXMLDisplayBean xmlBean = new NewConceptXMLDisplayBean();\n            xmlBean.setNewConceptXml(conceptBean);\n            String data = BrowserUtilities.encodeUrl(\"conceptXml\") + \"=\" + BrowserUtilities.encodeUrl(xmlBean.getNewConceptXml()) + \"&\" + BrowserUtilities.encodeUrl(\"nameSpace\") + \"=\" + BrowserUtilities.encodeUrl(namespace);\n            XMLPropertyHandler configPh = new XMLPropertyHandler(\"dtsbrowserclassify.xml\");\n            Properties configProps = configPh.getProps();\n            String urlString = configProps.getProperty(\"url\");\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuffer buf = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                buf.append(line);\n            }\n            String resultXml = buf.toString();\n            wr.close();\n            rd.close();\n            ClassifiedConceptBean ccBean = new ClassifiedConceptBean();\n            ClassifyResultParser parser = new ClassifyResultParser(resultXml);\n            ResultBuilder rbuilder = new ResultBuilder();\n            rbuilder.setConceptBean(ccBean);\n            rbuilder.setParser(parser);\n            rbuilder.setNamespace(namespace);\n            try {\n                rbuilder.buildResult();\n                ccBean = rbuilder.getConceptBean();\n                ClassifiedConceptDisplayBean displayBean = new ClassifiedConceptDisplayBean();\n                displayBean.setNewConceptHtml(ccBean);\n                session.setAttribute(\"classifyResult\", ccBean);\n                session.setAttribute(\"classifyDisplayResult\", displayBean);\n                status = \"success\";\n            } catch (Exception e) {\n                Categories.dataServer().error(StackTracePrinter.getStackTrace(e));\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_1\") + e.getMessage());\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n            }\n        }\n        return (mapping.findForward(status));\n    }\n", "label": 0, "substitutes": {"readIntoList": ["readIntonLog", "readIntoMap", "readInttoMap", "readInttoList", "readIntoLog", "readInttoLog", "readTextoLog", "readTextoList", "readIntonList", "readTextoMap", "readIntonMap"], "url": ["connection", "job", "sl", "data", "name", "org", "channel", "email", "remote", "gl", "stream", "base", "ssl", "rule", "user", "l", "address", "Url", "buffer", "URL", "source", "image", "service", "feed", "path", "object", "config", "server", "uri", "date", "io", "http", "file", "resource", "input", "host", "link", "location", "rl", "string"], "list": ["data", "tree", "get", "name", "self", "pool", "batch", "table", "array", "info", "load", "detail", "status", "nav", "cache", "all", "part", "user", "l", "member", "see", "client", "temp", "this", "test", "show", "map", "listed", "we", "parent", "object", "li", "view", "group", "lists", "server", "code", "menu", "index", "LIST", "queue", "coll", "out", "join", "record", "result", "json", "obj", "dict"], "in": ["reader", "bin", "iter", "er", "f", "data", "login", "ins", "m", "stream", "min", "In", "rec", "ssl", "is", "b", "inner", "again", "loader", "r", "l", "din", "IN", "err", "fr", "client", "ini", "buffer", "i", "source", "image", "inc", "nin", "h", "read", "raw", "io", "inn", "c", "file", "as", "a", "lin", "token", "input", "out", "con", "re", "gin"], "inputLine": ["outputLine", "inputFile", "issueline", "ifName", " inputBlock", " inputStream", "InputName", "argumentL", "InputItem", "commandFile", "outputFile", "outputL", "outputline", "ifline", " inputText", "inputLin", "inputL", "inputName", "InputStream", "inputBlock", "commandName", "commandBlock", " inputline", "requestL", "ifLin", "argumentBlock", "InputString", "inputItem", "ifLine", "issueName", "outputString", " inputName", "InputLine", "outputText", " inputItem", "InputBlock", "InputL", " inputFile", "issueLin", " inputL", "commandText", "Inputline", " inputString", "requestline", "InputText", "commandline", "argumentStream", "inputStream", "requestText", "InputFile", "argumentLine", "inputText", "issueLine", "inputline", "requestLine", "inputString", " inputLin", "commandItem", "commandLine"], "commandNameBegin": ["commandPathBeginning", "commandStringBegin", " commandNameCreate", " commandTimeBegin", "commandParambegin", " commandLineBeginning", "CommandLineEnd", "commandPathBegin", "commandTimeBegin", "commandTimebegin", "commandLineBeginning", "commandLengthBeginning", " commandStringBeginning", " commandTimeBeginning", " commandLineEnd", "commandTimeCreate", " commandTimeEnd", "commandParamEnd", "CommandNamebegin", "commandStringBeginning", " commandTimeCreate", " commandStringBegin", "commandLineBegin", "commandNameBeginning", "commandLineCreate", " commandNameBeginning", " commandStringbegin", " commandStringEnd", "commandParamBegin", "CommandLineBeginning", "CommandNameBegin", "commandTimeBeginning", "commandPathEnd", "commandLengthBegin", "commandLinebegin", "commandStringEnd", " commandLineBegin", "commandNameCreate", "commandParamBeginning", " commandLinebegin", " commandNamebegin", "commandLengthCreate", "commandTimeEnd", "commandPathbegin", "commandLineEnd", "CommandNameEnd", "commandStringbegin", "commandLengthEnd", "CommandLinebegin", "commandNamebegin", "CommandNameBeginning", "CommandLineBegin"], "commandNameEnd": [" commandNameend", " commandNameEND", "commandLineEND", "commandPathBegin", "operationNameBegin", "commandTimeBegin", "commandLineStart", " commandLineEnd", " commandLineStart", "commandParamEnd", " commandTimeEnd", "commandPathEND", " commandLineend", " commandTimeend", "operationNameEnd", "commandNameEND", " commandNameStart", "commandnameEnd", "commandParamend", "commandTimeend", "commandLineBegin", "commandPathStart", "commandTimeEND", "commandLineend", "commandParamBegin", "commandNameStart", "commandnameend", " commandTimeEND", "operationParamStart", "commandTimeStart", "commandPathEnd", " commandLineEND", "commandnameEND", " commandLineBegin", "commandNameend", "commandParamStart", "commandParamEND", "operationParamend", "operationParamEnd", "commandTimeEnd", "commandLineEnd", "commandPathend", "operationNameStart", "operationNameend", "operationParamBegin"], "item": ["job", "app", "extra", "iter", "er", "data", "si", "it", "manager", "name", "channel", "edit", "handler", "el", "layer", "p", "info", "ip", "event", "xml", "base", "plugin", "add", "atom", "items", "page", "part", "user", "instance", "article", "client", "temp", "i", "entry", "hop", "image", "service", "bar", "api", "or", "response", "parent", "object", "builder", "order", "next", "ui", "other", "update", "li", "group", "admin", "server", "owner", "up", "Item", "menu", "source", "action", "result", "link", "area", "json", "obj", "option", "element", "site"], "e": ["x", "le", "er", " ev", "f", "ception", " pe", "oe", "force", "error", "edge", "handler", "ze", "change", "p", "se", " event", "one", "event", "ae", "en", "fe", "ec", "ie", "me", "u", "ite", "l", "E", "o", "exc", "err", "this", "ke", "d", "i", "ne", "t", "or", "Event", "ev", "v", "te", "pe", "ise", "c", "ce", "a", "ed", "es", "ea", "ve", "re", "esi", "ee"]}}
{"id1": "7891509", "id2": "8486429", "code1": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "code2": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"pageAddress": ["siteUrl", "urlUrl", "resourceaddress", "siteLocation", "urlLocation", "pageaddress", "siteName", "resourceLocation", "siteAddress", "PageLocation", "pageLocation", "urladdress", " pageUrl", "urlAddress", "PageName", "resourceUrl", " pageName", "pageUrl", "pageName", " pageLocation", "PageUrl", "PageAddress", "Pageaddress", "resourceAddress"], "url": ["reader", "connection", "open", "sl", "f", "data", "socket", "channel", "stream", "web", "base", "ssl", "plugin", "ls", "bb", "page", "b", "loader", "user", "l", "r", "client", "address", "this", "Url", "i", "URL", "source", "service", "image", "feed", "object", "uri", "server", "browser", "http", "file", "resource", "out", "host", "string", "element"], "in": ["reader", "bin", "isin", "login", "f", "data", "into", "socket", "s", "ins", "stream", "min", "In", "rec", "ssl", "inside", "kin", "conn", "b", "inner", "again", "win", "l", "din", "r", "line", "IN", "err", "client", "ini", "buffer", "i", "source", "init", "inc", "nin", "read", "inn", "c", "file", "as", "id", "impl", "resource", "input", "out", "token", "gin"], "inputLine": ["inputFile", "pageline", "InputCell", "imageFile", "inputPage", "selectPage", "inputContent", "inputL", "selectFile", " inputContent", "rawUrl", "pageString", "imageL", " inputline", "inputCell", " inputCell", "selectLine", "rawString", "InputLine", "rawPage", "rawLine", "rawContent", "InputL", " inputFile", " inputPage", " inputL", "inputUrl", " inputUrl", " inputString", "imageCell", "InputFile", "pageUrl", "rawline", "rawFile", "inputline", "pageLine", "imageLine", "inputString", "selectContent"]}}
{"id1": "21488518", "id2": "18782385", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 1, "substitutes": {"createNew": ["openOpen", "newOpen", "resourceNew", "createResource", "resourceOpen", "resourceCopy", "createCopy", "newResource", "newNew", "newCopy", "openCopy", "resourceResource", "createOpen", "openResource", "openNew"], "name": ["full", "office", "connection", "x", "missing", "ext", "ame", "data", "current", "self", "type", "non", "one", "label", "class", "base", "ix", "model", "part", "time", "size", "content", "old", "alias", "member", "e", "key", "ename", "address", "client", "comment", "style", "common", "image", "value", "anc", "large", "path", "parent", "filename", "url", "ui", "names", "Name", "n", "number", "code", "no", "default", "file", "folder", "id", "title", "prefix", "word", "search", "on", "resource", "named", "directory", "none", "string", "NAME", "end", "username"], "in": ["reader", "bin", "connection", "login", "data", "slice", "ins", "In", "inner", "size", "win", "din", "work", "IN", "plus", "ini", "buffer", "i", "source", "image", "init", "inc", "exec", "read", "raw", "pass", "thin", "up", "file", "id", "len", "src", "resource", "input", "record", "con", "diff"], "length": ["offset", "sequence", "type", "body", "Length", "timeout", "load", "ength", "time", "size", "bytes", "content", "line", "password", "buffer", "count", "padding", "limit", "path", "filename", "url", "width", "level", "number", "duration", "id", "len"], "contentType": ["ContentLength", "resourceType", " contentPath", "resourceLength", "ContentPath", "ContentType", "resourcetype", " contentLength", "contenttype", "contentPath", "Contenttype", "resourcePath", " contenttype", "contentLength"], "dest": ["prop", "trip", "cdn", "sup", "opt", "later", "tif", " destination", "cont", "destroy", "gz", "comb", "orig", "desc", "output", "conf", "txt", "img", "done", "zip", "trans", "dist", "temp", "dc", "d", "source", "parent", "config", "store", "route", "thin", "flat", "wb", "folder", "transform", "src", "Dest", "upload", "result", "target", "dir", "home", "tx", "de", "tmp"], "out": ["lock", "bin", "connection", "ext", "f", "data", "socket", "channel", "pool", "sync", "ex", "outs", "gz", "log", "copy", "page", "conn", "cache", "again", "output", "img", "zip", "cmd", "line", "writer", "err", "password", "o", "client", "flush", "OUT", "temp", "this", "buffer", "source", "image", "path", "exec", "object", "parent", "url", "view", "server", "null", "io", "file", "up", "result", "resource", "exp", "Out", "obj"], "request": ["job", "open", "ext", "get", "complete", "type", "remote", "QUEST", "reference", "quest", "wheel", "xml", "base", "req", "user", "instance", "query", "respect", "rer", "client", "external", "buffer", "call", "child", "path", "response", "object", "project", "Request", "url", "config", "transfer", "friend", "store", "route", "pe", "rate", "upload", "resource", "input", "claim", "directory", "report", "forward", "re", "access", "use"]}}
{"id1": "9647576", "id2": "12586404", "code1": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Override\n    public List<ProvaSolution[]> run(ProvaService prova, String agent, String key, String src) throws IOException {\n        File file = new File(src);\n        BufferedReader in;\n        InputStream is = null;\n        try {\n            if (!file.exists() || !file.canRead()) {\n                try {\n                    is = Thread.currentThread().getContextClassLoader().getResourceAsStream(src);\n                    in = new BufferedReader(new InputStreamReader(is));\n                } catch (Exception ex1) {\n                    try {\n                        is = RuleReaderImpl.class.getResourceAsStream(src);\n                        in = new BufferedReader(new InputStreamReader(is));\n                    } catch (Exception ex2) {\n                        try {\n                            URL url = new URL(src);\n                            in = new BufferedReader(new InputStreamReader(url.openStream()));\n                        } catch (Exception ex3) {\n                            throw new IOException(\"Cannot read from \" + src);\n                        }\n                    }\n                }\n            } else {\n                FileReader fr = new FileReader(file);\n                in = new BufferedReader(fr);\n            }\n            List<ProvaSolution[]> results = prova.consult(agent, in, key);\n            return results;\n        } finally {\n            if (is != null) is.close();\n        }\n    }\n", "label": 0, "substitutes": {"Reserve": ["Send", "Reserves", "Rerves", "Serve", " Reserves", "Rolve", "Rend", "Rerve", "Resolve", "Resend", " Resolve", "Solve", " Resend", "Serves"], "stbookings": ["stauthorings", "ssbookalls", "stbooksings", "stbookalls", "ssbookings", "ssbooksies", "stauthories", "stauthorifications", "stbooksalls", "stbooksies", "stbookifications", "ssbookifications", "stauthoralls", "ssbooksifications", "stbooksifications", "ssbookies", "stBookalls", "stBookings", "ssbooksings", "stbookies", "ssbooksalls", "stBookies", "stBookifications"], "stchartwl": ["stplotls", "STchartml", "stconfigml", "stchartls", "st_ls", "STchartwl", "stplotwl", "STconfigowl", "stchartml", "stchartowl", "STconfigml", "st_wl", "stplotowl", "stconfigowl", "STconfigwl", "st_owl", "STchartls", "STconfigls", "st_ml", "stconfigwl", "stconfigls", "STchartowl", "stplotml"], "sp": ["esp", "profile", "sl", "Sp", "sg", "name", "si", "tp", "email", "session", "type", "sc", "span", "sk", "rap", "space", "p", " sc", "inst", "isp", "str", "xml", "pace", "pl", "SP", "arp", "page", "pr", "ipp", "text", "jp", "op", "bp", "pp", "ig", "service", "source", "ap", " esp", "sil", " SP", "spe", "mp", " Sp", "ps", "scope", "script", "bsp", "amp", "osp", "ss", "sf", "spl", "spr", "html", "ip", "yp"], "userbooksql": ["usersbookprintf", "userbookssql", "userreadsil", " useraveskel", "userbooksearch", "otherbookssql", "userbooksprintf", "otherbooksql", "userlocksearch", "usersbooksprintf", "userreadsearch", "useraveskl", "otherbookql", "otherbookQL", "userbookskl", " useravesql", "userbookskel", "userordersql", "userpagesql", "userordersQL", "userreadsprintf", "userordersqs", "userbookqs", "usersbooksQL", "usersbookQL", "otherbookqs", "useraveskel", " userbookskel", "userbookql", "userorderssql", "usersbookearch", "userbooksil", " useravesil", " useraveskl", "usersbookql", "userpagessql", "userbookearch", "usersbooksql", "userlocksQL", "userbanksql", "userpagesqs", "userpagesQL", "userlocksprintf", "userreadsQL", "userbooksqs", "userreadskel", "userbookprintf", "useravesil", "userbookQL", "userreadsql", " userbookskl", "userlocksql", "otherbooksQL", "userbankskl", "usersbooksearch", "userbankskel", "userbooksQL", "useravesql", "userreadskl", "otherbooksqs", " userbooksil", "userbanksil"], "agentbooksql": ["userbookssql", "agentpagesql", "agentbookQL", "userpagesli", "agentstylesql", "agentbooksli", "agentbookli", "agentbookql", "agentbooksci", "agentstylesil", "userpagesql", "agentpagesli", "agentbooksil", "agentpluginsql", "agentpluginsci", "agentgroupsql", "userbooksqu", "userbooksil", "userpagessql", "agentbooksqu", "agentstylessql", "userpagesQL", "agentgroupsQL", "agentBookssql", "userbooksli", "userpagesci", "userbooksci", "agentstylesqu", "agentbookssql", "agentpluginssql", "agentBooksqu", "agentpluginsQL", "agentBooksql", "userbooksQL", "agentgroupssql", "agentbooksQL", "agentpagesci", "agentBooksil", "agentpagesQL", "agentpagessql", "agentgroupsli"], "bookingid": ["booksingsid", "bookingname", "bookillingurl", "bookingsid", "booksinginfo", "booksingid", "bookillingid", "bookingsname", "bookingsinfo", "booksingsname", "bookillingname", "bookinginfo", "bookINGinfo", "bookINGurl", "bookillinginfo", "booksingsinfo", "bookINGname", "bookingurl", "bookingsurl", "booksingurl", "booksingsurl", "booksingname", "bookINGid"], "currentcoach": [" currentpoac", "currentpoac", " currentcoah", " currentpoase", "currentpoache", "currentlycoache", "currentcoase", "currentcoah", "currentloached", "currentboached", "currentcoache", " currentloached", " currentcoached", " currentloah", "currentnoac", "currentnoach", " currentpoam", "currentchoase", "currentnoaching", "currentlycoach", "currentpoaching", "currentpoam", "currentchoam", "currentloah", "currentlycoac", " currentcoase", "currentboah", "currentCOase", " currentcoache", "currentcoached", " currentpoach", "currentgoach", "currentgoac", "currentlypoache", "currentlypoac", "currentlycoaching", "currentcoac", "currentcoam", " currentcoam", "currentCOach", " currentloache", "currentboache", "currentpoase", "currentnoache", "currentboach", "currentlypoaching", " currentcoac", "currentchoac", "currentCOam", "currentpoached", "currentgoaching", "currentchoach", "currentCOac", "currentloach", "currentpoach", "currentloache", "currentlypoach", "currentpoah", " currentloach", "currentcoaching", "currentgoache"], "currentseat": ["Currentslave", " currentcomponent", "Currentsex", "Currentseason", "activecourse", "Currentcomponent", " currentsex", "currentlyseat", "Currentcourse", "activeseat", "currentseason", "currentticket", "currentlysex", "Currentseat", " currentticket", "Currentticket", "activecomponent", " currentseason", "currentsex", "activeticket", "currentlyseason", "currentcomponent", " currentslave", "currentcourse", "currentslave", "currentlyslave", " currentcourse"], "tickpos": ["ickPos", "helloposition", "ickerpointer", "trialpos", "ickposition", " tickPos", "tickpose", " tickpose", "hellopos", "trialpose", "ickerpos", "helloPOS", "tickpo", "crosspos", "ickpo", "hellopointer", "ickpose", " tickPOS", "stickpos", "stickposition", "stickPos", "trialPos", "ickPOS", "ickpointer", "crosspo", "tickPos", "crossPos", "tickpointer", "ickerposition", "helloPos", "trialPOS", "ickerPos", " tickposition", "tickPOS", "tickposition", "ickpos", " tickpo"], "chartavailupdsql": ["chartavailupdatessql", "chartavailumpdsqs", "chartavailupdatesqs", "chartavailupdatesql", "chartavailupsssql", "chartavailupssqs", "chartavailumpdsql", "chartavailumpssql", "chartavailupdssql", "chartavailumpsssql", "chartavailupcsqs", "chartavailupssql", "chartavailumpdssql", "chartavailumpssqs", "chartavailupdsqs", "chartavailupcsql", "chartavailupcssql"]}}
{"id1": "5620792", "id2": "11477906", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "label": 0, "substitutes": {"SHA1": ["SHA256", "HAOne", "sha256", "sha64", "HA1", "sha1", "shaOne", "SHAOne", "HA256", "HA64", "SHA64"], "text": ["connection", "ext", "data", "name", "str", "hex", "binary", "class", "letter", "format", "contract", "txt", "content", "bytes", "password", "key", "address", "secret", "buffer", "source", "image", "template", "value", "Text", "path", "struct", "object", "pattern", "url", "context", "config", "transfer", "code", "in", "id", "prefix", "word", "message", "token", "TEXT", "input", "out", "length", "string", "font"], "HASH_VALUE_SIZE": ["HASH_VALUEFVALUE", "HASH_VALUEFSIZE", "HASH_VALUE2VALUE", "HASH_VALUE2LOAD", "HASH_SIZE_SIZE", "HASH_SIZE_VALUE", "HASH_VALUEFsize", "HASH_SIZE_LOAD", "HASH_VALUE2size", "HASH_VALUE2SIZE", "HASH_VALUE_LOAD", "HASH_Value_SIZE", "HASH_VALUE_Size", "HASH_Value_size", "HASH_Value_VALUE", "HASH_VALUE_VALUE", "HASH_VALUEFLOAD", "HASH_SIZE_size", "HASH_VALUE_size", "HASH_Value_Size"], "md": ["meta", "bd", "f", "data", "mag", "mg", "rm", "wd", "method", "dd", "m", "body", "mad", "ma", "em", " MD", "mt", "gen", "ind", "me", "ld", "dig", "mb", "am", "mac", "hm", "cmd", "dm", "um", "sm", "d", "MD", "mo", "mod", "hash", "amd", "sum", "mp", "code", "ng", "metadata", "mm", "pm", "mu", "valid", "message", "sha", "bf", "mc", "ms", "pd", "mand", "od", "nm", "editor", "pkg"], "sha1hash": ["sha2str", "sha2h", "SHA1hex", "ha1dig", "sha2hex", "ha1Hash", "sha1sum", "sha1hex", "sha2dot", "sha0h", "SHA2h", "ha1sum", "sha256h", "sha1dot", "sha9hash", "sha0hex", "SHA2hex", "SHA2dot", "sha64str", "sha256dot", "sha64sum", "SHA1h", "ha2dig", "sha0hash", "sha64dig", "sha1dig", "sha64Hash", "ha1str", "sha2sum", "sha1str", "ha2hash", "sha2dig", "sha0dot", "sha9Hash", "ha1hash", "ha2str", "ha2sum", "sha1h", "sha9dig", "sha2Hash", "SHA1hash", "sha1Hash", "ha2Hash", "SHA1dot", "sha64hash", "sha9str", "SHA2hash", "sha2hash", "sha256hex", "sha256hash"]}}
{"id1": "13233761", "id2": "3024992", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 0, "substitutes": {"executeUpdateTransaction": ["executeInsertStatement", "executeQuerySession", "executeDatabaseTransaction", "executeQueryStatement", "executeUpdateSession", "executeDatabaseTx", " executeUpdateSession", " executeUpdateStatement", "executeInsertTx", "executeUpdateStatement", "executeInsertSession", "executeDatabaseStatement", " executeDatabaseSession", "executeQueryTx", " executeDatabaseTransaction", " executeDatabaseStatement", "executeInsertTransaction", "executeDatabaseSession", " executeDatabaseTx", "executeQueryTransaction", " executeUpdateTx", "executeUpdateTx"], "queries": ["blands", "squands", "commires", "compests", "blests", "compands", "squips", "squires", "questires", "quires", "squests", "questeries", "quests", "bleries", "commands", "quips", "comperies", "compips", "blips", "quands", "squeries", "questands", "commeries", "questips", "commips"], "autoCommit": [" autoCommmit", "AutoCommit", " autoComits", "AutoDebit", "autoommitted", "autoDebmit", "autoommits", "autoDebits", "autocommit", "autoCommmit", "autoCommrit", "autoComits", "autoCompitted", " autoCommits", "autocommrit", "AutoCommits", "autoCompmit", "AutoCommmit", " autoComitted", "autoCommits", "autoCompits", "autocommmit", "autoComitted", "AutoCommrit", "AutoDebits", "autoommit", "autocommits", "autoCommitted", " autoComit", "AutoDebrit", "autoComit", "autoDebrit", " autoCommitted", "autoDebit", "autoCompit", "AutoDebmit", "autoommmit", "autoComrit"], "iterator": ["reader", "connection", "iter", "sequence", "data", "division", "ator", "gener", "population", "vector", "handler", "database", "runners", "slice", "creator", "later", "stream", "filter", "started", "info", "inst", "set", "ie", "adder", "loop", "inner", "instance", "walker", "loader", "size", "section", "former", "done", "internet", "collection", "encer", "parser", "ter", "list", "i", "entry", "step", "pointer", "init", "starter", "interstitial", "outer", "next", "context", "finder", "metadata", "Iterator", "index", "series", "consider", "cher", "inter", "string", "start", "end", "runner", "ski"], "query": ["connection", "sequence", "data", "name", "question", "q", "table", "command", "press", "filter", "str", "expression", "rule", "commit", "qu", "key", "sq", "row", "comment", "call", "entry", "style", "condition", "select", "value", "next", "update", "uri", "script", "search", "message", "action", "ql", "result", "record", "join", "sql", "string", "Query"], "statement": ["connection", "sequence", "data", "si", "start", "session", "s", "database", "command", "table", "usage", "inst", "state", "mt", "expression", "commit", "conn", "section", "parser", "flush", "comment", "style", "storage", "condition", "response", "ment", "next", "document", "unit", "function", "script", "action", "Statement", "stat", "result", "join", "sql", "execute", "string", "use", "element"]}}
{"id1": "10728243", "id2": "15810440", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"scramble411": ["scramprint411", "screamprint411", "screamble123", "screamprint41", "screamble5", "screamprint123", "screamprint5", "scramble5", "scramble41", "scramcy41", "scramprint5", "scramprint123", "screamble411", "scrambe5", "scramcy123", "scramble123", "scrambe41", "scramcy5", "scrambe123", "screamble41", "scrambe411", "scramprint41", "scramcy411"], "password": ["wallet", "name", "channel", "email", "wd", "sudo", "words", "user", "Password", "mac", "account", "key", "address", "secret", "crypt", "padding", "sword", "project", "phrase", "PASS", "hash", "path", "filename", "attribute", "sum", "config", "number", "pass", "dh", "word", "prefix", "token", "input", "pad", "security", "auth", "string", "username"], "seed": ["offset", "volume", "Salt", "finger", "name", "machine", "slice", "pair", "state", "mode", "sudo", "text", "size", "zip", "alias", "key", "random", "address", "secret", "crypt", "padding", "source", "template", "driver", "phrase", "hash", "pattern", "prime", "sum", "pass", "shadow", "id", "prefix", "eed", "token", "pad", "length", "string", "device", "username"], "md": [" Md", "bm", "meta", "df", "bd", "vd", "doc", "mag", "mg", "cd", "addr", "rm", "wd", "ds", "grad", "mad", "dd", "m", "ma", " MD", "mt", "mode", "ind", "ld", "kg", "dig", "di", "mid", "om", "mb", "ht", "am", "part", "mac", "hm", "cmd", "dm", "mn", "sm", "d", "dc", "MD", "km", "gd", "mo", "diff", "amd", "mi", "mp", "metadata", "mm", "pm", "dh", "sha", "po", "cm", "mem", "mc", "nd", "ms", "pd", "mand", "ad", "od", "hd", "nm", "Cmd", "pkg"], "passwordHashStage1": ["passwordSumStage1", "passwordSumPhase1", "passwordHashPhaseOne", "passwordSumStage0", "passwordHashstage3", "passwordHashstage4", "passwordHashstage0", "passwordSumStage4", "passwordSumPhase2", "passwordSumPhase4", "passwordHashPhase0", "passwordHashPhase4", "passwordHashStageOne", "passwordSumStage3", "passwordHashStep3", "passwordHashStep1", "passwordHashStep2", "passwordSumPhase3", "passwordHashstage2", "passwordSumStage2", "passwordHashstage1", "passwordSumPhaseOne", "passwordSumPhase0", "passwordHashPhase1", "passwordHashPhase2", "passwordHashPhase3", "passwordHashStage4", "passwordHashstageOne", "passwordSumStageOne", "passwordHashStage3", "passwordHashStage0"], "passwordHashStage2": ["passwordHashStage02", "passwordSumStage1", "passwordSumPhase1", "passwordSumStageTwo", "passwordHashStage8", "passwordBlockStage1", "passwordBlockStage4", "passwordBlockstage4", "passwordHashstage8", "passwordBlockstage2", "passwordHashstage4", "passwordBlockStage8", "passwordHashStep4", "passwordSumPhase2", "passwordSumStage02", "passwordHashPhase8", "passwordHashStageTwo", "passwordHashPhase02", "passwordHashPhase4", "passwordBlockStage2", "passwordHashstage02", "passwordHashstageTwo", "passwordHashStep1", "passwordHashStep2", "passwordHashstage2", "passwordSumStage2", "passwordHashstage1", "passwordHashPhaseTwo", "passwordBlockstage1", "passwordHashPhase1", "passwordHashStep8", "passwordSumPhaseTwo", "passwordHashPhase2", "passwordBlockstage8", "passwordHashStage4", "passwordSumPhase02"], "toBeXord": ["tobeXorder", "toBeCrossor", "toBeZorder", "toBeWorkors", "tobeYors", "toBeXords", "toBEYord", "toBeXor", "toBeXors", "toBeZors", "toBEYORD", "toBeCrossords", "toBeZor", "toBEXords", "toBeYorder", "tobeXords", "tobeYorder", "toBeWorkord", "toBEXORD", "toBEYor", "toBeXorder", "toBeCrossord", "toBeYord", "tobeYord", "tobeXors", "tobeXord", "tobeCrossords", "toBEXord", "tobeCrossor", "toBeWorkords", "toBeXORD", "toBeYors", "toBeWorkORD", "toBeCrossors", "tobeCrossord", "tobeYor", "toBeZORD", "toBeWorkorder", "toBeYor", "toBeYords", "toBeCrossORD", "toBEYords", "toBeWorkor", "toBeZords", "toBEXor", "tobeXor", "tobeCrossors", "toBeZord", "toBeYORD"], "numToXor": ["numToXors", "numToXOr", "numToCrossOr", "num2XOr", "numToxOR", "numToWorkOR", "numToAbsorer", "numtoXors", "numtoxorer", "numToXOR", "num2Xorer", "numToAbsor", "numtoxor", "numToxors", "numToAnyOR", "numtoxOR", "numToAbsOR", "num2AbsOr", "num2XOR", "numtoxors", "numToAnyorer", "numToWorkors", "numToXorer", "numToWorkor", "num2AbsOR", "numToWorkorer", "numToCrossor", "numToCrossors", "numtoXorer", "numtoXOR", "numToxor", "numToAnyOr", "numToCrossorer", "num2Xor", "numToxorer", "numToAbsOr", "num2Absorer", "numToAnyor", "num2Absor", "numtoXor", "numToCrossOR"], "i": ["x", "f", "y", "si", "it", "ti", "ri", "slice", "m", "p", "j", "info", "pi", "k", "ix", "hi", "I", "di", "u", "b", "part", "multi", "bi", "qi", "l", "r", "e", "o", "key", "off", "abi", "d", "ci", "z", "t", "h", "xi", "v", "oi", "ui", "li", "uri", "n", "ii", "io", "c", "in", "id", "index", "chi", "a", "ai", "gi", "ip"]}}
{"id1": "17999474", "id2": "10451698", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipasfile", "getZipAtFile", "getZipAsDir", "getTempAsfile", "getTempAsFile", "getZipAtfile", "getTempAsPlace", "getTempAsDir", "getZipAtDir", "getZipasPlace", "getZipasDir", "getZipAsPlace", "getZipAtPlace", "getZipAsfile", "getZipasFile"], "digOb": ["signOb", " digob", "signObject", " digObject", "digOl", "dimOb", " digObj", "signob", " digOl", "signOB", "dimObject", "DigObj", "Digob", "ditob", "dimObj", "DigObject", "signObj", "DigOl", "digOB", "digObj", "ditOB", "ditObject", "DigOb", "ditOb", "digob", " digOB", "dimOl", "digObject"], "folderName": [" foldername", "foldPath", " folderDir", "foldName", "fileName", "foldername", "FolderName", "folderPath", "foldname", "packagePath", "packagename", "packageName", "foldInfo", "folderDir", "FolderPath", "FolderDir", "filePath", "fileInfo", "filename", "FolderInfo", " folderPath", "folderInfo", "Foldername", "packageDir"], "tmpFolder": ["tempDirectory", " temporaryManager", "tempManager", "tmpManager", "mpfolder", "tempfolder", "mpFolder", "tempDir", " temporaryFolder", "mpDir", "tmpfolder", " tmpDir", " tmpDirectory", "mpDirectory", " temporaryfolder", " tmpfolder", "tempFolder", "tmpDirectory", " tmpManager", "tmpDir", " temporaryDirectory"], "zip": ["pipe", "lock", "job", "sl", "f", "archive", "ze", "slice", "py", "seed", "install", "p", "download", "gz", "jar", "xml", "ie", "copy", "wrap", "clip", "cop", "bag", "flow", "temp", "zone", "proxy", "lib", "source", "pack", "lex", "z", "feed", "cf", "ulp", "url", " zipper", "io", "flat", "file", "folder", "ce", "ress", "upload", "ipped", "fp", " ZIP", "Zip", "json", "ip", "ignore", "tmp", "pkg"], "out": ["connection", "f", "socket", "sync", "info", "ex", "outs", "download", "gz", "gen", "os", "plain", "base", "log", "is", "copy", "page", "conn", "cache", "again", "output", "user", "loader", "box", "writer", "line", "err", "flow", "o", "client", "flush", "OUT", "temp", "this", "cli", "source", "z", "child", "path", "parent", "object", "url", "null", "io", "in", "file", "a", "upload", "result", "Out", "write", "obj"]}}
{"id1": "23532405", "id2": "8625346", "code1": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"persist": ["plist", "plister", "persistence", " Persister", " Persistence", "Persists", "Persister", " Persist", "plistence", "plists", "Persist", " Persists", "persists", "persister", "Persistence"], "ffConfigurable": ["ffGur", "ffPlur", "uffLoguring", "ffConfigured", "ffConfiguring", "uffLogurable", "ffConfigure", "effConfigural", "ffconfigural", "ffLogure", "FFConfurer", "FFConfigurable", "ffFure", "ffconfigurable", "ffPlurable", "ffSegurred", "ffConfigurred", "ffSegurable", "uffLogure", "FFConfiguring", "ffConfuring", "FFConfuring", "ffLogured", "ffConfigurer", "ffPluring", "ffLogural", "FFConfurred", "ffConfurable", "effConfigurable", "ffFuring", "effConfigured", "ffLogurer", "uffLogured", "ffGuring", "ffGurer", "ffConfure", "ffConfurred", "FFConfur", "effConfurable", "ffSegurer", "ffConfural", "ffSegural", "FFConfigur", "ffConfigur", "ffConfur", "FFConfigurer", "ffSegured", "FFConfurable", "uffConfigure", "ffConfurer", "uffConfigurable", "uffConfigured", "uffConfiguring", "ffLogurable", "effConfurer", "FFConfigurred", "FFConfural", "effConfured", "ffPlurer", "FFConfigural", "ffConfured", "ffLoguring", "ffFurable", "effConfural", "ffconfigurer", "ffconfigurred", "ffConfigural", "ffFured", "ffGurable", "effConfigurer"], "relativePath": [" relativepath", "ativeLocation", "ativeUrl", "relativepath", "absoluteLocation", "protectedPath", "relativeName", "absolutePoint", " relativePoint", "absolutepath", "absoluteUrl", " relativeName", "relativeLocation", "relativeFile", "relativePoint", "protectedFile", "ativePath", " relativeUrl", "absoluteName", " relativeFile", " relativeLocation", "absolutePath", "ativeName", "protectedPoint", "relativeUrl", "protectedpath", "absoluteFile"], "file": ["full", "le", "f", "data", "get", "name", "it", "File", "self", "place", "handler", "type", "el", "stream", " File", "fe", "local", "class", "base", "log", "model", "cache", "b", "part", "files", "zip", "l", "work", "single", "e", "temp", "show", "source", "image", "db", "ile", "cf", "path", "il", "filename", "object", "parent", "form", "url", "config", "store", "unit", "pe", "http", "io", "in", "folder", "php", "module", "FILE", "sf", "fp", "out", "dir", "directory", "location", "use"], "is": ["ais", "Is", "iss", "si", "does", "oss", "info", "ics", "gets", "isa", "IS", "was", "i", "mis", "ws", "api", "nis", "bis", "ui", "ir", "ps", "io", "ris", "as", "in", "ii", "iso", "iris", "es", "ai", "out", "us", "ios", "ms", "ip", "fs", "isi"], "os": ["oS", "ens", "ais", "oa", "cos", "oss", "s", "oos", "uns", "bos", "ori", "ips", "outs", "ol", "oid", "ies", "obs", "ops", "rs", "oses", "o", " bos", "OS", "Os", "oes", "io", "osi", "as", "ils", "iso", "aos", "ou", "us", "ios", "los", "ms", "fs", "ows"]}}
{"id1": "300397", "id2": "536614", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrap", "readandRewrites", "readAndRewwrite", "readandrewrites", "readandRewrap", "readAndSwwrite", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readAndRebrites", "readAndRewrites", "readAndrewrites", "readandrewrite", "readandRewwrite", "readandrewrap", "readAndRebrite", "readAndSwrites", "readAndSwrite", "readAndRebrap", "readAndrewrap", "readandrewwrite", "readAndRewrap", "readandRewrite"], "inFile": ["inputFile", "outFiles", "oldFile", "loginfile", "oldFilename", "infile", "inputfile", "outfile", "loginFile", " inSourceFile", "loginFiles", "inSourceFile", "outSourceFile", "loginFilename", "inFiles", "InFiles", " infile", "InSourceFile", "oldfile", "oldFiles", "inputFiles", "outFilename", " inFilename", "inFilename", "InFile", "Infile", " inFiles", "inputFilename"], "outFile": ["processFILE", "newFile", "newStream", "Outfile", " outStream", "thisFILE", "outDir", "thisfile", "outfile", " outDir", "outStream", "outputFile", "processFile", "processPlace", "offFile", "processFilename", "outputPlace", "offFilename", " outfile", "OutStream", "newDir", "outputFILE", "outputFilename", "thisFile", "outPlace", "exFILE", "exFilename", "newfile", "exFile", "outFilename", "outputfile", "offPlace", "OutDir", "outFILE", "thisFilename", "exfile", "OutFile", "offFILE"], "iis": ["iais", "Iais", " iIs", "iiss", "Iis", "IIS", " iiss", "iiIs", "iniis", "iniiss", " iris", "iniIs", "ciris", "iniIS", "iiis", "ciIs", "iiris", "iniris", "Iiss", "iiiss", " iIS", "ciIS", "iiIS", "iIS", "iris", "ciis", "iIs", "ciiss", "ciais", " iais"], "dcmParser": ["dcrParser", " dpmPar", "dmParser", "dcmJar", "dcrPar", "DcmInstallation", "dmissionReader", "dpmPlugin", "dmissionParser", " dpmReader", "dkmParser", "dcrLoader", "dhemInstallation", " dcrReader", " dcmReader", "dmcJar", "dmissionPlugin", "dcmPar", "dpmInstallation", "dcmHandler", "dpmHandler", " dpmparser", "dmLoader", "dpmPolicy", "dpmParser", "dcmPlugin", "dmmParser", " dcmLoader", " dpmJar", "dcmLanguage", "DcmJar", "dcrPlugin", " dpmarser", " dcmparser", "dmcPar", " dcmPar", "dmcParser", " dcrPlugin", "dkmPolicy", "dpmPar", "dCMLoader", "dpmLoader", "dbmPlugin", "dCMParser", " dpmHelper", "fcmReader", "dbmParser", "dCMHandler", "fpmReader", "dcrReader", "dkmPlugin", " dcmPolicy", "fpmHandler", "fcmparser", "dpmarser", "dmmparser", " dcmarser", "dbmPolicy", "dpmLanguage", "dcrJar", "dmoduleJar", "dmoduleparser", " dpmParser", "fcmHandler", "dmcarser", "dpmReader", "dcmPolicy", "dcmLoader", "dcmHelper", " dcmJar", " dcmPlugin", " dpmPlugin", "dpmparser", "dmoduleReader", "dmPlugin", " dcmHelper", "dhemJar", "dcmarser", "fpmparser", "dbmHelper", " dpmLoader", " dpmLanguage", "dmReader", " dcrLoader", "dcmparser", " dpmPolicy", "dmissionLanguage", "dhemParser", "dmmLoader", "dmodulePlugin", "dcrarser", "fpmParser", "dCMReader", "dCMPlugin", "fcmParser", "dCMparser", " dcmLanguage", "dcmInstallation", "dmoduleParser", " dcrParser", "DcmReader", "dhemReader", "dpmHelper", "dpmJar", "dmmPlugin", "dcmReader", "DcmParser", "dkmHelper"], "ds": ["cdn", "df", "ts", "asi", "data", "iss", "vals", "eps", "s", "icks", "bs", "dd", "ins", "services", "sync", "session", "ns", "da", "Ds", "utils", "os", "sys", "cs", "ld", "ls", "ys", "di", "conn", "parts", "is", "rs", "drivers", "dds", "Db", "dr", "dc", "d", "ras", "nas", "gd", "db", "points", "qs", "js", "ws", "tes", "DS", "Os", "xs", "uds", "vs", "gs", "ays", "ps", "details", "ils", "ants", "des", "src", "amps", "ros", "dat", "ss", "pd", "ads", "tx", "ks", "dt"], "pdReader": ["hdLoader", "pdRunner", "pbReader", "hdStream", "ddRunner", "dsreader", "dsReader", "ddLoader", "pdLoader", "pdStream", "pcLoader", "xdReader", "pcReader", "dsRead", "pbRunner", "pdreader", "pcWriter", "ddStream", "ddReader", "hdreader", "xdreader", "dsLoader", "xdWriter", "pdRead", "pbLoader", "pcRead", "hdWriter", "hdRead", "xdRead", "pbStream", "hdRunner", "hdReader", "dsWriter"], "out": ["lock", "ext", "login", "data", "doc", "name", "at", "down", "outs", "ssl", "w", "err", "flow", "o", "dot", "cli", "oder", "exec", "url", "default", "null", "io", "as", "co", "exp", "over", "point", "later", "session", "auto", "to", "sys", "page", "cache", "conn", "inner", "output", "term", "her", "key", "client", "builder", "outer", "parent", "order", "group", "code", "up", "word", "result", "director", "copy", "model", "with", "part", "line", "writer", "temp", "external", "lib", "image", "inc", "store", "Out", "obj", "device", "full", "connection", "manager", "s", "dev", "array", "sync", "layer", "ex", "gen", "base", "user", "again", "img", "password", "OUT", "list", "db", "child", " in", "object", "pass", "net", "in", "file", "diff", "write"], "dcmEncParam": ["dcmEstPar", "dcmDecPart", "dcmEncParameter", "dcmEncPart", "dcmElType", "dcmEnParameter", "dcmArchParameter", "dcmEnPar", "dcmDecArg", "dcmEnType", "dcmEstParameter", "dcmEstParam", "dcmArchArg", "dcmSecPart", "dcmDecParameter", "dcmEnPart", "dcmDecType", "dcmDecParam", "dcmEncPar", "dcmSecPar", "dcmSecParam", "dcmEncArg", "dcmEncType", "dcmElPar", "dcmEstType", "dcmElParameter", "dcmDecPar", "dcmEnArg", "dcmSecType", "dcmEnParam", "dcmArchParam", "dcmElParam"], "pdWriter": ["dsWrite", "PDWriting", "dpWriter", "pdWriting", "dsReader", "hdWrite", "dpWrite", "htWriting", "PDReader", "ddWrite", "dsOutput", "hdOutput", "PDWrite", "ddReader", "dpReader", "htReader", "pdOutput", "ddWriter", "pdWrite", "htWrite", "ddOutput", "PDWriter", "htWriter", "hdWriter", "hdReader", "dsWriter", "dpWriting"]}}
{"id1": "3309233", "id2": "14820302", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doUsingConsole", " doAsyncBackground", " doAsyncStudio", " doInAsync", "buildUsingBackground", " doUsingStudio", " doAsAsync", "buildInBackground", " doAsConsole", "buildUsingStudio", "buildUsingConsole", " doInConsole", " doAsBackground", " doAsyncConsole", "buildInConsole", "buildInStudio", "buildUsingAsync", " doInStudio", " doAsyncAsync", "buildInAsync", " doAsStudio", " doUsingBackground", " doUsingAsync"], "params": ["values", "data", "eps", "ds", "s", "type", "options", "py", "services", "results", "p", "settings", "ams", "par", "arms", "ls", "page", "mes", "parts", "files", "Parameters", "Param", "posts", "lines", "address", "strings", "i", "parse", "sp", "source", "pins", "ctx", "phrase", "objects", "comments", "config", "names", "ps", "details", "keys", "pm", "properties", "los", "reports", "types", "resources", "json", "Par"], "param": ["connection", "name", "channel", " parameter", "pool", "prom", "Parameter", "monitor", "string", "mor", "p", "ams", "par", "arm", "proc", "option", "pc", "camp", "lc", "model", "page", "conn", "part", "conf", "am", "contract", "aram", "gram", "Param", "vm", "rem", "password", "address", "temp", "single", "ram", "comment", "ctx", "project", "path", "parent", "object", "iam", "prem", "default", "config", "pri", "null", "mm", "pm", "amp", "cm", "mand", "cp", "km", "pb", "meter"], "client": ["connection", "app", "force", "self", "channel", "session", "handler", "apache", "secure", "Client", "comp", "p", "plugin", "ssl", "base", "conn", "proxy", "service", "cli", "connect", "api", "project", "response", "request", "cl", "url", "config", "server", "bird", "http", "c", "ce", "google", "resource", "cm", "con", "host", "help", "cp"], "post": ["f", "posted", "head", "put", "dd", "create", "install", "body", "p", "send", "wp", "load", "json", "proc", "set", "base", "add", "part", "op", "zip", "pre", "and", "query", "e", "patch", "pp", "comment", "hop", "entry", "feed", "api", "submit", "request", "response", "Post", "POST", "next", "form", "server", "http", "c", "pos", "upload", "push", "pod", "pb"], "resp": ["rh", "Resp", "error", "handler", "respond", "body", " response", "download", "enc", "par", "received", "Response", "rec", "status", "req", "page", "conn", "content", "success", "e", "err", "reply", "comm", "sp", "api", "request", "response", "exec", "server", "http", "rel", "rep", "resource", "res", "ref", "re", "json", "fc", "serv", "obj"], "entity": ["connection", "agent", "ity", "data", "el", "body", "enc", "event", "ec", "xml", "activity", "base", "status", "model", "conn", "node", "output", "instance", "content", "article", "line", "e", "translation", "entry", "Entity", "response", "object", "attribute", "code", "unit", "person", "resource", "coll", "json", "string", "ent", "obj", "element"], "result": ["data", "name", "place", "string", "results", "status", "match", "description", "page", "text", "output", "instance", "content", "Result", "success", "line", "translation", "address", "ret", "row", "entry", "source", "value", "response", "object", "property", "url", "default", "details", "message", "resource", "res", "record", "report", "location", "json", "desc"]}}
{"id1": "5872038", "id2": "364438", "code1": "    public void parse() throws ParserConfigurationException, SAXException, IOException {\n        DefaultHttpClient httpclient = initialise();\n        HttpResponse result = httpclient.execute(new HttpGet(urlString));\n        SAXParserFactory spf = SAXParserFactory.newInstance();\n        if (spf != null) {\n            SAXParser sp = spf.newSAXParser();\n            sp.parse(result.getEntity().getContent(), this);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"parse": [" scrape", "save", "Parser", "scan", " process", "create", "handle", "send", "se", "load", "xml", "set", "format", "arse", "throw", " parsing", "parser", "patch", " serve", "pack", "build", " explode", "feed", "process", "request", "exec", "eval", "delete", "read", "post", " parser", " service", "split", "transform", " assemble", " load", "report", "execute", "print", "write", " analyse", "apply"], "SAXException": ["SAXYWarning", "SAXYEX", "SAXWarning", "IAXException", "SAFXWarning", "SAFXEX", "SAXXWarning", "IAXWarning", "SAXXEX", "SAXEX", "IAXEX", "SAXXException", "IAFXEX", "SAFXException", "IAFXException", "IAFXWarning", "SAXYException"], "IOException": [" IOception", " IOExcept", "APIception", "SecurityExcept", "SecurityException", "APIException", "IOExcept", "APIExcept", "Securityception", "IOception"], "httpclient": ["Httpapi", "httpapi", " httpClient", "httpsapi", "httpserver", " httpapi", " httpconnection", "httpsserver", "Httpserver", "HttpClient", "Httpconnection", "httpClient", " httpserver", "httpconnection", "Httpclient", "httpsclient", "httpsconnection", "httpsClient"], "result": ["data", "session", "results", "rc", "status", "match", "page", "output", "instance", "Result", "success", "r", "err", "plus", "client", "this", "ret", "found", "product", "source", "api", "request", "response", "url", "default", "document", "server", "http", "sr", "message", "res", "resource", "record", "out", "report", "json", "obj"], "spf": [" spfx", " spcf", "Spf", "espfx", "espf", "SPfc", "spsf", " spfc", "scsf", "prf", "espfc", "scf", "SPf", "spfp", "SpF", "scfp", "prfp", "sccf", "Spcf", " spsf", "spcf", "espfs", " spfs", "spF", " spfp", "SPfp", "SPfs", "SPcf", "spfs", "prcf", "prF", "SPsf", " spF", "Spfp", "SPfx", "spfc", "spfx"], "sp": ["esp", "app", "sl", "f", "Sp", "si", "tp", "sc", "pt", "span", "p", "se", "inst", "wp", "par", "str", "pc", "pl", "SP", "pr", "br", "op", "bp", "parser", "asp", "pp", "service", "ap", "sw", "pe", "ps", "sr", "bsp", "ss", "sf", "gp", "obj", "spl", "so", "html", "serv", "sh"]}}
{"id1": "12146394", "id2": "10391753", "code1": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"md5Crypt": ["md4Key", "md6crypt", "md5Hash", "md2Crypt", "md6Hash", "md4Hash", "md2Key", "md6Crypt", "MD2Crypt", "md6Key", "MD5crypt", "MD2Hash", "MD5Hash", "md4crypt", "MD2Key", "md4Crypt", "md5Key", "md2crypt", "md2Hash", "MD5Crypt", "MD5Key", "md5crypt", "MD2crypt"], "key": ["lock", "proof", "data", "name", "version", "self", "type", "ssl", "carry", "shift", "magic", "kh", "go", "ke", "service", "source", "money", "ask", "cookie", "air", "other", "transfer", "sign", "number", "wire", "ce", "message", "fee", "length", "element", "cy", "point", "m", "power", "rule", "cer", "cache", "zip", "secret", "kid", "call", "row", "value", "parent", "hash", "order", "code", "date", "id", "word", "Key", "use", "x", "my", "seed", "state", "here", "copy", "year", "root", "ace", "temp", "this", "image", "phrase", "no", "empty", "trust", "ip", "full", "connection", "y", "char", "kw", "sync", "pair", "k", "any", "base", "blow", "req", "KEY", "user", "time", "text", "size", "password", "material", "list", "ch", "server", "core", "scope", "cert", "token", "input", "none", "string", "ee"], "salt": [" ssecret", "Salt", "ssalt", "sesift", "sesort", "osalt", "seskey", "sesalt", "osALT", "asal", "sesart", "Sodium", "southALT", "sesul", "sort", "ssALT", "svort", "sift", " skey", "ssol", "sesass", " sodium", "sessecret", "sal", "assecret", "sesALT", "sodium", "sesal", "svALT", "skey", "sul", "southsecret", " sALT", "asalt", " sass", "southift", "sol", "Ssecret", " sift", "southart", " sol", "ssass", "SALT", "osift", "ssecret", "sass", "sALT", "Sal", "osul", "southodium", "svalt", "asALT", "sval", " sart", "sart", "southalt", "sesol"], "_md": ["_MD", " _MD", " _amd", "_cmd", "\u00a0mand", "__cmd", " _nm", "_mg", "Newdm", " _dm", "_amd", "copydm", "_mand", "_m", " _m", "copymd", "__dm", "copycmd", "_key", " _key", "localmb", "Newamd", "localcmd", "\u00a0cmd", "\u00a0m", "__amd", "Newmd", "\u00a0dm", "\u00a0nm", "copykey", "_db", "_mb", " _cmd", "localmd", " _db", "_nm", "localmg", "\u00a0mode", "_dm", "_mode", "__md", "\u00a0md", "Newcmd"], "md2": ["cmd62", "amd2", "md02", "mdTwo", "md1", "hd32", "hd2", "MD62", " md4", "amd32", " md02", " md1", "md5", "hd62", "amd02", "cmd1", "MD4", "amd62", "MD5", " mdTwo", "cmd4", "md32", "MD1", " md32", "cmd02", "hdTwo", "amd4", "MD2", "md62", "md4", "amdTwo", "cmd5", "cmd3", " md5", "cmd2", " md62", "MD3"], "abyFinal": ["abeLast", "amyInitial", "rayInitial", "andyFinal", "rayFinal", "BabyFinish", "aberTotal", "andyInitial", "abiesFull", "abiesFinal", "sayInitial", "andyTotal", "abeFinish", "abyLast", "aberFinal", "abyTotal", "BabyFull", "abiesFinish", "abeFull", "abiesSuccess", "babyLast", "aberfinal", "saySpecial", "aberInitial", "rayLast", "babySuccess", "amyResult", "babyFinal", "abiesResult", "amySuccess", "amySpecial", "BabyFinal", "BabyLast", "Babyfinal", "andyLast", "abiesLast", "babyfinal", "amyFinal", "abyInitial", "sayFinal", "abeFinal", "abyFull", "abyFinish", "abyResult", "babyResult", "abySpecial", "andyfinal", "abyfinal", "butInitial", "butLast", "abySuccess", "butFinal", "babyInitial", "babySpecial", "babyTotal"], "n": ["x", "nt", "nn", "f", "y", "cn", "name", "nan", "nc", "un", "sn", "g", "m", "span", "byn", "na", "p", "dn", "ns", "non", "syn", "en", "k", "min", "not", "conn", "b", "all", "br", "num", "nu", "don", "l", "r", "fn", "o", "mn", "d", "ne", "ner", "z", "t", "pn", "yn", "v", "no", "number", "nor", "N", "net", "c", "ng", "inn", "ni", "nw", "a", "len", "np", "on", "adj", "network", "ny", "none", "nb", "gn", "node"], "j": ["x", "ji", "ij", "y", "jj", "bj", "si", "q", "p", "k", "ind", "ie", "I", "di", "jp", "b", "u", "num", "section", "qi", "l", "aj", "ja", "fr", "o", "jc", "d", "ne", "ci", "z", "js", "J", "xi", "v", "yi", "li", "ii", "io", "c", "uj", "ni", "index", "jl", "dj", "adj"], "i": ["ji", "y", "si", "ti", "ri", "mini", "p", "pi", "ie", "I", "di", "bi", "multi", "qi", "fi", "e", "o", "ini", "ci", "ali", "ki", "xi", "yi", "mi", "ui", "oi", "li", "zi", "ani", "ii", "io", "c", "ni", "iu", "index", "mu", "chi", "eni", "gi", "ai", "phi", "gu"], "sbPasswd": ["sbParwords", "sbPassrc", "rbCrw", "rbCrwd", "sfPassw", "bbParrc", "sbParrc", "sfSecretwd", "bbParwd", "sbPassWD", "sfSecretwords", "sbSecretwd", "sfPasswd", "cbPasswd", "cbParw", "sbPassw", "sbPassword", "sbCrwd", "sbCrwords", "sbCrrc", "rbCrWD", "sbParwd", "sbPassphrase", "rbPassw", "cbParwd", "sfSecretword", "sbPasswords", "bbPassword", "cbParword", "sbSecretw", "cbPassw", "sbParWD", "bbPassrc", "sbParw", "sbCrWD", "cbPassphrase", "sbCrw", "sfSecretw", "sbSecretword", "cbPassword", "sbFailphrase", "bbPasswd", "bbPassw", "rbCrword", "cbParphrase", "sfPasswords", "sbSecretwords", "rbPassWD", "bbParword", "sbFailwd", "sfPassword", "rbPasswd", "sbCrword", "sbFailword", "rbPassword", "sbFailw", "sbParword", "bbParw", "sbParphrase"], "md3": ["amd512", "amd23", "md1", "mand15", "mag512", "md15", "mdthree", "amd15", "mand3", "MD23", " mdthird", "MD53", "msthird", " mdthree", " md1", " md23", "cmd1", "mand512", "md512", "mag15", "mag3", " md03", "MD1", " md53", "cmd53", "mand23", "MD2", "mag23", "amdthird", "msthree", "ms3", "md53", "mdthird", "md23", "cmd23", "cmd3", "ms03", "amd03", "md03", "amdthree", "cmd2", "MD3", "amd3"]}}
{"id1": "12236729", "id2": "2022160", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "label": 1, "substitutes": {"copy": ["get", "py", "sync", "p", "download", "dump", "zip", "clip", "cop", "paste", "cmp", "cat", "Copy", "transfer", " dup", " copied", "io", " copying", "split", "clone", "php", "upload", "diff", "replace", "cp", " transfer", " Copy"], "inputFile": ["currentFile", "inputfile", "outputDir", "sourceFiles", " inputfile", " inputFiles", " inputPath", "outputPath", "inputDir", "currentfile", "sourcePath", "outputFiles", "sourcefile", "inputFiles", "outputfile", "currentDir", " inputDir", "sourceFile", "inputPath", "currentFiles"], "outputFile": ["tempDirectory", "inputfile", "outputDir", " outputDirectory", "Outputfile", "OutputDir", "tempDir", "referencefile", "tempfile", " outputDir", " outputFilename", "inputDir", "outputFilename", " outputfile", "OutputDirectory", "outputfile", "referenceFilename", "referenceFile", "referenceDir", "outputDirectory", "OutputFile", "tempFile", "inputFilename"], "in": ["reader", "bin", "connection", "lock", "sin", "f", "login", "get", "into", "socket", "s", "ins", "pin", "cin", "min", "In", "is", "inside", "kin", "conn", "inner", "again", "win", "din", "l", "r", "IN", "e", "err", "pull", "ini", "i", "source", "init", "image", "inc", "nin", "n", "read", "inn", "up", "as", "file", "id", "a", "lin", "input", "con", "ln", "gin"], "out": ["bin", "extra", "outside", "socket", "at", "error", "sync", "ex", "outs", "one", "plain", "log", "conn", "w", "b", "output", "again", "cache", "writer", "line", "err", "plus", "o", "off", "OUT", "temp", "i", "inc", "exec", "outer", "parent", "v", "n", "post", "null", "io", "net", "file", "up", "Out", "write", "obj", "over"], "c": ["x", "f", "char", "cd", "sc", "m", "ct", "C", "p", "k", "ec", "pc", "rc", "lc", "u", "b", "cr", "l", "line", "r", "e", "o", "esc", "d", "i", "count", "ci", "pointer", "cc", "uc", "cf", "ch", "xc", "character", "v", "cl", "code", "n", "cu", "ce", "id", "a", "cm", "col", "fc", "cy"]}}
{"id1": "9996334", "id2": "2807585", "code1": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"generateToken": ["generationSecret", "generATEKey", " GenerateKey", " GenerateTokens", " GenerATEToken", "generationKey", " GenerATEKey", "generatedToken", "generatedSecret", " GenerATETokens", "generatedTokens", "generateSecret", " GenerateToken", "generatedKey", " GenerateSecret", " GenerATESecret", "generationToken", "generateKey", "generateTokens", "generATESecret", "generationTokens", "generATEToken", "generATETokens"], "code": ["Code", "data", "tag", "name", "coded", "body", "info", "state", "str", "codes", "hex", "cache", "text", "output", "content", "mac", "password", "key", "address", "buffer", "source", "value", "ode", "hash", "next", "cod", "config", "c", "id", "script", "prefix", "message", "token", "header", "input", "string"], "md": ["meta", "df", "bd", "f", "mag", "mg", "cd", "rm", "wd", "ds", "grad", "dd", "m", "ma", " MD", "mt", "ind", "dig", "kg", "mb", "mac", "cmd", "dm", "sm", "d", "MD", "gd", "mo", "mod", "hash", "amd", "mp", "metadata", "mm", "pm", "mu", "sha", "po", "cm", "mc", "ms", "pd", "mand", "od", "hd", "ad", "editor"], "bytes": ["bin", "values", "data", "blocks", "s", "bs", "groups", "boot", "body", "ips", "outs", "units", "codes", "binary", "words", "les", "parts", "b", "output", "bits", "files", "zip", "bles", "lines", "address", "strings", "pieces", "tes", "objects", "classes", "vs", "bps", "seconds", "es", "Bytes", "string", "buf"]}}
{"id1": "9954926", "id2": "932225", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 0, "substitutes": {"simulate": ["imulation", "simulation", "animulator", "animure", "animulate", "Simure", "animulation", "imulator", "imure", "imulate", "simulator", "Simulator", "simure", "Simulation", "Simulate"], "out": ["lock", "data", "name", "pool", "down", "outs", "w", "err", "flow", "o", "flush", "buffer", "cli", "exit", "null", "io", "co", "resource", "report", "exp", "tmp", "point", "error", "session", "table", "sys", "log", "page", "cache", "conn", "output", "key", "client", "outer", "parent", "group", "up", "word", "result", "info", "state", "dump", "plain", "copy", "part", "writer", "line", "pre", "temp", "external", "lib", "store", "raw", "prefix", "con", "Out", "obj", "full", "bin", "ex", "gen", "base", "user", "again", "OUT", "comment", "list", "db", "object", "view", "server", "post", "net", "in", "window", "string", "write", "now"], "file": ["full", "connection", "le", "f", "data", "name", "File", "socket", "handler", "book", "stream", "fe", "log", "base", "rule", "page", "cache", "b", "loader", "output", "files", "l", "line", "collection", "address", "buffer", "source", "feed", "ile", "port", "path", "filename", "url", "unit", "pe", "in", "message", "FILE", "resource", "fp", "queue", "report"], "obtainUserReputationRequest": ["obtainUserRepurationQuery", "obtainUserReputedResponse", "obtainUserReputationInput", "obtainUserReputablerequest", "obtainUserReputionRequest", "obtainUserRepentionResponse", "obtainUserRelentionrequest", "obtainUserReputionResponse", "obtainUserReputableRequest", "obtainUserRelutationGrant", "obtainUserComputationEntry", "obtainUserRelutationRequest", "obtainUserComputeInput", "obtainUserReputedRequest", "obtainUserReputableResponse", "obtainUserReputationrequest", "obtainUserReputationGrant", "obtainUserReputeRequest", "obtainUserAnnutationQuery", "obtainUserAnnigrationResponse", "obtainUserReputeEntry", "obtainUserComputationInfo", "obtainUserReputedrequest", "obtainUserRelentionResponse", "obtainUserRelutationResponse", "obtainUserReputeQuery", "obtainUserAnnigrationRequest", "obtainUserRepositoryrequest", "obtainUserRepigrationrequest", "obtainUserReputionGrant", "obtainUserRepigrationResponse", "obtainUserRepulationResponse", "obtainUserRepurationGrant", "obtainUserReputedGrant", "obtainUserRepulationInput", "obtainUserComputerequest", "obtainUserComputeEntry", "obtainUserComputationInput", "obtainUserReputerequest", "obtainUserRepositoryRequest", "obtainUserRepigrationRequest", "obtainUserAnnutationResponse", "obtainUserComputeInfo", "obtainUserAnnigrationGrant", "obtainUserComputeRequest", "obtainUserRepurationRequest", "obtainUserRepurityInput", "obtainUserRepulationEntry", "obtainUserRepigrationGrant", "obtainUserAnnutationRequest", "obtainUserReputeResponse", "obtainUserRelentionRequest", "obtainUserRepentionGrant", "obtainUserRelutationrequest", "obtainUserComputationRequest", "obtainUserReputeInfo", "obtainUserComputationrequest", "obtainUserRepurityRequest", "obtainUserRepentionrequest", "obtainUserComputeResponse", "obtainUserReputationQuery", "obtainUserRepositoryInfo", "obtainUserAnnutationGrant", "obtainUserRepurityEntry", "obtainUserReputeGrant", "obtainUserRepigrationQuery", "obtainUserReputeInput", "obtainUserRepigrationInfo", "obtainUserRepositoryResponse", "obtainUserReputationInfo", "obtainUserComputationResponse", "obtainUserRelentionGrant", "obtainUserRepulationRequest", "obtainUserRepurationResponse", "obtainUserRepentionRequest", "obtainUserReputionrequest", "obtainUserReputationEntry", "obtainUserRepurityResponse", "obtainUserAnnigrationQuery"], "obtainUserReputationResponse": ["obtainUserExputationRequest", "obtainUserRepositoryRequest", "obtainUserExpositoryResp", "obtainUserExputationResponse", "obtainUserRepositoryResp", "obtainUserRepurationRequest", "obtainUserExpositoryResponse", "obtainUserRepositoryResponse", "obtainUserReputationResp", "obtainUserReputeResponse", "obtainUserRepurationResponse", "obtainUserExputationResp", "obtainUserRepurationResp", "obtainUserReputeRequest", "obtainUserExpositoryRequest", "obtainUserReputeResp"], "rateUserRequest": ["rateMachineVersion", "rateFileCommand", "ratedUserFunction", " rateUserUser", "ratedFileCommand", "rateUForce", "rateLineCustomer", "RateFileQUEST", "rateUsageForce", "ratePostRequest", "rateHumanRequest", " rateUserQuery", "ratedUserrequest", "rateServiceCommand", "rateUSERRequest", "rateUserResult", "ratedFileQuery", " rateuserrequest", "rateServiceFunction", "RateFileRequest", "ratedUserRequest", "rateCustomerQUEST", "rateUsageRequest", "featureUserResult", "RateUserRequest", "rateUrequest", "rateUserQUEST", "rateCustomerForce", "rateUsageReturn", "issueCustomerQUEST", "ratedUsageQUEST", "rateUResponse", "rateApplicationUser", "rateApplicationRequest", "gradeLineError", "rateUserReturn", "rateLinerequest", "rateFileVersion", " rateuserQUEST", "rateUSERQUEST", "rateUsReturn", "rateUQuery", "rateUsageGrant", "rateServiceRequest", "rateHumanrequest", "rateServiceQuery", "ratePostQUEST", "ratedUsageQuery", "rateUError", "ratedFileRequest", "gradeLineCustomer", "rateWordQuery", "ratedUserForce", "rateUserError", "featureMachineRequest", "featureUserRequest", "rateClientrequest", "rateUserCommand", "gradeLineRequest", "rateUsageQUEST", "issueUserRequest", "rateMachineResult", "issueUserReturn", "ratedUserQuery", "rateLineQuery", "ratedUsagerequest", " rateApplicationUser", "issueCustomerRequest", "rateFileQUEST", "issueUserForce", "gradeUserError", "rateFileFunction", "RateFilerequest", "RateUserResponse", "rateuserrequest", "rateURequest", "rateFileRequest", "rateLineGrant", " rateuserRequest", "ratedUserQUEST", " rateApplicationRequest", " rateUserQUEST", "rateHumanVersion", "featureMachinerequest", " rateApplicationQuery", "featureMachineVersion", "RateUserrequest", "gradeUserrequest", " rateClientrequest", "rateMachineRequest", "ratePostrequest", "rateUserVersion", "rateUSERForce", "rateUCommand", "rateCustomerReturn", "rateUCustomer", "rateLineResponse", "rateFileResponse", "issueCustomerReturn", "rateUsagerequest", " rateUserGrant", "RateFileResponse", "rateUsRequest", "rateWordrequest", " rateClientRequest", "RateUserQUEST", "rateLineError", "rateUQUEST", "rateWordError", "rateCustomerRequest", "rateUFunction", "ratePostResponse", "rateuserResponse", "ratedUserCommand", "rateFileUser", "ratedUsageRequest", "rateLineRequest", "rateUserUser", "rateClientGrant", "rateLineQUEST", "rateHumanResult", "rateFilerequest", "gradeUserRequest", "rateUserQuery", " rateClientGrant", "featureMachineResult", "rateuserRequest", "rateUserCustomer", "gradeLinerequest", "rateUsQUEST", " rateuserResponse", "issueUserQUEST", "rateUserFunction", "rateUSERrequest", "ratedFileFunction", "rateFileQuery", " rateUserrequest", "rateClientRequest", "rateApplicationResponse", "rateUserForce", "ratedUsageForce", "rateMachinerequest", "featureUserrequest", "rateUserGrant", "gradeUserCustomer", "rateFileResult", "rateUsageUser", "issueCustomerForce", "rateUsageResponse", "rateUserrequest", "rateApplicationQuery", "rateUsForce", "rateUsageQuery", "rateWordCustomer", "featureUserVersion", " rateApplicationResponse", "rateWordRequest", "rateuserQUEST"], "rateUserResponse": ["rateClientStatus", " rateUresponse", " rateApplicationResp", " rateUReply", "rateClientResponse", " rateUResponse", "RateUserCustomer", "rateUserResult", "RateUserRequest", "rateCustomResponse", "rateUResponse", "rateUserReference", "rateUserStatus", " rateUserResp", "rateuserresponse", "rateUsersResource", "rateCustomResp", "rateClientResp", "rateUReply", "RateTimeStatus", "RateUserStatus", "rateUsersResult", " rateApplicationReference", "rateUsersRequest", "rateFileResp", "rateTimeCustomer", "rateUserResp", "rateUserResource", "rateClientCustomer", "rateApplicationResp", "RateUserResponse", "rateCustomerResp", "RateTimeResp", " rateUResp", "rateUserresponse", "rateCustomCustomer", "rateApplicationReference", " rateUserStatus", "rateuserStatus", "rateCustomerData", "rateUresponse", "rateTimeStatus", "rateCustomStatus", " rateApplicationData", "rateUsersStatus", "rateFileResponse", " rateFileResult", "rateuserReference", " rateUserReference", "rateUResp", "rateApplicationData", "rateFileStatus", "rateCustomerRequest", "rateuserResponse", "rateTimeResp", " rateFileResponse", "rateFileReply", "rateTimeResponse", "RateTimeCustomer", "rateuserResp", "RateTimeResponse", "rateUserCustomer", "rateCustomerResource", "rateuserReply", "rateCustomerReference", " rateUserResult", "RateUserResource", "rateFileresponse", " rateFileStatus", "rateuserResult", "rateApplicationResponse", " rateUserReply", " rateUserresponse", "rateUsersResponse", "rateuserData", "rateUsersResp", "rateUserReply", "rateCustomerResponse", "rateFileResult", " rateFileResp", "RateUserResp", "rateUserData", " rateApplicationResponse", " rateUserData"], "fis": ["fiss", " fris", "bIs", "sfIs", "sfris", "sfiss", "FIs", "fIs", " fIs", "Fis", "bris", "Fiss", "bis", " fiss", "fris", "Fris", "sfis", "biss"], "br": ["reader", "Br", "ob", "arr", "bs", "body", "str", "bed", " fr", "bl", " bio", "pr", "b", "bridge", "cr", "r", "bp", "err", "fr", "bc", "dr", "rb", "buffer", "BR", "sp", "hr", "brush", "ch", "sw", "lr", "browser", "io", "wr", "gr", "bro", "tr", "result", "res", "fin", "ref", "ber", "ler", " tr", "Reader", "buf"], "call": ["msg", "f", "data", "doc", "name", "loc", "phone", "called", "type", "play", "sc", "ack", "body", "create", "info", "ck", "load", "str", "xml", "check", "roll", "text", "output", "user", "throw", "callback", "query", "line", "work", "e", "cell", "flow", "address", "buffer", "comment", "fax", "Call", "cat", "request", "response", "Line", "url", "cod", "cl", "code", "calling", "cu", "c", "ell", "message", "co", "result", "input", "contact", "charge", "voice", "claim", "push", "string", "use", "invoke"]}}
{"id1": "20190303", "id2": "13565787", "code1": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "code2": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "label": 0, "substitutes": {"test01_ok_failed_500_no_logo": ["test01_ok_failed_500_NO__log", "test01_ok_failed_500_NO_blog", "test01_ok_failed_500_no1Log", "test01_ok_failed_500_NO__blog", "test01_ok_failed_500_no__ban", "test01_ok_failed_500_no_Log", "test01_ok_failed_500_no1blog", "test01_ok_failed_500_no_ban", "test01_ok_failed_500_NO_ban", "test01_ok_failed_500_no1ban", "test01_ok_failed_500_NO_log", "test01_ok_failed_500_no__blog", "test01_ok_failed_500_NO__Log", "test01_ok_failed_500_no_log", "test01_ok_failed_500_NO_Log", "test01_ok_failed_500_no_blog", "test01_ok_failed_500_NO__ban", "test01_ok_failed_500_no__log", "test01_ok_failed_500_no__Log", "test01_ok_failed_500_no1log"], "client": ["connection", "https", "app", "manager", "force", "self", "socket", "channel", "pool", "session", "handler", "method", "secure", "Client", "p", "web", "per", "class", "plugin", "ssl", "conn", "cache", "instance", "console", "this", "proxy", "call", "cli", "service", "child", "api", "port", "request", "connect", "url", "config", "server", "uri", "http", "c", "php", "tc", "resource", "con", "host", "wait"], "post": ["f", "self", "head", "method", "to", "after", "load", "set", "copy", "success", "zip", "pre", "posts", "patch", "test", "call", "proxy", "entry", "build", "port", "api", "submit", "request", "process", "Post", "POST", "object", "feed", "next", "builder", "project", "code", "server", "pass", "http", "php", "upload", "pod", "end", "apply"], "response": ["connection", "data", "error", "pool", "respond", "method", "body", "application", "Response", "status", "model", "page", "successful", "output", "throw", "success", "reply", "respons", "service", "feed", "api", "request", "object", "next", "document", "view", "server", "http", "index", "message", "result", "resource", "report", "onse", "json", "resp", "site"]}}
{"id1": "8064604", "id2": "14733078", "code1": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 1, "substitutes": {"init": ["connection", "open", "it", "Init", "activate", "create", "boot", "install", "info", "load", "setup", "launch", "set", "client", "construct", "reset", "cli", "build", "exec", "update", "config", "transfer", "initial", "sleep", "start"], "mgr": ["mr", "pigr", "prr", "marr", "Mr", "amrr", "ctr", "amigr", "Marr", "Mgr", "amgr", "mtr", "carr", " mbr", "mrr", "ambr", " marr", "cr", "cgr", " mrr", " migr", " mtr", "mbr", "migr", "pbr", "pgr", " mr", "Mtr"], "cfg": ["Msg", "bm", " ssh", "cb", "Conf", " configuration", " cache", "g", "MC", "gen", "cache", " img", "conf", " conf", " cf", "password", "map", "db", "cf", "chain", "gate", " config", "config", "file", "mem", "mc", "gp", "Hash", " chain"], "sock": ["Sock", "socks", "gesocket", "opensocket", "socket", "Socket", " socket", "Sib", "opensib", "sink", "gesink", "opensock", "Sink", "gesock", "sib", " socks", " sink", "Socks", "opensocks", "gesocks", " sib"], "_cman": ["_gman", "_mcfg", " _mcmn", "_cmn", "_mcmn", "_cfg", "_mgr", "_ggr", " _cmn", "_mfg", "_mcgr", "_gmn", "_mcman", " _mcman", "_mman", " _mcfg", " _mcgr", " _cfg", "_cgr", " _cgr", "_gfg", "_mmn"], "_sock": ["_nsrc", "_svc", "_jsocks", "_nsocks", "_docks", "_opensocket", "_bort", "_dock", " _socks", "_unsock", "_Socket", "_serve", "longnsockets", "longsock", "_Sock", "_csock", "_dort", "_openserve", "_unsocks", "_jsock", "_bocks", "_sockets", "_sdk", "_opensvc", "_Socks", "_asock", "_socks", "_opensort", "_Serve", "_bocket", "_jsdk", "_src", "_bock", "_csrc", "_nsockets", " _svc", "longsrc", "_sort", "_asocks", "longnsrc", "longnsocks", " _serve", "longsocks", "_csockets", "_asrc", "_csocks", "_docket", "longnsock", "_Sdk", "_opensocks", "_nsock", "_asockets", "_unsdk", "_unsocket", "_Svc", "_opensock", "_jsocket", "longsockets", "_socket"], "i": ["x", "ji", "f", "y", "si", "it", "ti", "ri", "q", "my", "s", "slice", "m", "j", "info", "p", "pi", "k", "field", "ie", "ix", "is", "hi", "bi", "I", "u", "b", "inner", "multi", "di", "qi", "l", "r", "e", "o", "ini", "d", "ci", "value", "h", "xi", "v", "mi", "ui", "oi", "li", "uri", "n", "ii", "io", "in", "ni", "id", "index", "iu", "chi", "gi", "ai", "phi", "ip"], "key": ["lock", "data", "name", "type", "ck", "field", "str", "ie", "shift", "kh", "section", "source", "ask", "ki", "sign", "number", "wire", "search", "pick", "length", "fee", "cy", "point", "string", "label", "rule", "op", "query", "mix", "secret", "kid", "row", "value", "pid", "order", "code", "id", "json", "Key", "check", "qi", "root", "patch", "temp", "phrase", "nice", "sum", "trust", "prefix", "ip", "connection", "char", "q", "change", "pair", "k", "base", "match", "KEY", "text", "mac", "entry", "cert", "fix", "index", "token", "link", "ace"], "_sout": ["_Sin", "_sbOut", "_sein", "_seio", "_sio", "_Sout", "_sbout", "_sbio", "_seout", "_sOut", "_seOut", "_sin", "_sbin", "_Sio", "_SOut"], "_sinp": ["_inp", "_sinpc", "_sinb", "_siner", "_diser", "_dispc", "_srpc", "_inb", "_disp", "_srp", "_disb", "_srb", "_inpc", "_srer", "_iner"], "seed": ["finger", "data", "name", "scale", "char", "digit", "slice", "dd", "theme", "sudo", "sample", "shift", "kh", "zip", "root", "shape", "password", "random", "parser", "address", "ruby", "secret", "test", "row", "kid", "source", "feed", "cookie", "driver", "serial", "pattern", "prime", "sum", "delay", "shadow", "id", "folder", "index", "black", "eed", "sha", "token", "input", "host", "pad", "grain", "sql", "pick", "sleep", "slave", "json", "string", "username"], "rand": ["rh", "reg", "grad", "range", "dev", "NG", "min", "gen", "bot", "rc", "ind", "sample", "roll", "user", "win", "cr", "r", "max", "gram", "dist", "random", "dr", "go", "rr", "Rand", "chain", "der", " random", "next", "round", "bird", "ng", "id", "rar", "nd", "pick", "who", "draw", "re", "start"], "hex": ["lock", "iter", "digit", "rex", "div", "letter", "loop", "shift", "kh", "sex", "pex", "cookie", "wh", "chain", "sha", "lit", "pad", "exp", "length", "rh", "alph", "ph", "zip", "mix", "secret", "row", "pack", "closure", "cross", "pattern", "code", "oct", "id", "json", "x", "loc", "tri", "scale", "quant", "check", "temp", "cmp", "serial", "form", "sum", "raw", "transform", "auth", "cube", "ip", "bin", "char", "batch", "buff", "hess", "ex", "box", "text", "num", "ch", "cf", "ticket", "view", "shadow", "index", "token", "alpha", "string"], "pass": ["lock", "login", "ride", "session", "oss", "press", "handle", "allow", "task", "worker", "gen", "proc", "Pass", "mail", "Password", "line", "password", "secret", "test", "step", "parse", "run", "service", "feed", "process", "PASS", "path", "cross", "ass", "sign", "code", "oct", "post", "read", "route", "fix", "ress", "prefix", "flash", "rss", "fail", "ss", "skip", "push", "auth", "report", "access", "strip", "act"], "md5": [" md\t", "sha512", "md2", "sha5", "MD7", "md85", " MD\t", "mand5", "mandody", "mand3", " md3", " md4", "md\t", "sha4", " md\n", "sha3", "MD4", "MD5", " md512", "ma5", "MD85", "sha2", "MD512", "md512", "mand2", "MD\n", " MD\n", "ma4", " md2", "ma85", "MD2", " mdody", "md\n", "md4", "ma2", "mdody", "md7", " md7", " md85", "md3", "sha7", "MDody", "MD\t", "MD3"], "hash": ["rh", "lock", "alt", "ha", "hed", "version", "base", "dig", "html", "cache", "text", "kh", "her", "mac", "password", "ruby", "secret", "block", "build", "db", "h", "url", "sum", "code", "id", "sha", "header", "ash", "host", "auth", "addr", "string"], "banner": ["binorer", "warnnel", "banker", "binner", "banler", "ironning", "bannet", "annnet", "banning", "banorer", "Bannel", "warnler", "warnker", "blueker", "ironnet", "plannet", "Bann", "banners", "Banner", "planners", "blueler", "Banorer", "Banning", "bann", "binn", "binning", "bluenel", "planner", "bluener", "annners", "plann", "annning", "Banler", "annner", "bannel", "warnner", "ironner", "planning", "Banker", "planorer", "ironners"], "txt": ["cb", "ext", "elt", "data", "tin", "git", "ff", "email", "wd", "gold", "pdf", "tty", "info", "buff", "gz", "str", "xml", "bot", "fb", "text", "bytes", "img", "zip", "lines", "parser", "utt", "xt", "test", "xxx", "vt", "Text", "js", "struct", "notes", "pty", "hea", "config", "rpm", "thin", "details", "flat", "file", "rx", "np", "rss", "kt", "TEXT", "diff", "qt", "htm", "json", "tx", "obj", " text", "buf", "tmp"], "sname": ["nsnamed", "vesnames", "snames", "asnames", "sdata", "nsnames", " sName", "esname", " snamed", "vesnamed", "asnamed", "snamed", "sName", "esnames", "asname", " snames", "esName", "esnamed", "vesName", "nsdata", " sdata", "asdata", "vesname", "nsname"], "spass": ["espad", "Spass", "Spasses", "aspash", "aspasses", "SPasses", "slass", "splash", "espash", "SPass", "sloss", "spill", "spasses", "SPill", "aspass", "aspad", "espasses", "Sposs", "Spill", "slasses", "sposs", "spash", "splad", "splass", "splasses", "spad", "SPoss", "espass", "slill"], "sseed": [" spassword", "ssslave", "dentry", "submitseed", "dpassword", "gsgrain", "pssecret", "symgrain", "submittoken", "symseed", "sslave", "dtoken", "Skey", "psslave", "pslave", "Sgrain", "sssecret", "symkey", "skey", "sgrain", "sroot", "spassword", "gsseed", "submitpassword", "symeed", "gseed", "psseed", "Sseed", "psroot", "Seed", "stoken", "ssseed", "dseed", "ssecret", " stoken", "gskey", "psecret", "sentry", "proot", "ssroot", "submitentry", "pseed", " sentry"], "items": ["ids", "pages", "values", "data", "images", "rows", "cats", "articles", "groups", "phones", "results", "events", "ips", "xml", "units", "cells", "models", "abs", "files", "bits", "bytes", "parts", "members", "apps", "ops", "flows", "posts", "lines", "orders", "pins", "pieces", "rooms", "owners", "js", "loads", "objects", "qs", "names", "lists", "styles", "boxes", "keys", "photos", "ants", "params", "locks", "links", "Items", "projects", "item", "opens", "plugins", "ends"]}}
{"id1": "2168610", "id2": "11704429", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public void run() {\n        RandomAccessFile file = null;\n        InputStream stream = null;\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=\" + downloaded + \"-\");\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                error();\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                error();\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            }\n            file = new RandomAccessFile(destination, \"rw\");\n            file.seek(downloaded);\n            stream = connection.getInputStream();\n            while (status == DOWNLOADING) {\n                byte buffer[];\n                if (size - downloaded > MAX_BUFFER_SIZE) {\n                    buffer = new byte[MAX_BUFFER_SIZE];\n                } else {\n                    buffer = new byte[size - downloaded];\n                }\n                int read = stream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                status = COMPLETE;\n                stateChanged();\n            }\n        } catch (Exception e) {\n            error();\n        } finally {\n            if (file != null) {\n                try {\n                    file.close();\n                } catch (Exception e) {\n                }\n            }\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"update": ["connection", "save", "lock", "open", "current", "family", "get", "version", "name", "where", "edit", "error", "complete", "database", "create", "put", "range", "handle", "change", "sync", "send", "state", "event", "timeout", "load", "grade", "set", "status", "add", "position", "future", "check", "text", "instance", "ite", "bug", "patch", "updated", "address", "pull", "Update", "build", "run", "value", "inc", "response", "fill", "delete", "config", "width", "view", "date", "unit", "http", "up", "id", "index", "message", "resource", "diff", "result", "replace", "UPDATE", "draw", "insert", "write", "use", "end", "apply"], "o": ["office", "connection", "f", "oa", "oe", "oo", "m", "p", "k", "one", "os", "oid", "conn", "ono", "online", " O", " object", "e", "t", "or", "mo", "object", "ao", "ion", "oi", "n", "c", "co", "po", "bo", "ou", "O", "od", "none", "so", "obj", "ob"], "contact": ["connection", "office", "f", "point", "phone", "email", "campaign", "sync", "info", "event", "lead", "control", "match", "lc", "model", "check", "contract", "front", "content", "concept", "ace", "work", "collection", "cell", "account", "client", "address", "product", "call", "entry", "cmp", "fax", "cc", "connect", "feed", "project", "object", "choice", "form", "character", "config", "relation", "date", "conference", "cart", "co", " Contact", "coll", "result", "charge", "company", "report", "communication", "Contact", "act"], "pst": [" put", "psst", "put", "prsp", "pct", "spst", "prsta", "lpsts", "prST", "Pcr", "opst", "wpcr", "Post", "pcr", "preut", "prsl", "psc", " pct", "psta", "opsts", " pcr", "ptd", "wptd", " pST", "Pdd", "Psts", "pstd", "spct", " ptd", "wpst", "prsc", "lpst", " psc", "lptd", "prst", "lpST", "pssts", "psp", " psta", " psl", "PST", " psp", "Pct", "Psc", " pdd", "opste", "lpcr", "lpsta", "prct", "prste", "pssl", " pste", "Pst", "sput", "prdd", "pST", "epst", "epcr", " psts", " post", "epsts", "wpsh", "prect", "pdd", "prest", "prsts", "preste", "pste", "lpsh", "Psp", "Pste", "epST", "psts", "spste", "prcr", " psh", "post", "psl", "psh", "prtd", "opct", "prost"]}}
{"id1": "6418781", "id2": "1421557", "code1": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String[] names = client.listNames();\n            for (String name : names) {\n                System.out.println(\"Name = \" + name);\n            }\n            FTPFile[] ftpFiles = client.listFiles();\n            for (FTPFile ftpFile : ftpFiles) {\n                if (ftpFile.getType() == FTPFile.FILE_TYPE) {\n                    System.out.println(\"FTPFile: \" + ftpFile.getName() + \"; \" + FileUtils.byteCountToDisplaySize(ftpFile.getSize()));\n                }\n            }\n            client.logout();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"client": ["web", "class", "ssl", "and", "console", "cli", "close", "url", "c", "ce", "co", "resource", "queue", "out", "host", "end", "open", "hard", "socket", "session", "handler", "secure", "pc", "conn", "cloud", "cache", "contract", "front", "call", "builder", "project", "parent", "cart", "company", "app", "util", "remote", "command", "Client", "p", "clean", "cell", "patch", "ci", "image", "connect", "api", "config", "http", "google", "contact", "con", "cp", "grid", "connection", "manager", "force", "base", "plugin", "i", "request", "cl", "quit", "server", "net", "file", "cm"], "names": ["ids", "data", "blocks", "nets", "versions", "groups", "services", "results", "ns", "paces", "nam", "works", "people", "items", "words", "ans", "devices", "members", "files", "apps", "tools", "letters", "strings", "list", "Names", "objects", "terms", "ames", "keys", "modules", "users", "headers", "named", "types", "resources"], "name": ["x", "connection", "ame", "f", "data", "family", "_", "type", "info", "one", "nam", "str", "base", "part", "user", "size", "am", "l", "e", "member", "key", "common", "api", "path", "parent", "filename", "v", "Name", "n", "pass", "an", "file", "id", "a", "word", "action", "out", "named", "company", "string", "NAME"], "ftpFiles": ["fttpfiles", "fdtpfiles", "fdpfiles", "ctfFiles", "ftpKeys", "fdtpFiles", "ftfiles", "ftartFile", "ftpfiles", "fttpFiles", "ftpointiles", "fttpKeys", "ftpointFiles", "ftpointFile", "ctpFile", "ftartFiles", "ftnTokens", "ftnFiles", "ctfFile", "fttpFile", "fdtpFile", "fdpFile", "fttpTokens", "ftfFile", "ftpiles", "ftartfiles", "ftnfiles", "ftpTokens", "ctpKeys", "ctpiles", "fdpFiles", "ctpFiles", "ftfFiles", "fdtpTokens", "ftnFile", "ftpointKeys", "ctfiles", "ftartTokens", "fdpTokens", "fttpiles", "ctfKeys", "ftfKeys"], "ftpFile": ["ftpBlock", " ftlFile", "ftapifile", "lflEntry", "ftpfile", "ftfpFile", "ftPFile", "flFiles", "ftfDir", "ftlFiles", "lflFiles", " ftpUrl", "lfapfile", " ftlBlock", "lflFile", "lflPath", "ftpUrl", "fpDirectory", "ftfEntry", "lfpDir", "lfpEntry", "ftpEntry", "ftpDir", "ftapFiles", "ftapiDir", "ftlUrl", "ftfpBlock", "ftpaFile", " ftlUrl", "ftpaUrl", " ftpBlock", "ftpaEntry", "ftapiFiles", "ftpDirectory", "lfapFile", "ftpaFiles", "ftpaDirectory", "ftpPath", "flFile", "ftfFile", "ftPFiles", "lfpFiles", "ftapFile", "ftfDirectory", "lfapFiles", "ftapfile", "ftlBlock", "lfpPath", "ftpaBlock", "ftffile", "ftlFile", "fpFiles", "ftfpFiles", " ftlFiles", "ftfFiles", "ftlEntry", "ftfPath", "ftlPath", "ftfpUrl", "ftlDirectory", "lfapDir", "flEntry", "lfpFile", "fpEntry", "ftPPath", "ftapiFile", "ftapDir", "lfpfile", "fpFile", "ftPEntry", "flDirectory"]}}
{"id1": "17901739", "id2": "22442270", "code1": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"setMembers": ["setMember", "parseMember", "setJoin", "parseMethods", "SetMethods", " setMember", "SetMember", " setMethods", " setJoin", "SetJoin", "parseMembers", "parseJoin", "SetMembers", "setMethods"], "url": ["connection", "sl", "data", "org", "channel", "socket", "email", "base", "ssl", "blog", "user", "loader", "article", "l", "client", "address", "Url", "URL", "source", "service", "entry", "feed", "image", "hub", "path", "uri", "server", "io", "http", "file", "resource", "www", "queue", "location", "string"], "reader": ["iter", "er", "f", "handler", "table", "worker", "stream", "per", "rc", "keeper", "loader", "inner", "r", "writer", "l", "err", "rer", "parser", "e", "rr", "row", "i", "ner", "entry", "feed", "builder", "driver", "reading", "read", "server", "bird", "iterator", "io", "http", "file", "rar", "resource", "input", "report", "ler", "Reader", "editor"], "buffer": ["iter", "sequence", "data", "background", "str", "received", "binary", "b", "flush", "FFER", "source", "transfer", "uri", "null", "message", "queue", "header", "resource", "length", "fb", "border", "page", "cache", "output", "bytes", "address", "rb", "row", "parse", "template", "game", "document", "read", "code", "flash", "result", "texture", "uffer", "seed", "info", "counter", "expression", "bb", "loader", "line", "writer", "fr", "paste", "image", "feed", "phrase", "stage", "pause", "http", "wave", "buf", "bin", "batch", "sync", "layer", "buff", "Buffer", "button", "base", "video", "text", "password", "comment", "padding", "bar", "player", "request", "response", "filename", "server", "file", "input", "window", "string"], "pattern": ["df", "app", "handler", "slice", "command", "type", "array", "filter", "layer", "event", "str", "counter", "letter", "expression", "log", "rule", "match", "model", "format", " Pattern", "cache", "part", "position", "password", "parser", "patch", "Pattern", "condition", "atter", "image", "template", "feed", "child", "builder", "path", "object", "serial", "system", "regular", "config", "number", "group", "document", "file", "function", "cher", "script", "print", "re", "string", "graph"], "matcher": ["matter", "matach", "harler", "mither", "motter", "patchers", "patner", "motpattern", "mirter", "matchches", "captpattern", "matatter", "matchpattern", "attger", "matchter", "harpattern", "attcher", "compner", "matatcher", "lincher", "manher", "statcher", "mirher", " matchers", "matchatcher", "matched", "ratacher", "matler", "matching", "statner", " matpattern", " matacher", "linter", " matner", "Matacher", "linatter", " matler", "matches", "attacher", "Matter", "matchcher", "statler", "reches", "patatcher", "ratcher", "compter", "Matner", "mitchers", "patter", "reched", "mitch", "mitcher", "manner", "recher", "matacher", "matchach", "captcher", "patch", "attching", " mather", "matchler", " match", "mancher", "Mather", " matter", "Matching", "Matcher", "matchers", "patpattern", "captter", "compcher", "reach", "statpattern", "Matpattern", "matger", "harner", "matchher", "matchner", "match", "matchched", "compatcher", "linpattern", "harcher", "compach", "mirpattern", "patcher", "matchacher", "pather", "matner", "manacher", " matatter", "ratching", "compches", "compched", "captatter", "motcher", "mircher", "matpattern", "mather", "Matger", "motner", "ratger"], "erg": ["ag", "region", "arc", "er", "sg", "uster", "orters", "git", "org", "ander", "eri", "ung", "oga", "berg", "eur", "anger", "worker", "igor", "ero", "ERG", "irc", "rator", "era", "ard", "ger", "gas", "feat", "yang", "alg", "clus", "aga", "magic", "agog", "gae", "east", "gra", "orter", "usa", "dr", "og", "urg", "ig", "jing", "gd", "justice", "ers", "game", "rg", "der", "eng", "agg", "eric", "ord", "ocr", "ga", "gr", "gg", "gy", "porter", "aug", "rog", "forge", "ider", "progress", "gru", "ager"], "start": ["current", "name", "End", "stop", "type", "started", "cost", "grade", "art", "find", "ie", "shift", "mid", "work", "max", "off", "step", "source", "fill", "close", "sol", "stat", "Start", "pick", "pad", "end", "fit", "open", "it", "something", "boot", "se", "load", "ind", "position", "ish", "inner", "plus", "address", "count", "init", "read", "id", "last", "offset", "scale", "starting", "grad", "first", "seed", "pend", "info", "space", "state", "send", "sort", "set", "add", "part", "check", "old", "show", "style", "run", "sum", "pos", "ad", "rest", "bin", "get", "head", "st", "min", "base", "match", "need", "size", "like", "speed", "unit", "in", "middle", "index", "diff", "none", "begin"], "von": ["bin", "nn", "ver", "su", "tin", "john", "fen", "endon", "aven", "jan", "byn", "non", "won", "dn", "kn", "bn", "hn", "uber", "vin", "feat", "vu", "tun", "fun", "di", "fat", "anon", "jen", "don", "evin", "lon", "onna", "fn", "vid", "zon", "vor", "lu", "una", "hon", "bon", "mon", "han", "wen", "endor", "oni", "andon", "len", "olson", "eni", "lin", "flo", "fin", "ou", "ln", "mun", "melon", "ten", "tu"], "bis": ["offs", "bett", "cos", "bat", "bes", "outs", "vin", "is", "ls", "bi", "bits", "val", "phis", "cedes", "bas", "uno", "fb", "isi", "oss", "bs", "boot", "ori", "os", "lins", "obs", "vid", "abi", "bid", "nas", "ois", "ui", "li", "uss", "des", "len", "sis", "los", "vals", "BUS", "udi", "bos", "cin", "idis", "bb", "pins", "vs", "oni", "zi", "ris", "ni", "pos", "prefix", "oris", "ours", "eni", "us", "onis", "bin", "isin", "su", "ri", "buff", "pi", "base", "bian", "fat", "di", "lus", "bles", "bus", "nexus", "bps", "lin", "ios", "cus"], "m_strComponents": ["m_arrCommonents", "m_strCommales", "m_strComponentales", "m_strReponents", "m_intReponents", "m_strComponent", "m_strRepenses", "m_strCommorts", "m_intReports", "m_intCompales", "m_arrCompenses", "m_strCompenses", "m_strComports", "m_strComponentonents", "m_intCompenses", "m_arrComponent", "m_strExpenses", "m_arrCommenses", "m_strReports", "m_strRepales", "m_strCommenses", "m_strCommonents", "m_strExports", "m_intRepales", "m_arrCompales", "m_strExponents", "m_strCompales", "m_strComponentonent", "m_strExpales", "m_arrCommonent", "m_strExponent", "m_intRepenses", "m_intComponents", "m_strCommonent", "m_arrComponents", "m_strComponentenses", "m_arrCommales", "m_intComports"], "m_strPriorities": ["m_strPosifiers", "m_intPrefries", "m_strMonries", "m_StrPriorifiers", "m_strPriorifiers", "m_strPrioritions", "m_strPriorries", "m_intPriorities", "m_strPositions", "m_strPrefries", "m_strQualitions", "m_strQualities", "m_strQualifiers", "m_strActivitions", "m_StrPositions", "m_intPrioritives", "m_intPrefitions", "m_strPosity", "m_StrPriority", "m_StrPriorities", "m_intPrioritions", "m_strMonitions", "m_StrPrioritions", "m_StrPosities", "m_strActivitives", "m_strComparitions", "m_strActivries", "m_strMonities", "m_strPrefitions", "m_strMonitives", "m_strPosities", "m_strComparity", "m_strPriority", "m_intPrefitives", "m_strActivities", "m_strPrefities", "m_strQuality", "m_intPrefities", "m_intPriorries", "m_StrPosifiers", "m_StrPosity", "m_strComparifiers", "m_strPrefitives", "m_strPrioritives", "m_strComparities"]}}
{"id1": "4501356", "id2": "665420", "code1": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"calculateProfileDiffDigest": ["calculateProfilediffdigr", "calculateProfilediffdigHash", "calculateProfileDiffCodr", "calculateProfilediffdigests", "calculateProfileDiffdigHash", "calculateProfilediffdigest", "calculateProfileDiffdigests", "calculateProfileDiffDigests", "calculateProfileDiffdigr", "calculateProfilediffDigest", "calculateProfileDiffCodHash", "calculateProfileDiffDigr", "calculateProfileDiffMDHash", "calculateProfileDiffdigest", "calculateProfileDiffCodest", "calculateProfilediffDigHash", "calculateProfileDiffDigHash", "calculateProfileDiffMDr", "calculateProfileDiffCodests", "calculateProfileDiffMDests", "calculateProfilediffDigr", "calculateProfileDiffMDest", "calculateProfilediffDigests"], "profileDiff": ["familyInfo", "profDiff", "summaryInf", "messagediff", "summaryInfo", "profileEdit", "profileInfo", "profInfo", "familyEdit", "summaryEdit", "imageDie", "familyDiff", " profileDust", "profilediff", "styleInfo", " profilediff", " profileInfo", "messageDiff", "messageInfo", "settingsDelta", "pictureDiff", " profileDelta", "pictureInfo", " profileInf", " profileName", "imageDelta", "settingsDiff", "imageDiff", "profileDust", " profileDie", "messagePath", "settingsDie", "summaryDiff", " profileEdit", "familyInf", "profileDelta", "styleName", "profileInf", "settingsDust", "picturediff", "imageDust", "profilePath", "pictureName", "profPath", "styleDiff", "profdiff", "profileName", "stylediff", "profileDie", " profilePath"], "normaliseWhitespace": ["normaliseWitesSpace", "normaliseWhipspaces", "normaliseWhipsspace", "normaliseWhitespaced", "normaliseWhicksspace", "normaliseWhpacesspace", "normaliseWpacesspace", "normaliseWitesspace", "normaliseWhickspaces", "normaliseWhitesspace", "normaliseWhpacepace", "normaliseWhpacespaces", "normaliseWhpaceSpace", "normaliseWpacespaced", "normaliseWhickspaced", "normaliseWhickspace", "normaliseWhpacespace", "normaliseWhitesSpace", "normaliseWhipespace", "normaliseWhipespaced", "normaliseWitespaces", "normaliseWhpacepaces", "normaliseWhipspace", "normaliseWitespaced", "normaliseWpacesSpace", "normaliseWpacespace", "normaliseWpacespaces", "normaliseWhitespaces", "normaliseWhipesspace", "normaliseWhpacesSpace", "normaliseWhipsSpace", "normaliseWhipespaces", "normaliseWitespace", "normaliseWhpacespaced"], "md": ["msg", "meta", "df", "bd", "f", "mag", "mg", "cd", "rm", "sd", "wd", "ds", "mad", "dd", "m", "ma", " MD", "mt", "me", "dig", "b", "mb", "mac", "cmd", "dm", "d", "MD", "gd", "db", "hash", "amd", "mp", "metadata", "mm", "pm", "message", "sha", "bf", "diff", "mc", "pd", "mand", "hd", "od", "Cmd", "editor"]}}
{"id1": "886783", "id2": "14650352", "code1": "    private static void doGet(LNISoapServlet lni, String itemHandle, String packager, String output, String endpoint) throws java.rmi.RemoteException, ProtocolException, IOException, FileNotFoundException {\n        String itemURI = doLookup(lni, itemHandle, null);\n        URL url = LNIClientUtils.makeDAVURL(endpoint, itemURI, packager);\n        System.err.println(\"DEBUG: GET from URL: \" + url.toString());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setDoInput(true);\n        fixBasicAuth(url, conn);\n        conn.connect();\n        int status = conn.getResponseCode();\n        if (status < 200 || status >= 300) {\n            die(status, \"HTTP error, status=\" + String.valueOf(status) + \", message=\" + conn.getResponseMessage());\n        }\n        InputStream in = conn.getInputStream();\n        OutputStream out = new FileOutputStream(output);\n        copyStream(in, out);\n        in.close();\n        out.close();\n        System.err.println(\"DEBUG: Created local file \" + output);\n        System.err.println(\"RESULT: Status=\" + String.valueOf(conn.getResponseCode()) + \" \" + conn.getResponseMessage());\n    }\n", "code2": "    boolean checkIfUserExists(String username) throws IOException {\n        try {\n            URL url = new URL(WS_URL + \"/user/\" + URLEncoder.encode(username, \"UTF-8\") + \"/profile.xml\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.connect();\n            InputStream is = conn.getInputStream();\n            is.close();\n            return true;\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"doGet": ["doGET", " doPut", " doget", "doget", "Doget", "DoPut", "doPut", "DoGET", "toGet", "toPut", "toGET", "DoGet", "toget", " doGET"], "lni": ["rii", " lii", "rdi", "ioldi", "Ldi", "lti", "iolii", "Lti", "ldi", "rni", "Lii", "lii", "iolni", " lti", "rti", " ldi", "Lni", "iolti"], "itemHandle": ["pageHandle", "itemHand", "ItemHandle", " itemAddress", "ItemHandler", " itemHand", "itemsFile", "ItemHand", "pagehandle", "Itemhandle", "pageAddress", "itemsHandler", " itemHandler", "ItemAddress", " itemFile", "itemhandle", "itemsHandle", "pageURI", " itemhandle", "itemsHand", "ItemURI", "itemAddress", "itemHandler", "ItemFile", "itemFile"], "packager": ["installager", "installagers", "ackager", "Packagger", "ackatter", "Packatter", "packageager", "packagger", "paramager", "importaging", "packageatter", "Packager", "packatter", "packenger", "Packaging", "paramenger", "importagers", "ackagger", "ackaging", "paramaging", "importenger", "packageaging", "packageagger", "installenger", "installaging", "packagers", "importager", "packaging", "paramagers"], "output": ["office", "connection", "profile", "version", "ilo", "reference", "application", "web", "xml", "log", "control", "summary", "format", "model", "page", "online", "address", "console", "external", "buffer", "source", "image", "response", "path", "filename", "environment", "outer", "il", "config", "document", "null", "file", "module", "prefix", "message", "generated", "debug", "resource", "input", "queue", "target", "header", "written", "string", "write", "Output", "four"], "endpoint": ["restpoint", "endPoint", "endedend", "restend", " Endpoints", "Endpoint", " Endpoint", "Endend", "endpoints", " Endocol", "endpath", " endbase", " Endbase", " endpoints", "Endpath", " endocol", "endedpath", "Endpoints", "endocol", "endend", "Endocol", "endbase", "restPoint", "EndPoint", "endedPoint", "endedpoint", "restpath", "Endbase"], "ProtocolException": ["ProtocolBase", "ProtoException", "ProtocolFailure", "InterocolFailure", "ProtInterfaceException", "ProtoHandler", "InterocolHandler", "ProtportException", "ProtoFailure", "ProtocolHandler", "ProtInterfaceHandler", "InterportBase", "ProtInterfaceFailure", "ProtInterfaceBase", "ProtoBase", "InterocolException", "InterportException", "ProtportHandler", "InterportFailure", "InterocolBase", "InterportHandler", "ProtportFailure", "ProtportBase"], "IOException": [" IOEx", "IOError", "SecurityException", "SecurityError", "RemoteError", "IOEx", "SecurityEx", "RemoteEx", "RemoteException", " IOError"], "FileNotFoundException": ["FileIsAvailableExcept", "FileNotFoundExcept", "FileNotAvailableException", "FileNotfoundExcept", "FileIsAvailableError", "FileIsAvailableException", "FileNotAvailableError", "FileNotfoundError", "FileNotAvailableExcept", "FileIsFoundError", "FileNotFoundError", "FileNotfoundException", "FileIsFoundException", "FileIsFoundExcept"], "itemURI": ["containeruri", " itemRI", "objecturi", "ItemRI", "ItemURL", "containerRI", " itemUrl", "itemUrl", "objectURI", "containerURI", "itemURL", "itemRI", "itemuri", " itemuri", "Itemuri", "ItemURI", "objectURL", "objectUrl", " itemURL", "ItemUrl", "containerURL"], "url": ["connection", "job", "sl", "f", "loc", "org", "channel", "ur", "method", "el", "stream", "web", "download", "base", "ssl", "log", "ls", "ll", "page", "user", "bb", "zip", "l", "key", "client", "address", "Url", "i", "URL", "entry", "source", "image", "db", "hub", "path", "object", "li", "server", "uri", "io", "http", "c", "file", "impl", "id", "resource", "coll", "www", "host", "location", "rl", "ob", "il"], "conn": ["connection", "nt", "open", "cb", "oa", "cn", "socket", "nc", "sn", "error", "oss", "ca", "ct", "sync", "dn", "enc", "not", "en", "ec", "pc", "ann", "rc", "ssl", "conf", "orp", "fn", "err", "client", "dc", "connected", "cli", "ci", "ctx", "connect", "api", "ch", "uc", "db", "exec", "cf", "close", "config", "conv", "n", "server", "rt", "core", "io", "http", "c", "Conn", "co", "po", "coll", "cm", "con", "ai", "adj", "fail", "auth", "cp", "Connection", "col", "sql", "serv", "act"], "status": ["active", "msg", "ity", "login", "current", "version", "si", "error", "reason", "type", "method", "sync", "state", "str", "xml", "grade", "received", "class", "ix", "ssl", "size", "content", "Status", "success", "sex", "zip", "pre", "err", "warning", "source", "cli", "api", "response", "stage", "score", "level", "code", "server", "date", "rate", "id", "index", "sr", "message", "prefix", "stat", "result", "cm", "header", "fail", "progress", "json", "site"], "in": ["reader", "bin", "isin", "login", "data", "socket", "ins", "pin", "stream", "cin", "min", "In", "inside", "inner", "again", "rin", "win", "r", "din", "IN", "o", "pull", "ini", "i", "source", "init", "inc", "nin", "or", "n", "io", "inn", "up", "id", "a", "lin", "input", "con", "gin", "rx"], "out": ["bin", "extra", "ext", "doc", "self", "at", "sync", "ex", "outs", "min", "plain", "log", "copy", "user", "again", "cache", "w", "img", "writer", "line", "err", "plus", "o", "off", "client", "OUT", "temp", "this", "lib", "inc", "ch", "exec", "parent", "outer", "n", "io", "net", "file", "up", "co", "on", "ou", "exp", "Out", "gin", "obj"]}}
{"id1": "17999474", "id2": "8754809", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipasfile", "getZipAtFile", "getZipAsDir", "getTempAsfile", "getTempAsFile", "getZipAtfile", "getTempAsPlace", "getTempAsDir", "getZipAtDir", "getZipasPlace", "getZipasDir", "getZipAsPlace", "getZipAtPlace", "getZipAsfile", "getZipasFile"], "digOb": ["signOb", " digob", "signObject", " digObject", "digOl", "dimOb", " digObj", "signob", " digOl", "signOB", "dimObject", "DigObj", "Digob", "ditob", "dimObj", "DigObject", "signObj", "DigOl", "digOB", "digObj", "ditOB", "ditObject", "DigOb", "ditOb", "digob", " digOB", "dimOl", "digObject"], "folderName": [" foldername", "foldPath", " folderDir", "foldName", "fileName", "foldername", "FolderName", "folderPath", "foldname", "packagePath", "packagename", "packageName", "foldInfo", "folderDir", "FolderPath", "FolderDir", "filePath", "fileInfo", "filename", "FolderInfo", " folderPath", "folderInfo", "Foldername", "packageDir"], "tmpFolder": ["tempDirectory", " temporaryManager", "tempManager", "tmpManager", "mpfolder", "tempfolder", "mpFolder", "tempDir", " temporaryFolder", "mpDir", "tmpfolder", " tmpDir", " tmpDirectory", "mpDirectory", " temporaryfolder", " tmpfolder", "tempFolder", "tmpDirectory", " tmpManager", "tmpDir", " temporaryDirectory"], "zip": ["pipe", "lock", "job", "sl", "f", "archive", "ze", "slice", "py", "seed", "install", "p", "download", "gz", "jar", "xml", "ie", "copy", "wrap", "clip", "cop", "bag", "flow", "temp", "zone", "proxy", "lib", "source", "pack", "lex", "z", "feed", "cf", "ulp", "url", " zipper", "io", "flat", "file", "folder", "ce", "ress", "upload", "ipped", "fp", " ZIP", "Zip", "json", "ip", "ignore", "tmp", "pkg"], "out": ["connection", "f", "socket", "sync", "info", "ex", "outs", "download", "gz", "gen", "os", "plain", "base", "log", "is", "copy", "page", "conn", "cache", "again", "output", "user", "loader", "box", "writer", "line", "err", "flow", "o", "client", "flush", "OUT", "temp", "this", "cli", "source", "z", "child", "path", "parent", "object", "url", "null", "io", "in", "file", "a", "upload", "result", "Out", "write", "obj"]}}
{"id1": "20091126", "id2": "149935", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["open", "archive", "type", "put", "p", "download", "Cop", "output", "zip", "cop", "paste", "call", "cmp", "proxy", "cat", "source", "Copy", "process", "exec", "transfer", "io", "up", "file", "upload", "join", "cp", "write", "over"], "in": ["reader", "bin", "connection", "login", "f", "data", "name", "ins", "m", "min", "In", "base", "part", "b", "inner", "again", "old", "l", "work", "query", "IN", "buffer", "i", "source", "image", "inc", "or", "url", "config", "file", "id", "index", "a", "ic", "lin", "input", "diff", "ac"], "out": ["x", "ext", "data", "name", "point", "channel", "array", "p", "ex", "outs", "plain", "base", "page", "cache", "again", "output", "content", "dot", "err", "o", "off", "OUT", "temp", "external", "comment", "call", "source", "buffer", "image", "i", "value", "exec", "parent", "object", "v", "url", "default", "server", "io", "c", "file", "prefix", "a", "result", "target", "exp", "Out", "string", "write"], "inChannel": ["iniChannel", " inchannel", "inButton", "inGate", "inputButton", "INChannel", "INChan", "INGate", "iniGate", "outStream", "winStream", "insChannel", "inchannel", " inButton", "winChannel", " inChan", "iniStream", "outchannel", "INClient", "insChan", " inStream", "insStream", "outChan", "inputGate", "winchannel", "inClient", "INchannel", "iniChan", "inputChan", "insClient", "INButton", "inputChannel", "inChan", "inputStream", "outButton", "inputchannel", "inStream", " inClient", "INStream", "winChan"], "outChannel": ["outsConnection", "outsChannel", " outStream", "inContext", "inConnection", " outContext", "outputStream", " outConnection", "outStream", "outContext", "outputChan", "inchannel", "outchannel", "OutChan", " outChan", "outChan", "OutContext", "OutStream", "outsChan", "outsStream", "inClient", "OutClient", "outConnection", "Outchannel", "outputClient", "outputchannel", "OutChannel", "inChan", "outputChannel", "inStream", " outchannel", "outClient"]}}
{"id1": "6301863", "id2": "12171364", "code1": "    protected String doRawRequest(String postData) throws IOException {\n        URL url = new URL(SERVICE_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(postData);\n        wr.flush();\n        BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuffer sb = new StringBuffer();\n        String line;\n        while ((line = rd.readLine()) != null) {\n            sb.append(line);\n        }\n        wr.close();\n        rd.close();\n        return sb.toString();\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"doRawRequest": ["doPostPost", "DoRawRequest", "doPostResponse", "DoDirectRequest", "doPostMessage", "DoDirectResponse", "doRawMessage", "doFullResponse", "doDirectResponse", "DoDirectPost", "DoRawPost", "doFullRequest", "DoRawMessage", "doDirectRequest", "doFullMessage", "doPostRequest", "doDirectMessage", "doFullPost", "DoDirectMessage", "DoRawResponse", "doDirectPost", "doRawPost", "doRawResponse"], "postData": ["Postdata", "postString", " postdata", "POSTString", "postdata", "POSTData", "PostBody", "PostData", "postBody", "PostPart", "POSTPart", " postPart", " postString", " postBody", "postPart", "PostString", "POSTBody", "POSTdata"], "url": ["connection", "nt", "open", "sl", "f", "org", "fl", "ur", "web", "download", "str", "ll", "ssl", "base", "ls", "log", "bb", "b", "page", "blog", "user", "r", "l", "client", "Url", "service", "URL", "db", "api", "lr", "cl", "config", "server", "uri", "http", "c", "resource", "www", "host", "rl"], "conn": ["connection", "nt", "open", "lock", "cb", "rn", "loc", "cn", "reg", "org", "nc", "session", "g", "ct", "Connect", "sync", "dn", "enc", "not", "pub", "pc", "ann", "ssl", "w", "contract", "cr", "r", "client", "dc", "ci", "db", "connect", "ch", "cf", "exec", "close", "conv", "n", "rt", "Conn", "c", "wb", "co", "po", "coll", "ai", "con", "cm", "fp", "fail", "auth", "cp", "Connection", "apt", "act"], "wr": ["rh", "mr", "wt", "ww", "wd", "fw", "kr", "raft", "vr", "wp", "ru", "pr", "w", "wrap", "wm", "cr", "r", "writer", "ra", "Wr", "dr", "rr", "wn", "rb", "shr", "war", "WR", "hr", "wa", "rw", "sw", "nr", "rt", "wire", "wb", "RW", "wer", "rx", "nw", "fd", "wy", "rss", "Writer", "write", "wx"], "rd": ["rh", "reader", "bd", "rn", "RS", "RD", "rm", "wd", "ds", "dd", "adr", "rod", "ru", "rc", "ld", "dig", "pr", "rob", "cr", "r", "writer", "ra", "fr", "dr", "rb", "rr", "rowd", "gd", "hr", "db", "rw", "rg", "erd", "dra", "rt", "sr", "src", "ird", "fd", "rss", "tr", "xd", "wx", "pd", "rl", "rx"], "sb": ["SB", " SB", "BB", "cb", "bd", "su", "sg", "nn", "si", "lp", "bj", "gb", "s", "bs", "buff", "bt", "eb", "lab", "bh", "binary", "xb", "ssl", "bb", "ls", " eb", "b", "mb", "sv", "bp", "lines", "bc", "rb", "buffer", "abb", "db", "ws", "lb", "zb", "bg", "bps", "sa", "wb", "nb", "src", "bsp", "bf", "sf", "fp", "obb", "fb", "pb", "buf"], "line": ["job", "reader", "le", "sl", "f", "data", "name", " Line", "error", "type", "body", "sync", "non", "one", "str", "letter", "lc", "inline", "page", "user", "text", "part", "l", "r", "cell", "err", "lines", "key", "e", "lf", "row", "comment", "i", "source", "Line", "object", "character", "no", "cl", "code", "pass", "unit", "in", "split", "file", "id", "LINE", "word", "len", "message", "lin", "link", "string", "ip", "end"]}}
{"id1": "5676111", "id2": "19912848", "code1": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"get": ["open", "it", " it", "info", "download", "output", " exit", " this", "export", "build", "init", "run", "process", "exec", " download", "close", " upload", "let", " extract", " quit", "print", "start", "end"], "cnt": ["Cwd", "Cnn", "fnt", " count", "Cnt", "cst", "cnc", " cnc", "cwd", "Cst", "rcnt", "Cnc", "encst", "CNT", "fount", "rcnc", "rcNT", "fNT", "cNT", " cnd", "cnd", " cst", "count", "Count", "cnn", "Cnd", "encnt", " cwd", " cNT", " cnn", "fwd", "encnn", "encNT", "rcnd"], "url": ["connection", "open", "sl", "f", "loc", "cur", "name", "org", "git", "socket", "channel", "session", "ur", "web", "download", "str", "ll", "ssl", "ls", "bb", "log", "b", "blog", "cache", "page", "l", "r", "client", "Url", "URL", "source", "image", "path", "config", "server", "uri", "ir", "http", "c", "file", "impl", "resource", "bel", "www", "host", "coll"], "conn": ["connection", "open", "cur", "cb", "ens", "loc", "cn", "org", "socket", "nc", "oss", "ca", "ct", "p", "enc", "not", "en", "os", "ec", "ann", "ssl", "err", "client", "dc", "cli", "ci", "init", "ctx", "connect", "ch", "api", "exec", "conv", "n", "server", "io", "http", "c", "Conn", "co", "coll", "cm", "con", "out", "ai", "cp", "Connection", "col", "ob", "act"], "is": ["open", "iter", "ais", "Is", "iss", "loc", "isl", "ri", "s", "bs", "info", "os", "im", "ie", "isa", "IS", "ssl", "isc", "i", "ci", "init", "ws", "api", "or", "ois", "ui", "close", "bis", "uri", "ir", "io", "ris", "http", "as", "in", "iso", "id", "iris", "src", "are", "es", "ai", "res", "us", "ios", "lis", "ip", "ib", "ob", "il", "isi"], "filename": ["connection", "username", "login", "f", "loc", "family", "name", "fil", "class", "nil", "format", "Filename", "output", "size", "files", "l", "fn", "password", "key", "ename", "source", "ername", "path", "phrase", "nl", "uri", "file", "folder", "title", "prefix", "fd", "utf", "queue", "sf", "fp", "directory", "location", "length", "string", "il"], "fos": [" foss", "Fo", "fus", "fis", "Foses", "foses", "lo", "goses", "Fus", " fis", "fdicks", "gios", "fose", "fdo", "Fose", " fose", "efos", "lios", "loses", "ficks", " fus", "Ficks", "gos", "efose", " ficks", "go", "Fios", "Fis", "fdos", "Foss", "foss", "efus", "efoss", "fdis", "fios", "Fos", " fo", "fo", "los"], "buffer": ["offset", "reader", "border", "uffer", "iter", "sequence", "data", "channel", "vector", "batch", "reference", "seed", "layer", "buff", "Buffer", "counter", "binary", "base", "position", "bb", "page", "cache", "b", "output", "size", "bytes", "shape", "flush", "address", "padding", "source", "limit", "feed", "phrase", "transfer", "number", "pause", "server", "null", "read", "document", "memory", "duration", "file", "wave", "queue", "header", "input", "result", "length", "fb", "buf"]}}
{"id1": "17161805", "id2": "3745402", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 1, "substitutes": {"encode": ["reoding", "encoder", "encoding", "reode", "enoding", "ensoder", "Encode", "enscod", "Encod", "enscode", "Enoding", "recod", "enode", "enccod", "recode", "enoder", "ensode", "enccode", "Enode", "encod", "Enoder"], "plaintext": [" plaincontent", "longText", "foreTEXT", "bodyform", "forestring", " plainform", "plainTEXT", "plaincontent", "plainform", "bodyText", "bodytext", " plainTEXT", "bodycontent", "batstring", "foreText", "foretext", "longtext", "batText", "batTEXT", "longform", " plainText", "battext", "plainText", " plainstring", "plainstring", "longcontent"], "md": ["meta", "df", "bd", "f", "mag", "cd", "rm", "wd", "grad", "mad", "dd", "m", "ma", " MD", "ind", "me", "di", "mb", "mac", "cmd", "dm", "um", "sm", "d", "MD", "gd", "mod", "amd", "mp", "code", "rpm", "metadata", "mm", "pm", "dh", "sha", "po", "mc", "ms", "od", "mand", "pd", "hd", "ad"], "raw": ["missing", " Raw", "blocks", "ack", " hex", "remote", "array", "stream", "dec", "clean", "RAW", "enc", "load", "shared", "local", "hex", "binary", "ghost", "orig", "Raw", "instance", "all", "rew", "pure", "row", "buffer", "block", "pack", "feed", "ode", "serial", "original", "unsigned", "input", "out", "custom", "initial", "unknown", "internal", "alpha", "micro"]}}
{"id1": "14473711", "id2": "11562165", "code1": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 0, "substitutes": {"str2md5": ["str2mdse", "str2MD512", "str_md512", "str2MDse", "str2MD5", "str2md512", "str2MD3", "str2h3", "str2h512", "str_md3", "str_mdse", "str2dig5", "str_MD512", "str_MDse", "str2md3", "str_MD5", "str2h5", "str2hse", "str_MD3", "str2dig512", "str_md5", "str2dig3", "str2digse"], "str": ["msg", "er", "f", "data", "name", "char", "s", "arr", "st", "kr", "p", "enc", "hex", "format", "br", "text", "inner", "txt", "bytes", "Str", "r", "cr", "err", "fr", "dr", "strings", "test", "buffer", "i", "source", "sp", "t", "spec", "url", "code", "pass", "empty", "STR", "in", "sr", "tr", "input", "result", "exp", "string", "obj", "dict"], "alga": ["Alja", "alqa", "ALja", "ala", "elda", "Alsa", "Algas", "ALgas", " alja", "ALga", " algas", "algas", "alsa", " alqa", "elga", "ALda", "alsqa", " ala", " alca", " alsa", "ela", "ALca", "elgas", "Alga", "alca", "ALqa", " alda", "alsca", "alsga", "alda", "ALsa", "alja", "ALa", "alsda"], "digesta": ["diffsta", "finesta", "badera", "digeste", "diffosta", "codsta", "diffesta", "fineste", "digsta", "badza", "badesta", "digosta", "codosta", "codeste", "finosta", "igosta", "diffeste", "igera", "igza", "igesta", "finsta", "digza", "badosta", "codera", "codza", "codesta", "digera"]}}
{"id1": "9275622", "id2": "23510383", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 1, "substitutes": {"copyFile": ["moveFolder", "copyFiles", " copyfile", "copyFolder", "transferFile", "transferFolder", "moveFiles", "transferfile", " copyFiles", " copyFolder", "transferFiles", "movefile", "copyfile", "moveFile"], "_file1": ["_files1", "_files01", "_File2", "_fileone", "_resourceOne", "_mail2", "_file0", "_resource1", "_fFirst", "_resourceone", "_zip1", "_zipFirst", "_fileOne", "_zipOne", "_file01", "_fone", "_fOne", "_File0", "_f1", "_mail1", "_File01", "_mail0", "_File1", "_mail01", "_zipone", "_files2", "_files0", "_resourceFirst", "_fileFirst"], "_file2": ["_files4", "_filesecond", "_Filesecond", "_File5", "_File2", "jfile1", "_file4", " _filesTwo", " _files3", "jmodelsecond", "_model1", "_model5", "_file5", "_modelsecond", "_files3", "_file3", "jfile5", "_play2", "jfilesecond", " _file3", "_playTwo", "jmodel1", "jmodel5", "_play1", "_model2", "_playsecond", "_filesTwo", "_fileTwo", "_File1", "_play5", " _files4", "_files2", "_play4", " _file4", " _fileTwo", "jfile2", "_play3", "jmodel2", " _files2"], "fis": ["fiss", "infiss", "lfais", "lfi", "afis", "cfos", " fris", "afais", "cfiss", "lfis", "cfas", "Fils", " fais", "infils", "afiss", "fi", "Fas", "Fis", " fi", "fils", "infos", "Fiss", "fas", " fiss", "afi", " fils", "lfiss", "Fos", "fris", "Fris", "fais", "cfis", "cfris", "infis", " fas"], "fos": ["infaos", "Fo", "fus", "infus", "Foos", "Foses", "foses", "infios", "feos", "floes", "goses", "Fus", "info", " foos", "fOS", "flis", "infros", "gis", "Faos", "Fros", " fus", "gos", "feoses", "foes", "pis", "Fios", "Fis", "infoos", "infos", "fros", "poes", " faos", "pOS", "feus", "fios", "Fos", "pos", "feis", "foos", " fo", "flOS", " fios", "los", "lis", "faos", "lOS", "flos", "fo", " fros", "loes", "gus"], "canalFuente": ["canalBuence", "canalCraencia", "canaledBuje", "canaledBuze", "canalKuze", "canallBuente", "canallFuente", "canalBuento", "canalFuze", "canalsBuence", "canaledBuente", "canalSuente", "canalFuento", "canallBuence", "canalsFuente", "canalBuente", "canalBuje", "canalSuje", "canalFUje", "canaledFuente", "canalSuestro", "canaledFuestro", "canallFuze", "canalsFuence", "canalsBuento", "canalFUestro", "canalFuencia", "canalKuence", "canalsFuencia", "canalFUente", "canalBuencia", "canaledBuestro", "canaledFuje", "canalKuento", "canalsFuento", "canalFuje", "canallBuze", "canallFuence", "canalsBuencia", "canaledFuze", "canalBuestro", "canallFuencia", "canalKuente", "canalKuencia", "canalFuence", "canalFUencia", "canalSuze", "canalCraence", "canalsBuente", "canalFUze", "canalCraente", "canalCraento", "canalFUence", "canalBuze", "canallBuencia", "canalFuestro"]}}
{"id1": "11962480", "id2": "8047989", "code1": "    public void read(String skeletonFilename) throws Exception {\n        ClassLoader loader = UnicodePropertiesSkeleton.class.getClassLoader();\n        URL url = loader.getResource(skeletonFilename);\n        if (null == url) {\n            throw new Exception(\"Cannot locate '\" + skeletonFilename + \"' - aborting.\");\n        }\n        String line;\n        StringBuilder section = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n        while (null != (line = reader.readLine())) {\n            if (line.startsWith(\"---\")) {\n                sections.add(section.toString());\n                section.setLength(0);\n            } else {\n                section.append(line);\n                section.append(NL);\n            }\n        }\n        if (section.length() > 0) {\n            sections.add(section.toString());\n        }\n        if (sections.size() != size) {\n            throw new Exception(\"Skeleton file '\" + skeletonFilename + \"' has \" + sections.size() + \" static sections, but \" + size + \" were expected.\");\n        }\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"read": ["open", "readable", "get", "Read", "create", "download", "load", "find", "add", "copy", "register", "check", "construct", "parse", "build", "init", "process", "store", "split", "transform", "resource", "replace", "print", "report", "write", "start"], "skeletonFilename": ["southeastFile", "sletonFilename", " skelFilename", " skelFile", "sletonfilename", "skeletonSourceFile", "southeastFilename", "skelDownload", "SkeletonSourceFile", "sletonSourceFile", "skelFile", "SkelFilename", "SkelDownload", "skelSourceFile", "skeletonDownload", "SkeletonDownload", "sleeFilename", " skeletonFile", "southeastSourceFile", "sletonFile", "Skelfilename", "skelFilename", " skelSourceFile", "sleeFile", "skeletonFile", "SkelFile", "SkelSourceFile", " skeletonfilename", " skelfilename", "SkeletonFile", "Skeletonfilename", "sleeSourceFile", "sletonDownload", "sleefilename", "southeastDownload", "skelfilename", "skeletonfilename", "SkeletonFilename", " skeletonSourceFile"], "loader": ["lock", "er", "loc", "loaded", "name", "handler", "Loader", "layer", "load", "class", "log", "lc", "base", "cache", "b", "loading", "l", "r", "err", "parser", "lang", "buffer", "source", "init", "builder", "driver", "path", "system", "cl", "config", "server", "null", "http", "CL", "in", "file", "impl", "resource", "rl"], "url": ["connection", "sl", "cdn", "f", "data", "loc", "name", "ur", "load", "base", "ssl", "page", "b", "user", "l", "r", "client", "address", "Url", "buffer", "URL", "source", "service", "i", "image", "api", "lib", "feed", "path", "object", "uri", "server", "browser", "http", "file", "resource", "bel", "coll", "host", "location", "rl", "rel", "string"], "line": ["job", "le", "sl", "data", "name", "lo", "body", "sync", "se", "str", "definition", "letter", "log", "base", "inline", "lc", "page", "part", "text", "user", "content", "l", "cell", "L", "lines", "lf", "key", "row", "comment", "i", "entry", "source", "style", "parse", "Line", "write", "no", "cl", "number", "nl", "code", "unit", "pe", "file", "split", "LINE", "word", "lin", "item", "result", "header", "link", "string", "liner", "strip"], "section": ["job", "connection", "union", "region", "data", "division", "sect", "sections", "layout", "version", "handler", " intersection", "array", "layer", "body", "se", "sector", "definition", "letter", "rule", "lc", "format", "position", "page", "description", "text", "output", "contract", "content", "article", "zip", "writer", "journal", "patch", "parser", "key", "row", "service", "style", "entry", "ner", "block", "storage", "feed", "sub", "builder", "source", "parent", "sec", "character", "config", "server", "null", "element", "file", "Section", "function", "script", "search", "draft", "chapter", "join", "length", "location", "area", "string", "ler", "option", "editor"], "reader": ["iter", "er", "f", "ri", "handler", "worker", "stream", "layer", "per", "inner", "r", "writer", "rer", "parser", "rr", "row", "buffer", "i", "ner", "oder", "feed", "builder", "driver", "reading", "bird", "io", "file", "rar", "resource", "input", "ler", "Reader", "editor", "rx"]}}
{"id1": "13122204", "id2": "21063400", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unpackProject", "unpackFile", "Unzipmodel", "unzipFile", "unpatchProject", "UnzipModel", "unpackmodel", "unpatchmodel", "UnarchiveProject", "unpackModel", "UnzipFile", "unzipmodel", "unzipProject", "UnarchiveFile", "unpatchModel", "Unarchivemodel", "unpatchFile", "unarchivemodel", "unarchiveFile", "unarchiveProject", "unarchiveModel", "UnarchiveModel", "UnzipProject"], "filename": ["username", "fits", "loc", "f", "name", "File", "database", "download", "fil", "SourceFile", "nil", "model", "kl", "Filename", "files", "txt", "jet", "l", "fn", "source", "path", "url", "uri", "file", "folder", "title", "module", "src", "fd", "utf", "FILE", "bf", "fp", "directory", "location", "string", "il"], "tempdir": ["temdir", "Tempfolder", "tmpdirectory", "tempDIR", "Tempdirectory", " tempDIR", "tempfolder", "temdirectory", " tempDir", "temfolder", "tempDir", " tempfolder", "tempdirectory", "tmpfolder", "tempath", "TempDir", " tempdirectory", "tmppath", " temppath", "temDir", "TempDIR", "temppath", "Tempdir", "tmpDIR", "tmpDir", "tmpdir"], "dest": ["prop", "nt", "cdn", "loc", "opt", "sup", "later", "session", "handler", "st", "cont", "sync", "comb", "gen", "proc", "log", "di", "die", "walker", "output", "inner", "txt", "done", "zip", "trans", "export", "dist", "temp", "std", "dc", "test", "source", "builder", " Dest", "delete", "ui", "exit", "walk", "transfer", "store", "default", "flat", "file", "wb", "transform", "folder", "src", "Dest", "result", "target", "dir", "dat", "usr", "home", "de", "desc", "obj", "tar", "tmp", "rest"], "fis": ["fid", "fiss", "fisa", " fid", "flisa", "fsisa", "filebis", "flis", "flbis", "fsbis", "filei", "fileisa", "fileiss", "fi", "fileis", " fi", "fliss", "fbis", "lid", "li", " fiss", "fsis", "fsiss", "liss", "lis", "fileid"], "BUFFER": ["MAFIX", "BOFFER", "BOFER", "UPVER", " BUVER", "BOPER", "BUFF", "BOFIX", " BUFF", "TAFFER", " BUFIX", "CUVER", "UPFF", " BUVEN", " BUUCK", "BUVER", "SAFFER", "CUUCK", "UPVEN", "BUVEN", "BUFIX", "BUPER", "UPFFER", " BUFER", "SAPER", "MAFFER", "TAPER", "TAVER", "CUFFER", "BUFER", "SAVER", "CUVEN", "CUFF", "MAPER", "CUPER", "BUUCK", " BUPER", "SAUCK", "MAFER", "TAUCK"], "zis": ["ji", "zins", " zbis", "zisa", "yis", "Zis", " zi", " zii", "Zas", "xis", "zii", " zin", "zas", "ziss", "zin", "zipis", "yisa", " ziss", "yIS", "zipin", "xists", "Zisa", " zIS", " zins", "xos", "xii", " zas", "zipIS", " zos", "zipisa", "dis", "jis", "zipins", "jists", "dbis", "xi", "dii", " zisa", "zIS", "zi", " zists", "xiss", "diss", "zists", "Zins", "zipas", "yin", "zbis", "xbis", "zos", "jos"], "entry": ["nt", "reader", "connection", "si", "name", "archive", "ries", "ident", "info", "ge", "se", "ie", "rc", "match", "lc", "Entry", "part", "inner", "je", "her", "zip", "ace", "line", "e", "la", "row", "cat", "pack", "image", "feed", "inc", "or", "source", "spec", "next", "enter", "iterator", "li", "server", "pe", "jo", "file", "ce", "way", "module", "valid", "id", "porter", "ry", "result", "cel", "record", "ou", "ent", "de", "end", "element"], "count": ["iter", "f", "name", "_", "current", "allow", "type", "low", "counter", "ind", "base", "log", "add", "part", "b", "size", "time", "weight", "cache", "line", "val", "max", "e", "writer", "key", "buffer", "list", "Count", "cond", "i", "limit", "feed", "use", "next", "sum", "number", "code", "read", "core", "c", "in", "file", "id", "index", "pos", "len", "last", "coll", "length", "write", "start", "end"], "data": ["reader", "name", "batch", "body", "array", "info", "load", "str", "zero", "base", "format", "shift", "size", "bytes", "content", "la", "d", "buffer", "block", "image", "pack", "feed", "media", "value", "next", "number", "raw", "read", "DATA", "pos", "index", "len", "message", "a", "id", "result", "dat", "input", "record", "length", "alpha", "write", "start"], "fos": ["xoes", "afis", " foes", "bOS", "afops", "xoos", "bos", " foos", "fOS", " fOS", "xops", "afos", "foes", "dfops", "fops", "xos", "afOS", "bis", "dfos", "bops", "dfoos", "foos", " fops", "dfoes"]}}
{"id1": "397240", "id2": "22993368", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrap", "readandRewrites", "readAndRewwrite", "readandrewrites", "readandRewrap", "readAndSwwrite", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readAndRebrites", "readAndRewrites", "readAndrewrites", "readandrewrite", "readandRewwrite", "readandrewrap", "readAndRebrite", "readAndSwrites", "readAndSwrite", "readAndRebrap", "readAndrewrap", "readandrewwrite", "readAndRewrap", "readandRewrite"], "inFile": ["inputFile", "outFiles", "oldFile", "loginfile", "oldFilename", "infile", "inputfile", "outfile", "loginFile", " inSourceFile", "loginFiles", "inSourceFile", "outSourceFile", "loginFilename", "inFiles", "InFiles", " infile", "InSourceFile", "oldfile", "oldFiles", "inputFiles", "outFilename", " inFilename", "inFilename", "InFile", "Infile", " inFiles", "inputFilename"], "outFile": ["processFILE", "newFile", "newStream", "Outfile", " outStream", "thisFILE", "outDir", "thisfile", "outfile", " outDir", "outStream", "outputFile", "processFile", "processPlace", "offFile", "processFilename", "outputPlace", "offFilename", " outfile", "OutStream", "newDir", "outputFILE", "outputFilename", "thisFile", "outPlace", "exFILE", "exFilename", "newfile", "exFile", "outFilename", "outputfile", "offPlace", "OutDir", "outFILE", "thisFilename", "exfile", "OutFile", "offFILE"], "iis": ["iais", "Iais", " iIs", "iiss", "Iis", "IIS", " iiss", "iiIs", "iniis", "iniiss", " iris", "iniIs", "ciris", "iniIS", "iiis", "ciIs", "iiris", "iniris", "Iiss", "iiiss", " iIS", "ciIS", "iiIS", "iIS", "iris", "ciis", "iIs", "ciiss", "ciais", " iais"], "dcmParser": ["dcrParser", " dpmPar", "dmParser", "dcmJar", "dcrPar", "DcmInstallation", "dmissionReader", "dpmPlugin", "dmissionParser", " dpmReader", "dkmParser", "dcrLoader", "dhemInstallation", " dcrReader", " dcmReader", "dmcJar", "dmissionPlugin", "dcmPar", "dpmInstallation", "dcmHandler", "dpmHandler", " dpmparser", "dmLoader", "dpmPolicy", "dpmParser", "dcmPlugin", "dmmParser", " dcmLoader", " dpmJar", "dcmLanguage", "DcmJar", "dcrPlugin", " dpmarser", " dcmparser", "dmcPar", " dcmPar", "dmcParser", " dcrPlugin", "dkmPolicy", "dpmPar", "dCMLoader", "dpmLoader", "dbmPlugin", "dCMParser", " dpmHelper", "fcmReader", "dbmParser", "dCMHandler", "fpmReader", "dcrReader", "dkmPlugin", " dcmPolicy", "fpmHandler", "fcmparser", "dpmarser", "dmmparser", " dcmarser", "dbmPolicy", "dpmLanguage", "dcrJar", "dmoduleJar", "dmoduleparser", " dpmParser", "fcmHandler", "dmcarser", "dpmReader", "dcmPolicy", "dcmLoader", "dcmHelper", " dcmJar", " dcmPlugin", " dpmPlugin", "dpmparser", "dmoduleReader", "dmPlugin", " dcmHelper", "dhemJar", "dcmarser", "fpmparser", "dbmHelper", " dpmLoader", " dpmLanguage", "dmReader", " dcrLoader", "dcmparser", " dpmPolicy", "dmissionLanguage", "dhemParser", "dmmLoader", "dmodulePlugin", "dcrarser", "fpmParser", "dCMReader", "dCMPlugin", "fcmParser", "dCMparser", " dcmLanguage", "dcmInstallation", "dmoduleParser", " dcrParser", "DcmReader", "dhemReader", "dpmHelper", "dpmJar", "dmmPlugin", "dcmReader", "DcmParser", "dkmHelper"], "ds": ["cdn", "df", "ts", "asi", "data", "iss", "vals", "eps", "s", "icks", "bs", "dd", "ins", "services", "sync", "session", "ns", "da", "Ds", "utils", "os", "sys", "cs", "ld", "ls", "ys", "di", "conn", "parts", "is", "rs", "drivers", "dds", "Db", "dr", "dc", "d", "ras", "nas", "gd", "db", "points", "qs", "js", "ws", "tes", "DS", "Os", "xs", "uds", "vs", "gs", "ays", "ps", "details", "ils", "ants", "des", "src", "amps", "ros", "dat", "ss", "pd", "ads", "tx", "ks", "dt"], "pdReader": ["hdLoader", "pdRunner", "pbReader", "hdStream", "ddRunner", "dsreader", "dsReader", "ddLoader", "pdLoader", "pdStream", "pcLoader", "xdReader", "pcReader", "dsRead", "pbRunner", "pdreader", "pcWriter", "ddStream", "ddReader", "hdreader", "xdreader", "dsLoader", "xdWriter", "pdRead", "pbLoader", "pcRead", "hdWriter", "hdRead", "xdRead", "pbStream", "hdRunner", "hdReader", "dsWriter"], "out": ["lock", "ext", "login", "data", "doc", "name", "at", "down", "outs", "ssl", "w", "err", "flow", "o", "dot", "cli", "oder", "exec", "url", "default", "null", "io", "as", "co", "exp", "over", "point", "later", "session", "auto", "to", "sys", "page", "cache", "conn", "inner", "output", "term", "her", "key", "client", "builder", "outer", "parent", "order", "group", "code", "up", "word", "result", "director", "copy", "model", "with", "part", "line", "writer", "temp", "external", "lib", "image", "inc", "store", "Out", "obj", "device", "full", "connection", "manager", "s", "dev", "array", "sync", "layer", "ex", "gen", "base", "user", "again", "img", "password", "OUT", "list", "db", "child", " in", "object", "pass", "net", "in", "file", "diff", "write"], "dcmEncParam": ["dcmEstPar", "dcmDecPart", "dcmEncParameter", "dcmEncPart", "dcmElType", "dcmEnParameter", "dcmArchParameter", "dcmEnPar", "dcmDecArg", "dcmEnType", "dcmEstParameter", "dcmEstParam", "dcmArchArg", "dcmSecPart", "dcmDecParameter", "dcmEnPart", "dcmDecType", "dcmDecParam", "dcmEncPar", "dcmSecPar", "dcmSecParam", "dcmEncArg", "dcmEncType", "dcmElPar", "dcmEstType", "dcmElParameter", "dcmDecPar", "dcmEnArg", "dcmSecType", "dcmEnParam", "dcmArchParam", "dcmElParam"], "pdWriter": ["dsWrite", "PDWriting", "dpWriter", "pdWriting", "dsReader", "hdWrite", "dpWrite", "htWriting", "PDReader", "ddWrite", "dsOutput", "hdOutput", "PDWrite", "ddReader", "dpReader", "htReader", "pdOutput", "ddWriter", "pdWrite", "htWrite", "ddOutput", "PDWriter", "htWriter", "hdWriter", "hdReader", "dsWriter", "dpWriting"]}}
{"id1": "1769771", "id2": "812803", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["Copyfile", "copyChannel", "copyFiles", " copyfile", " copyChannel", "transferFile", "CopyChannel", "transferfile", " copyFiles", "transferChannel", "CopyFiles", "CopyFile", "transferFiles", "copyfile"], "in": ["reader", "bin", "lock", "login", "f", "data", "name", "ins", "pin", "m", "ex", "min", "In", "base", "inner", "again", "win", "l", "work", "query", "IN", "i", "source", "image", "inc", "url", "config", "io", "inn", "c", "file", "id", "index", "lin", "input", "diff"], "out": ["x", "extra", "ext", "name", "point", "p", "ex", "outs", "plain", "base", "conn", "b", "again", "output", "w", "user", "cache", "writer", "dot", "o", "off", "OUT", "external", "call", "image", "exec", "v", "default", "n", "server", "io", "c", "file", "up", "prefix", "resource", "target", "Out", "string", "write"], "inChannel": ["InClient", " inchannel", "INChannel", "binClient", "binStream", "INChan", "binchannel", "Inchannel", "outStream", "winStream", "InChan", "InStream", "insChannel", "inchannel", "winChannel", " inChan", "outchannel", "insChan", " inStream", "binChannel", "insStream", "outChan", "winchannel", "inClient", "INchannel", "inputChan", "insClient", "inputChannel", "inChan", "inputStream", "inputchannel", "inStream", "binChan", " inClient", "InChannel", "outClient", "INStream", "winChan"], "outChannel": ["nStream", " outStream", "outputCh", "inConnection", "outputController", "inCh", " outConnection", "outputStream", "outStream", "outputChan", "outManager", "inchannel", " outManager", "outchannel", "OutChan", "nChan", " outChan", "outChan", "inManager", " outCh", "outController", "outConnection", "Outchannel", "OutConnection", "inputChan", "outputchannel", "OutChannel", "inChan", "inputChannel", "outCh", "inputchannel", "inController", "nChannel", "nManager", "inStream", " outchannel", "outputChannel", "inputController"]}}
{"id1": "9096314", "id2": "13233761", "code1": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"handleNodeLostService": ["handleNodeUnknownServer", "handlenodelostServer", "handleNodeUnknownServices", "handlenodelostFunction", "handleNodelostFunction", "handlenodeLostServer", "handlenodeLostServices", "handleNodeLostFunction", "handlenodelostServices", "handleNodeUnknownService", "handlenodeLostFunction", "handleNodelostServices", "handleNodeLostServer", "handleNodeLostServices", "handleNodeErrorServices", "handleNodeErrorServer", "handleNodeUnknownFunction", "handleNodeErrorFunction", "handlenodeLostService", "handleNodeErrorService", "handlenodelostService", "handleNodelostServer", "handleNodelostService"], "eventID": ["sessionID", "eventid", "documentID", "nodeType", "nodeId", "resourceid", "sessionName", "resourceId", "EventType", "EventName", "EventID", "eventId", "documentName", "serviceId", "resourceID", "eventName", " eventid", "sessionId", "eventType", "EventId", "nodeName", "resourceName", " eventType", " eventId", "serviceName", "documentId", " eventName", "nodeid"], "nodeID": [" nodeName", "eventid", " nodeid", "networkID", "nodeId", "resourceid", "resourceId", "nodeInfo", "eventURL", "networkId", "NodeID", "eventId", "serviceId", "resourceID", "Nodeid", "eventName", "objectId", "serviceid", "objectID", "NodeId", " nodeInfo", " nodeURL", "nodeName", "resourceName", "NodeURL", "objectName", "serviceName", "networkInfo", "objectid", "nodeURL", "eventInfo", "nodeid", " nodeId"], "ipAddr": ["ipAddressrer", " ipChrs", "ipaddo", "ipaddl", "ipAddressr", "epaddl", "epAddrs", "epaddrs", "apiAddri", "ipAttrs", "apiAddr", "ipAtter", "ipAddressl", "ipAttp", "apiAddp", "apiAddrs", "ipAttr", " ipAttr", "ipAddressrs", "ipAttress", "apiAttr", "ipChp", "ipAddresser", "ipaddress", " ipAddress", "ipadder", "apiAttri", "ipAddressp", "epAddrer", " ipAddrer", "ipAddl", "epaddr", "ipAttri", " ipChrer", " ipAtto", "ipAddri", "apiAttp", " ipChr", "ipAttrer", "ipAdder", " ipAttrs", " ipChri", "ipChr", "ipaddrs", "ipChrer", "epaddrer", "ipAddresso", "ipAtto", "ipAddp", " ipAdder", "ipAddrer", "ipAddress", "ipChri", " ipAtter", "ipAddressri", "ipChl", "epAddl", "epAddr", "apiAttrs", "ipaddrer", "ipAddrs", "ipAddo", "ipChrs", " ipAddrs", " ipAddri", " ipAddo", "ipaddri", "ipaddr"], "serviceID": ["siteID", "featureUID", "ServiceType", "eventid", "networkID", "ServiceId", "networkName", "featureID", "siteid", "ServiceName", "serviceIDs", " serviceName", "siteIP", " serviceUID", "roleId", "featureId", "networkId", "eventIP", "eventId", "serviceId", "networkid", "eventName", " serviceid", "serviceUID", " serviceId", "serviceid", "imageId", "roleID", "roleIP", " serviceIDs", "roleid", "ServiceIP", "eventType", "imageID", "serviceType", " serviceType", "serviceName", "ServiceID", "serviceIP", "ServiceIDs", "imageUID", " serviceIP", "siteId", "eventIDs"], "eventTime": ["EventInfo", "EventTime", "serverName", "serverTime", " eventInfo", "eventtime", "serverInfo", "EventName", " eventName", "eventInfo", "Eventtime", "servertime", "eventName", " eventtime"], "log": ["lock", "tag", "pool", "stop", "type", "put", "ger", "class", "loop", "blog", "w", "cat", "path", "url", "sign", "c", "stat", "host", "exp", "pg", "it", "error", "en", "cache", "output", "contract", "plug", "bug", "key", "og", "call", "port", "or", "sec", "level", "tool", "use", "job", "f", "reg", "thread", "low", "info", "pl", "model", "writer", "cell", "lex", "feed", "config", "guard", "http", "crit", "Log", "full", "get", "where", "lo", "ge", "event", "gen", "base", "user", "LOG", "l", "proxy", "entry", "db", "cl", "pe", "net", "debug", "write"], "dbConn": ["webConn", "DbColl", "DBCt", " dbCon", "databaseconn", "DbCon", "Dbconn", "webCt", "logColl", "logCtrl", "dbCt", "dbConnection", " dbConnection", "libCt", "dbCtrl", " dbNC", "sqlCo", " dbDr", "dbConnect", "DbConn", "DbCs", "webCtrl", "databaseConn", " dbCtrl", "sqlSession", " dbCo", "dbCon", "sqlCtrl", "sqlconn", "libCon", "DbConnection", "dbColl", " dbconn", "databaseDr", "dbCs", "dbSession", "DbConnect", "databaseConnection", "libConn", " dbCs", "dbconn", "libconn", "DbCtrl", " dbSession", "DBConn", "logConnect", "DbSession", "DbDr", " dbColl", "logConn", " dbCt", "DbCo", "DBCs", "dbNC", "DBConnect", "sqlCt", "DbCt", "dbCo", "sqlNC", "webNC", "sqlConn", " dbConnect", "dbDr"], "getNextOutageIdStmt": ["getNextOutageIDStr", "getNextOutageIDSb", "getNextOutageIdStnt", "getNextOutageIdstmt", "getNextOutageIdStr", "getNextOutageIdstMT", "getNextOutageIdSnt", "getNextOutageIdstr", "getNextOutageIdRr", "getNextOutageIdStMT", "getNextOutageIdSmt", "getNextOutageIdSb", "getNextOutageIDSr", "getNextOutageIdCMT", "getNextOutageIDStnt", "getNextOutageIdRb", "getNextOutageIdCnt", "getNextOutageIDStb", "getNextOutageIdSr", "getNextOutageIdCr", "getNextOutageIDStmt", "getNextOutageIdRMT", "getNextOutageIdCmt", "getNextOutageIdSMT", "getNextOutageIdRmt", "getNextOutageIDSMT", "getNextOutageIDStMT", "getNextOutageIDSmt", "getNextOutageIdStb", "getNextOutageIdCb", "getNextOutageIdstnt", "getNextOutageIDSnt"], "outageID": ["OutageName", "outrageID", "outageURL", "outflowID", "outrageHandle", "OutrageHandle", "inrageUID", "outagingName", "outAGEId", "OutrageName", "outrageId", "outagementId", "inageUID", "inrageURL", "OutageSecret", "outagingSecret", "outflowName", "outissueUID", "outAGEName", "outageSecret", "outagementID", "outflowHandle", "outageId", "outissueURL", "OutageID", "outissueId", "outageName", "inrageId", "outAGEURL", "outAGESecret", "outageUID", "outAGEID", "inageURL", "outflowId", "outrageName", "outagingID", "outrageUID", "OutrageId", "inageId", "outagementName", "outAGEUID", "OutageHandle", "outageHandle", "inageID", "OutrageSecret", "OutageId", "outagementHandle", "outagingId", "outrageURL", "outrageSecret", "outissueID", "inrageID", "OutrageID"], "seqRS": ["sqRC", "eqRs", "colRS", " sequenceMR", " seqRT", "structRS", "reqRS", "seqRR", "sequRC", "seqRC", "structRs", "structSR", "seqRs", "seqMR", "sqRT", "colRR", "sequRS", "sequenceRS", "eqRT", "reqRR", " seqRC", "sqMR", "reqRC", "sqRS", "eqRS", "invrs", "reqRT", "eqRR", " seqRL", "invRS", " sequenceRS", "sequencers", "sequenceSR", "colRs", "sequenceRs", "seqSR", "sequRL", "seqRT", "colRT", "seqrs", "invSR", "reqRs", " seqTS", "sequTS", "seqRL", " seqMR", "reqTS", " sequenceRC", "reqRL", "seqTS", "structrs", " sequenceRT", "invRs"], "newOutageWriter": ["newOutissueWriter", "newoutureWrite", "newExlineReader", "newOutrageWrit", "newInflowWriter", "newOutpaceWriter", "newOutflowReader", "newExlineWriter", "newOutpaceReader", "newOutpointRW", "newInflowWrit", "newOutureInfo", "newoutageReader", "newoutureWriter", "newOutpointWrite", "newInageRW", "newOutartWriter", "newoutageInfo", "newOutagementWrit", "newoutageRW", "newOutflowWrite", "newOutagementWrite", "newOutissueWrite", "newExlineWrite", "newInageWriter", "newOutflowwriter", "newOutlineWriter", "newOutageInfo", "newOutrageRW", "newOutagewriter", "newoutageWriter", "newOutpacewriter", "newInageWrite", "newOutlineWrite", "newOutureRW", "newOutagementRW", "newOutpointWriter", "newInflowRW", "newOutflowRW", "newOutagementWriter", "newoutureRW", "newOutureWrite", "newoutagewriter", "newExagewriter", "newOutageRW", "newoutageWrite", "newOutlineReader", "newOutureReader", "newExageReader", "newOutureWriter", "newOutartInfo", "newOutflowInfo", "newoutureReader", "newOutlinewriter", "newoutureInfo", "newOutageWrite", "newOutflowWriter", "newOutrageWrite", "newInflowWrite", "newouturewriter", "newOutartRW", "newOutissueReader", "newOutageWrit", "newOutartWrite", "newOutpaceRW", "newInageWrit", "newExlinewriter", "newOutissuewriter", "newOuturewriter", "newOutrageWriter", "newOutageReader", "newOutflowWrit", "newOutpointReader", "newExageWrite", "newExageWriter"]}}
{"id1": "21491791", "id2": "19335986", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "label": 1, "substitutes": {"run": ["job", "app", "create", "worker", "command", "fork", "log", "loop", "all", "work", "spawn", "test", "call", "build", "process", "exec", "code", "unit", "func", "runner", "running", "execute", "invoke", "Run", "start", "apply"], "input": ["active", "connection", "readable", "data", "audio", "worker", "stream", "state", "control", "conn", "user", "loader", "inner", "text", "instance", "work", "flow", "parser", "client", "address", "source", "storage", "image", "entry", "feed", "request", "driver", "form", "context", "config", "iterator", "reading", "raw", "read", "view", "io", "in", "file", "up", "index", "resource", "out", "initial", "internal", "Input"], "output": ["connection", "office", "job", "data", "later", "put", "operation", "application", "web", "letter", "log", "control", "page", "cache", "writing", "user", "text", "writers", "console", "temp", "source", "image", "response", "path", "filename", "parent", "environment", "object", "exit", "outer", "config", "document", "unit", "file", "index", "generated", "written", "queue", "resource", "out", "target", "network", "Writer", "write", "Output", "end"], "reader": ["er", "manager", "ri", "handler", "book", "worker", "audio", "stream", "rator", "loader", "inner", "wrapper", "r", "rer", "parser", "client", "row", "ner", "oder", "entry", "source", "image", "builder", "driver", "request", "system", "context", "reading", "read", "server", "view", "author", "io", "owner", "in", "resource", "riter", "slave", "Reader", "peer"], "writer": ["connection", "ew", "office", "er", "data", "manager", "wan", "writ", "worker", "creator", "maker", "writing", "inner", "w", "wrapper", "her", "r", "engine", "work", "writers", "ter", "player", "ner", "entry", "ws", "war", "wa", "builder", "driver", "or", "outer", "rw", "request", "author", "wr", "wire", "wb", "nw", "wer", "word", "written", "riter", "out", "Writer", "write", "editor"], "pump": ["Pump", "mumps", "ppumper", "prumper", "prdump", "dmp", "Pprint", "pdump", "Pam", "Pumper", "pamp", "dump", "Pmp", "pmp", "camp", "pumping", "pram", "hump", "ppump", "Pamp", "humps", "ppumps", "mumper", " pdump", " pumping", "cumper", "pprint", "cump", "mprint", " pam", " pumps", "pumps", " pumper", "humper", "Pdump", "Pumps", " pmp", "prump", "pam", "pumper", "hprint", "dumps", " pamp", "mump", "ppumping", "Pumping", "cumping", "dumper"], "counter": ["const", "offset", "ener", "er", "keep", "Counter", "current", "ver", "ception", "sequence", "version", "master", "worker", "seed", "layer", "ger", "zero", "comment", "center", "loop", "page", "keeper", "loader", "instance", "num", "clock", "walker", "inner", "r", "collection", "rew", "ter", "trace", "currency", "row", "pointer", "count", "entry", "ner", "continue", "step", "starter", "race", "cookie", "builder", "outer", "parent", "second", "order", "url", "lr", "enter", "number", "hello", "server", "consumer", "code", "author", "repeat", "index", "timer", "result", "inter", "progress", "processor", "now", "runner", "meter"], "buffer": ["uffer", "iter", "data", "channel", "batch", "reference", "layer", "buff", "Buffer", "binary", "base", "position", "page", "text", "loader", "address", "entry", "source", "limit", "port", "url", "document", "server", "file", "message", "uf", "queue", "header", "resource", "length", "buf"], "off": ["offset", "open", "offs", "oa", "opt", "ff", "down", "head", "low", "auto", "Off", "info", "eno", "OFF", "set", "art", "less", "inner", "left", "own", "flow", "o", "of", "ui", "offer", "ord", "pos", "on", "fail", "out", "Offset", "ref", "unknown", "area", "addr", "start", "end", "now"], "len": ["lock", "bin", "lt", "elt", "loc", "name", "fl", "lim", "el", "body", "layer", "en", "gen", "log", "ll", "lc", "ld", "lan", "all", "size", "lon", "l", "line", "val", "lf", "den", "count", "lib", "limit", "url", "width", "li", "n", "in", "pos", "fd", "lin", "on", "fin", "lit", "Len", "ref", "length", "ln", "ler", "end"], "rd": ["rh", "rn", "RD", "red", "rm", "ds", "dd", "adr", "rod", "ru", "ind", "rc", "ld", "rob", "rf", "cr", "r", "rs", "val", "ra", "raid", "fr", "dr", "rb", "rr", " r", "d", "db", "hr", "rw", "lr", "dra", "ord", "rt", "nr", "rand", " prod", "fd", "rss", "RR", "xd", "nd", "rid", "rl", "ud", "rx"]}}
{"id1": "23517481", "id2": "10715601", "code1": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"md5": ["md8", "sha512", "md2", "sha5", " md8", "MD8", " md2", "MD2", "sha8", "MD5", " md512", "MD512", "md512", "sha2"], "uri": ["connection", "URI", "data", "name", "absolute", "origin", "ri", "iri", "database", "reference", "pi", "base", "format", "text", " ur", "query", "address", "abi", "Url", "i", "URL", "source", "api", "request", "path", "object", "filename", "url", "ui", "attribute", "io", "file", "id", "prefix", "message", "resource", "token", "location", "directory", "string", " URI"], "messageDigest": ["messageMixest", "messageDer", "messageMixEST", "messageMixusher", "messagedigger", "messagedigester", "messageMixester", "messageUploadested", "MessageDer", "messagediger", "MessageDigger", "messageDigested", "messageDigum", "MessageDesignest", "MessageDesignester", "MessageDigum", "messageDusher", "MessageDesignested", "messageDesignested", "messagedigested", "messageDigester", "messageUploadest", "messageUploadester", "messageDesignester", "MessageDigusher", "messageUploadum", "messagedigusher", "MessageDester", "messageDigger", "MessageMixusher", "MessageMixEST", "MessageDger", "MessageDigest", "MessageDiger", "MessageDigested", "messageDesignest", "messagedigest", "MessageDigEST", "messageDEST", "MessageMixester", "messageDigusher", "messageDger", "MessageDesignum", "messageDigEST", "MessageMixest", "MessageDest", "MessageDigester", "messageDesignum", "messagedigum", "messageMixger", "messageDiger", "messageMixer", "messageDester", "messagedigEST", "messageDest"], "bytes": ["values", "data", "blocks", "seq", "sequence", "s", "slice", "bs", "services", "events", "outs", "ips", "units", "binary", "words", "parts", "files", "bits", "bles", "lines", "steps", "letters", "address", "strings", "buffer", "pieces", "objects", "tes", "classes", "acters", "errors", "ions", "keys", "params", "seconds", "es", "resources", "Bytes"], "stringBuffer": ["objectBB", " stringHelper", "objectBuff", "externalBuffer", "stringText", "stringBuilder", "StringBar", "objectString", " stringBar", "externalBuff", "objectHelper", "intText", " stringLength", "externalBar", "stringBB", "intBuffer", "stringBar", "doubleBuilder", " stringBB", "doubleText", "doubleBuffer", "StringString", " stringString", "intBuilder", "StringHelper", "doubleBuff", "externalLength", "stringHelper", "StringBB", "StringFrame", "StringText", " stringBuff", "objectBuffer", "stringLength", "StringBuff", " stringFrame", "StringLength", "stringBuff", "stringString", "stringFrame", "intBuff", "objectFrame"], "b": ["x", "be", "f", "s", "body", "p", "k", "letter", "base", "bb", "bi", "B", "l", "r", "e", "rb", "abi", "d", "i", "buffer", "block", "value", "object", "v", "number", "code", "c", " a", "id", "a", " B", "sb", "bf", "length", "string", "fb", "bit", "ob"], "hex": ["x", "rh", "bin", "iter", "f", "loc", "char", "digit", "alph", "comp", "buff", "ex", "str", "letter", "binary", "bb", "cache", "text", "he", "check", "bits", "buffer", "i", "h", "hash", "serial", "pattern", "character", "url", "number", "oct", "code", "null", "raw", "c", "a", "utf", "lit", "header", "length", "alpha", "string", "ip", "bit"]}}
{"id1": "11556231", "id2": "9802073", "code1": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "code2": "    public void testAutoCommit() throws Exception {\n        Connection con = getConnectionOverrideProperties(new Properties());\n        try {\n            Statement stmt = con.createStatement();\n            assertEquals(0, stmt.executeUpdate(\"create table #testAutoCommit (i int)\"));\n            con.setAutoCommit(false);\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (0)\"));\n            con.setAutoCommit(false);\n            con.rollback();\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (1)\"));\n            con.setAutoCommit(true);\n            con.setAutoCommit(false);\n            con.rollback();\n            con.setAutoCommit(true);\n            ResultSet rs = stmt.executeQuery(\"select i from #testAutoCommit\");\n            assertTrue(rs.next());\n            assertEquals(1, rs.getInt(1));\n            assertFalse(rs.next());\n            rs.close();\n            stmt.close();\n        } finally {\n            con.close();\n        }\n    }\n", "label": 0, "substitutes": {"ByURL": ["byUrl", "CreateURI", "createURL", "bySSL", "ByURI", "BySSL", "createSSL", "CreateURL", "CreateSSL", "ByUrl", "createUrl", "byURL", "byURI", "createURI", "CreateUrl"], "urlstr": ["URLSTR", " urlstring", "Urlstring", "UrlStr", "httpSTR", "urlSTR", "urlstring", "httpStr", " urlname", "URLstring", "URLstr", "httpstr", "httpstring", "UrlSTR", "Urlstr", "URLname", "urlname", " urlSTR", "URLStr", "Urlname", "urlStr"], "uri": ["URI", "absolute", "manager", "ri", "iri", "database", "type", "pi", "base", "direction", "description", "text", "domain", "href", "qi", "query", "collection", "address", "Url", "i", "URL", "image", "path", "filename", "ui", "attribute", "server", "route", "io", "http", "file", "id", "prefix", "resource", "host", "location", "directory", "string", " URI", "username"], "url": ["sl", "f", "loc", "channel", "session", "stream", "web", "download", "base", "ssl", "page", "conn", "user", "loader", "l", "client", "address", "Url", "service", "URL", "image", "proxy", "feed", "path", "system", "li", "server", "http", "file", "id", "resource", "host", "link", "location", "string"], "connection": ["open", "director", "socket", "channel", "handler", "database", "stream", "body", "application", "control", "conn", "l", "writer", "collection", "client", "i", "URL", "connected", "connect", "or", "response", "system", "context", "relation", "server", "io", "http", "c", "resource", "con", "directory", "Connection"], "in": ["bin", "login", "f", "socket", "s", "ins", "stream", "cms", "In", "kin", "conn", "inner", "r", "writer", "and", "IN", "client", "ini", "i", "init", "inc", "connect", "or", "inn", "c", "as", "a", "lin", "input", "out", "con", "ac"], "reader": ["iter", "er", "ais", "channel", "handler", "stream", "rc", "conn", "loader", "inner", "wrapper", "r", "writer", "parser", "client", "ini", "row", "buffer", "i", "entry", "or", "reading", "read", "server", "io", "result", "input", "out", "resource", "ler", "Reader"], "is": ["ais", "Is", "iss", "isl", "si", "ri", "iri", "s", "ins", "info", "has", "cms", "os", "im", "isa", "IS", "conn", "was", "rs", "err", "i", "sp", "ci", "mis", "or", "nis", "bis", "ui", "io", "ris", "as", "iso", "sr", "src", "iris", "rss", "ai", "out", "ios", "lis", "serv", "fs", "isi"], "document": ["doc", "database", "m", "application", "xml", "ocument", "class", "output", "content", "Documents", "writer", "root", "collection", "Document", " documentation", "response", "parent", "object", "config", "message", "graph", " documents", "result", "resource", "docs", "element", "node"], "source": ["container", "language", "stream", "info", "class", "text", "instance", "content", "SOURCE", "parser", "service", "driver", "parent", "object", "context", "unit", "file", "src", "resource", "input", "Source", "string", "element", "node"], "name": ["URI", "tag", "type", "info", "definition", "base", "format", "description", "text", "instance", "domain", "root", "key", "comment", "value", "parent", "object", "filename", "property", "attribute", "Name", "names", "file", "id", "prefix", "word", "resource", "named", "location", "string", "NAME", "element", "node"], "namespaceURI": ["namespaceNS", "namesferenceuri", "perspaceGI", "namespaceduri", "namesferenceURI", "namesheeturi", "namespaceMI", "NamespacesMI", "namesistenceMI", "perspacedGI", "nameservinguri", "NamespaceFINE", "namespacesFINE", "namesistenceuri", "namespacedGI", "namespacesURI", "NamespaceMI", "namesferenceMI", "namespaceuri", "perspaceuri", "namesheetGI", "namesistenceURI", "NamespaceURI", "namespaceFINE", "Namespacesuri", "NamespaceNS", "namespacesMI", "NamespacesURI", "nameservingNS", "NamespacesFINE", "perspacedURI", "namespaceGI", "namespacedURI", "namesheetURI", "namesferenceFINE", "Namespaceuri", "perspaceURI", "namespacedNS", "namesistenceFINE", "namespacesuri", "perspaceduri", "nameservingURI"], "qualifiedName": [" qualifiedPath", "simplePath", "simpleName", "localType", "localPath", "simplename", "qualName", "simpleURI", "qualifiedURI", "qualifiedType", "fixedName", "fixedname", "qualPath", "qualname", "qualURI", " qualifiedURI", "fixedPath", " qualifiedname", "qualifiedPath", "fixedType", "localname", " qualifiedType", "qualifiedname"], "data": ["doc", "type", "language", "body", "stream", "info", "str", "xml", "definition", "class", "base", "format", "description", "model", "text", "output", "content", "buffer", "ata", "value", "child", "template", "parent", "object", "property", "context", "default", "config", "number", "comments", "id", "DATA", "script", "message", "resource", "input", "def", "string", "media", "NAME", "element", "node"], "tagName": ["localClass", " tagClass", "tagClass", "TagName", "localname", "Tagname", "TagClass"], "target": ["prop", "head", "method", "info", "label", "base", "class", "component", "format", "instance", "domain", "href", "root", "address", "template", "path", "parent", "object", "next", "property", "Target", "uid", "resource", "host", "location", "NAME", "node"], "elementId": [" elementid", "elementID", "objectID", "nodeID", "elementTag", "objectTag", "objectid", " elementTag", "nodeId", "nodeTag", " elementID", "elementid", "nodeid", "objectId"], "tagname": [" tagNAME", "TagName", "tagNAME", "TagNAME", "classNAME", "Tagname", "classname", "className"], "localName": ["clientNAME", "clientName", "localname", "clientname", " localname", "qualifiedNAME", "localNAME", "qualifiedname", " localNAME"]}}
{"id1": "17190057", "id2": "22560224", "code1": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "code2": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"encode": ["unode", "Enescape", "Encode", "unescape", "encescape", "uncode", "Enode", "enccode", "enescape", "enode"], "input": ["reader", "inf", "data", "addin", "audio", "secure", "stream", "string", "array", "str", "hex", "binary", "ssl", "format", "text", "output", "instance", "img", "plus", "password", "address", "temp", "this", "buffer", "xxx", "source", "i", "image", "crypt", "request", "pattern", "form", "context", "config", "raw", "empty", "null", "in", "prefix", "amp", "result", "def", "alpha", "Input"], "NoSuchAlgorithmException": ["NoSuchAlodingError", "NoSuchEdgorithmWarning", "NoSuchEdgorithmException", "NoSuchEdryptionError", "NoSuchAlgoement", "NoSuchAlryptionWarning", "NoSuchAlodingException", "NoSuchAlgorithmement", "NoSuchAlgorithmError", "NoSuchEdgorithmError", "NoSuchAlryptionement", "NoSuchAlodingWarning", "NoSuchAlryptionException", "NoSuchAlgorithmWarning", "NoSuchAlgoWarning", "NoSuchEdgorithmement", "NoSuchAlgoException", "NoSuchEdryptionException", "NoSuchAlgoError", "NoSuchEdryptionement", "NoSuchEdryptionWarning", "NoSuchAlodingement", "NoSuchAlryptionError"], "md": ["meta", "df", "bd", "doc", "mag", "cd", "wd", "mad", "dd", "m", "ma", " MD", "mt", "me", "dig", "mb", "mac", "cmd", "zip", "dm", "key", "um", "dc", "d", "MD", "db", "mo", "mod", "hash", "amd", "mi", "sum", "mp", "code", "metadata", "mm", "pm", "message", "sha", "mc", "ms", "pd", "mand", "ad", "hd", "od", "nm"]}}
{"id1": "14567939", "id2": "5836744", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"baseHash": ["basehash", " generateHash", " chainSecret", "BaseFile", "BaseSecret", " generateSecret", " generateFile", "Basehash", " chainhash", " chainFile", "baseFile", "baseSecret", " generatehash", " chainHash", "BaseHash"], "name": ["ame", "data", "type", "create", "definition", "base", "class", "part", "user", "alias", "account", "key", "member", "normal", "address", "secret", "style", "image", "path", "parent", "hash", "object", "names", "Name", "n", "hello", "file", "id", "word", "prefix", "resource", "host", "named", "string", "NAME"], "password": ["wallet", "profile", "data", "wd", "seed", "words", "text", "Password", "account", "key", "paste", "secret", "crypt", "padding", "source", "sword", "value", "path", "PASS", "hash", "pattern", "phrase", "attribute", "code", "pass", "priv", "word", "prefix", "token", "input", "diff", "security", "auth", "stroke", "string", "device", "username"], "digest": ["mdest", "moder", "modested", "signusher", "decEST", " diger", "DigEST", "Digester", "Digusher", "modester", "digested", "mdr", " digusher", "digester", "digEST", "mdEST", "mdester", " digger", "digger", "decest", "signester", "digr", "Digested", "Digger", "diger", "digusher", "signer", "Diger", "modest", "signest", "signger", "Digr", "decr", " digested", "decester", " digester", "Digest"]}}
{"id1": "22560224", "id2": "2525897", "code1": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "label": 1, "substitutes": {"hashStringMD5": [" hashStringUTF4", " hashFileMD8", " hashStringM6", " hashStringMK4", " hashStringMD4", " hashStringM5", " hashFileMD4", " hashFileMK8", " hashStringMD6", " hashFileMK6", " hashStringUTF6", " hashStringMD8", " hashFileMK4", " hashStringUTF8", " hashFileMK5", " hashStringMK5", " hashStringMK8", " hashStringM4", " hashFileMD5", " hashFileMD6", " hashStringM8", " hashStringMK6", " hashStringUTF5"], "string": ["sequence", "data", "name", "version", "database", "slice", "array", "p", "str", "letter", "binary", "text", "bytes", "content", "section", "writer", "password", "address", "strings", "buffer", "list", "source", "map", "service", "object", "filename", "number", "uri", "date", "null", "STR", "file", "ring", "script", "word", "message", "operator", "result", "input"], "md": ["meta", "df", "bd", "gm", "f", "data", "vd", "mag", "mg", "rm", "wd", "dd", "m", " MD", "me", "dig", "mb", "am", "mac", "hm", "cmd", "dm", "vm", "um", "sm", "d", "MD", "km", "gd", "hash", "amd", "mp", "rpm", "metadata", "mm", "pm", "cm", "bf", "mc", "ms", "pd", "mand", "ad", "hd", "od", "nm"], "byteData": ["wordInfo", "ByteSeries", "blockData", "bytePart", "byteDATA", "bitBytes", " byteBytes", "ByteDATA", "wordArray", "ByteData", "bitData", "ByteArray", "bitdata", "bitInfo", "letterDATA", " byteInfo", "blockArray", "wordPart", "lineInfo", "hardData", "letterLength", "ByteInfo", "largeArray", "hardLength", "ByteString", "harddata", "BytePart", "letterdata", "byteArray", "byteSeries", "blockString", " byteLength", " byteSeries", "blockdata", "letterData", "Bytedata", "linedata", " bytePart", "byteBytes", "wordData", "largeSeries", "byteInfo", "bytedata", "byteString", "hardDATA", " byteString", " byteArray", "byteLength", " bytedata", "largeDATA", "largeData", "lineData", "lineBytes", " byteDATA"], "sb": ["SB", " SB", "BB", "bm", "cb", "BP", "sg", "kB", "gb", "SF", "bs", "sc", "buff", "eb", "bh", "xb", "ssl", "bb", "ls", "b", "mb", "bp", "ruby", "rb", "sq", "buffer", "abb", "db", "Buff", "bps", "pb", "ab", "nb", "Bs", "src", "bf", "sf", "BG", "usb", "obb", "fb", "bc", "buf"], "i": ["x", "ji", "f", "y", "si", "it", "ti", "ri", "s", "slice", "g", "m", "j", "p", "ori", "pi", "k", "info", "field", "ie", "ix", "hi", "is", "lc", "bi", "I", "u", "b", "w", "di", "multi", "qi", "l", "fi", "e", "o", "ini", "abi", "d", "ci", "sp", "h", "xi", "v", "oi", "ui", "yi", "mi", "li", "n", "uri", "ii", "io", "c", "in", "id", "iu", "index", "eni", "ai", "gi", "phi", "ip"], "hexString": ["nullText", "nullString", "hexstring", "hexArray", " hexArray", "formstring", "exArray", "exstring", " hexBuffer", "hexText", "shortstring", "exBuffer", "exText", "hexBuffer", "shortArray", "nullBuffer", "formString", "octArray", "octstring", "octBuffer", " hexStr", "exString", "formArray", "nullstring", "exStr", "octString", "hexStr", " hexstring", "shortString", "octStr", "formStr", " hexText", "shortBuffer"], "hex": ["rh", "x", "iter", "char", "digit", "ctr", "alph", "escape", "sync", "buff", "hess", "rex", "ex", "str", "xf", "quad", "shift", "text", "he", "num", " Hex", "kh", "sex", "coord", "shape", "temp", "cmp", "pex", "closure", "pack", "nexus", "cf", "wh", "h", "hash", "brew", "cross", "character", "form", "xa", "sum", "hello", "oct", "raw", "xxxxxxxx", "http", "id", "utf", "lit", "exp", "cube", "length", "alpha", "ip", "bit"]}}
{"id1": "8132219", "id2": "1180878", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyStream", "Copyfile", "copyFiles", " copyfile", " copyStream", "transferFile", "transferfile", " copyFiles", "transferStream", "CopyFiles", "CopyFile", "transferFiles", "copyfile", "copyStream"], "inFile": ["inputFile", "binFiles", "binPlace", "outFiles", "inPlace", "INfile", "infile", "inputfile", "outfile", " inSourceFile", "INFilename", "binFile", "inSourceFile", "INFile", "inFiles", " infile", "InSourceFile", "outPlace", "binfile", "INSourceFile", "inputFiles", " inFilename", "inFilename", "InFile", "InFilename", "Infile", "inputPlace"], "outFile": ["outFiles", "againFile", "infile", "outputFile", "outfile", "againfile", " outFiles", "inFiles", "outputPlace", " outFilename", " outfile", "outputFilename", "againFilename", "outPlace", " outPlace", "outputFiles", "outFilename", "outputfile", "inFilename", "againPlace"], "in": ["x", "reader", "bin", "connection", "f", "data", "name", "ins", "pin", "m", "In", "base", "is", "part", "inner", "again", "rin", "din", "work", "IN", "ini", "i", "source", "image", "inc", "like", "url", "config", "n", "io", "inn", "c", "as", "file", "id", "index", "a", "ic", "input"], "out": ["x", "bin", "ext", "data", "name", "version", "to", "p", "ex", "outs", "plain", "log", "copy", "conn", "w", "b", "output", "part", "cache", "user", "line", "writer", "dot", "o", "client", "OUT", "external", "call", "buffer", "image", "exec", "v", "default", "n", "null", "io", "c", "file", "prefix", "resource", "obj", "Out", "string", "write", "Output"], "inChannel": ["iniChannel", "INSocket", " inchannel", "INChannel", "sinFlow", "INChan", "inConnection", "outStream", " inConnection", "sinSocket", "outLanguage", "winStream", "inchannel", "INFlow", "sinChan", "winChannel", "inichannel", " inChan", "iniStream", "outchannel", "inFlow", "sinChannel", " inFlow", "outChan", "winchannel", "INchannel", "outConnection", "INConnection", "winLanguage", "inputChan", "inLanguage", "inputChannel", "inChan", "inputStream", "iniLanguage", "inputchannel", "inSocket", "inStream", "INStream", " inSocket"], "outChannel": ["inPath", "newStream", "againchannel", " outStream", "inConnection", "newChan", " outContext", " outConnection", "outContext", "outStream", "outputChan", "inchannel", "outPath", "againChannel", "againPath", "outchannel", "OutChan", " outChan", "outChan", "OutContext", "againChan", "OutStream", "outConnection", "Outchannel", "OutConnection", "outputchannel", "OutChannel", "inChan", "outputChannel", " outchannel", "newContext", "newChannel", " outPath"]}}
{"id1": "11556231", "id2": "335223", "code1": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"ByURL": ["byUrl", "CreateURI", "createURL", "bySSL", "ByURI", "BySSL", "createSSL", "CreateURL", "CreateSSL", "ByUrl", "createUrl", "byURL", "byURI", "createURI", "CreateUrl"], "urlstr": ["URLSTR", " urlstring", "Urlstring", "UrlStr", "httpSTR", "urlSTR", "urlstring", "httpStr", " urlname", "URLstring", "URLstr", "httpstr", "httpstring", "UrlSTR", "Urlstr", "URLname", "urlname", " urlSTR", "URLStr", "Urlname", "urlStr"], "uri": ["URI", "absolute", "manager", "ri", "iri", "database", "type", "pi", "base", "direction", "description", "text", "domain", "href", "qi", "query", "collection", "address", "Url", "i", "URL", "image", "path", "filename", "ui", "attribute", "server", "route", "io", "http", "file", "id", "prefix", "resource", "host", "location", "directory", "string", " URI", "username"], "url": ["sl", "f", "loc", "channel", "session", "stream", "web", "download", "base", "ssl", "page", "conn", "user", "loader", "l", "client", "address", "Url", "service", "URL", "image", "proxy", "feed", "path", "system", "li", "server", "http", "file", "id", "resource", "host", "link", "location", "string"], "connection": ["open", "director", "socket", "channel", "handler", "database", "stream", "body", "application", "control", "conn", "l", "writer", "collection", "client", "i", "URL", "connected", "connect", "or", "response", "system", "context", "relation", "server", "io", "http", "c", "resource", "con", "directory", "Connection"], "in": ["bin", "login", "f", "socket", "s", "ins", "stream", "cms", "In", "kin", "conn", "inner", "r", "writer", "and", "IN", "client", "ini", "i", "init", "inc", "connect", "or", "inn", "c", "as", "a", "lin", "input", "out", "con", "ac"], "reader": ["iter", "er", "ais", "channel", "handler", "stream", "rc", "conn", "loader", "inner", "wrapper", "r", "writer", "parser", "client", "ini", "row", "buffer", "i", "entry", "or", "reading", "read", "server", "io", "result", "input", "out", "resource", "ler", "Reader"], "is": ["ais", "Is", "iss", "isl", "si", "ri", "iri", "s", "ins", "info", "has", "cms", "os", "im", "isa", "IS", "conn", "was", "rs", "err", "i", "sp", "ci", "mis", "or", "nis", "bis", "ui", "io", "ris", "as", "iso", "sr", "src", "iris", "rss", "ai", "out", "ios", "lis", "serv", "fs", "isi"], "document": ["doc", "database", "m", "application", "xml", "ocument", "class", "output", "content", "Documents", "writer", "root", "collection", "Document", " documentation", "response", "parent", "object", "config", "message", "graph", " documents", "result", "resource", "docs", "element", "node"], "source": ["container", "language", "stream", "info", "class", "text", "instance", "content", "SOURCE", "parser", "service", "driver", "parent", "object", "context", "unit", "file", "src", "resource", "input", "Source", "string", "element", "node"], "name": ["URI", "tag", "type", "info", "definition", "base", "format", "description", "text", "instance", "domain", "root", "key", "comment", "value", "parent", "object", "filename", "property", "attribute", "Name", "names", "file", "id", "prefix", "word", "resource", "named", "location", "string", "NAME", "element", "node"], "namespaceURI": ["namespaceNS", "namesferenceuri", "perspaceGI", "namespaceduri", "namesferenceURI", "namesheeturi", "namespaceMI", "NamespacesMI", "namesistenceMI", "perspacedGI", "nameservinguri", "NamespaceFINE", "namespacesFINE", "namesistenceuri", "namespacedGI", "namespacesURI", "NamespaceMI", "namesferenceMI", "namespaceuri", "perspaceuri", "namesheetGI", "namesistenceURI", "NamespaceURI", "namespaceFINE", "Namespacesuri", "NamespaceNS", "namespacesMI", "NamespacesURI", "nameservingNS", "NamespacesFINE", "perspacedURI", "namespaceGI", "namespacedURI", "namesheetURI", "namesferenceFINE", "Namespaceuri", "perspaceURI", "namespacedNS", "namesistenceFINE", "namespacesuri", "perspaceduri", "nameservingURI"], "qualifiedName": [" qualifiedPath", "simplePath", "simpleName", "localType", "localPath", "simplename", "qualName", "simpleURI", "qualifiedURI", "qualifiedType", "fixedName", "fixedname", "qualPath", "qualname", "qualURI", " qualifiedURI", "fixedPath", " qualifiedname", "qualifiedPath", "fixedType", "localname", " qualifiedType", "qualifiedname"], "data": ["doc", "type", "language", "body", "stream", "info", "str", "xml", "definition", "class", "base", "format", "description", "model", "text", "output", "content", "buffer", "ata", "value", "child", "template", "parent", "object", "property", "context", "default", "config", "number", "comments", "id", "DATA", "script", "message", "resource", "input", "def", "string", "media", "NAME", "element", "node"], "tagName": ["localClass", " tagClass", "tagClass", "TagName", "localname", "Tagname", "TagClass"], "target": ["prop", "head", "method", "info", "label", "base", "class", "component", "format", "instance", "domain", "href", "root", "address", "template", "path", "parent", "object", "next", "property", "Target", "uid", "resource", "host", "location", "NAME", "node"], "elementId": [" elementid", "elementID", "objectID", "nodeID", "elementTag", "objectTag", "objectid", " elementTag", "nodeId", "nodeTag", " elementID", "elementid", "nodeid", "objectId"], "tagname": [" tagNAME", "TagName", "tagNAME", "TagNAME", "classNAME", "Tagname", "classname", "className"], "localName": ["clientNAME", "clientName", "localname", "clientname", " localname", "qualifiedNAME", "localNAME", "qualifiedname", " localNAME"]}}
{"id1": "3584508", "id2": "21488518", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": ["copyUrl", " downloadUrl", "transferresource", " copyresource", "copyFile", " downloadResource", " copyUrl", "transferUrl", " downloadresource", "transferResource", " downloadFile", "copyresource", "transferFile", " copyFile"], "url": ["connection", "sl", "f", "data", "loc", "name", "remote", "stream", "web", "download", "xml", "base", "ssl", "ource", "ls", "page", "loader", "l", "r", "address", "Url", "URL", "source", "image", "feed", "path", "object", "lr", "uri", "server", "http", "file", "id", "src", "resource", "bel", "www", "host", "ref", "re", "string"], "input": ["active", "reader", "bin", "connection", "inf", "qa", "open", "f", "data", "current", "get", "socket", "error", "session", "ack", "audio", "stream", "load", "xml", "binary", "base", "ssl", "bb", "cache", "inner", "instance", "l", "plus", "client", "address", "pull", "temp", "this", "buffer", "i", "source", "parse", "image", "but", "inc", "api", "feed", "request", "exec", "form", "context", "config", "http", "in", "file", "index", "upload", "resource", "out", "accept", "progress", "Input", "element", "act"], "output": ["connection", "data", "current", "socket", "put", "stream", "operation", "layer", "application", "web", "binary", "log", "control", "copy", "cache", "writer", "flow", "address", "console", "external", "buffer", "source", "image", "production", "response", "outer", "object", "environment", "other", "default", "config", "document", "unit", "file", "resource", "out", "result", "queue", "target", "ou", "network", "write", "Output"], "b": ["x", "be", "bin", "cb", "ob", "f", "bit", "batch", "bs", "m", "p", "k", "base", "binary", "bb", "bi", "B", "mb", "br", "abs", "l", "line", "r", "e", "bc", "rb", "d", "buffer", "i", "bar", "db", "lb", "h", "v", "n", "ab", "pb", "c", "file", "a", "sb", "bf", "fb", "nb", "buf"]}}
{"id1": "7425022", "id2": "23666867", "code1": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"transferWSDL": ["transferWDDL", "transferSWSDDL", "transferWNDL", "transferWNDDL", "transferWSDl", "transferWsdL", "transferSWsdLS", "transferSWsdDL", "transferSWSDL", "transferWSDLS", "transferWDDl", "transferWDDDL", "transferSWSDLS", "transferWsdl", "transferSWsdL", "transferWsdLS", "transferWsdDL", "transferWNDl", "transferSWSDl", "transferSWsdl", "transferWSDDL", "transferWDDLS", "transferWNDLS"], "wsdlURL": ["wdlFILE", "wsdlUrl", "wsdalUrl", "wsdnURL", "wsdnPath", "wsdlURI", "wsllUrl", "wsslUrl", "wssdUrl", "wdlURL", "wsslURI", "wdlURI", "wslPath", "wslURL", "wsllURI", "wssdFILE", "wsslURL", "wslURI", "wllUrl", "wslUrl", "wsdalURL", "wsdalURI", "wllFILE", "wsslPath", "wsdlPath", "wdlUrl", "wsdlFILE", "wsdalPath", "wsllPath", "wllURL", "wssdPath", "wdlPath", "wssdURL", "wsllFILE", "wllPath", "wsdnFILE", "wsllURL", "wsdnUrl"], "userPassword": ["userName", "userData", " userpassword", "usePassword", " userName", "UserWord", "useData", " userPass", "USERpassword", "userWord", "USERPassword", "usepassword", " userData", "useAuth", "UserPassword", "usePass", "UserAuth", "UserData", "userAuth", "UserName", " userWord", "USERName", "UserPass", " userAuth", "Userpassword", "userpassword", "USERWord", "userPass"], "filePath": ["FilePath", "filepath", " filepath", "FileStr", "FileLocation", "Filepath", "fileStr", "fileLocation", "transferpath", "transferLocation", " fileStr", "transferPath", " fileLocation", "transferStr"], "endpoint": ["adwall", "endPoint", " endPoint", "Endpoint", "adPoint", "endpoints", " endpoints", "adpoint", "adpoints", "EndPoint", "Endwall", "endwall", " endwall", "Endpoints"], "conn": ["connection", "nt", "open", "cb", "loc", "cn", "oa", "reg", "org", "socket", "nc", "oss", "g", "ca", "ct", "Connect", "p", "sync", "dn", "ns", "enc", "pub", "en", "ec", "pc", "ann", "rc", "ssl", "w", "part", "conf", "inner", "fn", "Con", "client", "dc", "comm", "cli", "ci", "init", "ws", "connect", "ch", "cf", "ctx", "h", "exec", "col", "close", "url", "n", "conv", "Conn", "c", "dh", "impl", "co", "coll", "cm", "con", "adj", "mc", "sql", "auth", "cp", "Connection", "pg", "ac", "ob", "act"], "is": ["sc", "has", "ie", "ar", "its", "ws", "js", "h", "ps", "io", "as", "iso", "iet", "out", "fs", "isi", "ais", "iss", "isl", "si", "it", "iv", "ins", "stream", "os", "rs", "mis", "or", "sec", "ois", "oc", "src", "es", "ai", "ss", "est", "il", "act", "x", "p", "info", "isp", " IS", "im", "hi", "was", "ops", "r", "ism", "bis", "ris", "sr", "rss", "res", "us", "lis", "serv", "ip", "ib", "rest", "Is", "ri", "s", "irc", "any", "IS", "isc", "ipp", "mes", "i", "ir", "in", "index", "ios", "rx"], "isr": ["issw", " isl", "iscr", "isl", " isp", "ssp", "iscp", "ssrs", "isp", "ISr", "isrs", "ssrb", "issr", "issrb", "ISw", "ISl", "ISp", "iscrb", "iscrs", " isw", "isrb", "isw", "issl", "issrs", "ssr", "issp"], "sw": ["x", "ew", "su", "sl", "wt", "ww", "sc", "hw", "stream", "iw", "wp", "wo", "xml", "wra", "sem", "im", "ow", "hi", "tw", "wrap", "w", "wl", "was", "sv", "cr", "r", "rew", "sm", "hop", "wa", "war", "ws", "wh", "rw", "response", "eng", "aw", "wb", "wr", "nw", "rx", "rss", "sb", "sf", "Sw", "pg", "so", "sh", "wx", "SW"], "buf": ["prop", "bin", "cur", "cb", "bd", "seq", "data", "ha", "ff", "char", "batch", "pool", "buff", "Buffer", "str", "bh", "rc", "base", "bb", "shift", "b", "vec", "text", "br", "bytes", "box", "cr", "bag", "err", "la", "rb", "buffer", "block", "feed", "uc", "raw", "cv", "brace", "func", "wb", "len", "uf", "cas", "pad", "fb", "bc", "rx"], "read": ["reader", "READ", "open", "iter", "f", "data", "get", "start", "ride", "Read", "play", "g", "boot", "stream", "sync", "send", "se", "k", "load", "en", "find", "reads", "log", "add", "need", " write", "copy", "check", "w", "text", "size", "num", "ok", "old", "r", "work", "max", "buffer", "count", "i", "run", "parse", "block", "feed", "child", "connect", "select", "default", "reading", "n", "pass", "raw", "in", "index", "input", "skip", "sleep", "length", "write", "use", "end", "wait"], "outputDir": ["inputFile", " outputFolder", "outFolder", "OutputFile", "outDir", "outputFile", "outFile", "outDirectory", " outputDirectory", "OutputDir", " outputFile", "OutputFolder", "tmpFolder", "outputPath", "inputDir", "inputFolder", "OutputDirectory", "tmpDirectory", " outputPath", "OutputPath", "tmpPath", "outputFolder", "inputDirectory", "outputDirectory", "tmpDir"], "file": ["full", "lock", "le", "f", "data", "name", "File", "handler", "stream", "info", "local", "letter", "log", "base", "future", "b", "output", "files", "content", "zip", "writer", "line", "work", "buffer", "build", "db", "feed", "ile", "path", "parent", "object", "filename", "url", "store", "unit", "up", "folder", "function", "message", "FILE", "resource", "dir", "fp", "out", "directory"], "fos": ["infaos", "FOs", "f\n", " fOs", "infOs", "FOS", "fOS", " f\n", " fOS", "Faos", "t\n", "F\n", "fOs", "infos", " faos", "infOS", "Fos", "faos"]}}
{"id1": "8164056", "id2": "22320592", "code1": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "code2": "    private static void loadDefaultPreferences() {\n        try {\n            URL url = ClassLoader.getSystemResource(\"OpenDarkRoom.defaults.properties\");\n            preferences.load(url.openStream());\n        } catch (FileNotFoundException e) {\n            log.error(\"Default preferences file not found\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"encode": ["enccod", "unode", "Encode", "uncod", "encquote", "unquote", "Encod", "enquote", "Enode", "Enquote", "enccode", "uncode", "encod", "enode"], "str": ["cur", "iter", "er", "f", "data", "char", "arr", "ctr", "rev", "st", "p", "enc", "div", "hex", "orig", "br", "text", "inner", "txt", "Str", "r", "e", "fr", "err", "strings", "temp", "this", "buffer", "sp", "hr", "code", "STR", "in", "result", "input", "exp", "string", "obj", "stri"], "buf": ["cur", "cb", "bd", "f", "data", "ff", "bu", "array", "buff", "aux", "Buffer", "proc", "bh", "binary", "bb", "b", "box", "vec", "br", "bp", "bag", "err", "rb", "buffer", "db", "ctx", "uc", "cf", "Buff", "conv", "agg", "cv", "pb", "ab", "wb", "src", "af", "fd", "uf", "cas", "sb", "result", "bf", "fp", "coll", "obj", "queue", "fb", "bc", "tmp", "pkg"], "md5": ["sha512", "md2", "sha5", " md3", " md4", "sha3", "dig5", "MD4", "MD5", " md512", "MD11", "MD512", "md512", "sha2", "md11", "dig512", " md2", "MD2", "md4", "dig11", " md11", "md3", "dig4", "MD3"], "bytes": ["pages", "sequence", "seq", "values", "data", "rows", "slice", "bs", "boot", "body", "ips", "outs", "ns", "units", "quarters", "codes", "binary", "ls", "cells", "items", "words", " elements", "text", "files", "bits", "content", "b", "bles", "parts", "lines", "steps", "letters", "pins", "pieces", "ings", "tes", "objects", "classes", "bis", "vs", "errors", "bps", "seconds", " strings", "es", "rules", "Bytes", "string"], "i": ["x", "ji", "f", "si", "ti", "ri", "slice", "m", "p", "j", "info", "pi", "ori", "hi", "I", "bi", "u", "b", "part", "multi", "di", "inner", "qi", "l", "val", "e", "o", "key", "abi", "d", "ci", "t", "h", "xi", "v", "oi", "ui", "li", "n", "uri", "ii", "io", "c", "in", "id", "index", "chi", "mu", "ai", "gi", "phi", "length"], "s": ["su", "sl", "f", "sg", "si", "ds", "m", "p", "ns", "ex", "os", "cs", "ls", "u", "b", "abs", "l", "e", "o", "its", "strings", "secret", "d", "S", "hs", "service", "ws", "t", "js", "spec", "h", "v", "signed", "n", "c", "in", "a", "es", "ss", "sb", "aws", "string", "fs"]}}
{"id1": "6742637", "id2": "9996334", "code1": "    private static List<Properties> findExtensions() {\n        URL url = null;\n        try {\n            List<Properties> extensions = new ArrayList<Properties>();\n            Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\");\n            while (res.hasMoreElements()) {\n                url = res.nextElement();\n                Properties prop = new Properties();\n                prop.load(url.openStream());\n                extensions.add(prop);\n            }\n            return extensions;\n        } catch (IOException ioe) {\n            String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm();\n            throw new RuntimeException(msg, ioe);\n        }\n    }\n", "code2": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "label": 0, "substitutes": {"findExtensions": ["getExtension", "findDistends", "getextensions", "findextensions", "getextends", "getExtends", "getExtensions", "getextension", "findAppends", "findExtension", "findextends", "findAppension", "findDistension", "findextension", "findAppensions", "findExtends", "findDistensions"], "url": ["ul", "connection", "sl", "ver", "f", "data", "loc", "name", "org", "remote", "ur", "gl", "web", "load", "rc", "base", "ssl", "log", "ls", "bb", "page", "zip", "l", "r", "bug", "err", "fr", "address", "pull", "Url", "service", "URL", "source", "image", "buffer", "feed", "api", "ch", "entry", "path", "lr", "cl", "config", "uri", "server", "io", "http", "file", "id", "impl", "src", "resource", "result", "bel", "link", "coll", "location", "rl", "re", "rel", "html", "element", "il"], "extensions": ["exencies", "exras", "xtension", "extras", "extension", "exensions", "fensions", "exension", "appras", "intension", "intensions", "intps", "fps", "extps", "fends", "Extencies", "appensions", "exends", "Extensions", "appencies", "xtends", "xtensions", "xtps", "exps", "intends", "Extras", "appension", "Extension", "extencies", "fension"], "res": ["rh", "mr", "vals", "ver", "RE", "rows", "RS", "rev", "results", "Rs", "ries", "rex", "vers", "ex", "os", "rc", "is", "req", "Res", "pres", "resolution", "rez", "r", "rs", "rem", "err", "fr", "RES", "rus", "rr", "ras", "ret", "hr", "ch", "js", "response", "request", "raw", "ps", "http", "ris", "details", "gr", "ress", "rss", "result", "resource", "es", "out", "ros", "re", "resp", "rest"], "prop": ["feature", "app", "ext", "f", "data", "opt", "point", "Prop", "comp", "p", "j", "info", "proc", "option", "fb", "class", "base", "feat", "pr", "part", "b", "term", "op", "val", "key", "style", "api", "project", "attr", "property", "config", "mp", "ps", "priv", "pos", "lit", "resource", "result", "properties", "def", "pro", "ref", "exp", "cp", "fp", "obj", "pb", "pac", "tmp"], "msg": ["Msg", "gm", "ext", "tag", "sg", "loc", "mag", "mg", "error", "reason", "s", "g", "m", "info", "mt", "str", "printf", "ug", "log", "status", "me", "format", "rag", "req", "mid", "ko", "text", "mb", "kg", "cmd", "err", "mn", "og", "urg", "comm", "eg", "db", "cfg", "bg", "gs", "agg", "gr", "title", "message", "bf", "ms", "string"]}}
{"id1": "17999474", "id2": "324679", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"getZipAsFile": ["getZipasfile", "getZipAtFile", "getZipAsDir", "getTempAsfile", "getTempAsFile", "getZipAtfile", "getTempAsPlace", "getTempAsDir", "getZipAtDir", "getZipasPlace", "getZipasDir", "getZipAsPlace", "getZipAtPlace", "getZipAsfile", "getZipasFile"], "digOb": ["signOb", " digob", "signObject", " digObject", "digOl", "dimOb", " digObj", "signob", " digOl", "signOB", "dimObject", "DigObj", "Digob", "ditob", "dimObj", "DigObject", "signObj", "DigOl", "digOB", "digObj", "ditOB", "ditObject", "DigOb", "ditOb", "digob", " digOB", "dimOl", "digObject"], "folderName": [" foldername", "foldPath", " folderDir", "foldName", "fileName", "foldername", "FolderName", "folderPath", "foldname", "packagePath", "packagename", "packageName", "foldInfo", "folderDir", "FolderPath", "FolderDir", "filePath", "fileInfo", "filename", "FolderInfo", " folderPath", "folderInfo", "Foldername", "packageDir"], "tmpFolder": ["tempDirectory", " temporaryManager", "tempManager", "tmpManager", "mpfolder", "tempfolder", "mpFolder", "tempDir", " temporaryFolder", "mpDir", "tmpfolder", " tmpDir", " tmpDirectory", "mpDirectory", " temporaryfolder", " tmpfolder", "tempFolder", "tmpDirectory", " tmpManager", "tmpDir", " temporaryDirectory"], "zip": ["pipe", "lock", "job", "sl", "f", "archive", "ze", "slice", "py", "seed", "install", "p", "download", "gz", "jar", "xml", "ie", "copy", "wrap", "clip", "cop", "bag", "flow", "temp", "zone", "proxy", "lib", "source", "pack", "lex", "z", "feed", "cf", "ulp", "url", " zipper", "io", "flat", "file", "folder", "ce", "ress", "upload", "ipped", "fp", " ZIP", "Zip", "json", "ip", "ignore", "tmp", "pkg"], "out": ["connection", "f", "socket", "sync", "info", "ex", "outs", "download", "gz", "gen", "os", "plain", "base", "log", "is", "copy", "page", "conn", "cache", "again", "output", "user", "loader", "box", "writer", "line", "err", "flow", "o", "client", "flush", "OUT", "temp", "this", "cli", "source", "z", "child", "path", "parent", "object", "url", "null", "io", "in", "file", "a", "upload", "result", "Out", "write", "obj"]}}
{"id1": "18097962", "id2": "5148212", "code1": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 0, "substitutes": {"getVersion": ["parseVersions", " getVersions", "parseVersion", "getVersions", "showRelease", "parseVERSION", "parseRelease", " getVERSION", "showVersion", "showVersions", "showVERSION", "getRelease", "getVERSION", " getRelease"], "version": ["feature", "ver", "name", "ception", "type", "versions", "python", "language", "install", "VERSION", "array", "latest", "info", "release", "status", "position", "model", "description", "format", "text", "output", "vert", "instance", "section", "content", "bug", "line", "vision", "secret", "comment", "source", "build", "image", "value", "project", "driver", "object", "v", "update", "server", "unit", "Version", "message", "action", "resource", "result", "cover", "string", "option", "element"], "version_url": ["versioningfile", "versioningurl", "version_URL", "version_feed", "ver_url", "versioningUrl", "version_file", " version_feed", "ver_Url", "ver_file", " version_str", "versioningresource", "ver_resource", "version_str", "version_resource", "version_Url", " version_URL"], "url": ["connection", "open", "sl", "f", "fl", "channel", "socket", "stream", "web", "download", "ll", "ssl", "base", "bb", "log", "ls", "conn", "page", "zip", "l", "fr", "client", "Url", "URL", "api", "cl", "server", "uri", "http", "c", "file", "www", "bel", "host", "resource", "rl"], "con": ["connection", "bin", "open", "cur", "login", "f", "cn", "cos", "channel", "socket", "un", "ins", " conn", "stream", "enc", "pub", "en", "pc", "plain", "log", "rc", "conn", "b", "win", "l", "IN", "Con", "ran", "init", "inc", "ch", "CON", "connect", "uc", "exec", "close", "conv", "Conn", "c", "http", "co", "coll", "ln", "Connection", "fc"], "in": ["reader", "bin", "connection", "isin", "login", "f", "data", "fac", "s", "ins", "hel", "pin", "stream", "cin", "ex", "In", "rec", "ssl", "kin", "is", "conn", "b", "inner", "again", "rin", "r", "din", "IN", "ini", "i", "init", "inc", "nin", "inn", "c", "file", "as", "impl", "lin", "on", "input", "out", "gin"], "inputLine": ["outputLine", "inputFile", "InputPart", " inputStream", "inputValue", "outputStream", " inputValue", "tempStream", "outputFile", "outputline", "inputL", "templine", " inputline", "outputPart", " inputPart", "InputLine", "InputValue", "rawLine", "tempLine", " inputFile", "InputL", " inputL", "Inputline", "inputStream", "InputFile", "rawline", "inputline", "rawValue", "inputPart", "rawL"]}}
{"id1": "3046085", "id2": "4852691", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"s": ["f", "data", "name", "g", "m", "services", "sets", "p", "ns", "str", "is", "sample", "w", "text", "b", "parts", "content", "r", "e", "strings", "i", "S", "source", "sound", "t", "path", "v", "speech", "gs", "n", "south", "in", "params", "a", "es", "ss", "sb", "joined", "string", "ses"], "tokenizer": [" tokener", " tokenner", "okener", " tokenization", "optimizer", " tokeniter", "okenzer", "generized", "logize", "okeniser", "generizer", "optiminer", "Tokenizers", "widgetizable", "tokenizers", "tunzer", "toolizer", "Tokenener", "Tokeniser", "initializable", "normalizer", " tokenzer", "normalizable", " tokenener", "tokenister", "tokener", "statizer", "Tokenized", "optimiser", "Tokeniner", "okenator", " tokenized", "initializer", "tunner", " tokenister", "widgetiser", "statator", "finer", "generize", "tokenner", "tooliner", "tokenener", "initialiser", "okenization", "tokeniser", " tokenizers", " tokenize", "tokenizable", "okenize", "normalize", "initialization", "okeniter", "widgetiner", "finizer", "Tokenizable", "finize", "tokenized", "initialize", "initialiner", " tokeniser", "statizers", "logizer", "okenister", " tokenator", "Tokener", "tunizer", "generiser", "tokeniner", "normaliner", "optimizable", "loginer", "tokenization", "okenner", "tokeniter", "logizable", "okenizers", "Tokenizer", "tokenzer", " tokenizable", "finizable", "okenizable", "statiter", "tuner", "okenener", "toolize", "Tokenister", "okenizer", "toolizable", "widgetizer", "tokenator", "okeniner", "Tokenize", "tokenize"], "title": ["meta", "genre", "profile", "tag", "song", "data", "name", "type", "audio", "layer", "theme", "Title", "label", "art", "bot", "album", "summary", "format", "description", "music", "team", "text", "source", "filename", "url", "author", "metadata", "owner", "prefix", "resource", "company", "string", "media", "editor", "license", "username"], "artist": ["genre", "tag", "song", "Artist", "master", "archive", "piece", "audio", "creator", "photo", "layer", "theme", "chart", "episode", "art", "winner", "album", "music", "video", "season", "alias", "patch", " artists", "track", "player", "source", "image", "filename", "author", "metadata", "prefix", "target", "cover", "voice", "media", "username"], "location": ["region", "tag", "loc", "layout", "photo", "audio", "language", "layer", "theme", "gallery", "album", "position", "description", "time", "content", "address", "lang", "image", "mobile", "path", "url", "level", "message", "Location", "motion", "length", "area", "media"], "rating": ["genre", "boarding", "audio", "training", "rank", "sharing", "album", "resolution", "description", "weight", "playing", "ranking", "scoring", "fps", "season", "random", "padding", "style", "live", "breaking", "game", "score", "rate", "repeat", "tracking", "alpha", "media", "rising"], "overplay": ["offledge", "offplay", "replay", "oplay", "overlay", "opplay", "overledge", "opload", "reledge", "reload", "offlay", "overload", "relay", "opledge", "offload"], "temp": ["tag", "data", "sequence", "name", "layout", "loc", "Temp", "current", "type", "pt", "stable", "body", "emp", "partial", "str", "base", "format", "music", "part", "cache", "txt", "content", "test", "track", "list", " temporary", "style", "source", "template", "testing", "path", "stage", " tmp", "tmp", "empty", "unit", "flat", "original", "prefix", "message", "tc", "fake", "string", "media", "font"], "tags": ["ids", "thumbnails", "images", "sections", "packages", "phones", "events", "relations", "words", "files", "features", "bots", "authors", "strings", "tracks", "assets", "archives", "stats", "stars", "dates", "notes", "products", "comments", "names", "styles", "Tags", "terms", "fields", "modules", "videos", "users", "bugs", "tests", "properties", "reports", "types", "resources", "plugins"], "bytes": ["pages", "values", "data", "blocks", "articles", "balls", "body", "ips", "outs", "units", "codes", "gets", "words", "les", "parts", "size", "bits", "files", "lines", "letters", "strings", "pieces", "tes", "objects", "notes", "comments", "errors", "bps", "keys", "params", "videos", "seconds", "es", "fee", "Bytes"], "hasher": ["haher", "hahers", "hanhr", "haveest", " hashed", "hadher", "hashher", "haveer", "haser", "Haser", "haer", "hanher", "havehandler", "haest", "Hashers", "hashandler", "hashhandler", "Hashed", " hashers", "hashers", "Hasest", "hashed", "hadumper", "haveumper", "haner", "hadest", " hashr", "Hasher", "hanest", "hashumper", " haser", "hasumper", "hashr", "haveher", "hashest", "hahed", "hasest", "havehr", " hasest", "hadhandler"]}}
{"id1": "2936678", "id2": "3767903", "code1": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getUniqueKey": ["getStringkey", "getStringLink", "makeuniqueHash", "getUniqueHash", "makeuniquekey", "makeUniqueKey", "getuniquekey", "getPrimaryLink", "makeUniquekey", "getPrimaryHash", "getStringKey", "getPrimarykey", "getuniqueHash", "getuniqueLink", "getUniquekey", "makeUniqueLink", "makeuniqueLink", "makeuniqueKey", "makeUniqueHash", "getStringHash", "getUniqueLink", "getuniqueKey", "getPrimaryKey"], "digest": [" digests", "digit", "dests", "DigEST", "Digid", "Digester", "uuester", "longest", "digested", "dester", "longEST", "genest", "genit", "digester", "digEST", " digid", "dest", "longester", " digEST", "Digested", "uuest", "uuid", "uuEST", "genEST", "longested", "digests", "Digit", " digit", "digid", " digested", "Digests", " digester", "Digest", "dested"], "md": ["meta", "df", "bd", "vd", "mag", "mg", "cd", "sd", "gb", "wd", " dd", "grad", "dd", "m", "mad", "ma", " MD", "mt", "gen", "dig", "ld", "alg", "mb", "mac", "hm", "cmd", "dm", "mn", "dc", "d", "sm", "MD", "km", "gd", "mo", "hash", "amd", "v", "mp", "rpm", "metadata", "mm", "pm", "dh", "ud", "mc", "nd", "pd", "mand", "hd", "med", "ad", "od", "Cmd", "de", "nm"], "timeVal": ["rateValue", "TIMEval", " timeValue", "timeval", " timeSeries", "Timeval", " timeLen", " timeval", "timeValue", "TimeBu", "rateVal", "rateBu", "TIMEValue", " timeBu", "rateLen", "TimeValue", "TimeVal", "TimeLen", "TIMESeries", "timeBu", "TIMEVal", "timeLen", "timeSeries", "TimeSeries"], "localHost": ["localhost", "localPort", "remotePort", " localPort", "privateAddress", "localAddress", "LocalMac", "privateHost", " localAddress", "localMac", "remoteMac", "remotehost", "LocalAddress", "Localhost", "remoteHost", "LocalHost", "privatePort", "remoteAddress", " localhost", "privatehost", "LocalPort", " localMac"], "randVal": ["randLen", "randomval", " randBu", "RandomVal", " randval", "randomVal", "randValue", " randLen", "RandBu", " randValue", "RandValue", "randomValue", " randStr", "randBu", "RandomValue", "Randomval", "randomLen", "randomBu", "randStr", "RandomLen", "randval", "RandStr", "randomStr", "RandVal"], "val": ["x", "msg", "abc", "sl", "vals", "values", "data", "loc", "seq", "reg", "gb", "grad", "range", "pt", "rev", "el", "dev", "enc", "Val", "ind", "bl", "base", "format", "vol", "pr", "az", "key", "temp", "ret", "test", "live", "db", "value", "eval", "v", "update", "unit", "pm", "id", "valid", "sel", "result", "res", "VAL", "ref", "addr", "string", "buf"]}}
{"id1": "7044153", "id2": "810342", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"sendExceptionToServer": ["sendExceptionWithserver", "sendExceptiontoHost", "sendExceptiontoServer", "sendExceptionWithServer", "sendErrorToserver", "sendExceptionToService", "sendExceptionAsHost", "sendExceptionAsserver", "sendErrorToService", "sendErrortoHost", "sendExceptionAsService", "sendExceptionToserver", "sendExceptionWithHost", "sendErrortoService", "sendErrortoserver", "sendErrorToServer", "sendErrorToHost", "sendExceptionAsServer", "sendExceptionToHost", "sendErrortoServer", "sendExceptiontoService", "sendExceptiontoserver", "sendExceptionWithService"], "server": ["email", "base", "erver", "ssl", "Server", "conf", "domain", "root", "client", "address", "test", "proxy", "service", "db", "port", "ser", "null", "http", " host", "prefix", "header", "host", "addr", "serv", "ip", "json"], "ex": ["x", "full", "su", "ext", "Ex", "ception", "error", "rupt", "aux", "nex", "rex", "event", "str", "Exc", "hex", "log", "class", "status", "base", " exc", "throw", "sex", "export", "err", "ax", "exc", "e", "temp", "acer", "pex", "lex", "example", "exec", "exit", "cl", "except", "fail", "con", "res", "Exception", "def", "exp", "none", "re", "ace", "tx", "obj", "EX"], "config": ["connection", "app", "cb", "ext", "Conf", "options", "settings", "proc", "rc", "log", "base", "text", "conf", "cmd", "bug", "etc", "client", "address", "console", "service", "cfg", "Configuration", "file", "Config", "json"], "prob": ["pebe", "peb", "Probe", "pebs", "Proj", "Probs", " probs", "probe", "proj", "Prob", "probs", " probe", " proj", "pej"], "dataSB": ["dataBL", "uiEl", "execBB", "offLB", "pSB", "innerLB", "DataFB", "errorBB", "contentsb", "nosb", "codeEB", "uiSB", "noSB", "workBB", "eventSB", "strLB", " dataEB", "controlBL", "dataRB", "datasb", "ifsb", "postLB", "ifSL", "postSB", "fileSB", "fullLB", " dataLB", "DataBL", "innersb", "cachesb", "filesb", " dataFB", "errorEB", "datLB", "DataBB", "contentLB", "cacheSB", "datSB", "codeSB", " dataBB", "execBL", "errorPB", "responseLB", "errorSL", "responseSB", "ifLB", "codeLB", "DataLB", "cacheLB", "controlsb", " dataBL", "eventSL", "execLB", "dataBs", "offsb", "fullBB", "DataSL", "DataHL", "DataOB", "loadBB", "datBB", "noSL", "codeRB", "fullBL", "loadSB", "Datasb", "dataOB", "loadsb", "defaultBB", "dataFB", "offSB", "dataEB", "datOB", "responseBL", "offBB", "uiLB", "eventLB", "defaultSB", "codeMB", "dataBB", "eventBB", "workSB", "loadLB", "codeHL", "contentOB", "codeBB", "postsb", "workPB", "innerSB", " dataPB", "fileLB", "DataRB", "errorOB", "strsb", "controlLB", "postSL", "dataSL", "DataSB", "defaultLB", "errorLB", "errorsb", "execsb", "pLB", " dataBs", " dataEl", " dataRB", " dataOB", "dataHL", "innerSL", "offSL", "DataMB", "noLB", "defaultsb", "dataLB", "controlBB", "ifSB", "fileSL", "errorSB", "pBs", " dataMB", "dataEl", "contentSB", "codesb", "codeBs", "codeFB", "codeEl", "strSB", " datasb", "controlSB", "responseBB", " dataHL", "execSB", "psb", " dataSL", "cacheBL", "dataPB", "workSL", "strSL", "dataMB", "fullSB"], "trace": ["trip", "profile", "data", "tri", "scale", "error", "type", "ctr", "span", "string", "array", "stack", "info", "xml", "log", "ptr", "cache", "r", "bug", "trans", "err", "e", "flow", "bean", "address", "temp", "race", "track", "buffer", "test", "atter", "t", " debug", " tracing", "details", "shadow", " traced", "message", "debug", "tr", "result", "out", "cover", "fake", "report", "ace", "tx", " traces", "strip", "runner", "ray"]}}
{"id1": "21642215", "id2": "807346", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "label": 1, "substitutes": {"addIDs": ["findID", "addLinks", "addIDS", "loadIDS", " addLinks", "findIDs", "findIDS", " addID", "loadLinks", "addID", "loadID", " addIDS", "loadIDs", "findLinks"], "row": ["reader", "job", "scan", "rows", "batch", "table", "head", "array", "info", "per", "ow", "copy", "user", "tab", "r", "query", "bug", "cell", "key", "column", "list", "entry", "feed", "builder", "group", "raw", "view", "post", "server", "up", "index", "ro", "Row", "tr", "item", "record", "ry", "result", "report", "col"], "name": ["connection", "ame", "start", "type", "filter", "info", "str", "description", "time", "size", "alias", "query", "key", "source", "image", "path", "filename", "Name", "number", "n", "file", "title", "search", "word", "prefix", "resource", "named", "string", "NAME", "username"], "in": ["reader", "bin", "lock", "iter", "login", "f", "doc", "it", "socket", "at", "container", "session", "s", "ins", "pin", "m", "stream", "string", "cin", "ex", "min", "In", "xml", "gen", "rec", "is", "ssl", "conn", "b", "inner", "with", "user", "again", "cache", "win", "l", "query", "r", "IN", "err", "din", "ini", "buffer", "i", "source", "image", "init", "inc", "nin", "path", "update", "n", "inn", "c", "as", "file", "http", "a", "ic", "resource", "input", "out", "record", "con", "token", "diff", "re", "gin", "serv"], "urlName": ["toolPath", "UrlName", "URLPath", "UrlStr", "fileName", "toolname", "UrlPart", "toolName", " urlname", "URLName", "urlPart", "filePart", "UrlPath", "URLname", "UrlType", "urlname", "filePath", "lStr", "filename", " urlType", "lName", "urlType", "lType", "lPath", " urlPath", " urlPart", "urlPath", " urlStr", "lname", "Urlname", "urlStr"], "url": ["reader", "connection", "open", "sl", "f", "org", "fl", "channel", "socket", "gl", "stream", "web", "base", "ssl", "b", "loader", "user", "l", "r", "client", "Url", "buffer", "URL", "source", "service", "image", "feed", "hub", "path", "uri", "server", "io", "http", "file", "resource", "input", "out", "bel", "link", " URL"], "inputLine": ["inputSel", "accessLine", "inputEmail", "inputEntry", "searchLine", "inputLin", "inputLink", "readSync", "inputL", "uploadLin", " inputline", "requestUrl", "accessSync", "execEmail", "inputWrite", "dataLink", "input\n", "readLook", "htmlline", "InputL", "Inputline", "typeLINE", " inputWrite", "issueSel", "InputFile", "indexEntry", "rawline", "requestString", "InputRoute", "readL", "indexLine", " inputBlock", " inputStream", "execline", "baseFile", "readline", "baseline", " inputSel", "formLINE", "responseLine", "againLine", "againWrite", "dataLin", "inputSource", " inputLINE", "requestLINE", "rawLine", "htmlString", "inputUrl", "dataSource", " inputLink", " inputString", "inputLINE", "requestline", "inputStream", "dataLo", "formLin", "issueLine", "inputline", "dataLine", " inputLin", "inputRoute", "output\n", "issueline", "dataLook", "dataWrite", " inputLo", "typeline", "againUrl", "updateline", "indexLINE", "uploadLine", "baseLine", "dataUrl", "readFile", "readLine", " inputEntry", " inputSync", "execLine", "updateLine", "execUrl", " inputRoute", "InputLine", "formline", "updateLin", " inputUrl", "indexSync", " inputL", "responseFile", "requestEmail", "rawFile", "requestLine", "inputString", " input\n", "issueLin", "typeLink", "rawL", "inputLook", "inputFile", " inputLook", "dataSync", "dataFile", "searchFile", "Input\n", "dataline", "searchL", "dataLINE", "searchStream", "typeLine", "htmlLine", "InputLo", "inputLo", "inputSync", "formLine", "accessEntry", "accessLINE", "InputStream", "uploadSel", "updateLINE", "InputSource", "InputLink", "htmlLINE", "InputLINE", "againLINE", "responseLINE", "dataBlock", "InputSync", "InputBlock", " inputFile", " inputEmail", "baseLINE", "dataRoute", "uploadline", "readLin", " inputSource", "inputBlock", "responseLink"], "score": ["feature", "gain", "error", "sc", "cost", "seed", "loss", "rank", "rice", "confidence", "grade", "winner", "status", "match", "Score", "time", "size", "weight", "ranking", "scoring", "key", "test", "count", "ner", "player", "live", " Score", "value", "game", "speed", "price", "level", "code", "width", "core", "rate", "index", "message", "result", "length", "fee", "fit"], "metaboliteID": ["metmboliteSize", "metmboliteId", "metmboliqueID", "metabolverseIN", "metabolidateName", "metabolriteID", "metabolitationID", "metaboliteId", "metabolizeID", "metabolidateInfo", "metaboliteType", "metmboliqueType", "metabolitableIDs", "metabolizeName", "metabolverseId", "metabololeIndex", "metabolitableType", "metovalriteName", "metabolitationId", "metabolizeInfo", "metovalriteIN", "metabololeSize", "metabolitationName", "metaboliciteID", "metaboliqueType", "metabolheticAddress", "metabolitableName", "metmboliteName", "metabolitionAddress", "metabololeName", "metaboliteIDs", "metabolitableSize", "metaboliteAddress", "metaboliqueIDs", "metaboliqueId", "metmbolitableName", "metaboliciteInfo", "metabolverseID", "metmboliteID", "metaboliteIN", "metabolriteAddress", "metovaliteName", "metabolheticID", "metovalriteID", "metabolriteSize", "metabolverseName", "metabolheticId", "metabolriteInfo", "metmboliqueId", "metabolitionID", "metovalriteId", "metabolheticIndex", "metovaliteAddress", "metmboliqueIDs", "metmbolitableSize", "metabolicizeScore", "metaboliciteName", "metovaliteId", "metabolitionIndex", "metaboliteInfo", "metabolidateID", "metabolriteIndex", "metabolriteName", "metovalriteAddress", "metabolriteScore", "metovalriteIndex", "metabolidateScore", "metabololeID", "metabolizeScore", "metabolitionId", "metovaliteIndex", "metaboliciteScore", "metabolriteIDs", "metmbolitableIndex", "metaboliteIndex", "metmboliteIndex", "metaboliteScore", "metabolitationIN", "metabolriteIN", "metaboliteName", "metabolicizeName", "metaboliqueID", "metovaliteID", "metmboliteIDs", "metabolitableIndex", "metabolriteType", "metabolicizeID", "metabolriteId", "metaboliteSize", "metabolitableId", "metabolitableID", "metmboliteType", "metovaliteIN", "metmbolitableID", "metabolicizeInfo"], "dataScore": ["dataRank", "numberGrade", " dataLevel", "dataWeight", " dataPath", "inputID", "DataRank", "styleWeight", "laPath", "DataSum", "numberRank", "dataPath", "videoType", "laSum", "DataMatch", "inputSize", "numberScore", " dataID", "dataMatch", "indexPath", "inputMatch", "dataLevel", "doubleType", "doubleRank", "numberLevel", " dataSource", "styleType", "DataSize", "doubleWeight", " dataRank", "doubleScore", "dataSum", " dataType", " dataSum", "inputSource", "indexID", "videoSize", " dataWeight", " dataMatch", "dataSize", "DataGrade", "dataGrade", "numberWeight", " dataGrade", "videoWeight", " dataSize", "dataSource", "laScore", "inputScore", "DataLevel", "dataID", "dataType", "DataScore", "videoScore", "DataPath", "laLevel", "indexScore", "styleSize", "styleScore", "inputPath", "indexSource", "numberType"], "data": ["missing", "extra", "error", "batch", "array", "body", "results", "change", "info", "div", "sample", "picture", "text", "size", "weight", "alpha", "content", "done", "zip", "key", "buffer", "style", "source", "ata", "image", "value", "map", "response", "ui", "number", "code", "empty", "split", "DATA", "message", "resource", "dat", "input", "result", "pad", "area", "json", "string", "media"], "molecularWeight": ["moleciumFlow", "molecularSize", "molesularWeight", "moleuralSize", "moleculeWidth", "molecularWidth", "mosecularWeight", "molellularWidth", "moleculeSize", "mosellularWidth", "moleciumWeight", "mosellularFlow", "moleuralWidth", "moleularWidth", "molesularSize", "moleculeWeight", "mosecularWidth", "molescularSize", "molescularWidth", "mosellularWeight", "molesularWidth", "molellularFlow", "molescularWeight", "moleularWeight", "moleculeFlow", "molecularFlow", "molellularWeight", "mosecularFlow", "moleciumWidth", "moleularSize", "moleuralWeight"]}}
{"id1": "10445819", "id2": "6558022", "code1": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "code2": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "label": 0, "substitutes": {"getReader": ["getreader", "getParser", "getStream", "readStream", "newStream", "newreader", "newParser", "readParser", "loadReader", "newReader", "loadStream", "loadParser", "readReader", "loadreader", "readreader"], "stream": ["reader", "open", "ream", "sl", "f", "data", "channel", "pool", "slice", "body", "cont", "sync", "clean", "control", "roll", "wrapper", "output", "instance", "content", "zip", "trans", "temp", "source", "feed", "child", "port", "object", "serial", "v", "url", "sw", "form", "document", "raw", "read", "null", "http", "file", "draft", "impl", "valid", "upload", "resource", "input", "coll", "host", "window", "draw", "Stream"]}}
{"id1": "1986417", "id2": "13516684", "code1": "    @Override\n    public void export(final Library lib) throws PluginException {\n        try {\n            new Thread(new Runnable() {\n\n                public void run() {\n                    formatter.format(lib, writer);\n                    writer.flush();\n                    writer.close();\n                }\n            }).start();\n            ftp.connect(host);\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                ftp.disconnect();\n                throw new PluginException(\"Unable to connect to FTP\");\n            }\n            ftp.login(user, pass);\n            ftp.pasv();\n            ftp.changeWorkingDirectory(dir);\n            ftp.storeFile(file, inStream);\n            ftp.logout();\n        } catch (SocketException e) {\n            throw new PluginException(e);\n        } catch (IOException e) {\n            throw new PluginException(e);\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 0, "substitutes": {"export": [" writer", "f", "handler", " exports", "output", "work", "fn", " fn", " reporter", " transform", "process", " report", "exec", " output", "io", " upload", "file", "function", "module", "fp", "print", "write"], "lib": ["reader", "bin", "data", "LIB", " module", "dl", "language", "local", "os", " library", "library", "plugin", "ld", "lc", "log", "loop", "loader", "l", " fn", "fn", "val", "Lib", "ruby", " Lib", "lang", "ler", " Library", "db", "ctx", "ino", "url", "config", "server", "browser", "io", "Library", "file", "script", "module", "src", " script", "dll", "editor", " libraries"]}}
{"id1": "1362", "id2": "2199604", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubblerCompare", "bubblesOrder", "bubblerOrder", "ubbleSort", "ubbleOrder", "bubblerSort", "ubblingOrder", "ubblesort", "ubblingsort", "ubblingSort", "ubblingCompare", "bubblesort", "bubbleOrder", "bubblessort", "bubblesCompare", "bubblingCompare", "bubblingSort", "bubblersort", "bubblesSort", "bubblingsort", "ubbleCompare", "bubblingOrder", "bubbleCompare"], "a": ["active", "f", "data", "sup", "oa", "at", "something", "s", "ack", "m", "aa", "aaa", "ma", "array", "p", "aux", "auto", "na", "any", "ae", "another", "ama", "ans", "u", "abs", "b", "all", "am", "A", "img", "access", "apps", "aj", "l", "work", "e", "o", "la", "va", "address", "d", "list", "ata", "ba", "empty", "aw", "sa", "an", "ab", "as", "c", "ga", "index", "result", "tta", "ad", "area", "alpha", "ac", "au"], "swapped": ["swoped", "Swoped", " swaped", "wap", "swap", "flapped", "Swaped", "Swap", "wapping", "swaps", " swapping", "rewaps", " swap", "waped", "Swapping", "swapping", " swaps", "rewaped", "rewapping", "swaped", "flap", "floped", "rewapped", "waps", "rewap", "flapping", "Swapped", "rewoped", "wapped"], "i": ["x", "f", "y", "sup", "si", "it", "start", "ti", "ri", "mini", "iv", "m", "p", "j", "info", "pi", "k", "ori", "ind", "ie", "ix", "hi", "I", "bi", "u", "b", "ami", "di", "multi", "qi", "l", "fi", "e", "key", "ini", "d", "anti", "ci", "init", "api", "h", "ki", "xi", "v", "mi", "ui", "oi", "next", "li", "uri", "ii", "io", "in", "ni", "id", "index", "iu", "module", "eni", "ai", "gi", "adi", "uni", "ip"], "tmp": ["x", "f", "sup", "opp", "stuff", "addr", "qq", "m", "emp", "st", "p", "j", "ie", "tv", "bb", "prev", "part", "b", "yy", " ff", "alpha", "txt", "front", "pre", "angle", "dest", "pp", "temp", "test", "xxx", "cmp", "vt", "mmm", "t", "tt", "v", "mp", "amp", "tc", "kk", "append", "pad", "area", "foo", "obj", "nb"]}}
{"id1": "841724", "id2": "23370621", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrap", "readandRewrites", "readAndRewwrite", "readandrewrites", "readandRewrap", "readAndSwwrite", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readAndRebrites", "readAndRewrites", "readAndrewrites", "readandrewrite", "readandRewwrite", "readandrewrap", "readAndRebrite", "readAndSwrites", "readAndSwrite", "readAndRebrap", "readAndrewrap", "readandrewwrite", "readAndRewrap", "readandRewrite"], "inFile": ["inputFile", "outFiles", "oldFile", "loginfile", "oldFilename", "infile", "inputfile", "outfile", "loginFile", " inSourceFile", "loginFiles", "inSourceFile", "outSourceFile", "loginFilename", "inFiles", "InFiles", " infile", "InSourceFile", "oldfile", "oldFiles", "inputFiles", "outFilename", " inFilename", "inFilename", "InFile", "Infile", " inFiles", "inputFilename"], "outFile": ["processFILE", "newFile", "newStream", "Outfile", " outStream", "thisFILE", "outDir", "thisfile", "outfile", " outDir", "outStream", "outputFile", "processFile", "processPlace", "offFile", "processFilename", "outputPlace", "offFilename", " outfile", "OutStream", "newDir", "outputFILE", "outputFilename", "thisFile", "outPlace", "exFILE", "exFilename", "newfile", "exFile", "outFilename", "outputfile", "offPlace", "OutDir", "outFILE", "thisFilename", "exfile", "OutFile", "offFILE"], "iis": ["iais", "Iais", " iIs", "iiss", "Iis", "IIS", " iiss", "iiIs", "iniis", "iniiss", " iris", "iniIs", "ciris", "iniIS", "iiis", "ciIs", "iiris", "iniris", "Iiss", "iiiss", " iIS", "ciIS", "iiIS", "iIS", "iris", "ciis", "iIs", "ciiss", "ciais", " iais"], "dcmParser": ["dcrParser", " dpmPar", "dmParser", "dcmJar", "dcrPar", "DcmInstallation", "dmissionReader", "dpmPlugin", "dmissionParser", " dpmReader", "dkmParser", "dcrLoader", "dhemInstallation", " dcrReader", " dcmReader", "dmcJar", "dmissionPlugin", "dcmPar", "dpmInstallation", "dcmHandler", "dpmHandler", " dpmparser", "dmLoader", "dpmPolicy", "dpmParser", "dcmPlugin", "dmmParser", " dcmLoader", " dpmJar", "dcmLanguage", "DcmJar", "dcrPlugin", " dpmarser", " dcmparser", "dmcPar", " dcmPar", "dmcParser", " dcrPlugin", "dkmPolicy", "dpmPar", "dCMLoader", "dpmLoader", "dbmPlugin", "dCMParser", " dpmHelper", "fcmReader", "dbmParser", "dCMHandler", "fpmReader", "dcrReader", "dkmPlugin", " dcmPolicy", "fpmHandler", "fcmparser", "dpmarser", "dmmparser", " dcmarser", "dbmPolicy", "dpmLanguage", "dcrJar", "dmoduleJar", "dmoduleparser", " dpmParser", "fcmHandler", "dmcarser", "dpmReader", "dcmPolicy", "dcmLoader", "dcmHelper", " dcmJar", " dcmPlugin", " dpmPlugin", "dpmparser", "dmoduleReader", "dmPlugin", " dcmHelper", "dhemJar", "dcmarser", "fpmparser", "dbmHelper", " dpmLoader", " dpmLanguage", "dmReader", " dcrLoader", "dcmparser", " dpmPolicy", "dmissionLanguage", "dhemParser", "dmmLoader", "dmodulePlugin", "dcrarser", "fpmParser", "dCMReader", "dCMPlugin", "fcmParser", "dCMparser", " dcmLanguage", "dcmInstallation", "dmoduleParser", " dcrParser", "DcmReader", "dhemReader", "dpmHelper", "dpmJar", "dmmPlugin", "dcmReader", "DcmParser", "dkmHelper"], "ds": ["cdn", "df", "ts", "asi", "data", "iss", "vals", "eps", "s", "icks", "bs", "dd", "ins", "services", "sync", "session", "ns", "da", "Ds", "utils", "os", "sys", "cs", "ld", "ls", "ys", "di", "conn", "parts", "is", "rs", "drivers", "dds", "Db", "dr", "dc", "d", "ras", "nas", "gd", "db", "points", "qs", "js", "ws", "tes", "DS", "Os", "xs", "uds", "vs", "gs", "ays", "ps", "details", "ils", "ants", "des", "src", "amps", "ros", "dat", "ss", "pd", "ads", "tx", "ks", "dt"], "pdReader": ["hdLoader", "pdRunner", "pbReader", "hdStream", "ddRunner", "dsreader", "dsReader", "ddLoader", "pdLoader", "pdStream", "pcLoader", "xdReader", "pcReader", "dsRead", "pbRunner", "pdreader", "pcWriter", "ddStream", "ddReader", "hdreader", "xdreader", "dsLoader", "xdWriter", "pdRead", "pbLoader", "pcRead", "hdWriter", "hdRead", "xdRead", "pbStream", "hdRunner", "hdReader", "dsWriter"], "out": ["lock", "ext", "login", "data", "doc", "name", "at", "down", "outs", "ssl", "w", "err", "flow", "o", "dot", "cli", "oder", "exec", "url", "default", "null", "io", "as", "co", "exp", "over", "point", "later", "session", "auto", "to", "sys", "page", "cache", "conn", "inner", "output", "term", "her", "key", "client", "builder", "outer", "parent", "order", "group", "code", "up", "word", "result", "director", "copy", "model", "with", "part", "line", "writer", "temp", "external", "lib", "image", "inc", "store", "Out", "obj", "device", "full", "connection", "manager", "s", "dev", "array", "sync", "layer", "ex", "gen", "base", "user", "again", "img", "password", "OUT", "list", "db", "child", " in", "object", "pass", "net", "in", "file", "diff", "write"], "dcmEncParam": ["dcmEstPar", "dcmDecPart", "dcmEncParameter", "dcmEncPart", "dcmElType", "dcmEnParameter", "dcmArchParameter", "dcmEnPar", "dcmDecArg", "dcmEnType", "dcmEstParameter", "dcmEstParam", "dcmArchArg", "dcmSecPart", "dcmDecParameter", "dcmEnPart", "dcmDecType", "dcmDecParam", "dcmEncPar", "dcmSecPar", "dcmSecParam", "dcmEncArg", "dcmEncType", "dcmElPar", "dcmEstType", "dcmElParameter", "dcmDecPar", "dcmEnArg", "dcmSecType", "dcmEnParam", "dcmArchParam", "dcmElParam"], "pdWriter": ["dsWrite", "PDWriting", "dpWriter", "pdWriting", "dsReader", "hdWrite", "dpWrite", "htWriting", "PDReader", "ddWrite", "dsOutput", "hdOutput", "PDWrite", "ddReader", "dpReader", "htReader", "pdOutput", "ddWriter", "pdWrite", "htWrite", "ddOutput", "PDWriter", "htWriter", "hdWriter", "hdReader", "dsWriter", "dpWriting"]}}
{"id1": "350482", "id2": "15904772", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doversioncheck", "doBuildCheck", "doReleasecheck", " doVersionWork", "doVersionWork", " doBuildWork", "doversionTest", " doReleaseCheck", " doBuildcheck", " doBuildCheck", "doReleaseTest", " doVersioncheck", "doReleaseCheck", " doVersionTest", "doVERSIONcheck", " doReleasecheck", "doBuildWork", "doVersionTest", " doBuildTest", "doVERSIONTest", "doBuildTest", " doReleaseTest", "doBuildcheck", "doVERSIONWork", "doReleaseWork", "doVersioncheck", "doversionCheck", "doVERSIONCheck"], "view": ["full", "reader", "lock", "app", "layout", "self", "q", "edit", "widget", "session", "el", "body", "change", "div", "View", "event", "screen", "vis", "model", "page", "cache", "box", "can", "l", "e", "display", "cell", "see", "client", "this", "row", "buffer", "show", "comment", "style", "image", "block", "port", "gui", "request", "object", "v", "ui", "update", "config", "form", "server", "http", "views", "sel", "input", "window", "out", "VIEW", "accept", "html", "use", "gu"], "url": ["connection", "open", "sl", "f", "socket", "channel", "stream", "web", "base", "ssl", "log", "ll", "bb", "blog", "user", "loader", "zip", "l", "client", "address", "Url", "buffer", "URL", "source", "build", "image", "service", "lib", "hub", "path", "server", "uri", "browser", "http", "file", "resource", "input", "bel", "host", "string", "ob"], "in": ["reader", "isin", "sin", "login", "data", "socket", "s", "ins", "stream", "cin", "In", "binary", "is", "b", "inner", "rin", "win", "din", "IN", "ini", "buffer", "i", "source", "init", "inc", "nin", "bis", "n", "inn", "file", "as", "lin", "resource", "input", "out", "con", "ac", "gin"], "bin": ["reader", "border", "lock", "sin", "data", "socket", "pin", "body", "cin", "bn", "bot", "binary", "log", "kin", "bb", "bi", "inline", "part", "b", "loader", "inner", "win", "din", "IN", "ruby", "abi", "buffer", "lib", "run", "init", "spin", "browser", "inn", "oin", "file", "lin", "fin", "input", "out", "record", "con", "ln", "gin", "nb"], "line": ["job", "le", "data", "name", "lo", "el", "layer", "non", "ge", "load", "str", "definition", "letter", "log", "base", "inline", "lc", "rule", "page", "b", "text", "part", "model", "l", "e", "cell", "lines", "key", "lf", "ine", "row", "i", "source", "comment", "style", "block", "entry", "parse", "Line", "band", "object", "no", "cl", "code", "pass", "unit", "nl", "pe", "file", "split", "up", "LINE", "word", "valid", "message", "id", "lin", "link", "home", "day", "string", "ip", "end", "look", "site"], "develBuild": ["dellRelease", "deVELBuilt", "deelBuild", "deviousBuild", "deploybuild", "desvenBuilt", "DEvelBuilt", "desvenBuild", "desvenRun", "develbuild", "deelRelease", "desvelBuild", "deVELRun", "dewardbuild", "desvelRun", "desvelBuilt", "desvenBuilder", "deelRun", "develBuilder", "desvenbuild", "DEVELBuilt", "devenbuild", "devenRun", "DEVELBuilder", "DEVELBuild", "devenRelease", "deVELBuild", "deployBuilt", "desvelBuilder", "DEVELbuild", "deviousbuild", "deelBuilder", "DEvelbuild", "deVELbuild", "develRun", "deviousBuilt", "deployRun", "develRelease", "dellRun", "desvelRelease", "devenBuilder", "deployBuilder", "dewardBuild", "devenBuilt", "dellBuilder", "dellBuild", "DEvelBuild", "dewardBuilt", "deployBuild", "desvenRelease", "dewardBuilder", "develBuilt", "desvelbuild", "devenBuild", "deVELBuilder", "DEvelBuilder"], "stableBuild": ["stableVersion", "compatibleBuild", "validbuild", "latestBuild", "baseBuilder", "securebuild", "staticBuilder", " stableVersion", "prettyBuild", "baseBuild", "validBuilder", "basebuild", "prettyVersion", "baseVersion", "compatibleBuilder", "staticbuild", "latestbuild", "prettyBuilder", "prettybuild", "staticBuild", "validBuild", " stablebuild", " stableBuilder", "compatiblebuild", "stablebuild", "secureBuild", "stableBuilder", "latestBuilder", "secureBuilder"]}}
{"id1": "14168494", "id2": "12417893", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["transferClass", " copiedClass", "copyFiles", " copyfile", " copiedfile", "transferFile", "transferfile", " copyFiles", " copiedFile", "transferFiles", "copyClass", " copyClass", "copyfile", " copiedFiles"], "dest": ["data", "loc", "name", "sup", "true", "later", " destination", "st", "destroy", "comb", "class", "orig", "output", "txt", "done", "dist", "temp", "this", "d", "source", "path", " Dest", "transfer", "null", "file", "wb", "Dest", "resource", "target", "out", "dir", "desc", "obj", "tmp"], "src": ["bin", "sl", "sin", "cb", "loc", "sup", "master", "gb", "ds", "s", "sc", "slice", "stream", "st", "sync", "inst", "download", "rc", "ssl", "copy", "rob", "img", "dist", "rb", "sq", "source", "sub", "storage", "filename", "url", "config", "sit", "file", "split", "Dest", "upload", "sel", "sb", "target", "tmp"], "srcChannel": ["sourceChan", "rcConnection", " srcStream", " srcButton", "rcCh", "destConnection", "srcSection", " srcchannel", "rcButton", "distStream", "distChannel", "destChan", "sourceButton", "sourceChannel", "distChan", "rcChan", " srcConnection", "rcSection", "srcCh", "srcChan", "rcStream", "inputConnection", " srcCh", "srcStream", "rcchannel", "srcButton", "sourcechannel", "destChannel", "srcchannel", "inputChannel", "rcChannel", "inputchannel", "destchannel", " srcSection", "distCh", "inputSection", "srcConnection", " srcChan"], "dstChannel": [" dstchannel", "Dstchannel", "drcchannel", "drcContext", "dstsConnection", " dstChan", " drdContext", "dstConnection", "drcChannel", "dstchannel", "dDestChannel", " drdchannel", "ddestConnection", "dsrcVideo", "drdchannel", "dstVideo", "dDestchannel", "drcChan", " dstsStream", " drdChan", "drdChannel", "DstChannel", "ddestChannel", "dstsStream", "Ddestchannel", " dstschannel", "dstContext", "dDestConnection", "ddestContext", "ddestChan", " dstStream", "ddestchannel", " dstConnection", "DstVideo", "DdestChannel", "dstChan", " dstsChannel", "DdestVideo", " drdChannel", "dDestStream", "ddestStream", "dsrcChannel", "drdContext", "dstschannel", "dstsChannel", "dsrcchannel", " dstContext", "ddestVideo", " dstsConnection", "drdChan", "dstStream", "drcVideo"]}}
{"id1": "10214218", "id2": "18217985", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static String fromHtml(URL url, String defaultEncoding, boolean overrideEncoding) throws IOException, BadDocumentException {\n        URLConnection conn = url.openConnection();\n        String contentType = conn.getContentType();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) {\n            int i = contentType.indexOf(\"charset\");\n            if (i >= 0) {\n                String s = contentType.substring(i);\n                i = s.indexOf('=');\n                if (i >= 0) {\n                    s = contentType.substring(i + 1).trim();\n                    encoding = s.replace(\"\\'\", \"\").replace(\"\\\"\", \"\").trim();\n                    if (encoding.equals(\"\")) {\n                        encoding = defaultEncoding;\n                    }\n                }\n            } else {\n                encoding = defaultEncoding;\n            }\n        }\n        String expected = \"text/html\";\n        if (contentType == null) {\n            DefaultXMLNoteErrorHandler.warning(null, 90190, \"Returned content type for url.openConnection() is null\");\n            contentType = expected;\n        }\n        int index = contentType.indexOf(';');\n        if (index >= 0) {\n            contentType = contentType.substring(0, index).trim();\n        }\n        if (!contentType.equals(expected)) {\n            String msg = translator.translate(\"The content type of url '%s' is not '%s', it is '%s'\");\n            throw new BadDocumentException(String.format(msg, url.toString(), expected, contentType));\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        return fromHtml(in, encoding);\n    }\n", "label": 0, "substitutes": {"encrypt": [" enccrypt", " encipher", " encress", "encipher", "enrypt", "encress", "enress", "enipher", "deccrypt", "decress", "decipher", "enccrypt", "decrypt"], "plaintext": [" plainsource", "mainText", "anytext", " plaintxt", "battxt", "batText", " plainstruct", "anystruct", "maintext", "plaintxt", "plainsource", " plainText", "mainstruct", "battext", "plainText", "anyText", "batsource", "plainstruct", "batstruct", "anytxt", "mainsource"], "md": ["meta", "bd", "data", "mag", "mg", "wd", "mad", "dd", "m", "ma", "em", " MD", "mt", "mage", "arm", "dig", "ld", "kg", "mb", "am", "mac", "hm", "cmd", "dm", "key", "dr", "sm", "d", "MD", "db", "mo", "mod", "amd", "mp", "metadata", "mm", "pm", "dh", "mu", "message", "sha", "cm", "mc", "ms", "pd", "mand", "ad", "od", "nm", "pg", "Cmd"], "raw": ["full", "data", "ack", "array", "dec", "good", "clean", "RAW", "enc", "load", "hex", "binary", "rc", "words", "Raw", "instance", "text", "bytes", "content", "wrapper", "rew", "row", "buffer", "block", "image", "pack", "feed", "serial", " RAW", "null", "ng", "original", "wave", "unsigned", "message", "input", "initial", "unknown", "none", "buf"], "hash": ["rh", "data", "ha", "hed", "version", " hex", "array", "hex", "base", "log", "cache", "mac", "her", "kh", "ruby", "key", "secret", "abi", "block", "image", "response", "h", "url", "sum", "code", "ashes", "id", "message", "sha", "header", "ash", "Hash", "alpha", "html", "sh"]}}
{"id1": "19934218", "id2": "15351863", "code1": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"doCrypt": ["murMac", " runDec", "DoExt", " runMac", "murExt", " runExt", " runCrypt", "DoDec", "murCrypt", " doExt", "murDec", "DoMac", "DoCrypt", " doMac", " doDec"], "text": ["connection", "ext", " TEXT", "data", "name", "seed", "str", " Text", "hex", "binary", "class", "letter", "format", "contract", "txt", "content", "EXT", "password", "key", "this", "secret", "buffer", "crypt", "source", "image", "value", "Text", "editor", "path", "struct", "object", "pattern", "context", "url", "config", "code", "in", "word", "message", "token", "TEXT", "input", "length", "string", "obj", "font"], "UnsupportedEncodingException": ["UnsupportedEncoderException", "UnsupportedEncasingException", "UnsupportedEncodedEx", "UnsupportedEncasingEx", "UnsupportedEncodingError", "UnsupportedEncodedException", "UnsupportedEncodingEx", "UnsupportedEncodedError", "UnsupportedEncoderError", "UnsupportedEncasingError", "UnsupportedEncoderEx"], "md": [" Md", "bm", "meta", "df", "bd", "vd", "data", "mag", "mg", "rm", "wd", "sd", "method", "dd", "m", "body", "mad", "ma", " MD", "mt", "mode", "me", "dig", "ld", "mb", "am", "mac", "hm", "cmd", "dm", "mn", "dr", "d", "MD", "map", "gd", "mo", "mod", "hash", "amd", "mp", "code", "metadata", "mm", "pm", "valid", "message", "ud", "sha", "bf", "mc", "def", "ms", "pd", "mand", "ad", "hd", "od", "nm", "Cmd"], "sha1hash": ["sha2h", "SHA1hex", "sha256Hash", "sha2hex", "sha1sum", "sha1hex", "md6hash", "SHA2sha", "sha6h", "md1sha", "SHA1sha", "SHA2h", "sha6hex", "md6h", "shaonehash", "SHA2Hash", "sha6hash", "sha256h", "md6hex", "sha5Hash", "sha0sum", "sha0hex", "shaonehex", "sha5h", "SHA2hex", "SHA1sum", "sha5hex", "SHA1h", "sha256sum", "sha6sha", "md6sha", "sha2sha", "sha0hash", "SHA1Hash", "sha2sum", "sha1sha", "sha1h", "SHA1hash", "shaoneh", "sha2Hash", "SHA2sum", "shaonesha", "sha1Hash", "sha0sha", "SHA2hash", "sha5hash", "md1hex", "sha256sha", "sha2hash", "sha256hex", "md1hash", "sha256hash", "md1h", "sha5sha"]}}
{"id1": "12066447", "id2": "13783549", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"truncate": ["truncational", "truncator", "autatenator", "trunate", "autuncation", "trrenation", "tratenate", "autuncate", "autatenational", "trrenational", "tratenator", "trrenator", "tratenational", "autatenation", "truncation", "trunation", "autatenate", "autuncational", "tratenation", "trunator", "autuncator", "trunational", "trrenate"], "file": ["full", "connection", "f", "data", "get", "name", "it", "File", "current", "archive", "handler", "type", "stream", "body", "info", " File", "one", "local", "log", "base", "class", "format", "model", "page", "cache", "binary", "future", "files", "time", "zip", "l", "line", "single", "e", "plus", "address", "this", "source", "image", "db", "ile", "or", "path", "parent", "object", "filename", "url", "document", "uri", "per", "io", "http", "function", "folder", "FILE", "resource", "out", "fp", "queue", "directory", "string"], "backupRoot": ["backdownRoot", "Backdownroot", "backbackDir", "backbaseroot", "backUpFolder", "backUproot", "BackureRoot", "BackupDir", "BackbackFile", "backbaseDirectory", "frontdownRoot", "BackupHome", "backflowDir", "backbackFile", "frontdownDir", "backUpRoot", "BackupRoot", "backflowRoot", "BackdownRoot", "backuproot", "backureDirectory", "BackureHome", "backflowroot", "backupsFolder", "backUpDir", "backbackHome", "frontuproot", "frontdownroot", "BackbackRoot", "backflowFile", "BackdownDirectory", "backureRoot", "backupsDir", "backbaseRoot", "backupsroot", "backdownDirectory", "backbackroot", "backdownPath", "backureDir", "backupsRoot", "backupDirectory", "BackdownPath", "backdownroot", "backbackDirectory", "BackureDir", "BackureDirectory", "backdownFolder", "frontupFolder", "backbasePath", "frontupRoot", "backupPath", "Backbackroot", "backupDir", "Backuproot", "BackupDirectory", "backupHome", "backupsDirectory", "BackbackDir", "backupFile", "backupFolder", "backdownFile", "frontupDir", "backdownHome", "backdownDir", "BackupPath", "frontdownFolder", "BackupFile", "backbackRoot", "backureHome", "backupsPath"], "df": ["f", "data", "DF", "dl", "ds", "dd", "pdf", "raf", " def", "dn", "da", "fe", "xf", "dict", "format", "di", "fn", "dm", "fr", "tf", "flow", "md", "dc", "d", "CF", "db", "cf", "dp", "deb", "dq", "io", "func", "af", "fd", "bf", "sf", "fp", "def", "pd", "de", "fc", "fb", "fs", "dt"], "date": ["x", "open", "tag", "data", "name", "version", "modified", "complete", "create", "type", "D", "m", "created", "sync", "j", "ge", "min", "str", "log", "atom", "rule", "format", "days", "Date", "time", "output", "ale", "year", "bug", "work", "pre", "updated", "back", "d", "style", "db", "value", "dates", "age", "form", "stage", "url", "update", "code", "pe", "ate", "dose", "module", "valid", "message", "dat", "input", "out", "custom", "diff", "fee", "day", " Date", "re", "string", "use", "dt"], "zipFile": ["zFiles", "ZipFile", "sqlSection", "ZipEntry", "zipSection", "zipfile", "ressSection", "zfile", "ressfile", "zipFiles", "sqlFile", " zipFiles", "sqlfile", "zModel", "zFile", "ressModel", "ZipFiles", "Zipfile", "zipEntry", "sqlModel", " zipfile", "zipModel", "zSection", " zipEntry", "ressFile", "zEntry"], "zos": ["webkit", "fits", "ZA", "cos", "las", "zy", "eros", "zona", "bes", "liquid", "cash", "robe", "budget", "asio", "bos", "hess", "settings", "outs", "gz", "os", "zero", "lins", "ssl", "kos", "ls", "zl", "zag", "css", "rez", "her", "zip", "ops", "zon", "jas", "tz", "address", "nz", "proxy", "iffs", "zh", "uz", "closure", "z", "zn", "js", "zer", "zb", "zx", "zik", "exit", "zzy", "han", "zen", "dylib", "zi", " sands", "nox", "osi", "ozo", "ils", "inos", "zar", "bitcoin", "ros", "zes", "chini", "los", "forge", "zan", "zo", "obb", "ses", "dos"], "fis": ["fiss", "fits", " fris", "infiss", "fiz", "Fisl", "bos", "rafiss", "fias", " fos", "Fias", "viz", "flis", "vils", "infils", "infids", "vis", "infiz", "fisl", "infits", " fisp", "vits", "Fis", "lids", "fils", "fliss", "Fiss", "rafris", "flids", "bis", "fisp", " fiz", "fids", "flris", " fits", " fiss", "infias", "bisl", " fils", " fisl", "fris", "rafis", "Fos", "flias", "flisp", "Fris", "rafias", "Fisp", "lias", "liss", "lis", "biss", "fos", " fias", "infis"], "entry": ["reader", "offset", "extra", "data", " Entry", "si", "it", "card", "archive", "auto", "ries", "info", "se", "ge", "array", "event", "letter", "ie", "per", "lc", "add", "Entry", "term", "her", "zip", "r", "ace", "and", "e", "cell", "key", "address", "row", "comment", "style", "image", "z", "feed", "or", "ion", "next", "ui", "uri", "server", "the", "index", "ry", "cel", "obj", "record", "zo", "exp", "so", "de", "element"], "buffer": ["reader", "border", "uffer", "iter", "sequence", "data", "channel", "vector", "batch", "slice", "reference", "seed", "layer", "buff", "Buffer", "binary", "position", "bb", "page", "cache", "b", "bytes", "writer", "shape", "address", "flush", "FFER", "row", "padding", "comment", "feed", "transfer", "number", "server", "null", "memory", "wave", "beta", "queue", "header", "result", "pad", "available", "length", "device", "buf"], "readed": ["inted", "readled", "bootered", "readable", "inputled", "readended", " Readable", " Readed", "texted", "intended", "textended", "readED", " readED", "bootED", " readled", " Readned", "booted", "intED", " readended", " readized", "intized", " Readled", "readned", "readered", " ReadED", "inputED", "inputed", " readable", " readered", "readized", "inputned", " readned", "textED", "textized", "bootable", " Readered"]}}
{"id1": "14688886", "id2": "16388708", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"populateResources": ["popractResources", "compulateFiles", "populateFiles", "compulateRelations", "popractFiles", "compureResource", "popureFiles", "compureFiles", "popractRelations", "compulateResource", "compureResources", "popureResources", "compureRelations", "poputeResources", "popureRelations", "popureResource", "compulateResources", "poputeRelations", "popractResource", "populateResource", "poputeResource", "poputeFiles", "populateRelations"], "templates": ["Templ", "temeters", "tompl", "temples", "templateples", " temures", "templateplates", "typlate", "temures", "typs", "temens", "tomplate", "Temens", "templ", "filplates", " templ", "Temeters", "filures", "templateps", "promplate", "filens", "filpl", "tempplate", "stempl", "typl", "stemples", "Temures", "Template", "stemps", "tempplates", "template", "prometers", "temps", "temppl", "Temples", "Temps", "tomplates", "typlates", "tometers", "templatepl", "promplates", " temens", "tempps", "Templates", "prompl", "stemplates"], "url": ["connection", "job", "sl", "f", "data", "name", "fl", "channel", "email", "el", "download", "xml", "pl", "base", "ssl", "html", "page", "href", "r", "l", "e", "address", "Url", "service", "URL", "source", "image", "template", "entry", "feed", "buffer", "path", "filename", "object", "pattern", "config", "uri", "server", "route", "http", "file", "resource", "host", "link", "location", " URL", "string", "ob", "il"], "fileName": ["filenameLength", " fileType", "resourcePart", "fName", "resourcePath", "fileDirectory", "FILESystem", "FileDirectory", "sourceString", "stringType", "stringName", "FILESync", " filename", " fileDir", "FILETime", "fileString", "FileType", " fileLength", "modelSystem", "fileSystem", " fileString", "Filename", " fileFull", "FileDir", "filePath", "folderPart", "FILELocation", "sourceLength", "resourceName", "stringDirectory", " fileSystem", " fileSync", "filenameName", "FileString", "fileType", "FileFull", "FileInfo", "foldername", "folderPath", "filenameType", "fileKey", " filePart", "fileSync", "filePart", "fileLocation", "fKey", "filenamename", "filenameFull", "fileInfo", "fileFull", "fname", "fileTime", "modelName", "objectTime", " fileTime", "filenameString", " fileInfo", " fileLocation", "objectSync", " fileKey", "fileDir", "fileLength", "sourceInfo", " filePath", "objectname", "sourceName", "FileKey", "sourcename", "fDir", " fileDirectory", "modelLocation", "filename", "FILEname", "modelname", "objectName", "FileName", "folderName", "resourcename", "FILEName"], "templateResource": ["eventResource", "plateResource", "templateFile", "xmlRole", "templateContainer", "privateReader", "layoutRing", "privateresource", "templateType", "privateResource", "copyresource", "eventUrl", " templateType", "xmlResource", "templateRing", "templateRole", " templateFile", "translationRing", "privateUrl", "translationContainer", "plateContainer", "templateresource", "plateRing", "tempRole", "copyReader", "xmlFile", "copyResource", "tempResource", "translationResource", "eventresource", "templateContent", "plateContent", "templateReader", "copyUrl", "translationContent", "tempType", " templateRole", "xmlType", "eventReader", "templateUrl", "tempFile", "layoutResource", "layoutContent", "layoutContainer"], "is": ["app", "ais", "Is", "iss", "isl", "it", "ri", "s", "irc", "ori", "has", "cms", "os", "im", "isa", "IS", "isc", "abs", "was", "r", "ar", "its", "api", "nis", "bis", "ir", "uri", "io", "ris", "as", "in", "iso", "iris", "src", "rss", "out", "ios", "lis", "serv", "ip", "ib", "isi"], "strBuff": ["StrBuff", " strBuffer", " strFlow", "strFlow", "brBuffer", "stringFlow", "strbuff", "strTab", " strTab", "arrBuff", "arrTab", " strText", " strGrab", "rText", "stringBuffer", "brGrab", "rBuffer", "arrPref", " strbuff", "StrTab", "strPref", " strPref", "StrText", "brBuff", "Strbuff", "rbuff", "rBuff", "StrBuffer", "StrPref", "arrBuffer", "strText", "strBuffer", "stringGrab", "stringBuff", "brFlow", "strGrab"], "br": ["reader", "mr", "Br", "cb", "er", "data", "arr", "ctr", "stream", "ori", "div", "bl", "yr", "text", "b", "cr", "r", "err", "fr", "bc", "dr", "rb", "bar", "BR", "sp", "hr", "brush", "nr", "browser", "io", "gr", "sr", "bro", "tr", "res", "result", " reader", "orb", "ber", "Reader", "buf"], "str": ["strike", "cur", "sl", "er", "f", "data", "iter", "name", "char", "arr", "type", "sc", "st", "kr", "p", "enc", "div", "lc", "pr", "text", "cr", "r", "line", "err", "fr", "key", "dr", "style", "sp", "hr", "t", "or", "spec", "sec", "cl", "oct", "STR", "wr", "sr", "tr", "coll", "string", "Str", "star", "stri"], "images": ["pages", "thumbnails", "ages", "gif", "games", "ups", "groups", "services", "ims", "ins", "versions", "events", "ips", "lights", "icons", "gallery", "quarters", "people", "words", "picture", "models", "files", "features", "holes", "flows", "apps", "letters", "shows", "scripts", "assets", "image", "pieces", "rooms", "stars", "png", "objects", "dates", "xs", "classes", "frames", "Images", "styles", "tags", "boxes", "ions", "photos", "sites", "jobs", "videos", "views", "users", "opens", "tests", "bands", "plugins", "resources", "types", "inches", "media", "agents"], "i": ["ie", "format", "bi", "b", "d", "cli", "xi", "uri", "io", "gi", "html", "gu", "ij", "si", "it", "ind", "lc", "I", "u", "key", "z", "yi", "mi", "ui", "li", "id", "ai", "x", "app", "f", "_", "ti", "p", "info", "j", "xml", "hi", "add", "multi", "qi", "fi", "e", "ini", "this", "Url", "ci", "image", "config", "n", "ii", "http", "ni", "iu", "mu", "eni", "phi", "ip", "ji", "y", "s", "slice", "pi", "di", "v", "in", "index", "chi", "diff", "uni"], "img": ["abc", "app", "ext", "sl", "f", "data", "cb", "aut", "ff", "gif", "aff", "tif", "arr", "fw", "m", "p", "info", "inst", "im", "gallery", "ie", "bl", "icon", "fig", "att", "iframe", "lib", "map", "image", "gd", "hr", "ch", "png", "v", "bg", "small", "config", "li", "norm", "ani", "ng", "file", "imp", "src", "input", "jpg", "exp", "fb", "tmp"], "imgProperty": ["cacheProperty", "cachePro", " imgProp", "imgProp", "bgPro", " imgImage", "imgImage", "bgProperty", "cacheImage", " imgPro", "cacheProp", "imgPro", "bgProp", "bgImage"]}}
{"id1": "5744493", "id2": "9109613", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": ["newFileCopy", " doFilecopy", " dofileCopy", "newFilecopy", " doFileWrite", "newBlockProxy", " dofilecopy", " dofileWrite", " doFolderCopy", " doFolderWrite", "newBlockCopy", " doBlockWrite", " doFolderProxy", " doFoldercopy", "newFileProxy", " doFileCopy", "newFileWrite", " doBlockProxy", " doBlockCopy", "newBlockWrite", " dofileProxy", " doFileProxy", " doBlockcopy", "newBlockcopy"], "in": ["reader", "bin", "lock", "isin", "login", "data", "name", "ins", "pin", "m", "ex", "min", "In", "base", "part", "b", "inner", "again", "win", "query", "IN", "err", "buffer", "i", "source", "image", "inc", "url", "config", "inn", "c", "file", "id", "index", "lin", "input", "diff"], "out": ["connection", "ext", "name", "point", "socket", "ex", "outs", "plain", "base", "copy", "page", "cache", "conn", "again", "output", "b", "user", "part", "writer", "pre", "dot", "off", "o", "OUT", "temp", "external", "buffer", "source", "image", "exec", "v", "default", "server", "io", "file", "prefix", "resource", "target", "Out", "string", "write"], "inChannel": [" inchannel", "INSocket", "INChannel", "binStream", "INChan", "InSocket", "outStream", "Inchannel", "InChan", "InStream", "inchannel", "inputSocket", " inChan", "outchannel", "INClient", " inStream", "binChannel", "outChan", "outSocket", "inClient", "INchannel", "inputChan", "inputChannel", "inChan", "inputStream", "inSocket", "inStream", "binChan", " inClient", "InChannel", "outClient", "INStream", "binSocket", " inSocket"], "outChannel": ["intChan", "inButton", " outButton", " outStream", "againStream", "outStream", "intchannel", "inchannel", "againChannel", "outchannel", "OutBuffer", "againSocket", "OutChan", "OutContainer", " outChan", "outChan", "outContainer", "againChan", "OutStream", "inContainer", "outSocket", " outBuffer", "intButton", "OutChannel", "inChan", " outSocket", "outButton", " outContainer", "inSocket", "inStream", " outchannel", "inBuffer", "intChannel", "outBuffer"], "maxCount": ["blockSize", " maxcount", "axSize", "axLength", "MaxSum", "MaxSize", "maxSum", "axCount", " maxSize", " maxLength", "blockcount", "maxSize", "blockSum", "maxcount", " maxSum", "MaxCount", "Maxcount", "blockCount", "MaxLength", "axcount", "maxLength"], "size": ["offset", "volume", "loc", "data", "name", "sized", "scale", "type", "range", "cap", "p", "send", "mode", "min", "Size", "en", "position", "shift", "time", "bytes", "max", "capacity", "shape", "flush", "address", "seek", "count", "limit", "speed", "sum", "width", "transfer", "n", "small", "unit", "empty", "SIZE", "len", "ize", "available", "length", "fee", "start", "end"], "pos": ["offset", "pose", "open", "iter", "loc", "data", "point", "cos", "slice", "pt", "p", "min", "os", "base", "position", "part", "Pos", "val", "o", "off", "address", "pointer", "count", "i", "block", "port", "limit", "spec", "slot", "pid", " position", "no", "POS", "pass", "unit", "rel", "neg", "id", "index", "len", "po", "obj", "diff", "ref", "length", "push", "start"]}}
{"id1": "20128728", "id2": "18696387", "code1": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyStream", "Copyfile", "moveSourceFile", "moveStream", " copyfile", " copyStream", "CopyFile", "copySourceFile", " copySourceFile", "movefile", "CopySourceFile", "copyfile", "copyStream", "moveFile"], "src": ["inf", "sl", "sin", "loc", "start", "s", "sc", "st", "stream", "inst", "download", "rc", "ource", "ls", "conn", "b", "files", "front", "img", "dist", "dest", "rb", "sq", "source", "image", "path", "filename", "url", "config", "server", "uri", "core", "sit", "in", "file", "upload", "sel", "sb", "input", "obj", "buf"], "dst": ["fdst", "fdft", "dsts", "Dput", " dsts", " ddest", "dft", "fsts", "fput", "ddest", "idsts", "dput", "Dst", "fdest", "idft", " dput", "Ddest", "dut", "fst", " dut", "Dsts", "idst", " dft", "fdsts", "idut", "fdut"], "inChannel": ["innerChan", "dinChan", " inchannel", "dinchannel", "INChannel", " inQueue", "INChan", "innerStream", "outStream", "Inchannel", "outQueue", "InChan", "inchannel", "inputLanguage", " inChan", "outchannel", " inStream", "outChan", "dinChannel", "InQueue", "inClient", "dinLanguage", "INchannel", "inputChan", "inLanguage", "inQueue", "inChan", "innerChannel", "INLanguage", "inputChannel", "inputStream", "inputchannel", "inStream", " inClient", "InChannel", "outClient", "INStream", "innerClient"], "outChannel": ["againchannel", " outStream", "inContext", "inConnection", " outContext", "outputStream", "againStream", " outConnection", "outContext", "outStream", "outputChan", "inchannel", "againChannel", "outchannel", "againSocket", "OutChan", " outChan", "outChan", "OutContext", "againChan", "OutStream", "outSocket", "outConnection", "Outchannel", "OutConnection", "outputchannel", "OutChannel", "inChan", " outSocket", "outputChannel", "inStream", " outchannel", "inSocket"]}}
{"id1": "18891988", "id2": "11341711", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["loadFilename", "downloadfile", "getfile", "downloadFile", "GetFile", "getFilename", "loadString", "Getfile", "downloadString", "loadfile", "GetFilename", "loadFile", "GetString", "getString", "downloadFilename"], "serviceName": ["ServiceType", "ServicePath", "ServiceName", "Servicename", "projectPath", "packagePath", "packagename", " servicePath", "servicePath", "packageName", "projectName", "ServiceUrl", "projectType", "serviceUrl", "servicename", "serviceType", "packageUrl", " serviceType", " servicename", " serviceUrl", "projectUrl"], "wsdlLocation": ["wsdlUrl", "wsslLocation", "wllFile", "wsllUrl", "wddlLocation", "awslFile", "wddlDirectory", "wsdlFile", "wdlDirectory", "wslLocation", "awsdlLocation", "wllFolder", "wsdlFolder", "wsllAddress", "wslpDirectory", "wslpLocation", "wddlFile", "wslFolder", "awslDirectory", "wsslFile", "wssdFolder", "awsdlDirectory", "wdlLocation", "wllLocation", "wdlFile", "wdlFolder", "wssdFile", "wsllFile", "wslUrl", "wslDirectory", "wsdlDirectory", "wslpFile", "wsslAddress", "awsdlUrl", "awslUrl", "wssdAddress", "wsllFolder", "wllAddress", "wsDLUrl", "wddlFolder", "wsslFolder", "wslFile", "awsdlFile", "wslpFolder", "awslLocation", "wdlAddress", "wsDLDirectory", "wsllLocation", "wsdlAddress", "wsDLLocation", "wsllDirectory", "wsDLFile", "wssdLocation"], "endpoint": ["enpointer", "endPoint", "ENDPoint", "endpo", "enaddress", " endpointer", "endsword", "endspoint", "endsocol", " endPoint", "Endpoint", " endpo", "endpoints", "enination", "startpoint", " endocol", "Endword", "endocol", "enPoint", "ENDination", "startPoint", "Endocol", "enpoint", " endaddress", "EndPoint", "endspo", "endination", " endword", "startaddress", "ENDpoints", "Endpo", "Endination", "ENDpoint", "startpointer", "endaddress", "Endpoints", "endpointer", "endword", "enpoints"], "fileLocation": ["FILEUrl", "FileLocation", "FILEURI", "FileUrl", " fileUrl", " fileDirectory", "fileUrl", "FILELocation", " fileURI", "fileURI", "FILEDirectory", "FileURI", "fileDirectory", "FileDirectory"], "tempDir": [" tempDirectory", "tempDirectory", "tempPath", "tempVer", " tempdir", " temporaryDir", " temporaryPath", " temporaryVer", "TempDir", "tmpVer", " tempPath", "TempPath", "TempDirectory", "tempdir", "tmpDirectory", "tmpPath", "Tempdir", "tmpDir", " tempVer", " temporaryDirectory", "tmpdir"], "url": ["ul", "connection", "open", "sl", "f", "fl", "channel", "socket", "ur", "el", "stream", "web", "download", "log", "ssl", "base", "ll", "ls", "conn", "l", "client", "address", "pull", "Url", "service", "URL", "source", "image", "path", "config", "server", "uri", "io", "http", "file", "www", "coll", "host", "contact", "string"], "WSDLFile": ["WSDLLFiles", "WSDlSourceFile", "WDDLPath", "WSDLFiles", "WINDLFolder", "WSDLLfile", "WSDDLBase", "WINDELFile", "WSDELFile", "WDDlfile", "WSDLFolder", "WINDLPath", "WINDLFiles", "WINDELFiles", "WDDlPath", "WINDLFile", "WSDDLFile", "WSDlFile", "WSDELPath", "WSDDLPath", "WSDlBase", "WDDLFile", "WDDLfile", "WSDlFolder", "WDDLSourceFile", "WSDlPath", "WSDlfile", "WSDLLFolder", "WINDELFolder", "WSDLLBase", "WSDLLSourceFile", "WDDLFolder", "WDDlBase", "WSDLLPath", "WDDlSourceFile", "WSDDLFolder", "WDDlFile", "WSDLPath", "WDDLBase", "WSDLBase", "WSDDLSourceFile", "WSDDLFiles", "WSDDLfile", "WSDLLFile", "WDDlFolder", "WSDLSourceFile", "WSDELFolder", "WINDELPath", "WSDELFiles", "WSDLfile"], "tmpWSDLFile": ["tmpWSDlFolder", "tmpWDDELFile", "tmpWSDLLFile", "tmpWDDLFiles", "tmpWSDELLocation", "tmpWSDELFolder", "tmpWSDLLFiles", "tmpWSDDLUrl", "tmpWSDLUrl", "tmpWSDELFiles", "tmpWSDDLFile", "tmpWSDlUrl", "tmpWSDLLFolder", "tmpWDDELUrl", "tmpWDDlUrl", "tmpWDDELLocation", "tmpWDDlFolder", "tmpWSDLFiles", "tmpWDDELFiles", "tmpWSDlLocation", "tmpWSDELUrl", "tmpWDDlFiles", "tmpWSDDLLocation", "tmpWDDlFile", "tmpWDDLFile", "tmpWSDLLUrl", "tmpWSDlFile", "tmpWDDLLocation", "tmpWSDLLocation", "tmpWSDLFolder", "tmpWSDlFiles", "tmpWDDLUrl", "tmpWSDDLFiles", "tmpWDDLFolder", "tmpWSDELFile"], "inputFile": ["tempPage", "InputUrl", "requestFiles", "InputBase", "tempBase", " inputStream", "tempFactory", "infile", "inputfile", "outputFile", "inDir", "InputPage", "inputFactory", "outputDir", "inputPage", "requestFile", "InputFactory", "InputStream", " inputFactory", " inputfile", "tempfile", "tempPlace", " inputFiles", "requestStream", "InputBuffer", "InputDir", "inputDir", "tempBuffer", "inPage", "requestfile", " inputPage", "inputBase", "inputUrl", " inputUrl", " inputBuffer", " inputPlace", "outputFiles", " inputBase", "inputFiles", "inputBuffer", "outputfile", "inputStream", "InputFile", "InputPlace", "tempUrl", " inputDir", "Inputfile", "tempFile", "InputFiles", "inputPlace", "inFile"], "tmpFile": ["tempPage", "tempDirectory", "TempFiles", "tempDocument", "tmpPage", "inputDocument", "uploadFile", "tempStream", "TempFile", " tmpPage", "tmpStream", " tmpDirectory", "uploadDocument", "uploadFiles", "uploadStream", "TempPage", "inputFiles", "TempDirectory", "tmpDirectory", "tempFiles", "inputStream", "tmpFiles", " tmpFiles", "tempFile"], "in": ["connection", "bin", "reader", "lock", "login", "f", "data", "socket", "ins", "pin", "m", "p", "In", "is", "ssl", "conn", "inner", "again", "win", "din", "l", "r", "IN", "client", "source", "image", "init", "inc", "inn", "c", "file", "up", "id", "impl", "on", "lin", "input", "gin"], "out": ["connection", "bin", "name", "socket", "channel", "error", "sync", "to", "outs", "timeout", "In", "log", "copy", "conn", "part", "inner", "output", "again", "conf", "cache", "can", "line", "writer", "IN", "err", "o", "client", "OUT", "source", "image", "inc", "ch", "outer", "parent", "conv", "group", "server", "io", "net", "c", "file", "up", "co", "on", "input", "Out"], "con": ["connection", "open", "cn", "socket", "nc", "channel", "un", "gin", "ins", "sync", "en", "plain", "rec", "ssl", "kin", "rc", "conn", "inner", "conf", "win", "can", "IN", "Con", "ran", "client", "connect", "ch", "CON", "uc", "inc", "close", "conv", "thin", "Conn", "c", "com", "co", "cm", "ctrl", "fc", "bc"], "fileLength": ["contentlength", "channelSize", "contentLen", "contentSize", "contentLength", "filelength", "fileLen", " filelength", "fileWidth", " fileLen", " fileWidth", " fileSize", "channelLen", "fileSize", "Filelength", "FileLen", "FileSize", "channelLength", "FileLength", "channelWidth", "FileWidth"], "channelIn": ["resourceOut", "resourceIn", "connectionin", "Channelin", "channelIN", "characterIn", "connectionIn", "channelConn", "channelin", "ChannelIn", "connectionOut", " channelin", "characterin", " channelConn", "ChannelConn", " channelIN", "characterOut", "ChannelOut", "characterIN", "connectionConn", "resourceIN", "resourcein", "ChannelIN"], "channelOut": ["chanOUT", "canOUT", " channelOutput", "chanOut", " channelout", "canOut", "Channelout", "connectionOutside", "ChannelOutput", "channelout", "connectionIn", "channelOUT", "ChannelIn", "connectionOut", "ChannelOUT", "connectionOutput", "ChannelOutside", "connectionout", "chanOutside", "chanout", "canIn", "channelOutput", "chanIn", "ChannelOut", "channelOutside", "canOutside"], "tmpDocument": ["newFile", "mpDocument", "tmDocument", "tempDocument", "newContent", " tmpNode", "tempdocument", " tmpdocument", "tempContent", "mpDoc", "mpFile", "tempDoc", "tmpContent", "newDocument", "tmpNode", "tmNode", " tmpDoc", "tmFile", " tmpContent", "tempNode", "tmdocument", "mpNode", "tempFile", "tmpDoc", "tmpdocument", "newdocument"], "nl1": ["ln11", "arl5", "dl2", "NL0", "NL1", "jl1", "nl6", "nlone", "NL2", "nl0", "arlFirst", "nn1", "kl5", "NL11", "klFirst", "jlone", "nn6", "NL6", "nl5", "klone", "nl2", "kl1", "arlone", "dl0", "nlFirst", "jl5", "nn0", "nn2", "arl1", "nl11", "jlFirst", "nn11", "ln6", "ln1", "ln2", "dl1"], "i": ["ji", "f", "y", "si", "it", "ti", "ri", "slice", "m", "p", "j", "info", "pi", "ie", "ix", "hi", "I", "bi", "di", "b", "u", "multi", "part", "qi", "l", "fi", "e", "o", "uli", "ini", "abi", "d", "ci", "z", "xi", "v", "mi", "ui", "oi", "yi", "li", "uri", "n", "ii", "io", "ni", "id", "iu", "index", "chi", "mu", "eni", "ai", "gi", "phi", "ip"], "node1": ["node0", " node0", "package91", "packageOne", " node91", "layer2", " nodeone", "layer1", "n1", " node2", "nodeone", "shapeOne", "nOne", "Node1", "NodeOne", "shape1", "n0", "nodeOne", "shapeone", "node91", "node2", "package1", "Node91", "packageone", "n2", "layerOne", "Node0", " nodeOne", "Node2", "shape91", "layer91"], "tmpOut": ["vmOUT", "tempout", "cacheOUT", " tmpout", "tempIn", "cacheIn", "ptyout", "txtOutput", "cacheFile", "tempOutput", "txtout", "tmpIn", "ptyOut", "tempOut", "tmpOUT", " tmpWriter", "tmpout", "vmOut", "tmpWriter", " tmpOUT", "ptyOutput", " tmpOutput", "ptyIn", "vmIn", "vmout", "tmpOutput", "tempOUT", " tmpIn", "cacheOut", "txtWriter", "tempWriter", "tempFile", "txtOut"], "retVal": ["RETval", "retRet", "valval", "valVal", "valRet", "retval", " retRet", "RETRet", "RETVal", "valObj", "retObj", " retObj", "RETObj", " retval"]}}
{"id1": "1180878", "id2": "23666867", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchURLdata", "frieveURLData", "fetchHTTPDATA", "frieveUrldata", "fetchHTTPdata", "fetchJSONdata", "frieveUrlData", "fetchUrldata", "frieveUrlDATA", "fetchJSONDATA", "fetchHTTPData", "frieveURLdata", "frieveURLDATA", "fetchUrlData", "fetchURLDATA", "fetchUrlDATA", "fetchJSONData"], "url": ["connection", "sl", "f", "loc", "data", "name", "fl", "ur", "gl", "el", "download", "xml", "base", "ssl", "ls", "html", "page", "user", "text", "href", "l", "address", "Url", "URL", "source", "image", "feed", "api", "path", "filename", "view", "uri", "server", "http", "file", "src", "resource", "www", "host", "location", "string", "username"], "proxyHost": ["ProxyDomain", "proxyHead", "baseHost", " proxyAddress", "serverAddress", "proxyAddress", "cacheHost", "serverPath", "remoteDomain", " proxyhost", "baseAddress", "cachePort", "proxyhost", "cachehost", "ProxyAddress", "proxyServer", "ProxyHead", "baseHead", "baseDomain", "ProxyHost", " proxyServer", "remoteHead", "Proxyhost", "cacheAddress", "ProxyPort", "remoteHost", "proxyDomain", "ProxyPath", "serverServer", "ProxyServer", "serverHost", "proxyPath", " proxyPath", "remoteAddress"], "proxyPort": [" proxyAddress", "httpHost", "proxyAddress", "cacheHost", "cachePort", "ProxyAddress", " proxyport", "Proxyport", "httpPort", "proxyServer", "httpServer", "ProxyHost", "proxyport", " proxyServer", "cacheAddress", "ProxyPort", "ProxyServer", "httpAddress", "cacheport"], "con": ["login", "ls", "win", "go", "common", "ocon", "exec", "xc", "close", "pen", "conv", "c", "com", "co", "on", "ctrl", "out", "fan", "re", "fc", "open", "cur", "socket", "pin", "syn", "pub", "en", "pc", "canon", "conn", "cache", "conf", "don", "sub", "fa", "ai", "cone", "bc", "cons", "x", "act", "ver", "f", "cn", "fl", "un", "remote", "ec", "per", "fun", "part", "cr", "pre", "ran", "ci", "cc", "run", "connect", "inc", "n", "http", "an", "cas", "mc", "cp", "connection", "fac", "ca", "change", "sync", "min", "gen", "rc", "rec", "can", "Con", "uc", "CON", "cf", "ch", "cl", "func", "cm", "ac"], "is": ["isin", "ais", "Is", "iss", "get", "si", "it", "cos", "isl", "ri", "does", "s", "oss", "bs", "p", "info", "has", "state", "ori", "cms", "ics", "os", "im", "ie", "isa", "IS", "cs", "isc", "conn", "abs", "was", "can", "ops", "ar", "its", "i", "sp", "mis", "isu", "ws", "api", "or", "js", "il", "ci", "bis", "vs", "ir", "ps", "ris", "as", "in", "iso", "act", "id", "iris", "are", "es", "ai", "out", "us", "ios", "lis", "serv", "fs", "ib", "isi"], "u": ["ul", "su", "f", "q", "un", "ur", "m", "p", "ut", "ru", "os", "user", "b", "U", "conn", "l", "o", "client", "lu", "yu", "fu", "i", "uc", "api", "h", "v", "ui", "ue", "uri", "uv", "cu", "io", "c", "http", "file", "up", "hu", "iu", "uci", "ou", "us", "nu", "tu"], "proxy": ["x", "connection", "f", "force", "socket", "phone", "pool", "Proxy", "type", "create", "pin", "XY", " proxies", "remote", "p", "web", "timeout", "fe", "pc", "ssl", "prot", "copy", "cache", "wrapper", "xy", "zip", "l", "cop", "plus", " Proxy", "client", "address", "bean", "lib", "port", "api", "config", "server", "uri", "pse", "pe", "http", "c", "shadow", "clone", "pa", "resource", "host", "ip", "roxy"], "baos": ["abros", "calos", "BAis", "hao", "pao", "caas", "boOS", "BAros", "caos", "hais", "bao", "BAos", "haos", "paos", "aOS", "bolos", "bais", "pais", "baOs", "Bais", "abis", "caOS", "abOs", "BaOs", "boas", "haOS", "BAOS", "alos", "paOS", "BAOs", "baOS", "boos", "Baros", "aas", "baas", "aos", "baros", "Baos", "balos", "BAo", "abos"]}}
{"id1": "310182", "id2": "13657103", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["conception", " deconvert", "Convert", "converting", "subvert", "unversion", " deconverting", "CONverting", "unvert", "CONvert", "unception", "Conversion", " deconverted", "unverted", "subverted", "Converted", "conversion", " deconversion", "CONverted", "subversion", "oconvert", "CONversion", "converted", "Conception", "Converting", "CONception", "subverting", "oconversion", "oconverted", "oconverting"], "src": ["reader", "username", "cb", "sin", "loc", "RC", "name", "sn", "gb", "s", "sc", "slice", "cpp", "stream", "st", "secure", "inst", "download", "sth", "load", "gz", "proc", "sys", "rc", "SourceFile", "ssl", "component", "ource", "prot", "req", "feat", "video", "img", "href", "fn", "dist", "back", "rb", "cmp", "source", "storage", "ctx", "path", "spec", "filename", "attr", "stage", "url", "config", "code", "uri", "sit", "file", "impl", "Dest", "upload", "sel", "scene", "sb", "input", "resource", "Source", "fp", "ref", "rl", "string", "obj", "buf", "tmp", "supp"], "dest": ["bin", " destination", "cont", " dst", "class", "orig", "di", "txt", "img", "fn", "dist", "temp", "std", "dc", "test", "lib", "source", "disk", "path", "null", "Dest", "target", "dir", "dat", "home", "obj", "tmp"], "in": ["reader", "bin", "inf", "isin", "login", "f", "data", "doc", "inas", "ins", "pin", "stream", "ex", "In", "is", "win", "r", "din", "val", "IN", "err", "ini", "d", "i", "source", "inc", "t", "n", "pass", "ps", "inn", "io", "as", "up", "file", "a", "input"], "p": ["f", "lp", "tp", "s", "g", "py", "m", "j", "pi", "wp", "pc", "per", "pr", "jp", "b", "part", "op", "l", "bp", "pre", "cop", "e", "r", "parser", "o", "pp", "d", "i", "sp", "t", "h", "v", "ps", "pe", "c", "P", "pm", "np", "pa", "po", "fp", "pd", "cp", "pg", "pb"], "ds": ["data", "dl", "dd", "services", "groups", "ys", "cs", "ls", "ld", "tools", "d", " props", "js", "ded", "xs", "uds", "ps", "ils", "ges", "tests", "pd", "ads", " sd", "df", "lp", "ups", "ins", "bs", "Ds", "os", "sys", "sts", "obs", "rs", "dds", "dm", "nas", "gd", "hs", "points", "ipes", "qs", "DS", "styles", "des", "ss", "ks", "dos", "cons", "ts", "vals", "eps", "els", "icks", "da", "ns", "parts", " ps", "dist", " DS", "posts", "dc", "scripts", "ths", "dates", "vs", "gs", "ays", "dat", "docs", "dt", "s", "sync", "utils", "ans", "di", "words", "models", "lines", "db", "dp", "ants", "amps", "plugins"], "format": ["tag", "data", "f", "layout", "sche", "scale", "name", "version", "at", "ant", "handler", "type", "table", "language", "filter", "letter", "feat", "class", "plugin", "model", "part", "magic", "fn", "parser", "atter", "style", "source", "template", "t", "api", "spec", "struct", "filename", "pattern", "path", "form", "url", "config", "unit", "Format", "file", "function", "act", "prefix", "fd", "frame", "record", "host", "fp", "string", "nat"], "hasPixelData": ["hasPicturedata", "hasPictureSize", "hasByteData", " hasPixeldata", "hasPixeldata", "showsPixelDATA", "hasPixelSize", "hasPixelStyle", "showsByteStyle", " hasPixelSize", "showsBytedata", "hasByteStyle", "showsPixeldata", "showsByteData", "hasPictureData", "hasByteSize", "showsByteDATA", "hasByteDATA", "showsPixelData", "haspixeldata", "hasBytedata", "hasPixelDATA", "haspixelSize", "haspixelData", "showsPixelStyle"], "inflate": ["insflATE", "invenATE", "inflode", "inffated", "inFlated", "InFlace", "Inflace", "invenate", "insflate", "inflated", "inadequating", "inFlace", "insflating", "infolating", "infolATE", "inadequATE", "invenode", "inadequode", "insflode", "inffation", "infloated", "insvenATE", "invenating", "inffate", "inFlate", "inadequate", "inflating", "InFlated", "infolode", "infface", "Inflated", "Inflate", "InFlation", "inflation", "Inflation", "infloace", "insvenating", "insvenode", "infolate", "InFlate", "inflATE", "inflace", "infloate", "insvenate", "infloation", "inFlation"], "pxlen": ["mxlen", "fxdata", "mxpos", "campos", "pclon", "axln", "ppl", "txlen", "fxLen", "pxdata", "pxsize", "pngcount", "xpsize", "pxpos", "txln", "xpcount", "ppLen", "txlin", "mxdata", "camdata", "camln", "mxln", "axlen", "pcln", "pnglength", "pglen", "pxden", "fxden", "txlon", "pgLen", "pxl", "pxlength", "pxlon", "axlon", "pclin", "camlen", "pgden", "pxln", "mxcount", "pngsize", "fxln", "pgl", "mxlength", "mxsize", "axlin", "pclen", "fxl", "pxcount", "fxpos", "pxLen", "fxlen", "xplen", "pnglen", "ppden", "pxlin", "xplength", "pplen"], "out": ["lock", "point", "error", "session", "state", "outs", "gen", "dump", "sys", "log", "copy", "page", "cache", "user", "again", "output", "conn", "line", "work", "query", "err", "OUT", "list", "lib", "cli", "step", "parent", "v", "store", "server", "group", "post", "io", "up", "co", "inter", "pad", "re", "Out", "obj"]}}
{"id1": "4417943", "id2": "12417893", "code1": "    public void test() {\n        try {\n            String query = \"* <http://xmlns.com/foaf/0.1/workplaceHomepage> <http://www.deri.ie/>\" + \"* <http://xmlns.com/foaf/0.1/knows> *\";\n            String url = \"http://sindice.com/api/v2/search?qt=advanced&q=\" + URLEncoder.encode(query, \"utf-8\") + \"&qt=advanced\";\n            URL urlObj = new URL(url);\n            URLConnection con = urlObj.openConnection();\n            if (con != null) {\n                Model model = ModelFactory.createDefaultModel();\n                model.read(con.getInputStream(), null);\n            }\n            System.out.println(url);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"test": ["app", "scan", "Test", "load", "loop", "check", "evaluate", " Test", "work", "show", "parse", "run", " testing", "build", "testing", "stats", "example", "server", "index", "debug", "tests", "train", "report", "est", "start", " tests"], "query": ["qa", "answer", "question", "scan", "depth", "q", "type", "range", "filter", "quest", "body", "timeout", "sort", "gallery", "expression", "qu", "cache", "term", "random", "sq", "comment", "source", "qs", "request", "dq", "uri", "index", "search", "series", "report", "qt", "sql", "re", "json", "media", "Query"], "url": ["connection", "sl", "f", "data", "loc", "name", "q", "error", "ur", "web", "download", "xml", "base", "ssl", "html", "page", "href", "l", "address", "Url", "service", "URL", "proxy", "source", "db", "buffer", "api", "request", "path", "config", "uri", "server", "route", "http", "file", "id", "search", "resource", "www", "host", "link", "location", "string"], "urlObj": [" urlOb", "UrlObj", "httpObject", "urlObject", "Urlobj", " urlObject", "UrlOb", "resourceOb", "resourceLib", "urlOb", "fileobj", " urlobj", "httpOb", "resourceObj", "urlLib", "UrlLib", "fileObj", " urlLib", "httpLib", "urlobj", "httpObj", "fileLib", "resourceObject", "fileOb"], "con": ["connection", " rc", "open", "cur", "f", "cn", "un", "aff", "ca", " conn", "ct", "Connect", "syn", "sync", "pc", "rc", "lc", "fun", "fat", "conn", "conf", "Con", "ran", "sub", "connect", "uc", "CON", "cf", "ocon", "exec", "xc", "close", "cl", "conv", "Conn", "c", "fa", "com", "co", "soc", " Con", "out", " CON", "cp", "Connection", "fc", "obj", "bc", "cons"], "model": ["reader", "connection", "Model", "app", "data", "type", "m", "info", "xml", "class", "base", "copy", "page", "models", "conf", "instance", "content", "zip", "client", "proxy", "source", "image", "api", "response", "path", "object", "config", "code", "server", "view", "null", "file", "module", "resource", "cm", "json", "obj"]}}
{"id1": "16804988", "id2": "20588811", "code1": "    public void init() {\n        String filename = getParameter(\"filename\");\n        if (filename == null) {\n            Error(\"Illegal filename\");\n            return;\n        }\n        Dimension dim = DEFAULT_SIZE;\n        try {\n            int w = Integer.parseInt(getParameter(\"width\"));\n            int h = Integer.parseInt(getParameter(\"height\"));\n            dim = new Dimension(w, h);\n        } catch (Exception e) {\n        }\n        InputStream in;\n        try {\n            File ff = new File(filename);\n            in = new FileInputStream(ff);\n        } catch (Exception ignore) {\n            try {\n                URL url = new URL(filename);\n                in = url.openStream();\n            } catch (Exception e) {\n                Error(\"Graph viewer: Failed to open: \" + filename + \"\\n\" + e);\n                return;\n            }\n        }\n        getContentPane().add(getWindow(in));\n        resize(dim);\n        repaint();\n    }\n", "code2": "    public void run() {\n        long time = System.currentTimeMillis();\n        logger.info(\"Version: \" + version);\n        String hostname = properties.getProperty(\"mercuriushost\");\n        String protocol = properties.getProperty(\"mercuriusprotocol\");\n        String port = properties.getProperty(\"mercuriusport\");\n        String path = properties.getProperty(\"mercuriuspath\");\n        String action = properties.getProperty(\"mercuriusaction\");\n        logger.info(\"Getting Timex Data --- \" + getTimeDifferent(time));\n        String xml = timexfrmk.getUnsynchedSessionsXMLFormat();\n        logger.info(\"Done getting Timex Data --- \" + getTimeDifferent(time));\n        if (timexfrmk.getSessionCount() > 0) {\n            try {\n                logger.info(\"Sending Timex Data to Mercurius --- \" + getTimeDifferent(time));\n                String data = URLEncoder.encode(\"action\", \"UTF-8\") + \"=\" + URLEncoder.encode(action, \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"data\", \"UTF-8\") + \"=\" + URLEncoder.encode(xml, \"UTF-8\");\n                if (isAdminFeedKeySet()) {\n                    data += \"&\" + URLEncoder.encode(\"adminfeedkey\", \"UTF-8\") + \"=\" + URLEncoder.encode(adminfeedkey, \"UTF-8\");\n                    logger.debug(\"Using adminfeedkey to authenticate\");\n                } else {\n                    Authenticator.setDefault(new CustomAuthenticator(user, password));\n                    logger.debug(\"Using user/pwd to authenticate\");\n                }\n                String u = protocol + \"://\" + hostname + \":\" + port + path;\n                logger.debug(\"Posting xml data to: \" + u);\n                URL url = new URL(u);\n                URLConnection conn = url.openConnection();\n                conn.setRequestProperty(\"User-Agent\", \"TimexMercurius/\" + version);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                StringBuffer s = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    s.append(line);\n                }\n                if (s.length() > 0) {\n                    logger.debug(s.toString());\n                    if (s.toString().indexOf(\"Result:\") != -1) {\n                        logger.info(s.toString().substring(s.toString().indexOf(\"Result:\")));\n                        if (s.toString().indexOf(\"Result: Successful\") != -1) {\n                            timexfrmk.updateSessionsStatus();\n                        }\n                    } else {\n                        logger.error(s.toString());\n                    }\n                } else {\n                    logger.info(\"No data returned\");\n                }\n                wr.close();\n                rd.close();\n            } catch (MalformedURLException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (IOException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (Exception e) {\n                logger.error(e);\n                logger.trace(e, e);\n            }\n        } else {\n            logger.info(\"There is nothing to send.  Everything has already been synchronized\");\n        }\n        timexfrmk.close();\n        logger.info(\"Done!!! Total Time: \" + getTimeDifferent(time));\n    }\n", "label": 0, "substitutes": {"init": ["Initialized", "layout", "it", " Init", "Init", "activate", "create", "info", "load", "setup", "launch", "format", " initialization", "construct", "show", " startup", "parse", "build", "image", "close", "update", "config", " initialized", "initial", "ize", "draw", "start"], "filename": ["f", "loc", "name", "database", "kn", "download", "fil", "SourceFile", "binary", "nil", "ssl", "kl", "Filename", "loader", "size", "files", "txt", "content", "online", "l", "ppa", "fn", "journal", "password", "ename", "doi", "fax", "which", "path", "phrase", "il", "config", "n", "uri", "metadata", "file", "folder", "title", "params", "prefix", "word", "fd", "upload", "utf", "sf", "fp", "jpg", "directory", "length", "location", "string", "dll", "license", "username"], "dim": ["gm", "Dim", "ext", "wid", "sam", "si", "fac", "scale", "lim", "g", " Dim", "ims", "m", "slice", "grad", "span", "p", "info", "py", "min", "div", "param", "im", "dimension", "format", "di", "part", "multi", "size", "num", "imm", "img", "wm", "dom", "dm", "val", "fi", "iframe", "marg", "dr", "dist", "shape", "d", "image", "project", "spec", "mod", "mi", "width", "config", "du", "thin", "index", "dat", "cm", "diff", "fm", " reim", "dem", "grid"], "w": ["x", "ew", "f", "y", "wt", "q", "wd", "s", "fw", "m", "hw", "p", "k", "en", "ow", "u", "b", "weight", "win", "r", "l", "max", "e", "o", "d", "i", "z", "wa", "t", "wh", "rw", "v", "sw", "width", "n", "c", "a", "W", "height"], "h": ["x", "rh", "f", "y", "ha", "ah", "q", "s", "p", "j", "k", "en", "bh", "ht", "u", "b", "ph", "kh", "hm", "th", "l", "e", "o", "d", "hs", "z", "H", "hr", "gh", "t", "ih", "oh", "v", "n", "c", "uh", "height", "hd", "sh"], "in": ["reader", "bin", "connection", "login", "f", "data", "fac", "socket", "ins", "el", "pin", "stream", "min", "In", "fe", "is", "kin", "ssl", "conn", "b", "again", "win", "l", "r", "din", "IN", "err", "ax", "amin", "ini", "i", "source", "lib", "inc", "nin", "cf", "cl", "n", "read", "io", "inn", "file", "as", "id", "impl", "cgi", "src", "resource", "input", "out", "fp", "ac", "gin", "serv", "fb", "fc"], "ff": ["ffe", "df", "cb", "f", "fl", "aff", "buff", "fff", "fe", "fed", "library", "bb", "xff", "FF", "ouf", "lf", "pp", "back", "fx", "cmp", "ctx", "feed", "cf", "ulp", "eff", "ef", "iff", "file", "af", "fd", "uf", "bf", "sf", "fp", "fc", "fb", "buf"], "url": ["connection", "open", "sl", "f", "fl", "stream", "web", "download", "base", "ssl", "ll", "ls", "b", "zip", "l", "e", "fr", "Url", "URL", "source", "image", "feed", "path", "uri", "server", "io", "http", "file", "src", "www", "resource", "sf", "fp", "string", "fb", "ob"]}}
{"id1": "12349563", "id2": "14590676", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    public static void download(String address, String localFileName) {\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            URL url = new URL(address);\n            out = new BufferedOutputStream(new FileOutputStream(localFileName));\n            conn = url.openConnection();\n            in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n            System.out.println(localFileName + \"\\t\" + numWritten);\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"resourceExists": [" fileexistence", " resourceexits", " resourceexists", " resourceAbses", " resourceExistence", " resourceAbsists", " fileexits", " resourceCompits", " fileExistence", " resourceCompes", " fileExists", " resourceCompistence", " resourceExits", " fileExits", " resourceCompists", " fileExes", " fileexists", " fileexes", " resourceExes", " resourceAbsits", " resourceAbsistence", " resourceexistence", " resourceexes"], "location": ["connection", "localhost", "region", "loc", "data", "name", "point", "layout", "type", "remote", "language", "reference", "operation", "layer", "info", "local", "base", "position", "description", "content", "href", "LOC", "shape", "collection", "address", "pointer", "source", "image", "provided", "path", "response", "filename", "object", "uri", "server", "route", "file", "folder", "message", "Location", "resource", "target", "host", "home", "length", "directory", "area", "string", "node"], "url": ["connection", "open", "sl", "f", "loc", "fl", "web", "base", "ll", "ssl", "blog", "page", "b", "user", "zip", "l", "r", "address", "Url", "i", "URL", "lib", "build", "source", "image", "api", "path", "config", "server", "uri", "io", "http", "c", "file", "impl", "resource", "www", "host", "string", "obj"], "cxn": ["cxxp", "Cuxn", "cxxn", "cuxns", "cdsn", "Cuxns", "crexp", "Cxp", "Cxns", "cexns", " crexn", " crexg", " crexp", "cxns", "Cxn", "crexg", "cuxp", "cexg", "cexcon", "cexp", "cdscon", "cdsp", "crexn", " cxcon", "Cuxp", "cxxne", "cxg", "cuxn", " cxg", "cxxns", " crexcon", "Cxne", " cxp", "cuxne", "cxcon", "cxne", "cexne", "cxp", "crexcon", "cexn", "cdsg", "Cuxne"], "is": ["x", "app", "ens", "ais", "Is", "iss", "get", "isl", "it", "cos", "does", "s", "oss", "bs", "stream", "ori", "info", "has", "web", "cms", "os", "im", "isa", "IS", "isc", "abs", "was", "internet", "ar", "its", "i", "init", "api", "or", "js", "nis", "next", "close", "ui", "bis", "ois", "ir", "uri", "ris", "http", "in", "as", "iso", "id", "iris", "src", "es", "ai", "out", "us", "ios", "ms", "lis", "ip", "fs", "ob", "isi"], "byteBuffer": ["byteBuff", "ByteArray", "ByteBuffer", "ByteBB", " byteBuff", "bitBB", "bitBuffer", "ByteBuff", "bitBuff", "byteArray", " byteLength", "ByteLength", "byteLength", "bitArray", " byteArray", "bitLength", " byteBB", "byteBB"]}}
{"id1": "15445861", "id2": "20735941", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyDirectory", "Copyfile", "copyFiles", " copyfile", "copyDirectory", "transferFile", "transferfile", " copyFiles", " copyDirectory", "CopyFiles", "CopyFile", "transferFiles", "transferDirectory", "copyfile"], "srcFile": ["rcDir", "rcFile", " srcPath", "rcTime", "rcDirectory", "srcFiles", "rcPath", "srcDirectory", " srcStream", " srcPlace", "sourceDir", "srcTime", "destDir", "supFile", "ourceTime", "rcFiles", "destTime", "sourceDirectory", " srcDir", "sourceFiles", "srcPlace", " srcFiles", "rcfile", " srcDirectory", "supfile", "ourcePath", "ourcePlace", "rcStream", "sourcePath", "srcStream", "sourcefile", "rcPlace", "srcPath", " srcTime", "supPath", "srcfile", "supStream", "ourceFile", " srcfile", "sourceFile", "destDirectory", "srcDir"], "destFile": ["DestFile", "destfile", "vertPath", "inationFilename", "vertFiles", "stdTime", " destTime", "endFilename", "targetFile", "tempPath", " destPath", "vertFile", "DestFiles", "destTime", "sourceDirectory", "inationFiles", "Destfile", "tempfile", "endTime", "inationPath", "stdDirectory", " destFilename", "sourceTime", "destPath", " destFiles", " destDirectory", "stdfile", "targetPath", "DestFilename", "vertFilename", "targetTime", "destFilename", "sourcefile", "targetFilename", "inationFile", " destfile", "endPath", "tempFiles", "destFiles", "stdFile", "sourceFile", "endFile", "DestPath", "tempFile", "destDirectory"], "in": ["reader", "bin", "isin", "login", "f", "get", "socket", "ins", "pin", "m", "cin", "ex", "min", "In", "base", "is", "inside", "kin", "b", "inner", "again", "rin", "win", "r", "din", "IN", "pull", "ini", "i", "source", "image", "init", "inc", "nin", "or", "h", "url", "read", "io", "inn", "as", "up", "id", "a", "input", "con", "ac", "gin", "serv"], "out": ["bin", "ext", "socket", "sync", "to", "ex", "outs", "one", "base", "conn", "user", "w", "cache", "again", "output", "inner", "by", "writer", "work", "line", "err", "off", "o", "client", "OUT", "inc", "exec", "parent", "other", "n", "pass", "io", "net", "file", "up", "exp", "Out", "gin", "obj"], "buffer": ["offset", "reader", "border", "uffer", "iter", "data", "channel", "batch", "slice", "reference", "layer", "buff", "Buffer", "variable", "binary", "base", "position", "b", "size", "bytes", "flush", "address", "padding", "source", "block", "limit", "feed", "phrase", "url", "transfer", "read", "document", "server", "null", "pause", "memory", "wave", "queue", "header", "input", "result", "length", "buf"], "no": ["x", " number", "nt", " lo", "data", "NO", " mo", "error", "type", "lo", "from", "auto", "na", "to", "info", "only", "eno", "zero", "os", " none", " NO", "ko", "size", "num", "was", "o", "off", "go", "i", "which", "wa", "mo", "maybe", "ino", "number", "nor", "nr", "io", "id", "pos", "index", "yes", "No", "nothing", "co", "po", "none", "so", "nos"]}}
{"id1": "18202328", "id2": "8047989", "code1": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"register": ["save", "app", " reg", "login", "reg", "master", "activate", "create", "play", " registration", "load", "setup", " Register", "check", "user", "password", "bind", "init", "connect", "chain", "Register", "update", "config", " unlock", "Login", "auth", " regenerate", "start"], "session": ["connection", "lock", "login", "manager", "version", "machine", "socket", "channel", "ess", "master", "thread", "play", "remote", "python", "caster", "database", "sync", "state", "event", "Session", "ssl", "position", "conn", "user", "cache", "video", "section", " Session", "shell", "password", "client", "temp", "proxy", "gui", "service", "image", "child", "connect", "cookie", "port", "game", "h", "driver", "request", "parent", "config", "facebook", "view", "server", "group", "ession", "sa", "room", "person", "global", "browser", "script", "message", "sb", "resource", "window", "mc", "host", "security", "input", "slave", "use", "device", "site"], "username": ["localhost", "ame", "profile", "login", "name", "phone", " nickname", "email", "database", "seed", "minecraft", "monitor", "verb", " password", "user", "text", "Password", "term", "account", "password", "address", "subject", "crypt", "secret", "nick", "source", "ername", "sword", "mobile", "driver", "path", "phrase", "filename", "property", "url", "character", "attribute", "Name", "hello", "uri", "person", "duration", "title", "prefix", "word", "message", "users", "uid", "token", "mother", "host", "voice", "length", "auth", "string", "NAME", "amer", "steam"], "verificationKey": ["vermentKEY", "vermentSecret", "verificationSecret", "significationKey", "validificationPoint", "verifyPoint", "signationKEY", "significationKEY", "verationKEY", "verifyingPoint", "validifyingKey", "vermentkey", "verationKey", "verationSecret", "verifyingkey", "validificationKey", "verificationkey", "verifyingSecret", "validifyingkey", "verifyKey", "validificationkey", "verifyingKey", "verifySecret", "signationSecret", "verifykey", "verationkey", "verifyingKEY", "validificationSecret", "significationSecret", "signationKey", "significationkey", "verationPoint", "verificationPoint", "signationkey", "verificationKEY", "vermentKey", "validifyingSecret", "validifyingPoint"], "salt": ["Salt", "sehash", "suffhash", "sort", "setsALT", "seALT", "setsort", "setsodium", "sealt", "sSalt", "suffALT", "sodium", "seSalt", " sALT", "SSalt", "suffSalt", "SALT", "shash", "suffalt", " sort", "sALT", " sodium", "Shash", "setsalt"], "hash": ["name", "version", "hed", "pool", "array", "hex", "log", "match", "html", "cache", "user", "text", "output", "mac", "her", "kh", "query", "password", "key", "address", "secret", "crypt", "buffer", "build", "square", "h", "url", "sum", "number", "memory", "message", "sha", "result", "input", "ash", "host", "total", "header", "auth", "Hash", "string"], "digest": ["dige", "hedested", "signEST", "digit", " digests", "DigEST", "diggest", "Digester", "biggest", "digested", "hedEST", " dige", "defEST", "signests", "bigested", "digester", "bigester", "digEST", "Dige", "bigest", "logit", " digger", "logester", "digger", "hedester", "defe", " digEST", "Digested", "signested", "Digger", "logest", "Diggest", "logger", "signest", "defester", "Digit", " digit", "digests", "hedest", " digested", "defest", "Digests", " digester", "Digest", " diggest"], "nameChars": [" nameCharARS", "namechARS", "namechases", "nameChararts", " nameChararts", " nameCharts", "nameChacters", "nameCharts", "nameCheats", " nameChARS", "nameChases", "nameChears", " nameCharacters", "nameGracters", "nameChARS", "nameCharARS", "nameGrars", "namechacters", " nameCharars", " nameChats", "nameChats", "namechars", "nameCheARS", "nameCharacters", " nameChacters", "nameGrARS", " nameChases", "nameGrarts", "namechats", "nameCharars", "namecharts", "nameCheases"], "nameChar": ["Namechar", "idCharacter", "resourceChar", " NameCh", " nameText", " nameCh", "NameCharacter", "NameCtrl", " nameDir", "nameText", " NameChar", "NameCh", "idCh", " NameText", "resourcechar", "NameDir", "nameCh", " nameCharacter", "addressCh", "nameCharacter", " nameCtrl", " namechar", "idChar", "resourceCharacter", "idText", " NameCharacter", "NameChar", "addressCharacter", "nameDir", "nameCtrl", "addressChar", "addressCtrl", "resourceDir", "namechar"], "p": ["er", "f", "lp", "point", "q", "at", "s", "g", "py", "m", "pair", " P", "j", "pc", "per", "jp", "u", "b", "part", "br", "op", "l", "r", "cop", "pre", "e", "o", "client", "pp", "d", "i", "sp", "t", "api", "ap", "h", "v", "n", "ps", "pe", "up", "P", "a", "pa", "np", "po", "fp", "cp"], "player": ["connection", "players", "er", "league", "data", "name", "manager", "gamer", "machine", "aster", "master", " Player", "pool", "caster", "play", "g", "worker", "m", "party", "layer", "winner", "per", "class", "match", "position", "team", "part", "user", "video", "playing", "can", "l", "board", "e", "member", "played", "client", "live", "controller", "driver", "game", "parent", "media", "n", "server", "conference", "pe", "person", "owner", "pm", "script", "pro", "slave", "ace", "ler", "Player", "leader", "steam"], "c": ["abc", "cb", "arc", "f", "nc", "sc", "ca", "m", "C", "ct", "k", "enc", "ec", "pc", "rc", "cs", "lc", "cache", "conf", "cr", "l", "r", "o", "dc", "d", "cc", "ci", "ctx", "t", "cf", "chain", "h", "v", "cl", "config", "n", "cu", "ce", "tc", "con", "cm", "mc", "cp", "ac", "fc", "bc"]}}
{"id1": "442381", "id2": "19494842", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doversioncheck", "doBuildCheck", "doReleasecheck", " doVersionWork", "doVersionWork", " doBuildWork", "doversionTest", " doReleaseCheck", " doBuildcheck", " doBuildCheck", "doReleaseTest", " doVersioncheck", "doReleaseCheck", " doVersionTest", "doVERSIONcheck", " doReleasecheck", "doBuildWork", "doVersionTest", " doBuildTest", "doVERSIONTest", "doBuildTest", " doReleaseTest", "doBuildcheck", "doVERSIONWork", "doReleaseWork", "doVersioncheck", "doversionCheck", "doVERSIONCheck"], "view": ["full", "reader", "lock", "app", "layout", "self", "q", "edit", "widget", "session", "el", "body", "change", "div", "View", "event", "screen", "vis", "model", "page", "cache", "box", "can", "l", "e", "display", "cell", "see", "client", "this", "row", "buffer", "show", "comment", "style", "image", "block", "port", "gui", "request", "object", "v", "ui", "update", "config", "form", "server", "http", "views", "sel", "input", "window", "out", "VIEW", "accept", "html", "use", "gu"], "url": ["connection", "open", "sl", "f", "socket", "channel", "stream", "web", "base", "ssl", "log", "ll", "bb", "blog", "user", "loader", "zip", "l", "client", "address", "Url", "buffer", "URL", "source", "build", "image", "service", "lib", "hub", "path", "server", "uri", "browser", "http", "file", "resource", "input", "bel", "host", "string", "ob"], "in": ["reader", "isin", "sin", "login", "data", "socket", "s", "ins", "stream", "cin", "In", "binary", "is", "b", "inner", "rin", "win", "din", "IN", "ini", "buffer", "i", "source", "init", "inc", "nin", "bis", "n", "inn", "file", "as", "lin", "resource", "input", "out", "con", "ac", "gin"], "bin": ["reader", "border", "lock", "sin", "data", "socket", "pin", "body", "cin", "bn", "bot", "binary", "log", "kin", "bb", "bi", "inline", "part", "b", "loader", "inner", "win", "din", "IN", "ruby", "abi", "buffer", "lib", "run", "init", "spin", "browser", "inn", "oin", "file", "lin", "fin", "input", "out", "record", "con", "ln", "gin", "nb"], "line": ["job", "le", "data", "name", "lo", "el", "layer", "non", "ge", "load", "str", "definition", "letter", "log", "base", "inline", "lc", "rule", "page", "b", "text", "part", "model", "l", "e", "cell", "lines", "key", "lf", "ine", "row", "i", "source", "comment", "style", "block", "entry", "parse", "Line", "band", "object", "no", "cl", "code", "pass", "unit", "nl", "pe", "file", "split", "up", "LINE", "word", "valid", "message", "id", "lin", "link", "home", "day", "string", "ip", "end", "look", "site"], "develBuild": ["dellRelease", "deVELBuilt", "deelBuild", "deviousBuild", "deploybuild", "desvenBuilt", "DEvelBuilt", "desvenBuild", "desvenRun", "develbuild", "deelRelease", "desvelBuild", "deVELRun", "dewardbuild", "desvelRun", "desvelBuilt", "desvenBuilder", "deelRun", "develBuilder", "desvenbuild", "DEVELBuilt", "devenbuild", "devenRun", "DEVELBuilder", "DEVELBuild", "devenRelease", "deVELBuild", "deployBuilt", "desvelBuilder", "DEVELbuild", "deviousbuild", "deelBuilder", "DEvelbuild", "deVELbuild", "develRun", "deviousBuilt", "deployRun", "develRelease", "dellRun", "desvelRelease", "devenBuilder", "deployBuilder", "dewardBuild", "devenBuilt", "dellBuilder", "dellBuild", "DEvelBuild", "dewardBuilt", "deployBuild", "desvenRelease", "dewardBuilder", "develBuilt", "desvelbuild", "devenBuild", "deVELBuilder", "DEvelBuilder"], "stableBuild": ["stableVersion", "compatibleBuild", "validbuild", "latestBuild", "baseBuilder", "securebuild", "staticBuilder", " stableVersion", "prettyBuild", "baseBuild", "validBuilder", "basebuild", "prettyVersion", "baseVersion", "compatibleBuilder", "staticbuild", "latestbuild", "prettyBuilder", "prettybuild", "staticBuild", "validBuild", " stablebuild", " stableBuilder", "compatiblebuild", "stablebuild", "secureBuild", "stableBuilder", "latestBuilder", "secureBuilder"]}}
{"id1": "3309233", "id2": "4750967", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doUsingConsole", " doAsyncBackground", " doAsyncStudio", " doInAsync", "buildUsingBackground", " doUsingStudio", " doAsAsync", "buildInBackground", " doAsConsole", "buildUsingStudio", "buildUsingConsole", " doInConsole", " doAsBackground", " doAsyncConsole", "buildInConsole", "buildInStudio", "buildUsingAsync", " doInStudio", " doAsyncAsync", "buildInAsync", " doAsStudio", " doUsingBackground", " doUsingAsync"], "params": ["values", "data", "eps", "ds", "s", "type", "options", "py", "services", "results", "p", "settings", "ams", "par", "arms", "ls", "page", "mes", "parts", "files", "Parameters", "Param", "posts", "lines", "address", "strings", "i", "parse", "sp", "source", "pins", "ctx", "phrase", "objects", "comments", "config", "names", "ps", "details", "keys", "pm", "properties", "los", "reports", "types", "resources", "json", "Par"], "param": ["connection", "name", "channel", " parameter", "pool", "prom", "Parameter", "monitor", "string", "mor", "p", "ams", "par", "arm", "proc", "option", "pc", "camp", "lc", "model", "page", "conn", "part", "conf", "am", "contract", "aram", "gram", "Param", "vm", "rem", "password", "address", "temp", "single", "ram", "comment", "ctx", "project", "path", "parent", "object", "iam", "prem", "default", "config", "pri", "null", "mm", "pm", "amp", "cm", "mand", "cp", "km", "pb", "meter"], "client": ["connection", "app", "force", "self", "channel", "session", "handler", "apache", "secure", "Client", "comp", "p", "plugin", "ssl", "base", "conn", "proxy", "service", "cli", "connect", "api", "project", "response", "request", "cl", "url", "config", "server", "bird", "http", "c", "ce", "google", "resource", "cm", "con", "host", "help", "cp"], "post": ["f", "posted", "head", "put", "dd", "create", "install", "body", "p", "send", "wp", "load", "json", "proc", "set", "base", "add", "part", "op", "zip", "pre", "and", "query", "e", "patch", "pp", "comment", "hop", "entry", "feed", "api", "submit", "request", "response", "Post", "POST", "next", "form", "server", "http", "c", "pos", "upload", "push", "pod", "pb"], "resp": ["rh", "Resp", "error", "handler", "respond", "body", " response", "download", "enc", "par", "received", "Response", "rec", "status", "req", "page", "conn", "content", "success", "e", "err", "reply", "comm", "sp", "api", "request", "response", "exec", "server", "http", "rel", "rep", "resource", "res", "ref", "re", "json", "fc", "serv", "obj"], "entity": ["connection", "agent", "ity", "data", "el", "body", "enc", "event", "ec", "xml", "activity", "base", "status", "model", "conn", "node", "output", "instance", "content", "article", "line", "e", "translation", "entry", "Entity", "response", "object", "attribute", "code", "unit", "person", "resource", "coll", "json", "string", "ent", "obj", "element"], "result": ["data", "name", "place", "string", "results", "status", "match", "description", "page", "text", "output", "instance", "content", "Result", "success", "line", "translation", "address", "ret", "row", "entry", "source", "value", "response", "object", "property", "url", "default", "details", "message", "resource", "res", "record", "report", "location", "json", "desc"]}}
{"id1": "15362793", "id2": "539195", "code1": "    public static String ReadURL(URL url, boolean textonly) {\n        try {\n            URLConnection uconn = url.openConnection();\n            Object ucont = uconn.getContent();\n            if (ucont instanceof InputStream) return ReadInputStream((java.io.InputStream) ucont, textonly); else return \"\" + ucont;\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"ReadURL": ["readUrl", "readHTTP", "ReadHTTP", "GetURL", "GetUrl", " ReadString", " ReadHTTP", "GetHTTP", "ReadString", "ReadUrl", "readString", " ReadUrl", "GetString", "readURL"], "url": ["connection", "sl", "loc", "twitter", "ur", "secure", "web", "jar", "str", "base", "ll", "ssl", "page", "conn", "user", "l", "bug", "err", "fr", "address", "this", "Url", "service", "URL", "source", "image", "api", "or", "path", "config", "server", "uri", "io", "http", "file", "impl", "resource", "host", "link", "string"], "textonly": ["extempty", " textOnly", "Textonly", "textOnly", "extOnly", "TextOnly", "textempty", "Textempty", "extonly", " textempty"], "uconn": ["UConn", "uconnection", "ouconnection", "Ucon", "cuconnect", "cuconnection", "Uconnect", "oucon", "cuconn", " ucon", "Uconn", "uopen", "Uconnection", "cuopen", "luconnect", "ouconn", "luopen", "ucon", "luconnection", "Uopen", "ouConn", " uconnection", "uconnect", " uConn", "luconn", "uConn"], "ucont": ["uccouch", "acnt", "uuotton", "unicontent", "uuCont", "cuont", "ucet", "ucontent", "uccront", "uccont", "acont", "unicouch", "uccant", "aucnt", "uclontent", "ucouch", "aucCont", "cuotton", "bcant", "uccontent", "uuond", "unicnt", "unicet", "acotton", "uclet", "uscCont", "ucent", "bcront", "ucond", "aucond", "aucent", "uscont", "ucnt", "uclont", "ucCont", "unicant", "aucotton", "uclouch", "uccnt", "uuont", "uscotton", "bcont", "ucotton", "cunt", "acent", "uscond", "cuent", "unicront", "aucont", "ucant", "uccet", "bcnt", "ucront", "unicont"]}}
{"id1": "11049257", "id2": "18202328", "code1": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "code2": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "label": 1, "substitutes": {"generate": [" genation", " genate", "GenerATE", "generATE", " genating", "validating", "Generate", "validATE", "generating", "Generation", "validate", "generation", "Generating", "validation", " genATE"], "secure": ["https", "secondary", "force", "socket", "session", "remote", "encrypted", " securely", "sys", "ssl", "ite", "zip", "deep", "password", "client", "sensitive", "secret", "sq", "proxy", " insecure", " secured", "service", "sec", "express", "config", "quiet", "server", "protect", "ssh", "weak", "Secure", "sr", "debug", "host", "security", "stable"], "sep": ["spepel", "perseep", " seb", "sepa", "sepel", "SEp", "spep", "sepent", "ensepel", "SEpa", " sepa", "SEb", "sept", " sepel", "seep", " sepent", " seep", "persepa", "persep", "ensepent", "spepent", "seb", "perseb", "spept", "ensept", "ensep", " sept", "SEep"], "messagedigest": ["messagagse", "messagedighester", "messagedaghest", "messagedigester", "messagedagist", "messagedigress", "messagedimester", "messagedimest", "messagigester", "messagedligester", "messageddighest", "messagedighse", "messagagher", "messagigest", "messagedegher", "messagighester", "messagaghest", "messagedighEST", "messagedegester", "messagigress", "messageddigher", "messagedigse", "messagagester", "messagigist", "messagagest", "messagedeghest", "messagagress", "messagedagest", "messagedigist", "messagedimist", "messagedligist", "messagedighest", "messagighEST", "messageddigester", "messagedagress", "messagighest", "messagedligEST", "messagagEST", "messagedligress", "messagedigEST", "messagighse", "messagedagher", "messagedagEST", "messagagist", "messagedligse", "messagedimress", "messagigEST", "messageddigest", "messagedegest", "messagedigher", "messagedagester", "messagedligest", "messagedagse", "messagigse", "messagigher"], "stringbuffer": ["serialbuffer", " stringbuf", "writebuf", " stringsource", "binarybuf", "systemqueue", "numberbuf", "Stringbuffer", " stringbuff", "groupuffer", "jsonbuffer", "stringcache", "ringurl", " stringqueue", "stringbase", "binarybuffer", "stringboard", "Stringbase", "stringaddress", "stringbuff", "stringmanager", "defaultbuf", "groupbuf", "stringurl", "serialboard", " stringmanager", "systembuffer", " stringuffer", "linequeue", "functionbuffer", " stringcache", "stringbuilder", "writebuff", "arraybuf", "numberqueue", "numberbuffer", "linebuffer", "arraybuffer", "systembuff", "stringthrow", "filecache", "fileboard", "numberbuilder", "ringmanager", "filemanager", "defaultbuffer", "defaultqueue", "groupbuffer", "filebuff", "groupaddress", "binarythrow", "writethrow", "functionbuf", " stringurl", "stringqueue", "fileurl", "linebuf", "linebuff", "ringsource", " stringthrow", "jsonaddress", "serialcache", "Stringbuf", "systembuf", "filesource", "numberbase", "arraybase", "writebuffer", "ringbuffer", " stringboard", "stringsource", "defaultaddress", "serialbuff", "arraybuilder", "functionbuff", "jsonuffer", " stringaddress", "jsonbuf", "stringuffer", "numberaddress", "binarybuff", "stringbuf", "Stringbuilder", "filebuffer", "functionqueue"], "stringbuffer2": ["stringpage2", "stringbuf82", "objectbuffer5", "stringbuff10", "stringbuf002", " stringBuffer4", " stringbuffer3", "objectbuff2", "stringbufAll", "stringbuff32", "stringbase3", " stringreaderTwo", " stringcommentTwo", "doubleBuffer3", "stringbuf3", "stringbuffL", "stringufferII", "stringbuilder02", "stringbuffCache", "stringfb2", "stringfbCache", " stringbuffer12", "doublebufferTwo", "stringbarTwo", "stringuffer64", "stringloopL", "stringcopy62", "stringloaderII", " stringcomment2", " stringbuffer5", " stringbuffer02", "stringbuffType", "stringpageL", "stringbuffer10", "stringbuffer02", "stringcode2", "stringbufferL", "doubleBuffer2", "stringbar32", "stringloader64", "stringbuffer12", "doublebuffer52", "stringbuff62", "stringbufType", "stringcache02", " stringloop2", " stringBuffer52", "stringbuffer4", " stringbufferAll", "finalbuffer5", "stringviewTwo", "stringbuffer62", "stringbuff200", " stringbuffer82", "stringbase2", "doublebuffer1", " stringbuffer8", "stringBuffer1", " stringBuffer3", "stringcomment2", "stringfbAll", "doublebuffer3", "doublebuffer4", "listbufferL", "stringbuffAll", " stringreaderII", "stringbuilder12", "stringbuffer82", "stringcode5", "stringbuff8", "stringbuffer002", " stringbufferCache", "stringbuff4", "doubleBuffer4", "stringbuffer64", "stringcache12", "stringreaderII", " stringcache02", " stringloop8", " stringbuffer52", " stringfb20", "stringbuff20", "objectbuff5", "stringserverTwo", "finalbuff2", "stringqueue62", " stringbuffer200", "stringbuff1", "stringbreak4", "stringloaderTwo", "stringbufferAll", "stringview2", "stringbuf52", " stringbufferTwo", "stringloop200", "stringcache2", "stringbufferTwo", "stringbuff3", "doubleBuffer52", "stringloopTwo", "stringbreak2", "stringcache10", "stringbuffTwo", "objectbuff62", "stringcomment002", "listbufferTwo", "stringbuilder10", "stringserver002", "stringloader2", " stringbuffer002", "finalbufferTwo", "stringpageTwo", " stringcode5", "stringreader2", "listloop2", "stringbar5", "finalbuffer2", " stringcache2", "stringloop2", "stringBuffer2", "stringbufCache", "stringcodeTwo", "listloopL", "objectbuffer62", "stringuffer2", "stringfb200", " stringloop200", "stringview52", " stringreader64", "stringloop02", "stringbuf4", " stringloopTwo", "stringBuffer52", "stringbreak3", "finalbuffTwo", "stringbase52", "stringbufferII", " stringcache12", "finalbufferType", "stringBuffer4", "stringview4", " stringreader2", "stringserver82", "finalbuffType", " stringbuffer20", "stringreaderTwo", " stringfbCache", " stringcomment82", " stringbuffer10", "stringbufferCache", "stringfbTwo", "stringbufTwo", "stringqueue5", "stringserver5", "stringbuffer200", " stringfb2", "stringbase4", "stringbuffer20", " stringcode2", "stringcode32", "stringloop8", "stringbuf20", " stringcache10", "stringBufferTwo", " stringcodeTwo", " stringbuffer64", "stringbuffer5", "stringbuff02", " stringcode32", " stringfbAll", "stringreader64", "stringpage02", "stringbuilder2", "finalbuff5", "stringcopy5", "stringbreak1", "doubleBuffer1", "listbuffer2", "stringbuffer8", "stringbuf5", "stringbuff12", "stringbufferType", "listbuffer02", "objectbuffer2", "listloopTwo", "stringqueue2", "stringserver2", "stringBuffer3", "stringbuffer32", " stringbufferII", "stringcopy2", "stringcommentTwo", "stringfb8", "stringbar2", "stringbuff2", "stringufferTwo", " stringbuffer32", "doublebuffer2", "stringbuffer52", "listloop02", " stringbuffer4", "doubleBufferTwo", "stringserverType", " stringcomment002", "stringbuffer3", " stringBuffer2", "stringbuf2", "stringcomment82", "stringbuff5", "stringfb20"], "inetaddress": ["networkAddress", "iotimage", "etimage", "etaccount", "tunimage", "inetimage", "tunAddress", "nethost", "ethost", "inethost", "netaddress", "iotAddress", "etaddr", "tunaccount", "tunaddress", "netaddr", "etaddress", "inetaccount", "networkaddress", "etAddress", "networkaddr", "netAddress", "iotaddress", "inetAddress", "networkhost", "inetaddr", "iotaccount"], "l": ["sl", "tl", "f", "lp", "al", "dl", "el", "m", "p", "ll", "lc", "ls", "kl", "u", "b", "r", "L", "lf", "lang", "d", "z", "t", "lb", "v", "lr", "li", "n", "nl", "c", "lv", "ln", "rl", "length"], "l1": ["l81", "l51", "l2", "ll1", " lOne", "lc1", " l2", "il1", "sl2", "L7", " l5", " l7", " l81", "l5", "lx", "L2", "lc2", "il51", " lone", " lx", "L81", "llone", "sl1", "sl5", "Lx", "il5", "slOne", "ll2", "Lone", "ll81", "cl1", "lOne", "sl51", "lone", "l7", "lcx", "clOne", "lc7", "cl2", "L1", " l51"], "abyte0": ["byte000", "ome0", "iterator000", "iterator1", "ome1", "abytei", "iterator8", "abase0", "abytes1", "abasekeeper", "abytes8", "abase50", "umboj", "umboi", " arrayzero", "abyte000", "omej", "bytei", "byte1", "abytezero", " array50", "abasezero", "abytej", "omei", "gmentkeeper", " array0", "byte8", " arraykeeper", "bytej", "abyte1", "umbo1", "abytes000", "abytekeeper", "umbo0", "gmentzero", "abyte8", "abyte50", "iterator0", "byte0", "gment0", "gment50", "abytes0"], "stringbuffer1": [" stringview1", " stringviewone", "stringbuffer01", "Stringbuffer1", "stringview81", " stringbuffer3", "stringviewFirst", "stringbuf1", "StringBuffer2", "stringufferone", "Stringbuffer11", "stringbuf3", "stringview1", "doubleBuffer81", "stringbuff11", "stringlayer81", " stringuffer3", "stringBuffer8", "doubleBuffer2", " stringbufferone", " stringuffer01", "stringufferOne", "stringbuffer11", "doublebuffer81", "stringbuilder8", "Stringbuffer8", "StringBuffer8", "doublebuffer1", "stringBuffer1", "stringlayerone", "doublebufferOne", "doubleBufferOne", "stringbuff8", "stringuffer1", "stringbufferOne", "stringviewone", "stringuffer01", " stringviewFirst", "stringbufferFirst", "stringBuffer81", "stringufferFirst", "stringbuff1", "stringbuf01", "stringbuff3", " stringbufferFirst", "StringBuffer11", "stringbufferone", "stringBuffer2", "stringbuff01", "stringuffer2", "stringBuffer11", " stringuffer1", "stringuffer3", "stringbuilder2", "doubleBuffer1", "StringBuffer1", "stringbuffer8", "stringbuilder1", "stringlayerFirst", "stringbuffer81", "stringBufferOne", " stringbuffer81", "Stringbuffer2", "stringbuilder11", "stringbuff2", "stringuffer81", " stringview81", "doublebuffer2", " stringbuffer01", "stringlayer1", "stringbuffer3"], "i": ["x", "ji", "f", "y", "si", "ti", "ri", "slice", "p", "ori", "pi", "k", "ind", "ie", "ix", "hi", "I", "di", "u", "bi", "qi", "fi", "e", "o", "ini", "abi", "d", "ci", "z", "h", "xi", "v", "oi", "ui", "mi", "yi", "li", "uri", "n", "ii", "io", "c", "in", "id", "index", "iu", "vi", "eni", "ai", "gi", "phi", "ip"], "j": ["x", "job", "ji", "ij", "f", "jj", "bj", "si", "note", "g", "p", "kj", "k", "ie", "ix", "b", "jp", "jet", "qi", "aj", "ja", "e", "journal", "o", "cell", "jc", "d", "z", "ali", "ch", "js", "J", "v", "li", "n", "ii", "jo", "c", "jack", "jl", "oj", "dj", "adj", "length", "json", "obj"], "s": ["ts", "f", "hes", "g", "ins", "bs", "m", "services", "sets", "results", "p", "ns", "str", "os", "ssl", "is", "ls", "words", "u", "b", "sports", "parts", "abs", "sv", "r", "rs", "e", "its", "o", "lines", "strings", "resses", "S", "hs", "ws", "ings", "qs", "t", "js", "h", "xs", "v", "bis", "gs", "n", "styles", "south", "ps", "http", "c", "as", "ions", "sites", "series", "a", "seconds", "states", "es", "ss", "tests", "sb", "us", "ms", "ches", "string", "fs", "ses"]}}
{"id1": "20208819", "id2": "16063533", "code1": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "label": 1, "substitutes": {"hash": ["get", " hashing", "str", "dump", "copy", "format", "check", "output", "num", " Hash", "mix", "parse", "build", "pack", "sum", "update", "code", "raw", " hashes", "print", "Hash", "string", "SHA"], "input": ["reader", "inf", "data", "current", "addin", "audio", "seed", "string", "array", "str", "binary", "text", "output", "instance", "inner", "plus", "address", "temp", "buffer", "source", "image", "feed", "request", "parent", "form", "url", "context", "config", "raw", "null", "in", "upload", "length", "accept", "Input"], "algorithm": [" algorith", "calgorithm", "algebra", "Algo", "Algorithm", " algebra", "calgebra", "Algorith", "aliphabet", "calgorith", "algo", " algo", "aligorithm", " alphabet", "aligebra", "Algebra", "alphabet", "algorith", "calgo", "aligo", "Alphabet"], "dig": ["ag", "enc", "get", "cd", "g", "grad", "pin", "dec", "ex", "comb", "div", "fe", "gen", "im", "sem", "me", "log", "lab", "Dig", "add", "wrap", "alg", "ld", "rob", "num", "and", "um", "dim", "imag", "mix", "del", "test", "d", "cmp", "ig", "build", "init", "db", "mod", "rg", "cod", "rd", "sign", "prep", "rand", "ng", "grab", "pm", "tool", "dat", "exp", "push", "de"], "result": ["df", "su", "iter", "data", "current", "manager", "card", "master", "string", "results", "array", "counter", "ger", "match", "format", "future", "page", "user", "output", "Result", "success", "work", "root", "member", "dest", "this", "ret", "buffer", "test", "source", "db", "value", "api", "builder", "response", "url", "our", "sum", "default", "group", "uri", "consumer", "null", "up", "global", "function", "valid", "message", "res", "diff", "cover", "record", "report", "length", "re", "json", "runner"], "digest": ["dige", "signEST", "generest", " digests", "DigEST", "generests", " Dige", "Digester", " Digest", "generester", "digested", " dige", "bigested", "bigests", "digester", "Digse", "bigester", "digEST", "Dige", "bigest", "digse", "signester", " digEST", "Digested", "generEST", " Digester", "signest", " digse", " DigEST", "digests", " digested", "signse", " digester", "Digest", "Digests"], "hex": ["rh", "bin", "iter", "data", "char", "digit", "head", "ctr", "array", "buff", "hess", "rex", "ex", "zero", "xf", "format", "shift", "check", "text", "pixel", "ph", "num", "throw", "sex", "zip", "address", "temp", "mix", "row", "pex", "wh", "h", "pattern", "ticket", "form", "uint", "sum", "oct", "null", "transform", "index", "utf", "header", "length", "cube", "string", "bit"], "i": ["x", "f", "y", "si", "it", "ti", "ri", "j", "p", "info", "pi", "ix", "hi", "I", "bi", "b", "di", "multi", "qi", "l", "e", "o", "uli", "abi", "d", "ci", "z", "t", "h", "xi", "v", "oi", "ui", "li", "n", "uri", "ii", "io", "c", "id", "iu", "a", "index", "mu", "ai", "gi", "phi"], "u": ["x", "ul", "cur", "su", "f", "sup", "char", "bu", "q", "un", "uu", "ur", "p", "pu", "ru", "b", "U", "num", "l", "e", "o", "lu", "back", "yu", "d", "fu", "uc", "h", "v", "ue", "ui", "uri", "du", "uv", "cu", "c", "up", "hu", "iu", "mu", "chu", "uf", "uid", "ou", "us", "uni", "string", "nu", "tu"], "highCount": ["largeCode", "lowLength", "highCode", "highercount", "higherCode", "higherCount", "largeSize", "highC", "largeCount", "highSize", "higherCast", "fullCast", "hiSize", "hiCode", "HighCode", "higherSize", "HighSize", "lowCode", "fullcount", "HighC", "HighCount", "fullCount", "HighLength", "hiCount", "largeC", "highCast", "lowCast", "higherC", "lowSize", "highLength", "hiLength", "highcount", "lowcount"], "lowCount": ["slowCount", "highSum", "lowLength", "LowCount", "lowC", "highC", "highSize", "LowSize", "slowSum", "lowerLength", "slowCast", "LowC", "lowerC", "lowerSize", "lowerCast", "lowerSum", "LowCast", "highCast", "lowCast", "lowSize", "lowerCount", "slowLength", "highLength", "lowSum"]}}
{"id1": "22431487", "id2": "4830847", "code1": "    public static String doPost(String URL, List<NameValuePair> params) {\n        try {\n            OauthUtil util = new OauthUtil();\n            URI uri = new URI(URL);\n            HttpClient httpclient = util.getNewHttpClient();\n            HttpPost postMethod = new HttpPost(uri);\n            StringBuffer paramString = new StringBuffer();\n            paramString.append(\"OAuth\");\n            for (int i = 0; i < params.size(); i++) {\n                paramString.append(\" \" + params.get(i).getName());\n                paramString.append(\"=\\\"\" + encodeUrl(params.get(i).getValue()) + \"\\\",\");\n            }\n            String xx = paramString.substring(0, paramString.length() - 1);\n            postMethod.addHeader(\"Authorization\", xx);\n            HttpResponse httpResponse = httpclient.execute(postMethod);\n            if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                String strResult = EntityUtils.toString(httpResponse.getEntity());\n                Log.i(\"DEBUG\", \"result: \" + strResult);\n                return strResult;\n            }\n        } catch (Exception e) {\n            Log.i(\"DEBUG\", e.toString());\n        }\n        return null;\n    }\n", "code2": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "label": 0, "substitutes": {"doPost": [" doLoop", "doPosts", "doRequest", "formRequest", "apiPosts", "apiPost", "formPosts", " doPosts", "formPost", "apiRequest", "formLoop", "doLoop", "apiLoop", " doRequest"], "URL": ["URI", "File", "IO", "PORT", "R", "METHOD", "IP", "API", "WS", "HTML", "Address", "Url", "SSL", "url", "Name", "Page", "HTTP", "IR", "ID", "http", "CL", "PATH", "Base", "Location", "DIR", "UR", "Path", "resource", "JSON", "FILE", "DB", "GI", "string", "NAME", "SR"], "params": ["values", "data", "name", "s", "options", "services", "array", "results", "p", "settings", "ams", "pi", "par", "param", "relations", "arms", "is", "ls", "words", "parts", "members", "features", "Parameters", "apps", "rs", "Param", "strings", "ras", "list", "pins", "parse", "api", "request", "url", "vs", "names", "afi", "server", "ps", "http", "details", "terms", "photos", "pos", "changes", "users", "es", "properties", "types", "resources", "json", "Par", "ip"], "util": ["su", " url", "manager", "install", "auto", "ut", "universal", "utils", " utility", "mut", "u", "U", "internet", " u", "kit", "client", "lu", "utt", "anti", "cli", "lib", "init", "gui", "Ut", "api", "spec", "url", "ui", "general", "unit", "io", "http", "global", "impl", "iu", "mu", "valid", "string", "il"], "uri": ["connection", "URI", "absolute", "ri", "iri", "database", "handler", "pi", "base", "plugin", "API", "U", "Manager", "PI", "client", "address", "Url", "cli", "service", "api", "request", "path", "response", "url", "ui", "config", "server", "route", "io", "http", "id", "resource", "uni", " URI"], "httpclient": ["Httpapi", " httpmethod", "httpapi", " httpClient", "httpmethod", "htmlserver", "httpsapi", " httpconnection", " httpapi", "httpserver", "htmlmethod", "httpsconfig", "Httpserver", "htmlClient", "Httpmethod", " httpconfig", "HttpClient", "Httpconnection", "httpClient", "httpconnection", " httpserver", "Httpclient", "Httpconfig", "httpsclient", "htmlclient", "httpconfig", "httpsconnection"], "postMethod": ["POSTFunction", " postPath", " postmethod", " postRequest", " postFunction", "PostFunction", "postMessage", "POSTmethod", "PostMethod", "postFunction", "POSTMethod", "patchMethod", "Postmethod", "patchFunction", "POSTRequest", "PostMessage", "PostRequest", " postMessage", "typeFunction", "patchPath", "typeMethod", "typemethod", "PostPath", "typeRequest", "patchMessage", "postRequest", "postPath", "postmethod"], "paramString": ["paramStr", " paramArray", "paramstring", "memberFile", "priArray", "paramsStr", "paramFile", "ParamStream", "paramsArray", "cmService", "cmArray", "Paramstring", "parString", "ParamArray", " paramstring", "errorArray", "priStr", "ParamFile", "parFile", "paramStream", "parStream", " paramStr", "ParamString", " paramFile", "memberArray", "ParamBuffer", "paramBuffer", "ParamList", "parArray", "errorString", "paramList", "memberstring", " paramBuffer", "cmString", "errorBuffer", "errorFile", "ParamService", "paramArray", "paramsList", "cmstring", "memberString", "priString", "priBuffer", " paramService", " paramStream", "ParamStr", "paramsString", "paramService", " paramList"], "i": ["x", "ji", "f", "data", "y", "si", "name", "it", "ti", "ri", "q", "s", "slice", "iv", "g", "m", "p", "j", "info", "pi", "k", "ori", "ie", "ix", "is", "hi", "ei", "I", "di", "u", "b", "part", "multi", "bi", "qi", "l", "e", "o", "key", "ini", "d", "count", "ci", "cli", "z", "t", "xi", "oi", "v", "ui", "li", "n", "ii", "io", "c", "in", "id", "index", "iu", "ic", "eni", "ai", "gi", "length", "ip"], "xx": ["x", "XXX", "Code", "cn", "ux", "ant", "ww", "ck", "enc", "zz", "vv", "yy", "xy", "X", "ax", "key", " XX", "pp", "xxx", "xxxx", "XX", "cc", "response", "xi", "xa", "XXXX", "code", "pass", "xxxxxxxx", "foo", "prefix", "header", "ss", "uid", "host", "json", "act"], "httpResponse": ["phpResponse", "Httpresponse", "HttpRequest", " httpClient", "postResp", "phpResp", "HttpReply", "phpClient", "httpReply", " httpReply", "hrresponse", "httpRequest", "httpresponse", "HttpConnection", " httpRequest", "HttpClient", "httpResp", "phpresponse", " httpresponse", "httpClient", " httpConnection", "HttpResp", "HttpResponse", " httpResp", "hrReply", "postConnection", "hrResp", "hrResponse", "postRequest", "postResponse", "httpConnection"], "strResult": ["StrRes", "objReturn", "drResponse", "objResponse", " strReturn", " strRes", " strStatus", " strResponse", "strStatus", "strResponse", "stringRes", "StrResult", "stringReturn", "Strresult", "strRes", "stringResult", "strresult", "drStatus", " strresult", "drresult", "drResult", "StrResponse", "objResult", "objresult", "stringResponse", "StrStatus", "strReturn", "StrReturn"]}}
{"id1": "7945594", "id2": "7468819", "code1": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "label": 1, "substitutes": {"fileDownload": ["folderURL", "urlPull", " filePull", "filePull", "urldownload", "filedownload", "fileURL", " fileURL", "folderPull", "urlDownload", "folderdownload", "urlURL", " filedownload", "folderDownload"], "fAddress": ["bPath", " faddr", "baddr", "fPath", "fingaddr", "FAdd", "rfLocation", "fOrder", "fEmail", "sfMessage", "bAdd", "urlAdd", "bLocation", " fPath", "fileLocation", "baddress", "sfAddress", "bEmail", "sfPath", "fingEmail", " faddress", "fLocation", " fAdd", "faddr", "sfAdd", "rfMessage", "fileAddress", "rfaddress", "urladdress", "bAddress", "fMessage", "urlAddress", "fAdd", "sfLocation", " fEmail", "sfaddress", "rfAddress", "fileAdd", "fingAdd", " fLocation", "urlOrder", "sfOrder", " fMessage", "FAddress", "faddress", "FLocation", " fOrder", "fingAddress"], "destinationDir": ["destributionDir", "destinationDIR", "destinationDirectory", "destinatedDur", "destributionDirectory", "destativeArea", "destippingDir", "destinationDur", "DestributionDIR", "destinatedDir", "declinatedPath", "DestinationArea", "declinatedDur", "DestinationDirectory", "destributionDIR", "destributionDur", "destippingArea", "destributionDar", "declinatedDir", "destinatedPath", "DestributionDirectory", "destippingDirectory", "declinationDur", "destativeDIR", "declinationDir", "destineDur", "DestinationDir", "declinatedDar", "declinationDar", "destineDar", "DestinationDIR", "destinationDar", "destinationPath", "destinePath", "declinationPath", "DestributionDir", "destinationArea", "destippingDIR", "DestributionArea", "destativeDirectory", "destributionArea", "destativeDir", "destributionPath", "destineDir", "destinatedDar"], "slashIndex": ["sllashLength", "SlashedIndex", "SlashIndex", "slashedLength", "Slashindex", "SlashedCount", "SlashCount", "slashindex", "slashedCount", "slargeindex", "slargeLength", "slushLength", "sllashindex", "slashedindex", "sllashIndex", "SlashLength", "slushIndex", "slashLength", "Slashedindex", "slushindex", "SlashedLength", "slargeIndex", "slashCount", "slashedIndex", "slargeCount", "sllashCount"], "periodIndex": [" periodOffset", "dollarIndex", " periodStart", "moneyIndex", "moneyStart", "moneyindex", "dollarStart", "dollarOffset", "periodindex", " periodindex", "periodStart", "periodOffset", "dollarindex", "moneyOffset"], "fileName": ["FilePath", "fname", " fileAddress", "FileAddress", "fPath", "FileName", "fileAddress", "filePath", "fName", "Filename", "filename", " filename", " filePath"], "url": ["ul", "connection", "open", "sl", "f", "loc", "org", "fl", "channel", "socket", "uu", "ur", "web", "download", "str", "base", "log", "ssl", "ll", "page", "u", "blog", "conn", "user", "plug", "l", "bug", "Url", "proxy", "URL", "service", "image", "feed", "api", "ch", "path", "config", "li", "uri", "oc", "server", "http", "c", "up", "resource", "www", "ou", "bel", "link", "rl", "re", "rel", "string", "ob"], "uc": ["ul", "connection", "cur", "union", "nc", "uu", "sc", "unc", "stream", "ec", "pc", "rc", "lc", "cci", "usc", "u", "conn", "auc", "exc", "um", "ci", "cc", "cus", "ucc", "anc", "hub", "UC", "oc", "cu", "uci", "http", "c", "com", "tc", "soc", "con", "ou", "mc", "ac", "fc", "bc"], "in": ["reader", "bin", "login", "f", "data", "into", "it", "socket", "s", "ins", "stream", "cin", "In", "rc", "is", "inside", "conn", "b", "inner", "again", "din", "r", "IN", "err", "ini", "this", "i", "source", "cli", "init", "image", "inc", "nin", "n", "io", "inn", "c", "up", "lin", "input", "con", "ac", "gin"], "file": ["full", "connection", "f", "data", "name", "File", "socket", "place", "book", "to", "fe", "letter", "base", "log", "per", "rule", "class", "page", "b", "output", "files", "zip", "l", "line", "e", "o", "this", "source", "ile", "path", "parent", "filename", "io", "folder", "up", "FILE", "resource", "fp", "dir"], "fos": ["fileob", "Fo", "FOs", "fis", " fOs", "fileOs", "sfos", " fis", "sfo", "FOS", "Fops", "fOS", " fOS", "fileos", "fob", "sfOS", "Fob", "Fis", "fops", "fOs", " fob", "Fos", " fo", "fo", "sfis", " fops", "fileops"], "out": ["bin", "f", "data", "s", "down", "sync", "to", "outs", "plain", "log", "copy", "w", "inner", "output", "b", "again", "line", "writer", "work", "err", "o", "flush", "OUT", "block", "init", "inc", "exec", "outer", "update", "io", "net", "up", "ou", "Out", "string", "write"], "inputLine": ["outputLine", "inputRow", " inputBlock", "outputLINE", "InputChar", " inputRow", "errorL", "outputL", "outputline", "inputL", " inputEl", "outputEl", "inputChar", "InputEl", " inputline", " inputChar", "errorLine", " inputLINE", "InputLine", "InputBlock", "InputL", " inputL", "Inputline", "outputRow", "outputBlock", "inputLINE", "outputChar", "inputline", "errorRow", "inputBlock", "inputEl", "errorLINE"]}}
{"id1": "17337238", "id2": "7927042", "code1": "    private Retailer create() throws SQLException, IOException {\n        Connection conn = null;\n        Statement st = null;\n        String query = null;\n        ResultSet rs = null;\n        try {\n            conn = dataSource.getConnection();\n            st = conn.createStatement();\n            query = \"insert into \" + DB.Tbl.ret + \"(\" + col.title + \",\" + col.addDate + \",\" + col.authorId + \") \" + \"values('\" + title + \"',now(),\" + user.getId() + \")\";\n            st.executeUpdate(query, new String[] { col.id });\n            rs = st.getGeneratedKeys();\n            if (!rs.next()) {\n                throw new SQLException(\"\u041d\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c generated key 'id' \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 retailers.\");\n            }\n            int genId = rs.getInt(1);\n            rs.close();\n            saveDescr(genId);\n            conn.commit();\n            Retailer ret = new Retailer();\n            ret.setId(genId);\n            ret.setTitle(title);\n            ret.setDescr(descr);\n            RetailerViewer.getInstance().somethingUpdated();\n            return ret;\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (Exception e1) {\n            }\n            throw e;\n        } finally {\n            try {\n                rs.close();\n            } catch (Exception e) {\n            }\n            try {\n                st.close();\n            } catch (Exception e) {\n            }\n            try {\n                conn.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    private void loadDynamically(File result, String extraPath) {\n        URL url = null;\n        InputStream is = null;\n        FileOutputStream fos = null;\n        try {\n            url = new URL(homeServerUrl + extraPath);\n            is = url.openStream();\n            fos = new FileOutputStream(result);\n            byte[] buff = new byte[8192];\n            int nbRead;\n            while ((nbRead = is.read(buff)) > 0) fos.write(buff, 0, nbRead);\n        } catch (IOException e) {\n            throw new StellariumException(\"Cannot dynamically load \" + result + \" from \" + url);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"create": ["save", "open", "created", "creator", "type", "one", "destroy", "setup", "add", "copy", " recreate", "instance", "creation", "construct", "init", "request", "Create", "update", "config", "store", "make", " Create", "record", "replace", "insert", "write", "start"], "IOException": [" IOception", "DatabaseException", "TimeoutException", "IOError", "IOception", "DatabaseError", "Timeoutception", "Databaseception", "TimeoutError", " IOError"], "conn": ["connection", "nt", "lock", "ens", "loc", "cn", "reg", "nc", "error", "session", "ds", "oss", "wd", "ca", "ct", "Connect", "p", "sync", "dn", "enc", "pub", "en", "os", "ann", "rc", "log", "pr", "ht", "conf", "cr", "r", "err", "client", "ci", "cc", "db", "connect", "ch", "ctx", "h", "n", "rt", "Conn", "c", "dh", "Coll", "po", "coll", "res", "con", "sql", "pg", "Connection", "col", "cp", "ad", "apt", "ob", "act"], "st": ["nt", "sl", "ts", "ess", "sn", "ds", "s", "sc", "put", "pt", "dd", "ct", "stop", "ist", "sync", "inst", "mt", "se", "sth", "str", "ut", "ast", "ste", "ld", "pr", "sts", "ust", "ST", "cr", "r", "td", "fr", "std", "step", "sp", "db", "t", "St", "sta", "sw", "cl", "rd", "rt", "sa", "src", "sb", "ost", "con", "ss", "nd", "ft", "est", "sh", "rest"], "query": ["statement", "question", "where", "q", "error", "database", "table", "command", "seed", "qq", "how", "filter", "clean", "timeout", "str", "rule", "qu", "pr", "description", "iq", "term", "cr", "sq", "test", "comment", "rr", "parse", "build", "select", "value", "request", "form", "update", "sum", "dq", " Query", "uri", "code", "scope", "script", "search", "index", "ql", "result", "resource", "join", "eries", "sql", "report", "push", "string", "json", "Query"], "rs": ["mr", "ts", "ues", "reg", "rows", "RS", "rm", "issues", "ds", "s", "ack", "ins", "results", "Rs", "acks", "vers", "ns", "ows", "rc", "arms", "ys", "cs", "ls", "req", "pr", "ans", "cr", "r", "repl", "runs", "dr", "rr", "ras", "rys", "row", "hs", "hr", "ws", "ars", "rg", "xs", "vs", "rd", "rt", "ps", "ris", "sr", "rss", "asts", "ros", "res", "ges", "result", "ms", "rl", "ers", "ks", "rx"], "genId": ["gID", " genType", "genInt", "ginid", "gid", "genID", " genById", " genID", "winID", "gId", " genid", "Genid", "ginById", "winId", "ginId", "genType", "GenID", "winid", "genById", "generType", "generId", "winById", "libId", "ginID", "generInt", "genid", " genInt", "libInt", "libType", "GenId"], "ret": ["ext", "login", "data", "vr", "detail", "proc", "class", "RET", "val", "cat", "default", "Reg", "rt", "search", "gt", "usr", "pro", "re", "ft", "fit", "active", "seq", "vet", "Ret", "pub", "success", "att", "back", "reply", " Ret", "general", "let", "REG", "id", "result", "bf", "Pub", "pb", "job", "f", "reg", "true", "place", "fun", "part", "repl", "r", "res", "ref", "auth", "arg", "obj", "resp", "grid", "alt", "det", "rev", "gen", "utils", "bot", "rc", "base", "match", "num", "proxy", "entry", "db", "response", "v", "server", "tr", "def", "rets", " result", "desc"]}}
{"id1": "18433984", "id2": "21656668", "code1": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doUpload": ["DoDownload", "runUpload", "doupload", "doDownload", "DoSave", "doSave", "DoUpload", " doupload", "runDownload", "runupload", "Doupload", "runSave", " doSave", " doDownload"], "request": ["data", "current", "version", "type", "QUEST", "worker", "operation", "quest", "art", "subject", "buffer", "requ", "path", "url", "transfer", "message", "resource", "queue", "join", "header", "initial", "report", "re", "session", "stream", "page", "content", "query", "client", "parent", "Request", "context", "document", "result", "accept", "json", "use", "complete", "create", "method", "command", "info", "state", "param", "xml", "model", " Request", "r", "temp", "image", "submit", "config", "hello", "raw", "http", "upload", "connection", "er", "get", "q", "head", "application", "ware", "event", "match", "req", "require", "user", "instance", "condition", "child", "object", "view", "server", "file", "frame", "input", "string"], "response": ["connection", "Resp", "stream", "application", "xml", "Response", "status", "model", "page", "output", "content", "client", "reply", "image", "document", "view", "server", " Response", "message", "resource", "result", "report", "onse", "re", "json", "resp"], "reqSession": ["rbSession", "qClient", " reqSecret", "requSession", "reqLog", "rbClient", "rbsession", "clientCh", "tempsession", "rbLog", "tempSession", "rbConn", "refSession", "requsession", "clientSocket", "clientsession", "refLog", "tempCh", " reqession", "requConn", " reqLog", "reqession", "rbession", "reqConn", "refSecret", "reqsession", "reqSocket", "rbSecret", "reqCh", "requClient", "refession", "qSession", "reqClient", "clientSession", "qsession", " reqsession", "reqSecret", "tempSocket", "qConn", " reqCh", " reqSocket"], "uploadFiles": ["transferfiles", "UploadFiles", "UploadFile", "transferResources", "uploadResources", " uploadfiles", " uploadResources", "UploadResources", "uploadfiles", " uploadFile", "transferFiles", "uploadFile", "transferFile", "Uploadfiles"], "tempDirName": ["tempDirectoryKey", "tempDirectoryname", "cacheDirName", "tempFileSize", "tempVername", "tempVerCode", "tempAreaSize", " tempDirCode", " tempFilename", "cacheDirname", " tempFileName", "tempFoldername", "tempFolderCode", "tempDirSize", "TempDirectoryName", "tempDirectoryHome", "tempVerDesc", "tempDirectoryName", "tempDirDesc", " tempFolderCode", "tempDirInfo", "tempDirectoryInfo", "tempFolderDesc", "cacheDIRHome", "TempDirectoryCode", "cacheDIRName", "tempFileCode", "tempFolderPath", "tempFolderPart", "tempDirHome", "TempDirKey", "tempDIRName", "cacheDIRname", "tempDirectoryPart", "TempDirPath", "tempAreaName", "tempFolderKey", "tempDirCode", "tempVerName", "tempDirPath", " tempFileInfo", "tempFilename", "tempFileKey", "tempDirectoryCode", "tempDirectorySize", "tempDirKey", " tempDirDesc", "tempDIRPart", "cacheDIRPart", "tempDirname", " tempDirInfo", " tempFolderDesc", "tempDIRHome", "tempFilePath", "tempDirectoryPath", "tempFolderName", "tempFileInfo", " tempDirSize", "TempDirCode", "tempDirectoryDesc", "tempAreaname", "tempDIRname", " tempFileSize", "tempFileName", " tempFoldername", "TempDirectoryPath", "tempAreaInfo", "cacheDirHome", "tempDirPart", " tempFolderName", "cacheDirPart", " tempDirname", "TempDirName", "TempDirectoryKey", "tempFolderHome"], "tempUploadDir": [" tempUploadManager", "temUploadPath", "tempDownDirectory", " tempDownloadFolder", "testBuildD", " tempUploadArea", "testBuilddir", "tempUploadInfo", "TempUploadDirectory", " tempStreamJar", "tempFileFolder", "tempuploadFolder", "tempDownDir", "tempTempdir", "tempDownloadManager", "tempCaptureJar", "tempUploadD", "temuploadPath", "tempUploadFile", "tempDownloadDb", "tempBuildDir", "tempDownFolder", "TempUploadFolder", "tempStreamFolder", "TempUploadDir", "TempUploadDb", " tempUploadDirectory", "tempImagedir", "testUploadJar", "tempImageDir", "TempDownloadDirectory", "tempAttachUrl", "testAttachDir", "tempUploaddir", "tempDownloaddir", "tempTempDb", " tempStreamFolder", "tempBuildJar", "tempUploadJar", "tempRootDirectory", "tempuploadPath", " tempDownloadDir", "temuploadInfo", "tempCapturedir", " tempUploadDb", "tempUploadManager", "tempWorkDirectory", "tempTempFolder", "tempStreamDirectory", "tempImageDirectory", "testUploadD", "testBuildJar", "tempDownloadFolder", "tempDownloadDirectory", "temUploadFolder", "tempRootDir", " tempUploadFolder", " tempUploadJar", " tempDownloadDb", "tempInputFolder", "tempuploadDir", "testAttachdir", "tempCaptureDir", "tempStreamDir", "tempFileDirectory", "tempStreamJar", "tempUploadArea", " tempDownloadManager", "TempDownloadDb", "tempUploadDirectory", "temuploadFolder", "TempDownloadDir", "TempDownloadFolder", "tempTempDirectory", "tempuploadInfo", "tempBuildD", "tempStreamDb", "temuploadDir", "testUploaddir", "tempDownJar", "tempDownloadDir", "tempUploadUrl", "tempAttachdir", "tempTempManager", "tempCaptureD", "tempRootDb", "tempStreamArea", "tempDownloadUrl", " tempDownloadFile", "tempUploadPath", "tempBuilddir", "testUploadUrl", "tempWorkFile", "tempInputPath", "testUploadDir", "tempDownloadD", "tempDownloadArea", "temUploadDir", " tempUploaddir", "testAttachFolder", " tempDownloaddir", "tempImageManager", "tempDownloadPath", "testBuildDir", "tempUploadDb", "tempUploadFolder", "tempImageArea", " tempDownloadDirectory", "tempFileFile", "tempDownloadInfo", "tempWorkDir", " tempStreamDirectory", "tempDownloadJar", "tempTempDir", "testAttachUrl", "tempInputDir", "temUploadInfo", " tempUploadFile", "tempFileDir", "tempInputInfo", "tempDownloadFile", "tempImageFolder", "testUploadFolder", " tempStreamDir", " tempDownloadArea", "tempWorkFolder", "tempRootFolder", "tempAttachDir", "tempAttachFolder"], "attachmentDir": ["attributionFile", "attporaryFile", "attmentFile", "attachedDir", "attporaryDet", "AttachmentFile", "attributionDb", "AttmentDir", "attmentMin", "assachmentDirectory", "attachmentFile", "attachmentDet", "attachedDet", "AttmentFolder", "assachmentDet", "attachedFile", "assachmentDir", "attachmentDirectory", "assachedFile", "attentionObj", "attributionDir", "attentionDir", "AttachedDir", "AttachmentDirectory", "attentionFolder", "attporaryDb", "attmentObj", "AttachedFile", "AttachmentObj", "AttachedDirectory", "attachFile", "attributionDet", "assachedDirectory", "attachmentObj", "attmentDir", "attachmentFolder", "AttachmentMin", "attentionMin", "AttachmentFolder", "attmentFolder", "attachmentDb", "attachDb", "attachedDirectory", "AttachedObj", "attachedDb", "attentionDb", "attachDirectory", "attmentDirectory", "attentionFile", "assachmentDb", "attachedObj", "assachedDet", "AttmentMin", "assachedDb", "attachDir", "AttmentDirectory", "AttachmentDir", "assachedDir", "assachmentFile", "attporaryDir", "attachmentMin", "attentionDirectory"], "paramMap": ["ParameterMap", "argBlock", "ParameterCache", " paramCache", " paramArray", " parameterCache", "ParameterZone", "argClear", "ParameterList", " parameterList", "argList", "paramClear", "ParamArray", "parammap", "argMap", "ParamClear", "Parammap", " paramZone", " parameterZone", "mediaArray", "ParamList", " parammap", "paramList", "paramBlock", " parameterMap", "mediaList", "argArray", "ParamBlock", "paramArray", "ParamMap", " paramClear", " paramBlock", "mediamap", "paramCache", "paramZone", "mediaMap", " paramList"]}}
{"id1": "8430178", "id2": "19868933", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyPath", "Copyfile", "copyFiles", " copyfile", "transferFile", "transferfile", " copyFiles", " copyPath", "copyPath", "CopyFiles", "CopyFile", "transferFiles", "transferPath", "copyfile"], "source_name": [" source_key", "src_name", "src_uri", "source_key", "src_file", "src_size", "sourceCtype", "source_Name", "source_uri", " source_path", "sourceCfile", "sourceNalias", "sourceCname", "src_type", "source_size", "Source_file", " source_Name", "sourceNfile", "source_path", "Source_name", "Source_data", "sourceNname", "source_alias", "source_type", "sourceNtype", "source_data", "sourceCalias", "source_names", " source_names", "src_alias"], "dest_name": [" dest_label", " destination_info", "destPnames", " dest_named", "Dest_path", " destination_path", "destPName", "dest_model", " dest_Name", " dest_names", "dest_info", "destFilelabel", "dest_resource", "destflabel", "dest_word", "destappnames", " destinationFresource", " destinationFpath", " dest_word", "destfname", "destFname", "destJnames", "target_model", "destFpath", "source_Name", "destRName", " destination_name", " destinationFinfo", "destfnamed", "destffile", " destinationFname", "dest_Name", " dest_definition", "destFilename", "dest_file", "dest_named", "dest_type", "dest_path", "target_names", "dest_none", "dest_id", "destPmodel", "target_type", "Dest_Name", " dest_file", "destPtype", "source_path", "Dest_id", "destPpath", "destFilefile", "destapptype", "destFilenamed", "dest_label", "destRdefinition", "destJName", "Dest_name", "dest_names", "destappmodel", " dest_path", " destination_resource", "destJword", "destFresource", "destPname", "destJname", " dest_type", "destRname", "destPword", "destappname", "destRpath", "source_names", "target_name", " dest_none", "destFinfo", "dest_definition"], "source_file": [" source_url", "src_name", "source_base", "ource_files", "source_files", "source__file", " source_base", "source_stream", "sourcefurl", "ource_line", "src_file", "source_line", "source__base", "sourceffile", "source__name", "sourcefFile", "ource_file", "ource_name", " source_File", "source_url", "source_cache", " source_cache", "source__class", " source_class", "source_class", "src_files", "source_File", "sourcefname", "src_stream", " source_files"], "destination_file": ["destation_file", "destinationablefile", "destention_name", "destinate_base", "destination_base", "destination4source", "destination2name", "destention_file", "destination2path", "destination2file", "destinate_file", "destation_name", "destention4path", "destation_function", "destination_function", "destination_folder", "destination2source", "destinationablebase", "destinate_page", "destinationablefiles", "destention_source", "destention4name", "destination_name", "destination4file", "destinationablepage", "destination_source", "destination_files", "destation_folder", "destination4name", "destination4path", "destention_path", "destination_page", "destinate_files", "destention4file", "destention4source", "destination_path", "destation_files"], "source": ["reader", "connection", "open", "ources", "current", "name", "get", "master", "remote", "reference", "slice", "from", "stream", "secure", "load", "local", "class", "ource", "copy", "cache", "inner", "output", "ite", "single", "SOURCE", "client", "dest", "service", "proxy", "storage", "image", "spec", "parent", "object", "config", "view", "uri", "unit", "core", "server", "file", "scope", "index", "search", "src", "resource", "target", "result", "Source", "input", "ize", "diff", "via", "resources", "slave", "start", "site"], "destination": ["coordinator", "foreigninate", "destining", "descinator", "destension", "constinator", "identinated", "descination", "destinated", "variinator", "targetinated", "coordination", "destina", "targetinator", "identribution", "Destining", "Destension", "testinator", "foreigninator", " destina", "coordinated", " destinated", "testinated", "variination", "dependinated", "foreigninated", "Destination", "identination", "descension", "Destinator", "identina", "variinated", "foreignination", "dependination", "Destinated", " destining", "coordension", "validinated", "validinate", "testribution", "dependinator", "testination", "constribution", "variinate", "validination", "destinator", "destribution", "destinate", " destribution", "descinated", "targetination", "targetinate", "Destina", "Destribution", "constination", " destinator", "constining", "validinator", "dependinate"], "buffer": ["reader", "bin", "uffer", "iter", "sequence", "channel", "pool", "batch", "buff", "Buffer", "timeout", "binary", "cache", "text", "writer", "flush", "temp", "padding", "block", "image", "limit", "transfer", "memory", "header", "queue", "window", "input", "buf"], "bytes_read": ["Bytes_read", "bytesUnRead", "bytesUnfound", "bytes_set", "Bytes_Read", "Bytes_set", "Bytes_found", "bytesUnread", "bytes_Read", "bytesUnset", "bytes_found"], "in": ["reader", "bin", "connection", "lock", "login", "f", "data", "get", "current", "doc", "container", "session", "s", "ins", "stream", "p", "min", "In", "fe", "rec", "is", "log", "ssl", "b", "inner", "again", "r", "l", "val", "IN", "din", "line", "temp", "ini", "image", "inc", "or", "request", "path", "h", "nin", "url", "n", "read", "inn", "file", "as", "id", "a", "resource", "input", "out", "con", "token", "re", "serv"], "response": ["su", "answer", "data", "sequence", "true", "version", "question", "error", "reason", "respond", "body", "application", "received", "Response", "status", "model", "description", "text", "output", "success", "r", "line", "reply", "respons", "reset", "image", "feed", "api", "example", "request", "value", "object", "next", "update", "offer", "view", "uri", "server", "message", "result", "res", "resource", "header", "location", "onse", "report", "re", "json", "string", "dict", "resp"], "parentdir": [" parentdiff", "homeDir", "homedir", "hostdir", "parentfile", "hostdirectory", "partfile", "Parentdir", "rootdirectory", " parentdict", "parentdiff", " parentfile", "parentDir", "homediff", "hostdict", "parentsdiff", "rootlib", "partdirectory", " parentDir", "parentsfile", "parentsdir", "rootdir", "Parentdirectory", "parentlib", "parentsDir", "Parentdict", "partlib", "parentdirectory", "parentdict", "partdir", " parentlib", "homefile", " parentdirectory", "rootfile"]}}
{"id1": "6966398", "id2": "5414088", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"reader": ["connection", "df", "iter", "er", "manager", "ri", "handler", "book", "raf", "stream", "p", "se", "cms", "k", "load", "rc", "per", "reads", "cer", "keeper", "loader", "instance", "her", "r", "writer", "parser", "o", "pp", "dr", "rr", "row", "buffer", "client", "ner", "oder", "source", "feed", "or", "builder", "driver", "rw", "context", "config", "reading", "read", "server", "io", "pe", "file", "rake", "rar", "ry", "resource", "input", "ler", "Reader"], "ks": ["rows", "inks", "ds", "icks", "bs", "sk", "acks", "se", "ips", "ck", "k", "ics", "ns", "gets", "works", "cs", "reads", "kb", "ans", "kies", "ls", "ko", "ops", "rs", "ke", "hs", "ctx", "qs", "KS", "ki", "DS", "books", "ku", "orks", "vs", "kes", "powers", "akes", "ps", "checks", "keys", "co", "acs", "cks", "opens", "ss", "es", "ges", "CS", "ches", "ms", "fs", "acts"], "key": ["lock", "court", "point", "char", "type", "seed", "ca", "p", "pair", "state", "k", "base", "ssl", "cache", "user", "client", "secret", "ke", "service", "value", "ki", "sign", "code", "transfer", "server", "read", "pe", "io", "keys", "c", "file", "ring", "ce", "trust", "co", "pg", "Key", "ee"], "chain": ["lock", "sequence", "family", "scale", "container", "table", "range", "slice", "stack", "pair", "wheel", "enc", "set", "base", "rule", "wrap", "cache", "box", "circle", "cr", "root", "collection", "Chain", "crypt", "secret", "list", "chains", "block", "image", "path", "object", "config", "store", "code", "c", "file", "coll", "mc", "network", "none"], "os": ["cos", "ds", "oss", "ot", "options", "s", "bos", "p", "outs", "ol", "oid", "is", " o", "op", "ops", "rs", "oses", "o", " bos", "OS", "Os", "object", "io", "ps", "osi", "iso", "pos", "aos", "rss", "ros", "res", "ou", "los", "ios", "es", "opens", "ms", "fs", "ob"], "stamper": ["spamler", "data", "stAMmer", "_", "streamler", "stammpper", " nostamler", " nostameler", "streammer", "stAMper", "s", "g", "spAMmer", "stammer", "stampper", " nostamper", "spampe", "starmper", " nostampper", " nostamepper", "stammler", "starmler", "streamper", "stammpe", "stammmer", "streampe", "stAMpe", "spAMpe", "spamper", "this", "starmple", "stameler", "stammper", "stampe", "path", "stamler", "stameper", " nostameper", "function", "spAMper", "starmpper", "stample", "stamepper", "stammple", "spAMler", "stAMler", " nostample", "stameple", " nostameple", "spammer"], "appearance": ["Appearing", "installearance", "suppfacing", "applier", "askfacing", " applier", "appeared", "askeared", "ppasion", " appear", "installearing", "signlier", "formearance", " appence", " appeared", "suppasion", "formismo", "signointment", "ppaser", "ppearance", "formearing", "atteared", " appismo", "formaser", "appears", "appointment", "appismo", "appfacing", "askence", "appearing", "feedointment", "ppearing", " appaser", "byearing", "suppearing", "signearing", "installear", "appasion", "ppear", "Appears", "appaser", "appear", "signearance", "byismo", "feedear", " appfacing", "feedearance", "signfacing", "suppear", "feedfacing", "byearance", "Appearance", "appence", "attearance", "installasion", "formear", "Applier", "signears", "suppearance", "attence", "suppointment", "attfacing", " appears", "signear", "byear", "askearance", " appearing"]}}
{"id1": "18370075", "id2": "6159896", "code1": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "code2": "    public static String md5(String str) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - start\");\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] b = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < b.length; i++) {\n                int v = (int) b[i];\n                v = v < 0 ? 0x100 + v : v;\n                String cc = Integer.toHexString(v);\n                if (cc.length() == 1) sb.append('0');\n                sb.append(cc);\n            }\n            String returnString = sb.toString();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"md5(String) - end\");\n            }\n            return returnString;\n        } catch (Exception e) {\n            logger.warn(\"md5(String) - exception ignored\", e);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - end\");\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"createPasswordDigest": ["createPasswordDigenge", "createpasswordDigester", "createPasswordModifier", "createpassworddigest", "createpasswordDigenge", "createpasswordDigifier", "createPasswordSignifier", "createpassworddigenge", "createPasswordSignester", "createPassworddigest", "createPasswordSignest", "createPassworddigester", "createpassworddigifier", "createPasswordModenge", "createPassworddigenge", "createPasswordDigifier", "createPasswordSignenge", "createPassworddigifier", "createPasswordModest", "createPasswordModester", "createpassworddigester", "createPasswordDigester", "createpasswordDigest"], "password": ["wallet", "login", "data", "name", "email", "wd", "database", "command", "seed", "p", "Pass", "words", "user", "text", "Password", "account", "key", "address", "secret", "crypt", "padding", "source", "sword", "phrase", "path", "filename", "hash", "PASS", "pattern", "config", "pass", "word", "message", "token", "pad", "security", "auth", "string", "username"], "salt": [" ssecret", "Salt", "ssalt", "pALT", "sesalt", "palt", "ssALT", "sesass", "sessecret", "sesALT", "sssecret", "Sass", " sALT", " sass", "pass", "Ssecret", "ssass", "SALT", "ssecret", "sass", "sALT", "psecret"], "md": ["meta", "bd", "mag", "cd", "mad", "dd", "m", "ma", " MD", "mt", "clean", "ind", "me", "ld", "kg", "di", "mb", "mail", "ph", "mac", "cmd", "zip", "dm", "mn", "d", "MD", "gd", "mo", "mod", "amd", "code", "metadata", "mm", "pm", "message", "sha", "po", "bf", "mc", "nd", "ms", "pd", "mand", "ad", "od", "nm"], "digest": ["generress", "digress", "generest", " digests", "DigEST", "generests", "Digester", "generester", "hashester", "digested", "dester", "signcode", " digress", "digester", "decests", "digEST", " digcode", "dest", "digcode", "decest", "signester", " digEST", "decress", "Digested", "hashcode", "signested", "signest", "digests", "hashest", " digested", "dEST", "decester", " digester", "Digest", "dested", "hashested"]}}
{"id1": "15051083", "id2": "7948308", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"getMessageDigest": ["getMessagedigests", "getMessageDigester", "getmessageDigest", "getMessageHashests", "getMessagedigest", "getMessageDesignester", "getmessageDigests", "getMessageDesignest", "getMessageHashest", "getmessageDigature", "getMessageDigature", "getMessagedigester", "getmessageDigester", "getmessagedigests", "getMessageDesignature", "getMessageHashester", "getmessagedigature", "getmessagedigest", "getMessageHashature", "getMessagedigature", "getMessageDigests", "getMessageDesignests", "getmessagedigester"], "digest": ["sandester", "greatester", "signesting", "digeter", " Dighed", " diger", " digests", " digeter", "DigEST", " digex", "Digester", " Digest", "Digeter", " dighed", "sandest", "digesting", "digested", "sandested", "Digesting", "signiter", "digester", "hexex", "digEST", "Digiter", "hexEST", " Digger", "greatiter", "greatest", "dighed", " digger", "digiter", "digger", "feedested", "signester", " digEST", "Digested", " Digeter", "hexest", "signested", "diger", "Digger", "sandesting", "greatested", " Diger", " Digester", "Diger", "feedest", "signest", "Dighed", "digests", "Digex", "hexests", "digex", " digested", " digester", "Digest", "Digests", "feedester"], "node": ["connection", "name", "point", "self", "remote", " child", " source", "one", "event", "local", "Node", "component", "entity", "instance", "root", "address", "source", "child", "path", "ode", " parent", "object", " namespace", "parent", "config", "document", "odes", "n", " Node", "route", "server", "uri", "global", "index", "module", "resource", " annotation", "location", "network", "internal", " nodes", "element"], "external": ["https", "multiple", "secondary", "outside", "name", "tern", "remote", "reference", "ex", "local", "Intern", "binary", "instance", "export", "e", "account", "client", " remote", "ternal", "source", " global", "External", "outer", "object", "environment", "n", "intern", "global", " External", "resource", "target", "out", "international", "foreign", " foreign", "network", "internal", "element"], "messageDigest": [" messageDesignest", " messageDigesting", "messagedigger", "messagedigester", "messageHashested", "messageSignested", "messageHashest", " messageHashesting", "messageDigested", "MessageSignested", "messageHashester", "messageDigenge", "messageDesignested", " messageDigger", "messagedigested", "messageMarkested", "messageDigester", " messageDesignested", "MessageSignest", "messageMarkenge", "messageDesignester", "messageSignester", " messageHashested", "messageDigger", "MessageSignester", "messageSignest", "MessageDigest", " messageHashest", " messageDesignger", "messageDesignest", " messageHashester", "messagedigest", "MessageDigested", "messageMarkest", "messageMarkester", "messageDenge", "messageModester", "messageDigesting", "messageDested", "messageModested", "messageDesignger", "messageModesting", "messageHashesting", " messageDigester", "messageModest", " messageDigested", "MessageDigenge", "MessageDigester", "MessageSignenge", "messageDester", "messageSignenge", " messageDesignester", "messageDest", "messageDesignesting"]}}
{"id1": "62362", "id2": "7499186", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["conception", " deconvert", "Convert", "converting", "subvert", "unversion", " deconverting", "CONverting", "unvert", "CONvert", "unception", "Conversion", " deconverted", "unverted", "subverted", "Converted", "conversion", " deconversion", "CONverted", "subversion", "oconvert", "CONversion", "converted", "Conception", "Converting", "CONception", "subverting", "oconversion", "oconverted", "oconverting"], "src": ["reader", "username", "cb", "sin", "loc", "RC", "name", "sn", "gb", "s", "sc", "slice", "cpp", "stream", "st", "secure", "inst", "download", "sth", "load", "gz", "proc", "sys", "rc", "SourceFile", "ssl", "component", "ource", "prot", "req", "feat", "video", "img", "href", "fn", "dist", "back", "rb", "cmp", "source", "storage", "ctx", "path", "spec", "filename", "attr", "stage", "url", "config", "code", "uri", "sit", "file", "impl", "Dest", "upload", "sel", "scene", "sb", "input", "resource", "Source", "fp", "ref", "rl", "string", "obj", "buf", "tmp", "supp"], "dest": ["bin", " destination", "cont", " dst", "class", "orig", "di", "txt", "img", "fn", "dist", "temp", "std", "dc", "test", "lib", "source", "disk", "path", "null", "Dest", "target", "dir", "dat", "home", "obj", "tmp"], "in": ["reader", "bin", "inf", "isin", "login", "f", "data", "doc", "inas", "ins", "pin", "stream", "ex", "In", "is", "win", "r", "din", "val", "IN", "err", "ini", "d", "i", "source", "inc", "t", "n", "pass", "ps", "inn", "io", "as", "up", "file", "a", "input"], "p": ["f", "lp", "tp", "s", "g", "py", "m", "j", "pi", "wp", "pc", "per", "pr", "jp", "b", "part", "op", "l", "bp", "pre", "cop", "e", "r", "parser", "o", "pp", "d", "i", "sp", "t", "h", "v", "ps", "pe", "c", "P", "pm", "np", "pa", "po", "fp", "pd", "cp", "pg", "pb"], "ds": ["data", "dl", "dd", "services", "groups", "ys", "cs", "ls", "ld", "tools", "d", " props", "js", "ded", "xs", "uds", "ps", "ils", "ges", "tests", "pd", "ads", " sd", "df", "lp", "ups", "ins", "bs", "Ds", "os", "sys", "sts", "obs", "rs", "dds", "dm", "nas", "gd", "hs", "points", "ipes", "qs", "DS", "styles", "des", "ss", "ks", "dos", "cons", "ts", "vals", "eps", "els", "icks", "da", "ns", "parts", " ps", "dist", " DS", "posts", "dc", "scripts", "ths", "dates", "vs", "gs", "ays", "dat", "docs", "dt", "s", "sync", "utils", "ans", "di", "words", "models", "lines", "db", "dp", "ants", "amps", "plugins"], "format": ["tag", "data", "f", "layout", "sche", "scale", "name", "version", "at", "ant", "handler", "type", "table", "language", "filter", "letter", "feat", "class", "plugin", "model", "part", "magic", "fn", "parser", "atter", "style", "source", "template", "t", "api", "spec", "struct", "filename", "pattern", "path", "form", "url", "config", "unit", "Format", "file", "function", "act", "prefix", "fd", "frame", "record", "host", "fp", "string", "nat"], "hasPixelData": ["hasPicturedata", "hasPictureSize", "hasByteData", " hasPixeldata", "hasPixeldata", "showsPixelDATA", "hasPixelSize", "hasPixelStyle", "showsByteStyle", " hasPixelSize", "showsBytedata", "hasByteStyle", "showsPixeldata", "showsByteData", "hasPictureData", "hasByteSize", "showsByteDATA", "hasByteDATA", "showsPixelData", "haspixeldata", "hasBytedata", "hasPixelDATA", "haspixelSize", "haspixelData", "showsPixelStyle"], "inflate": ["insflATE", "invenATE", "inflode", "inffated", "inFlated", "InFlace", "Inflace", "invenate", "insflate", "inflated", "inadequating", "inFlace", "insflating", "infolating", "infolATE", "inadequATE", "invenode", "inadequode", "insflode", "inffation", "infloated", "insvenATE", "invenating", "inffate", "inFlate", "inadequate", "inflating", "InFlated", "infolode", "infface", "Inflated", "Inflate", "InFlation", "inflation", "Inflation", "infloace", "insvenating", "insvenode", "infolate", "InFlate", "inflATE", "inflace", "infloate", "insvenate", "infloation", "inFlation"], "pxlen": ["mxlen", "fxdata", "mxpos", "campos", "pclon", "axln", "ppl", "txlen", "fxLen", "pxdata", "pxsize", "pngcount", "xpsize", "pxpos", "txln", "xpcount", "ppLen", "txlin", "mxdata", "camdata", "camln", "mxln", "axlen", "pcln", "pnglength", "pglen", "pxden", "fxden", "txlon", "pgLen", "pxl", "pxlength", "pxlon", "axlon", "pclin", "camlen", "pgden", "pxln", "mxcount", "pngsize", "fxln", "pgl", "mxlength", "mxsize", "axlin", "pclen", "fxl", "pxcount", "fxpos", "pxLen", "fxlen", "xplen", "pnglen", "ppden", "pxlin", "xplength", "pplen"], "out": ["lock", "point", "error", "session", "state", "outs", "gen", "dump", "sys", "log", "copy", "page", "cache", "user", "again", "output", "conn", "line", "work", "query", "err", "OUT", "list", "lib", "cli", "step", "parent", "v", "store", "server", "group", "post", "io", "up", "co", "inter", "pad", "re", "Out", "obj"]}}
{"id1": "20717531", "id2": "8064604", "code1": "    public static String encrypt(String plainText) {\n        if (TextUtils.isEmpty(plainText)) {\n            plainText = \"\";\n        }\n        StringBuilder text = new StringBuilder();\n        for (int i = plainText.length() - 1; i >= 0; i--) {\n            text.append(plainText.charAt(i));\n        }\n        plainText = text.toString();\n        MessageDigest mDigest;\n        try {\n            mDigest = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            return plainText;\n        }\n        mDigest.update(plainText.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"encrypt": [" enccrypt", " decress", " encipher", "Enccrypt", "Encrypt", " deccrypt", " encress", "encipher", "encress", "enccrypt", " decrypt", "Encipher", " decipher", "Encress"], "plainText": ["fullTime", "protectedText", "simpleTime", "externalString", "originaltext", "binaryString", "publicTEXT", "plainTEXT", " plainContent", "fullData", "flatData", "singleString", "batContent", " plainData", "flattext", "publicText", "singleText", "externalKey", "simpletext", "protectedTEXT", "plainTarget", "externalText", " plainTEXT", "fullText", "originalTEXT", "externaltext", "fullTEXT", " plainString", "fulltext", "protectedTextColor", "flatTEXT", " plainTarget", "flatTime", "batText", "simpleText", "binaryText", "plainPart", "plainTextColor", "plainContent", "protectedString", "protectedtext", "originalText", "batTEXT", "originalTextColor", " plainKey", "plaintext", "plainData", " plainPart", "flatContent", " plainTextColor", "flatTarget", "protectedKey", "battext", "publictext", "singlePart", "plainString", "simpleTEXT", "publicTarget", "protectedContent", "binaryPart", "plainTime", "flatText", "binarytext", "plainKey", "singletext", " plaintext"], "text": ["ext", "data", "event", "str", "letter", "b", "output", "math", "txt", "contract", "writer", "password", "key", "off", "address", "test", "buffer", "service", "source", "image", "value", "feed", "Text", "builder", "path", "object", "editor", "struct", "port", "pattern", "context", "url", "width", "code", "form", "config", "post", "null", "id", "word", "message", "result", "input", "append", "out", "TEXT", "print", "length", "string", "tx", "use", "font"], "i": ["x", "ji", "f", "y", "si", "it", "ti", "ri", "s", "slice", "m", "j", "p", "info", "pi", "k", "field", "ind", "ie", "ix", "hi", "I", "bi", "di", "u", "multi", "b", "qi", "l", "fi", "e", "o", "key", "ini", "temp", "abi", "ci", "z", "t", "h", "xi", "oi", "mi", "ui", "v", "li", "uri", "n", "ii", "io", "c", "in", "ni", "id", "index", "iu", "chi", "mu", "vi", "eni", "ai", "gi", "phi", "ip"], "mDigest": ["mdigester", "mDigger", "mdigest", "MDigester", "mDigEST", "mdigex", " mDigusher", "mdiger", "cmDigested", "mDger", "MDex", "mCompest", "mDiger", " mDigester", " mDester", "MDest", "mHashEST", "mHashester", "mdigger", "mHashger", "mDigse", "mdigests", "mCompester", "mCompests", "mEdester", "mdigse", "MDests", "mDester", " mHashger", "MDigex", "cmDiger", "mDEST", "mHashusher", "mDigusher", "mDer", "mDigex", "mdigEST", "mHashest", " mHashester", "cmdigester", "mCompex", "cmdigest", "mEder", "cmdigested", "mDested", "mDest", "mDse", " mDest", "mDigester", " mDigEST", "mEdested", " mDigse", "mdigusher", "MDigest", " mDse", "mDigests", "cmDigester", "MDigests", "mDex", "cmdiger", "mEdest", "cmDigest", " mDEST", " mDigger", "mdigested", "mHashse", " mHashest", "mDigested", " mHashusher", "mDests", "mDusher", "MDester"], "d": ["x", "did", "f", "data", " data", "cd", "sd", "ds", "s", "dl", "D", "dd", "m", " D", "p", "dn", "da", "str", "dig", "ld", "di", "u", "b", "bytes", "l", "e", "dim", "md", "dr", "dc", "db", "z", "t", "ded", "h", "v", "n", "c", "id", "dh", "a", "fd", "dat", "string", "dt", "dos"], "hash": ["bin", "f", "ha", "hed", "version", "string", "array", "str", "hex", "log", "base", "carry", "b", "output", "user", "size", "kh", "her", "mac", "dot", "key", "secret", "buffer", "bar", "build", "image", "block", "square", "db", "h", "v", "url", "sum", "history", "number", "code", "ashes", "memory", "ssh", "shadow", "message", "sha", "result", "header", "ash", "cover", "print", "Hash", "html", "sh"]}}
{"id1": "2736184", "id2": "23510383", "code1": "    public static String getURLContent(String urlPath, String requestData, String charset) {\n        BufferedReader reader = null;\n        HttpURLConnection conn = null;\n        StringBuffer buffer = new StringBuffer();\n        OutputStreamWriter out = null;\n        try {\n            URL url = new URL(urlPath);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            conn.setDefaultUseCaches(false);\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(60000);\n            out = new OutputStreamWriter(conn.getOutputStream(), charset);\n            out.write(requestData);\n            out.flush();\n            int repCode = conn.getResponseCode();\n            if (repCode == 200) {\n                int count = 0;\n                char[] chBuffer = new char[1024];\n                BufferedReader input = new BufferedReader(new InputStreamReader(conn.getInputStream(), charset));\n                while ((count = input.read(chBuffer)) != -1) {\n                    buffer.append(chBuffer, 0, count);\n                }\n            }\n        } catch (Exception ex) {\n            logger.error(\"\", ex);\n        } finally {\n            try {\n                if (out != null) {\n                    out.close();\n                }\n                if (reader != null) {\n                    reader.close();\n                }\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            } catch (Exception ex) {\n            }\n        }\n        return buffer.toString();\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 0, "substitutes": {"getURLContent": ["getUrlBody", "getStreamResource", "postUrlBody", "postURLBody", "postURLContent", "getURLResource", "getRequestContents", "getUrlContent", "getUrlResource", "postUrlContents", "postUrlContent", "getURLBody", "getRequestResource", "getStreamBody", "postURLContents", "getStreamContents", "getStreamContent", "postURLResource", "postUrlResource", "getRequestBody", "getUrlContents", "getURLContents", "getRequestContent"], "urlPath": ["URLPath", "urlUrl", "fileCase", "fileContent", "fileName", "bufferpath", "resourcePath", "URLName", "urlName", "UrlContent", "UrlCase", "bufferPath", "UrlPath", "urlpath", "bufferContent", "urlContent", "URLUrl", "resourcepath", "URLpath", "fileUrl", "filePath", "urlCase", "bufferCase", "resourceName", "resourceUrl", "filepath", "Urlpath"], "requestData": ["Requestdata", "responseData", " requestInfo", "RequestData", "RequestInfo", "taskData", " requestText", "RequestBody", "responseBody", "responseInfo", " requestdata", "responseText", "taskdata", " requestBody", "RequestText", "requestInfo", "requestBody", "taskBody", "requestText", "requestdata", "taskText"], "charset": ["charsET", "chaseset", "chasET", "chARSetting", "claseset", "CharsET", "clARSet", "chasespace", "ChasET", "chARSource", "Chaspace", "chARSET", "Charspace", "charsetting", "clARSets", "chARSets", "chasesets", "clasesetting", "clasespace", "chactersource", "clarsetting", "clARSpace", "chaset", "chactersET", "clARSET", "Chaset", "chasetting", "chaspace", "clarsET", "charsource", "Charset", "clarspace", "charsets", "chacterset", "Chasource", "chasource", "clasesET", "charspace", "chARSet", "clarset", "Charsource", "chacterspace", "chasesetting", "clarsets", "chasesET", "chARSpace"], "reader": ["connection", "iter", "er", "socket", "channel", "error", "q", "handler", "worker", "sync", "timeout", "rc", "req", "cache", "loader", "inner", "r", "writer", "err", "parser", "client", "rr", "row", "i", "ner", "oder", "source", "ch", "request", "driver", "config", "read", "server", "bird", "core", "raw", "io", "http", "in", "resource", "result", "Reader"], "conn": ["lock", "channel", "nc", "enc", "ssl", "cmd", "err", "o", "cli", "cat", "ctx", "path", "exec", "close", "conv", "io", "c", "co", "on", "coll", "pg", "open", "org", "socket", "error", "session", "pub", "en", "pc", "ann", "cache", "conf", "query", "client", "connected", "init", "code", "ai", "Connection", "act", "cn", "reg", "ct", "ec", "part", "dc", "ci", "connect", "config", "n", "http", "con", "mc", "auth", "cp", "col", "connection", "nt", "cb", "ca", "sync", "Connect", "rc", "can", "comm", "ch", "uc", "cf", "server", "core", "Conn", "in", "cm", "ac"], "buffer": ["uffer", "iter", "cb", "data", "batch", "array", "buff", "Buffer", "timeout", "str", "counter", "fb", "binary", "base", "bb", "cache", "b", "loader", "output", "throw", "writer", "line", "flow", "sb", "row", "source", "feed", "builder", "request", "response", "transfer", "server", "wave", "message", "queue", "resource", "result", "append", "print", "report", "length", "fp", "string", "use", "buf"], "out": ["connection", "bin", "app", "login", "data", "name", "socket", "channel", "error", "pool", "container", "sync", "outs", "download", "timeout", "plain", "log", "base", "ssl", "copy", "w", "cache", "output", "again", "conf", "part", "user", "cmd", "inner", "writer", "loader", "err", "o", "client", "OUT", "call", "source", "init", "inc", "ch", "child", "exec", "object", "outer", "parent", "no", "config", "group", "server", "null", "io", "net", "in", "file", "co", "result", "resource", "con", "network", "Out", "string", "write", "obj"], "url": ["connection", "open", "sl", "f", "org", "channel", "socket", "ur", "web", "base", "ssl", "ll", "ls", "log", "lc", "b", "cache", "l", "client", "Url", "URL", "api", "uc", "path", "n", "server", "uri", "http", "c", "file", "resource", "www", "con", "host", "bc", "il"], "repCode": [" repCount", "repCount", "repType", " repResponse", "replCode", "repState", "replData", "RepState", "respZone", "replCount", "respState", "repData", " repData", "respCount", "RepCode", "replType", "respData", "repResponse", "respResponse", "respCode", "repZone", " repType", "RepResponse", " repState", "RepZone", "respType", " repZone"], "count": ["offset", "keep", "current", "start", "get", "char", "force", "depth", "name", "allow", "counter", "ind", "base", "add", "more", "cache", "part", "time", "size", "weight", "max", "key", "found", "Count", "i", "cond", "limit", "child", "list", "process", "sum", "read", "code", "number", "core", "c", "id", "index", "len", "length", "col", "use", "end", "act"], "chBuffer": ["ctbuffer", "ichBuffer", "ChBuffer", "phbuffer", "phBuffer", "quBuff", "cBuff", "charBuff", "ctBuffer", "charbuffer", "ichBar", "ichBuff", "charArray", "quBuffer", "Chbuffer", "chImpl", "ChBuff", " chbuffer", "phImpl", "ChImpl", "chbuffer", "quBar", "chBuff", "ctArray", "cArray", "ChCount", "ctBuff", "phBuff", "ichCount", " chBuff", "charBuffer", "chBar", "chCount", "ChBar", "chArray", " chImpl", "quCount", "cBuffer", "cbuffer"], "input": ["active", "connection", "inf", "iter", "er", "data", "socket", "s", "stream", "event", "inch", "loader", "output", "inner", "wrapper", "instance", "l", "r", "client", "temp", "this", "i", "source", "image", "child", "inc", "request", "exec", "driver", "form", "config", "server", "http", "in", "resource", "Input"]}}
{"id1": "2521141", "id2": "494226", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copy": ["ame", "open", "get", "rm", "archive", "create", "type", "change", "sync", "ge", "opy", "download", "move", "load", "dump", "share", "zip", "clip", "cop", "paste", "source", "cat", "image", "Copy", "delete", "update", "config", "transfer", "pe", "file", "attach", "clone", "upload", "diff", "ize", "link", "directory", "cp", " cp", "write", "ignore"], "from_name": [" from_key", "from_key", "from__name", "from_filename", "to_path", "from_memory", "to_filename", " from_names", "source_memory", "from_path", "fromMname", "from_names", " from_Name", "fromFmemory", "fromMfile", "from__path", "from__memory", "source_path", "fromFpath", "source_filename", "from__filename", "fromMnames", "from_Name", "source_name", "fromFname", "fromFfilename"], "to_name": [" to_path", "from_filename", "to_path", "toamhome", "to_filename", "to_Name", "to_home", " to_Name", "from_path", "toamfile", "toamname", "toampath", " to_home"], "from_file": ["from___filename", "from___file", "fromCbrain", "from__file", "source_files", "from___auto", " from__auto", "from__name", "from_folder", "remote_log", "from_filename", "from_log", "fromCfile", "from_brain", "from_source", " from_directory", "from__resource", "fromappfunction", "from__files", "from_auto", "from_lane", " from_folder", "source_resource", "from_function", "fromapplane", "from__auto", "remote_file", "remote_lane", "from_files", " from__file", "fromCfilename", " from__name", "fromappfile", "source_directory", "source_filename", "fromCname", "from__filename", "fromapplog", " from_source", "from_resource", " from__filename", "source_brain", "from_directory", " from_auto", "source_file", "source_name", "from__directory", " from_filename", "from___name", "remote_function", " from_files"], "to_file": ["to__dir", "from_load", "to67name", "to_stream", "toJfile", "source_files", "into_name", "toJname", "intojname", "to_queue", " to_model", "to__load", "source_server", "to_files", "to64name", "tojfunction", "to_dir", "to64use", "to_binary", "to64function", " to_queue", "eto_remote", "eto_file", "to67file", "to_bar", "into_file", "to_filename", "from_dir", "to64file", "to_model", "to__name", "tojname", "from_bar", "intojfile", "to___file", " to_class", "to67load", "eto___name", "toJbar", " to_filename", "from_files", "tojfile", "tojuse", "intojfunction", "to67dir", "from_binary", "from_model", "toJstream", "from_stream", "source_filename", "to_server", "intojuse", "to__file", "to___remote", "to_remote", "eto___remote", "eto_name", "eto___file", "to_load", "to_use", "into_function", "source_file", "to___name", "into_use", " to_files", "to_class", "to_function"], "parent": ["current", "name", "container", "pool", "type", "par", "div", "source", "path", "url", "uri", "null", "owner", "function", "search", "resource", "out", "host", "directory", "Parent", "tree", "point", "session", "handler", "rule", "page", "cache", "am", "term", "content", "ppa", "client", "address", "port", "or", "author", "global", "folder", "id", "target", "home", "loc", "complete", "remote", "p", "per", "parents", "part", "old", "root", "patch", "temp", "test", "inc", "api", "pa", "po", "mother", "location", "ip", "full", "connection", "manager", "any", "fat", "user", "size", "child", "server", "unit", "memory", "file", "ac", "string"], "dir": ["lock", "cur", "iter", "director", "f", "data", "loc", "name", "keep", "manager", "doc", "ver", "container", "wd", "dev", "dec", "dep", "div", "per", "class", " directory", "di", "part", "user", "nav", "die", "cache", "Dir", "r", "root", "dr", "md", "dc", "d", "entry", "cat", "block", "db", "build", "or", "dis", "path", "object", "url", "group", "ir", "io", "in", "file", "folder", "id", "global", "module", "coll", "tr", "out", "def", "home", "directory", "exp", "rel", "dict"], "from": ["connection", "get", "name", "self", "two", "range", "From", "stream", "auto", "low", "se", "one", "fe", "without", "find", "per", "base", "add", "vol", "component", "with", "conn", "part", "cache", "can", "by", "left", "cr", "ra", "cor", "e", "fr", "normal", "client", "address", "bean", "this", "source", "parse", "entry", "feed", "api", "or", "ch", "cf", "form", "url", "context", "view", "server", "empty", "pe", "http", "io", "file", "ce", "flo", "cm", "ou", "link", "con", "who", "so", "start", "when"], "to": ["connection", "office", "su", "ver", "two", "socket", "session", "TO", "type", "auto", "sync", "pi", "one", "tto", "not", "To", "per", "top", "base", "that", "fat", "conn", "with", "output", "op", "thro", "size", "until", "by", "too", "o", "client", "dest", "see", "proxy", "storage", "db", "value", "t", "or", "api", "will", "store", "server", "io", "http", "as", "file", "co", "po", "token", "target", "out", "flo", "via", "on", "about", "so", "write", "fb"], "buffer": ["reader", "border", "uffer", "iter", "data", "texture", "channel", "batch", "slice", "reference", "seed", "layer", "buff", "Buffer", "variable", "binary", "position", "bb", "page", "b", "writer", "shape", "address", "flush", "row", "comment", "source", "block", "padding", "feed", "character", "url", "default", "number", "document", "server", "transfer", "read", "null", "memory", "duration", "wave", "message", "queue", "header", "window", "total", "resource", "length", "buf"], "bytes_read": ["gets___allow", "bytes_allow", "byteslexbefore", "gets___reads", "byte_load", "bytes___reads", "bytes_reads", "gets___pass", "gets_allow", "gets_read", "bytes_pass", "bytesXbefore", "byte_read", "gets_pass", "byte_current", "bytes___pass", "bytes_en", "bytesXload", "bytes_load", "bytes_before", "byteslexread", "bytes___read", " bytes_en", "byteslexcurrent", "bytes_current", "bytesXcurrent", "gets___read", " bytes_found", "byteslexload", "byte_before", "gets_reads", "bytes___allow", "bytesXread", "bytes_write", " bytes_write", "bytes_found"]}}
{"id1": "20414923", "id2": "22401746", "code1": "    protected int deleteBitstreamInfo(int id, Connection conn) {\n        PreparedStatement stmt = null;\n        int numDeleted = 0;\n        try {\n            stmt = conn.prepareStatement(DELETE_BITSTREAM_INFO);\n            stmt.setInt(1, id);\n            numDeleted = stmt.executeUpdate();\n            if (numDeleted > 1) {\n                conn.rollback();\n                throw new IllegalStateException(\"Too many rows deleted! Number of rows deleted: \" + numDeleted + \" only one row should be deleted for bitstream id \" + id);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"Problem deleting bitstream. \" + e.getMessage(), e);\n            throw new RuntimeException(\"Problem deleting bitstream. \" + e.getMessage(), e);\n        } finally {\n            cleanup(stmt);\n        }\n        return numDeleted;\n    }\n", "code2": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "label": 0, "substitutes": {"deleteBitstreamInfo": ["deleteBitstreamINFO", "deletebitStreamINFO", "deleteBitStreaminfo", "deletebitStreamDetails", "deleteBitsystemINFO", "deleteBitstoreINFO", "deletebitStreamInfo", "deleteBitstoreDetails", "deleteBitstreaminfo", "deletebitStreaminfo", "deleteBitstreamDetails", "deletebitstreamDetails", "deletebitstreaminfo", "deletebitstreamINFO", "deleteBitsysteminfo", "deleteBitsystemDetails", "deleteBitStreamInfo", "deleteBitStreamINFO", "deleteBitStreamDetails", "deletebitstreamInfo", "deleteBitstoreInfo", "deleteBitsystemInfo", "deleteBitstoreinfo"], "id": ["ids", "x", "offset", "did", "aid", "seq", "data", "name", "error", "type", "create", "ident", "p", "info", "ip", "one", "status", "oid", "mid", "part", "num", "ide", "root", "vid", "key", "address", "kid", "d", "count", "i", "which", "source", "entry", "db", "path", "parent", "object", "pid", "like", "url", "no", "code", "number", "ID", "in", "index", "Id", "uid", "ref", "rid", "sid", "ad", "start"], "conn": ["connection", "nt", "cn", "nc", "session", "ca", "ct", "sync", "dn", "enc", "ann", "rc", "pr", "jp", "cr", "client", "mn", "dc", "ci", "cc", "ctx", "connect", "db", "ch", "cf", "exec", "col", "config", "server", "rt", "Conn", "c", "co", "stat", "coll", "cm", "con", "mc", "sql", "cp", "Connection", "pg", "serv", "obj", "act"], "stmt": ["sttr", "Stmr", "Stmn", " stmn", " stpr", "Sttr", "stMT", "strdb", "strmr", "Stmt", " start", " stdb", "strm", "stmd", " stm", " stMT", "strmd", " stmr", "shMT", " stmd", "Stdb", "stpr", "stmr", " sttr", "stdb", "shmd", "StMT", "Stpr", "Stlt", " stlt", "strpr", "stlt", " stst", "stmn", "strmt", "strtr", "stst", "stm", "Stst", "shart", "Stm", "Start", "Stmd", "shmt", "start", "strmn", "strMT", "strlt", "strst"], "numDeleted": ["numDeoded", "numdelected", "numDelete", "Numdeleted", "numDelected", "NumDeleted", "numNeleted", "numUndleted", " numDeoded", " numdeashed", " numDeashed", "numDuleted", "numdeleted", "NumDeigrated", "numdeigrated", "numUndDelete", "numExletes", "numDeletes", "numDuDelete", "numDeashed", "numDeloded", "numdeashed", "numExashed", " numdeoded", "numDellected", "numDefleted", "Numdeigrated", " numDeased", "numdeued", "numdelete", "numDeDelete", "numDeased", "numModleted", "numDelased", " numDeletes", " numDelete", "numdeletes", "numDeigrated", "numNeletes", "numExoded", "numDuigrated", "NumdeDelete", "numNelete", "NumDeued", " numdeleted", " numDelected", "NumDeDelete", "numdeoded", "numModletes", "numModashed", "numdeDelete", "numDelleted", " numdelected", "numExleted", " numdeased", " numdeletes", "numDefoded", "numDeflected", "numUndued", "numdeased", "numMododed", "numDefased", "Numdeued", "numDeued"]}}
{"id1": "3401153", "id2": "15580610", "code1": "    private String getHTML(String pageURL, String encoding, String dirPath) throws IOException {\n        StringBuilder pageHTML = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(pageURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"MSIE 7.0\");\n            connection.connect();\n            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), encoding));\n            String line = null;\n            while ((line = br.readLine()) != null) {\n                pageHTML.append(line);\n                pageHTML.append(\"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            connection.disconnect();\n        }\n        if (dirPath != null) {\n            File file = new File(dirPath);\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file));\n            bufferedWriter.write(pageHTML.toString());\n            bufferedWriter.close();\n        }\n        return pageHTML.toString();\n    }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 0, "substitutes": {"getHTML": ["updateJSON", "createURL", "getURL", "updatePage", "updateURL", "loadHTML", "createPage", "loadJSON", "loadURL", "updateHTML", "createJSON", "createHTML", "getPage", "getJSON", "loadPage"], "pageURL": [" pageURI", "badURL", "baseUrl", "baseURI", "pageurl", "basePath", "Pageurl", "baseURL", "PageURI", "pagePath", "badurl", " pageUrl", "PagePath", "pageURI", " pagePath", "badUrl", " pageurl", "pageUrl", "PageUrl", "PageURL", "badURI"], "encoding": ["decoding", "contension", "encoded", "contoding", "encasing", "encension", "coded", "decension", "Encoding", "caging", "decasing", "enaging", "encoder", "enoded", "contoder", "casing", "decoder", "encaging", "coding", "enoding", "Encasing", "contasing", "enasing", "Encoded", "Encension", "Encoder", "Encaging"], "dirPath": ["DirLocation", " dirpath", "directoryPoint", "DirLog", "zipFile", "buildLog", "folderPath", "DirDir", " dirLocation", "dirFile", "buildFile", " dirDir", "Dirpath", "dirLog", "DirFile", "directorypath", "directoryDir", "directoryFile", "zippath", "dirPoint", "dirpath", "zipPoint", "directoryLocation", "zipPath", "buildPath", "directoryPath", "folderFile", "folderpath", "DirPath", "folderPoint", "dirLocation", "directoryLog", "dirDir"], "pageHTML": ["siteUrl", "codeHTML", " pageURI", "pageBody", "pageWriter", "Pagehtml", "rowJSON", "resultURL", "sectionBody", "rowURL", "PageHTTP", "PageBody", "codehtml", "sectionHTTP", "pageJSON", " pageJSON", "rowHTML", "pagehtml", "PageURI", " pagehtml", "resultUrl", " pageWriter", "siteURL", "resultHTML", "PageHTML", "resultWriter", "resulthtml", "codeWriter", " pageUrl", "pageURI", "sectionURL", "codeUrl", "siteHTML", "PageJSON", " pageBody", "pageHTTP", "pageUrl", "resultJSON", "sectionHTML", " pageHTTP", "PageUrl", "rowhtml", "PageURL", "siteURI"], "connection": ["reader", "open", "union", "director", "cb", "loc", "manager", "org", "socket", "channel", "pool", "handler", "database", "session", "body", "application", "bec", "communication", "timeout", "log", "position", "conn", "b", "text", "cache", "user", "wrapper", "section", "collection", "password", "o", "client", "proxy", "connected", "condition", "ci", "db", "connect", "ctx", "or", "builder", "response", "uc", "ion", "character", "context", "config", "number", "relation", "uri", "server", "io", "http", "c", "function", "resource", "con", "directory", "Connection", "string", "bc"], "url": ["sl", "f", "loc", "channel", "stream", "web", "base", "ssl", "log", "page", "conn", "user", "plug", "l", "client", "address", "Url", "URL", "build", "image", "feed", "connect", "builder", "path", "update", "server", "uri", "browser", "http", "function", "contact", "coll", "link", "location", "Connection", "string"], "br": ["reader", "mr", "Br", "cb", "ob", "arr", "ctr", "stream", "body", "ori", "str", "bh", "bl", "pr", "b", "keeper", "bridge", "cr", "r", "err", "fr", "cro", "bc", "dr", "rb", "ner", "BR", "hr", "ch", "lr", "io", "ocr", "sr", "src", "bro", "tr", "result", " reader", "ler", "Reader", "buf"], "line": ["le", "sl", "data", "name", "char", "el", "sync", "ge", "str", "letter", "base", "inline", "lc", "page", "b", "text", "l", "r", "cell", "lines", "lf", "key", "column", "row", "ine", "style", "entry", "block", "comment", "Line", "response", "object", "character", "cl", "li", "code", "pass", "unit", "pe", "c", "up", "LINE", "word", "message", "frame", "lin", "link", "string", "end"], "e": ["x", "be", "er", "f", "ception", "oe", "force", "error", "ze", "type", "p", "se", "one", "ae", "fe", "en", "ec", "ie", "die", "je", "r", "E", "exc", "o", "err", "i", "or", "ev", "ue", "te", "pe", "ise", "c", "ce", "es", "ea", "Exception", "ve", "re", "esi", "ace", "ee"], "file": ["reader", "le", "lock", "f", "data", "name", "File", "socket", "handler", "book", "body", "base", "log", "per", "page", "b", "output", "files", "zip", "l", "writer", "angle", "buffer", "source", "db", "feed", "ile", "path", "h", "filename", "null", "io", "http", "pe", "folder", "FILE", "result", "dir", "fp", "resource"], "bufferedWriter": ["bufferingReader", "buffenedFile", "buffedWriter", "BufferedWrite", "uferedwriter", "bufferingFile", "buffaredWriting", "buffenedWriter", "buffinedWriter", "bufferedwriter", "buffaredWriter", "bufferedFile", "bufferedReader", "ufaredWriter", "ufaredwriter", "bufferingWrite", "ufaredWriting", "BuffererWriter", "buffererW", "buffedWriting", "BufferedWriter", " bufferingFile", "buffererFile", "bufferedWriting", "buffenedReader", "buffererWriter", " bufferingW", "buffenedW", "BuffererWrite", " bufferingWriter", "buffilledWriter", "bufferingWriter", "uferedWriter", " bufferedReader", "uferedWriting", "buffedwriter", "BufferedReader", "bufferedW", "buffaredwriter", "BuffererReader", "buffilledwriter", "buffinedReader", "bufferedWrite", "buffererWrite", "buffinedWrite", " bufferedFile", "bufferingW", " bufferedW", " bufferingReader", "buffinedFile", "buffererReader", "buffilledWriting", "BuffererFile", "BufferedFile"]}}
{"id1": "2668853", "id2": "11341711", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileAsStream", "decodeFiletoStream", "decodeStringTofile", "decodeFiletofile", "decodeFileToFiles", "decodeFile2File", "decodeStringToStream", "decodeFiletoFiles", "decodeFileAsfile", "decodeFileAsFile", "decodeString2File", "decodeFiletoFile", "decodeFileTofile", "decodeString2Stream", "decodeFile2file", "decodeStringToFiles", "decodeString2Files", "decodeFileToStream", "decodeFile2Stream", "decodeFileAsFiles", "decodeStringToFile", "decodeFile2Files", "decodeString2file"], "infile": ["inputFile", "inputfilename", "outfilename", "infilename", "inputfile", "outFile", "inputfiles", "minfile", "outfiles", "infp", "inputfp", "outfp", " infilename", " infiles", " inFile", "infiles", "minfp", "minFile", "minfilename", "inFile"], "outfile": ["outputfilename", "Outfile", "outfilename", "infilename", "outputFile", "outFile", "Outfolder", " outfp", " outfilename", "infp", "outfp", " outFile", "outputfull", " outfull", "outfull", "Outfull", " outfolder", "outputfp", "outputfile", "infolder", "OutFile", "outputfolder", "outfolder"], "in": ["reader", "bin", "login", "f", "data", "socket", "inas", "s", "ins", "pin", "m", "cin", "ex", "min", "In", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "e", "ini", "this", "i", "source", "init", "image", "inc", "nin", "inn", "up", "as", "a", "ic", "lin", "input", "con", "re", "ac", "gin"], "out": ["lock", "bin", "ext", "name", "point", "socket", "error", "session", "s", "sync", "to", "ex", "outs", "In", "base", "copy", "conn", "cache", "b", "output", "again", "inner", "op", "writer", "line", "work", "err", "off", "client", "o", "OUT", "lib", "image", "inc", "exec", "outer", "other", "exit", "no", "pass", "post", "io", "net", "file", "up", "as", "co", "on", "target", "home", "exp", "Out", "write", "obj"], "buffer": ["offset", "bin", "reader", "border", "uffer", "iter", "data", "batch", "slice", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "b", "size", "bytes", "shape", "address", "flush", "row", "padding", "source", "value", "limit", "feed", "url", "transfer", "pause", "server", "null", "memory", "wave", "split", "queue", "input", "resource", "result", "pad", "length", "buf"], "read": ["iter", "current", " check", "find", "reads", "work", " r", "select", "limit", "exec", "fill", "next", " reach", " sleep", "length", "end", "wait", "READ", "open", "Read", "allow", "play", "se", "load", "ind", " write", " connect", "count", "parse", "tell", "id", " load", " reader", "start", "use", " ride", "x", "reader", "ride", "send", " find", "add", "copy", "check", "r", "line", "seek", "lex", " copy", "run", "feed", "connect", "inc", " use", "ad", " receive", "get", " request", "sync", "k", "size", " parse", " Read", "reading", "pass", " send", "index", "input", "skip", "sleep", " get", "write"], "success": ["full", " successful", "job", "rolling", "data", "true", " succ", "cess", "error", "complete", "correct", "successfully", "first", "results", " succeed", "good", "fast", "zero", "winner", "status", "roll", "successful", "again", "ok", "content", "ceed", "rolled", "done", "better", "construct", "found", "warning", "continue", "value", "response", "selected", "Success", "default", "ccess", "pass", "null", "danger", "func", "valid", "yes", "follow", "result", "fail", "initial", "safe", " Success", "accept", "failed"]}}
{"id1": "13596891", "id2": "20519261", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 1, "substitutes": {"doTransfer": ["handleTransfer", "doSend", "makeTransfer", " doImport", "doRequest", "handleRequest", "handleSend", "doImport", "makeRequest", "makeImport", " doRequest", "makeSend", " doSend", "handleImport"], "request": ["reader", "connection", "data", "current", "version", "q", "session", "complete", "QUEST", "command", "type", "stream", "create", "remote", "application", "event", "xml", "received", "position", "req", "model", "user", "rf", "instance", "time", "query", "client", "subject", "this", "condition", "requ", "object", "form", "Request", "context", "config", "enter", "server", "post", "http", "in", "com", "message", "result", "input", "resource", "queue", "record", "report", "re"], "response": ["full", "connection", "version", "error", "session", "respond", "remote", "body", "results", "application", "event", "en", "Response", "status", "model", "page", "cache", "output", "content", "success", "writer", "client", "reply", "service", "warning", "call", "image", "object", "next", "default", "document", "view", "server", "http", " Response", "index", "message", "result", "resource", "out", "res", "header", "cover", "report", "onse", "re", "json", "serv", "resp", "site"], "method": ["version", "reason", "session", "type", "command", "METHOD", "head", "send", "mode", "verb", "sort", "hod", "class", "status", "direction", "format", "description", "position", "text", "time", "term", "content", "cmd", "callback", "subject", "pull", "call", "process", "path", "property", "sign", "date", "route", "prefix", "message", "resource", "json", "string", "use", "Method"], "servletContext": [" servantContext", " servantProvider", "ServletsConfig", "ServletsContext", "servlexContext", "servApplicationContext", "servletCurrent", "servletcontext", "servlexController", "servApplicationConfig", "servantContext", " servantConfig", "servletsContext", "servLETConfig", "Servletscontext", "servletscontext", "servantCurrent", "servLETContext", "servletsConfig", "servletProvider", "servApplicationController", "servleConfig", "servantProvider", "servLETCurrent", "servlexConfig", "ServletContext", "servletConfig", " servletCurrent", "ServletConfig", " servletProvider", " servletConfig", "servLETProvider", "servletController", "Servletcontext", "servApplicationcontext", "servletsController", " servantCurrent", "servleProvider", "servlexcontext", "servleCurrent", "servleContext", "ServletController", "servantConfig", "ServletsController"], "wac": ["wAC", " WAC", " wae", "wsae", " Wae", "wae", " wAC", " Wacs", " wacs", " Wac", "wsAC", "wsacs", "wsac", "wacs"], "szUrl": ["asizFrame", " sizurl", "szFolder", "szerURL", "szerFrame", "szerUrl", "sziurl", "aszUrl", "sizURL", "szenurl", "sziUrl", "aszUr", "sziUr", "szaPath", "szeUrl", " sizUrl", "sizPath", "szenUrl", "asizPath", " sizFolder", "sznUrl", "sziURL", "sizFolder", "sizUr", "asizUr", "asizurl", "sznurl", "szeFolder", "asizUrl", "sizurl", "szeUr", "szerUr", "sizFrame", "szenFolder", " sizURL", "sznPath", "aszURL", "sznUr", "szaURL", " szurl", "szurl", "szeURL", "sznURL", "szenURL", "asizURL", " szURL", "szPath", "szeFrame", "szFrame", " szFolder", "szUr", "szaUrl", "sizUrl", "szURL", "aszPath", "szeurl", "szaUr", "aszFrame", "aszurl"], "url": ["ul", "connection", "sl", "f", "loc", "get", "name", "org", "fl", "socket", "ur", "gl", "el", "stream", "web", "event", "xml", "base", "log", "ssl", "ll", "page", "conn", "cloud", "user", "l", "key", "client", "Url", "buffer", "source", "URL", "service", "lb", "context", "config", "li", "server", "uri", "http", "rel", "file", "impl", "resource", "www", "host", "location", "rl", "re", " URL", "string", "obj", "il"], "is": ["x", "ais", "Is", " are", "iss", "isl", "it", "ri", "oss", "bs", " bis", "info", "has", "web", "cms", "os", "im", " isn", "rc", "IS", "isa", "isc", "was", "i", "ci", "isu", "il", "bis", "ir", "uri", "ii", "ris", "io", "as", "ils", "iso", "isf", "src", "ai", "us", "ios", "lis", "serv", "ip", "ib", "rx", "isi"], "sout": ["sin", "sdata", "Sin", "souts", "sOUT", "sOut", " sOut", "SOut", " sin", " souts", "Souts", "Sdata", " sdata", "Sout", "SOUT", " sOUT"], "con": ["const", "login", "cos", "version", "nc", "type", "web", "ssl", "Internal", "win", "single", "subject", "common", "ctx", "ocon", "exec", "xc", "close", "pen", "conv", "c", "com", "co", "on", "coll", "ctrl", "re", "fc", "open", "cur", "pin", "m", "syn", "fe", "en", "pc", "san", "lc", "conn", "cache", "conf", "don", "query", "client", "wa", "general", "author", "fa", "internal", "Connection", "bc", "cons", "ver", "cn", "util", "wan", "un", "remote", "ct", "C", "ec", "fun", "pre", "ran", "cc", "run", "connect", "inc", "java", "http", "Common", "crit", "cp", "connection", "get", "ca", "non", "min", "event", "gen", "rc", "status", "user", "can", "l", "Con", "uc", "cf", "CON", "ren", "cl", "view", "server", "core", "net", "func"], "hNames": ["hostKeys", " hNs", "ihBlocks", "hBlocks", "hostNames", " hKeys", "hFiles", " hBlocks", "hName", "ihVs", "ihNames", "HTypes", "HVs", "hrNs", "hrNames", "hrKeys", "hostNs", "hTypes", "ihName", "hNs", "hrName", " hTypes", "hrTypes", "HNames", "HName", "HBlocks", " hVs", "hKeys", "hrFiles", " hFiles", "hVs", "hostTypes", "HFiles", " hName"], "txt": ["nt", "lt", "cb", "elt", "name", "tin", "wt", "git", "q", "py", "ct", "bt", "XT", "str", "gz", "inet", "binary", "prot", "ht", "jp", "text", "csv", "section", "zip", "sv", "key", "utt", "xt", "rr", "xxx", "vt", "fx", "ctx", "value", "t", "Text", "phrase", "struct", "v", "et", "in", "lv", "rx", "gt", "header", "kt", "gi", "fp", "TEXT", "htm", "qt", "nm", "tx", "obj", " text", "dt", "wx"], "inBody": ["Inbody", "outBody", "InBody", "outFile", "outStream", "outbody", "InStream", "INFile", "inbody", "INReader", "insReader", " inStream", "insStream", "INbody", " inFile", "insBody", "InReader", "insFile", "INBody", " inbody", " inReader", "inStream", "InFile", "inReader", "INStream", "inFile"], "bufCh": [" bufC", "queueCh", "buffCh", " bufCH", "ufCh", "queuech", "buffch", "buffCH", "bufChar", "bufferCH", "bufch", " bufch", "queueCH", "ufC", "ufch", "bufCol", "bufCH", "buffC", "bufC", "ufCol", "bufferch", "bufferCh", "ufCH", "bufferChar", "queueCol", " bufChar", "ufChar", " bufCol"], "r": ["x", "rh", "reader", "er", "f", "reg", "ri", "q", "g", "range", "R", "m", "p", "k", "ru", "str", "rc", "pr", "u", "b", " rg", "br", "rf", "w", "cr", "rs", "ar", "e", "fr", "err", "rr", "rb", "i", "d", "ner", "hr", "rw", "rg", "v", "lr", "rd", "n", "nr", "rt", "c", "sr", "ror", "result", "res", "rl", "re"], "outReq": ["outRecreq", " outEq", "outREck", "outDequest", " outReh", "outEque", "outRquest", " outSeck", "outRsq", " outSeque", " outRsce", "outRece", "outEreq", "outREh", "outRsce", "outDeque", " outRq", "outSece", " outRsq", "outSequest", " outSece", "outConce", " outReque", " outRereq", "outRecq", " outRce", "outRsque", "outSeq", "outConque", "outRce", "outREque", "outReck", "outSeque", "outRck", "outRecque", " outRsh", " outRsque", " outEque", "outRsh", "outEck", "outEq", "outRecck", " outEreq", "outDece", "outDeq", " outRequest", "outReh", "outRereq", "outRequest", "outConh", "outRecce", "outRreq", " outRque", " outEck", " outRece", " outRquest", "outConq", "outRque", "outREq", "outSeck", "outREce", "outRq", " outSeq", " outReck", "outReque"], "buff": ["Ptr", "Msg", "f", "data", "array", "info", "Buffer", "p", " buffers", "bb", "b", "num", "lines", "buffer", "map", "ch", " chunk", "Buff", "Info", "file", "Pad", "uf", " Buffer", "buf", " Buff"]}}
{"id1": "11484416", "id2": "5138455", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"moveFile": [" movedDirectory", " moveDirectory", "MoveFiles", " movedFiles", "moveFiles", "MoveDirectory", " movedPath", " movedFile", " moveFiles", "movePath", "moveDirectory", " movePath", "MovePath", "MoveFile"], "orig": ["bin", "iter", "ext", "Orig", "f", "loc", "org", "origin", "archive", "ctr", "remote", "raf", "array", "ori", "info", "comb", "base", "prev", "copy", "img", "old", "coord", "raid", "dest", "imag", "temp", "rb", "exe", "proxy", "source", "real", "init", "image", "build", "bas", "original", "file", "folder", "id", "impl", "src", "transform", "frame", "coll", "home", "internal", "obj", "buf", "tmp"], "target": ["nt", "f", "current", "it", "force", "origin", "manager", "master", "archive", "arget", "remote", "reference", "auto", "to", "base", "prot", "format", "copy", "match", "eth", "dest", "temp", "this", "ret", "external", "source", "build", "template", "t", "project", "path", "parent", "object", "next", "platform", "original", "Target", "resource", "join", "result", "replace", "compatible", " Target", "tmp"], "buffer": ["bin", "iter", "uffer", "sequence", "data", "batch", "reference", "slice", "layer", "buff", "stack", "Buffer", "binary", "base", "position", "copy", "bb", "cache", "b", "bytes", "content", "address", "padding", "source", "block", "feed", "request", "url", "transfer", "read", "code", "raw", "null", "repeat", "file", "wave", "message", "frame", "header", "result", "resource", "input", "queue", "length", "write", "buf"], "bread": ["ffe", "rows", "bat", "fen", "batch", "robe", "piece", "fle", "ble", "fall", "good", "web", "rub", "div", "fe", "eb", "zero", "str", "fine", "fed", "bn", "loop", "bb", "die", "beat", "cook", "num", "zip", "wake", "bare", "key", "circ", "design", "bc", "abi", "meal", "feed", "cake", "raft", "brew", "choice", "fred", "food", "wen", "bee", "width", "hello", "inn", "knife", "buck", "grain", "sleep", "fee", "length", "fif", "rib", "four", "broken"], "fis": ["fiss", "lfos", "afis", "ufiss", "hIs", "fisa", " fisa", "his", "qils", "lfis", "fIs", " fIs", "fxIs", "fxis", "fxisa", "afiss", "afos", "afIs", "fxos", "qos", "fils", "hisa", "qiss", " fiss", "lfIs", "ufils", " fils", "lfiss", "qis", "ufis", "hos", "ufos"], "fos": ["infaos", " foss", "flens", "Foses", "foses", "flois", "fose", "flose", "Fose", "gros", "Fois", "Faos", "gis", "flaos", "Fros", " fose", "flors", "floses", "gos", "Fens", " foses", "Fis", "infos", "infois", "fors", "fros", "Foss", "goss", "foss", " fens", "Fos", " fros", "fois", "faos", "flos", "Fors", "fens", "infors"]}}
{"id1": "11704429", "id2": "19147281", "code1": "    public void run() {\n        RandomAccessFile file = null;\n        InputStream stream = null;\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=\" + downloaded + \"-\");\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                error();\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                error();\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            }\n            file = new RandomAccessFile(destination, \"rw\");\n            file.seek(downloaded);\n            stream = connection.getInputStream();\n            while (status == DOWNLOADING) {\n                byte buffer[];\n                if (size - downloaded > MAX_BUFFER_SIZE) {\n                    buffer = new byte[MAX_BUFFER_SIZE];\n                } else {\n                    buffer = new byte[size - downloaded];\n                }\n                int read = stream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                status = COMPLETE;\n                stateChanged();\n            }\n        } catch (Exception e) {\n            error();\n        } finally {\n            if (file != null) {\n                try {\n                    file.close();\n                } catch (Exception e) {\n                }\n            }\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"run": ["worker", "download", "load", " deploy", "loop", "done", "work", "client", "build", "init", " running", "process", "exec", "url", "update", "server", "up", " loop", " work", "running", "sleep", "execute", "Run", "start", "runner"], "file": ["reader", "le", "lock", "f", "data", "tree", "File", "force", "channel", "socket", "pool", "handler", "play", "body", "layer", "fe", "letter", "log", "per", "base", "binary", "library", "cache", "b", "loader", "files", "user", "zip", "writer", "line", "collection", "flow", "lf", "pull", "proxy", "source", "lib", "image", "feed", "child", "path", "like", "object", "filename", "il", "url", "uri", "server", "io", "http", "pe", "folder", "function", "FILE", "resource", "queue", "fp", "directory", "media", "use", "fit"], "stream": ["reader", "pipe", "sl", "data", "socket", "channel", "pool", "handler", "thread", "slice", "per", "log", "ssl", "roll", "loader", "output", "video", "box", "wrapper", "zip", "writer", "client", "temp", "row", "source", "image", "feed", "port", "child", "or", "response", "path", "object", "form", "url", "sw", "context", "iterator", "view", "server", "post", "io", "http", "in", "draft", "upload", "resource", "input", "queue", "result", "coll", "via", "length", "string", "pod", "Stream"], "connection": ["reader", "version", "channel", "socket", "error", "handler", "session", "database", "command", "creator", "operation", "to", "info", "application", "timeout", "position", "conn", "b", "text", "wrapper", "internet", "section", "writer", "collection", "translation", "password", "client", "service", "connected", "proxy", "condition", "image", "source", "connect", "or", "response", "ion", "character", "url", "context", "config", "number", "relation", "server", "uri", "io", "http", "c", "function", "problem", "resource", "con", "directory", "Connection", "communication"], "contentLength": ["ContentLength", "serverLen", " contentNumber", "contentlength", "ContentSize", " contentType", "sizeLen", "serverLength", "requestNumber", "contentType", "requestLength", "resourceLength", "contentLen", "requestUrl", "contentSize", "ContentLen", "sizeSize", "contentUrl", "serverSize", "loadlength", "rawLen", "contentNumber", "rawLength", "rawSize", "Contentlength", "resourceUrl", "resourceNumber", " contentUrl", "serverlength", "sizeLength", "requestType", "loadLength", "loadSize", "resourceType", "loadLen"], "size": ["offset", "loc", "name", "sized", "scale", "complete", "body", "send", "clean", "timeout", "Size", "load", "position", "cache", "time", "weight", "bytes", "content", "year", "zip", "max", "capacity", "shape", "address", "count", "storage", "source", "ci", "limit", "value", "large", "speed", "form", "close", "small", "width", "number", "code", "server", "empty", "unit", "SIZE", "ize", "length", "fee"], "buffer": ["reader", "bin", "border", "offset", "iter", "uffer", "data", " data", "channel", " buf", "pool", "batch", "slice", "reference", "seed", "sync", "layer", "buff", "Buffer", "load", "zero", " buffers", "base", "binary", "position", "bb", "cache", "callback", "capacity", "flush", "address", "row", "padding", "source", "block", "feed", "limit", "child", "url", "number", "transfer", "null", "rate", "wave", "queue", "header", "result", "resource", "length", "write", "buf"], "downloaded": ["underloaded", "deped", "diffload", "ownloading", "downsloader", "downgraded", "deled", "downsgraded", "downled", "diffloaded", "disload", "ownloaded", "underloading", "downsload", "download", "ownled", "owngraded", "degraded", "DOWNled", "uploaded", "downloader", "ownped", "diffled", "downwritten", "DOWNloader", "diswritten", " downled", "downsloading", "downsloaded", "underwritten", "underload", "DOWNloaded", "disloaded", "deload", "diffloading", "downloading", " download", "disloading", "downsped", " downloading", "upled", "ownloader", "DOWNload", "downsled", "upload", "uploading", "deloading", "deloaded", "ownload", "downswritten", "downped"], "read": ["READ", "readable", "data", "get", "start", "ride", "scale", "Read", "allow", "play", "range", "create", "slice", "change", "send", "se", "ip", "load", "en", "find", "reads", "add", "copy", "call", "check", "b", "weight", "r", "line", "work", "flow", "bind", "count", "i", "parse", "select", "block", "feed", "connect", "limit", "build", "exec", "fill", "inc", "child", "like", "update", "level", "reading", "raw", "pass", "number", "view", "rate", "io", "in", "index", "resource", "skip", "sleep", "length", "accept", "write", "use", "end", "wait"], "status": ["active", "lock", "current", "si", "name", "version", "error", "reason", "session", "complete", "type", "flag", "press", "state", "mode", "str", "sem", "class", "content", "Status", "service", "style", "source", "step", "continue", "process", "spin", "speed", "stage", "sum", "score", "sign", "code", "server", "unit", "date", "update", "null", "id", "message", "scene", "stat", "action", "sb", "result", "fail", "progress", "wait"]}}
{"id1": "20190303", "id2": "5299276", "code1": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"test01_ok_failed_500_no_logo": ["test01_ok_failed_500_NO__log", "test01_ok_failed_500_NO_blog", "test01_ok_failed_500_no1Log", "test01_ok_failed_500_NO__blog", "test01_ok_failed_500_no__ban", "test01_ok_failed_500_no_Log", "test01_ok_failed_500_no1blog", "test01_ok_failed_500_no_ban", "test01_ok_failed_500_NO_ban", "test01_ok_failed_500_no1ban", "test01_ok_failed_500_NO_log", "test01_ok_failed_500_no__blog", "test01_ok_failed_500_NO__Log", "test01_ok_failed_500_no_log", "test01_ok_failed_500_NO_Log", "test01_ok_failed_500_no_blog", "test01_ok_failed_500_NO__ban", "test01_ok_failed_500_no__log", "test01_ok_failed_500_no__Log", "test01_ok_failed_500_no1log"], "client": ["connection", "https", "app", "manager", "force", "self", "socket", "channel", "pool", "session", "handler", "method", "secure", "Client", "p", "web", "per", "class", "plugin", "ssl", "conn", "cache", "instance", "console", "this", "proxy", "call", "cli", "service", "child", "api", "port", "request", "connect", "url", "config", "server", "uri", "http", "c", "php", "tc", "resource", "con", "host", "wait"], "post": ["f", "self", "head", "method", "to", "after", "load", "set", "copy", "success", "zip", "pre", "posts", "patch", "test", "call", "proxy", "entry", "build", "port", "api", "submit", "request", "process", "Post", "POST", "object", "feed", "next", "builder", "project", "code", "server", "pass", "http", "php", "upload", "pod", "end", "apply"], "response": ["connection", "data", "error", "pool", "respond", "method", "body", "application", "Response", "status", "model", "page", "successful", "output", "throw", "success", "reply", "respons", "service", "feed", "api", "request", "object", "next", "document", "view", "server", "http", "index", "message", "result", "resource", "report", "onse", "json", "resp", "site"]}}
{"id1": "14194234", "id2": "10212189", "code1": "    private String File2String(String directory, String filename) {\n        String line;\n        InputStream in = null;\n        try {\n            File f = new File(filename);\n            System.out.println(\"File On:>>>>>>>>>> \" + f.getCanonicalPath());\n            in = new FileInputStream(f);\n        } catch (FileNotFoundException ex) {\n            in = null;\n        } catch (IOException ex) {\n            in = null;\n        }\n        try {\n            if (in == null) {\n                filename = directory + \"/\" + filename;\n                java.net.URL urlFile = ClassLoader.getSystemResource(filename);\n                if (urlFile == null) {\n                    System.out.println(\"Integrated Chips list file not found: \" + filename);\n                    System.exit(-1);\n                }\n                in = urlFile.openStream();\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            StringBuffer xmlText = new StringBuffer();\n            while ((line = reader.readLine()) != null) {\n                xmlText.append(line);\n            }\n            reader.close();\n            return xmlText.toString();\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"Integrated Chips list file not found\");\n            System.exit(-1);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n        return null;\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 1, "substitutes": {"File2String": ["File4string", "FiletoString", "Filetostring", "File4Line", "file4Line", "file4String", "FiletoStr", "file4Str", "File2Line", "FileTostring", "file4string", "File4Str", "FileToStr", "file2string", "FileToLine", "File4String", "file2Str", "FileToString", "File2Str", "file2String", "FiletoLine", "File2string", "file2Line"], "directory": ["office", "connection", "division", "manager", "archive", "database", "python", "application", "mode", "direction", "library", "description", "direct", "txt", "section", "root", "collection", "password", "d", "source", "storage", "project", "path", "environment", "system", "document", "uri", "category", "folder", "file", "prefix", "module", "Directory", "resource", "dir", "location"], "filename": ["connection", "sequence", "name", "File", "database", "language", "layer", "download", "xml", "fil", "SourceFile", "nil", "binary", "summary", "inline", "kl", "Filename", "description", "ssl", "loader", "files", "txt", "href", "l", "ppa", "fn", "collection", "journal", "password", "ename", "which", "source", "path", "phrase", "il", "url", "document", "figure", "uri", "route", "metadata", "jo", "file", "folder", "title", "prefix", "utf", "FILE", "resource", "sf", "fp", "token", "location", "rl", "string", "dll", "username"], "line": ["le", "iter", "data", "name", "char", "type", "se", "en", "str", "xml", "letter", "log", "base", "lc", "rule", "page", "part", "text", "l", "ace", "e", "cell", "key", "ine", "row", "buffer", "source", "entry", "comment", "parse", "feed", "Line", "write", "character", "url", "cl", "next", "li", "code", "nl", "unit", "ml", "pe", "file", "id", "LINE", "word", "len", "frame", "lin", "link", "string", "liner", "ip", "end"], "in": ["x", "bin", "connection", "isin", "login", "into", "get", "it", "socket", "inas", "ins", "pin", "stream", "cin", "ex", "min", "In", "en", "vin", "is", "kin", "conn", "b", "inner", "include", "rin", "part", "again", "win", "r", "din", "l", "IN", "err", "o", "ini", "i", "source", "init", "inc", "nin", "or", "arin", "url", "reading", "n", "thin", "io", "inn", "c", "file", "as", "id", "index", "a", "fa", "src", "lin", "fin", "input", "out", "resource", "token", "gin"], "f": ["x", "df", "inf", "File", "fl", "fen", "p", "info", "fe", "b", "w", "F", "l", "fn", "e", "tf", "fr", "lf", "this", "d", "i", "fx", "feed", "t", "h", "v", "n", "c", "file", "folder", "fa", "func", "fd", "fin", "bf", "sf", "fp", "fm", "out", "fo", "fc", "fb", "fs"], "urlFile": [" urlLine", "urlUrl", "viewUrl", "viewfile", "viewContent", "URLInfo", "resourcePath", "systemPath", "viewFile", "UrlLine", " urlContent", "UrlInfo", "resourcefile", " urlfile", " urlFolder", "urlInfo", "UrlFile", "resourceContent", "urlContent", "UrlFolder", " urlUrl", "urlFolder", "urlfile", "URLLine", " urlInfo", "urlLine", "resourceUrl", " urlPath", "URLFolder", "resourceLine", "URLFile", "resourceFile", "urlPath", "systemFile", "systemUrl", "systemLine"], "reader": ["iter", "er", "ri", "handler", "stream", "layer", "ger", "per", "rc", "loader", "inner", "r", "writer", "l", "rer", "parser", "rr", "row", "buffer", "i", "ner", "oder", "feed", "builder", "driver", "reading", "read", "bird", "uri", "server", "io", "file", "cher", "rar", "ry", "result", "input", "out", "ler", "Reader", "editor", "over", "rx"], "xmlText": ["mlString", "mlBuffer", "xmlString", "jsonBuffer", "urlString", "phpTEXT", "phpText", "phptext", "jsonTEXT", " xmltext", "xmlTEXT", "xmltext", "phpData", "mlText", "mlData", "jsonData", "urlData", "xmlBuffer", "xmlData", " xmlData", "urlTEXT", " xmlBuffer", "mltext", " xmlTEXT", "mlTEXT", "jsonText", "urlText", " xmlString"]}}
{"id1": "8329093", "id2": "1169642", "code1": "    public void parse(ParserEvent event) {\n        logger.debug(\"parse() called for link \" + event.getLink().getURI());\n        if (event.getLink().getURI().matches(itemFilter)) {\n            logger.debug(\"Content \" + event.getLink().getURI() + \" matched\");\n            Statement stmt = null;\n            ResultSet rs = null;\n            long checksum1 = 0;\n            try {\n                URL url = new URL(event.getLink().getURI());\n                checksum1 = url.openConnection().getLastModified();\n            } catch (MalformedURLException mfe) {\n                logger.error(\"Malformed url \" + event.getLink().getURI() + \" - \" + mfe.getMessage());\n                return;\n            } catch (IOException ioe) {\n                logger.error(\"Couldn't read \" + event.getLink().getURI() + \" - \" + ioe.getMessage());\n                return;\n            }\n            if ((checksum1 == 0) || (checksum1 == 1)) {\n                Adler32 adler32 = new Adler32();\n                NodeList nodes = (NodeList) event.getPageData().getData();\n                adler32.update(nodes.toHtml().getBytes());\n                checksum1 = adler32.getValue();\n            }\n            try {\n                stmt = conn.createStatement();\n                rs = stmt.executeQuery(\"SELECT * FROM documents WHERE url='\" + event.getLink().getURI() + \"'\");\n                if (rs.first()) {\n                    long checksum2 = rs.getLong(\"checksum\");\n                    if (checksum1 == checksum2) {\n                        stmt.executeUpdate(\"UPDATE documents SET checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    } else {\n                        stmt.executeUpdate(\"UPDATE documents SET checksum=\" + checksum1 + \", checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    }\n                } else {\n                    stmt.executeUpdate(\"INSERT INTO documents VALUES \" + \"(DEFAULT, '\" + event.getLink().getURI() + \"', \" + checksum1 + \", '\" + providerId + \"', \" + String.valueOf(System.currentTimeMillis()) + \")\");\n                }\n            } catch (SQLException e) {\n                logger.error(\"Could't perform database query or update - \" + e.getMessage());\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    rs = null;\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    stmt = null;\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        String key = getKey();\n        synchronized (this.lauchedHTTPRequests) {\n            if (this.lauchedHTTPRequests.contains(key)) return;\n            this.lauchedHTTPRequests.add(key);\n        }\n        String st = this.dataSource.getTileURL(this.x, this.y, this.z);\n        URL url;\n        try {\n            url = new URL(st);\n        } catch (MalformedURLException e1) {\n            logger.warning(\"Error in URL: \" + st);\n            return;\n        }\n        String geoJSON = \"\";\n        try {\n            InputStream is;\n            if (\"file\".equals(url.getProtocol())) is = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) is = url.openStream(); else {\n                logger.warning(\"Impossible to load settings from \" + url + \". Unsupported protocol \" + url.getProtocol());\n                return;\n            }\n            BufferedReader in = new BufferedReader(new InputStreamReader(is));\n            String line;\n            while ((line = in.readLine()) != null) geoJSON += line;\n            in.close();\n        } catch (FileNotFoundException e) {\n            return;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n        VectorTile tile = new VectorTile(geoJSON, x, y, z);\n        Geometry[] geoms = new Geometry[tile.getPieces().size()];\n        int i = 0;\n        for (MfGeo geo : tile.getPieces()) {\n            if (geo.getGeoType() == GeoType.GEOMETRY) {\n                geoms[i++] = ((MfGeometry) geo).getInternalGeometry();\n            } else if (geo.getGeoType() == GeoType.FEATURE) {\n                MfFeature mf = (MfFeature) geo;\n                geoms[i++] = mf.getMfGeometry().getInternalGeometry();\n            }\n        }\n        GeometryCollection gc = new GeometryFactory().createGeometryCollection(geoms);\n        this.dataSource.getDataLoader().add(new OpenCartoFeature(this.dataSource.getLayer(), new Rep(gc), this.z));\n        this.dataSource.getLayer().getDisplayCacheLoader().coin();\n        synchronized (this.lauchedHTTPRequests) {\n            this.lauchedHTTPRequests.remove(key);\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["Parser", "handle", " discover", "info", "se", " build", "arse", " scan", " dissect", "patch", "parser", " split", " parsing", " serve", " merge", "pack", " explode", "process", " parser", " extract", " assemble", " read", "replace", " patch", " sniff", " setup", " analyse", "apply"], "event": ["x", "open", "app", "actual", "data", "version", "error", "handler", "type", "g", "stream", "layer", "info", "events", "load", "xml", "cache", "user", "text", "instance", "vent", "entity", "content", "e", "flow", "address", "this", "comment", "style", "entry", "image", "source", "Event", "request", "response", "parent", "object", "environment", "ev", "v", "context", "update", "other", "document", "view", "attribute", "config", "author", "original", "function", "ce", "message", "action", "item", "result", "resource", "input", "element", "node"], "stmt": ["tpt", "STmd", " stbl", " stmb", " stmn", "tmd", "admd", " stct", " start", "Stmt", "Stpt", "adql", "STmn", "stmd", " stm", " stpt", "tbl", "Stmb", "STmt", "rnt", "spbl", "admt", " stmd", "spmd", "Stbl", "dnt", "STm", "Stct", "dql", "stql", "tm", "stbl", "adbl", "tmn", "stmn", "dmt", "spmt", "adpt", "stm", "tmt", "dpt", "spart", "rpt", "tct", "Stm", "stmb", "stpt", "tmb", "Stmd", "adnt", "stnt", "stct", "rmt", "start", "adart", "rql"], "rs": ["mr", "ts", "vals", "RC", "rows", "RS", "sels", "maps", "eers", "ds", "icks", "ins", "bs", "results", "Rs", "acks", "events", "vers", "relations", "ats", "ows", "rc", "cs", "ys", "ls", "pr", "obs", "repl", "r", "runs", "lines", "rr", "ras", "rys", "nas", "hs", "ws", "hr", "stats", "qs", "ars", "xs", "rd", "gs", "odes", "rt", "ps", "ris", "details", "otes", "sr", "src", "rss", "result", "res", "opens", "ros", "ges", "ms", "resources", "ks"], "checksum1": ["checksumm2", "checksumbOnce", " checkssum0", "checkssum1", "checksummer0", " checksum100", "checksnum61", "checksumsOne", "checksumbOne", "checksummer91", "checkssum2", "checkssum61", "checksumOnce", "checksnum2", " checkssum2", "checksum0", " checksum3", " checksum61", " checkssum1", "checksumsOnce", "checksum3", "checksull2", "checksums1", "checksque2", " checkssumOne", "checksumb2", "checksumm1", "checksumi1", " checksum0", "checksnum0", "checksUM3", "checksUM2", " checkssum91", "checkssum3", "checkssumOnce", " checkssum61", "checksUM1", "checksnumOne", "checksUMOne", "checksummer2", "checksumOne", "checksull1", "checkssum91", "checksullOne", "checksum91", "checksque100", "checksum61", "checksam1", "checksque1", "checksum100", "checkssum0", " checksumOnce", "checksumb1", " checkssum100", "checkssumOne", "checksnum1", "checksam100", "checksnum3", "checksums2", "checkssum100", "checksnum91", "checksummOne", " checksum91", "checksam2", "checksull61", " checksumOne", "checksummer1", "checksque0", "checksumi3", " checkssumOnce", "checksumi2", "checksam0", " checkssum3"], "url": ["ul", "connection", "job", "sl", "URI", "f", "data", "loc", "org", "fl", "channel", "error", "el", "stream", "layer", "web", "xml", "base", "ssl", "ll", "ls", "html", "page", "conn", "b", "user", "blog", "match", "text", "content", "r", "l", "address", "pull", "Link", "Url", "buffer", "URL", "image", "api", "path", "object", "uri", "server", "http", "file", "impl", "ball", "id", "message", "resource", "bel", "www", "orb", "coll", "link", "location", " URL", "string", "ob"], "adler32": ["adlr31", " adlr2", " adler40", "adger31", " adger40", " adler16", " adger31", "adlor32", "adlor16", "adger16", "aclr2", " adger32", "adder31", "adder40", "adle40", "adlr16", "aclr16", "adle2", " adger16", "aclr52", "acler32", "adlr32", "acler52", "adlr40", "adler40", "adle16", "adger2", " adlr32", "acler2", "adder16", "adger40", "adlr2", "adger52", "adler52", " adler31", "adler31", "adlr52", "adlor2", " adlr40", "adlor52", "adger32", " adler2", "adler16", "adler2", " adlr16", "adder32", "acler16", "aclr32", "adle32"], "nodes": ["nubes", "Nubes", "sodes", "Nodes", "sods", "sode", "snobs", "tods", "Node", "tents", " node", "Nobs", "snode", " nobs", "Nents", "sents", "snodes", "snubes", " nubes", "nents", "nods", "todes", "nobs", "tode", "Nods", "node"], "checksum2": [" checksum82", "checksums1", "checksha82", "checksha1", " checkssum0", "checksha0", "checksha2", "checksub2", "checksums2", "checkssum1", "checksummer0", "checksums0", "checkssum2", " checkssum82", " checksum0", "checksub1", " checkssum2", "checksummer1", "checksummer82", "checksub0", "checksum0", "checkssum82", "checkssum0", " checkssum1", "checksum82", "checksummer2"]}}
{"id1": "4852691", "id2": "17817568", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "code2": "    public Reader getGETReader_bak(URL url) {\n        Reader reader = null;\n        if (Navigator.isVerbose()) System.out.println(\"Web3DService.getGETReader caching \" + url);\n        int contentLength = -1;\n        URLConnection urlc;\n        try {\n            urlc = url.openConnection();\n            urlc.setReadTimeout(Navigator.TIME_OUT);\n            if (getEncoding() != null) {\n                urlc.setRequestProperty(\"Authorization\", \"Basic \" + getEncoding());\n            }\n            urlc.connect();\n            String content_type = urlc.getContentType();\n            if (content_type == null || content_type.equalsIgnoreCase(\"x-world/x-vrml\") || content_type.equalsIgnoreCase(\"model/vrml\") || content_type.equalsIgnoreCase(\"model/vrml;charset=ISO-8859-1\")) {\n                InputStream is = urlc.getInputStream();\n                DataInputStream d = new DataInputStream(is);\n                contentLength = urlc.getContentLength();\n                byte[] content = new byte[contentLength];\n                if (d != null) {\n                    d.readFully(content, 0, contentLength);\n                }\n                is.close();\n                d.close();\n                ByteArrayInputStream bais = new ByteArrayInputStream(content);\n                reader = new InputStreamReader(bais);\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip\")) {\n                InputStream is = urlc.getInputStream();\n                BufferedInputStream bis = new BufferedInputStream(is);\n                GZIPInputStream gis = new GZIPInputStream(bis);\n                StringBuffer sb = new StringBuffer();\n                BufferedReader zipReader = new BufferedReader(new InputStreamReader(gis));\n                char chars[] = new char[10240];\n                int len = 0;\n                contentLength = 0;\n                while ((len = zipReader.read(chars, 0, chars.length)) >= 0) {\n                    sb.append(chars, 0, len);\n                    contentLength += len;\n                }\n                chars = null;\n                gis.close();\n                zipReader.close();\n                bis.close();\n                is.close();\n                reader = new StringReader(sb.toString());\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(cis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    cis.close();\n                    bufReader.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    GZIPInputStream gis = new GZIPInputStream(cis);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(gis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    bufReader.close();\n                    gis.close();\n                    cis.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"text/html;charset=utf-8\")) {\n                System.out.println(\"text/html;charset=utf-8\");\n            } else {\n                System.err.println(\"ContentNegotiator.startLoading unsupported MIME type: \" + content_type);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return reader;\n    }\n", "label": 0, "substitutes": {"hash": ["get", " fingerprint", " hashing", "str", "dump", "log", "dig", "copy", "add", "check", "component", "text", "password", " Hash", "build", "pack", "h", "sum", "update", "code", "read", " hashes", "print", "Hash", "string", "SHA"], "data": ["reader", "connection", "s", "database", "audio", "body", "p", "info", "str", "dump", "hex", "binary", "base", "format", "video", "text", "output", "bytes", "content", "key", "address", "buffer", "padding", "source", "storage", "image", "response", "memory", "DATA", "a", "message", "result", "input", "dat", "length", "json", "string", "media"], "digest": ["signEST", " diger", "digit", "DigEST", "digener", " digests", "Digester", "biger", "signests", "digester", "Digse", "logener", "bigester", "digEST", "Digener", "bigest", " digger", "digger", "logester", "digse", "bigEST", "signester", " digEST", "diger", "Digger", "logest", "signer", "Diger", "signest", "signger", " digse", "loger", "digests", "Digit", " digit", "signit", " digener", "signse", " digester", "Digest", "Digests", "bigger"]}}
{"id1": "14001795", "id2": "23291583", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    private ByteArrayInputStream fetchUrl(String urlString, Exception[] outException) {\n        URL url;\n        try {\n            url = new URL(urlString);\n            InputStream is = null;\n            int inc = 65536;\n            int curr = 0;\n            byte[] result = new byte[inc];\n            try {\n                is = url.openStream();\n                int n;\n                while ((n = is.read(result, curr, result.length - curr)) != -1) {\n                    curr += n;\n                    if (curr == result.length) {\n                        byte[] temp = new byte[curr + inc];\n                        System.arraycopy(result, 0, temp, 0, curr);\n                        result = temp;\n                    }\n                }\n                return new ByteArrayInputStream(result, 0, curr);\n            } finally {\n                if (is != null) {\n                    try {\n                        is.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            if (outException != null) {\n                outException[0] = e;\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"copyOverWarFile": ["copyOverWebFile", "copyOverWarPath", "copyoverwarfile", "copyOverWebfile", "copyoverWarfile", "copyOverWebFiles", "copyoverWarPath", "copyOverWARFile", "copyOverWarFiles", "copyoverWarFile", "copyOverWARFiles", "copyOverWebPath", "copyOverwarfile", "copyoverWarFiles", "copyOverwarFiles", "copyoverwarFiles", "copyOverWARPath", "copyOverwarPath", "copyoverwarPath", "copyOverWARfile", "copyOverwarFile", "copyoverwarFile", "copyOverWarfile"], "dir": ["lock", "df", "cur", "director", "data", "loc", "keep", "manager", "doc", "wd", "handler", "handle", "dn", "clean", "download", "local", "log", "class", "direction", "plugin", " directory", "di", "cache", "part", "direct", "Dir", "r", "work", "zip", "dist", "md", "dr", "dc", "d", "lib", "build", "db", "feed", "parent", "url", "config", "store", "group", "ir", "http", "up", "folder", "file", "draft", "DIR", "fd", "coll", "window", "def", "directory", "desc", "pkg"], "ff": ["ffe", "df", "bd", "cb", "fl", " buff", "aff", "cpp", "fw", "dd", "fff", "buff", "fe", "fed", "bb", "rf", "ph", "uff", "xff", "fold", "FF", "fox", "lf", "upp", "flow", "pp", "ffff", "fx", "feed", "cf", "fam", "cl", "eff", "ef", "iff", "eph", "fd", "uf", "bf", "sf", "TF", "fp", "ft", "fb", "now", "buf"], "files": ["pages", "images", "blocks", "sections", "data", "rows", "fl", "s", "bs", "groups", "balls", "results", "events", "fe", "Files", "ls", "items", "models", "ums", "features", "apps", "flows", "lines", "iles", "objects", "classes", "names", "ps", "keys", "file", "split", "fa", "jobs", "locks", "users", "plugins", "fs"], "f": ["x", "inf", "name", "fl", "fen", "handler", "aff", "p", "info", "fe", " file", "part", "rf", "F", "l", "fn", "e", "fr", "tf", "fold", "lf", "d", " fa", "i", "feed", "t", "cf", "filename", "of", "v", "n", "flat", "c", "file", "fa", "fd", "bf", "fp", "sf", "fc", "fb", "fs"], "newFile": [" newLine", "smallFile", "existingF", " newDir", "oldFile", "nextFiles", " newfile", "existingFile", "nextFile", "updateFile", "newLine", "smallDir", "nextFolder", "newFolder", "updateF", "existingfile", "andFile", " newFiles", "existingLine", " newFolder", "updateLine", "NewFolder", "newDir", "andfile", "andDir", "smallfile", "nextDir", "oldFiles", "newfile", "NewF", "NewDir", "newF", "newFiles", "NewFile", "oldF", " newF", "NewFiles", "oldDir", "updatefile"], "fi": ["ffe", "si", "fw", "py", "ifi", "Fi", "ife", "info", "afe", "pi", "fe", "shi", "fine", "fy", "ifa", "cci", "bi", "qi", "FI", "fr", "lf", "ini", "ico", "abi", "i", "cf", "xi", "zi", "afi", "uci", "ii", "fa", "sci", "wi", "fin", "flo", "sf", "fp", "fc", "fb", "fs", "isi"], "fo": ["osa", "inf", "si", "oo", "fw", "lo", "info", "afe", "tto", "wo", "fe", "os", "shi", "xf", "di", "ko", "olo", "o", "ico", "ato", "ofi", "mo", "cf", "ki", "obo", "afi", "io", "ho", "ni", "fa", "co", "uf", "po", "flo", "bo", "sf", "zo", "FO", "so", "obi"]}}
{"id1": "6304373", "id2": "5951961", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrTemFiles", "uploadOrDeleteMediaOrMemporary", "uploadOrDeleteMediaOrTemplateporary", "uploadOrDeleteMediaOrMempl", "uploadOrDeleteMediaOrtemFiles", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrtemplates", "uploadOrDeleteMediaOrTemplatepl", "uploadOrDeleteMediaOrTemplateplates", "uploadOrDeleteMediaOrMemFiles", "uploadOrDeleteMediaOrtempl", "uploadOrDeleteMediaOrMemplates", "uploadOrDeleteMediaOrTemporary", "uploadOrDeleteMediaOrTemplateFiles", "uploadOrDeleteMediaOrtemporary"], "action": ["active", "lock", "name", "version", "now", "error", "effect", "type", "method", "operation", "change", "state", "event", "activity", "status", "plugin", "format", "commit", "part", "ction", "section", "flow", "test", "call", "step", "service", "style", "controller", "what", "api", "parent", "environment", "next", "url", "activation", "actions", "view", "function", "Action", "module", "site", "flash", "item", "resource", "ACTION", "element", "act"], "object": ["full", "lock", "office", "current", "version", "now", "self", "edit", "email", "thread", "auto", "mode", "not", "event", "letter", "class", "oid", "model", "part", "instance", "article", "o", "subject", "address", "zone", "service", "image", "ject", "project", "request", "objects", "environment", "parent", "system", "url", "document", "number", "group", "function", "module", "resource", "target", "host", "directory", "none", "string", "obj", "element", "node"], "numElements": ["numGeodes", " numelem", " numElem", "numelem", "numGelements", " numeodes", " numelement", "numeodes", " numEodes", "numElodes", "numElem", "numEllem", " numelements", "numelements", "numEllements", "numEllement", "numGelem", "numelement", "numEodes", "numGelement"], "req": ["msg", "mr", "util", "g", "load", "verb", "xml", "log", "base", "conf", "r", "err", "ctx", "builder", "parent", "next", "update", "gr", "ro", "module", "params", "res", "obj", "usr", "report", "html", "use", "resp"], "session": ["connection", "lock", "manager", "container", "thread", "state", "event", "shared", "local", "Session", "cache", "instance", "client", "subject", "temp", "test", "service", "sp", "image", "ctx", "request", "response", "h", "system", "context", "ESSION", "document", "ession", "sa", "http", "browser", "person", "scope", "global", "flash", "resource", "result", "token", "security", "use", "site"], "ftp": [" ftcp", "FTc", "FTP", " ftP", "ftP", "ttcp", "ftcp", "ttc", "ftc", "FTp", "FTcp", "ttp", "ttP", " ftc"], "user": ["full", "lock", "connection", "er", "profile", "data", "ver", "name", "current", "self", "error", "type", "creator", "info", "state", "shared", "ee", "used", "per", "base", "log", "class", "rule", "html", "page", "match", "mail", "by", "bug", "account", "e", "usa", "client", "member", "User", "this", "comment", "image", "db", "project", "path", "parent", "hash", "other", "url", "system", "config", "facebook", "group", "USER", "pass", "person", "author", "browser", "view", "post", "module", "admin", "users", "result", "custom", "record", "usr", "home", "auth", "string", "use", "username"], "links": ["ids", "pages", "images", "tree", "mails", "email", "groups", "results", "log", "base", "items", "members", "mail", "posts", "lines", "Link", "image", "Links", "url", "actions", "styles", "details", "menu", "flash", "linked", "headers", "link", "html"], "folders": ["filries", "handers", "filages", "foldages", "handors", "anchors", "filers", "foldries", "filors", "anchers", "handries", "anchries", "anchages", "foldors", "handages"], "folder": ["connection", "region", "volume", "layout", "division", "two", "archive", "email", "database", "slice", "command", "device", "layer", "theme", "letter", "plugin", "sample", "future", "picture", "zip", "fold", "address", "zone", "source", "editor", "project", "path", "filename", "url", "level", "enter", "document", "uri", "Folder", "flat", "menu", "scope", "id", "upload", "resource", "dir", "append", "home", "directory", "location", "network", "area", "ignore", "element", "license"], "server": ["localhost", "reader", "connection", "version", "manager", "scale", "socket", "master", "email", "database", "remote", "type", "seed", "status", "erver", "ssl", "page", "Server", "inner", "node", "engine", "account", "client", "address", "service", "source", "port", "value", "outer", "filename", "system", "url", "enter", "uri", "ser", "resource", "token", "host", "directory", "location", "network", "slave", "string", "device", "peer", "username", "site"], "login": ["connection", "lock", "profile", "layout", "name", "machine", "socket", "basic", "email", "database", "pin", "info", "label", "status", "log", "plugin", "blank", "sudo", "blog", "picture", "ssl", "mail", "bridge", "shell", "account", "journal", "secret", "service", "cookie", "path", "filename", "url", "config", "group", "pass", "consumer", "Login", "users", "resource", "skin", "auth", "network", "access", "string", "username", "site"], "password": ["connection", "volume", "profile", "division", "name", "manager", "basic", "email", "database", "photo", "worker", "language", "timeout", "sudo", "plugin", "picture", "Password", "mask", "alias", "account", "column", "secret", "padding", " passwords", "sword", "cookie", "phrase", "PASS", "filename", "pattern", "ass", "pass", "word", "token", "security", "directory", "auth", "slave", "access", "string", "device", "strip", "username"], "fileTransferFolder": ["fileTransferTheme", "FileUploadfolder", "FileUploadFolder", "fileTransformFolder", "mediaTransferServer", "fileUploadfolder", "fileTransformfolder", "FileTransferPath", "fileUploadFolder", "fileAccessfolder", "FileUploadPath", "fileTransformTheme", "fileTransformPath", "fileTransferDirectory", "FileTransferfolder", "fileUploadTheme", "fileImportDirectory", "fileImportFolder", "mediaUploadFolder", "fileAccessFolder", "FileUploadTheme", "fileImportfolder", "fileUploadServer", "fileTransferServer", "fileTransferPath", "mediaUploadfolder", "fileAccessTheme", "mediaUploadDirectory", "FileTransferFolder", "mediaUploadServer", "mediaTransferfolder", "fileTransferfolder", "FileTransferTheme", "fileUploadDirectory", "mediaTransferDirectory", "mediaTransferFolder", "fileUploadPath", "fileAccessPath", "fileImportServer"], "liveFolder": ["LiveFolder", " liveDirectory", " livefolder", "PreviewFolder", "PreviewDirectory", " liveLocation", "Previewfolder", "livefolder", "LiveLocation", "PreviewLocation", "liveLocation", "LiveDirectory", "liveDirectory", "Livefolder"], "servers": ["SerServer", "servServer", "servations", " serations", " serServer", "Serations", " serls", "serServer", "Servers", "serls", "servvers", "serations", "servls", "Serls"], "message": ["msg", "manager", "error", "email", "Message", "body", "array", "application", "status", "log", "summary", "description", "page", "mail", "mess", "content", "member", "address", " messages", "buffer", "image", "request", "response", "path", "url", "update", "document", "details", "menu", "module", "flash", "resource", "header", "string", "element"]}}
{"id1": "15241397", "id2": "8079516", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["doGET", "handleget", " doPut", " doget", "doget", "handlePut", "didPut", "doPut", "didget", "handleGET", "handleGet", "didGet", "didGET", " doGET"], "request": ["connection", "reader", "er", "data", "complete", "QUEST", "method", "type", "info", "application", "web", "event", "received", "xml", "req", "user", "instance", "query", "client", "subject", "buffer", "image", "object", "Request", "url", "context", "document", "uri", "server", "http", "message", "input", "result", "resource", "queue", "initial", "report"], "response": ["full", "connection", "data", "version", "error", "pool", "session", "respond", "body", "results", "application", "Response", "status", "model", "page", "output", "writer", "collection", "client", "reply", "image", "parent", "object", "next", "other", "esi", "document", "view", "server", "wave", "function", "message", "resource", "result", "out", "queue", "host", "report", "onse", "generation", "json", "resp", "site"], "rewrittenQueryString": ["rewwrittenQueryList", "rewrittenUrlService", "rewrittenqueryString", "rewrittenQueryText", "rewwrittenRequestString", "rewrittenQueryList", "rewrittenRequestService", "rewwrittenQueryLine", "rewrittenPageList", "rewrittenqueryStr", "rewrittenQueryArray", "rewwrittenQueryArray", "rewrittenQuestionList", "rewrittenPageLine", "rewrittenUrlString", "rewwrittenRequestArray", "rewwrittenRequestLine", "rewrittenqueryService", "rewwrittenQueryStr", "rewrittenRequestText", "rewrittenQueryService", "rewrittenUrlText", "rewrittenQuestionArray", "rewwrittenRequestStr", "rewrittenqueryLine", "rewrittenPageArray", "rewrittenQuestionText", "rewwrittenQueryString", "rewwrittenRequestService", "rewrittenRequestStr", "rewrittenQueryLine", "rewwrittenQueryText", "rewrittenQuestionStr", "rewrittenRequestString", "rewwrittenRequestText", "rewwrittenQueryService", "rewrittenRequestLine", "rewrittenQuestionString", "rewrittenUrlLine", "rewrittenQuestionLine", "rewrittenRequestList", "rewrittenqueryText", "rewwrittenRequestList", "rewrittenRequestArray", "rewrittenQueryStr", "rewrittenPageString"], "rewrittenUrl": ["RewwrittenUrl", "rewilledUrl", "rewriteUrl", "rewardedLanguage", "rewardedInt", "rewwrittenInt", "rewmatchedUrl", "rerittenLanguage", "rewrapedUrl", "rewmatchedURL", "rewrittenInt", "rewardedUrl", "rewrittenLanguage", "rewardedJar", "rewardedUr", "RewrittenFile", "RewrittenUr", "rewilledURL", "rewatchedServer", "RewwrittenLocation", "rewardedURL", "rewatchedURL", "RewrittenServer", "rewrittenText", "rewwrittenServer", "rewcraftedUrl", "rewrapedUr", "rewwrittenJar", "rewrittenurl", "rewwrittenLanguage", "rewedurl", "rewcraftedUr", "rewwrittenLocation", "rewwrittenText", "Rewwrittenurl", "rewrapedFile", "rewriteText", "rewrittenURL", "rewodedUrl", "RewwrittenInt", "rewwrittenUr", "rewrittenServer", "rewrapedURL", "rewrittenJar", "RewrittenURL", "RewrittenLocation", "RewwrittenText", "rewodedFile", "rewriteServer", "rewmatchedFile", "rerittenUrl", "RewrittenInt", "rerittenURL", "rewatchedUrl", "rewwrittenUrl", "rewedURL", "rewmatchedurl", "RewrittenUrl", "rewrittenUr", "rewrittenLocation", "rewwrittenFile", "rewedUrl", "rewriteURL", "rewcraftedURL", "RewwrittenURL", "RewwrittenUr", "rewcraftedLocation", "rewilledJar", "RewrittenText", "rerittenFile", "RewwrittenFile", "rewatchedText", "rewodedLanguage", "rewardedLocation", "RewrittenJar", "rewedFile", "RewwrittenServer", "rewardedFile", "rewrittenFile", "rerittenUr", "rewilledInt", "rewodedURL", "rewwrittenURL", "rewedUr", "RewwrittenJar", "rewwrittenurl", "Rewrittenurl"], "httpURLConnection": ["httpCLConnection", "httpURIConnect", "apacheURLFlow", "httpURLCode", "httpURLService", "webSSLClient", "httpurlCurrent", "httpurlConnection", "httpURLConn", "httpURConn", "apacheURLConnect", "httpStreamconnection", "httpSSLConnection", "httpURIClient", "HttpChannelconnection", "httpUrlconnection", " httpURConn", " httpUrlConnection", "httpUrlConnection", "httpStreamSession", " httpURLconnection", "httpStreamConnection", " httpURConnect", "httpurlFlow", "httpUrlContext", "httpChannelService", "HttpURLConnection", "httpURLContext", " httpUrlConn", "httpCLConn", " httpStreamCurrent", "webSSLConnection", "httpURIconnection", "HttpURLconnection", "httpPathCurrent", "webURLContext", "webSSLContext", "httpurlconnection", "httpUrlConn", "httpURLCurrent", "apacheGEConnect", "httpURConnect", " httpStreamSession", "httpWebConnect", "httpSSLContext", "httpPathConnection", "httpPathconnection", "httpurlSession", "HttpChannelConnect", "httpGEconnection", " httpURLSession", "httpURIFlow", "httpURIContext", "httpURLClient", "httpurlConn", " httpURLConn", "httpUrlService", "httpStreamCurrent", "httpURConnection", "httpUrlConnect", "apacheGEConnection", "HttpURLConnect", " httpStreamConnection", " httpURConnection", "httpGEConnection", "httpURIConnection", "httpURLconnection", "httpurlConnect", " httpURLCurrent", "httpChannelconnection", "httpELConn", " httpURLConnect", "httpChannelConnection", "httpWebConn", "webURLClient", "apacheGEFlow", "httpSSLConn", " httpStreamconnection", "apacheURLconnection", "HttpURLService", "httpSSLClient", "httpELConnection", "HttpChannelConnection", "httpGEFlow", "webURLConnection", "webURLConn", "httpChannelConnect", "httpGEConnect", "httpUrlCode", "HttpChannelService", "httpWebConnection", "httpURconnection", " httpURLCode", "httpURService", " httpUrlCode", "httpUrlClient", "httpPathSession", "apacheGEconnection", "httpURLFlow", "httpCLCode", "webSSLConn", "apacheURLConnection", "httpurlCode", "httpURIConn", "httpURLConnect", "httpELConnect", "httpURLSession"], "header": ["feature", "iter", "er", "director", "data", "version", "channel", "master", "error", "handler", "head", "reference", "filter", "layer", "pair", "info", "after", "field", "event", "definition", "rule", "match", "component", "part", "bridge", "section", "her", "writer", "line", "member", "key", "ter", "dr", "column", "back", "buffer", "list", "entry", "player", "comment", "block", "driver", "outer", "hash", "second", "character", "Header", "next", "default", "attribute", "document", "group", "server", "date", "consumer", "author", "metadata", "function", "index", "message", "item", "token", "headers", "queue", "result", "cover", "string"], "value": ["office", "values", "data", "current", "name", "version", "now", "get", "type", "language", "V", "info", "field", "variable", "option", "label", "letter", "expression", "set", "format", "description", "model", "text", "content", "sv", "val", "VALUE", "key", "password", "comment", "entry", "child", "parent", "object", "v", "property", "attribute", "default", "document", "hello", "server", "function", "valid", "message", "item", "gi", "Value", "json", "string", "media", "end", "element"], "inputStream": ["pullStreamer", "inputSteam", "resourceSteam", "InputChannel", "InputStream", "InputStreamer", "outputStreamer", "pullstream", "inputStreamer", "resourceChannel", "pullStream", "pullSteam", "resourcestream", "resourceStream", "inputChannel", "Inputstream", "outputChannel", "outputSteam", "InputSteam", "inputstream", "outputstream"], "outputStream": ["inputSteam", " outputChannel", "OutputSteam", "outputFile", "OutputChannel", " outputFile", "OutputStream", "outputStreamer", "externalstream", "Outputstream", "inputStreamer", "externalSteam", "externalStreamer", "responseStream", "responseSteam", " outputSteam", "responseFile", "outputChannel", "outputSteam", "responseChannel", "externalStream", "inputstream", "OutputFile", "outputstream", "OutputStreamer"]}}
{"id1": "947406", "id2": "18693224", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["get", "it", "put", "sync", "p", "download", "dump", "Cop", "log", "csv", "clip", "zip", "cop", "paste", "cmp", "cat", "Copy", "transfer", "split", "file", "clone", "replace", "cp", " cp", "write", " transfer", " Copy"], "src": ["cur", "sl", "sin", "loc", "data", "name", "gb", "s", "sc", "ins", "stream", "inst", "bh", "rc", "ource", "rob", "files", "txt", "img", "href", "rs", "fn", "dist", "rb", "sq", "source", "sub", "stab", "js", "filename", "url", "config", "uri", "sit", "id", "sel", "resource", "input", "sb", "string", "use"], "dest": ["prop", "const", "bin", "sup", "opt", "name", "later", "wd", "st", "destroy", "comb", "class", "orig", "die", "output", "txt", "img", "done", "dist", "temp", "test", "d", "source", " Dest", "delete", "thin", "flat", "wb", "folder", "des", "Dest", "result", "target", "dir", "dat", "replace", "home", "de", "desc", "obj", "tmp", "rest"], "in": ["reader", "bin", "lock", "isin", "login", "data", "issue", "it", "socket", "s", "ins", "pin", "m", "cin", "info", "download", "In", "vin", "base", "is", "kin", "conn", "b", "inner", "again", "rin", "win", "r", "din", "trans", "IN", "err", "work", "pull", "ini", "this", "i", "source", "init", "lib", "inc", "nin", "cf", "url", "pass", "thin", "inn", "as", "up", "id", "a", "lin", "input", "con", "diff", "gin"], "out": ["x", "bin", "app", "ext", "data", "socket", "at", "pool", "sync", "ex", "one", "outs", "timeout", "os", "plain", "log", "conn", "cache", "again", "output", "w", "part", "vert", "img", "user", "writer", "inner", "err", "o", "off", "OUT", "client", "this", "call", "lib", "source", "image", "init", "inc", "nin", "or", "exec", "outer", "exit", "no", "our", "io", "net", "up", "file", "index", "id", "aos", "ou", "exp", "Out", "write", "obj"], "buf": ["bin", "cur", "cb", "bd", "f", "data", "seq", "loc", "ff", "fl", "batch", "cap", "buff", "p", "bn", "fab", "bh", "rc", "feat", "orig", "b", "br", "box", "num", "bytes", "bp", "bag", "off", "rb", "buffer", "count", "block", "ctx", "uc", "v", "raw", "cv", "ab", "c", "nb", "pos", "len", "fd", "uf", "queue", "bf", "result", "pad", "ref", "fb", "bc"], "n": ["x", "nt", "nn", "f", "rn", "nc", "un", "sn", "m", "na", "p", "dn", "ns", "j", "k", "en", "ind", "u", "b", "w", "size", "num", "l", "max", "o", "d", "i", "count", "ne", "z", "t", "nin", "v", "no", "number", "nr", "N", "ng", "c", "index", "len", "nd", "length", "write", "nb"]}}
{"id1": "8000624", "id2": "12236729", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"CopyTo": [" copyFrom", " transferFile", " copyTo", "copyTo", " copyto", "copyFile", "copyFrom", "CopyFile", " transferTo", "Copyto", "copyto", " transferto", " transferFrom", " copyFile", "CopyFrom"], "dest": ["bin", "data", "sup", "name", "opt", "later", " destination", "table", "them", "cont", "destroy", "comb", "class", "orig", "die", "desc", "w", "output", "txt", "content", "img", "done", "dist", "temp", "test", "source", "path", "filename", "object", " Dest", "delete", "exit", "flat", "file", "wb", "folder", "transform", "src", "Dest", "target", "write", "obj", "tmp", "rest"], "in": ["x", "reader", "bin", "connection", "isin", "sin", "f", "login", "issue", "s", "ins", "pin", "m", "cin", "In", "vin", "inside", "kin", "conn", "b", "inner", "again", "rin", "win", "r", "l", "din", "IN", "ax", "plus", "pull", "ini", "i", "source", "image", "init", "inc", "lib", "nin", "h", "n", "pass", "thin", "inn", "as", "up", "fa", "id", "wave", "lin", "input", "con", "ln", "re", "ac", "gin"], "out": ["x", "bin", "app", "ext", "outside", "data", "name", "socket", "pin", "sync", "ex", "outs", "not", "timeout", "one", "copy", "conn", "w", "b", "output", "cache", "again", "inner", "part", "vert", "user", "writer", "err", "plus", "o", "off", "OUT", "temp", "this", "client", "call", "i", "lib", "external", "image", "inc", "nin", "or", "outer", "exec", "object", "other", "url", "no", "our", "n", "io", "net", "up", "file", "target", "ou", "Out"], "c": ["x", "abc", "cb", "arc", "f", "char", "sc", "m", "ca", "ct", "C", "p", "enc", "ec", "pc", "rc", "lc", "u", "content", "cr", "l", "r", "e", "o", "exc", "esc", "dc", "d", "i", "pointer", "ci", "cc", "comment", "buffer", "ch", "t", "uc", "cf", "xc", "v", "cl", "config", "code", "n", "oc", "cu", "ce", "ic", "cm", "ac", "col", "fc", "bc", "cy"]}}
{"id1": "17856064", "id2": "3806532", "code1": "    public static PersistencyParameters parse(String unitName) {\n        URL[] persistenceUnits;\n        try {\n            persistenceUnits = Classpath.search(\"META-INF/\", \"persistence.xml\");\n        } catch (IOException e) {\n            throw new Error(e);\n        }\n        Set classes = new HashSet();\n        for (int i = 0; i < persistenceUnits.length; i++) {\n            URL url = persistenceUnits[i];\n            try {\n                nu.xom.Builder b = new nu.xom.Builder(false);\n                Document d = b.build(url.openStream());\n                Nodes unitNodes = d.getRootElement().query(\"//p:persistence-unit\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                for (int j = 0; j < unitNodes.size(); j++) {\n                    Node unitNode = unitNodes.get(j);\n                    Element unitElt = ((Element) unitNode);\n                    String uName = unitElt.getAttributeValue(\"name\");\n                    if (!uName.equals(unitName)) continue;\n                    {\n                        PersistencyParameters parameters = new PersistencyParameters();\n                        Nodes classNodes = unitElt.query(\"//p:property\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                        for (int k = 0; k < classNodes.size(); k++) {\n                            Node classNode = classNodes.get(k);\n                            if (!(classNode instanceof Element)) continue;\n                            Element classElt = (Element) classNode;\n                            String elementName = classElt.getAttribute(\"name\").getValue();\n                            if (elementName.equals(\"eclipselink.jdbc.url\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setJdbcUrl(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.user\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBUserName(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.password\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBPassword(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.driver\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBDriverClassName(elementValue);\n                            }\n                        }\n                        return parameters;\n                    }\n                }\n            } catch (Exception x) {\n                x.printStackTrace();\n                throw new Error(x);\n            }\n        }\n        return null;\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"parse": [" check", " constructor", " process", " discover", " inspect", " start", " analyze", " compile", " parsed", " scan", " execute", " test", " install", " parsing", " pars", " validate", " ls", " params", " parser", " extract", " assemble", " load", " read", " analyse", " resolve", " structure"], "unitName": ["unitname", "uiValue", "unitsname", "unit1", "unitsName", " unit1", "uiType", "UnitName", "machinePath", "uiName", "unitPath", " unitValue", "UnitNames", "unitValue", " unitNames", " unitPath", " unitname", "Unit1", "unitType", "unitsNames", " unitType", "machineValue", "Unitname", "machineType", "uiPath", "machineName", "units1", "unitNames"], "persistenceUnits": ["persistenceunites", "persistenceUITS", "persistanceUnitodes", "persistenceUnites", "persistanceUnunits", "persistanceUnitit", "persistenceUnitunits", "persistanceUnitITS", "persistenceUNitions", "persistenceOperits", "persistenceUnitit", "persistenceOperit", "persistenceUits", "persistenceUnitITS", "persistenceUNits", "persistenceLogits", "persistenceUnunits", "persistenceUNit", "persistanceUnitites", "persistenceUnitits", "persistanceUnists", "persistenceOperodes", "persistenceUnit", "persistenceUnodes", "persistanceUnits", "persistanceUnitits", "persistenceUnitodes", "persistenceUnititions", "persistanceUnITS", "persistanceClites", "persistenceClites", "persistenceClITS", "persistenceLogists", "persistenceLogunits", "persistenceUNites", "persistanceUnites", "persistanceUnitions", "persistanceUnitists", "persistanceUnodes", "persistenceOperites", "persistenceUnITS", "persistenceUNITS", "persistenceununits", "persistenceLogites", "persistenceClitions", "persistenceClits", "persistanceClitions", "persistanceUnit", "persistenceUites", "persistenceUnitions", "persistenceUnists", "persistenceunits", "persistanceClits", "persistenceUNodes", "persistenceUnitists", "persistenceunists", "persistenceUnitites", "persistanceClITS", "persistenceUit", "persistanceUnitunits"], "classes": [" constants", " sources", " Classes", "groups", "services", "results", " interfaces", " suites", "set", "class", "Class", " groups", " assignments", " class", " models", " packages", "names", "ps", " protocols", "params", " instances", "es", "result", "properties", " formulas", "resources", " configurations", " tests"], "i": ["x", "ji", "f", "y", "si", "ti", "ri", "p", "ori", "pi", "info", "ie", "ix", "hi", "I", "bi", "u", "di", "multi", "qi", "l", "fi", "ini", "ci", "z", "xi", "v", "mi", "ui", "oi", "yi", "li", "n", "uri", "ii", "in", "ni", "id", "index", "iu", "eni", "ai", "gi", "phi", "ip"], "url": ["connection", "sl", "f", "data", "name", "ur", "web", "xml", "base", "ssl", "plugin", "ls", "user", "href", "l", "address", "Url", "service", "URL", "source", "entry", "image", "api", "path", "filename", "config", "uri", "server", "route", "io", "http", "up", "file", "in", "resource", "link", "location", "string", "element", "username"], "b": ["be", "bd", "cb", "f", "gb", "bs", "m", "p", "bt", "verb", "eb", "bh", "base", "library", "bb", "B", "br", "l", "r", "e", "o", "bc", "rb", "lib", "build", "db", "builder", "hub", "Builder", "v", "bis", "n", "ab", "c", "wb", "a", "sb", "obj", "fb", "pb", "ob"], "d": ["df", "did", "director", "f", "data", "ds", "dl", "s", "g", "D", "m", " D", "dd", "p", "xml", "di", "u", "l", "r", "dom", "dm", "e", "dot", "md", "dc", "db", "t", "n", "c", "id", "fd", "dat", "dir", "pd", "dt", "dos"], "unitNodes": ["unitNideos", "unitSnodes", "unitnurs", " unitnideos", "unitnideos", "unitRenodes", "unitNoms", " unitNoded", "unitnoms", "unitNobs", "unitNubes", "unitSnode", "unitNoded", " unitnurs", "unitDideos", "unitNeoms", "unitnubes", " unitnodes", " unitnode", " unitnoms", "unitNurs", "unitDodes", "unitSnoded", " unitNobs", "unitNeode", "unitSnoms", "unitDurs", " unitNideos", "unitRenubes", "unitRenobs", "unitRenoms", " unitNubes", "unitNeoded", "unitnodes", " unitnoded", "unitNeodes", " unitNoms", "unitnobs", " unitNurs", "unitnode", "unitnoded"], "j": ["job", "ji", "ij", "jit", "y", "f", "jj", "bj", "it", "q", "note", "g", "p", "kj", "syn", "ie", "jen", "jp", "br", "u", "jet", "section", "qi", "aj", "l", "je", "ja", "fr", "key", "jc", "z", "ch", "js", "J", "h", "v", "n", "uj", "ii", "jo", "ni", "jl", "dj", "json", "obj"], "unitNode": ["tunElement", "UnitElement", "unitsnode", "tunNode", "UnitN", "connectionElement", "unitsName", " unitElement", "connectionPath", "unitPath", "unitsElement", "connectionNode", " unitPath", " unitnode", "connectionN", "unitsNode", "unitElement", "UnitNode", "unitN", "tunName", " unitN", "UnitPath", "tunnode", "unitnode"], "unitElt": ["elementElet", "unitExt", "unitUxt", "unitNld", " unitExt", "unitGeLT", "unitEselt", "unitNLT", "unitelem", "unitEler", " unitUlem", "unitGelt", "unitIlt", "elementElt", "elementEslt", " unitEelt", "elementEsld", "unitext", " unitEler", "unitOlt", "unitEslt", " unitELT", "unitOld", "uniteelt", "uniteld", "unitELT", "unitelet", "unitNlt", "uniteler", "unitEsld", "unitOlet", "unitOelt", "unitUlem", "elementEelt", "elementEselt", " unitOld", "unitGeelt", " unitOLT", "unitOLT", "unitElet", "unitGeld", "unitIlem", "unitEld", "unitIxt", " unitOlt", " unitEld", " unitOelt", "elementEld", "unitEslet", "unitNelt", "unitIler", "unitelt", " unitUlt", " unitUler", " unitUxt", "unitEelt", "elementEslet", "unitUler", "unitUlt", "unitElem", " unitElem"], "uName": ["suValue", "unitname", "duNames", "duName", "uname", " uname", "uValue", " uNode", " uNames", "unitPath", "unitValue", "suName", "uPath", "duValue", "suname", "uNames", " uValue", "uNode", "suPath", "duNode", "unitNames", " uPath"], "parameters": ["aramParameters", "paramseter", "parumers", "paramseters", "arameter", "paramParameters", "peters", "paramams", "paramsParameters", "pels", "perseters", "aramels", "promParameters", "pumers", "paramumers", "promels", "persels", "paramels", "paramsels", "pareters", "persumers", "prometers", "pams", "parels", "arameters", "params", "prometer", "persams", "parameter"], "classNodes": ["classSnodes", "classEode", "classClements", "classSnlements", " classNlements", "classNinode", "fieldNinode", "fieldNinobs", "fieldNODE", "Classnodes", "classNlements", "classSode", "classNODE", "classSnode", "Classnode", "fieldNodes", "classnanks", "fieldNobs", "classNelements", "classCodes", "ClassNode", "classSODE", "classEanks", "ClassNodes", "classVODE", "classNinODE", "classSodes", "classSnoded", "fieldNinODE", "classnodes", "classNanks", "classNeodes", "classnode", "classNinobs", "classnoded", "ClassNoded", "classVobs", "classNoded", "Classnoded", "Classnanks", " classNoded", "classNobs", " classCode", "classSobs", "ClassNanks", "classCode", "classNeoded", "classVodes", " classCodes", " classCoded", " classClements", "classCoded", "fieldNode", "classEoded", "classNinodes", "fieldNinodes", "classNeode", "classEodes", "classVode"], "k": ["f", "y", "unk", "kw", "q", "g", "sk", "kr", "p", "kn", "ck", "kat", "ko", "w", "ok", "r", "ky", "work", "key", "dk", "ke", "kid", "K", "z", "ch", "ki", "ik", "kick", "h", "ek", "ku", "v", "n", "c", "id", "kk", "ad", "km", "ks"], "classNode": ["classFile", "classTree", "classElement", "configElement", " classFile", "baseTree", "fileRoot", " classnode", "classSource", "busnode", "classNs", " classSource", "configNode", "elementSource", "Classnode", " className", "fileNode", "ClassNode", "elementTree", "fileTree", "fileElement", "ClassNs", "classnode", "className", "configName", "busNs", "busNode", "baseElement", "ClassFile", "elementNode", "configSource", "baseRoot", "elementRoot", "elementElement", " classElement", "classRoot", " classNs", "busFile", "baseNode"], "classElt": ["Classeelt", "classUxt", "classEelt", "classeLT", "classXlt", "ClassXld", "classUelt", "classext", "ClassXelt", "ClassExt", "classXler", "elementElt", "classOlt", "classYxt", "classYlem", "Classelem", "ClassEld", "ClassOler", "Classelt", "ClassElem", "classeelt", "elementeelt", "classYlt", "elementext", "classEler", "classEld", "ClassXlt", "classUlt", "classeld", "classelem", "ClassOlt", "classXxt", "classExt", "ClassElt", "classXld", "classOler", "elementExt", "classELT", "classYelt", "classOxt", "ClassEler", "ClassXLT", "ClassOld", "ClassOxt", "ClassEelt", "elementEld", "Classeld", "classOld", "classelt", "ClassELT", "classXLT", "classYler", "elementeld", "elementelt", "classElem", "classUld", "classXelt", "classUlem", "classYld", "elementEelt"], "elementName": ["articleName", "elementAnn", "typeName", "layerApp", "elementFamily", "articleFamily", "moduleValue", "modulename", " elementPath", "elementname", "classPath", "classValue", " elementFamily", " elementFace", "modulePath", "className", "moduleName", "articleApp", "sectionFace", "elementFace", "sectionName", "typeApp", "stringFamily", "elementApp", "typeAnn", "articleAnn", "stringFace", "stringName", "typeFamily", " elementname", "layerFamily", "sectionFamily", "elementPath", "layerAnn", "classname", "layerName"], "elementValue": ["objectvalue", "objectValue", "entryVal", " elementText", "elementString", "entryVALUE", "memberText", "Elementvalue", "objectString", "elementVal", "optionVal", "ElementText", "ElementValue", "styleText", "entryValue", "ElementVal", "optionString", "memberValue", "optionValue", "ElementString", "objectVal", "entryvalue", "ElementVALUE", " elementVal", "memberVal", "elementText", "stylevalue", "entryText", "styleVALUE", "elementVALUE", "optionvalue", "elementvalue", "memberVALUE", " elementVALUE", "styleValue"]}}
{"id1": "19944975", "id2": "7396682", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["WriteReport", " writeConfig", "saveSection", "saveConfiguration", "WriteConfig", "saveReport", " writeSection", "WriteConfiguration", "writeSection", "WriteSection", "writeConfig", "saveConfig", " writeReport", "writeReport"], "out": ["reader", "connection", "ext", "name", "at", "pool", "inas", "m", "sync", "ex", "outs", "xml", "dump", "plain", "base", "conn", "w", "again", "output", "user", "inner", "writer", "line", "IN", "err", "password", "key", "flush", "client", "OUT", "o", "temp", "external", "list", "lib", "this", "init", "project", "path", "parent", "filename", "object", "exec", "config", "server", "io", "c", "file", "scope", "prefix", "resource", "res", "window", "report", "exp", "Out", "string", "write", "obj"], "url": ["connection", "open", "sl", "f", "data", "org", "channel", "stream", "web", "xml", "base", "ll", "ssl", "page", "conn", "b", "l", "r", "address", "Url", "service", "URL", "source", "image", "feed", "api", "path", "object", "config", "server", "uri", "io", "http", "file", "resource", "location", "rel", "string", "ob"], "in": ["reader", "bin", "isin", "login", "f", "data", "socket", "inas", "s", "ins", "pin", "stream", "cin", "cms", "min", "In", "xml", "is", "inside", "copy", "ssl", "kin", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "inc", "nin", "n", "inn", "c", "as", "file", "id", "a", "lin", "resource", "input", "ac", "gin", "serv"]}}
{"id1": "7757297", "id2": "9647576", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"submit": ["save", "open", "login", "Submit", "complete", "type", " submission", "send", "download", "register", "success", "sub", "run", "init", "request", "process", "form", "close", "update", "post", "input", "report", "execute", "accept", "write", "start", "apply"], "uri": ["URI", "data", "absolute", "ri", "iri", "database", "xml", "base", "plugin", "format", "description", "text", " ur", "href", "address", "Url", "i", "URL", "cli", "source", "api", "path", "response", "filename", "ui", " Uri", "server", "route", "io", "http", "duration", "file", "id", "message", "resource", "location", "report", "directory", "string", " URI", "username"], "Exception": ["Ex", "ception", "End", "Response", "Exc", "Adapter", "Problem", "Application", "A", "Transaction", "Document", "Error", " exception", "Event", "Null", "Request", "Description", "ceptions", "Except", "Interface", "Timeout", "except", "Exit", "Connection", "Record"], "encodedrdf": ["encodedwde", "encodingrdf", "encodedrrrf", "encodedrrf", "encodedvrrf", "encodedrdbf", "encodedvrbf", "encoderdef", "encodedwdF", "encodedrtbf", "encodeudf", "encodedrre", "encodingwdf", "encodeudef", "encoderde", "encodedudf", "encodeude", "encodingwdbf", "encodeudrf", "encodedudef", "encodedrdF", "encodedwdbf", "encodedudrf", "encodedrref", "encodingrdF", "encodingrdrf", "encoderdrf", "encodedwdrf", "encodedvrF", "encodedwdf", "encodedrdrf", "encodedwdef", "encodingwdF", "encodingwdrf", "encodedrtf", "encodedrtF", "encodedude", "encodedvrf", "encodedrde", "encoderdf", "encodingrdbf", "encodedrdef", "encodedrtrf"], "url": ["job", "open", "loc", "name", "channel", "socket", "session", "database", "base", "ssl", "position", "control", "page", "conn", "user", "text", "l", "client", "address", "Url", "proxy", "URL", "service", "source", "image", "connect", "path", "config", "relation", "server", "http", "file", "contact", "resource", "link", "location", "Connection", "string", "use"], "connection": ["open", "loc", "version", "org", "channel", "socket", "session", "database", "handler", "application", "communication", "position", "conn", "b", "text", "section", " Connection", "l", "writer", "password", "client", "service", "connected", "URL", "condition", "source", "proxy", "connect", "or", "driver", "response", "character", "context", "config", "document", "n", "relation", "number", "server", "io", "http", "c", "in", "function", "contact", "con", "link", "directory", "Connection", "string", "use"], "lastUser": ["LastUser", " lastWord", "latestRow", "latestUser", "LastRow", "LastWord", "lastCategory", " lastCategory", "LastCategory", "latestCategory", "lastWord", " lastRow", "lastRow", "latestWord"], "out": ["lock", "office", "login", "data", "doc", "name", "at", "pool", "down", "outs", "w", "wrapper", "cmd", "err", "o", "flush", "off", "cli", "exec", "io", "exp", "socket", "error", "log", "page", "conn", "cache", "inner", "output", "key", "client", "call", "init", "builder", "outer", "up", "global", "word", "result", "dump", "plain", "copy", "commit", "part", "check", "writer", "line", "temp", "external", "image", "no", "prefix", "Out", "obj", "full", "bin", "extra", "sync", "req", "user", "again", "password", "OUT", "comment", "list", "view", "server", "in", "file", "window", "write", "editor"]}}
{"id1": "646016", "id2": "8953394", "code1": "    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorCliente.elimina()\");\n        int id = cli.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            sql = \"DELETE FROM persona WHERE id =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt.executeUpdate(sql);\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        }\n    }\n", "code2": "    private void update(String statement, SyrupConnection con, boolean do_log) throws Exception {\n        Statement s = null;\n        try {\n            s = con.createStatement();\n            s.executeUpdate(statement);\n            con.commit();\n        } catch (Throwable e) {\n            if (do_log) {\n                logger.log(Level.INFO, \"Update failed. Transaction is rolled back\", e);\n            }\n            con.rollback();\n        }\n    }\n", "label": 1, "substitutes": {"elimina": [" elimada", "elimalina", "elimerini", "elrimina", "elrimada", " elrimita", "elrimini", " elrimina", " elimita", " elrimini", "elimalita", "elimita", " elrimada", "elimerina", "elimerada", "elimada", "elimalada", "elimalini", " elimini", "elimerita", "elrimita", "elimini"], "cli": ["connection", "util", "dl", "ctl", "lo", "Client", "hi", "lc", "API", "cci", "di", "conn", "cmd", "l", "client", "lu", "oci", "i", "ci", "gui", "ctx", "api", "colo", "gd", "cfg", "xi", "ui", "GUI", "li", "server", "uri", "cu", "osi", "uci", "CL", "cgi", "c", "sci", "gi", "ctrl"], "id": ["x", "ids", "connection", "aid", "active", "login", "f", "name", "version", "start", "it", "q", "error", "email", "database", "type", "ident", "p", "info", "en", "patient", "status", "oid", "model", "mid", "num", "zip", "val", "vid", "key", "client", "address", "md", "kid", "d", "i", "entry", "style", "db", "value", "path", "h", "like", "pid", "url", "admin", "code", "server", "ID", "in", "index", "Id", "ql", "uid", "resource", "sid", "ip"], "sql": ["msg", "job", "base", "sl", "su", "statement", "data", "layout", "name", "sg", "util", "eps", "liquid", "dl", "type", "seed", "install", "sync", "str", "os", "sys", " SQL", "log", "status", "SQL", "ls", "ssl", "lc", "html", "ll", "sv", "cmd", "l", "query", "zip", "shell", "err", "lua", "sal", "sex", "lang", "cop", "sq", "comment", "i", "live", "db", "js", "url", "no", "general", "repl", "nl", "sol", "null", "details", "lv", "function", "script", "params", "ql", "result", "sb", "sf", "ln", "auth", "rl", "string", "generic", "il"], "stmt": ["estmt", "sttr", "putmt", "sthmt", " stmb", " stdr", " stmn", " stmm", "fMT", "stMT", "fmp", "estpt", "estnt", "estmb", "Stmt", " stnt", "estmd", " stdb", "estmm", "estdb", "Stmm", "stmp", "stmm", "instmt", "stmd", "fmt", "sthdr", "putmb", " stm", " stMT", " stpt", "shmn", " stmd", "stdr", "Stdb", " sttr", "stdb", "stsql", "shtr", "StMT", " stmp", " stsql", "shnt", "stmn", "estsql", "stm", "sthm", "estmn", "sthdd", "putsql", "putpt", "Stm", " stdd", "instm", "stpt", "fm", "stmb", "Stmp", "Stmd", "shmt", "stnt", "esttr", "instdr", "instdd", "stdd"]}}
{"id1": "11153282", "id2": "21232043", "code1": "    public static boolean existsURL(String urlStr) {\n        try {\n            URL url = ProxyURLFactory.createHttpUrl(urlStr);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.connect();\n            int responseCode = con.getResponseCode();\n            con.disconnect();\n            return !(responseCode == HttpURLConnection.HTTP_NOT_FOUND);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    @Override\n    public File call() throws IOException {\n        HttpURLConnection conn = null;\n        ReadableByteChannel fileDownloading = null;\n        FileChannel fileWriting = null;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            if (size == -1) {\n                size = conn.getContentLength();\n            }\n            fileDownloading = Channels.newChannel(conn.getInputStream());\n            fileWriting = new FileOutputStream(file).getChannel();\n            long left = size;\n            long chunkSize = BLOCK_SIZE;\n            for (long downloaded = 0; downloaded < size; left = size - downloaded) {\n                if (left < BLOCK_SIZE) {\n                    chunkSize = left;\n                }\n                fileWriting.transferFrom(fileDownloading, downloaded, chunkSize);\n                downloaded += chunkSize;\n                setProgress(downloaded);\n            }\n        } finally {\n            if (file != null) {\n                file.deleteOnExit();\n            }\n            if (conn != null) {\n                conn.disconnect();\n            }\n            if (fileDownloading != null) {\n                try {\n                    fileDownloading.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0441\u043a\u0430\u0447\u0438\u0432\u0430\u043d\u0438\u044f\", ioe);\n                }\n            }\n            if (fileWriting != null) {\n                try {\n                    fileWriting.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 \u0444\u0430\u0439\u043b\", ioe);\n                }\n            }\n        }\n        return file;\n    }\n", "label": 0, "substitutes": {"existsURL": ["exiesurl", "containsUrl", "exiesURL", "exainsURI", "containsURI", "containsURL", "existsurl", "exainsURL", "exitsurl", "contistsurl", "existsUrl", "contistsURL", "exitsUrl", "containsurl", "exitsURI", "exiesURI", "exitsURL", "existsURI", "exainsUrl", "exainsurl", "contistsURI", "contistsUrl", "exiesUrl"], "urlStr": ["uriStr", "urlUrl", "httpSTR", "urlSTR", "urlString", "uriString", "httpStr", " urlString", "uriSTR", "urlSt", "URLUrl", "resourceSt", "httpString", " urlUrl", "URLString", " urlSTR", "resourceString", "httpSt", " urlSt", "URLSt", "uriSt", "resourceUrl", "URLStr", "resourceStr"], "url": ["ul", "connection", "open", "sl", "f", "loc", "fl", "ur", "el", "secure", "web", "aur", "ll", "log", "base", "ssl", "bb", "ls", "conn", "b", "lc", "blog", "l", "e", "client", "Url", "proxy", "URL", "api", "config", "server", "http", "c", "file", "resource", "www", "host", "bel", "fc"], "con": ["x", "connection", "open", "ver", "cn", "fl", "un", "ca", " conn", "ct", "syn", "web", "bn", "en", "ec", "gen", "pc", "ann", "rc", "plain", "conn", "conf", "can", "Con", "ran", "client", "cc", "common", "run", "connect", "CON", "cf", "ocon", "exec", "xc", "bon", "close", "conv", "Conn", "c", "http", "fa", "co", "on", "ctrl", "cover", "cm", "ln", "Connection", "fc", "bc", "cons"], "responseCode": ["resourcecode", "responsecode", " responsecode", "statusStatus", "statusCount", "ResponseCode", "statusType", "ResponseStatus", "ResponseType", "statusCode", "responseStatus", "ResponseCount", "Responsecode", "respCount", "respStatus", "respCode", "responseCount", "responseType", "resourceCode", "respType", "resourceType", " responseType"]}}
{"id1": "942693", "id2": "16142024", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["conception", " deconvert", "Convert", "converting", "subvert", "unversion", " deconverting", "CONverting", "unvert", "CONvert", "unception", "Conversion", " deconverted", "unverted", "subverted", "Converted", "conversion", " deconversion", "CONverted", "subversion", "oconvert", "CONversion", "converted", "Conception", "Converting", "CONception", "subverting", "oconversion", "oconverted", "oconverting"], "src": ["reader", "username", "cb", "sin", "loc", "RC", "name", "sn", "gb", "s", "sc", "slice", "cpp", "stream", "st", "secure", "inst", "download", "sth", "load", "gz", "proc", "sys", "rc", "SourceFile", "ssl", "component", "ource", "prot", "req", "feat", "video", "img", "href", "fn", "dist", "back", "rb", "cmp", "source", "storage", "ctx", "path", "spec", "filename", "attr", "stage", "url", "config", "code", "uri", "sit", "file", "impl", "Dest", "upload", "sel", "scene", "sb", "input", "resource", "Source", "fp", "ref", "rl", "string", "obj", "buf", "tmp", "supp"], "dest": ["bin", " destination", "cont", " dst", "class", "orig", "di", "txt", "img", "fn", "dist", "temp", "std", "dc", "test", "lib", "source", "disk", "path", "null", "Dest", "target", "dir", "dat", "home", "obj", "tmp"], "in": ["reader", "bin", "inf", "isin", "login", "f", "data", "doc", "inas", "ins", "pin", "stream", "ex", "In", "is", "win", "r", "din", "val", "IN", "err", "ini", "d", "i", "source", "inc", "t", "n", "pass", "ps", "inn", "io", "as", "up", "file", "a", "input"], "p": ["f", "lp", "tp", "s", "g", "py", "m", "j", "pi", "wp", "pc", "per", "pr", "jp", "b", "part", "op", "l", "bp", "pre", "cop", "e", "r", "parser", "o", "pp", "d", "i", "sp", "t", "h", "v", "ps", "pe", "c", "P", "pm", "np", "pa", "po", "fp", "pd", "cp", "pg", "pb"], "ds": ["data", "dl", "dd", "services", "groups", "ys", "cs", "ls", "ld", "tools", "d", " props", "js", "ded", "xs", "uds", "ps", "ils", "ges", "tests", "pd", "ads", " sd", "df", "lp", "ups", "ins", "bs", "Ds", "os", "sys", "sts", "obs", "rs", "dds", "dm", "nas", "gd", "hs", "points", "ipes", "qs", "DS", "styles", "des", "ss", "ks", "dos", "cons", "ts", "vals", "eps", "els", "icks", "da", "ns", "parts", " ps", "dist", " DS", "posts", "dc", "scripts", "ths", "dates", "vs", "gs", "ays", "dat", "docs", "dt", "s", "sync", "utils", "ans", "di", "words", "models", "lines", "db", "dp", "ants", "amps", "plugins"], "format": ["tag", "data", "f", "layout", "sche", "scale", "name", "version", "at", "ant", "handler", "type", "table", "language", "filter", "letter", "feat", "class", "plugin", "model", "part", "magic", "fn", "parser", "atter", "style", "source", "template", "t", "api", "spec", "struct", "filename", "pattern", "path", "form", "url", "config", "unit", "Format", "file", "function", "act", "prefix", "fd", "frame", "record", "host", "fp", "string", "nat"], "hasPixelData": ["hasPicturedata", "hasPictureSize", "hasByteData", " hasPixeldata", "hasPixeldata", "showsPixelDATA", "hasPixelSize", "hasPixelStyle", "showsByteStyle", " hasPixelSize", "showsBytedata", "hasByteStyle", "showsPixeldata", "showsByteData", "hasPictureData", "hasByteSize", "showsByteDATA", "hasByteDATA", "showsPixelData", "haspixeldata", "hasBytedata", "hasPixelDATA", "haspixelSize", "haspixelData", "showsPixelStyle"], "inflate": ["insflATE", "invenATE", "inflode", "inffated", "inFlated", "InFlace", "Inflace", "invenate", "insflate", "inflated", "inadequating", "inFlace", "insflating", "infolating", "infolATE", "inadequATE", "invenode", "inadequode", "insflode", "inffation", "infloated", "insvenATE", "invenating", "inffate", "inFlate", "inadequate", "inflating", "InFlated", "infolode", "infface", "Inflated", "Inflate", "InFlation", "inflation", "Inflation", "infloace", "insvenating", "insvenode", "infolate", "InFlate", "inflATE", "inflace", "infloate", "insvenate", "infloation", "inFlation"], "pxlen": ["mxlen", "fxdata", "mxpos", "campos", "pclon", "axln", "ppl", "txlen", "fxLen", "pxdata", "pxsize", "pngcount", "xpsize", "pxpos", "txln", "xpcount", "ppLen", "txlin", "mxdata", "camdata", "camln", "mxln", "axlen", "pcln", "pnglength", "pglen", "pxden", "fxden", "txlon", "pgLen", "pxl", "pxlength", "pxlon", "axlon", "pclin", "camlen", "pgden", "pxln", "mxcount", "pngsize", "fxln", "pgl", "mxlength", "mxsize", "axlin", "pclen", "fxl", "pxcount", "fxpos", "pxLen", "fxlen", "xplen", "pnglen", "ppden", "pxlin", "xplength", "pplen"], "out": ["lock", "point", "error", "session", "state", "outs", "gen", "dump", "sys", "log", "copy", "page", "cache", "user", "again", "output", "conn", "line", "work", "query", "err", "OUT", "list", "lib", "cli", "step", "parent", "v", "store", "server", "group", "post", "io", "up", "co", "inter", "pad", "re", "Out", "obj"]}}
{"id1": "22418839", "id2": "6470716", "code1": "    public void handleHandshake(Packet2Handshake par1Packet2Handshake) {\n        boolean flag = true;\n        String s = par1Packet2Handshake.username;\n        if (s == null || s.trim().length() == 0) {\n            flag = false;\n        } else if (!s.equals(\"-\")) {\n            try {\n                Long.parseLong(s, 16);\n            } catch (NumberFormatException numberformatexception) {\n                flag = false;\n            }\n        }\n        if (!flag) {\n            netManager.networkShutdown(\"disconnect.genericReason\", new Object[] { \"The server responded with an invalid server key\" });\n        } else if (par1Packet2Handshake.username.equals(\"-\")) {\n            addToSendQueue(new Packet1Login(mc.session.username, 29));\n        } else {\n            try {\n                URL url = new URL((new StringBuilder()).append(\"http://session.minecraft.net/game/joinserver.jsp?user=\").append(mc.session.username).append(\"&sessionId=\").append(mc.session.sessionId).append(\"&serverId=\").append(par1Packet2Handshake.username).toString());\n                BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s1 = bufferedreader.readLine();\n                bufferedreader.close();\n                if (s1.equalsIgnoreCase(\"ok\")) {\n                    addToSendQueue(new Packet1Login(mc.session.username, 29));\n                } else {\n                    netManager.networkShutdown(\"disconnect.loginFailedInfo\", new Object[] { s1 });\n                }\n            } catch (Exception exception) {\n                exception.printStackTrace();\n                netManager.networkShutdown(\"disconnect.genericReason\", new Object[] { (new StringBuilder()).append(\"Internal client error: \").append(exception.toString()).toString() });\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "label": 0, "substitutes": {"handleHandshake": [" processhandled", " handleHeadled", " handleHandled", " handlehandled", " handleHandlerled", " handleHeadling", " processHandshake", " processHandled", " processhandling", " handlehandling", " handleHeadshake", " handleHandlerling", " handleHandling", " processHandling", " processhandshake", " handlehandshake", " handleHandlershake"], "par1Packet2Handshake": ["par1Packet2Hanshake", "par1Packet2MarshMessage", "par1Packet2Hanpair", "par1Packet2handle", "par1Packet2HostMessage", "par1Packet2Handle", "par1Packet2Hostling", "par1PacketTranslationhandshake", "par1PacketTranslationHandword", "par1Packet2Shpair", "par1Packet2Handla", "par1Packet2handword", "par1Packet2HanMessage", "par1Packet2Shle", "par1PacketTranslationhandword", "par1Packet2HandMessage", "par1Packet2handshake", "par1Packet2ChMessage", "par1Packet2Handpair", "par1Packet2Marshle", "par1Packet2Hanle", "par1Packet1HandMessage", "par1Packet1Handle", "par1Packet2Marshling", "par1Packet1Handpair", "par1Packet1Handshake", "par1Packet2Hostword", "par1Packet2Shshake", "par1Packet2Hostle", "par1PacketTranslationHandshake", "par1Packet2Marshshake", "par1Packet2Shla", "par1Packet1Handling", "par1Packet2Chle", "par1PacketTranslationHandling", "par1Packet2Chshake", "par1Packet2Chling", "par1Packet2Hanla", "par1Packet2Hostshake", "par1PacketTranslationhandle", "par1Packet2Handword", "par1Packet1Handla", "par1PacketTranslationHandle", "par1Packet2Handling", "par1Packet2handling", "par1Packet2Hanling", "par1PacketTranslationhandling"], "s": ["username", "sl", "su", "f", "data", "sg", "si", "ts", "ds", "session", "g", "services", "m", "sync", "p", "ns", "str", "os", "units", "ssl", "is", "ls", "words", "u", "w", "abs", "b", "sv", "r", "rs", "l", "e", "lines", "o", "strings", "service", "i", "S", "d", "hs", "ws", "submit", "spec", "h", "v", "sum", "gs", "comments", "n", "ps", "c", "a", "sb", "input", "sf", "es", "ss", "aws", "sym", "suff", "string", "fs", "ses", "site"], "flag": ["ag", "f", "tag", "util", "name", "force", "bool", "char", "type", "flags", "string", "field", "sort", "status", "log", " bit", "fun", "cloud", "mask", "year", "bug", "fortune", "val", "and", "win", "key", "zip", "Flag", "ret", "enable", "count", "cat", "ask", "age", "store", "code", "sign", "kind", "agg", "func", "file", "lag", "id", "FLAG", "wave", "valid", "af", "len", "fd", " flags", "debug", "fail", "leaf", "ad", "arg", "start", "bit", "wait"], "url": ["connection", "job", "sl", "f", "data", "name", "org", "channel", "stream", "web", "base", "ssl", "page", "blog", "user", "b", "r", "l", "address", "Url", "service", "URL", "source", "buffer", "image", "feed", "api", "hub", "path", "object", "server", "uri", "browser", "http", "file", "id", "www", "queue", "resource", "string"], "bufferedreader": ["buffaredreader", "buffledreader", "bufferingReader", " bufferedwriter", "buffaredReader", "bufferingparser", "buffendedwriter", "bufferedwriter", "bufferedparser", "buffledwriter", "buffereder", " buffendedReader", "bufferedReader", "buffledReader", "buffendedReader", "bufferingwriter", " buffererReader", "buffererparser", " buffendedwriter", " bufferedparser", "buffedreader", "Bufferedwriter", "bufferedhandler", "buffendedreader", "bufferinghandler", "Buffererwriter", "buffererreader", " buffendeder", " buffereder", "Bufferedhandler", "Buffererhandler", "buffedwriter", "buffererwriter", "buffedReader", "BufferedReader", "buffedhandler", "buffererhandler", " bufferedReader", "BuffererReader", "buffleder", " buffererreader", "buffaredwriter", "buffaredparser", " buffererwriter", " buffendedreader", "Bufferedreader", "buffendeder", "bufferingreader", "buffererReader", " buffererparser", "Buffererreader", "buffererer"], "s1": ["s3", "S0", "SOne", "s0", "mentsasso", "Sasso", "sOne", "ments2", "s4", "hsfirst", "qs1", "qsfirst", "p1", " s3", "S3", "ments3", "sfirst", "ments1", " s0", "hs4", "qs4", " s4", "hs1", "p0", "p2", "pOne", "sasso", "sFirst", " sfirst", " sasso", "S2", "S1", "qsFirst", " sOne", "hsFirst", "s2", " s2", " sFirst"]}}
{"id1": "6890417", "id2": "5989666", "code1": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "code2": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"a1": ["ga0", "A01", "A3", "a0", "a01", "an1", "an01", "ga01", " a01", " a0", "A1", "alpha1", "ga1", "A2", "alpha0", "ga2", "alpha2", "an3", "alpha01", "an2"], "a2": ["n4", "n8", "A8", "p1", "A4", "p5", "A1", "p2", "A2", "A5", "n2", "p4", "n5"], "a3": [" a23", "alpha9", "ga9", "la33", "an33", "ga3", "alpha3", "ga5", "alpha5", "la3", "an23", " a33", "ga2", "alpha2", "la23", "an3", "a23", "a33"], "a4": ["ga4", "pa4", "as2", "A4", "as4", "as5", "as9", "ma4", "A2", "pa10", "ga8", "A5", "A9", "ga10", "pa8", "ma10", "ma8"], "a5": ["A6", "a7", "n7", "A8", "A4", "alpha8", "a6", "alpha6", " a7", "p5", "alpha5", "p2", "alpha4", "A5", "n2", "p7", " a6", "n6", "p6", "n5"], "a8": ["b10", "A6", "b6", "b7", "a7", "A8", "A4", "alpha8", "a6", "alpha6", " a7", "b4", "b8", "alpha4", "b11", "A11", "an7", " a6", "an6", "an8", "alpha11", "an10"], "a9": ["alpha9", " a09", "a7", "A8", "p10", "alpha7", "alpha09", "alpha8", " a7", "p09", "A11", "alpha10", "p7", "A9", "p9", "alpha11", "a09", "A7"], "a10": ["an9", "b10", "alpha9", "as09", " a12", "as10", "A8", "A09", "alpha8", "b9", "as9", "A10", "a12", "b8", "alpha12", "b09", "alpha10", "as8", "an12", "A9", "an8", "a09", "an10"], "a11": [" a18", " a12", "A12", "am11", "alpha18", "a7", "A8", "alpha8", "am10", " a7", "am7", "A10", "a12", "a13", "alpha12", "A11", "am13", "A13", "a18", " a13", "A18", "alpha11", "A7"], "ps": ["pers", "ts", "hes", "eps", "ds", "s", "ups", "ins", "py", "ons", "ples", "als", "p", "ips", "ams", "PS", "pi", "ns", "settings", "os", "per", "gets", "cs", "is", "ls", "pr", "jp", "parts", "pps", "files", "pres", "Ps", "ops", "rs", "ppa", "posts", "lines", "pp", "alls", "pes", "ras", "proxy", "points", "ws", "qs", "ipes", "js", "vs", "gs", "cases", "pass", "pse", "pe", "details", "as", "ils", "params", "pos", "pa", "ports", "aps", "changes", "es", "tests", "ss", "properties", "res", "ms", "rules", "ks", "ases"], "url": ["connection", "sl", "f", "fl", "twitter", "gl", "web", "download", "ll", "ssl", "log", "ls", "base", "page", "control", "user", "cloud", "l", "bug", "client", "address", "Url", "proxy", "URL", "service", "buffer", "image", "build", "response", "object", "config", "document", "server", "uri", "browser", "http", "file", "www", "contact", "string"], "request": ["connection", "open", "session", "complete", "create", "method", "remote", "respond", "worker", "p", "info", "web", "per", "req", "user", "access", "r", "client", "pull", "temp", "reply", "this", "call", "external", "buffer", "child", "connect", "builder", "response", "next", "Request", "transfer", "hello", "server", "post", "pe", "http", "rate", "upload", "result", "resource", "report", "re", "push", "use", "rest"]}}
{"id1": "12197169", "id2": "13595251", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 0, "substitutes": {"read": ["reader", "open", "readable", "get", "Read", "create", "stream", "ready", "download", "load", "loop", "check", "work", "parse", "run", "continue", "init", "process", "request", "reading", "println", "replace", "print", "report", "write", "start", "end"], "in": ["reader", "bin", "connection", "isin", "er", "f", "data", "login", "doc", "scan", "it", "at", "error", "s", "ins", "from", "stream", "info", "ex", "cms", "min", "In", "log", "ssl", "is", "conn", "b", "again", "inner", "by", "l", "r", "IN", "e", "din", "err", "fr", "o", "ini", "buffer", "source", "image", "ing", "inc", "nin", "path", "of", "url", "server", "n", "io", "inn", "c", "file", "id", "index", "a", "on", "token", "input", "out", "con"], "line": ["reader", "le", "sl", "f", "data", "name", "el", "ge", "se", "str", "log", "status", "inline", "lc", "page", "b", "text", "l", "val", "cell", "e", "lines", "key", "L", "lf", "ine", "row", "source", "block", "comment", "ne", "entry", "value", "buffer", "Line", "parse", "object", "url", "code", "unit", "file", "id", "LINE", "message", "frame", "lin", "record", "link", "col", "string", "end"], "i": ["x", "f", "si", "ti", "ri", "slice", "p", "info", "j", "pi", "ori", "ie", "ix", "is", "I", "bi", "u", "b", "di", "qi", "l", "fi", "e", "o", "ini", "abi", "ci", "xi", "oi", "ui", "li", "n", "zi", "ii", "io", "ni", "index", "eni", "ai", "gi", "phi", "uni", "ip", "ski"], "logDatum": ["LogDatum", "logdata", "logDictionary", "logDsum", "Logdict", "logFata", "logDData", "Logdatum", "logdict", "exDictionary", "logFatum", "logDDam", "logDatatum", "logDatictionary", "logDatict", "exDDictionary", "logDDatum", "exDData", "logDDictionary", "exDDam", "LogData", "exDDatum", "logDsict", "Logdata", "logDsatum", "logDatata", "LogDum", "logdum", "exData", "logDict", "logFam", "logData", "logDatam", "LogDict", "logDum", "exDatum", "Logdum", "logDsata", "exDam", "logDam", "logFictionary", "logdatum"]}}
{"id1": "812803", "id2": "823074", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["conception", " deconvert", "Convert", "converting", "subvert", "unversion", " deconverting", "CONverting", "unvert", "CONvert", "unception", "Conversion", " deconverted", "unverted", "subverted", "Converted", "conversion", " deconversion", "CONverted", "subversion", "oconvert", "CONversion", "converted", "Conception", "Converting", "CONception", "subverting", "oconversion", "oconverted", "oconverting"], "src": ["reader", "username", "cb", "sin", "loc", "RC", "name", "sn", "gb", "s", "sc", "slice", "cpp", "stream", "st", "secure", "inst", "download", "sth", "load", "gz", "proc", "sys", "rc", "SourceFile", "ssl", "component", "ource", "prot", "req", "feat", "video", "img", "href", "fn", "dist", "back", "rb", "cmp", "source", "storage", "ctx", "path", "spec", "filename", "attr", "stage", "url", "config", "code", "uri", "sit", "file", "impl", "Dest", "upload", "sel", "scene", "sb", "input", "resource", "Source", "fp", "ref", "rl", "string", "obj", "buf", "tmp", "supp"], "dest": ["bin", " destination", "cont", " dst", "class", "orig", "di", "txt", "img", "fn", "dist", "temp", "std", "dc", "test", "lib", "source", "disk", "path", "null", "Dest", "target", "dir", "dat", "home", "obj", "tmp"], "in": ["reader", "bin", "inf", "isin", "login", "f", "data", "doc", "inas", "ins", "pin", "stream", "ex", "In", "is", "win", "r", "din", "val", "IN", "err", "ini", "d", "i", "source", "inc", "t", "n", "pass", "ps", "inn", "io", "as", "up", "file", "a", "input"], "p": ["f", "lp", "tp", "s", "g", "py", "m", "j", "pi", "wp", "pc", "per", "pr", "jp", "b", "part", "op", "l", "bp", "pre", "cop", "e", "r", "parser", "o", "pp", "d", "i", "sp", "t", "h", "v", "ps", "pe", "c", "P", "pm", "np", "pa", "po", "fp", "pd", "cp", "pg", "pb"], "ds": ["data", "dl", "dd", "services", "groups", "ys", "cs", "ls", "ld", "tools", "d", " props", "js", "ded", "xs", "uds", "ps", "ils", "ges", "tests", "pd", "ads", " sd", "df", "lp", "ups", "ins", "bs", "Ds", "os", "sys", "sts", "obs", "rs", "dds", "dm", "nas", "gd", "hs", "points", "ipes", "qs", "DS", "styles", "des", "ss", "ks", "dos", "cons", "ts", "vals", "eps", "els", "icks", "da", "ns", "parts", " ps", "dist", " DS", "posts", "dc", "scripts", "ths", "dates", "vs", "gs", "ays", "dat", "docs", "dt", "s", "sync", "utils", "ans", "di", "words", "models", "lines", "db", "dp", "ants", "amps", "plugins"], "format": ["tag", "data", "f", "layout", "sche", "scale", "name", "version", "at", "ant", "handler", "type", "table", "language", "filter", "letter", "feat", "class", "plugin", "model", "part", "magic", "fn", "parser", "atter", "style", "source", "template", "t", "api", "spec", "struct", "filename", "pattern", "path", "form", "url", "config", "unit", "Format", "file", "function", "act", "prefix", "fd", "frame", "record", "host", "fp", "string", "nat"], "hasPixelData": ["hasPicturedata", "hasPictureSize", "hasByteData", " hasPixeldata", "hasPixeldata", "showsPixelDATA", "hasPixelSize", "hasPixelStyle", "showsByteStyle", " hasPixelSize", "showsBytedata", "hasByteStyle", "showsPixeldata", "showsByteData", "hasPictureData", "hasByteSize", "showsByteDATA", "hasByteDATA", "showsPixelData", "haspixeldata", "hasBytedata", "hasPixelDATA", "haspixelSize", "haspixelData", "showsPixelStyle"], "inflate": ["insflATE", "invenATE", "inflode", "inffated", "inFlated", "InFlace", "Inflace", "invenate", "insflate", "inflated", "inadequating", "inFlace", "insflating", "infolating", "infolATE", "inadequATE", "invenode", "inadequode", "insflode", "inffation", "infloated", "insvenATE", "invenating", "inffate", "inFlate", "inadequate", "inflating", "InFlated", "infolode", "infface", "Inflated", "Inflate", "InFlation", "inflation", "Inflation", "infloace", "insvenating", "insvenode", "infolate", "InFlate", "inflATE", "inflace", "infloate", "insvenate", "infloation", "inFlation"], "pxlen": ["mxlen", "fxdata", "mxpos", "campos", "pclon", "axln", "ppl", "txlen", "fxLen", "pxdata", "pxsize", "pngcount", "xpsize", "pxpos", "txln", "xpcount", "ppLen", "txlin", "mxdata", "camdata", "camln", "mxln", "axlen", "pcln", "pnglength", "pglen", "pxden", "fxden", "txlon", "pgLen", "pxl", "pxlength", "pxlon", "axlon", "pclin", "camlen", "pgden", "pxln", "mxcount", "pngsize", "fxln", "pgl", "mxlength", "mxsize", "axlin", "pclen", "fxl", "pxcount", "fxpos", "pxLen", "fxlen", "xplen", "pnglen", "ppden", "pxlin", "xplength", "pplen"], "out": ["lock", "point", "error", "session", "state", "outs", "gen", "dump", "sys", "log", "copy", "page", "cache", "user", "again", "output", "conn", "line", "work", "query", "err", "OUT", "list", "lib", "cli", "step", "parent", "v", "store", "server", "group", "post", "io", "up", "co", "inter", "pad", "re", "Out", "obj"]}}
{"id1": "7981642", "id2": "4599372", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 0, "substitutes": {"update": ["save", "login", "data", "edit", "create", "put", "change", "send", "setup", "set", "add", "copy", "register", "user", "check", "text", "u", "and", "password", "key", "updated", "address", "Update", "build", "init", "exec", "h", "delete", "url", "config", "sum", "sign", "post", "up", "append", "replace", "UPDATE", "auth", "push", "insert", "write", "end", "apply"], "mail": ["ul", "msg", "office", "gmail", "alt", "login", "lock", "name", "phone", "mails", "m", "ge", "gal", "xml", "label", "Email", "local", "model", "html", "user", "text", "front", "zip", "old", "password", "address", "md", "proxy", "fax", "source", "value", "url", "hello", "uri", "server", "date", "group", "view", "file", "folder", "dial", "id", "message", "Mail", "contact", "dir", "host", "company", "who", "string", "ip", "username"], "email": ["office", "gmail", "ail", "cdn", "alt", "login", "cn", "name", "phone", "archive", "wd", "note", "mails", "el", "info", "dn", "en", "xml", "Email", "inet", "class", "log", "model", "description", "text", "online", "zip", "old", "line", "password", "address", "md", "nick", "fax", "url", "enter", "li", "n", "uri", "server", "hello", "eu", "folder", "file", "id", "message", "Mail", "dir", "host", "home", "addr", "ip", "element", "username"], "pwd": ["pwt", "cpwd", "cpws", " pWD", "Pws", "ppwd", "Ppassword", "hwd", "hwa", " ppass", "pwa", "hWD", "Pwd", "Pwh", " pwa", " pwt", "ppassword", "cpwt", "Ppass", " pwh", "cpWD", "pWD", "pwh", "Pwa", "ppwh", "hpass", "PWD", "Pwt", "pws", " pws", "pppassword", " ppassword", "ppass", "pppass"], "firstname": ["firstemail", "caseName", "lastkey", "lastuser", " firstName", "hostname", "lastnames", "casename", " firstuser", "lastName", " firstpass", "firstkey", "lastpass", "firstuser", " firstnames", "hostemail", "firstnames", "newuser", "firstpass", "casepass", "hostkey", "newname", " firstemail", "hostName", " firstkey", "caseemail", "lastemail", "newnames", "firstName"], "lastname": [" lastday", "lastkey", "firstday", "lastn", "secondName", "lastnames", "fullname", "lastName", "firstkey", " lastaddress", "firstaddress", "fulln", "lastday", " lastName", "secondname", "lastaddress", "secondkey", "firstnames", " lastnames", " lastn", "fullnames", "fullday", " lastkey", "fullName", "firstn", "firstName", "secondaddress"], "connection": ["manager", "nc", "pool", "handler", "database", "sc", "session", "creator", "ca", "m", "application", "lc", "di", "conn", "b", " Connection", "client", "this", "connected", "condition", "cc", "connect", "db", "cf", "h", "object", "response", "ion", "system", "context", "config", "document", "relation", "server", "Conn", "c", "function", "management", "index", "con", "directory", "Connection", "communication", "bc", "graph"], "attrs": ["attacts", "attks", "attributes", "attras", "Attps", " attks", "atras", "attars", "matps", "atributes", "attps", " attr", "atRS", "Attributes", "Attrs", " attRS", "AttRs", "addars", "atr", "addras", "atrs", "addributes", "attRs", " attRs", " attributes", "addRS", " attps", " attacts", "atps", "Attr", "addRs", "atars", " attars", "attr", "atks", "matars", "addps", "addrs", "matrs", "Attars", "attRS", "Attras", "atacts", "matributes", "Attacts", "addr", "addks"], "sha": ["ema", "meta", "volume", "ka", "ha", "sche", "si", "ua", "ca", "ma", "na", "da", "pi", "lambda", "shi", "base", "hi", "acl", "ami", "mac", "alias", "password", "va", "la", "md", "sm", "wa", "h", "asha", "sum", "sa", "mm", " SHA", "ga", "a", "pa", "eta", "pg", "alpha", "ya", "SHA", "sh", "HA"], "digest": ["mdest", "modEST", " digester", " digests", "DigEST", "diggest", "Digester", "digested", "moded", "modests", "Digcode", " diggest", "digester", "tagest", "digEST", "diged", " digcode", "mdested", "mdester", "mdgest", "digcode", "Diged", " digEST", "Digested", "Diggest", "modest", " diged", "tagester", "digests", "tagcode", " digested", "tagested", "Digest", "Digests"], "hash": ["rh", "bin", "ag", "ha", "hed", "version", "body", "array", "enc", "hex", "bh", "base", "match", "dig", "user", "mac", "her", "kh", "password", "key", "secret", "block", "image", "build", "value", "h", "url", "sum", "code", "raw", "message", "ash", "cover", "auth", "Hash", "json", "html", "sh"], "ctx": [" cx", " rc", "cb", "qa", "loc", "Context", "cn", " cs", "cca", "fw", "sc", "ca", " conn", "ct", "hw", "ck", "pc", "rc", "cs", "lc", " context", "cci", "conn", "jp", "cr", "client", "sq", "cmp", "ci", "cc", "vc", "anc", "cf", "xc", "context", "cl", "config", "conv", "cu", "cv", "c", "cas", "tc", " c", "ctrl", "cm", "mc", "cp", "tx", "bc", "pkg"], "newName": ["oldAddress", " newAddress", "newEmail", "Newname", "oldname", "oldEmail", "newAddress", "NewName", " newEmail", "newname", "NewAddress", " newname", "NewEmail"], "oldName": ["oldHome", "origname", " oldAddress", "OldName", "newHome", "OldHome", "newAddress", "OldAddress", " oldPath", "OldPath", "origName", " oldEmail", "Oldname", "oldname", " oldname", "oldPath", " oldHome", "oldAddress", "OldEmail", "newEmail", "oldEmail", "origPath", "origEmail"]}}
{"id1": "19584877", "id2": "3330944", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToStream", "encodeFiletoStream", "encodeString2Stream", "encodeFiletoFile", "encodeStringToString", "encodeString2String", "encodeFileToStream", "encodeFileToString", "encodeFileFromFiles", "encodeFile2Files", "encodeStringToFiles", "encodeFile2String", "encodeStringToFile", "encodeFileFromString", "encodeString2Files", "encodeFileFromFile", "encodeFiletoString", "encodeFile2Stream", "encodeFileToFiles", "encodeFiletoFiles", "encodeString2File", "encodeFile2File", "encodeFileFromStream"], "infile": ["inputFile", "inputfilename", "Infiles", "outfilename", "infilename", "inputfile", "outFile", "inputfiles", "outfiles", "infp", "inputfp", "outfp", " infilename", " infp", " infiles", "infiles", "Infilename", "InFile", "Infile", "inFile"], "outfile": ["newFile", "outputfilename", "Outfile", "outfilename", "infilename", "outFile", "Outfolder", " outfp", " outfilename", "infp", "newfolder", "outname", "outfp", " outname", " outFile", "Outname", " outfolder", "outputfp", "newname", "newfile", "outputfile", "infolder", "OutFile", "outputfolder", "outfolder"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "vin", "base", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "image", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "copy", "conn", "cache", "again", "output", "inner", "writer", "work", "line", "err", "off", "client", "o", "OUT", "lib", "source", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "post", "io", "net", "file", "up", "co", "on", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "reader", "border", "uffer", "iter", "data", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "len", "queue", "input", "result", "length", "write", "fb", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "close", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "input", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "modified", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "respons", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "5441579", "id2": "21152728", "code1": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "code2": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "label": 1, "substitutes": {"createPseudoUUID": [" createPseudoUUuid", " createPseudoPuid", " createPseudoUuid", " createPseudoPMD", " createPseudoUUD", " createPseudoPUID", " createPseoUUD", " createPseoUMD", " createPseudoPUD", " createPseoUuid", " createPseudoUUMD", " createPseudoUMD", " createPseudoUUUID", " createPseoUUID", " createPseudoUUUD"], "messageDigest": [" messageDigesting", "messagediger", "messagedigse", "MessageDigusher", "messageSignester", "messageDesigner", "messageSignest", "MessageSignusher", "messageDesignest", "messagedigest", "MessageDigEST", "maildigester", "messagedigener", "messageDigener", "messageSignEST", " messageDigester", "messageDester", " messageDest", "messageDigse", "messageDigester", "MessageSignester", "messageDigusher", "messageDigesting", "messageSignse", " messageDesting", "messageDigEST", "messageDiger", "messageSignusher", " messageDester", "messageDigested", "messageBuilder", "MessageSignEST", "messagedigested", "MessageSignest", "messageDesignester", "messagedigusher", "messageBuildest", "MessageDigse", "messageDesignEST", "MessageDigested", "MessageDigener", "maildigest", "mailDigester", "messageDest", "messageDer", "messagedigester", "messageSignested", "maildiger", "maildigEST", "messageBuildesting", " messageDiger", "messageDesting", "mailDiger", "mailDigest", "messageSignesting", "MessageDigest", "messageSigner", " messageDer", "mailDigEST", "messageSignener", "MessageDigester", "messagedigEST", "messageDesignusher", "messageBuildester"], "localHost": ["localhost", "localPort", " localPort", "remotePort", "localAddress", "LocalDomain", " localDomain", " localAddress", "foreignHost", "foreignAddress", "foreignPort", "remotehost", "localDomain", "LocalAddress", "Localhost", "remoteHost", "foreignDomain", "LocalHost", "remoteAddress", " localhost", "LocalPort"], "digestBytes": [" digesterBlocks", " digastbytes", "DigestBitcoin", "digestFiles", "digenseBlocks", "digesterTokens", " digesterBytes", "digengeByte", "Digestbytes", "digeterBytes", "digesterBytes", "digesterPoints", "digesterFiles", "digestedbytes", "digenseBytes", "digestedBlocks", "digengeBitcoin", "digestsPoints", "digesterParts", "digendBytes", "digestPoints", "digESTBytes", " digengeBytes", "digestbytes", "digestedBytes", "digengeBytes", "DigesterBitcoin", "digesterBitcoin", "digesterBlocks", "digastByte", "digesterbytes", "digestampBitcoin", "digESTByte", "DigesterGb", "DigestWords", " digastTokens", "digestWords", "DigestGb", "digestsByte", "DigestByte", " digengePages", " digesterbytes", " digestbytes", "DigesterBytes", "digestampbytes", "digestampBytes", "digestedPages", " digestParts", "digestBitcoin", "DigestFiles", " digestPages", "digESTBitcoin", "digesterGb", "digestampWords", " digengeBitcoin", "Digesterbytes", "digeterByte", "digestBlocks", "digastBytes", "DigesterFiles", " digestBitcoin", "digestGb", "digestedParts", "digestPages", " digestTokens", " digestByte", "digseTokens", "digesterWords", "digseBytes", "digestedBitcoin", "DigestBytes", " digastBytes", "digeterFiles", "digendBitcoin", "digESTbytes", "DigesterByte", "DigestPoints", "digestsBytes", "digseByte", "digesterByte", "DigesterPoints", " digestBlocks", "digendbytes", "digestTokens", "digsePages", "digESTPoints", "digenseParts", "digestedByte", "digensebytes", " digengeByte", "digestByte", "digengePages", "DigesterWords", "digastTokens", "digsebytes", "digastbytes", "digeterGb", "digenseWords", "digseBitcoin", " digesterParts", " digastByte", "digenseBitcoin", "digestParts"], "sb": ["SB", " SB", "BB", "bm", "cb", "su", "nn", "sg", "ob", "si", "lp", "bj", "sl", "gb", "s", "bs", "sth", "bt", "fe", "eb", "bh", "xb", "bl", "ssl", "kb", "bb", "ls", "lc", "bi", "b", "binary", "conn", "txt", "sv", "bp", "shell", "vm", "rb", "abi", "buffer", "abb", "sp", "db", "ws", "lb", "ba", "bg", "url", "lr", "nl", "sa", "pb", "wb", "nb", "sr", "Bs", "src", "bf", "sf", "ss", "ai", "usb", "obj", "sym", "fb", "bc", "ib", "buf"]}}
{"id1": "9081749", "id2": "15351863", "code1": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"encrypt": ["esccrypt", "Enccrypt", "Encrypt", "escipher", "encipher", "encryption", "escryption", "Encryption", "deccrypt", "decryption", "decipher", "enccrypt", "decrypt", "Encipher", "escrypt"], "password": ["wallet", "data", "name", "email", "wd", "database", "command", "seed", "python", "array", "encrypted", "description", "words", "picture", "user", "text", "cache", "Password", "css", "weight", "mask", "root", "account", "parser", "key", "address", "secret", "crypt", "buffer", "padding", "this", " passwords", "image", "sword", "value", "project", "phrase", "PASS", "pattern", "parent", "pass", "null", "params", "word", "prefix", "message", "token", "pad", "auth", "string", "strip", "username"], "encryptType": ["encertType", "acrypttype", "encryptClass", "encrupttype", "encipherClass", "encryptionTypes", "encrypttype", "acryptionTyp", "encruptTyp", "acryptTypes", "ecryptClass", "ecipherKey", "acryptionTypes", "encerttype", "acryptionType", "enciphertype", "encPTKey", "encPTType", "ecryptKey", "encryptTypes", "encryptKey", "acryptType", "encriptTyp", "encruptTypes", "encryptionTyp", "encripttype", "encryptionType", "encPTtype", "encipherKey", "encriptTypes", "encruptType", "acryptiontype", "encPTClass", "encipherType", "ecipherClass", "encertKey", "ecipherType", "ecryptType", "acryptTyp", "encryptTyp", "eciphertype", "encriptType", "encertClass", "encryptiontype", "ecrypttype"], "md": ["df", "bd", "vd", "f", "mag", "hed", "cd", "rm", "grad", "mad", "dd", "m", " MD", "mt", "dig", "di", "mb", "mac", "hm", "cmd", "dm", "um", "d", "MD", "gd", "mo", "mod", "amd", "der", "mp", "rpm", "metadata", "mm", "pm", "dh", "mc", "pd", "mand", "hd", "od", "nm", "Cmd"], "hash": ["full", "ver", "data", "ha", "hed", "hard", "char", "digit", "version", "error", "handle", "how", "array", "filter", "body", "str", "hex", "log", "base", "cache", "check", "part", "throw", "kh", "her", "mac", "bug", "query", "dot", "key", "count", "style", "build", "image", "block", "value", "h", "fill", "url", "sum", "code", "number", "ashes", "memory", "id", "index", "search", "len", "message", "flash", "sha", "header", "ash", "diff", "print", "Hash", "html", "chip", "sh", "bit"], "hexString": ["pixelBuffer", "squareField", "blackString", "hexstring", "hexArray", "hexLine", " hexArray", " hexField", "blackFile", "hexField", " hexBuffer", "rawBuffer", " hexSet", "rawstring", "blackLine", "alphFile", "zipString", "blackstring", "hexFile", "squareArray", "hexBuffer", "hashArray", "squareString", "zipSet", "pixelString", "rawArray", "zipField", "squareSet", "zipArray", "hashString", "alphLine", "alphString", "rawString", "hexSet", "hashFile", "hashstring", "pixelstring", "rawFile", " hexstring", "alphstring", " hexLine", " hexFile", "pixelFile"], "i": ["x", "ji", "f", "data", "si", "start", "it", "ti", "ri", "s", "slice", "p", "j", "info", "pi", "ie", "ix", "I", "bi", "u", "b", "di", "multi", "qi", "l", "r", "e", "o", "off", "ini", "abi", "temp", "count", "ci", "h", "xi", "v", "oi", "ui", "li", "n", "uri", "ii", "io", "c", "id", "index", "ai", "gi", "phi", "length", "ip", "end"]}}
{"id1": "3683344", "id2": "9846843", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 0, "substitutes": {"genRandomGUID": [" genRandomUUID", " genRandomUIP", " genRandomUuid", " genRandomGID", " genRandomGUuid", " genRandGIP", " genRandGID", " genRandomGUIP", " genRandomIGIP", " genRandUID", " genRandomGIP", " genRandomIGID", " genRandUIP", " genRandomUID", " genRandUUID", " genRandomIGUID", " genRandGUID", " genRandGuid", " genRandomIGuid", " genRandomGuid", " genRandomGUUID", " genRandUuid"], "secure": ["active", "https", "force", "depth", "q", " Secure", "session", "allow", "remote", "seed", "encrypted", "exclusive", "timeout", "str", "smart", "fast", "sys", "ssl", "require", "zip", "forced", "deep", "password", "random", "client", "sensitive", "secret", "proxy", " insecure", "sec", "close", "config", "server", "protect", "ssh", "weak", "Secure", "debug", "safe", "host", "security", "stable"], "valueBeforeMD5": ["valueBeforeMR5", "valueBeforeMD85", "valueBeforeMS5", "valueBeforeMR85", "valueBeforeMC3", "valueAfterMD55", "valueBeforeMS2", "valueBeforeMP2", "valueBeforeMD3", "valueBeforeMT5", "valueBeforeSHA1", "valueBeforemd3", "valueBeforeMP5", "valueAfterMD05", "valueBeforeSHA3", "valueBeforeSHA2", "valueAfterMD1", "valueBeforeM5", "valueBeforeMC5", "valueAfterMC8", "valueAfterMS5", "valueAfterMS3", "valueBeforeMR8", "valueBeforeMP3", "valueBeforemd8", "valueAfterMS2", "valueBeforeM3", "valueBeforemd5", "valueBeforeMR3", "valueBeforeAMD3", "valueBeforeAMD5", "valueBeforemd85", "valueBeforeSHA5", "valueBeforeMP55", "valueBeforeMS3", "valueBeforeMT20", "valueBeforeM1", "valueAfterMC3", "valueBeforeMD55", "valueBeforeMD05", "valueBeforeMD8", "valueAfterMD85", "valueBeforeAMD05", "valueBeforeMT55", "valueBeforeMD2", "valueAfterMD3", "valueBeforeMC85", "valueAfterMD20", "valueBeforeM2", "valueBeforeMT3", "valueBeforeMD1", "valueAfterMS1", "valueBeforeMD20", "valueBeforeAMD20", "valueAfterMC85", "valueBeforeMT2", "valueAfterMC5", "valueAfterMD2", "valueAfterMD8", "valueBeforeMC8", "valueBeforeMS1", "valueBeforeMT05"], "valueAfterMD5": ["valueAfterMF3", "valueAfterMFTE", "valueBeforeMP2", "valueBeforeMD3", "valueBeforeMD512", "valueBeforeMDody", "valueBeforeMP3", "valueBeforeMP1", "valueAfterDF3", "valueAfterMC1", "valueAfterHTML05", "valueAfterAST3", "valueAfterAMD3", "valueBeforeMD1", "valueAfterASTody", "valueAfterM3", "valueBeforeMPTE", "valueAfterAST5", "valueBeforeMDql", "valueAfterMC2", "valueAfterMP3", "valueBeforeMP5", "valueBeforeMDTE", "valueBeforeMC5", "valueAfterAST512", "valueAfterDM5", "valueBeforeAST2", "valueAfterHTMLTE", "valueBeforeAST3", "valueBeforeVM3", "valueAfterMC3", "valueBeforeMD2", "valueAfterDF005", "valueAfterMF5", "valueAfterHTML5", "valueAfterMC5", "valueAfterMD2", "valueAfterMP005", "valueAfterDF5", "valueAfterMCql", "valueBeforeMC3", "valueBeforeVM005", "valueAfterMDody", "valueAfterMTql", "valueAfterMD05", "valueAfterHTML512", "valueAfterHTMLody", "valueAfterGM005", "valueAfterMD005", "valueBeforeMP05", "valueAfterMF05", "valueAfterHTML3", "valueAfterMP1", "valueAfterDMody", "valueAfterMD3", "valueAfterAST005", "valueAfterM1", "valueAfterMT5", "valueAfterMD512", "valueBeforeASTody", "valueBeforeVM5", "valueAfterVM3", "valueAfterAMD005", "valueBeforeAST5", "valueAfterGM2", "valueAfterMDql", "valueAfterMP5", "valueAfterMD1", "valueBeforeAST005", "valueAfterAST2", "valueAfterMT3", "valueAfterVM5", "valueAfterGM5", "valueBeforeAST512", "valueAfterDM3", "valueAfterMP05", "valueAfterAMD5", "valueBeforeMD05", "valueAfterVM005", "valueAfterM5", "valueBeforeMD005", "valueAfterM2", "valueAfterDM512", "valueAfterGM3", "valueBeforeMCql", "valueAfterMP2", "valueAfterMPTE", "valueAfterMDTE"], "md5": ["amd512", "cmd05", "amd2", "md05", "cmdkey", "md2", " md25", " mdkey", "md1", "mand5", "amd25", "mand3", "amd5", " md3", "cmd512", " md1", "md25", "cmd1", " md05", "md65", "MD5", " md65", "mand512", " md512", "MD512", " MD05", "md512", "mand2", "cmd65", " md53", "cmd53", " MD53", " md2", "MD2", " MD3", "mand65", "md53", " MD5", "cmd5", "cmd3", "mdkey", "mandkey", "md3", "mand1", "MD25", "cmd2"], "sbValueBeforeMD5": ["sbValueWithoutMF5", "sbValueBeforeMD3", "sbValueBeforeMC5", "sbValueInsideMD5", "sbValueBetweenMD2", "sbValueBeforeMP1", "sbValueAfterMP3", "sbValueBeforeMP525", "sbValuebeforeND85", "sbValueBeforeMT005", "sbValueBeforeMP3", "sbValueBeforemd05", "sbValueBeforeMD525", "sbValueBeforeND3", "sbValueBeforemd25", "sbValueBeforeAMD3", "sbValuebeforeMD2", "sbValueBehindND25", "sbValuebeforeND5", "sbValueBeforemd3", "sbValueBeforeMP512", "sbValueBeforeMG3", "sbValueWithoutMD25", "sbValueBeforeMF25", "sbValueBetweenmd3", "sbValueWithoutMF35", "sbValueBetweenMD305", "sbValueBeforeMD05", "sbValueBeforeMP25", "sbValueBeforeAMD5", "sbValueBeforeMM005", "sbValueBeforeMM55", "sbValueBeforeMS85", "sbValueBeforeMS512", "sbValueBeforeMD55", "sbValueWithoutMD35", "sbValueBetweenmd305", "sbValuebeforeMD85", "sbValueInsideAMD5", "sbValueBeforeMP05", "sbValueBeforeMS5", "sbValuebeforeND3", "sbValueAfterMD512", "sbValueAfterMP55", "sbValueBeforeAMD512", "sbValueWithoutMD5", "sbValueBeforemd305", "sbValueBeforeMR25", "sbValueBeforeMT55", "sbValueBetweenmd2", "sbValueAfterMP005", "sbValueBeforeMC25", "sbValueBeforeMD2", "sbValueBeforeAMD1", "sbValueBeforeMD35", "sbValueBehindMD3", "sbValueAfterMP1", "sbValueWithoutMD3", "sbValueInsideAMD25", "sbValueBeforeMP2", "sbValueBeforeMF3", "sbValueBeforeMP005", "sbValueBehindMD25", "sbValueAfterMD1", "sbValueBehindMD5", "sbValueInsideAMD05", "sbValueBeforeMD1", "sbValueBeforemd2", "sbValueBeforeND25", "sbValueBeforeMP55", "sbValueBeforeMF35", "sbValuebeforeMD5", "sbValueAfterMD005", "sbValueBeforeMT3", "sbValueBeforeMF5", "sbValueBeforeMR525", "sbValueInsideMD3", "sbValueBehindND525", "sbValueBeforeND5", "sbValueBeforeAMD25", "sbValueAfterMP512", "sbValueWithoutMF3", "sbValueInsideMD05", "sbValueBeforeND525", "sbValueBeforeMD305", "sbValueBeforeAMD305", "sbValuebeforeMD3", "sbValueInsideMD25", "sbValueBeforeMS2", "sbValueBeforeMT5", "sbValueAfterMP5", "sbValueBeforeMD512", "sbValueBehindMD525", "sbValueAfterMD55", "sbValueBeforeMD25", "sbValueBeforeAMD2", "sbValueBeforeMD85", "sbValueAfterMD3", "sbValueBeforeND2", "sbValueBeforeMG5", "sbValueBeforeND85", "sbValueBeforeMP85", "sbValueBetweenMD5", "sbValueBeforeMM3", "sbValueBeforeAMD05", "sbValueBeforeMP5", "sbValueBeforeMD005", "sbValueBeforeMC35", "sbValueInsideAMD3", "sbValueBeforeMS3", "sbValueBeforemd5", "sbValueBetweenMD3", "sbValueBeforeMG25", "sbValuebeforeND2", "sbValueBehindND3", "sbValueBeforeMC3", "sbValueAfterMD5", "sbValueBeforeMS1", "sbValueBehindND5", "sbValueBeforeMM5", "sbValueWithoutMF25", "sbValueBeforeMG35", "sbValueBeforeMR3", "sbValueBetweenmd5", "sbValueBeforeMR5", "sbValueBeforeMP305"], "time": ["etime", "name", "version", "depth", "times", "q", "error", "type", "seed", "cost", "mode", "timeout", "counter", "Time", "size", "clock", "year", "TIME", "work", "random", "tz", "temp", "race", "count", "money", "ime", "value", "port", "speed", "age", "date", "rate", "duration", "delay", "id", "timer", "hour", "host", "sleep", "length", "start", "month"], "rand": ["rh", "reg", "name", "version", "depth", "q", "risk", "error", "type", "range", "seed", "clean", "rank", "winner", "rc", "rule", "mid", "rage", "win", "year", "r", "root", "bug", "raid", "dist", "max", "random", "dr", "rr", "Rand", "count", "serial", "pattern", "order", "round", "core", "ng", "rate", "delay", "id", "ro", "right", "index", "rss", "nd", "pick", "length", "re", "alpha", "bit"], "array": ["feature", "app", "vector", "batch", "archive", "database", "arr", "range", "Array", "table", "error", "pair", "expression", "sample", "cache", "all", "multi", "instance", "section", "r", "bug", "collection", "angle", "address", "row", "list", "image", "value", "arrow", "air", "object", "our", "view", "number", "element", "function", "index", "a", "module", "record", "integer", "area", "string", "now", "ray"], "strTemp": ["drTemp", "arrTemp", "arrTem", "objtemp", "brTemp", "strVar", " strTest", "objFake", "crTem", "crTemp", "crtemp", "drtemp", "brtemp", "objTemp", "drVar", "drTem", "arrTest", "strFake", "stringTem", " strtemp", " strTemplate", "stringtemp", "crTemplate", "StrBase", " strTem", "strTest", "StrTemp", "stringTemp", " strVar", "stringFake", "drTemplate", "objTem", "brTest", "strTemplate", "strtemp", "strTem", "arrBase", "brTem", " strFake", "arrtemp", "brVar", "Strtemp", "strBase", " strBase"], "i": ["x", "ji", "f", "y", "start", "si", "ti", "ri", "slice", "p", "j", "info", "pi", "k", "field", "ie", "ix", "hi", "I", "di", "u", "b", "multi", "l", "e", "o", "key", "abi", "d", "ci", "z", "h", "xi", "v", "yi", "ui", "n", "li", "uri", "ii", "io", "c", "in", "id", "index", "mu", "eni", "ai", "gi", "phi", "ip", "end"]}}
{"id1": "21092340", "id2": "3375722", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"addToArchive": ["addtoAsive", "addToArchIVE", "addtoAsIVE", "addToSlively", "addToSlives", "addtoAsively", "addToSlIVE", "addToAdaptively", "addToAsIVE", "addToSlive", "addToArchives", "addToAdaptive", "addToAsive", "addToArchively", "addToAdaptIVE", "addtoArchively", "addtoArchIVE", "addToAsives", "addtoArchive", "addToAsively", "addtoArchives", "addToAdaptives", "addtoAsives"], "pod": ["table", "p", "ods", "pi", "proc", "pc", "pl", "per", "plugin", "component", "cer", "part", "cache", "loader", "Pod", "plug", "zip", "bean", "product", "child", "project", "object", "pid", "tmp", "post", "pe", "ce", "module", "po", "host", "pad", "od", "ad", "pot", "peer", "node", "pkg"], "podArchiveOutputStream": ["podArchIVEInputDirectory", "podArchiveFileDirectory", "podArchIVEOutputStream", "podArchiveIOSteam", "podArchiveByteStream", "podArchiveOutputDirectory", "podArchiveFileFile", "podArchivesFileResource", "podArchivingOutputStream", "podArchiveByteSteam", "podArchiveOperationStream", "podArchiveFilePath", "podArchivesOutputSteam", "podArchIVEOutputSteam", "podArchivesFileStream", "podArchiveIOResource", "podArchIVEOutputFile", "podArchivesOutputResource", "podArchivingWriteSteam", "podArchiveOutputSteam", "podArchiveWritePath", "podArchivingWriteStream", "podArchIVEInputSteam", "podArchiveInputStream", "podArchiveWriteSteam", "podArchivingOutputPath", "podArchivingWritePath", "podArchiveFileStream", "podArchivesFileSteam", "podArchivesOutputFile", "podArchiveFileResource", "podArchivingOutputSteam", "podArchivesFileFile", "podArchiveOutputResource", "podArchivesOutputStream", "podArchiveIOFile", "podArchiveIOStream", "podArchiveByteDirectory", "podArchiveInputFile", "podArchiveInputSteam", "podArchiveByteFile", "podArchiveWriteFile", "podArchIVEInputStream", "podArchiveInputDirectory", "podArchiveFileSteam", "podArchIVEOutputDirectory", "podArchiveOperationResource", "podArchiveInputPath", "podArchiveOperationSteam", "podArchIVEInputFile", "podArchivingOutputFile", "podArchiveOperationFile", "podArchiveIODirectory", "podArchiveOutputFile", "podArchiveOutputPath", "podArchiveWriteStream", "podArchivingWriteFile"], "filename": ["sequence", "f", "name", "archive", "database", "kn", "application", "download", "fil", "label", "SourceFile", "nil", "binary", "kl", "Filename", "loader", "files", "l", "ppa", "fn", "alias", "ename", "subject", "which", "path", "il", "property", "url", "uri", "platform", "route", "file", "folder", "title", "module", "prefix", "word", "FILE", "sf", "fp", "named", "location", "directory", "string", "dll", "username"], "source": ["reader", "connection", "sl", "archive", "slice", "seed", "stream", "stack", "ource", "copy", "text", "output", "loader", "zip", "SOURCE", "service", "proxy", "image", "driver", "path", "parent", "url", "config", "document", "uri", "unit", "file", "src", "resource", "input", "target", "Source", "result", "slave", "string", "use"], "entry": ["reader", "connection", "data", "it", "archive", "stream", "string", "auto", "se", "ge", "event", "letter", "ie", "add", "Entry", "article", "zip", "r", "line", "e", "address", "this", "row", "pointer", "image", "child", "feed", "or", "path", "parent", "object", "iterator", "post", "file", "index", "resource", "result", "record", "obj", "element"]}}
{"id1": "18793482", "id2": "742465", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"modifyApplicationMessage": ["modifyapplicationmessage", "modifyApplicationMsg", "modifyApplicationContent", "modifiedApplicationMessage", "modifyAppContent", "modifiedapplicationMessage", "modifyapplicationContent", "modifiedApplicationContent", "modifiedApplicationMsg", "modifyExternalMessage", "modifyapplicationMessage", "modifiedapplicationContent", "modifyExternalmessage", "modifyAppMsg", "modifyapplicationMsg", "modifyExternalMsg", "modifiedapplicationMsg", "modifiedapplicationmessage", "modifyExternalContent", "modifiedApplicationmessage", "modifyApplicationmessage", "modifyAppmessage", "modifyAppMessage"], "locale": ["localales", "locationale", "localALE", "placeame", "localue", "localame", "locame", "localator", "locator", "localale", "placeALE", "locales", "Locator", " locator", "locue", "Locales", "Locame", "locationales", " locame", "LocALE", "Locale", "placeales", "placeale", "locationue", " locales", "Locue", "locALE", "locationALE"], "messageName": ["reasonValue", "msgKey", "phraseType", "MessageKey", "messagename", "MessageValue", "msgName", " messagename", "msgType", "reasonname", "MessageName", "MessageType", "Messagename", "messageType", "phraseValue", "reasonType", "msgValue", "reasonName", "phraseKey", "messageKey", " messageType", " messageKey", "phraseName"], "messageValue": ["messageVal", " messageVal", "MessageValue", "msgName", "MessageVal", "msgType", "MessageName", "MessageType", "responseName", "responseVal", "messageType", "msgValue", "responseType", "msgVal", " messageType", "responseValue"], "properties": ["prop", "Property", "data", "options", "py", "perties", "settings", "ips", "xml", "Pro", "conf", "txt", "ops", " props", "api", "stats", " Properties", "property", "config", "ps", "metadata", "params", "pro", "resources", "json", "obj", "pb", "tmp"], "i18nPath": ["i11fCorp", "i32ninUrl", "i18fUrl", "i18nFile", "i18napath", "i18nsFile", "i18onLocation", "i18bStr", "i32nUrl", "i18bPart", "i32nPath", "i18nepath", "i18nStr", "i18fPath", "i18onPath", "i18ninUrl", "i16npath", "i16nsPart", "i11fUrl", "i18npath", "i16nPath", "i11fPath", "i18ninFile", "i32ninPath", "i18nsPath", "i32ninFile", "i32ninLocation", "i18nsUrl", "i11npath", "i11fpath", "i18neUrl", "i18nsCorp", "i18ninPath", "i16nsStr", "i16nsPath", "i18nLocation", "i18bPath", "i18naPath", "i16nPart", "i11nUrl", "i18fCorp", "i18nsLocation", "i18onFile", "i18naStr", "i18nCorp", "i11nPath", "i18nePath", "i18nspath", "i18naPart", "i18onUrl", "i18nUrl", "i18fpath", "i18ninLocation", "i18nPart", "i18nsPart", "i16nspath", "i11nCorp", "i32nLocation", "i18bpath", "i18nsStr", "i16nStr", "i32nFile", "i18neCorp"], "englishFile": ["propertiesPath", "propertiesFile", "ianaJar", " englishJar", "Englishfile", "EnglishFolder", "EnglishPath", "EnglishFiles", " englishPath", "englishPath", "propertiesfile", "ianaFile", "EnglishFile", " englishfile", "languageJar", "ianaDir", "englishJar", "examplefile", "englishFiles", "englishfile", "examplePath", "exampleFolder", "languageFiles", " englishFiles", "englishDir", "ianaPath", "languagefile", "exampleFile", " englishDir", "languagePath", "propertiesFolder", "englishFolder", "languageDir", "languageFile"], "propertiesFilePath": ["propertiesFilesUrl", "propertiesFileName", "propertiesFilesName", "propertiesDirpath", "propertiesSourceFilePath", "propertiesSourceFileURL", "pertiesfileURL", "propertiesFileUrl", "propertiesDirUrl", "propertiesfilePath", "propertiesFileURL", "propertiesFilespath", "pertiesfilepath", "pertiesFilepath", "pertiesfileName", "propertiesfileName", "propertiesSourceFilepath", "propertiesSourceFileName", "pertiesDirName", "propertiesfileURL", "propertiesfilepath", "pertiesDirpath", "propertiesFilesPath", "propertiesFilesURL", "pertiesfilePath", "pertiesDirPath", "pertiesFileURL", "pertiesDirUrl", "propertiesDirPath", "propertiesfileUrl", "propertiesDirName", "pertiesFileName", "pertiesFileUrl", "propertiesFilepath", "pertiesFilePath"], "file": ["lock", "le", "data", "name", "book", "language", "field", "letter", "binary", "class", "format", "die", "b", "single", "buffer", "source", "ile", "path", "h", "property", "url", "function", "module", "message", "resource", "directory", "it", "File", "socket", "handler", "play", "stream", "fe", "log", "page", "entity", "content", "zip", "or", "parent", "up", "folder", "php", "word", "use", "reader", "f", "p", "one", "model", "part", "show", "http", "FILE", "fp", "full", "connection", "force", "application", "base", "future", "text", "files", "l", "child", "filename", "object", "unit", "pe", "string", "media"], "in": ["reader", "bin", "isin", "sin", "er", "f", "login", "into", "it", "ri", "s", "ins", "pin", "p", "cin", "In", "inside", "kin", "b", "inner", "again", "rin", "win", "l", "r", "din", "IN", "err", "plus", "ini", "d", "i", "init", "image", "inc", "nin", "or", "n", "io", "inn", "ic", "lin", "input", "con", "gin"], "out": ["full", "bin", "ext", "f", "socket", "error", "s", "sync", "to", "p", "ex", "outs", "one", "plain", "part", "w", "b", "output", "again", "inner", "by", "r", "work", "err", "and", "o", "OUT", "i", "lib", "cli", "image", "inc", "builder", "outer", "exec", "v", "n", "io", "net", "up", "word", "co", "ou", "home", "exp", "Out", "string", "write", "end"], "c": ["x", "abc", "cur", "arc", "f", "char", "sc", "C", "ct", "p", "dec", "cont", "k", "enc", "ec", "pc", "rc", "lc", "b", "w", "size", "cr", "l", "r", "o", "esc", "ice", "dc", "d", "i", "pointer", "ci", "cc", "ch", "t", "cf", "uc", "h", "xc", "v", "character", "cl", "code", "n", "cu", "ce", "a", "con", "ac", "col", "bc", "cy"], "is": ["iter", "ais", "Is", "iss", "get", "si", "it", "ri", "does", "s", "ins", "stream", "info", "has", "str", "os", "isa", "IS", "its", "i", "isu", "api", "bis", "ui", "ir", "ps", "ris", "as", "iso", "id", "are", "es", "res", "us", "ios", "re", "serv", "ib"], "breader": ["feedamer", "breadler", "breadr", "feediter", " cakeER", "brewr", " cakeler", " Breader", "weber", " breadler", " Breadler", " cakeer", "breadER", " breaders", "brewiter", "feedr", " breadER", " BreadER", "webiter", " Breaders", "breaders", "webamer", "webr", "feeder", "brewer", " cakeers", "breadamer", "breaditer", "brewamer"], "line": ["le", "sl", "data", "name", "side", "error", "lo", "el", "body", "sync", "one", "str", "definition", "letter", "log", "rule", "status", "base", "inline", "page", "part", "text", "lc", "model", "liner", "section", "l", "cell", "key", "lines", "lf", "row", "comment", "style", "parse", "block", "entry", "feed", "value", "Line", "response", "phrase", "band", "lined", "character", "url", "no", "next", "plugin", "li", "code", "pass", "nl", "split", "LINE", "word", "message", "frame", "lin", "header", "item", "link", "day", "string", "write", "ip", "end", "look", "strip"], "strBuilder": [" strBuffer", " strbuilder", "brbuilder", "strBlock", "stringbuilder", "brBuffer", "stringBuilder", "strBuilding", "StrBlock", "stringBuffer", "stringBuilding", "StrBuilding", "brBuilding", "StrBuild", "stringBuild", " strBuilding", "StrBuffer", "StrBuilder", "brBuild", "strbuilder", "strBuffer", " strBlock", "brBlock", " strBuild", "Strbuilder", "brBuilder", "strBuild"], "pieces": ["cuts", "pages", "vals", "values", "pots", "blocks", "sections", "nets", "tips", "piece", "phones", "groups", "services", "cards", "ips", "forms", "cells", "items", "words", "parts", "planes", "circle", "bits", "features", "bytes", "files", "ops", "flows", "apps", "lines", "steps", "letters", "strings", "pins", "places", "packs", "marks", "rings", "tops", "objects", "lists", "names", "styles", "boxes", "keys", "split", "seconds", "bones"], "found": ["full", "missing", "required", "matched", "f", "loaded", "true", "fixed", "fl", " Found", "made", "got", "first", "created", "successfully", "fall", "identified", "not", "filled", "used", "find", "given", "letter", "all", "successful", "built", "old", "left", "l", "val", "based", "err", "changed", "lost", "updated", "printed", "expected", "normal", "Found", "count", "defined", "temp", "finding", "null", "search", "valid", "still", "result", "sent", "failed", "confirmed", "broken"]}}
{"id1": "9275622", "id2": "12172485", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": ["moveFolder", "copyFiles", " copyfile", "copyFolder", "transferFile", "transferFolder", "moveFiles", "transferfile", " copyFiles", " copyFolder", "transferFiles", "movefile", "copyfile", "moveFile"], "_file1": ["_files1", "_files01", "_File2", "_fileone", "_resourceOne", "_mail2", "_file0", "_resource1", "_fFirst", "_resourceone", "_zip1", "_zipFirst", "_fileOne", "_zipOne", "_file01", "_fone", "_fOne", "_File0", "_f1", "_mail1", "_File01", "_mail0", "_File1", "_mail01", "_zipone", "_files2", "_files0", "_resourceFirst", "_fileFirst"], "_file2": ["_files4", "_filesecond", "_Filesecond", "_File5", "_File2", "jfile1", "_file4", " _filesTwo", " _files3", "jmodelsecond", "_model1", "_model5", "_file5", "_modelsecond", "_files3", "_file3", "jfile5", "_play2", "jfilesecond", " _file3", "_playTwo", "jmodel1", "jmodel5", "_play1", "_model2", "_playsecond", "_filesTwo", "_fileTwo", "_File1", "_play5", " _files4", "_files2", "_play4", " _file4", " _fileTwo", "jfile2", "_play3", "jmodel2", " _files2"], "fis": ["fiss", "infiss", "lfais", "lfi", "afis", "cfos", " fris", "afais", "cfiss", "lfis", "cfas", "Fils", " fais", "infils", "afiss", "fi", "Fas", "Fis", " fi", "fils", "infos", "Fiss", "fas", " fiss", "afi", " fils", "lfiss", "Fos", "fris", "Fris", "fais", "cfis", "cfris", "infis", " fas"], "fos": ["infaos", "Fo", "fus", "infus", "Foos", "Foses", "foses", "infios", "feos", "floes", "goses", "Fus", "info", " foos", "fOS", "flis", "infros", "gis", "Faos", "Fros", " fus", "gos", "feoses", "foes", "pis", "Fios", "Fis", "infoos", "infos", "fros", "poes", " faos", "pOS", "feus", "fios", "Fos", "pos", "feis", "foos", " fo", "flOS", " fios", "los", "lis", "faos", "lOS", "flos", "fo", " fros", "loes", "gus"], "canalFuente": ["canalBuence", "canalCraencia", "canaledBuje", "canaledBuze", "canalKuze", "canallBuente", "canallFuente", "canalBuento", "canalFuze", "canalsBuence", "canaledBuente", "canalSuente", "canalFuento", "canallBuence", "canalsFuente", "canalBuente", "canalBuje", "canalSuje", "canalFUje", "canaledFuente", "canalSuestro", "canaledFuestro", "canallFuze", "canalsFuence", "canalsBuento", "canalFUestro", "canalFuencia", "canalKuence", "canalsFuencia", "canalFUente", "canalBuencia", "canaledBuestro", "canaledFuje", "canalKuento", "canalsFuento", "canalFuje", "canallBuze", "canallFuence", "canalsBuencia", "canaledFuze", "canalBuestro", "canallFuencia", "canalKuente", "canalKuencia", "canalFuence", "canalFUencia", "canalSuze", "canalCraence", "canalsBuente", "canalFUze", "canalCraente", "canalCraento", "canalFUence", "canalBuze", "canallBuencia", "canalFuestro"]}}
{"id1": "13886238", "id2": "19868933", "code1": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"init": ["open", "it", " Init", "error", "Init", "activate", " reload", " discover", "info", "strap", "load", "setup", "launch", "art", "destruct", "check", "initialized", "construct", "reset", "test", "parse", "build", "update", "config", "start", "rest"], "backupFile": ["backUPF", "backrapSourceFile", "backacyfile", "backupsFile", "backureSourceFile", "BackdownFile", "backupFILE", "lookoutfile", "backrapDir", "lookupFile", "BackupDir", "BackureFiles", "backUPStream", "backoutFile", "backoutFILE", "backbackFile", "BackupStream", "backbackFolder", "backbackFILE", "lookoutFILE", "BackdownF", "backdownStream", "lookupFILE", "BackureFile", "backrapFile", "backbackfile", "lookupFolder", "backdownF", "lookoutFile", "backupFiles", "backUPFile", "backupsFiles", "backupsDir", "BackdownFiles", "backoutfile", "BackupSourceFile", "lookupfile", "backbookFile", "backdownFiles", "backureFile", "backureDir", "backbookStream", "backUPFiles", "backupSourceFile", "backacyFILE", "BackupF", "BackupFiles", "BackureDir", "BackdownStream", "lookoutFolder", "BackureSourceFile", "backureFiles", "backupDir", "backupfile", "backrapFiles", "backupStream", "backupsSourceFile", "backbookF", "backdownFile", "backupFolder", "backacyFile", "backbookFiles", "backacyFolder", "BackupFile", "backoutFolder", "backupF"], "buff": ["app", "cb", "ob", "ff", "char", "gb", "slice", "boot", "comp", "fab", "comb", "gz", "fe", "cast", "load", "bb", "b", "mb", "ph", "txt", "uff", "zip", "cmd", "shape", "flush", "pp", "ffff", "rb", "bind", "buffer", "back", "comment", "build", "cond", "feed", "ch", "bound", "bg", "cod", "Buff", "oct", "grab", "gg", "uf", "utf", "sb", "bf", "pad", "length", "cp", "fb", "pb", "now", "buf", "font"], "in": ["reader", "bin", "connection", "isin", "login", "f", "data", "get", "socket", "s", "slice", "ins", "pin", "el", "stream", "cin", "min", "In", "ssl", "inside", "part", "b", "inner", "again", "win", "old", "din", "l", "r", "IN", "e", "ini", "i", "image", "inc", "nin", "or", "exec", "url", "n", "pass", "inn", "c", "up", "id", "lin", "input", "con", "diff", "ac", "gin", "serv"], "out": ["reader", "bin", "ext", "doc", "socket", "ins", "sync", "ex", "outs", "one", "gen", "copy", "conn", "b", "user", "output", "again", "inner", "conf", "part", "win", "writer", "line", "IN", "err", "ax", "o", "client", "OUT", "lib", "inc", "exec", "n", "pass", "io", "net", "file", "up", "prefix", "co", "exp", "Out", "serv"], "read": ["lock", "iter", "data", "current", "find", "reads", "b", "work", "max", "d", "buffer", "select", "ask", "exec", "fill", "next", "close", "search", "length", "end", "wait", "READ", "open", "Read", "play", "se", "load", "en", "ind", "log", "ok", "bind", "row", "count", "parse", "build", "level", "id", "last", "start", "use", "x", "reader", "ride", "send", "add", "copy", "check", "roll", "r", "seek", "run", "lex", "feed", "connect", "n", "raw", "ad", "ip", "reach", "readable", "get", "sync", "k", "text", "size", "i", "block", "child", " Read", "reading", "view", "pass", "ink", "index", "input", "skip", "sleep", "write"], "reportWriter": ["exportJournal", "reportWalker", "reviewEditor", "reviewWriter", "resultStream", "summaryStream", "exportWriter", " reportWriting", "reviewDriver", "ReportWriter", "reportedTime", "reportedEditor", "exportHelper", " reportWalker", "summaryWriter", "reportStream", "commentWrite", "reportWriting", " reportWrite", " reportDriver", "reportedDriver", " reportEditor", "commentPage", "reviewEngine", "reportReader", "reportApplication", "exportApplication", "resultPage", " reportHelper", "exportReader", "summaryPage", "reviewTime", "reportedEngine", "reportedHelper", "ReportWriting", "reportedReader", " reportReader", "reportDriver", "reportedWriter", "reportTime", "reportEngine", "ReportWs", "reportedWalker", "commentWriter", "reportedWriting", "commentStream", "reportPublisher", " reportWs", " reportPublisher", "reportJournal", "reportHelper", "summaryWrite", "resultWriter", "reportedWrite", " reportTime", " reportApplication", "reportWrite", "reportWs", "resultWrite", "ReportWrite", "reportedWs", "exportPublisher", "exportWrite", " reportEngine", "exportWalker", "reportEditor", "summaryPublisher", "reportPage", "ReportApplication", "ReportReader", "reviewWrite", "summaryJournal", " reportJournal"], "restarting": ["restarmed", "restartING", "Restarting", "restrited", "RestritING", "restartsING", "restartable", "restarsING", "RestartING", "restartsating", "restarmING", "restriting", "restruptING", "Restartting", "restritable", "restritING", "restarted", "Restritting", "restarsing", "Restritable", "Restritating", "restritting", "restarming", "restartsting", "restartting", "Restarted", "Restartable", "restarmable", "restarsating", "Restartating", "restarsting", "restartating", "Restrited", "restrupted", "restrupting", "Restriting", "restritating", "restartsing", "restruptable"]}}
{"id1": "13644374", "id2": "3430784", "code1": "    public byte[] getBytesFromUrl(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toByteArray(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 0, "substitutes": {"getBytesFromUrl": ["getbytesFormUrl", "getBytesFormString", "getBytesFromString", "getBytesFromRoute", "getbytesFormRoute", "getbytesFormString", "getbytesFormURL", "getBytesfromUrl", "getBytesfromRoute", "getBytesFormURL", "getBytesFromURL", "getBytesViaString", "getbytesFromUrl", "getBytesfromString", "getBytesViaRoute", "getBytesViaUrl", "getBytesFormUrl", "getBytesFormRoute", "getBytesfromURL", "getbytesFromRoute", "getbytesFromString", "getBytesViaURL", "getbytesFromURL"], "url": ["connection", "sl", "data", "loc", "name", "email", "ur", "method", "download", "str", "xml", "base", "page", "href", "l", "key", "address", "Url", "i", "URL", "buffer", "service", "source", "api", "request", "path", "server", "uri", "route", "http", "resource", "result", "host", "ref", "location", "json", "string"], "get": ["open", "start", "create", "method", "put", "handle", "body", "send", "load", "find", "set", "gets", "query", "e", "client", "pull", "call", "service", "i", "cli", "build", "parse", "api", "request", "Get", "exec", "like", "GET", "update", "read", "http", "resource", "execute", "use", "json"], "response": ["full", "connection", "f", "data", "tree", "error", "respond", "method", "body", "application", "received", "Response", "status", "page", "output", "content", "success", "e", "reply", "feed", "api", "request", "object", "document", "server", "http", "wave", "message", "result", "resource", "out", "report", "onse", "json", "resp"], "entity": ["connection", "data", "el", "body", "info", "event", "xml", "model", "page", "node", "output", "instance", "content", "ale", "collection", "e", "translation", "this", "entry", "image", "Entity", "api", "object", "environment", "document", "server", "null", "pe", "person", "http", "metadata", "file", "message", "action", "resource", "result", "security", "json", "ent", "element", "resp"]}}
{"id1": "4599372", "id2": "3745402", "code1": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 0, "substitutes": {"readFixString": ["readfixContent", "readFixedstring", "readfixArray", "createFixedContent", "readfixString", "readFixArray", "createFixedString", "readFixedArray", "readAdjustArray", "readFixstring", "readFixedContent", "createFixstring", "readFixContent", "createFixArray", "readFixedString", "readAdjuststring", "createFixedstring", "createFixString", "readAdjustContent", "createFixContent", "createFixedArray", "readfixstring", "readAdjustString"], "len": ["lt", "le", "sl", "f", "loc", "data", "lp", "el", "body", "enc", "en", "str", "ll", "base", "lc", "part", "size", "l", "line", "val", "e", "fn", "lf", "list", "count", "i", "limit", "code", "n", "li", "split", "file", "pos", "lin", "lit", "Len", "length", "ln", "string"], "sw": ["ew", "sl", "wt", "fl", "sn", "ww", "sc", "fw", "hw", "stream", "iw", "wp", "wra", "ow", "WS", "bb", "tw", "w", "sv", "zip", "writer", "serv", "sp", "ws", "wa", "wh", "rw", "null", "aw", "io", "sa", "wb", "wr", "nw", "sr", "lv", "sb", "ss", "sf", "es", "Sw", "so", " SW", "sh", "wx", "SW"]}}
{"id1": "15797402", "id2": "9449064", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"parse": ["save", "Parser", "scan", " process", "handle", "worker", "processing", "se", "load", "xml", "pc", "fork", "set", " rewrite", "wrap", "arse", " parsing", "parser", "patch", " split", " convert", "service", " dispatch", "pack", " transform", " serve", "request", "process", "read", "raw", "view", "rate", " parser", "http", "split", "transform", "php", "cover", "replace", "print", "report", " analyse", "apply"], "stream": ["reader", "data", "channel", "down", "remote", "handle", "stack", "download", "load", "sample", "video", "loader", "inner", "content", "writer", "client", "temp", "source", "image", "feed", "response", "form", "url", "document", "read", "raw", "server", "iterator", "view", "http", "in", "file", "src", "message", "upload", "resource", "input", "draw", "through", "Stream"], "handler": ["reader", "connection", "data", "manager", "channel", "handle", "monitor", "layer", "phase", "Handler", "info", "application", "event", "base", "format", "di", "loader", "wrapper", "writer", "collection", "parser", "client", "service", "pointer", "controller", "ctx", "driver", "response", "parent", "hand", "h", "default", "server", "handled", "function", "host", "processor"], "metadata": ["mx", "connection", "meta", "data", "manager", "database", "monitor", "m", "runtime", "info", "mt", "state", "xml", "adata", "plugin", "component", "di", "content", "managed", "collection", "parser", "subject", "md", "material", "source", "map", "storage", "template", "ctx", "mon", "property", "met", "mi", "config", "document", "attribute", "metry", "uri", "management", "params", "module", "message", "header", "resource", "properties", "directory", "json", "processor"], "context": ["reader", "connection", " contexts", "data", "Context", "manager", "command", "method", "event", "xml", "component", "text", "instance", "txt", "content", "concept", "collection", "translation", "subject", "proxy", "cmp", "kernel", "entry", "ctx", "request", "parent", "object", "environment", "system", "config", "document", "scope", "message", " Context", "resource", "mc", "processor", "tx", "element"], "name": ["active", "connection", "missing", "ame", "job", "full", "data", "version", "type", "m", "sync", "label", "class", "base", "model", "part", "time", "size", "old", "alias", "work", "key", "address", "call", "comment", "source", "common", "image", "child", "api", "large", "path", "filename", "object", "url", "no", "default", "names", "Name", "n", "code", "null", "route", "in", "file", "id", "prefix", "search", "message", "action", "word", "on", "resource", "named", "none", "string", "NAME"], "out": ["connection", "bin", "extra", "ext", "data", "manager", "cos", "socket", "channel", "pool", "sync", "ex", "outs", "plain", "copy", "page", "conn", "user", "again", "output", "instance", "writer", "line", "err", "o", "client", "flush", "OUT", "temp", "lib", "source", "image", "child", "builder", "path", "object", "url", "server", "null", "io", "in", "file", "resource", "result", "window", "exp", "Out", "obj", "ray"]}}
{"id1": "22046596", "id2": "20619879", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["get", "put", "sync", "to", "p", "download", "all", "zip", "clip", "paste", "Copy", "exec", "transfer", "Transfer", " copied", " dup", "io", " copying", "file", "upload", "cp", " cp", " copies", "write", " transfer", " Copy"], "s": ["x", "ts", "sl", "f", "sin", "si", "ds", "g", "ins", "m", "services", "p", "se", "ns", "outs", "os", "ssl", "is", "ls", "u", "b", "less", "files", "w", "sv", "l", "e", "o", "i", "S", "source", "storage", "xs", "v", "gs", "south", "ps", "c", "as", "a", "src", "es", "ss", "sf", "sb", "input", "sh", "fs", "ses"], "t": ["x", "ts", "f", "y", "it", "at", "tp", "ot", "down", "g", "pt", "m", "tor", "to", "p", "tty", "ty", "b", "l", "r", "e", "tf", "o", "temp", "i", "z", "template", "object", "v", "n", "T", "c", "file", " T", "tc", "tr", "target", "ta"], "in": ["reader", "bin", "login", "f", "sin", "socket", "g", "ins", "pin", "m", "sync", "p", "min", "In", "is", "ssl", "conn", "b", "inner", "again", "rin", "win", "l", "din", "r", "IN", "e", "pull", "d", "i", "source", "init", "inc", "nin", "h", "url", "n", "io", "inn", "c", "as", "file", "id", "up", "input"], "out": ["x", "connection", "bin", "ext", "f", "channel", "at", "g", "sync", "p", "ex", "outs", "not", "plain", "conn", "b", "again", "output", "w", "user", "l", "writer", "err", "o", "off", "client", "OUT", "temp", "d", "call", "image", "inc", "parent", "v", "n", "null", "io", "net", "c", "file", "Out", "obj"]}}
{"id1": "23291583", "id2": "20663364", "code1": "    private ByteArrayInputStream fetchUrl(String urlString, Exception[] outException) {\n        URL url;\n        try {\n            url = new URL(urlString);\n            InputStream is = null;\n            int inc = 65536;\n            int curr = 0;\n            byte[] result = new byte[inc];\n            try {\n                is = url.openStream();\n                int n;\n                while ((n = is.read(result, curr, result.length - curr)) != -1) {\n                    curr += n;\n                    if (curr == result.length) {\n                        byte[] temp = new byte[curr + inc];\n                        System.arraycopy(result, 0, temp, 0, curr);\n                        result = temp;\n                    }\n                }\n                return new ByteArrayInputStream(result, 0, curr);\n            } finally {\n                if (is != null) {\n                    try {\n                        is.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            if (outException != null) {\n                outException[0] = e;\n            }\n        }\n        return null;\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 0, "substitutes": {"fetchUrl": ["fetchString", "furlurl", "fetchurl", "Fetchurl", "FetchString", "fdownloadURL", "fetchURL", "furlString", "fdownloadurl", "FetchUrl", "fdownloadString", "furlURL", "furlUrl", "FetchURL", "fdownloadUrl"], "urlString": [" urlstring", "filestring", "urlUrl", " urlStream", "fileString", " urlFile", "urlstring", "httpFile", "httpstring", "fileSource", "httpString", " urlUrl", "ruleSource", "sourceSource", "sourceString", "sourceStream", "ruleString", "httpSource", "ruleStream", "ruleUrl", "urlStream", "sourceUrl", "fileFile", "urlSource", " urlSource", "urlFile"], "outException": ["outEvent", "outError", "againException", "againception", "againEvent", "inception", " outEvent", "OutError", "Outception", "inError", "outception", " outError", "againError", "OutException", "inEvent", " outception", "inException"], "url": ["ul", "job", "open", "sl", "ver", "f", "data", "loc", "fl", "ur", "el", "web", "jar", "str", "base", "ssl", "rule", "ll", "log", "ls", "b", "page", "conn", "l", "r", "e", "Url", "i", "URL", "source", "image", "build", "feed", "api", "lib", "lr", "li", "store", "uri", "server", "http", "file", "resource", "www", "bel", "rl", "string", "fb", "il"], "is": ["be", "app", "ais", "Is", "iss", "get", "isl", "it", "si", "ri", "oss", "iv", "stream", "ori", "info", "has", "web", "os", "ie", "isa", "IS", "hi", "isc", "abs", "was", "internet", "ar", "err", "its", "i", "init", "ws", "api", "or", "js", "il", "nis", "bis", "close", "ois", "uri", "ir", "http", "ris", "in", "as", "iso", "id", "isf", "src", "are", "eni", "es", "ai", "out", "us", "ms", "ip", "fs", "ib", "ob", "isi"], "inc": ["lock", "const", "inf", "iter", "keep", "loc", "nc", "inse", "sc", "ins", "dec", "enc", "min", "ec", "ind", "rc", "rec", "lc", "INC", "conn", "inner", "num", "ign", "Inc", "acc", "err", "occ", "circ", "ci", "init", "limit", "uc", "sec", "level", "ir", "pri", "ii", "incre", "c", "in", "inn", "index", "con", "length", "exp", "spl", "ac", "col"], "curr": ["carru", "urrb", "perrb", "terril", "curro", "ferr", "currr", "surre", "urrc", "currn", "curru", "currb", "CurR", "terrs", " curru", " curril", "verrs", "Curbr", "verpr", " currc", "terr", " curre", "carril", " currs", "curpr", "Currc", "grrs", "charrr", "Curr", "urrr", "ferrs", "currd", " curpr", "grry", " currd", "Curpr", "charr", "terrd", "grr", "ferro", "currc", "carrs", "Curru", "perrs", "charro", "verr", "perru", "grro", " curbr", "carr", "curR", "charrn", "surR", "perrd", "urrd", "surr", "curbr", "curril", "surru", "perrn", " curry", " curro", "ferry", "urrn", " currb", "Currs", "carrd", "currs", "curry", "perrc", "verrc", "urro", "urr", "carrc", "surrc", "perr", "carR", "perre", "perbr", "curre", "perrr", "surrs", "perro"], "result": ["iter", "ver", "data", "current", "master", "error", "complete", "arr", "range", "array", "results", "info", "event", "grade", "rc", "status", "match", "page", "cache", "text", "output", "content", "success", "Result", "r", "done", "root", "err", "fr", "test", "buffer", "source", "ret", "continue", "comment", "product", "found", "list", "request", "response", "parent", "order", "sum", "default", "uri", "date", "memory", "function", "search", "message", "resource", "res", "diff", "cover", "report", "length", "json"], "n": ["x", "nt", "nn", "rn", "cn", "nc", "un", "sn", "s", "m", "na", "j", "dn", "ns", "p", "min", "enc", "en", "k", "rec", "conn", "u", "size", "num", "nu", "l", "r", "fn", "err", "e", "o", "ne", "i", "init", "z", "t", "pn", "no", "number", "nl", "nor", "nr", "N", "net", "c", "ng", "an", "ni", "len", "nd", "ln", "nb"], "temp": ["full", "extra", "iter", "cur", "data", "loc", "current", "now", "Temp", "py", "stable", "emp", "clean", "shared", "str", "base", "lc", "copy", "cache", "part", "output", "txt", "content", "old", "zip", "pre", "err", "key", "dest", "test", "buffer", "source", "init", "v", "raw", "empty", "null", "unsigned", "cut", "tc", "input", "diff", "tr", "fake", "wait", "tmp"]}}
{"id1": "10281203", "id2": "19322910", "code1": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    @Test\n    public void test_blueprintTypeByTypeID() throws Exception {\n        URL url = new URL(baseUrl + \"/blueprintTypeByTypeID/20188\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"{\\\"blueprintTypeID\\\":20188,\\\"blueprintTypeName\\\":\\\"Obelisk Blueprint\\\",\\\"productTypeID\\\":20187,\\\"productTypeName\\\":\\\"Obelisk\\\",\\\"productCategoryID\\\":6,\\\"techLevel\\\":1,\\\"productionTime\\\":1280000,\\\"researchProductivityTime\\\":7680000,\\\"researchMaterialTime\\\":5120000,\\\"researchCopyTime\\\":2560000,\\\"researchTechTime\\\":500000,\\\"productivityModifier\\\":256000,\\\"wasteFactor\\\":10,\\\"maxProductionLimit\\\":1,\\\"productVolume\\\":\\\"17550000\\\",\\\"productPortionSize\\\":1,\\\"dumpVersion\\\":\\\"cru16\\\"}\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n        connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/xml\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?><invBlueprintTypeDto><blueprintTypeID>20188</blueprintTypeID><blueprintTypeName>Obelisk Blueprint</blueprintTypeName><dumpVersion>cru16</dumpVersion><maxProductionLimit>1</maxProductionLimit><productCategoryID>6</productCategoryID><productPortionSize>1</productPortionSize><productTypeID>20187</productTypeID><productTypeName>Obelisk</productTypeName><productVolume>17550000</productVolume><productionTime>1280000</productionTime><productivityModifier>256000</productivityModifier><researchCopyTime>2560000</researchCopyTime><researchMaterialTime>5120000</researchMaterialTime><researchProductivityTime>7680000</researchProductivityTime><researchTechTime>500000</researchTechTime><techLevel>1</techLevel><wasteFactor>10</wasteFactor></invBlueprintTypeDto>\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/xml; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"makeRead": ["doREAD", " executeSet", " manageRead", " manageSet", " manageWrite", " makeWrite", "doWrite", " manageREAD", "doSet", " makeREAD", "doRead", " executeRead", " executeWrite", " executeREAD", " makeSet"], "user": ["job", "name", "creator", "install", "field", "log", "blog", "bug", "alias", "password", "User", "row", "comment", "nick", "pod", "pid", "url", "admin", "USER", "date", "post", "author", "server", "owner", "word", "users", "uid", "custom", "record", "host", "usr", "home", "string", "write", "use", "month", "human", "username", "site"], "databaseID": ["dbID", " databaseIDS", " databaseIDs", "DatabaseID", "dbName", "dbIDs", "connectionID", "connectionName", "DatabaseName", " databaseName", "connectionIDs", "databaseId", "databaseName", "collectionID", "collectionIDS", "databaseIDs", "databaseIDS", "collectionId", "DatabaseId", "DatabaseIDS", "collectionName", " databaseId"], "time": ["etime", "name", "times", "type", "table", "ip", "mode", "tim", "timeout", "counter", "Time", "set", "size", "clock", "year", "TIME", "end", "key", "tz", "comment", "money", "ime", "value", "port", "read", "date", "post", "rate", "duration", "delay", "id", "timer", "host", "sleep", "length", "home", "string", "start", "month"], "query": ["connection", "answer", "name", "question", "scan", "q", "error", "database", "command", "rule", "commit", "conn", "cmd", "work", "sq", "call", "condition", "comment", "select", "request", "update", "general", "code", "uri", "post", "function", "params", "search", "script", "message", "ql", "result", "join", "eries", "sql", "report", "execute", "json", "string", "Query"], "statement": ["connection", "agent", "volume", "si", "session", "s", "database", "command", "note", "language", "st", "table", "usage", "ma", "mt", "inst", "state", "str", "expression", "status", "rule", "commit", "di", "conn", "part", "instance", "section", "alias", "password", "parser", "comment", "i", "storage", "style", "db", "condition", "use", "response", "general", "document", "relation", "server", "unit", "jo", "function", "script", "message", "Statement", "stat", "study", "result", "join", "joined", "sql", "execute", "slave", "media", "start"], "count": ["offset", "get", "force", "depth", "error", "batch", "type", "handle", "table", "state", "find", "set", "base", "part", "cache", "size", "by", "err", "key", "expected", "list", "Count", "cond", "i", "limit", "found", "child", "process", "inc", "age", "sum", "code", "number", "c", "id", "index", "diff", "total", "length", "start"]}}
{"id1": "20208819", "id2": "4531653", "code1": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["get", " hashing", "str", "dump", "copy", "format", "check", "output", "num", " Hash", "mix", "parse", "build", "pack", "sum", "update", "code", "raw", " hashes", "print", "Hash", "string", "SHA"], "input": ["reader", "inf", "data", "current", "addin", "audio", "seed", "string", "array", "str", "binary", "text", "output", "instance", "inner", "plus", "address", "temp", "buffer", "source", "image", "feed", "request", "parent", "form", "url", "context", "config", "raw", "null", "in", "upload", "length", "accept", "Input"], "algorithm": [" algorith", "calgorithm", "algebra", "Algo", "Algorithm", " algebra", "calgebra", "Algorith", "aliphabet", "calgorith", "algo", " algo", "aligorithm", " alphabet", "aligebra", "Algebra", "alphabet", "algorith", "calgo", "aligo", "Alphabet"], "dig": ["ag", "enc", "get", "cd", "g", "grad", "pin", "dec", "ex", "comb", "div", "fe", "gen", "im", "sem", "me", "log", "lab", "Dig", "add", "wrap", "alg", "ld", "rob", "num", "and", "um", "dim", "imag", "mix", "del", "test", "d", "cmp", "ig", "build", "init", "db", "mod", "rg", "cod", "rd", "sign", "prep", "rand", "ng", "grab", "pm", "tool", "dat", "exp", "push", "de"], "result": ["df", "su", "iter", "data", "current", "manager", "card", "master", "string", "results", "array", "counter", "ger", "match", "format", "future", "page", "user", "output", "Result", "success", "work", "root", "member", "dest", "this", "ret", "buffer", "test", "source", "db", "value", "api", "builder", "response", "url", "our", "sum", "default", "group", "uri", "consumer", "null", "up", "global", "function", "valid", "message", "res", "diff", "cover", "record", "report", "length", "re", "json", "runner"], "digest": ["dige", "signEST", "generest", " digests", "DigEST", "generests", " Dige", "Digester", " Digest", "generester", "digested", " dige", "bigested", "bigests", "digester", "Digse", "bigester", "digEST", "Dige", "bigest", "digse", "signester", " digEST", "Digested", "generEST", " Digester", "signest", " digse", " DigEST", "digests", " digested", "signse", " digester", "Digest", "Digests"], "hex": ["rh", "bin", "iter", "data", "char", "digit", "head", "ctr", "array", "buff", "hess", "rex", "ex", "zero", "xf", "format", "shift", "check", "text", "pixel", "ph", "num", "throw", "sex", "zip", "address", "temp", "mix", "row", "pex", "wh", "h", "pattern", "ticket", "form", "uint", "sum", "oct", "null", "transform", "index", "utf", "header", "length", "cube", "string", "bit"], "i": ["x", "f", "y", "si", "it", "ti", "ri", "j", "p", "info", "pi", "ix", "hi", "I", "bi", "b", "di", "multi", "qi", "l", "e", "o", "uli", "abi", "d", "ci", "z", "t", "h", "xi", "v", "oi", "ui", "li", "n", "uri", "ii", "io", "c", "id", "iu", "a", "index", "mu", "ai", "gi", "phi"], "u": ["x", "ul", "cur", "su", "f", "sup", "char", "bu", "q", "un", "uu", "ur", "p", "pu", "ru", "b", "U", "num", "l", "e", "o", "lu", "back", "yu", "d", "fu", "uc", "h", "v", "ue", "ui", "uri", "du", "uv", "cu", "c", "up", "hu", "iu", "mu", "chu", "uf", "uid", "ou", "us", "uni", "string", "nu", "tu"], "highCount": ["largeCode", "lowLength", "highCode", "highercount", "higherCode", "higherCount", "largeSize", "highC", "largeCount", "highSize", "higherCast", "fullCast", "hiSize", "hiCode", "HighCode", "higherSize", "HighSize", "lowCode", "fullcount", "HighC", "HighCount", "fullCount", "HighLength", "hiCount", "largeC", "highCast", "lowCast", "higherC", "lowSize", "highLength", "hiLength", "highcount", "lowcount"], "lowCount": ["slowCount", "highSum", "lowLength", "LowCount", "lowC", "highC", "highSize", "LowSize", "slowSum", "lowerLength", "slowCast", "LowC", "lowerC", "lowerSize", "lowerCast", "lowerSum", "LowCast", "highCast", "lowCast", "lowSize", "lowerCount", "slowLength", "highLength", "lowSum"]}}
{"id1": "4593011", "id2": "13757855", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "label": 0, "substitutes": {"loadDDL": ["loadODML", "loadDDML", "loadCDL", "loadSDLL", "loadCDML", "LoadCDE", "LoadCDLL", "loadSDL", "loadODLL", "LoadDDL", "LoadDDML", "loadCDLL", "loadCDE", "loadSDML", "loadDDLL", "LoadCDL", "loadSDE", "LoadCDML", "loadODE", "loadODL", "LoadDDE", "LoadDDLL", "loadDDE"], "stmt": ["stgr", "estmt", "STpr", "esttt", "sttr", "rmd", "Stmr", "Stmn", "rm", " stmn", "tmd", "STmb", " stpr", "estmp", "estm", "estmb", "Stmt", " stdb", "estmd", "tdb", "STmr", "stmp", "STgr", "stmd", "estmr", " stm", "Stmb", "STmt", "constmt", " stmd", "rdb", "Stdb", "stpr", "constm", "Sttt", "stmr", " stgr", "stdb", "STtr", " sttr", "tm", "sttt", "strgr", "strpr", "stmn", "STmp", "strtr", " sttt", "constdb", "stm", "tmt", "strmt", "Stm", "stmb", "constmn", "Stmp", "Stmd", "rmt"], "qry": ["equry", " qury", "quRY", "qrys", "qRY", "qries", " qrys", "qri", " qries", "Qri", " qRY", "eqRY", "Qry", "Qries", "qurys", "quries", " qri", "quury", "qury", "Qrys", "eqry", "quri", "eqrys"], "q": ["qa", "f", "qq", "quest", "quant", "p", "k", " sq", "eq", "Q", "req", "qu", "b", "iq", "r", " req", "query", "e", " query", "key", "sq", "d", "i", "requ", "select", "qs", "ch", "t", "request", " p", "v", "config", "dq", "n", "c", "id", "ql", "queue", "qt"]}}
{"id1": "1097146", "id2": "3430784", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getContentdigifier", "getMessageSignest", "getMessagedigests", "getMessageDigester", "getMessagedigest", "getMessageEncester", "getMessageEncests", "getMessageEncifier", "getContentdigests", "getContentDigests", "getMessageEncest", "getContentDigest", "getMessagedigester", "getMessageSignests", "getContentDigester", "getContentdigest", "getMessagedigifier", "getMessageSignifier", "getMessageDigests", "getMessageDigifier", "getMessageSignester", "getContentdigester", "getContentDigifier"], "input": ["reader", "inf", "data", "self", "container", "type", "audio", "string", "stream", "array", "state", "str", "xml", "definition", "binary", "model", "text", "output", "instance", "inner", "content", "plus", "password", "address", "temp", "this", "buffer", "i", "source", "list", "image", "parse", "submit", "request", "parent", "object", "form", "context", "config", "argument", "raw", "empty", "null", "document", "element", "in", "message", "amp", "out", "target", "accept", "Input", "now"], "md": ["bm", "meta", "df", "bd", "vd", "mag", "mg", "rm", "wd", "mad", "dd", "m", "ma", " MD", "mt", "me", "di", "mb", "am", "mac", "M", "cmd", "dm", "um", "mn", "dr", "sm", "d", "dc", "MD", "gd", "mo", "mod", "amd", "mp", "rpm", "metadata", "mm", "pm", "sha", "cm", "bf", "mc", "ms", "od", "mand", "nm"], "bytes": ["pages", "vals", "values", "data", "blocks", "rows", "gb", "s", "bs", "groups", "body", "outs", "units", "codes", "binary", "base", "words", "les", "parts", "b", "files", "bits", "ies", "bles", "lines", "address", "its", "strings", "pieces", "ipes", "tes", "classes", "odes", "bps", "null", "keys", "seconds", "es", "Bytes", "string"]}}
{"id1": "2009072", "id2": "17792212", "code1": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"openInput": ["createInput", "getOutput", "OpenContent", "OpenResource", "OpenInput", "createResource", "getResource", "getInput", "createOutput", "OpenOutput", "createContent", "getContent", "openContent", "openResource", "openOutput"], "path": ["full", "data", "tree", "name", "self", "s", "method", "stream", "filter", "clean", "enc", "str", "xml", "base", "part", "user", "text", "inner", "txt", "content", "root", "plus", "key", "temp", "list", "pointer", "image", "template", "value", "api", "relative", "request", "parent", "object", "pattern", "next", "context", "form", "sign", "uri", "route", "http", "c", "file", "transform", "id", "PATH", "word", "index", "prefix", "ath", "Path", "input", "ref", "string", "obj", "end", "node"], "len": ["le", "sl", "iter", "lp", "fl", "span", "en", "str", "base", "ll", "lc", "part", "size", "lon", "l", "line", "val", "lf", "list", "count", "sp", "limit", "v", "n", "li", "split", "pos", "lin", "fin", "Len", "length", "ln", "end"], "p": ["ep", "f", "lp", "point", "tp", "vp", "s", "py", "m", "j", "param", "pc", "pr", "jp", "u", "l", "pre", "o", "pp", "i", "sp", "api", "t", "ap", "v", "pe", "ps", "c", "P", "np", "pa", "po", "fp", "cp", "ip", "pb"], "url": ["connection", "open", "sl", "f", "fl", "channel", "web", "base", "ssl", "html", "page", "blog", "b", "user", "conn", "l", "client", "Url", "URL", "source", "image", "feed", "api", "object", "uri", "server", "browser", "http", "file", "ball", "resource", "www", "host", "link", "location", "string", "ob"], "result": ["reader", "open", "data", "array", "results", "stream", "event", "match", "ssl", "page", "output", "instance", "content", "Result", "r", "val", "err", "this", "ret", "buffer", "entry", "source", "api", "request", "response", "object", "air", "raw", "uri", "http", "up", "message", "resource", "res", "report", "obj", "tmp"]}}
{"id1": "11334468", "id2": "9857412", "code1": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "code2": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "label": 0, "substitutes": {"wordFrequency": ["wordFeedrequency", "wordFraction", "wordTidelity", "WordWrequency", "wordFitness", "wordWrequency", "wordTraction", "WordFitness", "wordWraction", "wordTitness", "WordFraction", "WordWraction", "wordTrequency", "WordFidelity", "WordWitness", "wordFidelity", "wordFeeditness", "wordFeedidelity", "wordFeedraction", "wordWidelity", "WordFrequency", "wordWitness", "WordWidelity"], "word": ["nn", "tag", "name", "ww", "first", "language", "wp", "str", "letter", "rule", "words", "part", "w", "text", "term", "old", "line", "query", "writer", "password", "key", "sword", "phrase", "pattern", "number", "code", "Word", "search", "W", "prefix", "message", "token", "input", "out", "string"], "replWebQuery": ["ReplWebquery", "replCoreQuery", "replaceWebExp", "replwebExp", "replWebquery", "replWordQuery", "replwebRequest", "replWavequery", "replWaveQuery", "replacewebExp", "replacewebQuery", "replWaveUrl", "replwebUrl", "replWebExp", "replCorequery", "replacewebRequest", "replCoreExp", "ReplwebQuery", "replWordExp", "replaceWebQuery", "replacewebquery", "Replwebquery", "ReplWebQu", "ReplWebQuery", "replWordquery", "replaceWebquery", "replCoreRequest", "ReplWebUrl", "ReplwebUrl", "replwebQu", "replwebquery", "replWaveQu", "ReplwebQu", "replWebUrl", "replWordRequest", "replwebQuery", "replWebRequest", "replWebQu", "replaceWebRequest"], "url": ["connection", "open", "sl", "f", "data", "org", "socket", "channel", "web", "str", "xml", "base", "ll", "ssl", "ls", "bb", "page", "conn", "b", "log", "zip", "l", "r", "e", "address", "Url", "buffer", "URL", "source", "image", "service", "feed", "hub", "path", "object", "uri", "server", "browser", "http", "file", "impl", "www", "resource", "link", "location", "string"], "content": ["reader", "data", "body", "cont", "stream", "str", "xml", "description", "text", "output", "line", "Content", "comment", "buffer", "source", "entry", "image", "feed", "response", "read", "raw", "message", "resource", "result", "input", "out", "string", "media"], "in": ["reader", "bin", "connection", "isin", "login", "f", "data", "s", "ins", "stream", "In", "conn", "b", "again", "inner", "rin", "user", "l", "r", "din", "line", "IN", "e", "client", "ini", "this", "i", "source", "image", "inc", "nin", "server", "io", "inn", "c", "file", "as", "input", "out", "con", "gin", "serv"], "inputLine": ["outputLine", "inputFile", "feedStream", " inputBlock", " inputStream", "outputFile", "outputline", "feedline", "outputL", "inputL", "InputStream", "feedL", " inputline", "InputLine", "InputBlock", " inputFile", "InputL", " inputL", "outputBlock", "Inputline", "feedLine", "inputStream", "InputFile", "inputline", "inputBlock"], "fr": ["feature", "ire", "elt", "f", "fl", "arr", "ur", "range", "el", "adr", "aa", "kr", "vr", "Fr", "str", "fe", "fb", "pr", "br", "rf", "fer", "cr", "rs", "err", "dist", "dr", "rr", "frac", " r", "fx", "lr", "rt", "fre", "FR", "sr", "len", "fin", "tr", "result", "fp", "fm", " dr", "fee", "rl", " result", "ler", "fc"]}}
{"id1": "11616716", "id2": "22993368", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResponseAsReader", "getCMSResultAsFile", "getCMSResultInFile", "getCMSResultInSteam", "getCMSResultWithSteam", "getCMSResponseAsSteam", "getCMSResponseasFile", "getCMSResultasFile", "getCMSResultasStream", "getCMSResponseasSteam", "getCMSResponseasReader", "getCMSResultWithFile", "getCMSResultWithStream", "getCMSResultasSteam", "getCMSResultasReader", "getCMSResponseasStream", "getCMSResultAsReader", "getCMSResultWithReader", "getCMSResultInStream", "getCMSResultAsSteam", "getCMSResultInReader", "getCMSResponseAsFile", "getCMSResponseAsStream"], "rqlQuery": ["srqlQuery", "rqlQu", "riliQuery", "riliQu", "srqlQ", " rqlMethod", "rsqlQuery", "rqlMethod", "rQLMethod", "srqlquery", "riliQ", "rQLQu", " rqlQu", "rQLQ", "srQLQu", "rQLquery", " rsqlQuery", "rsqlQu", "srQLQuery", "riliquery", "rQLQuery", "rSQLQuery", "rsqlMethod", "rsqlquery", " rsqlMethod", " rqlquery", "rSQLQu", "rqlquery", " rsqlQu", "srQLQ", " rsqlquery", "srQLquery", "rSQLquery", "rqlQ", "rSQLMethod", "srqlQu", "rsqlQ"], "osr": ["otsrm", "OSrt", "cosrt", "cosrr", "otsr", " ospr", "osssr", "osfr", "losr", "losrr", " oscr", "oswer", "opsR", "opsrar", " osrr", "osrw", "osrs", "otspr", " ossr", "bosrar", "osscr", "usrt", "oserr", "osrt", " osfr", "opsr", "boswer", "osspr", "ossr", "iospr", "osrr", "userr", "osserr", "ysrar", "bosr", "iosr", "obswer", "cosr", "obsrar", "ossrr", "osrar", "opswer", "losfr", "ossrt", "usrw", "ospr", "usrr", "ossrw", "ysr", "ossrm", "losrt", "obsr", "usrs", "OSrr", "ossrs", "ysrt", " osrar", "OSr", "osR", "OSerr", "iosrs", "otssr", " osrt", "iosrw", "obsR", "usr", " osrm", "cosfr", "bosR", "ossrar", "uspr", "oscr", "osrm", "yscr"], "url": ["connection", "open", "sl", "f", "org", "fl", "channel", "socket", "web", "base", "ssl", "ll", "ls", "lc", "blog", "b", "page", "l", "r", "client", "Url", "URL", "source", "path", "config", "nl", "uri", "server", "http", "file", "resource", "www", "host", "rl", "string", "fb", "ob"], "conn": ["connection", "nt", "open", "cur", "cb", "f", "loc", "cn", "rn", "reg", "org", "nc", "oss", "ca", "ct", "sync", "p", "enc", "en", "ec", "ann", "pc", "rc", "ssl", "lc", "pr", "wrapper", "cr", "l", "fn", "err", "client", "dc", "ci", "db", "connect", "ch", "ctx", "h", "exec", "attr", "conv", "n", "server", "rt", "http", "c", "Conn", "net", "coll", "con", "cp", "Connection", "col", "act"]}}
{"id1": "8921716", "id2": "414258", "code1": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"MD5": [" MD8", "MP4", "SHA512", "MP8", "MP512", "MD8", " MD512", "MD4", "SHA4", "SHA8", "MP5", "MD512", "SHA5", " MD4"], "text": ["ext", " TEXT", "data", "name", "version", "str", " Text", "hex", "letter", "class", "binary", "format", "output", "contract", "txt", "content", "bytes", "EXT", "password", "key", "this", "secret", "buffer", "test", "source", "image", "template", "Text", "editor", "path", "struct", "object", "pattern", "url", "config", "number", "code", "in", "word", "prefix", "message", "token", "TEXT", "input", "length", "string", "font"], "UnsupportedEncodingException": ["UnsupportedEncodedception", "UnsupportedEncagingATION", "UnsupportedEncasingException", "UnsupportedEncagingException", "UnsupportedencodedException", "UnsupportedEncodedATION", "UnsupportedEncodingATION", "UnsupportedEncodingception", "UnsupportedencodingATION", "UnsupportedEncodedException", "UnsupportedencodingException", "UnsupportedEncagingception", "UnsupportedEncasingception", "UnsupportedencodedATION", "UnsupportedEncasingATION", "Unsupportedencodedception", "Unsupportedencodingception"], "md": ["meta", "df", "bd", "vd", "data", "mag", "mg", "manager", "cd", "rm", "wd", "method", "dd", "m", "body", "ma", " MD", "mt", "mode", "me", "match", "ld", "dig", "di", "mb", "mac", "cmd", "dm", "docker", "d", "MD", "mo", "mod", "hash", "amd", "mp", "code", "rpm", "metadata", "mm", "pm", "valid", "message", "sha", "cm", "bf", "mc", "ms", "pd", "mand", "pg", "od", "hd", "nm", "Cmd", "ad"], "md5hash": ["mddownsum", "md5Hash", "mand53html", "md5kh", "md2html", "md6hash", "md6kh", "md25hash", "md6Hash", " md6hex", "md25Hash", "md53hash", "md2sum", " md5Hash", "md2hash", "md4Hash", "mand5html", "md2version", "md53html", "md6hex", " md6Hash", " md6sum", " md5hex", "md25html", " md5kh", "md5version", "md5hex", "md2kh", "md53Hash", "md6sum", "md53version", "mand5Hash", "md5sum", " md6kh", "md4hash", "md5html", "mand53version", "md4hex", "md8sum", "md25version", " md6hash", "md8hex", "mddownHash", "md2Hash", "mddownkh", "mand53hash", "mddownhash", "mand5hash", " md5sum", "md8Hash", "md4sum", "mand53Hash", "md8hash", "mand5version"]}}
{"id1": "1357662", "id2": "7499186", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"copyFileTo": [" copyFileFrom", "copyChannelFile", " copyfileTo", "copyFileFrom", " copyfileFile", "copyFilesTO", " copyfileTO", "copyChannelTO", "copyfileFrom", " copyfileFrom", "copyfileTO", "copyFilesTo", "copyfileFile", "copyChannelFrom", "copyfileTo", "copyFilesFrom", "copyFilesFile", "copyChannelTo", "copyFileTO", " copyFileFile", "copyFileFile", " copyFileTO"], "destination": ["distinator", "destruction", " Destination", "configinations", "destined", "destinated", "configinator", " Destribution", "distruction", " destinate", "Destinations", "configination", "distination", "Destination", "sourceinated", "destinations", "Destined", " destined", "sourceination", "distined", "Destinator", "separinations", " destinations", "separinator", "separination", "sourceinator", "targetruction", " Destinator", "separinated", "sourceinations", "destinator", "configinated", "destribution", "destinate", "targetinations", " destribution", " destruction", "Destribution", "targetination", "targetinate", "distinate", " destinator", "distinations"], "srcChannel": [" srcContext", "sourceChan", "rcConnection", "destConnection", " srcchannel", "destChan", "sourceChannel", "rcContext", "rcChan", "sourceConnection", " srcConnection", "srcChan", "rcchannel", "sourcechannel", "srcContext", "sourceContext", "srcchannel", "rcChannel", "destchannel", "srcConnection", " srcChan"], "destChannel": ["sourceChan", "descButton", " destButton", "Destchannel", "DestConnection", "destConnection", "restChan", "destChan", "sourceChannel", "DestChannel", "sourceConnection", " destchannel", "srcChan", "restchannel", "destButton", "restChannel", "srcButton", "sourcechannel", " destChan", "srcchannel", "descChannel", "destchannel", "DestChan", "srcConnection", " destConnection", "descchannel"]}}
{"id1": "8690362", "id2": "22401746", "code1": "    public static void fileUpload() throws IOException {\n        HttpClient httpclient = new DefaultHttpClient();\n        httpclient.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION, HttpVersion.HTTP_1_1);\n        HttpPost httppost = new HttpPost(postURL);\n        File file = new File(\"d:/hai.html\");\n        System.out.println(ukeycookie);\n        httppost.setHeader(\"Cookie\", ukeycookie + \";\" + skeycookie + \";\" + usercookie);\n        MultipartEntity mpEntity = new MultipartEntity();\n        ContentBody cbFile = new FileBody(file);\n        mpEntity.addPart(\"\", cbFile);\n        httppost.setEntity(mpEntity);\n        System.out.println(\"Now uploading your file into mediafire...........................\");\n        HttpResponse response = httpclient.execute(httppost);\n        HttpEntity resEntity = response.getEntity();\n        System.out.println(response.getStatusLine());\n        if (resEntity != null) {\n            System.out.println(\"Getting upload response key value..........\");\n            uploadresponsekey = EntityUtils.toString(resEntity);\n            getUploadResponseKey();\n            System.out.println(\"upload resoponse key \" + uploadresponsekey);\n        }\n    }\n", "code2": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "label": 0, "substitutes": {"fileUpload": ["urlupload", "urlPost", "FileDownload", "FileUpload", "Fileupload", "FilePost", " fileupload", "urlUpload", "urlDownload", "fileDownload", "filePost", "fileupload", " filePost", " fileDownload"], "httpclient": [" httpClient", "phpcon", "httpcon", "httpserver", " httpconnection", " http24", "httpsserver", "phpClient", "Httpcon", "php24", "HttpClient", "httpClient", " httpserver", "httpconnection", "Httpclient", "httpsclient", "webClient", "Http24", "webclient", "phpclient", "webserver", "httpsconnection", " httpcon", "webconnection", "httpsClient", "http24"], "httppost": ["motpsort", "httplod", "httmpod", "httpsost", "httipprest", " httpprest", "httppast", " httpport", "httpast", "httmpast", "httppod", "httpsrest", "httppposter", " httplost", "httpsort", " httplrest", "httmpoint", "httmppost", " httppod", "httppppost", "httprest", "htteppost", "httphort", "motpprest", "httmprest", " httploint", "httphost", "httippost", "motpspost", "httppoint", "httplpost", "motpport", "httploint", "httippod", "httmport", " httphort", "httplrest", "httpppost", "httpposter", "motppost", "httpspost", "httpport", " httplod", "httmpost", "httport", "httpost", " httpppost", " httphpost", " httphost", "httpppast", "motpsost", "httepast", " httphoint", "motpsrest", "httphpost", "httplost", "httmposter", "httposter", "httippoint", "httpprest", " httppoint", "httepost", "htteposter", "motpppost", "httplort", "httphoint"], "file": ["connection", "f", "data", "name", "File", "handler", "audio", "body", "stream", "p", "xml", "base", "log", "model", "story", "page", "cache", "b", "part", "files", "picture", "video", "content", "zip", "l", "e", "buffer", "source", "image", "feed", "path", "object", "filename", "form", "url", "document", "movie", "http", "folder", "php", "message", "upload", "FILE", "resource", "queue", "fp", "media"], "mpEntity": ["mpentity", " mpentity", "upentity", "cpContent", "phpEngine", "cpentity", " mpEngine", "MPEnt", "mmContent", "upOrg", "mmEnt", "mpUrl", "mmEntity", " mpContent", "mpEngine", "mpEnt", "cpOrg", "ppContent", "MPUrl", "MPBody", "mpOrg", "cpEntity", " mpUrl", "MPEngine", "upEntity", "MPContent", "phpBody", "MPEntity", " mpBody", "mpBody", "ppEnt", "upContent", "ppEntity", "mpContent", " mpOrg", "phpEntity", "phpUrl"], "cbFile": ["fbfile", "cbBody", "CBfile", "cbfile", "cbPart", "fbFiles", "bbFile", "fbFile", "cbFiles", "bbfile", "CBFiles", "CBEntity", "bbEntity", "fbEntity", "CBFile", "CBBody", "CBPart", "fbBody", "cbEntity", "fbPart", "bbFiles", "bbPart", "bbBody"], "response": ["full", "connection", "answer", "data", "tree", "sequence", "ception", "error", "respond", "body", "stream", "application", "received", "Response", "status", "model", "description", "page", "successful", "output", "success", "line", "collection", "client", "reply", "respons", "service", "image", "feed", "request", "object", "v", "default", "document", "relation", "server", "http", "message", "flash", "resource", "res", "result", "onse", "json", "de", "resp", "site"], "resEntity": ["ResInstance", "respInstance", "respEnt", "respEntity", " resUnit", "ResEntity", "resentity", "respentity", " resEnt", "Resentity", "respEntry", " resEntry", " resentity", "resEntry", "ResEnt", "resInstance", "resUnit", "resEnt", "respUnit", " resInstance", "ResUnit", "ResEntry"], "uploadresponsekey": ["uploadresponsevalue", "uploadResponsekey", " uploadrespkey", "uploadrequestpart", "uploadrespvalue", " uploadresponsevalue", "uploadResponsepart", " uploadresppart", " uploadrespKey", "UploadResponseKey", "uploadrequestKey", "uploadrespkey", " uploadresponseKey", "UploadResponsekey", "UploadresponseKey", "uploadResponseKey", "uploadresppart", " uploadresponsepart", "uploadresponseKey", " uploadrespvalue", "uploadrequestkey", "uploadResponsevalue", "uploadrespKey", "Uploadresponsevalue", "uploadrequestvalue", "UploadResponsevalue", "Uploadresponsekey", "uploadresponsepart"]}}
{"id1": "1188100", "id2": "13063241", "code1": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"test": ["Test", "error", "create", "method", "check", " Test", "call", "show", "run", " testing", "build", "testing", "example", " evaluate", "server", "debug", "tests", "fail", "out", "print", "report", "execute", " example", "write", "start"], "s": ["ts", "sl", "f", "si", "ds", "g", "bs", "session", "services", "stream", "sets", "sync", "p", "ns", "settings", "state", "outs", "os", "is", "ssl", "ls", "ans", "cs", "w", "b", "abs", "less", "sv", "ops", "rs", "l", "e", "o", "its", "lines", "d", "i", "S", "storage", "service", "ws", "source", "stats", "js", "h", "bis", "gs", "n", "south", "server", "ps", "as", "ils", "in", "states", "sb", "ss", "out", "es", "us", "ms", "opens", "sym", "fs", "ks", "ses"], "input": ["reader", "qa", "data", "audio", "stream", "xml", "ssl", "copy", "w", "output", "instance", "r", "flow", "o", "temp", "buffer", "i", "storage", "source", "image", "feed", "request", "response", "driver", "reading", "read", "raw", "null", "io", "in", "up", "php", "a", "rss", "out", "Input"], "writer": ["reader", "office", "er", "data", "wan", "writ", "book", "worker", "string", "layer", "str", "xml", "letter", "per", "w", "writing", "output", "wrapper", "walker", "keeper", "r", "work", "key", "writers", "o", "temp", "buffer", "ler", "storage", "source", "pointer", "wa", "WR", "builder", "rw", "outer", "raw", "null", "io", "wr", "wb", "word", "written", "riter", "out", "Writer", "write", "editor"]}}
{"id1": "14758866", "id2": "8788371", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getResourceAsStream": ["getResourcesasFile", "getResourceASStream", "getResourceasFile", "getResourceToString", "getResourceasStream", "getResourcesasSteam", "getResourcesAsFile", "getResourcesasString", "getResourceToSteam", "getResourceAsString", "getResourcesAsStream", "getResourcesAsSteam", "getResourcesasStream", "getResourceASString", "getResourceASSteam", "getResourceToFile", "getResourceASFile", "getResourceToStream", "getResourceAsSteam", "getResourceasSteam", "getResourceAsFile", "getResourcesAsString", "getResourceasString"], "name": ["full", "connection", "ame", "data", "version", "type", "remote", "info", "ip", "str", "base", "part", "cache", "time", "size", "domain", "alias", "key", "address", "source", "path", "parent", "filename", "object", "hash", "Name", "config", "uri", "names", "memory", "file", "id", "prefix", "word", "resource", "named", "location", "string", "NAME", "username"], "inputStream": [" inputstream", "inputSteam", "cachestream", "currentBody", "InputConnection", " inputBody", "currentstream", "InputChannel", "InputStream", "currentStream", " inputChannel", "cacheSteam", "pullChannel", "inputBody", "pullConnection", "inputConnection", "cacheStream", "pullStream", "pullSteam", "inputFeed", "InputFeed", " inputConnection", "Inputstream", "inputChannel", "currentSteam", "InputBody", "cacheFeed", "InputSteam", "inputstream", " inputSteam", " inputFeed"], "in": ["reader", "bin", "data", "socket", "ins", "m", "In", "rec", "log", "inner", "din", "r", "IN", "err", "buffer", "source", "image", "path", "exec", "read", "c", "src", "input", "re", "Out"], "out": ["lock", "bin", "msg", "data", "point", "error", "pool", "state", "outs", "ex", "gen", "proc", "dump", "ger", "sys", "log", "copy", "page", "part", "conn", "user", "output", "cache", "cmd", "r", "line", "writer", "pre", "err", "query", "key", "client", "flush", "OUT", "temp", "list", "buffer", "cli", "bar", "outer", "object", "group", "server", "raw", "io", "up", "file", "params", "println", "inter", "window", "debug", "ref", "Out", "obj"], "url": ["full", "connection", "https", "open", "sl", "f", "data", "loc", "org", "socket", "ur", "gl", "remote", "stream", "web", "download", "event", "base", "log", "ssl", "page", "cache", "b", "user", "l", "r", "left", "client", "address", "pull", "Url", "service", "URL", "source", "image", "feed", "api", "path", "object", "update", "config", "li", "server", "uri", "route", "browser", "http", "file", "resource", "result", "coll", "bel", "location", "rel", "string", "ob"], "remoteName": ["fullPath", "localPath", "Remotename", "remoteUrl", "fullname", "fullKey", "remotename", "RemoteUrl", "RemotePath", "localUrl", " remotePath", "RemoteKey", "remotePath", " remoteUrl", "localKey", "remoteKey", "fullName", "RemoteName", " remoteKey", " remotename"], "localName": ["remoteFile", "locString", "locName", "globalString", "locname", "localPath", "LocalKey", " localname", "localFile", "LocalPath", "locUrl", "LocalName", "remoteUrl", " localKey", "locPath", "localString", " localString", "remotename", "localUrl", "globalFile", "remotePath", " localUrl", " localFile", "localKey", "remoteKey", "globalname", "globalName", "globalKey", "globalPath", "localname", "remoteString", " localPath", "Localname"], "host": ["localhost", "loc", "hard", "database", "head", "type", "remote", "format", "conn", "domain", "address", "proxy", "hop", "service", "driver", "path", "h", "config", "arch", "server", "uri", "http", "Host", "prefix", "src", "header", "target", "dir", "home", "addr", "string", "ip", "username"], "prot": ["prop", "family", "channel", "addr", "pt", "lat", "proc", " plat", "ssl", "ht", "conn", "part", " proto", "Prot", "txt", "att", "password", "client", " protocol", "cli", "api", "col", "pattern", "config", "conv", "platform", "pass", "afi", "cert", "pos", "prefix", "ocol", "stat", "ios", "pro", "ref", "def", "rel", "serv", " protocols", "rot", "nat"], "port": ["f", "version", "point", "phone", "PORT", "type", "slice", "allow", "p", "pi", "timeout", "position", "direction", "future", "pr", "time", "size", "Port", "patch", "password", "address", "service", "hop", "proxy", "ort", "select", "value", "limit", "project", "path", "pid", "width", "number", "server", "uri", "pass", "file", "ports", "index", "priority", "target", "length", "string", "ip", "rest"], "cacheFile": ["remoteFile", "CacheDirectory", "basefile", "outputConnection", "localfile", " cacheLine", " cachefile", "cacheConnection", "proxyHandle", "localFile", "outputFile", "baseFile", "CacheDir", "achePlace", "cacheMessage", "storageFile", "cacheDirectory", " cacheDir", "cacheLine", "remoteUrl", "fakeFile", "sessionDir", " cacheFiles", "localDir", "tempDir", "acheFiles", "sessionFiles", "cacheUrl", "tempfile", "fakeUrl", "storageFiles", "localFiles", "cacheHandle", "Cachefile", "cachePlace", "storagePlace", "proxyfile", "cacheFiles", " cacheHandle", "CacheUrl", "cachefile", "proxyDir", "fakeLine", "tempHandle", "remoteLine", "outputMessage", " cachePlace", "baseMessage", "CacheFile", " cacheConnection", "remotefile", "outputfile", "acheFile", "fakefile", " cacheMessage", "sessionUrl", "cacheDir", " cacheDirectory", " cacheUrl", "CacheFiles", "proxyFile", "localDirectory", "baseConnection", "tempFile", "sessionFile"], "urlConnection": ["URLconnection", "sslFile", "URLConnection", "slCode", "urlconnection", "slChannel", "httpCode", " urlFile", "cacheConnection", "cachePool", "cacheConn", "downloadEntry", "downloadConnection", " urlconnection", "webConnect", "fileConnection", "URLResponse", " urlChannel", " urlConnect", "urlPool", "slConnection", "cacheConnect", "fileConn", "urlEntry", "sslConnection", "urlPart", "filePart", "fileConnect", "downloadconnection", "slCommand", "sslResponse", "httpChannel", " urlCommand", "httpPool", "httpCon", "urlCon", "urlResponse", "urlConnect", "sslConn", "httpConnect", "downloadFile", " urlCode", "URLConn", "sslConnect", "urlCommand", " urlPool", "urlChannel", "httpconnection", "URLCon", "sslEntry", "urlCode", "sslconnection", "urlConn", " urlConn", "URLConnect", "httpResponse", " urlPart", "webconnection", " urlEntry", "URLPart", "webConnection", "httpCommand", "httpConn", "webCon", "urlFile", "httpConnection"], "httpURLConnection": ["httpCLConnector", "httpCLConnection", "httpREConnection", "httpSLCode", "upperRTransaction", "httpURLCode", "httpRNode", "upperRNode", " httpLLConstruction", "httpSLConnection", "httpRLConnector", "httpHTTPFunction", "httpREStatement", "httpHTTPQuery", "httpURQuery", "httpCLConnect", "httpSLconnection", "httpurlConnection", "httpRLClient", "httpURLConn", "httpMconnection", "upperURLNode", "httpWSNode", "httpLLconnection", "httpURNode", "httpBLQuery", "httpLLConnection", " httpUrlFunction", "httpUrlconnection", "httpDOMconnection", " httpUrlConnection", "httpMLFunction", "cacheURLClient", "httpUrlConnection", " httpHTTPConnection", " httpURLconnection", "httpRLConnection", "urlUrlClient", "httpBLFunction", "httpDateconnection", "httpURFunction", " httpLLConn", "cacheURLConnection", "httpBLOperation", "upperURLConnection", "httpREConstruction", "httpurlconnection", "httpurlStatement", "urlUrlStatement", "httpFormConnection", "httpURLFunction", "shortURLConnection", "httpREconnection", "httpMLconnection", "httpREClient", "upperURLconnection", "urlURLconnection", "httpRLConnect", "httpURLOperation", " httpHTTPQuery", "cacheURLConnect", "cacheUrlClient", "httpHTTPOperation", "httpWSTransaction", "httpURLClient", "httpMCode", "currentURLCode", "upperURLTransaction", "httpBLConnection", " httpUrlconnection", "httpUROperation", "shortSLConnection", " httpURLConn", "shortSLconnection", "httpURConnection", "httpURLNode", " httpLLConnection", "shortSLConnect", "httpUrlConnect", "httpFormConnect", "httpDateConstruction", "currentURLConnection", " httpHTTPFunction", "httpCLClient", "httpURLConstruction", " httpLLconnection", "httpURLconnection", "httpFormconnection", "httpURLStatement", "httpUrlFunction", "httpHTTPConnection", "httpSLConnect", " httpURLQuery", "urlUrlconnection", "httpWSconnection", " httpURLConnect", "currentURLconnection", "shortURLConnect", " httpURLOperation", "httpDOMFunction", "httpRConnection", "httpURTransaction", "currentURLConnect", "urlURLStatement", "httpDOMConnect", "httpUrlConnector", "httpMLConnect", "cacheUrlConnector", "httpDOMConnection", "httpUrlStatement", " httpURLFunction", " httpURLConstruction", "urlUrlConnection", "upperRconnection", "httpREConn", "urlURLClient", "httpMLConnection", "httpURconnection", "httpURLQuery", "httpLLConn", "httpURLConnector", " httpUrlConnect", "httpUrlClient", "urlURLConnection", "httpURLTransaction", "cacheURLConnector", "httpRLconnection", "httpurlClient", "httpLLConstruction", "cacheUrlConnect", "shortURLconnection", "httpWSConnection", " httpHTTPOperation", "httpDateConnection", "cacheUrlConnection", "httpRTransaction", "httpRconnection", "httpMConnection", "httpURLConnect", "upperRConnection", "httpDateConn", "httpMConnect"], "responseCode": ["statusStatus", "ResponseMessage", "statusCount", "ResponseCode", "statusType", "ResponseStatus", "replyMessage", "ResponseType", "statusCode", "replyType", "responseStatus", "replyCode", "ResponseCount", " responseMessage", "statusMessage", " responseStatus", "replyCount", "responseCount", "responseType", "responseMessage", " responseType"], "lastModified": ["lastModed", "lastMODIFIED", " lastMODined", "lastMinified", "lastEdIFIED", "New", "nextMODified", " lastModied", "lastEdified", "lastModIFIED", "lastmoded", "nextMODed", "lastMODied", "nextModIFIED", "nextMODied", "nextModied", "lastmodIFIED", " lastModined", " lastMODied", " lastMODIFIED", "lastEded", "lastmodified", "_", "lastMODified", "lastMinIFIED", " lastMODified", "lastmodied", "lastModied", "lastMinied", "this", "lastMODification", "lastmodification", "nextModification", "nextMODIFIED", "lastEdification", "lastMODed", " lastModIFIED", "lastModined", "s", "nextModified", "lastModification", "lastMinined", "lastMODined", "nextMODification", "nextModed"]}}
{"id1": "6470716", "id2": "14317425", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"st": ["est", "const", "f", "s", "sc", "put", "pt", "ct", "ist", "inst", "ast", "sth", "str", "fe", "class", "ste", "ld", "sts", "ust", "ST", "Str", "r", "fr", "std", "d", "t", "tt", "struct", "St", "sta", "stage", "cl", "code", "id", "src", "sb", "www", "sf", "ost", "stress", "ft", "string", "start", "rest"], "url": ["ul", "connection", "open", "sl", "f", "loc", "org", "fl", "ur", "gl", "stream", "web", "download", "pl", "log", "base", "ssl", "ll", "ls", "bb", "html", "b", "user", "blog", "page", "zip", "l", "bug", "err", "fr", "address", "Url", "URL", "build", "source", "feed", "image", "or", "hub", "path", "cl", "uri", "server", "http", "file", "id", "impl", "tool", "www", "coll", "bel", "host", "link", "string", "ob"], "fis": ["fiss", " fris", "afis", "lils", "flils", "bos", "FIS", "FIs", "flis", "fIs", "bi", "afiss", "afos", "afIs", "fi", "fips", "Fis", "lris", " fIS", " fi", "fli", "fliss", "fils", " fips", "Fiss", "bis", "flris", "zIS", " fiss", "Fips", " fils", "fris", "Fos", "Fris", "liss", "flIs", "zips", "zris", "fIS", "lis", "flos", "biss"], "zis": ["Ziss", "zipits", "zeisa", " zbis", "zisa", "Zis", "zipois", "zipisi", " zi", "zenisi", "zenais", "zipais", "ezIS", "zisi", "ziss", "zeis", "Zais", "zipis", "qi", " ziss", " zisi", "zeIS", " zIS", "ezips", "zois", " zits", " zisa", "qiss", "zIS", "zi", "zenis", " zais", "qbis", "ezisa", "zits", "zenois", "qis", "zips", "zeips", "ezis", "zbis", "zipi", "zipiss", " zois", "zipbis", "Zits", "zais", " zips"], "entry": ["nt", "reader", "extra", "si", "archive", "session", "auto", "ries", "ident", "info", "se", "ge", "country", "ie", "rc", "match", "lc", "Entry", "part", "inner", "je", "sea", "zip", "r", "ace", "line", "e", "cell", "key", "la", "address", "fr", "row", "comment", "dc", "parse", "image", "cat", "feed", "inc", "or", "spec", "object", "sec", "next", "enter", "li", "pe", "in", "file", "index", "ry", "result", "obj", "record", "cel", "exp", "ent", "de", "element"], "count": ["offset", "name", "_", "current", "depth", "allow", "type", "load", "en", "counter", "ind", "log", "base", "add", "more", "check", "cache", "size", "part", "line", "val", "max", "buffer", "list", "Count", "i", "limit", "feed", "use", "child", "parent", "sum", "default", "number", "read", "code", "c", "file", "id", "index", "len", "skip", "length", "write", "start", "end"], "data": ["reader", "error", "batch", "body", "results", "p", "info", "load", "str", "zero", "shift", "cache", "text", "size", "bytes", "content", "d", "buffer", "i", "image", "block", "feed", "value", "read", "number", "raw", "empty", "code", "DATA", "a", "len", "message", "result", "dat", "input", "length", "area", "alpha", "string", "start", "buf"], "fos": ["efosh", "fol", "fosh", "zol", "dfosi", "foses", "zOS", "efoses", "frosh", "Fol", "FOS", "fOS", "efos", "dfosh", "froses", "fosi", "znos", "fnos", "dfoses", "fros", "flol", "flnos", "dfos", "frosi", "efosi", "Fos", "flOS", "flos", "zos", "Fnos"], "dest": ["prop", "const", "cdn", "loc", "sup", "later", "slice", "dev", "stream", "cont", "sync", "comb", "di", "die", "inner", "output", "txt", "img", "done", "zip", "trans", "writer", "coord", "dist", "temp", "std", "dc", "test", "style", "source", "wh", "outer", "exit", "sum", "default", "south", "wb", "transform", "src", "des", "Dest", "flash", "result", "target", "out", "dat", "home", "desc", "de", "end", "tmp", "rest"]}}
{"id1": "4618237", "id2": "20310134", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"writeFileToFile": ["writeFile2File", "writeFilesToFile", "writeFileAsFiles", "writeFile2Channel", "writeFileAndFile", "writeFilesAsStream", "writeFileAndFiles", "writeFilesAsFiles", "writeFilesToFiles", "writeFileToStream", "writeFile2Files", "writeFilesToChannel", "writeFilesAsFile", "writeFileAndStream", "writeFilesToStream", "writeFileToChannel", "writeFilesAsChannel", "writeFileToFiles", "writeFileAsStream", "writeFileAsFile", "writeFileAndChannel", "writeFile2Stream", "writeFileAsChannel"], "fin": ["FIN", "inf", "f", "fen", "pin", "raf", "ori", "en", "fine", "kin", "Fin", "fat", "conn", "rf", "include", "rin", "din", "fn", "fi", "fr", "ini", "pins", "init", "arin", "rt", "thin", "inn", "ris", "file", "fa", "fd", "lin", "fp", "fm", "ln", "inv", "nir"], "fout": ["bin", "boff", "FOut", " fOut", " foff", "Fin", "rfOut", "rfin", "Foff", "bOut", "rfint", "bout", "Fint", "fOut", "fint", "foff", "rfout", " fint", "Fout"], "append": ["save", "open", "app", "ext", "opp", "spread", "batch", "pend", "send", "enc", "only", "printf", "optional", "add", "future", "text", "vert", "ended", "password", "flush", "padding", "pack", "want", "adjust", "ending", "update", "null", "protect", "flat", "atten", "except", "fail", "pad", "leaf", "push", "string", "end", "apply", "remove"], "inChannel": ["loginChannel", "innerChan", "innStream", " inchannel", "loginchannel", "INChannel", " inQueue", "inConnection", "INChan", "innerStream", "outStream", "Inchannel", "innchannel", "outQueue", "InChan", "InStream", "inchannel", "loginStream", "outchannel", "innerConnection", " inStream", "outChan", "inputConnection", "INchannel", "INConnection", "inputChan", "inputChannel", "inChan", "inputStream", "innerChannel", "inQueue", "innerchannel", "inStream", "innChannel", "INQueue", "InChannel", "INStream"], "outChannel": ["externalSocket", "inContext", " outContext", "outContext", "outStream", "outputChan", "inchannel", "externalChan", "externalChannel", "ioChan", "outchannel", "OutChan", " outChan", "outChan", "iochannel", "OutContext", "OutStream", "outSocket", "outputSocket", "ioStream", "Outchannel", "outputchannel", "ioChannel", "OutChannel", "inChan", "outputChannel", "inStream", " outchannel", "inSocket", "externalchannel"]}}
{"id1": "12428013", "id2": "6840241", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 0, "substitutes": {"polishOff": [" synchronishingOffline", " polishOffline", " synchronishDown", " polishingOn", " polishingDown", " polishingOffline", " synchronipeOff", " synchronishOffline", " polishOn", " synchroniceDown", " synchronishingOn", " synchronipeDown", " synchronipeOffline", " synchroniceOn", " synchronishingOff", " synchroniceOff", " synchronipeOn", " synchroniceOffline", " polishDown", " synchronishingDown", " synchronishOn", " polishingOff", " synchronishOff"], "monitor": ["Monitor", "username", "manager", "master", "container", "widget", "handler", "thread", "reason", "method", "m", "body", "mor", "state", "timeout", "counter", "umi", "log", "match", "control", "component", "status", "conn", "loader", "don", "clock", "callback", "dm", "member", "watch", "client", "sm", "condition", "image", "controller", "port", "or", "program", "oper", "driver", "object", "mon", "update", "config", "number", "consumer", "unit", "core", "duration", "pm", "period", "cher", "function", "module", "message", "annot", "stat", "timer", "cm", "mc", "report", "directory", "progress", "processor", "runner", "meter"], "from": ["connection", "loc", "name", "org", "origin", "actor", "at", "channel", "email", "remote", "range", "From", "type", "since", "base", "add", "vol", "component", "with", "user", "part", "size", "front", "by", "left", "false", "address", "back", "source", "or", "path", "form", "url", "attribute", "small", "code", "uri", "server", "route", "owner", "ce", "id", "prefix", "action", "about", "resource", "host", "contact", "ou", "who", "string", "start", "username"], "to": ["full", "connection", "su", "into", "name", "version", "two", "eto", "TO", "range", "type", "remote", "info", "table", "To", "top", "base", "with", "user", "size", "toc", "until", "by", "repl", "left", "o", "key", "address", "dest", "reply", "go", "source", "database", "value", "url", "uri", "server", "io", "file", "pos", "prefix", "po", "token", "target", "out", "about", "location", "ref", "so", "resource", "site"], "renameTo": ["renewFrom", "renAMEWill", "reageTo", "renAMETarget", "rennameto", "renAMEToken", "renenameTo", "relenameFrom", "renalFrom", " renAMETarget", "rennameTo", "renenameFrom", "renamelFor", " RenseTO", " RenseFor", "renameUrl", " RenAMEFor", "renenameTarget", "relameto", "renenameUrl", "reameto", "renokeOf", "renAMEFor", " renameTarget", "renAMETo", " RenameTarget", " RenameWill", "renameOf", "relalTarget", "renalTarget", "renageToken", "relenameUrl", "renamWill", "renamelTo", "relameTarget", "renributeWill", "renamTarget", " RenAMEWill", "relalTo", "renokeFrom", " RenameOf", "renamelTO", "renameFor", "renseTo", "relalto", "renributeFor", "renokeUrl", " RenseTo", "renageTo", "renameWill", "renseFor", "rennameFrom", "reageTO", "renokeFor", " renameFrom", "renalToken", " renAMETo", "renamelOf", "renewTo", "renalto", "renamFor", "rennameTarget", "renalTO", "relameUrl", "relameFrom", " RenseOf", "renributeTo", "renributeTarget", " RenAMETo", "renageTO", "renAMEUrl", "renseOf", "renoketo", "reameTo", "relalFrom", " renAMEFrom", "relenameTo", "renameTarget", "renAMEto", "reageto", "renenameto", " RenAMETarget", "renameTO", " RenameTO", "reameTO", "renameto", "renokeTo", "relameTo", "renamTo", "renAMEFrom", "renewTarget", "renameToken", "reageToken", "renseTO", "relenameto", "renAMETO", " RenameFor", "reameToken", " RenameTo", "renageto", "renameFrom", "renalTo", "renokeTO"], "ftpClient": ["afttStream", "ctcpServer", "ftpcConnection", "ftbCan", " ftpoCloud", "ftpChannel", "fttpHost", "ftpcHelper", "ftpClass", "ftcServer", "ftpiHost", " ftiClient", " ftpGuest", "ftpcCenter", " ftlCenter", "ftapiCloud", "ctcpResource", "ctcpClient", " ftoCan", "ftpsClass", " ftnHost", "ftfpResource", "ftoCan", "ftcpCloud", "ftpoCenter", " fttpClass", " ftoServer", " ftpCloud", " ftpiServer", "ctpChannel", " ftiServer", "ftcClient", "ftpGuest", "ctcpChannel", "ftbClient", " ftiGuest", "ftmResource", "ftiServer", " ftlCommunity", " fticlient", " ftlConnection", "ftpHost", " ftpiHost", "ftpResource", "ftpControl", "ftpcServer", "ftcpCenter", "ftpsControl", " fttpContainer", "fttpClass", "ftpcControl", "ftoHost", "ftpHelper", "ftcpConnection", "ftfClient", "ftcpResource", "ftpiServer", " ftpServer", "afttClient", " ftpoCenter", " ftapiClient", "ftcpChannel", "ftlClient", "fticlient", "ftiClient", "ftpoCloud", "ftcclient", "ftpiClient", "ftpCenter", "ctpResource", "ftcpGuest", "ftcpHost", " ftpiChannel", "ftnServer", " ftpclient", "ftfpChannel", "ftcGuest", "ftnHost", "fttpServer", " ftpChannel", " ftapiServer", "fttpClient", " ftpCenter", "fttClient", "fttpChannel", "ftpCloud", " ftpiClient", "fttpCan", " ftoClient", "ftcpHelper", "ftpConnection", "ftpclient", "ftfCloud", "ctpServer", " ftnClient", "ctpClient", " ftpConnection", "ftpCan", "ftapiHelper", "ftoServer", "aftpClient", "ftiGuest", "ftbrStream", "aftpStream", " ftoHost", "ftfpServer", "ftmChannel", " ftpContainer", "ftapiServer", "ftpCommunity", " ftpCan", "ftoClient", "ftfpCenter", "ftbrClient", "ftlConnection", "ftpcCloud", "ftfpClient", " ftapiCloud", "fttpContainer", "ftpcClass", " ftpControl", " ftpClass", "ftcpCommunity", "ftmServer", " ftlClient", "fttStream", "ftlCenter", "ftbHost", " ftapiHelper", "fttpControl", "ftpContainer", "ftcpClient", "ftpcCommunity", "ftpServer", "ftcpServer", "ftbServer", " ftpHelper", "ftfCenter", "ftfpCloud", "ftcpclient", "ftpiChannel", " ftpCommunity", "ftapiClient", "ftnClient", "ftlCommunity", "fttpStream", "ftpsClient", " ftnServer", "ftpoClient", " fttpClient", " fttpControl", "ftpStream", "ftmClient", " ftpoClient", "ftpcClient", "ftpcContainer", "ftpsContainer", " ftpHost"], "ftpHolder": ["ftpWather", "ftphook", "ftpShook", "ftpHold", "ftpChook", "ftpWold", "ftpHook", "ftpHander", "ftpCholder", "ftpWorkold", "fttpChook", "ftpChander", "ftpShander", "ftpHard", "ftphard", "ftpWholder", "fttpChard", "ftpHholder", "fttpHard", "ftpcWold", "ftpcWholder", "ftpWorkather", "ftpChard", "ftpWorkolder", "ftphold", "ftpholder", "fttpCholder", "ftpcHholder", "fttpHook", "ftpcWather", "fttpHolder", "ftphander", "fttpHander", "ftpcHold", "ftpcWolder", "ftpWorkholder", "ftpcHolder", "ftpShard", "ftpcHather", "ftpHather", "ftpWolder", "ftphather", "fttpChander", "ftpSholder", "ftphholder"], "iter": ["reader", "er", "f", "loc", "keep", "ver", "it", "ator", "ener", "gener", "iv", "info", "set", "ipper", "inner", "walker", "former", "size", "ite", "e", "err", "its", "ter", "izer", "list", "i", "entry", "ner", "init", "inc", "limit", "or", "collect", "oper", "outer", "chain", "next", "enter", "iterator", "ir", "ser", "finder", "http", "itter", "in", "file", "Iterator", "id", "index", "cher", "Iter", "result", "inter", "coll", "skip", "ip", "end", "over"], "element": ["data", "container", "type", "definition", "activity", "letter", "section", "service", "air", "next", "Element", "number", "owner", "module", "item", "header", "coll", "resource", "option", "email", "el", "variable", "page", "inner", "output", "entity", "content", "member", "key", "value", "or", "parent", "environment", "attribute", "document", "folder", "action", "result", "node", "reader", "per", "atom", "expression", "component", "part", "line", "e", "cell", "this", "style", "empty", "connection", "er", "layer", "event", "optional", "plugin", "match", "text", "instance", "article", "comment", "entry", "child", "object", "server", "et", "ele", "token", "input", "ee", "editor"]}}
{"id1": "22022715", "id2": "8320469", "code1": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 1, "substitutes": {"digest": ["mdest", "doure", "genests", "generest", "digure", "genested", " digests", "digit", "Digester", "dger", "generester", "digested", "dester", "genest", "doest", "doested", "doit", "digester", "dit", "generit", "mdure", "mdested", "dest", "mdester", "digger", "Digure", "Digested", "mdit", "genester", "digests", "Digit", "generger", " digested", " digester", "Digest", "Digests", "mdger"], "s": ["f", "data", "ds", "g", "m", "services", "p", "ns", "os", "is", "ssl", "ls", "words", "b", "bytes", "rs", "e", "password", "lines", "strings", "d", "i", "S", "source", "ws", "gs", "n", "ps", "c", "params", "a", "message", "es", "ss", "sb", "ms", "sym", "string", "ses"], "ret": ["nt", "alt", "ext", "data", "pat", "al", "addr", "arr", "det", "rev", "array", "info", "Ret", "Return", "match", "fun", "RET", "success", "repl", "val", "key", "reply", "xt", "secret", "std", "continue", "value", "hash", "default", "pass", "rt", "valid", "result", "res", "out", "bf", "def", "replace", "mem", "rets", "re", "arg", "obj"], "md": ["meta", "df", "bd", "cb", "mag", "mg", "cd", "wd", "mad", "dd", "m", "ma", " MD", "mt", "arm", "ind", "me", "dig", "di", "mb", "am", "mac", "cmd", "dm", "um", "d", "MD", "gd", "mo", "mod", "amd", "mp", "rpm", "metadata", "mm", "pm", "mc", "od", "mand", "pd", "pg", "hd", "nm", "Cmd", "ad", "editor", "pkg"]}}
{"id1": "9210168", "id2": "22879400", "code1": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "code2": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "label": 0, "substitutes": {"run": ["job", "background", "name", "apply", "un", "stop", "create", "launch", "base", "add", "loop", "register", "inner", "output", "work", "display", "runs", "test", "call", "show", "image", "process", "exec", "update", "code", "unit", "in", "running", "out", "render", "replace", "home", "execute", "invoke", "Run", "start", "runner"], "url": ["sl", "f", "loc", "ur", "remote", "str", "base", "ssl", "loader", "b", "plug", "user", "l", "err", "fr", "address", "Url", "service", "source", "URL", "image", "api", "path", "lr", "server", "uri", "nr", "browser", "http", "file", "id", "resource", "rl", "re", "string"], "fis": ["pIs", "fiss", "bIs", "fisa", " fisa", "flisa", "FIS", "bIS", "FIs", "piss", "flis", " fais", "fIs", " fIs", "pisa", "bais", "pis", "Fis", " fIS", "fliss", "Fiss", "bis", "Fais", " fiss", "flIs", "fais", "fIS", "biss"], "r": ["rh", "reader", "mr", "er", "f", "ri", "s", "ur", "R", "kr", "p", "vr", "ru", "rc", "is", "pr", "b", "rf", "cr", "rs", "ar", "l", "err", "fr", "e", "rus", "rr", "rb", "i", "d", "BR", "hr", "ir", "nr", "rt", "c", "wr", "sr", "rar", "tr", "res", "resource", "rl", "ler", "Reader", "rx"], "br": ["be", "reader", "mr", "Br", "ob", "HR", "arr", "vr", "str", "bh", "bl", "bb", "yr", "b", "B", "bridge", "cr", "err", "fr", "dr", "rb", "BR", "hr", "brush", "ch", "lr", "rt", "browser", "wr", "gr", "sr", "bro", "tr", "res", "result", "bf", "fb", "bc", "buf", "rx"], "line": ["le", "sl", "f", "data", "name", "char", "el", "ge", "str", "letter", "bl", "base", "lc", "inline", "part", "b", "cr", "l", "shell", "cell", "lines", "lf", "key", "column", "row", "buffer", "i", "comment", "style", "entry", "Line", "character", "cl", "li", "code", "number", "nl", "pass", "split", "file", "id", "LINE", "word", "sel", "lin", "header", "link", "rl", "string", "liner", "end"], "sb": ["SB", "BB", "bm", "cb", "bd", "sg", "si", "bj", "sn", "gb", "bs", "buff", "sth", "bt", "eb", "bh", "xb", "bl", "binary", "bb", "ls", "rob", "b", "mb", "erb", "sv", "bp", "rb", "buffer", "storage", "abb", "db", "lb", "zb", "bis", "lr", "sa", "ab", "pb", "amb", "wb", "nb", "src", "bsp", "bf", "sf", "usb", "obb", "fb", "bc", "ib", "buf"], "text": ["connection", "ext", "data", "name", "info", "str", "letter", "format", "output", "b", "txt", "content", "translation", "test", "buffer", "comment", "source", "entry", "value", "Text", "path", "object", "config", "code", "id", "title", "message", "result", "TEXT", "input", "string", "obj", "font"]}}
{"id1": "14047629", "id2": "20100809", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"source": ["reader", "connection", "ources", "session", "remote", "stream", "comp", "info", "load", "proc", "status", "class", "ource", "text", "loader", "inner", "content", "SOURCE", "service", "buffer", "proxy", "image", "parse", "path", "parent", "object", "exec", "request", "project", "config", "transfer", "document", "server", "in", "file", "src", "resource", "target", "result", "input", "Source", "fp", "out", "cp", "processor"], "process": ["pipe", "job", "open", "app", "machine", "master", "cess", "session", "thread", "press", "command", "method", "python", "processing", "task", "worker", "p", "proc", "class", "status", "copy", "loop", "share", "output", "work", "display", "parser", "console", "call", "run", "image", "port", "path", "exec", "parent", "pid", "project", "object", "system", "document", "post", "processor", "the", "file", "script", "index", "resource", "target", "result", "Process", "progress", "program", "use", "node"], "processStdOut": ["processStdOUT", "processSttOutput", "processStDOUT", "processStdinOut", "processSTdinOUT", "processStDObj", "processSttOUT", "processStdObj", "processStdOutput", "processSTdOUT", "processStdinObj", "processStDOutput", "processSTdinOutput", "processSTdOut", "processSTdinObj", "processSTdinOut", "processSTdObj", "processSttOut", "processStdinOUT", "processStDOut", "processSttObj", "processSTdOutput", "processStdinOutput"], "processStdIn": ["processStsin", "processStbIN", "processStdinOut", "processSttin", "processStdin", "processStsIns", "processStbIn", "processSttIn", "processStdinIN", "processStsIn", "processStrtInput", "processStbInput", "processStdInput", "processStdIN", "processStsInput", "processSttOut", "processStrdin", "processStrtIns", "processSttIN", "processStbin", "processSttInput", "processStdIns", "processStbIns", "processStrdIn", "processStrtin", "processStbOut", "processSttIns", "processStdinin", "processStrdInput", "processStrtIn", "processStdinIn", "processStrdIns"]}}
{"id1": "481364", "id2": "19096138", "code1": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"downloadFiles": ["DownloadImages", "downloadFile", "uploadItems", "processFiles", "DownloadFiles", "uploadImages", "downloadImages", "uploadFiles", "DownloadFile", "DownloadItems", "uploadFile", "downloadItems", "processImages", "processFile", "processItems"], "downloadFilesWorker": ["downloadFilesWorkER", "downloadFilesPoolER", "downloadFilesPooler", "downloadFilesLinkler", "downloadFilesLinkers", "downloadPhotosPooller", "downloadFilesPoolers", "downloadPhotosPoolers", "downloadFilesLinkER", "downloadFilesLinker", "downloadPhotosWorkers", "downloadPhotosPoolER", "downloadFilesWER", "downloadFilesWorkler", "downloadFilesWorkers", "downloadPhotosWorker", "downloadFilesPooller", "downloadPhotosPooler", "downloadFilesWer", "downloadFilesWler", "downloadFilesWers", "downloadPhotosWorkER", "downloadPhotosWorkler"], "startDownloadDate": ["startUploadData", "startFileDate", "startFileTime", " startDownloadMark", " startDownloadDay", "StartDownloadData", "startReviewData", "startFileMark", "StartReviewData", " startDownloadStatus", "startUploadMark", "startInstallYear", "startInstallTime", "startUploadTime", "startDownloadYear", "startReviewDate", " startDownloadTime", "startPullData", "StartReviewYear", "startUploadDate", "startImportDay", "StartReviewTime", "startPullTime", "startDownloadTime", "startInstallDay", "StartReviewDate", " startUploadData", "startImportDate", " startUploadTime", " startUploadDate", "StartDownloadTime", "startImportStatus", "startDownloadDay", " startUploadMark", "startUploadDay", "startImportTime", "startInstallDate", "startFileData", "startDownloadData", " startUploadStatus", "StartDownloadYear", "startReviewYear", "startDownloadMark", "startUploadStatus", "startPullDate", "startPullMark", "StartDownloadDate", "startUploadYear", "startInstallData", "startDownloadStatus", " startUploadDay", "startReviewTime", " startDownloadData", "startInstallStatus"], "refreshSpeed": ["defractionStep", "defractionSpeed", "defractionScore", "refractionSpeed", "refreshStep", "refractionScore", "defreshStyle", "refetchStyle", "refetchSpeed", "defreshScore", "defractionStyle", "refetchScore", "refetchStep", "refillStep", "refractionStyle", "refillSpeed", "refillScore", "defreshStep", "defreshSpeed", "refractionStep", "refillStyle", "refreshStyle", "refreshScore"], "lastDate": ["firstDay", " lastTime", "firstTime", "LastDate", " lastData", "lastTime", " lastDay", "LastData", "lastDay", "lastData", "LastTime", "firstData", "firstDate", "LastDay"], "totalSizeRead": [" totalSizeREAD", "totalNameRead", "totalUrlReader", "totalUrlREAD", "totalsizeRead", "totalSizeEx", "totalTimeWritten", "totalSectionReader", "totalsizeWritten", "totalNameNeed", "totalNumberWritten", "totalsizeEx", "totalSectionWritten", "TotalSizeNeed", "totalSectionRead", "TotalSizeRead", "TotalNumberEx", "totalNumberNeed", "totalSizeNeed", "totalSizeWritten", "totalNumberEx", "totalNumberReader", "totalTimeRead", "TotalSizeEx", "totalStringWritten", "totalTimeEx", "TotalSizeWritten", " totalNumberREAD", "totalNumberREAD", "totalUrlWritten", "totalNameWritten", "TotalNumberNeed", "totalStringNeed", "totalSizeREAD", " totalSizeReader", "totalSectionREAD", " totalNumberReader", "TotalNumberRead", "totalStringRead", " totalSizeWritten", " totalNumberWritten", "totalSizeReader", "totalUrlRead", "TotalNumberWritten"], "totalNumberRead": ["totalnumberFound", "totalAmountread", " totalNumberWrite", " totalSizeWrite", "totalnumberread", " totalNumberFound", " totalnumberWritten", "totalSizeFound", "totalNumWritten", " totalNumberread", "totalNumRead", "totalAmountWritten", "totalLengthWrite", "totalNumberWritten", "totalStringread", "totalLengthread", "totalnumberRead", "totalSizeread", " totalnumberread", "totalNumFound", "totalSizeWritten", "totalNumberFound", " totalnumberRead", "totalAmountRead", "totalLengthWritten", "totalNumberread", "totalStringWritten", "totalNumread", "totalSizeWrite", " totalSizeread", "totalAmountWrite", "totalNumberWrite", "totalStringRead", " totalSizeWritten", " totalNumberWritten", "totalLengthRead", "totalnumberWritten", " totalnumberFound"], "photo": ["job", "username", "pic", "profile", "login", "opus", "data", "phone", "widget", "ickr", "lo", "audio", "slice", "language", "pin", "layer", "info", "gal", "phot", " photographer", "gallery", "sharing", "album", "copy", "picture", "page", "video", "jp", "pixel", "instance", " photograph", "l", " photos", "collection", "journal", "member", "single", "avi", "la", "vision", "entry", "image", "api", "large", " photography", "project", "filename", "facebook", "document", "camera", "friend", "person", "room", "photos", "favorite", "item", " Photo", "Photos", "cover", "record", "result", "jpg", "Flickr", "voice", "Photo", "json", "trial", "media", "obj", "student", "license", "opa"], "url": ["open", "sl", "loc", "name", "org", "channel", "socket", "stream", "web", "download", "ssl", "position", "page", "conn", "user", "l", "client", "address", "Url", "URL", "source", "image", "api", "path", "response", "system", "config", "document", "uri", "server", "http", "file", "resource", "www", "out", "contact", "link", "host", "location", "string"], "connection": ["reader", "director", "loc", "channel", "socket", "handler", "database", "session", "stream", "body", "info", "web", "application", "control", "position", "conn", "l", "client", "connected", "URL", "which", "image", "connect", "api", "or", "response", "context", "document", "uri", "server", "io", "http", "c", "in", "function", "uno", "con", "out", "directory", "Connection", "communication", "bc"], "dis": ["reader", " Dis", "data", "loc", "channel", "dl", "DIS", "det", "body", "to", "non", "Dis", "info", "web", "mor", "se", "rec", "di", "conn", "pre", "dist", "fr", "normal", "service", "lib", "ws", "api", "or", "ui", "no", "io", "http", "file", "pos", "des", "resource", "res", "con", "out", "dir", "pro", "coll", "re", "serv", "de", "device"], "fos": ["phOS", "fis", "Foses", "foses", "bos", " fis", "fose", "FOS", "Fops", "fOS", "Fose", "fou", " fose", "Faos", "paos", " foses", "boses", "fops", "Fis", "phaos", "bis", " faos", "pou", "pOS", "bops", "Fos", "pos", "phos", "phou", "faos", "bose", "Fou", " fops", "baos"], "b": ["be", "job", "bin", "cb", "f", "bit", "batch", "gb", "bs", "boot", "p", "buff", "eb", "xb", "binary", "base", "bl", "bb", "B", "mb", "br", "bytes", "l", "r", "e", "rb", "buffer", "emb", "bar", "db", "lb", "ba", "v", "n", "ab", "c", "pb", "split", "wb", "sb", "bf", "nb", "ob"], "sizeRead": ["SizeRead", "scaleRead", "sizeWalk", "sizeWrite", "izeUse", "sizeIn", "nowRead", "stringWrite", "stringReader", "externalFind", " sizeLoad", "sizeLoad", "sizeReader", "stringFind", " sizeReader", "sizePass", "lengthRead", " sizeWalk", "izePass", "lengthPass", "lengthFind", "externalRead", " sizeWrite", "SizeUse", "scaleWalk", " sizeUse", "nowReader", "SizeIn", "SizeFind", "externalWrite", "SizeWalk", "nowFind", "izeReader", "nowLoad", "izeIn", " sizeFind", "sizeFind", "izeRead", " sizeIn", "sizeUse", "lengthReader", "stringRead", "lengthLoad", " sizePass", "scaleFind", "externalReader"], "totalDiffTime": ["finalDiffCount", "totalDistRate", "finalDiffTime", "totalDistCount", "totalChangeTime", "totalDiffTimes", "partialDiffTimes", "totalDeltaCount", "totalDeltaSpeed", "totalDiffRate", "totaldiffSpeed", "totaldiffTime", "totaldiffCount", "finaldiffRate", "totalDiffSpeed", "finaldiffCount", "totalDistSpeed", "partialDiffSize", "totaldiffSize", "partialDiffTime", "finalDiffRate", "totalDiffSize", "totalChangeTimes", "totalDiffCount", "finaldiffTime", "totalDeltaRate", "finalDiffSpeed", "totaldiffTimes", "totalChangeSize", "totalDeltaTime", "totalDistTime", "totaldiffRate", "finaldiffSpeed"], "totalSpeed": ["TotalDiff", " totalRate", "TotalTime", " totalspeed", "tspeed", " totalTime", "completeSpeed", "totalAverage", "completeRate", "totalspeed", "tRate", "tSpeed", "TotalSpeed", "validAverage", "completeAverage", "completeDiff", "totalTime", "validRate", "totalDiff", "validDiff", "TotalRate", "validSpeed", "totalRate", "Totalspeed", "TotalAverage", "tTime"], "list": ["full", "ul", "layout", "lp", "fl", "pool", "batch", "complete", "table", "slice", "low", "type", "array", "cont", "st", "p", "stack", "not", "load", "detail", "gallery", "set", "bl", "status", "ls", "page", "part", "all", "l", "left", "collection", "see", "la", "best", "test", "source", "entry", "live", "cli", "object", "cl", "lists", "li", "view", "code", "LIST", "queue", "coll", "record", "result"]}}
{"id1": "13783898", "id2": "5138455", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToStream", "encodeFiletoStream", "encodeString2Stream", "encodeFiletoFile", "encodeStringToString", "encodeString2String", "encodeFileToStream", "encodeFileToString", "encodeFileFromFiles", "encodeFile2Files", "encodeStringToFiles", "encodeFile2String", "encodeStringToFile", "encodeFileFromString", "encodeString2Files", "encodeFileFromFile", "encodeFiletoString", "encodeFile2Stream", "encodeFileToFiles", "encodeFiletoFiles", "encodeString2File", "encodeFile2File", "encodeFileFromStream"], "infile": ["inputFile", "inputfilename", "Infiles", "outfilename", "infilename", "inputfile", "outFile", "inputfiles", "outfiles", "infp", "inputfp", "outfp", " infilename", " infp", " infiles", "infiles", "Infilename", "InFile", "Infile", "inFile"], "outfile": ["newFile", "outputfilename", "Outfile", "outfilename", "infilename", "outFile", "Outfolder", " outfp", " outfilename", "infp", "newfolder", "outname", "outfp", " outname", " outFile", "Outname", " outfolder", "outputfp", "newname", "newfile", "outputfile", "infolder", "OutFile", "outputfolder", "outfolder"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "vin", "base", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "image", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "copy", "conn", "cache", "again", "output", "inner", "writer", "work", "line", "err", "off", "client", "o", "OUT", "lib", "source", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "post", "io", "net", "file", "up", "co", "on", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "reader", "border", "uffer", "iter", "data", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "len", "queue", "input", "result", "length", "write", "fb", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "close", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "input", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "modified", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "respons", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "14820302", "id2": "9081749", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 1, "substitutes": {"innerProcess": [" innerWrite", "innerprocess", "subWrite", "binaryWrite", "subConnect", "innerWrite", "innerConnect", "binaryConnect", " innerprocess", "binaryprocess", "subProcess", "subprocess", " innerConnect", "binaryProcess"], "curi": ["lciri", "Cunit", "lcunit", " curl", "Ciri", "lcri", "papi", "Curl", " cui", "puri", "Cui", "lurl", "Capi", " capi", " cri", "lcui", "cui", "lcuri", "lcgui", "fURI", "capi", "lURI", "Cri", "luri", "curl", "fri", "pURI", "cunit", " cgui", "lcURI", " cURI", "fui", "furi", "pri", "Curi", "CURI", "cgui", "cri", "Cgui", " cunit", "firi", "ciri", "lri", "cURI"], "regexpr": ["recrepl", "Renexp", "reggexpl", "Regexpr", "regexr", "prenexp", "rerupl", "pregexpl", "Regexpre", "regnexper", "regexpl", "recrep", "prenexpr", "RegexPR", "rerepr", "Renexpre", "regnexpl", "renexpr", "pregexp", "rerupr", "recreer", "relexpr", "regexpre", "rerer", "rereper", "reruer", "reggexper", "RenexPR", "recrepre", "regexp", "pregexer", "regexer", "renexer", "renexpl", "regexPR", "reggexpr", "pregexpr", "recrePR", "regnexr", "recepr", "relexpre", "recer", "Renexpr", "renexr", "rerup", "reggexr", "prenexpl", "regexper", "regnexpr", "receper", "Regexp", "renexper", "relexPR", "recrepr", "prenexer", "renexpre", "relexp", "renexp", "renexPR", "rerepl", "recepl"], "cs": ["cb", "cn", "cos", "sc", "bs", "ds", "ca", "icks", "sync", "acks", "ins", "ns", "cms", "ics", "ec", "os", "pc", "codes", "rc", "lc", "cer", "ls", "cells", "cache", "css", "cing", "conn", "cr", "rs", "wcs", "ks", "cc", "ci", "ctx", "qs", "cf", "js", "ces", "spec", "ars", "vs", "gs", "cases", "fs", "acts", "ps", "details", "c", "ce", "ced", "acs", "cks", "cas", "coll", "ss", "tc", "cm", "CS", "ches", "ms", "es", "cp", "ac", "cers", "cus", "ios", "bc", "Cs", "cons"], "digest": ["signEST", "igested", "hashcher", " diger", "digit", " digests", "hashger", " digcher", "diggest", "Digester", "biggest", "hashester", "digested", "Digcher", "signests", "bigests", "digester", "Digity", "digEST", "digcher", "logit", "bigest", " digger", "digity", "digger", "logester", "bigEST", "signester", " digEST", "Digested", "signested", "Digger", "diger", "logest", "signer", "igity", "signgest", "Diger", "logger", "signest", "signger", "igester", " digity", "Digit", " digit", "hashest", "digests", " digested", "igest", " digester", "Digest", " diggest"], "s": ["sl", "su", "f", "data", "si", "ds", "g", "bs", "groups", "services", "sets", "sync", "p", "ns", "settings", "str", "os", "binary", "is", "ls", "ans", "u", "b", "abs", "obs", "bytes", "l", "r", "rs", "e", "o", "address", "strings", "S", "ws", "t", "js", "h", "v", "sum", "gs", "n", "ps", "c", "states", "sb", "ss", "ms", "sym", "string", "ses"], "m": ["bm", "mr", "gm", "machine", "rm", "p", "me", "match", "om", "imm", "am", "M", "hm", "wm", "r", "dm", "e", "vm", "ym", "sm", "map", "mo", "tm", "v", "mi", "man", "mm", "c", "pm", "cm", "mc", "fm", "ms", "nm", "string"], "newDigestValue": ["newDigestVal", "newSignestValue", "newDigESTString", "newDigesterKey", "newDigeterKey", "newSignestKey", "newDigesterValues", "newSignestedValue", "newDigESTValue", "newSignestValues", "newDigESTValues", "newSignestedString", "newSignestedValues", "newDigeterString", "newDigeterVal", "newDigestedKey", "newDigeterValue", "newDigestedValues", "newDigestedValue", "newSignestString", "newDigestString", "newDigestedString", "newDigesterVal", "newDigestKey", "newDigestedVal", "newDigesterValue", "newDigESTKey", "newDigesterString", "newDigestValues", "newSignestedKey"]}}
{"id1": "5543349", "id2": "14191679", "code1": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 0, "substitutes": {"loadMFileViaWeb": ["loadMFileviaWeb", "loadMFileUsingweb", "loadMFileUsingWeb", "loadMFilesviaWeb", "loadMFilesviaweb", "loadMFileviaweb", "loadMFileViaweb", "loadMFilesViaWeb", "loadMFilesViaweb"], "codeBase": ["knowledgeBase", "codebase", "CodeUrl", " codeLocation", "addressbase", " codebase", "Codebase", "knowledgebase", "knowledgeFile", "CodeBase", "knowledgeName", "codeFile", "CodeName", "codeUrl", "CodeLocation", "knowledgeLocation", "knowledgeUrl", "addressUrl", "codeLocation", "addressName", "addressBase", "codeName", "CodeFile", " codeFile"], "directoryAndFile": ["DirectoryOrFilename", "directoryWithfile", "directoryOrSourceFile", "directoryandFiles", "directoryAndFiles", "DirectoryAndFile", "filenameandFile", "filenameAndfile", "directoryAndSourceFile", "DirectoryAndfile", "directoryOrFiles", "filenameAndFiles", "directoryWithFiles", "DirectoryAndSourceFile", "DirectoryOrfile", "DirectoryAndFilename", "filenameAndFile", "directoryWithFilename", "directoryandFilename", "directoryOrFile", "directoryOrFilename", "filenameAndFilename", "directoryandSourceFile", "directoryFromSourceFile", "directoryOrfile", "directoryFromFile", "filenameandFiles", "directoryWithFile", "directoryandFile", "directoryandfile", "directoryAndFilename", "filenameandfile", "DirectoryOrSourceFile", "directoryFromfile", "directoryFromFilename", "DirectoryOrFile", "directoryAndfile", "filenameandFilename"], "mFileName": ["mLibraryHandle", "cmFilesPath", "MFilePath", "mFilesPath", "MFileName", "cmFilesKey", "mSourceFileHandle", "pFunctionInfo", "mStringname", "cmFilesName", "mStringName", "mFileFile", "cmFilePath", "pFileInfo", "mFilenameData", "MSourceFileHandle", "mClassType", "mClassInfo", "pFunctionName", "mFileType", "mFilenameFile", "mBaseFile", "MFileYear", "mFilesname", "mLibraryYear", "mLibraryPath", "mFilenamePath", "mClassData", "cmFileKey", "mFilenameHandle", "mSourceFilePath", "cmFileName", "MFileData", "mFunctionInfo", "mBasePath", "mFilenameName", "pFunctionPath", "mSourceFileName", "pFileType", "mFunctionType", "mFileYear", "mClassname", "mStringPath", "mClassName", "mFilesType", "MClassFile", "MClassName", "MClassPath", "mFilename", "mFileInfo", "mFilePath", "pFileName", "mFileKey", "mBaseData", "mFileHandle", "mLibraryName", "MClassData", "mFilenameYear", "mFunctionName", "mClassFile", "mBaseName", "MFileFile", "mFilesName", "mFunctionPath", "MSourceFileName", "cmFilename", "mClassPath", "mFilesKey", "MSourceFileYear", "mClassKey", "MSourceFilePath", "MFileHandle", "pFilePath", "mStringKey", "mFileData", "mFilesInfo", "mSourceFileYear", "cmFilesname", "pFunctionType"], "code": ["data", "name", "type", "codes", "class", "loop", "done", "callback", "go", "buffer", "exec", "age", "number", "c", "ce", "module", "message", "co", "header", "length", "error", "page", "content", "zip", "key", "address", "call", "count", "closure", "id", "result", "use", "x", "Code", "f", "coded", "create", "fore", "method", "info", "expression", "check", "test", "xxx", "java", "n", "script", " Code", "escape", "body", "status", "text", "comment", "cod", "func", "file", "frame", "cause", "string", "now"], "function": ["feature", "job", "connection", "f", " module", "error", "handler", "python", "Function", "array", "operation", "variable", "event", "lambda", " library", "expression", "library", "class", "fun", "rule", "component", "instance", "output", "section", " object", "callback", "fn", "functional", " functionality", "service", "call", "lib", "value", "object", "role", "form", "ctor", "document", "number", "unit", "func", "file", "module", "word", "action", "result", "fp", "string", "element"], "url": ["reader", "connection", "sl", "er", "f", "data", "channel", "socket", "ur", "stream", "web", "download", "jar", "base", "ssl", "log", "page", "blog", "b", "loader", "user", "plug", "l", "r", "key", "address", "Url", "i", "URL", "source", "image", "feed", "path", "update", "server", "uri", "browser", "http", "file", "ball", "resource", "bel", "string"], "in": ["reader", "bin", "er", "f", "data", "login", "socket", "ins", "stream", "In", "is", "ssl", "b", "inner", "loader", "din", "r", "ar", "IN", "err", "fr", "client", "ini", "buffer", "i", "image", "inc", "arin", "read", "io", "inn", "c", "file", "as", "a", "af", "input", "out", "ac", "gin", "serv", "Reader"], "inReader": ["InWriter", "outStream", "InStream", " inParser", "outParser", "inRead", "INFile", "INReader", " inStream", "inWriter", " inFile", "InRead", "InParser", "incReader", "InReader", "INWriter", "inParser", "INRead", "incWriter", "outReader", " inRead", "incRead", "inStream", "InFile", " inWriter", "outWriter", "incParser", "inFile"], "line": ["connection", "sl", "data", "name", "char", "error", "type", "str", "letter", "inline", "lc", "model", "part", "page", "text", "include", "content", "cr", "r", "l", "e", "cell", "key", "lf", "column", "lines", "row", "comment", "i", "entry", "source", "Line", "write", "lined", "character", "cl", "number", "pass", "pe", "c", "file", "id", "LINE", "word", "message", "frame", "lin", "record", "link", "re", "col", "string", "liner"], "end": ["open", "name", "End", "stop", "complete", "create", "END", "info", "load", "en", "set", "add", "all", "ended", "e", "block", "init", "ending", "id", "pos", "append", "start", "begin"]}}
{"id1": "5607440", "id2": "10451698", "code1": "    public void updateShoppingBean(String userId) {\n        Connection connection = null;\n        PreparedStatement preparedStatement1 = null;\n        PreparedStatement preparedStatement2 = null;\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            connection = DriverManager.getConnection(this.jdbcURL);\n            connection.setAutoCommit(false);\n            String preparedQuery = \"INSERT INTO dbComputerShopping.order(name,product_id,quantity,date,status)VALUES(?,?,?,?,?)\";\n            preparedStatement1 = connection.prepareStatement(preparedQuery);\n            Date date = new Date();\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            String orderDate = format.format(date);\n            Iterator iterator = this.cart.iterator();\n            Object[] shoppingInfo = null;\n            while (iterator.hasNext()) {\n                shoppingInfo = (Object[]) iterator.next();\n                ProductBean product = (ProductBean) shoppingInfo[0];\n                int quantity = (Integer) shoppingInfo[1];\n                preparedStatement1.setString(1, userId);\n                preparedStatement1.setInt(2, product.getId());\n                preparedStatement1.setInt(3, quantity);\n                preparedStatement1.setString(4, orderDate);\n                preparedStatement1.setString(5, \"confirmed\");\n                preparedStatement1.executeUpdate();\n            }\n            Object[] cartInfo = null;\n            preparedQuery = \"UPDATE components SET quantity=quantity-? WHERE comp_id=?\";\n            preparedStatement2 = connection.prepareStatement(preparedQuery);\n            for (Iterator i = this.cart.iterator(); i.hasNext(); ) {\n                cartInfo = (Object[]) i.next();\n                ProductBean product = (ProductBean) cartInfo[0];\n                int quantity = (Integer) cartInfo[1];\n                ProductListBean productList = new ProductListBean(jdbcURL);\n                ArrayList components = productList.getComponents(product.getId());\n                for (Iterator j = components.iterator(); j.hasNext(); ) {\n                    ComponentBean component = (ComponentBean) j.next();\n                    preparedStatement2.setInt(1, quantity);\n                    preparedStatement2.setInt(2, component.getId());\n                    preparedStatement2.executeUpdate();\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n            }\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement1.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement2.close();\n            } catch (SQLException ex) {\n            }\n        }\n    }\n", "code2": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "label": 0, "substitutes": {"updateShoppingBean": ["updateShoppingBoan", "updateShoppingBan", "updateShippingBeAN", "updateShoppingBans", "updateShoppingBeAN", "updateShoppingBeans", "updateShippingBean", "updateShoppingBoAN", "updateShoppingBoans", "updateShippingBeaning", "updateShippingBeans", "updateShippingBAN", "updateShoppingBeaning", "updateShippingBan", "updateShoppingBaning", "updateShoppingBAN", "updateShoppingBEAN", "updateShoppingBoaning", "updateShoppingBEan", "updateShoppingBEans", "updateShippingBans", "updateShoppingBEaning", "updateShippingBaning"], "userId": ["clientName", "userName", "userData", " userPath", " userName", "clientData", " userType", "clientId", "UserType", "clientPath", "userPath", " userID", "clientID", " userData", "userID", "UserId", "UserPath", "UserData", "UserName", "userType", "clientType", "UserID"], "connection": ["lock", "statement", "data", "name", "manager", "machine", "channel", "pool", "container", "session", "database", "BC", "table", "handler", "application", "state", "class", "log", "conn", "cache", "section", " Connection", "engine", "writer", "collection", "query", "client", "subject", "service", "connected", "condition", "db", "connect", "driver", "ion", "context", "general", "config", "document", "relation", "server", "c", "function", "management", "index", "result", "resource", "con", "directory", "sql", "Connection", "communication", "bc", "graph"], "preparedStatement1": ["preparedDocumentB", "preparedComment1", "preparedstatement01", "preparedDatabase2", "preasterObject01", "preakedQuery1", "preparedCommentl", "preakedQuery4", "preppedStatement1", "preparedContextone", "preparedMaterial1", "preparedEvent01", "preparedContext4", "preparedDocumentn", "preparedMaterial17", "preasterObject1001", "prearedSession0", "preparedStruct31", "preparedQueryl", "preparedComment1001", "preparedSession1", "preparedStatone", "preparedContext31", "preparedDatabase4", "preparedState1", "preparedStatement0", "preppedStatement3", "prefixedStruct0", "preakedQuery2", "preparedMaterial2", "prearedStatement1", "preculatedStatement01", "prearedSession1", "preuredStat4", "preasterObjectone", "preppedStatl", "preparedQuery4", "preparedTransaction9", "preparedSessionB", "preparedDatabase17", "preparedCommentone", "preuredStat1", "preferredQuery17", "prefixedStruct31", "preparedObject01", "preculatedStatement1", "preparedStatementone", "preparedstatement1", "preferredStatement2", "prefixedStatement0", "preppedStat3", "preparedSession2", "preparedStat3", "preparedDocument1", "preparedDocument2", "prefixedStatement9", "preparedstatementone", "preasterStatementone", "preparedQuery3", "preuredStatement4", "preparedComment3", "prearedStatementB", "prearedStatement2", "preparedQueryn", "preparedStatement3", "preparedQuery1", "prearedSession2", "preasterStatement01", "preparedDocumentone", "preakedQueryn", "preakedStatement2", "preppedStatementl", "preparedStruct9", "preparedSession0", "preparedStatement1001", "prefixedStruct9", "preparedState9", "preparedStatementB", "prefixedStatement1", "preparedstatement1001", "preuredStat31", "preasterObject1", "preparedEvent1", "prefixedStatement31", "preparedDatabasen", "preculatedEvent01", "preparedStatement31", "preparedStat31", "preparedQuery17", "preparedStatement17", "preparedObject1001", "preasterStatement1001", "preparedTransaction0", "preppedStat1", "preakedStatementn", "preparedObjectone", "preparedStatement4", "preparedTransaction31", "preparedStat1", "preparedStat4", "preuredStatone", "preparedStruct0", "preparedObject1", "preparedDocument4", "preparedStatementl", "preuredStatement1", "preparedDatabase1", "preuredStatement31", "preferredQuery2", "preparedStatement9", "prearedSessionB", "preferredStatement1", "preparedStatl", "preakedStatement1", "preparedStatement01", "preparedComment01", "preparedState31", "preasterStatement1", "preparedContext1", "preparedDocument0", "preakedStatement4", "preparedQuery2", "preparedQueryB", "preparedState0", "prearedStatement0", "preferredQuery1", "preparedDocument31", "preparedTransaction1", "preparedStatementn", "preparedStruct1", "prefixedStruct1", "preparedState01", "preferredStatement17", "preuredStatementone", "preparedQuery0", "preculatedEvent1"], "preparedStatement2": ["preparedSession52", "preparedStatement404", "preparedResult2", "prearedStatement1", "preuredstatementtwo", "preparedstatement404", "prearedSession1", "preparedConfiguration2", "prearedSession52", "preparedSession0", "preparedstatement8", "preparedStatement52", "preparedScopetwo", "preparedResult1", "preparedConfiguration52", "preparedScope404", "preuredStatementtwo", "preparedScope2", "preparedstatement2", "preparedCondition8", "prearedStatement0", "prearedSession0", "prearedStatement52", "preuredStatement8", "preuredstatement8", "preuredstatement2", "preparedStatementtwo", "preparedSession1", "preparedResult0", "preuredStatement2", "preparedSession2", "preparedConfiguration1", "prearedSession2", "preparedScope8", "preparedCondition404", "preuredstatement404", "preparedStatement0", "preparedCondition2", "preparedStatement8", "prearedStatement2", "preparedConfiguration0", "preparedResult52", "preuredStatement404", "preparedConditiontwo", "preparedstatementtwo"], "preparedQuery": ["previsedquery", "PreparedQuery", "preplannedquery", "perparedStatement", "precedStatement", "precedquery", "perparedquery", "PrearedQu", "Preparedquery", "prearedStatement", "PreppedStatement", "previsedStatement", "prevertedBody", "PrearedFunction", "PreparedStatement", "preppedQu", "PrearedQuery", "Preppedquery", "prevertedFunction", "prearedInfo", "preplannedCommand", "preppedBody", "preppedquery", "prevertedQu", "prearedCommand", "PreppedQuery", "PreparedInfo", "prearedQuery", "preparedBody", "perparedBody", "preparedInfo", "PreppedQu", "preplannedQuery", "perparedQuery", "prearedquery", "PrearedInfo", "perppedBody", "previsedBody", "PreparedFunction", "preculatedQuery", "PreparedQu", "precedCommand", "prevertedquery", "perparedCommand", "perppedquery", "perppedQuery", "peraredCommand", "precedQuery", "perppedStatement", "preculatedInfo", "preparedFunction", "prearedQu", "prevertedStatement", "preppedQuery", "preparedquery", "preparedQu", "peraredStatement", "peraredquery", "previsedQuery", "prevertedQuery", "preparedStatement", "prearedFunction", "previsedQu", "preculatedFunction", "preplannedStatement", "preculatedQu", "peraredQuery", "preparedCommand", "preppedStatement", "prevertedInfo"], "date": ["open", "tag", "data", "name", "version", "complete", "type", "change", "event", "grade", "set", "status", "log", "match", "model", "Date", "time", "year", "bug", "d", "style", "db", "use", "order", "form", "stage", "age", "update", "number", "document", "rate", "duration", "ate", "file", "index", "module", "message", "resource", "dat", "record", "day", "string", "start", "month", "dt"], "format": [" formatted", "data", "name", " formatting", "scale", "pretty", "point", "at", "handler", "type", "handle", "table", "method", "filter", "info", "printf", "str", " fmt", "set", "letter", "class", "sort", "add", "html", "wrap", "part", "time", "term", "writer", "and", "export", "dot", "parser", "atter", " Format", "parse", "style", "value", "process", "struct", "pattern", "form", "prep", "unit", "Format", "split", "transform", "function", "prefix", "cut", "join", "replace", "report", "print", "string"], "orderDate": ["OrderTime", "serverdate", "OrderName", "orderDat", " orderData", "OrderDate", "OrderData", "requestDate", " orderDat", " orderdate", "orderName", "orderTime", "orderDay", " orderDay", "serverData", "orderdate", " orderTime", "serverDate", "requestDay", "OrderDay", "requestName", "requestDat", " orderName", "orderData", "serverTime", "Orderdate", "OrderDat"], "iterator": ["reader", "iter", "er", "sequence", "it", "ator", "gener", "vector", "later", "runners", "database", "started", "slice", "creator", "atio", "stream", "ident", "set", "ie", "adder", "ater", "loop", "inner", "instance", "walker", "loader", "ators", "former", "until", "done", "engine", "writer", "collection", "parser", "random", "ter", "pointer", "step", "entry", "interstitial", "storage", "init", "starter", "driver", "oper", "outer", "path", "choice", "wrapper", "context", "enter", "uri", "server", "finder", "metadata", "runner", "Iterator", "series", "consider", "Iter", "river", "holder", "timer", "header", "inter", "append", "you", "processor", "start", "selection", "ski"], "shoppingInfo": ["shppingInfo", "shoutingInfo", "swoppingArea", "shoppingINFO", "hoppingMeta", "swopingInfo", "shppingMeta", "shoutingInf", "swoppingInf", "shoutingINFO", "hillingId", "shoppingInf", "shoppingData", "shopingArea", "shillingArea", "shillinginfo", "shopingInf", "shppingInf", "shopingMeta", "shillingMeta", "hoppingInfo", "hillinginfo", "swopingObj", "swoppingInfo", "shillingInf", "shoppingObj", "shoppinginfo", "hoppingInf", "shoppingArea", "shippingInf", "hillingInfo", "shillingInfo", "shppinginfo", "shoppingId", "shashingId", "shppingArea", "hillingMeta", "shillingData", "hoppingId", "swoppingObj", "shppingObj", "shippingInfo", "ShoppingInf", "hoppinginfo", "shillingObj", "hillingData", "shopingData", "shashingInfo", "shopingObj", "swopingInf", "hoppingData", "shashingInf", "shppingId", "shillingINFO", "ShippingINFO", "ShippingInf", "shillingId", "ShippingInfo", "shppingData", "hillingInf", "swopingArea", "shoppingMeta", "ShoppingInfo", "ShoppingINFO", "shopingInfo", "shippingINFO", "shashinginfo"], "product": ["feature", "data", "version", "type", "creator", "filter", "p", "Product", "per", "class", "plugin", "copy", "model", "position", "seller", "user", "output", "collection", "client", "pp", "payment", "service", "source", "image", "child", "production", "project", "process", "parent", "object", "band", "order", "property", "attribute", "products", "config", "relation", "pe", "cart", "module", "result", "resource", "contact", "target", "input", "company", "processor"], "quantity": ["compification", "necessification", "quantification", "primITY", "compance", "authority", "necessifier", "necessity", "quantality", "quantance", "mentality", "commentality", "compality", "primality", "authorance", "aquicity", "authorality", "quantifier", "primification", "quanticity", "compity", "aquality", "aquity", "compifier", "authoricity", "primity", "mentITY", "quantITY", "mentity", "commentifier", "primation", "quantation", "commentity", "compicity", "commentITY", "compation", "primifier", "necessation", "mentifier", "aquance"], "cartInfo": ["cartMeta", " cartList", " cartMeta", " cartSize", "frontInf", "cartList", "productSize", "contactList", "frontInfo", "cartData", " cartObj", "productInfo", "contactInf", " cartStyle", "cartObj", "carInf", "contactInfo", "carInfo", "productData", " cartData", "frontStyle", "carMeta", "cartStyle", "carSize", "cartSize", "cartInf", " cartInf", "productObj", "productInf", "carStyle", "carObj", "frontMeta", "contactData", "frontObj"], "i": ["f", "si", "it", "ri", "info", "p", "pi", "ori", "ie", "is", "hi", "I", "di", "bi", "ami", "multi", "qi", "l", "e", "ini", "abi", "list", "cli", "ci", "init", "api", "xi", "v", "oi", "ui", "n", "uri", "li", "ani", "ii", "io", "c", "id", "index", "iu", "ic", "chi", "vi", "ai", "ati", "phi", "ip"], "productList": ["pageArray", "resourceList", "productArray", "configCollection", "productGroup", "cartList", " productlist", "resourceCollection", "configList", "pagelist", "resourcelist", " productArray", "pageGroup", "productlist", "productSet", "pageList", "productCollection", "cartlist", " productCollection", " productSet", " productGroup", "configSet", "resourceSet", "cartGroup", "configlist", "cartArray"], "components": [" complements", "commonents", "depients", "suppositories", "productarts", " compositories", "cproducts", "productategories", "comonents", "compenses", "compients", "commositories", "supponents", "comositories", "complements", "comlements", "productonents", "parts", "supplements", "depositories", "compositories", "compproducts", "compategories", "comenses", "suppenses", "comparts", "deponent", "categories", "comonent", "conents", "commients", "commonent", "carts", "ponents", "pategories", "comients", "productproducts", "pproducts", "deponents", " compenses"], "j": ["ji", "ij", "er", "f", "jj", "bj", "_", "where", "database", "p", "k", "ie", "add", "jp", "b", "all", "r", "l", "query", "o", "jc", "this", "z", "js", "J", "Select", "v", "other", " ii", "update", "config", "url", "n", "jo", "index", "id", "Config", "adj", "sql", "Insert", "area", "obj", "Query"]}}
{"id1": "471804", "id2": "18433984", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doversioncheck", "doChangeCheck", "doVersionUpdate", " doVersionUpdate", " doversionScan", " doVersionScan", "doChangecheck", " doVersioncheck", "doFeaturecheck", "doFeatureUpdate", "doversionUpdate", "doChangeUpdate", " doversioncheck", "doFeatureScan", "doFeatureCheck", "doVersionScan", "doChangeScan", " doversionCheck", "doversionScan", "doVersioncheck", "doversionCheck", " doversionUpdate"], "view": ["lock", "self", "container", "edit", "pool", "div", "screen", "see", "review", "update", "out", "html", "gu", "session", "el", "page", "cache", "query", "display", "client", "row", "port", "value", "ui", "group", "up", "fail", "use", "widget", "View", "im", "vis", "model", "vol", "check", "by", "e", "cell", "this", "show", "style", "image", "form", "config", "http", "VIEW", "full", "layout", "manager", "head", "body", "change", "event", "base", "box", "video", "user", "can", "comment", "list", "block", "object", "v", "server", "index", "views", "sel", "input", "window", "ou", "ve", "link"], "url": ["ul", "open", "sl", "f", "loc", "name", "socket", "email", "gl", "stream", "web", "download", "log", "base", "ssl", "bb", "ls", "ll", "blog", "b", "loader", "zip", "l", "bug", "fr", "address", "Url", "buffer", "URL", "source", "image", "builder", "hub", "path", "server", "uri", "null", "browser", "http", "file", "impl", "id", "resource", "www", "host", "link", "location", "length", "rel", "string", "ob"], "in": ["reader", "isin", "sin", "login", "data", "doc", "socket", "s", "ins", "pin", "m", "stream", "cin", "In", "binary", "is", "b", "inner", "again", "rin", "win", "din", "IN", "err", "ini", "buffer", "source", "init", "inc", "nin", "bis", "inn", "file", "as", "lin", "resource", "input", "out", "con", "ac"], "bin": ["reader", "border", "lock", "sin", "login", "socket", "pin", "body", "cin", "bn", "vin", "binary", "bot", "is", "bb", "bi", "b", "loader", "inner", "win", "din", "IN", "ruby", "ini", "abi", "buffer", "lib", "run", "init", "spin", "arin", "ban", "browser", "inn", "oin", "file", "lin", "fin", "input", "out", "record", "con", "gin", "nb"], "line": ["job", "le", "sl", "data", "name", "type", "pin", "range", "el", "ge", "one", "str", "definition", "letter", "log", "base", "lc", "inline", "page", "b", "text", "part", "user", "zip", "l", "val", "e", "cell", "lines", "lf", "key", "ine", "comment", "row", "entry", "block", "parse", "Line", "object", "cl", "code", "nl", "unit", "pe", "jo", "file", "up", "id", "LINE", "word", "lin", "out", "link", "string", "write", "ip", "end", "look"], "version": ["feature", "ver", "name", "support", "type", "dev", "python", "versions", "install", "VERSION", "latest", "download", "release", "plugin", "position", "model", "format", "video", "user", "vert", "section", "bug", "patch", "vision", "pull", "secret", "image", "value", "project", "driver", "v", "update", "server", "unit", "date", "author", "null", "code", "Version", "id", "beta", "cover", "host", "string", "option", "device", "license"], "build": ["lock", "job", "ver", "tag", "get", "mount", "Build", "hold", "how", "building", "boot", "install", "info", "clean", "load", "lease", "release", "log", "add", "built", "bug", "work", "uild", "patch", "pull", "row", "show", "style", "image", "block", "run", "feed", "builder", "update", "unit", "make", "post", "http", "valid", "follow", "help", "home", "print", "link", "rel", "use"]}}
{"id1": "15737836", "id2": "693636", "code1": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "code2": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "label": 1, "substitutes": {"delete": ["save", "drop", "get", "where", "create", "sync", " destroy", "destroy", " create", "release", " Delete", "del", "clear", "select", "connect", "process", "exec", "close", "update", "id", "Delete", " update", "replace", "sql", "execute", "write", "de", "remove"], "site": ["profile", "data", "name", "si", "edge", "session", "database", "type", "note", "remote", "course", "sync", "theme", "space", "se", "install", "xml", "set", "base", "class", "status", "model", "sample", "page", "cache", "conn", "blog", "plugin", "domain", "section", "ite", "line", "zone", "source", "image", "db", "project", "object", "environment", "config", "server", "unit", "sit", "null", "isite", "sites", "module", "item", "result", "target", "sql", "Site", "location", " Site", "network", "license", "node"], "dbo": ["idBo", "ideho", "Dba", "dho", "idbo", "idbl", " dBo", "drbi", "fbo", "rdbi", "idebo", "dbc", "Dbo", "ideBo", " dbi", "pBo", "Dbl", "drBo", "rdBo", "idho", " dBO", "dba", "drbo", "gbo", " dbos", "pba", "jbo", "pBO", "gbos", "idebl", "jba", " dbc", "dbi", "dBo", "dBO", "dbl", "jBo", "fBO", "gBO", "DBO", "fBo", "jBO", "fba", "DBo", "gBo", "Dbos", " dba", "Dho", "pbo", "rdbc", "rdbo", "dbos", "drbc"], "connection": ["lock", "union", "statement", "loc", "manager", "machine", "channel", "pool", "container", "session", "database", "handler", "table", "creator", "reference", "application", "library", "log", "position", "component", "ongo", "conn", "cache", "instance", "section", "query", "engine", "collection", "translation", "client", "subject", "condition", "connected", "ci", "image", "db", "connect", "ctx", "builder", "driver", "response", "environment", "ion", "character", "context", "config", "document", "relation", "server", "unit", "io", "c", "function", "management", "index", "result", "resource", "con", "directory", "sql", "Connection", "communication", "use", "bc", "graph", "node"], "preparedStatement": ["preppedString", "prefixedComment", "preciseStatement", "preachedService", "PrearedStat", "proparableStatement", "caparedTransaction", "eparedstatement", "preparedInstance", "preachedString", "partvisedStatement", "PreparedService", "psefixedComment", "psefixedQuery", "preculatedStatement", "prequalifiedInstance", "preparedComment", "prearedService", "prearedParent", "prearedTransaction", "partparedStat", "preppedQuery", "preformedstatement", "prehedStatement", "previousstatement", "PrearedHeader", "preparedHeader", "partvisedQuery", "preparedTransaction", "preparedScope", "PrearedDatabase", "preplacedStat", "PreparedDocument", "prelyingTransaction", "preparableStat", "preparedParent", "prepperConnection", "PreparedParent", "prefixedOperation", "preparedQuery", "previousDocument", "proparableInstance", "preppedTransaction", "preparedStat", "eparedConfiguration", "PreppedStatement", "PreparedDatabase", "PreparedOperation", "PreparedHeader", "prelyingComment", "preparedstatement", "prequalifiedstatement", "eculatedTransaction", "preutedStatement", "preutedOperation", "prearedQuery", "prehedComment", "caparedStatement", "preculatedConfiguration", "eculatedConfiguration", "preamedParent", "partparedComment", "calyingTransaction", "preformedDatabase", "preamedStat", "preamedStatement", "PrearedService", "preculatedTransaction", "preparedConfiguration", "preparableInstance", "partvisedComment", "prepperStatement", "proparedstatement", "previousTransaction", "prelyingstatement", "preciseParent", "previsedQuery", "proparablestatement", "eparedStatement", "preformedTransaction", "prequalifiedStatement", "caparedComment", "prefixedHeader", "PreparedTransaction", "prearedScope", "PrearedStatement", "PreparedStatement", "PrearedQuery", "calyingComment", "PrearedComment", "PrearedOperation", "prearedConfiguration", "PreppedConnection", "preparableStatement", "preciseStat", "preparedDocument", "preparedOperation", "PreparedStat", "caparedstatement", "prelyingStatement", "preparedString", "preciseString", "calyingstatement", "eparedTransaction", "PreppedDocument", "PrearedString", "pseparedComment", "preachedStatement", "preferredStatement", "previousStatement", "preplacedQuery", "preachedDatabase", "preppedStatement", "preformedString", "psefixedStatement", "preparablestatement", "prearedStat", "preculatedstatement", "preparedService", "calyingStatement", "prearedstatement", "previsedStat", "preppedConnection", "previousConnection", "prearedDatabase", "preppedComment", "eculatedStatement", "PreparedQuery", "prefixedScope", "prearedString", "pseparedScope", "prearedStatement", "previsedStatement", "prefixedStatement", "prequalifiedStat", "proparedStatement", "preferredQuery", "psefixedScope", "preamedString", "preplacedComment", "previousComment", "proparedStat", "prearedOperation", "preparedDatabase", "partparedQuery", "preutedQuery", "preformedStatement", "prehedScope", "preformedConfiguration", "prearedComment", "preppedDocument", "partvisedStat", "prearedHeader", "preferredString", "eculatedstatement", "previsedComment", "preutedHeader", "PreppedTransaction", "prefixedQuery", "pseparedQuery", "PrearedParent", "PreparedComment", "pseparedStatement", "preparedConnection", "prearedInstance", "prepperTransaction", "proparedInstance", "partparedStatement", "preplacedStatement", "prepperDocument", "preformedService", "PreparedConnection", "proparableStat", "prehedQuery", "preferredComment", "PreparedString"], "resultSet": [" resultGet", "responseList", "ResultLine", "rowSize", " resultList", "resultSize", "rowSource", "ResultSize", "responseSet", "ResultSource", "responseSource", "resultSource", "resultsSource", " resultLine", "ResultSet", "responseLine", "ResultList", " resultSource", "resultList", "ResultGet", "rowGet", "resultLine", "resultsLine", "resultsSet", "rowSet", "resultsList", "resultGet", " resultSize"], "chkSql": ["chkAsQL", "chKSql", "chkOsq", "chkOsQL", "chksSQL", "chKRssql", "chkPresQL", "chKRsql", "chkSsql", "chKRsq", "chkAsq", "chksAsQL", "chkSq", "chkPsql", "chKSsql", "chksSsql", "chkPressql", "chKRssl", "chkSQL", "chksAsql", "chkPresql", "chkRssql", "chkRsql", "chksSq", "chkSsl", "chkPssl", "chkPssql", "chkRssl", "chksAsq", "chKSsl", "chkOssl", "chkOssql", "chkOsql", "chksSql", "chkRsq", "chkPsq", "chKSq", "chkAsql", "chkPresq", "chkAssql", "chksAssql"], "selfDefinePath": ["selfDeclineKey", "selfDefinesUrl", "selfDefenName", "selfDeclinedPath", "selfDefinespath", "selfDeclinePath", "selfDefinesPath", "selfDefenPath", "selfDefenLocation", "selfDefineName", "selfDefinedUrl", "selfDefinedpath", "selfDefinesName", "selfDefinedName", "selfDeclinedKey", "selfDefiningKey", "selfDeclinedUrl", "selfDefineUrl", "selfDefinedLocation", "selfDeclinedpath", "selfDefinepath", "selfDefenpath", "selfDefiningUrl", "selfDefinedPath", "selfDefiningPath", "selfDefineKey", "selfDeclinepath", "selfDefinesLocation", "selfDefineLocation", "selfDeclineUrl", "selfDefinesKey", "selfDefiningpath", "selfDefinedKey"], "sqlStr": [" sqlText", " sqlBr", "querystr", "SQLDec", "qlBr", "SQLString", "sqlstr", " sqlDec", "SQLstr", "SQLBr", "sqlBr", "sqlText", "queryText", "sqlDec", " sqlstr", " sqlString", " sqlWr", "queryStr", "SQLWr", "qlWr", "SQLStr", "queryDec", "qlString", "SQLText", "sqlWr", "sqlString", "qlStr"]}}
{"id1": "12128591", "id2": "15166511", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["get", " fingerprint", " hashing", "str", "dump", "hex", "log", "add", "copy", "component", "check", "text", " Hash", "crypt", "parse", "build", "pack", "h", "sum", "update", "code", " hashes", "print", "Hash", "SHA"], "data": ["missing", "connection", "name", "s", "database", "body", "p", "info", "str", "hex", "class", "base", "format", "cache", "text", "output", "bytes", "content", "address", "buffer", "padding", "source", "style", "image", "value", "api", "template", "response", "memory", "in", "DATA", "a", "message", "result", "input", "dat", "pad", "length", "alpha", "string", "media"], "digest": ["dige", "mdest", "signEST", "signusher", "logenge", "pedester", "generest", " diger", "digit", "DigEST", " digests", "generests", "Digast", "Digester", "Digusher", "digenge", "generester", " digusher", " dige", "decit", "digester", "decests", "digEST", "bigester", "bigusher", "generit", "Dige", "mdester", "bigest", " digger", "digger", "logester", "decest", "signester", "pedest", " digEST", "Digenge", "mdenge", "mdast", "Digger", "diger", "digusher", "logest", "logast", "Diger", "signest", "digests", " digit", "pede", "peder", "decester", " digester", "Digest", "bigger", "digast"]}}
{"id1": "20751378", "id2": "4593012", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"hashPassword": ["hashWord", "signPassword", "cryptPassword", "signpassword", "cryptpassword", "hashpassword", "cryptWord", " hashWord", " hashPass", " hashpassword", "cryptPass", "signPass", "signWord", "hashPass"], "password": ["data", "name", "wd", "database", "command", "python", "seed", "p", "encrypted", "plain", "description", "words", "cache", "user", "w", "text", "Password", "content", "mac", "key", "address", "secret", "crypt", "padding", " passwords", "sword", "phrase", "path", "PASS", "pattern", "number", "code", "pass", "word", "prefix", "message", "sha", " Password", "token", "input", "security", "pad", "auth", "string", "username"], "hash": ["tag", "proof", "version", "pool", "put", "format", "kh", "work", "ruby", "square", "h", "url", "update", "number", "search", "message", "sha", "host", "height", "length", "html", "rh", "ha", "hed", "error", "log", "cache", "math", "her", "uild", "key", "address", "secret", "call", "build", "value", "gh", "oh", "code", "id", "result", "security", "replace", "Hash", "json", "sh", "pkg", "dump", "copy", "bolt", "check", "root", "style", "phrase", "sum", "ashes", "ssh", "ash", "auth", "addr", "msg", "alt", "handle", "array", "hex", "base", "match", "dig", "user", "text", "mac", "mod", "history", "memory", "index", "string"], "md": ["meta", "df", "bd", "vd", "f", "mag", "mg", "sd", "gb", "wd", "grad", "mad", "dd", "m", "ma", " MD", "mt", "dig", "kg", "mb", "am", "mac", "hm", "cmd", "dm", "sm", "d", "MD", "gd", "mod", "der", "amd", "metadata", "mm", "pm", "dh", "sha", "xd", "mc", "nd", "ms", "od", "mand", "hd", "pd", "nm", "km", "Cmd", "ME"]}}
{"id1": "5760649", "id2": "364438", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"createFile": ["saveResource", "createResource", " createResource", " createFolder", "CreateContent", "saveFolder", " createContent", "CreateFolder", "createFolder", "createContent", "CreateFile", "saveContent", "saveFile", "CreateResource"], "src": ["sl", "cb", "data", "loc", "name", "gb", "s", "slice", "sc", "stream", "secure", "load", "proc", "rc", "SourceFile", "ssl", "rob", "files", "txt", "content", "img", "href", "r", "fn", "ruby", "dest", "rb", "source", "path", "url", "uri", "sit", "file", "upload", "sel", "rss", "resource", "input", "sb", "Source", "fp", "resources", "string", "obj", "buf", "username"], "filename": ["ame", "f", "name", "s", "fil", "SourceFile", "nil", "feat", "Filename", "acl", "loader", "files", "output", "txt", "l", "fn", "ename", "which", "source", "path", "url", "uri", "route", "ames", "metadata", "file", "wb", "title", "prefix", "utf", "FILE", "resource", "sf", "fp", "location", "directory", "length", "rl", "string", "dll", "username"], "fis": ["fiss", " fris", "cfos", "sfos", "sfris", "fbs", "FIS", "sfiss", "cfIS", " fais", "Fbs", "Fis", " fIS", "cfais", "Fiss", "Fais", " fiss", "cfbs", " fbs", "Fos", "fris", "Fris", "fais", "fIS", "sfis", "cfis", "cfris"], "fos": ["sfios", "affos", "sfos", "Fbos", "affis", "bos", "FOS", "Fops", "fOS", " fOS", "fbos", "foras", "foros", "Fios", "Fas", "Fis", "fops", "affios", "bbos", "bios", "fas", "bis", "affbos", "sfops", "foris", "fios", "Fos", "forOS", " fios", "sfis", " fops", " fas"]}}
{"id1": "7044685", "id2": "6866575", "code1": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": [" enccrypt", " encipher", " encress", "encipher", "enrypt", "encress", "enress", "enipher", "deccrypt", "decress", "decipher", "enccrypt", "decrypt"], "plaintext": [" PlainText", " plaincontent", "broadtext", " plainsource", " Plainbinary", " Plaincontent", "plainTEXT", " plainbinary", "flattext", "plaincontent", "broadText", " plainTEXT", "flatTEXT", "fctext", "fccontent", " Plaintext", "fcbinary", " plainText", "plainsource", "broadTEXT", "flatsource", "plainText", "broadsource", "flatText", "fcText", "plainbinary"], "d": ["did", "bd", "f", "data", "cd", "sd", "ds", "dl", " dd", "g", "D", "dd", "m", "mad", "p", "dn", "da", "dig", "ld", "di", "b", "l", "r", "e", "o", "md", "dr", "dc", "gd", "db", "t", "ded", "h", "mod", "rd", "n", "dad", "c", "dh", "id", "ed", "fd", "dat", "nd", "pd", "mand", "ad", "od", "de", "dict", "dt"]}}
{"id1": "7757297", "id2": "17729554", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 0, "substitutes": {"submit": ["save", "open", "login", "Submit", "complete", "type", " submission", "send", "download", "register", "success", "sub", "run", "init", "request", "process", "form", "close", "update", "post", "input", "report", "execute", "accept", "write", "start", "apply"], "uri": ["URI", "data", "absolute", "ri", "iri", "database", "xml", "base", "plugin", "format", "description", "text", " ur", "href", "address", "Url", "i", "URL", "cli", "source", "api", "path", "response", "filename", "ui", " Uri", "server", "route", "io", "http", "duration", "file", "id", "message", "resource", "location", "report", "directory", "string", " URI", "username"], "Exception": ["Ex", "ception", "End", "Response", "Exc", "Adapter", "Problem", "Application", "A", "Transaction", "Document", "Error", " exception", "Event", "Null", "Request", "Description", "ceptions", "Except", "Interface", "Timeout", "except", "Exit", "Connection", "Record"], "encodedrdf": ["encodedwde", "encodingrdf", "encodedrrrf", "encodedrrf", "encodedvrrf", "encodedrdbf", "encodedvrbf", "encoderdef", "encodedwdF", "encodedrtbf", "encodeudf", "encodedrre", "encodingwdf", "encodeudef", "encoderde", "encodedudf", "encodeude", "encodingwdbf", "encodeudrf", "encodedudef", "encodedrdF", "encodedwdbf", "encodedudrf", "encodedrref", "encodingrdF", "encodingrdrf", "encoderdrf", "encodedwdrf", "encodedvrF", "encodedwdf", "encodedrdrf", "encodedwdef", "encodingwdF", "encodingwdrf", "encodedrtf", "encodedrtF", "encodedude", "encodedvrf", "encodedrde", "encoderdf", "encodingrdbf", "encodedrdef", "encodedrtrf"], "url": ["job", "open", "loc", "name", "channel", "socket", "session", "database", "base", "ssl", "position", "control", "page", "conn", "user", "text", "l", "client", "address", "Url", "proxy", "URL", "service", "source", "image", "connect", "path", "config", "relation", "server", "http", "file", "contact", "resource", "link", "location", "Connection", "string", "use"], "connection": ["open", "loc", "version", "org", "channel", "socket", "session", "database", "handler", "application", "communication", "position", "conn", "b", "text", "section", " Connection", "l", "writer", "password", "client", "service", "connected", "URL", "condition", "source", "proxy", "connect", "or", "driver", "response", "character", "context", "config", "document", "n", "relation", "number", "server", "io", "http", "c", "in", "function", "contact", "con", "link", "directory", "Connection", "string", "use"], "lastUser": ["LastUser", " lastWord", "latestRow", "latestUser", "LastRow", "LastWord", "lastCategory", " lastCategory", "LastCategory", "latestCategory", "lastWord", " lastRow", "lastRow", "latestWord"], "out": ["lock", "office", "login", "data", "doc", "name", "at", "pool", "down", "outs", "w", "wrapper", "cmd", "err", "o", "flush", "off", "cli", "exec", "io", "exp", "socket", "error", "log", "page", "conn", "cache", "inner", "output", "key", "client", "call", "init", "builder", "outer", "up", "global", "word", "result", "dump", "plain", "copy", "commit", "part", "check", "writer", "line", "temp", "external", "image", "no", "prefix", "Out", "obj", "full", "bin", "extra", "sync", "req", "user", "again", "password", "OUT", "comment", "list", "view", "server", "in", "file", "window", "write", "editor"]}}
{"id1": "13012591", "id2": "9261777", "code1": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "code2": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getPasswordHash": ["getPasswordSum", "getpasswordSecret", "getStringSum", "getHashSum", "getStringhash", " getPasswordSecret", " getpasswordSecret", "getpasswordHash", "getPasswordSecret", " getPasswordhash", " getpasswordHash", " getPasswordSum", "getStringSecret", " getpasswordhash", "getpasswordhash", "getHashhash", "getpasswordSum", "getHashSecret", "getStringHash", "getPasswordhash", "getHashHash", " getpasswordSum"], "password": ["data", "name", "email", "wd", "database", "array", "p", "words", "cache", "user", "text", "Password", "content", "account", "key", "address", "secret", "crypt", "buffer", "padding", "source", " passwords", "sword", "phrase", "path", "PASS", "pattern", "attribute", "config", "number", "code", "pass", "word", "prefix", "message", "token", "input", "security", "auth", "string", "confirmed", "username"], "md": ["bm", "meta", "gm", "bd", "vd", "mag", "mg", "gb", "dd", "m", "ma", " MD", "mt", "arm", "dig", "ld", "alg", "mb", "mac", "hm", "cmd", "dm", "dr", "material", "sm", "d", "dc", "MD", "map", "gd", "db", "mo", "mod", "amd", "mp", "metadata", "mm", "pm", "dh", "mu", "amp", "sha", "cm", "mem", "mc", "ms", "pd", "mand", "ad", "hd", "nm", "od", "mage", "pkg"], "hash": ["data", "ha", "hed", "error", "batch", "handle", "array", "filter", "body", "hex", "bh", "match", "dig", "carry", "cache", "check", "kh", "mac", "mask", "query", "dot", "key", "address", "secret", "row", "count", "map", "image", "build", "block", "square", "h", "url", "sum", "number", "code", "ashes", "index", "search", "message", "sha", "header", "ash", "diff", "cover", "host", "length", "total", "Hash", "html", "sh"], "buf": ["bin", "cb", "f", "data", "ff", "book", "array", "buff", "cap", "Buffer", "aux", "bh", "bb", "b", "box", "br", "abs", "img", "bp", "bag", "va", "rb", "abi", "buffer", "db", "ctx", "cf", "h", "v", "Buff", "conv", "cv", "pb", "ab", "nb", "src", "af", "uf", "cas", "sb", "bf", " buffer", "pad", "ref", "home", "fp", "fb", "bc", "tmp", "pkg"], "i": ["x", "ji", "f", "data", "si", "it", "ti", "ri", "s", "m", "p", "j", "pi", "k", "field", "hi", "I", "bi", "u", "b", "di", "multi", "qi", "l", "r", "fi", "e", "o", "uli", "abi", "d", "ci", "t", "h", "xi", "v", "oi", "ui", "li", "uri", "ii", "io", "c", "id", "index", "chi", "mu", "vi", "eni", "ai", "gi", "phi", "length", "ip", "end"]}}
{"id1": "22022715", "id2": "15166511", "code1": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"digest": ["mdest", "doure", "genests", "generest", "digure", "genested", " digests", "digit", "Digester", "dger", "generester", "digested", "dester", "genest", "doest", "doested", "doit", "digester", "dit", "generit", "mdure", "mdested", "dest", "mdester", "digger", "Digure", "Digested", "mdit", "genester", "digests", "Digit", "generger", " digested", " digester", "Digest", "Digests", "mdger"], "s": ["f", "data", "ds", "g", "m", "services", "p", "ns", "os", "is", "ssl", "ls", "words", "b", "bytes", "rs", "e", "password", "lines", "strings", "d", "i", "S", "source", "ws", "gs", "n", "ps", "c", "params", "a", "message", "es", "ss", "sb", "ms", "sym", "string", "ses"], "ret": ["nt", "alt", "ext", "data", "pat", "al", "addr", "arr", "det", "rev", "array", "info", "Ret", "Return", "match", "fun", "RET", "success", "repl", "val", "key", "reply", "xt", "secret", "std", "continue", "value", "hash", "default", "pass", "rt", "valid", "result", "res", "out", "bf", "def", "replace", "mem", "rets", "re", "arg", "obj"], "md": ["meta", "df", "bd", "cb", "mag", "mg", "cd", "wd", "mad", "dd", "m", "ma", " MD", "mt", "arm", "ind", "me", "dig", "di", "mb", "am", "mac", "cmd", "dm", "um", "d", "MD", "gd", "mo", "mod", "amd", "mp", "rpm", "metadata", "mm", "pm", "mc", "od", "mand", "pd", "pg", "hd", "nm", "Cmd", "ad", "editor", "pkg"]}}
{"id1": "19910627", "id2": "17947247", "code1": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "code2": "    public String postURL(String urlLocation, ArrayList headers, String content, HashMap postVariables, RenderEngine c) throws Exception {\n        String postContent = null;\n        if (postVariables != null) {\n            boolean firstElement = true;\n            postContent = new String();\n            Iterator elements = postVariables.keySet().iterator();\n            while (elements.hasNext()) {\n                String key = (String) elements.next();\n                String val = (String) postVariables.get(key);\n                if (firstElement) {\n                    postContent += Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                    firstElement = false;\n                } else {\n                    postContent += \"&\" + Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                }\n            }\n            elements = null;\n        } else {\n            postContent = content;\n        }\n        Debug.log(\"Connecting to URL '\" + urlLocation + \"', content '\" + postContent + \"'\");\n        URL url = null;\n        try {\n            url = new URL(urlLocation);\n        } catch (MalformedURLException e) {\n            Debug.log(\"Unable to retrieve URL '\" + urlLocation + \"': \" + e.getMessage());\n            return null;\n        }\n        StringBuffer lines = new StringBuffer();\n        HttpURLConnection conn = null;\n        boolean contentLengthFound = false;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            loadCookies(urlLocation, conn, c);\n            if (headers != null) {\n                for (int i = 0; i < headers.size(); i++) {\n                    String header = (String) headers.get(i);\n                    String key = header.substring(0, header.indexOf(\":\"));\n                    String value = header.substring(header.indexOf(\":\") + 2);\n                    if (key != null && key.equalsIgnoreCase(\"content-length\")) {\n                        contentLengthFound = true;\n                    }\n                    Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                    conn.setRequestProperty(key, value);\n                }\n            }\n            if (!contentLengthFound) {\n                Debug.log(\"Adding new request header 'Content-Length'='\" + postContent.length() + \"'\");\n                conn.setRequestProperty(\"Content-Length\", Integer.toString(postContent.length()));\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(postContent);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                lines.append(line);\n                lines.append(\"\\r\\n\");\n            }\n            handleHeaders(urlLocation, conn.getHeaderFields());\n            wr.close();\n            rd.close();\n            wr = null;\n            rd = null;\n        } catch (IOException e) {\n            if (conn != null) {\n                lines = new StringBuffer();\n                try {\n                    throw new Exception(\"Server returned error code '\" + conn.getResponseCode() + \"': \" + conn.getResponseMessage());\n                } catch (IOException ee) {\n                    throw new Exception(\"Unable to report error codes: \" + ee.getMessage());\n                }\n            }\n            Debug.log(\"I/O Exception occurred while communicating with endpoint: \" + e.getMessage());\n            return lines.toString().trim();\n        } catch (Exception e) {\n        }\n        url = null;\n        conn = null;\n        return lines.toString().trim();\n    }\n", "label": 0, "substitutes": {"getData": ["readData", "printData", "readContent", "printdata", "getFeed", "postFeed", "postData", "postContent", "getContent", "postdata", "printContent", "getdata", "readFeed", "readdata", "printFeed"], "httpclient": [" httpClient", "httpserver", " httpconnection", "httpscache", "phpconnection", "httpsserver", "phpClient", "Httpserver", "ttpcache", "ttpserver", "ttpClient", "phpserver", "HttpClient", "Httpconnection", "httpClient", "httpconnection", " httpserver", "Httpclient", "httpsclient", "httpcache", "phpclient", " httpcache", "ttpclient", "httpsClient"], "get": ["full", "open", "start", "it", "g", "method", "put", "create", "body", "handle", "remote", "send", "ge", "enable", "load", "find", "set", "base", "add", "check", "query", "single", "e", "client", "pull", "service", "i", "call", "init", "show", "parse", "api", "build", "request", "Get", "like", "write", "exec", "GET", "update", "read", "make", "http", "resource", "json", "generic", "use", "invoke"], "response": ["connection", "data", "ception", "error", "respond", "body", "application", "event", "received", "Response", "status", "page", "output", "success", "collection", "e", "client", "reply", "feed", "api", "request", "document", "server", "http", "message", "result", "resource", "out", "report", "onse", "json", "resp"], "entity": ["connection", "data", "issue", "el", "body", "em", "application", "event", "xml", "activity", "component", "output", "content", "article", "collection", "e", "client", "image", "Entity", "api", "media", "object", "environment", "document", "server", "unit", "pe", "person", "http", "file", "ce", "message", "resource", "result", "json", "ent", "element"], "instream": ["inputform", " inchannel", "inprogress", "outstream", "insfile", "infile", "outfile", "Inchannel", "outStream", "InStream", "inchannel", "Instream", "inform", "outchannel", "Inprogress", "outprogress", "inputprogress", " inStream", "insStream", " infile", " inform", "inschannel", "insstream", "outform", "Inform", "inputStream", "inStream", "inputstream", "Infile"], "responseMessage": [" responsemessage", "respondContent", "respondmessage", "ResponseMessage", "respondMessage", "respondBody", " responseContent", "ResponseBody", "responseBody", "Responsemessage", " responseBody", " responseMsg", "responseMsg", "respondMsg", "responsemessage", "ResponseContent", "responseContent", "ResponseMsg"]}}
{"id1": "5836744", "id2": "13783549", "code1": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"read": ["reader", "READ", "open", "readable", "data", "get", "Read", "error", "create", "stream", "send", "download", "load", "find", "add", "copy", "check", "include", "call", "parse", "run", "source", "connect", "process", "exec", "next", "close", "update", "reading", "transfer", "index", "resource", "input", "execute", "write", "start", "wait"], "name": ["x", "connection", "ame", "f", "data", "start", "type", "from", "stream", "body", "info", "str", "class", "base", "part", "time", "size", "content", "alias", "root", "e", "key", "client", "address", "style", "source", "image", "value", "path", "parent", "filename", "object", "no", "default", "names", "Name", "n", "code", "uri", "null", "file", "id", "word", "prefix", "index", "action", "resource", "host", "named", "string", "NAME", "end"], "status": ["active", "full", "msg", "login", "si", "error", "uses", "complete", "type", "method", "sync", "state", "ssl", "base", "size", "content", "Status", "success", "service", "source", "cli", "continue", "value", "api", "stats", "response", "speed", "stage", "exit", "update", "score", "width", "code", "server", "STAT", "rate", "id", "index", "stat", "result", "fail", "sb", "gc", "header", "json", "use", "wait", "site"], "url": ["open", "sl", "f", "data", "channel", "gl", "stream", "web", "base", "ssl", "ls", "blog", "b", "user", "plug", "l", "address", "Url", "buffer", "URL", "source", "image", "feed", "hub", "path", "object", "server", "uri", "browser", "http", "file", "id", "ball", "www", "bel", "host", "rel", "string", "obj", "ob"], "in": ["connection", "bin", "reader", "isin", "login", "f", "get", "version", "socket", "session", "inas", "ins", "el", "m", "stream", "In", "binary", "ssl", "part", "conn", "inner", "again", "din", "r", "IN", "fr", "ini", "buffer", "i", "source", "init", "image", "inc", "nin", "cf", "config", "pass", "inn", "as", "id", "index", "fd", "token", "input", "out", "resource", "gin"]}}
{"id1": "20995534", "id2": "4389475", "code1": "    private static Properties loadPropertiesFromClasspath(String path) {\n        Enumeration<URL> locations;\n        Properties props = new Properties();\n        try {\n            locations = Thread.currentThread().getContextClassLoader().getResources(path);\n            while (locations.hasMoreElements()) {\n                URL url = locations.nextElement();\n                InputStream in = url.openStream();\n                props.load(in);\n                in.close();\n                logger.config(\"Load properties from \" + url);\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"load properties from classpath \\\"\" + path + \"\\\" failed\", e);\n        }\n        return props;\n    }\n", "code2": "    @Override\n    public URLConnection openConnection(URL url) throws IOException {\n        if (!url.getProtocol().equals(\"file\")) {\n            String name = url.getFile();\n            File f = new File(cacheFolder, ((name.charAt(0) == '/') ? name.substring(1) : name).replace('/', File.separatorChar));\n            if (!f.exists()) {\n                File f2 = new File(f.getParentFile(), f.getName() + \"-not_found\");\n                if (!f2.exists()) {\n                    try {\n                        f.getParentFile().mkdirs();\n                        downloadFile(url, f);\n                    } catch (IOException e) {\n                        f.delete();\n                        throw e;\n                    }\n                }\n            }\n            return f.toURI().toURL().openConnection();\n        }\n        return super.openConnection(url);\n    }\n", "label": 0, "substitutes": {"loadPropertiesFromClasspath": ["loadPropertiesFromclassfile", "loadPropertiesfromclassname", "loadPropertiesFromSubname", "loadPropertiesFromclasspath", "loadPropertiesFromClassloader", "loadPropertiesfromClasspath", "loadPropertiesfromclasspath", "loadPropertiesFromclassname", "loadPropertiesfromclassloader", "loadPropertiesFromClassname", "loadPropertiesfromClassloader", "loadPropertiesFromSubfile", "loadPropertiesFromSubloader", "loadPropertiesfromClassname", "loadPropertiesFromSubpath", "loadPropertiesfromClassfile", "loadPropertiesFromclassloader", "loadPropertiesFromClassfile", "loadPropertiesfromclassfile"], "path": ["prop", "full", "data", "name", "error", "handler", "type", "method", "p", "enc", "xml", "log", "base", "part", "text", "loader", "content", "root", "work", "key", "pointer", "source", "template", "value", "request", "parent", "filename", "pattern", "object", "context", "config", "level", "uri", "route", "c", "id", "PATH", "prefix", "ath", "Path", "resource", "dir", "properties", "host", "location", "string"], "locations": ["LOCation", "locator", "Locors", "slators", "locors", "slator", "LOCions", "operation", "Locator", " locator", "Locions", "sllements", "Loclements", "LOCors", "locATIONS", "LOCocations", " location", "slATIONS", "LocATIONS", "colATIONS", "colation", "lococations", "LOCATIONS", " lococations", "colations", "operibraries", " locATIONS", "operations", "loclements", "LOCations", "slation", " locors", "locibraries", " locators", "locions", "operators", "Locations", "Location", "locators", "colions", " loclements", "location", " locibraries", "slations", "slibraries", "Lococations"], "props": [" propp", "suppcs", "protros", "supppps", "pospp", "peros", "protps", "ppp", "suppperties", " probs", "produps", "procs", "producs", " procs", " properties", "pbperties", "peperties", "pps", "pbros", "pbs", "produperties", "produpps", "suppps", "protbs", "pebs", "pbps", "propps", "pbbs", "peps", "propp", "posps", " propps", "posbs", "posperties", "properties", "proros", "probs", "pperties", "protperties"], "url": ["connection", "sl", "f", "loc", "name", "org", "gl", "el", "layer", "str", "class", "base", "ll", "ls", "ource", "ssl", "b", "user", "href", "l", "r", "e", "err", "key", "address", "Url", "i", "URL", "source", "entry", "feed", "lr", "uri", "route", "http", "file", "id", "src", "resource", "bel", "out", "coll", "location", "rl", "rel", "string", "obj", "element", "ob"], "in": ["reader", "bin", "connection", "isin", "login", "f", "data", "into", "it", "socket", "s", "ins", "stream", "ex", "In", "is", "conn", "inner", "again", "r", "din", "IN", "err", "ini", "i", "source", "image", "init", "inc", "nin", "config", "n", "io", "inn", "c", "file", "as", "id", "impl", "a", "ic", "src", "lin", "resource", "input", "out", "con", "ac", "gin", "serv"]}}
{"id1": "20675046", "id2": "13783549", "code1": "    public Object getContent(ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {\n        try {\n            URL url = (getURL() != null) ? new URL(getURL().toExternalForm()) : new URL(((URL) ctxAttrValue).toExternalForm());\n            InputStream reader = url.openStream();\n            int available = reader.available();\n            byte contents[] = new byte[available];\n            reader.read(contents, 0, available);\n            reader.close();\n            return new String(contents);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return ex.toString();\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["newContents", "createResource", "loadResource", "getResource", "newContent", "newResource", "getcontent", "createcontent", "loadContents", "createContent", "loadContent", "getContents", "newcontent", "loadcontent", "createContents"], "context": ["connection", "data", "Context", "name", "manager", "channel", "stream", "comp", "event", "proc", "class", "component", "text", "instance", "content", "writer", "temp", "this", "ctx", "path", "object", "config", "document", "consumer", "resource", "processor", "tx", "bc"], "ctxAttrName": ["ctxAttributeValue", "ctxAttrKey", "ctxAttrsKey", "ctxAddributeValue", "ctxAddrValue", "ctxAddrKey", "ctxAttrsValue", "ctxAttributeName", "ctxAttribKey", "ctxAddributeName", "ctxAttrPath", "ctxAttribName", "ctxAddributeKey", "ctxAddrName", "ctxAddrPath", "ctxAttrsName", "ctxAttrsPath", "ctxAddributePath", "ctxAttribPath", "ctxAttribValue", "ctxAttributePath", "ctxAttributeKey"], "ctxAttrValue": ["ctxAttributevalue", "ctxAttrVal", "ctxAttratorValue", "ctxAddributeVal", "ctxAttbvalue", "ctxAttributerVALUE", "ctxAttrivalue", "ctxAttributeValue", "ctxAttrKey", "ctxAddrvalue", "ctxAddributeValue", "ctxAttriValue", "ctxAddrValue", "ctxAttriVALUE", "ctxAttributeriName", "ctxAttmValue", "ctxAttmVal", "ctxAttributeriVALUE", "ctxAttmvalue", "ctxAttributerName", "ctxAddrKey", "ctxAttributeriValue", "ctxAttributerivalue", "ctxAttributeVal", "ctxAttratorVALUE", "ctxAttrvalue", "ctxAttbVal", "ctxAttbKey", "ctxAttorName", "ctxAttrVALUE", "ctxAttorvalue", "ctxAttratorName", "ctxAttmKey", "ctxAttratorvalue", "ctxAttributerValue", "ctxAttributervalue", "ctxAddributeKey", "ctxAttorVALUE", "ctxAttbValue", "ctxAttriName", "ctxAttorValue", "ctxAddrVal", "ctxAttributeKey", "ctxAddributevalue"], "url": ["connection", "sl", "org", "channel", "ur", "stream", "per", "base", "ssl", "bb", "blog", "user", "loader", "l", "writer", "address", "Url", "service", "URL", "source", "entry", "buffer", "feed", "api", "image", "build", "path", "object", "lr", "server", "uri", "browser", "io", "http", "file", "resource", "www", "host", "location", "string", "ler"], "reader": ["connection", "iter", "er", "f", "data", "ri", "iterator", "handler", " Reader", "worker", "stream", "ender", "layer", "per", "rc", "keeper", "loader", "l", "writer", "r", "rer", "parser", "rr", "buffer", "source", "oder", "entry", "feed", "builder", "driver", "reading", "read", "uri", "tx", "bird", "server", "io", "http", "browser", "in", "rar", "resource", "input", "result", "ler", "Reader", "editor", "rx"], "available": ["active", "missing", "full", "open", "readable", "current", "loaded", "version", "channel", "error", "allowed", "availability", "enough", "created", "closed", "array", "ready", "good", "free", "used", "supported", "able", "release", "position", "all", "instance", "existing", "content", "opened", "capacity", "enabled", "external", "found", "connected", "published", "buffer", "selected", "bound", "next", "default", "Available", "empty", "null", "memory", "unsigned", "valid", "accessible", "resource", "input", "running", "total", "length", "visible", "quality"], "contents": ["contens", "containingapes", " content", "contContents", "extences", "loadContents", "CONTures", "sequent", "intent", "explens", "containingent", "contures", "explent", "containingensions", "explents", "contings", "loadents", " contContents", "intensions", "content", "intapes", "contapes", "contences", "contensions", "containingents", "sequents", "extContents", " contures", "intents", "extents", "loadings", "sequensions", "CONTents", "extings", "explures", " contings", " contences", "loadences", "sequapes", " contens", "CONTens", "CONTent"]}}
{"id1": "5399593", "id2": "8119563", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    protected boolean checkLink(URL url) {\n        try {\n            URLConnection connection = url.openConnection();\n            connection.connect();\n            return true;\n        } catch (IOException e) {\n            MsgLog.error(\"DapParser.checkLink(): IOException: \" + e.toString());\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": [" encipher", "escipher", " encress", "decrypt", "escress", "encipher", "encryption", "escryption", "encress", "decress", "decryption", "decipher", " encryption", "escrypt"], "plaintext": [" plaincontent", "foreTEXT", " plainform", "ainText", "plainTEXT", "raincontent", "rainTEXT", "singleText", "plaincontent", "plainform", "singleform", " plainTEXT", "foreText", "foretext", "ainTEXT", " plainText", "aintext", "plainText", "rainText", "forecontent", "ainform", "singleTEXT", "raintext", "singletext"], "UnsupportedEncodingException": ["UnsupportedCodedEx", "UnsupportedEncryptionEx", "UnsupportedEncodedEx", "UnsupportedEncodingError", "UnsupportedCodedError", "UnsupportedEncgorithmError", "UnsupportedEncodedException", "UnsupportedCodingException", "UnsupportedEncodingEx", "UnsupportedCodedException", "UnsupportedCodingError", "UnsupportedEncgorithmException", "UnsupportedEncodedError", "UnsupportedEncryptionError", "UnsupportedEncryptionException", "UnsupportedCodingEx", "UnsupportedEncgorithmEx"], "md": ["meta", "bd", "mag", "mg", "hed", "cd", "rm", "wd", "mad", "dd", "m", "ma", " MD", "mt", "mage", "me", "dig", "mb", "am", "mac", "hm", "cmd", "dm", "mn", "material", "dc", "d", "MD", "map", "db", "mo", "mod", "amd", "sum", "mp", "code", "metadata", "mm", "pm", "mu", "message", "sha", "po", "bf", "mem", "mc", "ms", "od", "mand", "hd", "nm", "Cmd"], "raw": ["full", "missing", "blocks", "ack", "array", "dec", "clean", "RAW", "enc", "load", "shared", "hex", "ghost", "wrap", "Raw", "instance", "rew", "row", "buffer", "block", "serial", "sign", "empty", "null", "ng", "original", "unsigned", "message", "flash", "sha", "input", "initial", "aws", "unknown", "alpha", "micro", "buf"], "hash": ["rh", "data", "ha", "hed", "version", "array", "shared", "hex", "base", "log", "html", "cache", "text", "math", "mac", "kh", "ruby", "key", "password", "secret", "abi", "block", "image", "build", "h", "url", "sum", "code", "ashes", "id", "message", "flash", "sha", "header", "ash", "hh", "auth", "Hash", "alpha", "string", "sh"]}}
{"id1": "4618237", "id2": "7087108", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"writeFileToFile": ["writeFile2File", "writeFilesToFile", "writeFileAsFiles", "writeFile2Channel", "writeFileAndFile", "writeFilesAsStream", "writeFileAndFiles", "writeFilesAsFiles", "writeFilesToFiles", "writeFileToStream", "writeFile2Files", "writeFilesToChannel", "writeFilesAsFile", "writeFileAndStream", "writeFilesToStream", "writeFileToChannel", "writeFilesAsChannel", "writeFileToFiles", "writeFileAsStream", "writeFileAsFile", "writeFileAndChannel", "writeFile2Stream", "writeFileAsChannel"], "fin": ["FIN", "inf", "f", "fen", "pin", "raf", "ori", "en", "fine", "kin", "Fin", "fat", "conn", "rf", "include", "rin", "din", "fn", "fi", "fr", "ini", "pins", "init", "arin", "rt", "thin", "inn", "ris", "file", "fa", "fd", "lin", "fp", "fm", "ln", "inv", "nir"], "fout": ["bin", "boff", "FOut", " fOut", " foff", "Fin", "rfOut", "rfin", "Foff", "bOut", "rfint", "bout", "Fint", "fOut", "fint", "foff", "rfout", " fint", "Fout"], "append": ["save", "open", "app", "ext", "opp", "spread", "batch", "pend", "send", "enc", "only", "printf", "optional", "add", "future", "text", "vert", "ended", "password", "flush", "padding", "pack", "want", "adjust", "ending", "update", "null", "protect", "flat", "atten", "except", "fail", "pad", "leaf", "push", "string", "end", "apply", "remove"], "inChannel": ["loginChannel", "innerChan", "innStream", " inchannel", "loginchannel", "INChannel", " inQueue", "inConnection", "INChan", "innerStream", "outStream", "Inchannel", "innchannel", "outQueue", "InChan", "InStream", "inchannel", "loginStream", "outchannel", "innerConnection", " inStream", "outChan", "inputConnection", "INchannel", "INConnection", "inputChan", "inputChannel", "inChan", "inputStream", "innerChannel", "inQueue", "innerchannel", "inStream", "innChannel", "INQueue", "InChannel", "INStream"], "outChannel": ["externalSocket", "inContext", " outContext", "outContext", "outStream", "outputChan", "inchannel", "externalChan", "externalChannel", "ioChan", "outchannel", "OutChan", " outChan", "outChan", "iochannel", "OutContext", "OutStream", "outSocket", "outputSocket", "ioStream", "Outchannel", "outputchannel", "ioChannel", "OutChannel", "inChan", "outputChannel", "inStream", " outchannel", "inSocket", "externalchannel"]}}
{"id1": "14590676", "id2": "19520541", "code1": "    public static void download(String address, String localFileName) {\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            URL url = new URL(address);\n            out = new BufferedOutputStream(new FileOutputStream(localFileName));\n            conn = url.openConnection();\n            in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n            System.out.println(localFileName + \"\\t\" + numWritten);\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static URL[] getDirectoryListing(URL url) throws IOException, CancelledOperationException {\n        FileSystem.logger.log(Level.FINER, \"listing {0}\", url);\n        String file = url.getFile();\n        if (file.charAt(file.length() - 1) != '/') {\n            url = new URL(url.toString() + '/');\n        }\n        String userInfo = KeyChain.getDefault().getUserInfo(url);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.setAllowUserInteraction(false);\n        urlConnection.setConnectTimeout(FileSystem.settings().getConnectTimeoutMs());\n        if (userInfo != null) {\n            String encode = Base64.encodeBytes(userInfo.getBytes());\n            urlConnection.setRequestProperty(\"Authorization\", \"Basic \" + encode);\n        }\n        InputStream urlStream;\n        urlStream = urlConnection.getInputStream();\n        return getDirectoryListing(url, urlStream);\n    }\n", "label": 0, "substitutes": {"download": ["save", "open", "data", "get", " Download", "load", "dump", "release", "binary", "log", "copy", "register", "zip", "parse", "process", "exec", " downloading", "update", "transfer", "read", "Download", "split", "file", "upload", "append", "link"], "address": ["connection", "localhost", "name", "point", "socket", "email", "remote", "audio", "reference", "state", "expression", "base", "position", "output", "password", "Address", "URL", "source", "image", "port", "path", "number", "uri", "server", "route", "ress", "prefix", "resource", "target", "host", "location", "network", "directory", "addr", "string", "ip"], "localFileName": [" localFullAddress", "localFilename", "localPathPath", "localFilesAddress", " localSourceFileCopy", "localFileAddress", "localFullPath", " localFileAddress", "finalFileTarget", "localBufferName", "localFullAddress", "localSourceFileInfo", "localPathName", "localFilenamePath", "localBufferAddress", " localFullName", " localFullPath", "localSourceFileName", "localFilePath", "localFileTarget", "localFilesPath", "localFullname", "localSourceFilename", "localSourceFileTarget", "localBufferInfo", "localPathCopy", "localFullName", "localFilesTarget", "localFilenameName", "localSourceFilePath", "localFullInfo", " localSourceFilename", "localFilenameTarget", "localSourceFileAddress", "localFilenameAddress", "finalFileAddress", "localFileCopy", " localFilePath", "finalFilenamePath", " localFileCopy", "localSourceFileCopy", "localFileInfo", "finalFilenameAddress", " localSourceFileName", " localFullInfo", "localPathname", " localFileInfo", "finalFilenameTarget", " localSourceFilePath", "localFilesName", "finalFilenameName", "finalFilePath", "finalFileName", " localFilename", "localBufferPath", "localFullCopy"], "out": ["lock", "ext", "login", "name", "channel", "at", "pool", "outs", "screen", "b", "w", "err", "flow", "o", "cli", "source", "exec", "null", "io", "co", "exp", "Output", "point", "socket", "error", "sys", "log", "cache", "inner", "output", "client", "init", "outer", "group", "code", "up", "global", "result", "state", "dump", "plain", "copy", "with", "line", "writer", "lib", "image", "inc", "no", "n", "con", "Out", "obj", "connection", "bin", "sync", "ex", "user", "again", "instance", "OUT", "list", "comment", "block", "object", "net", "file", "ou", "window", "string", "write"], "conn": ["connection", "nt", "open", "cb", "cn", "socket", "nc", "ca", "enc", "not", "pc", "ie", "ssl", "cache", "conf", "win", "l", "err", "client", "cli", "ci", "init", "ctx", "connect", "ch", "api", "config", "conv", "n", "server", "core", "http", "c", "Conn", "net", "impl", "co", "ai", "con", "cp", "Connection", "act"], "in": ["reader", "bin", "connection", "login", "data", "into", "socket", "ins", "el", "pin", "cin", "ex", "In", "en", "rec", "is", "b", "inner", "again", "user", "win", "by", "din", "IN", "err", "client", "ini", "i", "source", "cli", "init", "image", "inc", "lib", "nin", "exec", "n", "inn", "oin", "as", "file", "id", "index", "lin", "on", "input", "con", "ac", "gin"], "url": ["connection", "job", "open", "sl", "cur", "f", "org", "channel", "socket", "web", "ll", "ssl", "base", "ls", "log", "blog", "b", "l", "err", "client", "pull", "Url", "service", "URL", "image", "connect", "api", "nl", "server", "uri", "http", "file", "cert", "id", "impl", "coll", "resource", "con", "host", "rl", "rel", "string", "ob"], "buffer": ["offset", "bin", "border", "reader", "uffer", "iter", "data", "batch", "slice", "reference", "layer", "buff", "Buffer", "load", "binary", "base", "copy", "page", "cache", "b", "bytes", "capacity", "FFER", "flush", "count", "source", "padding", "limit", "feed", "phrase", "transfer", "read", "null", "wave", "queue", "input", "resource", "result", "length", "buf"], "numRead": ["numWrite", "maxWrite", "netWrite", "numberRead", "nWritten", "nReader", "NumWrite", "nWrite", "nRead", "NumReader", "netRead", "numberWrite", "numberReader", " numReader", "numberWritten", "netWritten", " numWrite", "NumRead", "netReader", "maxRead", "NumWritten", "numReader", "maxWritten", "maxReader"], "numWritten": ["numWrite", "Numwritten", "nWritten", "NumWrite", "nWrite", "nRead", "umWrite", "umWritten", " numWrite", "NumRead", " numwritten", "umRead", "NumWritten", "umwritten", "numwritten", "nwritten"]}}
{"id1": "6988216", "id2": "5299276", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" runRawConnect", "runSimpleQuery", " runBasicSearch", "runSimpleConnect", " runBasicQuery", " runClientSearch", " runSimpleQuery", " runSimpleFilter", "runRawConnect", " runSimpleConnect", "runRawQuery", "runRawFilter", " runRawSearch", " runClientConnect", " runBasicConnect", " runClientFilter", " runSimpleSearch", " runBasicFilter", " runClientQuery", "runRawSearch", "runSimpleSearch", " runRawFilter", " runRawQuery", "runSimpleFilter"], "dummySource": ["duddyOrigin", "pummyContent", "puddyClient", "pummyClient", "puddyType", "duddyService", "dandySource", "duddyType", "pummyType", "daddyService", "dellyContent", " dumbOrigin", " dumbSource", "dumbConfig", "daddyType", "puddySource", "dummyConfig", "dandySite", "dummySourceFile", "dundleContent", "daddyContent", "duddySource", "daddySource", " dumbContent", "dellyService", "puddySourceFile", "dumbSource", "dummyClient", "dandySourceFile", "duddyClient", "dumbContent", " dummyConfig", "duddySourceFile", "duddySite", "dummyType", " dumbConfig", "pummySource", "dundleOrigin", "dummyOrigin", "daddySite", "dummySite", "dellyType", "dundleConfig", "pummyService", "puddyContent", "puddyService", "dumbOrigin", "duddyContent", " dummyOrigin", "pummySourceFile", "dandyClient", "duddyConfig", "puddySite", "dummyService", "daddyClient", "daddySourceFile", "pummySite", "dundleSource", "dellySource"], "os": ["oS", "ens", "oa", "cos", "ds", "oss", "oos", "bs", "uns", "s", "bos", "ori", "ns", "ol", "sys", "is", "ls", "om", "conn", "css", "obs", "ok", "op", "ops", "oses", "o", "ox", "i", "ks", "OS", "or", "mos", "Os", "object", "vs", "ose", "oc", "osi", "io", "ps", "as", "iso", "pos", "aos", "acs", "ros", "ss", "ou", "los", "ios", "us", "out", "es", "ms", "ols", "nos", "fs", "ows", "dos"], "dummyContent": [" dellyContents", "DummyBody", "dumperBody", "dumpingOutput", " dummyContents", "dellycontent", "DuckyReader", "DummyReader", "dummyOutput", "dumpingcontent", "dummycontent", "dellyContents", "DummySource", "duckyReader", "dummyReader", "DuckyBody", "dellyContent", "dumperSource", " dummycontent", "DuckyContent", "dumpingContent", " dellycontent", "duckyContent", " dellyContent", "DuckySource", "dumperReader", "duddySource", " dellyOutput", " dummyOutput", "dummyBody", "dumperContents", "duckyBody", "dummyContents", "dumpercontent", "duckySource", "DummyContent", "duddyContent", "dellyOutput", "duddyBody", "duddyReader", "dumpingContents", "dumperOutput", "dumperContent"], "source": ["reader", "connection", "sl", "sin", " Source", "ources", " sources", "cos", "channel", "sn", "s", "sc", "seed", "secure", "stream", "sync", "info", "class", "ource", "cache", "text", "size", "e", "SOURCE", "client", "service", "proxy", "i", "storage", "parent", "object", "url", "config", "uri", "unit", "core", "ser", "scope", "search", "src", "resource", "result", "target", "Source", "host", "resources", "slave", "string", "use", "element", "node", "site"], "content": ["data", "current", "version", "cos", "body", "cont", "cms", "clean", "load", "xml", "activity", "expression", "match", "music", "description", "model", "css", "text", "output", "size", "news", "address", "Content", "comment", "service", "image", "child", "value", "feed", "response", "url", "update", "config", "document", "code", "sol", "comments", "server", "transform", "title", "message", "resource", "target", "cover", "host", "header", "result", "report", "input", "html", "media", "children"], "qResult": ["queryRes", "iqResult", "kReturn", "qResults", "kSource", "queryResult", "kRes", "qFilter", "rSource", "queryResponse", "qSource", "rRes", "iqResults", "queryFilter", "qRes", "QResult", "queryResults", "qresult", " qresult", "kresult", "QFilter", "kResults", "iqresult", " qResponse", "rResult", "QReturn", "iqResponse", "QResults", "qResponse", "queryresult", "kFilter", "kResult", "rresult", "querySource", "queryReturn", "qReturn", " qResults"], "results": ["ids", "pages", "values", "data", "blocks", "rows", "s", "versions", "ins", "groups", "ries", "events", "vers", "RESULTS", "items", "models", "successful", "members", "files", "features", "collection", "runs", "its", "lines", "shows", "Results", "qs", "response", "objects", "errors", "details", "ions", "users", "result", "res", "tests", "reports", "resources", "docs", "children"], "it": [" It", "iter", "si", "IT", "edit", "ited", "slice", "ins", "itted", "p", "info", "ITS", "not", "mit", "pit", "It", "op", "ite", "l", "r", "and", "its", "rit", "list", "i", "entry", "ci", "which", "init", "ort", "t", "or", "v", "ait", "sit", "in", "split", "iti", "id", "the", "ic", "stat", "lit", "ati", "you", "ip"], "rSrc": [" rSsrc", " rEsource", "rDssrc", "rSource", "RIsrec", " rEsRC", "rSrec", "RSrec", "rAsource", "rDsRC", "rPsource", "rDsource", "RSrc", "RSource", "rEssrc", "rDsrc", "rPssrc", "rEsrc", "RIsrc", "rAssrc", "RIsource", "rAsrec", "rIsRC", "rIsrc", "rIsrec", "RSRC", " rSRC", "rIsource", "rSRC", "rPsRC", " rEsrc", "rEsRC", "rAsRC", "rSsrc", " rDsource", "rEsource", " rDssrc", " rDsRC", " rDsrc", "rPsrc", "RIsRC", " rEssrc", " rSource", "rAsrc"], "rSrcIn": ["rCRCOut", "rSourceOut", "rAsRCOut", "rSvcin", "rCsrcIn", "rSrcIN", "rSvcOut", "rSsrcin", "rSourceIn", "rSrcOut", "rAsRCIn", "rAsRCin", "rCsrcOut", "rCsrcIN", "rSRCIN", "rSRCin", "rSourceIns", "rSrcin", "rSvcIn", "rCrcin", "rSsrcIn", "rSvcIns", "rSrcIns", "rSsrcIN", "rCrcOut", "rCrcIns", "rSRCIn", "rSsrcOut", "rSRCIns", "rCRCIns", "rAsrcin", "rCrcIn", "rSourcein", "rAsrcOut", "rCrcIN", "rCRCIn", "rCsrcin", "rSRCOut", "rSvcIN", "rAsrcIn"], "actualOut": ["realOut", "eventIn", "publicOut", "assertOUT", "actualIn", " actualout", "nexpectedWin", "realWin", "operatorOUT", "eventout", "eventOUT", " ActualOUT", "assertOut", " ActualOut", "operatorIn", "operatorOut", "actualOutput", "publicIn", "realout", "illegalOUT", "actualWin", " ActualIn", "nexpectedout", "publicOutput", " actualOutput", "nexpectedIn", "assertIn", "illegalOut", "actualout", " ActualBridge", "assertBridge", " actualOUT", "operatorout", "nexpectedOut", "actualOUT", "realIn", " actualIn", "illegalIn", "publicOUT", "actualBridge", " actualWin", "eventOut", "illegalOutput", " actualBridge"]}}
{"id1": "15241397", "id2": "22977189", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"doGet": ["doGET", "handleget", " doPut", " doget", "doget", "handlePut", "didPut", "doPut", "didget", "handleGET", "handleGet", "didGet", "didGET", " doGET"], "request": ["connection", "reader", "er", "data", "complete", "QUEST", "method", "type", "info", "application", "web", "event", "received", "xml", "req", "user", "instance", "query", "client", "subject", "buffer", "image", "object", "Request", "url", "context", "document", "uri", "server", "http", "message", "input", "result", "resource", "queue", "initial", "report"], "response": ["full", "connection", "data", "version", "error", "pool", "session", "respond", "body", "results", "application", "Response", "status", "model", "page", "output", "writer", "collection", "client", "reply", "image", "parent", "object", "next", "other", "esi", "document", "view", "server", "wave", "function", "message", "resource", "result", "out", "queue", "host", "report", "onse", "generation", "json", "resp", "site"], "rewrittenQueryString": ["rewwrittenQueryList", "rewrittenUrlService", "rewrittenqueryString", "rewrittenQueryText", "rewwrittenRequestString", "rewrittenQueryList", "rewrittenRequestService", "rewwrittenQueryLine", "rewrittenPageList", "rewrittenqueryStr", "rewrittenQueryArray", "rewwrittenQueryArray", "rewrittenQuestionList", "rewrittenPageLine", "rewrittenUrlString", "rewwrittenRequestArray", "rewwrittenRequestLine", "rewrittenqueryService", "rewwrittenQueryStr", "rewrittenRequestText", "rewrittenQueryService", "rewrittenUrlText", "rewrittenQuestionArray", "rewwrittenRequestStr", "rewrittenqueryLine", "rewrittenPageArray", "rewrittenQuestionText", "rewwrittenQueryString", "rewwrittenRequestService", "rewrittenRequestStr", "rewrittenQueryLine", "rewwrittenQueryText", "rewrittenQuestionStr", "rewrittenRequestString", "rewwrittenRequestText", "rewwrittenQueryService", "rewrittenRequestLine", "rewrittenQuestionString", "rewrittenUrlLine", "rewrittenQuestionLine", "rewrittenRequestList", "rewrittenqueryText", "rewwrittenRequestList", "rewrittenRequestArray", "rewrittenQueryStr", "rewrittenPageString"], "rewrittenUrl": ["RewwrittenUrl", "rewilledUrl", "rewriteUrl", "rewardedLanguage", "rewardedInt", "rewwrittenInt", "rewmatchedUrl", "rerittenLanguage", "rewrapedUrl", "rewmatchedURL", "rewrittenInt", "rewardedUrl", "rewrittenLanguage", "rewardedJar", "rewardedUr", "RewrittenFile", "RewrittenUr", "rewilledURL", "rewatchedServer", "RewwrittenLocation", "rewardedURL", "rewatchedURL", "RewrittenServer", "rewrittenText", "rewwrittenServer", "rewcraftedUrl", "rewrapedUr", "rewwrittenJar", "rewrittenurl", "rewwrittenLanguage", "rewedurl", "rewcraftedUr", "rewwrittenLocation", "rewwrittenText", "Rewwrittenurl", "rewrapedFile", "rewriteText", "rewrittenURL", "rewodedUrl", "RewwrittenInt", "rewwrittenUr", "rewrittenServer", "rewrapedURL", "rewrittenJar", "RewrittenURL", "RewrittenLocation", "RewwrittenText", "rewodedFile", "rewriteServer", "rewmatchedFile", "rerittenUrl", "RewrittenInt", "rerittenURL", "rewatchedUrl", "rewwrittenUrl", "rewedURL", "rewmatchedurl", "RewrittenUrl", "rewrittenUr", "rewrittenLocation", "rewwrittenFile", "rewedUrl", "rewriteURL", "rewcraftedURL", "RewwrittenURL", "RewwrittenUr", "rewcraftedLocation", "rewilledJar", "RewrittenText", "rerittenFile", "RewwrittenFile", "rewatchedText", "rewodedLanguage", "rewardedLocation", "RewrittenJar", "rewedFile", "RewwrittenServer", "rewardedFile", "rewrittenFile", "rerittenUr", "rewilledInt", "rewodedURL", "rewwrittenURL", "rewedUr", "RewwrittenJar", "rewwrittenurl", "Rewrittenurl"], "httpURLConnection": ["httpCLConnection", "httpURIConnect", "apacheURLFlow", "httpURLCode", "httpURLService", "webSSLClient", "httpurlCurrent", "httpurlConnection", "httpURLConn", "httpURConn", "apacheURLConnect", "httpStreamconnection", "httpSSLConnection", "httpURIClient", "HttpChannelconnection", "httpUrlconnection", " httpURConn", " httpUrlConnection", "httpUrlConnection", "httpStreamSession", " httpURLconnection", "httpStreamConnection", " httpURConnect", "httpurlFlow", "httpUrlContext", "httpChannelService", "HttpURLConnection", "httpURLContext", " httpUrlConn", "httpCLConn", " httpStreamCurrent", "webSSLConnection", "httpURIconnection", "HttpURLconnection", "httpPathCurrent", "webURLContext", "webSSLContext", "httpurlconnection", "httpUrlConn", "httpURLCurrent", "apacheGEConnect", "httpURConnect", " httpStreamSession", "httpWebConnect", "httpSSLContext", "httpPathConnection", "httpPathconnection", "httpurlSession", "HttpChannelConnect", "httpGEconnection", " httpURLSession", "httpURIFlow", "httpURIContext", "httpURLClient", "httpurlConn", " httpURLConn", "httpUrlService", "httpStreamCurrent", "httpURConnection", "httpUrlConnect", "apacheGEConnection", "HttpURLConnect", " httpStreamConnection", " httpURConnection", "httpGEConnection", "httpURIConnection", "httpURLconnection", "httpurlConnect", " httpURLCurrent", "httpChannelconnection", "httpELConn", " httpURLConnect", "httpChannelConnection", "httpWebConn", "webURLClient", "apacheGEFlow", "httpSSLConn", " httpStreamconnection", "apacheURLconnection", "HttpURLService", "httpSSLClient", "httpELConnection", "HttpChannelConnection", "httpGEFlow", "webURLConnection", "webURLConn", "httpChannelConnect", "httpGEConnect", "httpUrlCode", "HttpChannelService", "httpWebConnection", "httpURconnection", " httpURLCode", "httpURService", " httpUrlCode", "httpUrlClient", "httpPathSession", "apacheGEconnection", "httpURLFlow", "httpCLCode", "webSSLConn", "apacheURLConnection", "httpurlCode", "httpURIConn", "httpURLConnect", "httpELConnect", "httpURLSession"], "header": ["feature", "iter", "er", "director", "data", "version", "channel", "master", "error", "handler", "head", "reference", "filter", "layer", "pair", "info", "after", "field", "event", "definition", "rule", "match", "component", "part", "bridge", "section", "her", "writer", "line", "member", "key", "ter", "dr", "column", "back", "buffer", "list", "entry", "player", "comment", "block", "driver", "outer", "hash", "second", "character", "Header", "next", "default", "attribute", "document", "group", "server", "date", "consumer", "author", "metadata", "function", "index", "message", "item", "token", "headers", "queue", "result", "cover", "string"], "value": ["office", "values", "data", "current", "name", "version", "now", "get", "type", "language", "V", "info", "field", "variable", "option", "label", "letter", "expression", "set", "format", "description", "model", "text", "content", "sv", "val", "VALUE", "key", "password", "comment", "entry", "child", "parent", "object", "v", "property", "attribute", "default", "document", "hello", "server", "function", "valid", "message", "item", "gi", "Value", "json", "string", "media", "end", "element"], "inputStream": ["pullStreamer", "inputSteam", "resourceSteam", "InputChannel", "InputStream", "InputStreamer", "outputStreamer", "pullstream", "inputStreamer", "resourceChannel", "pullStream", "pullSteam", "resourcestream", "resourceStream", "inputChannel", "Inputstream", "outputChannel", "outputSteam", "InputSteam", "inputstream", "outputstream"], "outputStream": ["inputSteam", " outputChannel", "OutputSteam", "outputFile", "OutputChannel", " outputFile", "OutputStream", "outputStreamer", "externalstream", "Outputstream", "inputStreamer", "externalSteam", "externalStreamer", "responseStream", "responseSteam", " outputSteam", "responseFile", "outputChannel", "outputSteam", "responseChannel", "externalStream", "inputstream", "OutputFile", "outputstream", "OutputStreamer"]}}
{"id1": "6260216", "id2": "665420", "code1": "    public InputStream send(String s, String s1) throws IOException {\n        HttpURLConnection httpurlconnection = null;\n        DataInputStream datainputstream = null;\n        System.setProperty(\"java.protocol.handler.pkgs\", \"com.sun.net.ssl.internal.www.protocol\");\n        URL url = new URL(s1);\n        httpurlconnection = (HttpURLConnection) url.openConnection();\n        configureURLConnection(httpurlconnection);\n        DataOutputStream dataoutputstream = new DataOutputStream(httpurlconnection.getOutputStream());\n        dataoutputstream.write(s.getBytes());\n        httpurlconnection.connect();\n        datainputstream = new DataInputStream(httpurlconnection.getInputStream());\n        if (httpurlconnection.getResponseCode() != 200) {\n            System.out.println(\"Invalid Response Code! Code Returned = \" + Integer.toString(httpurlconnection.getResponseCode()));\n            return null;\n        }\n        if (!httpurlconnection.getContentType().equalsIgnoreCase(\"Text/xml\")) {\n            System.out.println(\"Invalid Content-Type! Content type of response received = \" + httpurlconnection.getContentType());\n            return null;\n        } else {\n            return datainputstream;\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"send": ["open", "get", "command", "method", "from", "download", "dump", "text", "export", "flush", "Send", "reply", "call", "pack", "submit", "request", "process", "exec", "update", "transfer", "transform", "sent", "append", "report", "execute", "invoke", "write"], "s": ["ids", "f", "rows", "bs", "services", "sets", "p", "ips", "ns", "os", "ssl", "is", "ls", "u", "abs", "b", "files", "bytes", "ops", "l", "lines", "its", "o", "strings", "d", "i", "S", "ings", "t", "qs", "objects", "uploads", "gs", "n", "ps", "details", "ions", "params", "es", "sb", "opens", "aws", "string", "ses"], "s1": ["S0", "ssl1", "s0", "ses1", "strings2", "s81", "ses81", "strings1", "p1", "s01", "strings01", "ssl2", "p0", "ssl0", "p2", "p01", "ssl81", "strings0", "S2", "S1", "ses2", "ses0", "S81", "s2", "S01"], "httpurlconnection": ["httpreturnconnect", "Httpfileconnection", " httpshellchannel", "Httpurlposition", "httpurlchannel", "workhttpconnection", "httpURLservice", "workhttpconnect", "urlllcommunication", " httpurlConnection", "urlURLcommunication", "httpresourceposition", "httpstringconnection", "httpslogconnection", "httplogconnection", "httpURLrelation", "httpreturncommunication", "httpsbaserelation", "httplogposition", "httpsurlrelation", "httpurlConnection", "urlURLurl", " httpurlsystem", "httpshellsystem", "httpsurlconnection", "httpbreakconnection", " httpurlchannel", "httpscollmanager", "urlllconnection", "httpfileproblem", "httpfileconnection", "httpURLurl", "httpreturnconnection", "httpurlreference", "httpurlrelation", "httpurlfunction", "httpurlproblem", "httpcollsystem", "httplookfunction", "httpcollConnection", "httpURLmanager", "workurlconn", "httpwebcommunication", "urlurlConnection", "urlurlcommunication", "httpsurlConnection", "httppullconnect", "httpurlurl", "httpcollservice", " httpresourceconn", "httpstringchannel", "httpshellchannel", "httpsurlconn", "httplogConnection", "httphttpconn", " httpshellConnection", "httpscollconnection", "httpbreakcreation", "httpurlsystem", "httpreturnConnection", "httpwebrelation", " httpshellsystem", "httpfileposition", "urlURLreference", "httpllcreation", "httpstringsystem", "httpurlconn", "httpslconn", "urlurlconnection", "httplconn", "httpURLreference", "httplookconnect", " httpresourceposition", "httpURLcommunication", "httpbasefunction", "httplogcommunication", "httplogrelation", "urlURLconnection", "urlurlconnect", "httpslconnection", "httpslcommunication", "Httpurlconnection", "httpslreference", " httpurlconnect", "httpsURLconnection", "httpllcommunication", "httpsbasefunction", "workurlcreation", "httpscollservice", " httpurlconn", "httplookconnection", "httpurlposition", "httpsurlfunction", "httpresourceconnect", "httpurlmanager", "httppullconnection", "urlurlurl", "httphttpcommunication", "httplproblem", "httpwebreference", "httpurlcreation", "httpsbaseconnect", "httpURLconnection", "httpurlconnect", "httplconnect", "httpshellConnection", "httpsURLconn", "httpslogcommunication", " httpshellconnection", " httpresourceconnection", "httpfilecommunication", "Httpfileposition", "httphttpConnection", "httpscollconn", "workurlconnect", "httplcommunication", "Httpfilecommunication", "httpshellconnection", "workhttpconn", "httplconnection", "httplogconnect", "httppullConnection", "httpllconnection", "workhttpcreation", "httpresourceconn", "httpURLconn", "httpcollchannel", "httpreturnposition", "httpsurlcommunication", "httpslservice", "httpbaseconnection", "httpbreakconn", "httpbreakconnect", "httphttpconnection", "httphttpcreation", "httpwebconnection", "Httpurlcommunication", "urlllConnection", "httpslogconn", "Httpurlproblem", "httpsURLcommunication", " httpurlposition", "httplookrelation", "httpurlservice", "httpsURLrelation", "httpcollconnection", "httppullcommunication", "httpllConnection", "httpstringConnection", "httpslmanager", "httpslogConnection", "httpllconn", "httpslurl", "urlurlreference", "httpsurlconnect", "httpurlcommunication", "httplogconn", "httplConnection", "httpcollmanager", "httpresourceconnection", " httpresourceconnect", "httplposition", "httplogfunction", "httpllrelation", "httpllconnect", "httpweburl", "httpsbaseconnection", "workurlconnection", "httpsurlmanager", "httpsurlservice", "httpbaseconnect", "httphttpconnect", "httpreturnproblem", "httpcollconn", "httpbaserelation", "Httpfileproblem", "urlllconnect", "httpwebconn"], "datainputstream": ["datainoutputstream", "datainutview", "datrainoutputstream", "datainputsw", "datainputview", "dataincutsw", "datrainoutputsw", "dataincutstream", "datanacutstream", "datainputStream", "datainoutputpath", "datainutpath", "datainstform", "datrainputStream", "datainlogpath", "datainstructstream", "datainputform", "datrainputsw", "dataincutpath", "datainvalpath", "datrainputpath", "datainlogview", "datanacutsw", "datainlogstream", "datanaputstream", "datrainoutputpath", "datainoutputform", "datanaputsw", "datanaputpath", "datainstructStream", "datainstructpath", "datrainputstream", "datainstpath", "datainstructform", "datainlogsw", "datainoutputsw", "datainoutputStream", "datanacutview", "datainvalStream", "datainststream", "datanaputview", "datainutstream", "datainutStream", "datainutsw", "datainvalsw", "datainvalstream", "datrainoutputform", "datainputpath", "dataincutview", "datrainputform", "datrainoutputStream", "datainstStream", "datanacutpath"], "url": ["ul", "connection", "sl", "f", "loc", "org", "fl", "ur", "g", "gl", "stream", "web", "base", "ssl", "ll", "ls", "lc", "log", "bb", "conn", "page", "l", "fr", "address", "Url", "URL", "source", "feed", "api", "config", "li", "server", "uri", "http", "c", "file", "www", "resource", "host", "rl", "string", "ob"], "dataoutputstream": ["dataoutputpath", " dataputstream", "dataoutputchannel", " dataputchannel", " dataoutputpath", " dataoutputStream", "dataoutputStream", "dataOutputchannel", "datainputStream", "dataOutputStream", " dataoutputchannel", " dataputpath", "dataputchannel", " dataputStream", "dataOutputpath", "dataputStream", "dataputstream", "datainputchannel", "datainputpath", "dataOutputstream", "dataputpath"]}}
{"id1": "3252116", "id2": "10728243", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"getMD5": ["getSHA5", "getMD3", "getMAC5", " getSHA512", "getMD4", " getMD4", "getSHA512", "getMAC512", "getMD512", "getSHA3", " getMD512", " getSHA5", " getMD3", "getMP5", "getSHA4", " getSHA4", "getMP512", " getSHA3", "getMAC3", "getMAC4", "getMP4", "getMP3"], "source": ["connection", "sl", "f", "data", "slice", "from", "stream", "body", "base", "ource", "text", "output", "content", "SOURCE", "e", "password", "dest", "this", "secret", "buffer", "sp", "service", "parent", "object", "url", "config", "document", "code", "uri", "file", "src", "result", "input", "target", "Source", "resource", "fp", "security", "string"], "s": ["sl", "ts", "f", "sg", "si", "rows", "ds", "g", "ins", "als", "m", "services", "results", "sets", "p", "ns", "os", "ssl", "is", "ls", "b", "bytes", "ops", "r", "rs", "e", "its", "strings", "d", "S", "ings", "ws", "t", "js", "h", "bis", "gs", "n", "ps", "series", "sb", "ss", "es", "sym", "string", "fs", "ends", "ses"], "hexDigits": ["hashFormitives", "hexdigits", "hashFormats", "hexSignases", "hexdigals", "hexEdits", "hexEdists", "hashDigitives", "tempSignites", "hexEdites", "tempDigists", "hexDigases", " hexDigases", "hexSignit", "hexdigings", "hexFormists", "hexSignists", "hexSignites", " hexDigit", "hexSignitives", "hexFormats", "hexSignals", "tempDigites", "hashDigats", "hexDigitives", "hexDigites", "hexdigists", "tempSignals", "tempDigals", "hexDigats", "hexFormitives", "hexdigitives", "hexSignits", "hexSignats", "hexdigites", "hexDigals", "hashFormits", "tempSignists", "hexFormits", "hexdigases", "tempSignits", "hashDigits", "tempDigits", " hexDigings", "hexEdals", "hexdigit", "hexSignings", "hexDigists", "hexdigats", "hashFormists", "hexDigings", "hexDigit", "hashDigists"], "md": ["meta", "df", "bd", "vd", "f", "mag", "mg", "cd", "rm", "wd", "mad", "dd", "m", "ma", "em", " MD", "mt", "dig", "di", "mb", "mail", "am", "mac", "cmd", "dm", "um", "sm", "dc", "MD", "amd", "mi", "mp", "rpm", "metadata", "mm", "pm", "mu", "sha", "cm", "bf", "mc", "pd", "mand", "hd", "nm"], "tmp": ["meta", "extra", "app", "cb", "sup", "data", "stuff", "cpp", "seed", "array", "p", "buff", "wp", "bt", "proc", "fb", "base", "txt", "img", "bp", "pre", "dest", " temp", "temp", "rb", "test", "buffer", "pointer", "storage", "sp", "cmp", "pp", "api", "v", "config", "mp", "ppo", "params", "np", "append", "pad", "area", "obj", "now", "buf"], "str": ["cur", "iter", "sl", "data", "doc", "char", "arr", "ctr", "st", "j", "dec", "enc", "div", "hex", "cs", "pr", "part", "br", "text", "inner", "txt", "cr", "r", "err", "fr", "dr", "temp", "style", "sp", " sp", "hr", "spec", "exec", "sec", "v", "code", "unit", "STR", "pos", " substr", "sr", "tr", "obj", "ss", "exp", "string", "Str", "dict", "stri"], "k": ["x", "f", "y", "unk", "kw", "q", "g", "sk", "p", "j", "ck", "kat", "u", "b", "w", "ko", "ok", "work", "e", "key", "o", "dk", "kid", "d", "K", "ak", "ch", "ki", "kick", "v", "ek", "ku", "n", "c", "id", "kk", "mk", "ks"], "i": ["x", "ji", "f", "y", "si", "it", "ti", "ri", "m", "p", "j", "info", "pi", "hi", "I", "u", "b", "bi", "di", "multi", "shift", "qi", "l", "e", "abi", "d", "ini", "ci", "z", "t", "xi", "v", "oi", "ui", "li", "n", "uri", "ii", "io", "c", "in", "iu", "a", "chi", "mu", "index", "ai", "gi", "phi", "ip"], "byte0": ["number2", "pixel5", " byte5", "numberk", "pixel0", " byte2", "number0", "word0", "byte2", "number00", "pixelk", "byte5", "byte1", "letter2", "byte00", " byte6", " byte00", "pixel00", "letter0", "word2", "pixel6", "pixel2", "number5", "letterk", "bytek", " byte1", "word5", "number6", "number1", "word1", "byte6", "letter00"]}}
{"id1": "1097146", "id2": "18570190", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getContentdigifier", "getMessageSignest", "getMessagedigests", "getMessageDigester", "getMessagedigest", "getMessageEncester", "getMessageEncests", "getMessageEncifier", "getContentdigests", "getContentDigests", "getMessageEncest", "getContentDigest", "getMessagedigester", "getMessageSignests", "getContentDigester", "getContentdigest", "getMessagedigifier", "getMessageSignifier", "getMessageDigests", "getMessageDigifier", "getMessageSignester", "getContentdigester", "getContentDigifier"], "input": ["reader", "inf", "data", "self", "container", "type", "audio", "string", "stream", "array", "state", "str", "xml", "definition", "binary", "model", "text", "output", "instance", "inner", "content", "plus", "password", "address", "temp", "this", "buffer", "i", "source", "list", "image", "parse", "submit", "request", "parent", "object", "form", "context", "config", "argument", "raw", "empty", "null", "document", "element", "in", "message", "amp", "out", "target", "accept", "Input", "now"], "md": ["bm", "meta", "df", "bd", "vd", "mag", "mg", "rm", "wd", "mad", "dd", "m", "ma", " MD", "mt", "me", "di", "mb", "am", "mac", "M", "cmd", "dm", "um", "mn", "dr", "sm", "d", "dc", "MD", "gd", "mo", "mod", "amd", "mp", "rpm", "metadata", "mm", "pm", "sha", "cm", "bf", "mc", "ms", "od", "mand", "nm"], "bytes": ["pages", "vals", "values", "data", "blocks", "rows", "gb", "s", "bs", "groups", "body", "outs", "units", "codes", "binary", "base", "words", "les", "parts", "b", "files", "bits", "ies", "bles", "lines", "address", "its", "strings", "pieces", "ipes", "tes", "classes", "odes", "bps", "null", "keys", "seconds", "es", "Bytes", "string"]}}
{"id1": "5551393", "id2": "17083703", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getMD5": ["getM256", "getSHA5", "getMD256", "getM5", "getmd5", "getMD4", " getMD4", "getmd256", "getSHA512", " getMD256", "getmd4", "getMD512", " getM4", "getM512", " getM512", " getMD512", " getM5", " getM256", "getSHA4", "getM4", "getmd512", "getSHA256"], "source": ["data", "name", "slice", "seed", "secure", "info", "base", "ource", "text", "size", "output", "bytes", "content", "SOURCE", "address", "expected", "temp", "dest", "sm", "buffer", "service", "style", "proxy", "template", "object", "url", "config", "code", "unit", "file", "src", "message", "result", "input", "resource", "Source", "target", "security", "length", "string", "start"], "tmp": ["meta", "cb", "data", "current", "Temp", "stuff", "cpp", "py", "array", "body", "emp", "binary", "copy", "cache", "b", "part", "output", "txt", "zip", "var", "vm", "dest", "temp", "rb", "test", "buffer", "vt", "storage", "cmp", "tt", "default", "mp", "code", "metadata", "params", "src", "result", "sb", "bf", "fp", "nm", "foo", "html", "obj", "ignore", "buf"], "md": ["meta", "bd", "vd", "mag", "mg", "cd", "rm", "sd", "wd", "mad", "dd", "m", "ma", " MD", "mt", "ind", "ld", "di", "mb", "mac", "cmd", "zip", "dm", "mn", "d", "mmm", "MD", "gd", "mo", "mod", "amd", "mi", "oda", "mp", "rpm", "mm", "pm", "mu", "cm", "bf", "mc", "nd", "ms", "od", "mand", "nm", "ad", "hd", "pd", "editor"]}}
{"id1": "8000624", "id2": "11341711", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copyFrom", " transferFile", " copyTo", "copyTo", " copyto", "copyFile", "copyFrom", "CopyFile", " transferTo", "Copyto", "copyto", " transferto", " transferFrom", " copyFile", "CopyFrom"], "dest": ["bin", "data", "sup", "name", "opt", "later", " destination", "table", "them", "cont", "destroy", "comb", "class", "orig", "die", "desc", "w", "output", "txt", "content", "img", "done", "dist", "temp", "test", "source", "path", "filename", "object", " Dest", "delete", "exit", "flat", "file", "wb", "folder", "transform", "src", "Dest", "target", "write", "obj", "tmp", "rest"], "in": ["x", "reader", "bin", "connection", "isin", "sin", "f", "login", "issue", "s", "ins", "pin", "m", "cin", "In", "vin", "inside", "kin", "conn", "b", "inner", "again", "rin", "win", "r", "l", "din", "IN", "ax", "plus", "pull", "ini", "i", "source", "image", "init", "inc", "lib", "nin", "h", "n", "pass", "thin", "inn", "as", "up", "fa", "id", "wave", "lin", "input", "con", "ln", "re", "ac", "gin"], "out": ["x", "bin", "app", "ext", "outside", "data", "name", "socket", "pin", "sync", "ex", "outs", "not", "timeout", "one", "copy", "conn", "w", "b", "output", "cache", "again", "inner", "part", "vert", "user", "writer", "err", "plus", "o", "off", "OUT", "temp", "this", "client", "call", "i", "lib", "external", "image", "inc", "nin", "or", "outer", "exec", "object", "other", "url", "no", "our", "n", "io", "net", "up", "file", "target", "ou", "Out"], "c": ["x", "abc", "cb", "arc", "f", "char", "sc", "m", "ca", "ct", "C", "p", "enc", "ec", "pc", "rc", "lc", "u", "content", "cr", "l", "r", "e", "o", "exc", "esc", "dc", "d", "i", "pointer", "ci", "cc", "comment", "buffer", "ch", "t", "uc", "cf", "xc", "v", "cl", "config", "code", "n", "oc", "cu", "ce", "ic", "cm", "ac", "col", "fc", "bc", "cy"]}}
{"id1": "19494842", "id2": "17901739", "code1": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "code2": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "label": 1, "substitutes": {"callService": ["testService", "CallProxy", " callProxy", "CallServices", "callservice", "testProxy", "Callservice", " callservice", "CallService", "callProxy", "testservice", "testServices", "callServices", " callServices"], "url": ["connection", "open", "sl", "f", "socket", "ur", "stream", "web", "base", "ssl", "ll", "log", "blog", "conn", "b", "user", "l", "r", "e", "client", "address", "this", "Url", "service", "URL", "source", "i", "feed", "path", "server", "uri", "http", "file", "resource", "queue", "host", "json", "string"], "in": ["reader", "bin", "login", "f", "data", "into", "doc", "socket", "s", "ins", "stream", "In", "is", "kin", "ssl", "b", "inner", "again", "win", "din", "line", "r", "IN", "err", "client", "ini", "buffer", "i", "source", "init", "image", "inc", "h", "inn", "c", "file", "id", "impl", "lin", "input", "out", "re", "gin", "fb"], "inputLine": ["outputValue", "outputLine", "inputRow", "inputValue", " inputValue", "streamline", " inputRow", "readline", "outputline", "inputL", " inputline", " inputFrame", "requestL", "readLine", "streamLine", "InputString", "InputLine", "InputL", " inputL", "inputFrame", "Inputline", "streamString", "outputRow", " inputString", "requestline", "readValue", "readRow", "InputFrame", "inputline", "requestLine", "inputString", "requestString", "streamFrame"], "buf": ["cb", "ob", "f", "data", "ff", "bu", "pool", "gb", "array", "buff", "aux", "Buffer", "bh", "binary", "log", "base", "fun", "bb", "cache", "b", "br", "abs", "bag", "exc", "rb", "buffer", "db", "ctx", "builder", "cf", "context", "conv", "cv", "ab", "pb", "wb", "nb", "af", "uf", "cas", "result", "queue", "append", " buffer", "pad", "bf", "header", "fp", "sb", "coll", "string", "fb", "bc", "pkg"], "answer": ["su", "issue", "name", "question", "side", "stuff", "sn", "session", "complete", "answered", "install", "array", "say", "settings", "status", "blank", "description", "cache", "address", "reply", "knowledge", "swers", "entry", "ask", "value", "response", "order", "attribute", "update", "server", "empty", "uri", "Answer", " answers", "fix", "prefix", "word", "search", "message", "result", "option", "username", "site"]}}
{"id1": "8069594", "id2": "3767903", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", " copyfile", "copyFolder", "transferFile", " copiedfile", "transferFolder", "transferfile", " copyFiles", " copyFolder", " copiedFile", " copiedFolder", "transferFiles", "copyfile", " copiedFiles"], "in": ["x", "reader", "bin", "lock", "login", "data", "name", "it", "at", "ins", "pin", "m", "ex", "min", "In", "base", "part", "inner", "again", "win", "old", "din", "work", "IN", "err", "this", "i", "source", "image", "inc", "or", "exec", "url", "config", "null", "io", "inn", "file", "as", "id", "index", "a", "ic", "up", "input", "diff"], "out": ["x", "bin", "ext", "outside", "name", "version", "at", "to", "p", "ex", "outs", "one", "not", "plain", "base", "conn", "b", "all", "output", "vert", "again", "user", "old", "line", "writer", "err", "plus", "o", "off", "OUT", "this", "external", "source", "image", "inc", "exec", "object", "outer", "v", "update", "n", "server", "null", "io", "c", "file", "up", "about", "target", "Out", "write"], "inChannel": ["loginChannel", "loginchannel", "INChannel", "inContext", "binClient", "binStream", "INChan", "inConnection", "outStream", "Inchannel", "outContext", " inConnection", "loginContext", "InChan", "InStream", "inchannel", "inputContext", " inChan", "loginStream", "outchannel", "INClient", " inStream", "binChannel", "outChan", "inputConnection", "inClient", "INchannel", "INConnection", "inputChan", "inputChannel", "inChan", "inputStream", "inputchannel", "inStream", "binChan", " inClient", "InConnection", "InChannel", "INStream"], "outChannel": ["innerChan", "againContext", "againchannel", "outputConnection", " outStream", "inContext", "inConnection", "innerStream", "outputStream", "againStream", " outConnection", "outputChan", "outStream", "oStream", "outContext", "innerContext", "inchannel", "againChannel", "outchannel", "ochannel", "OutChan", " outChan", "outChan", "againChan", "OutStream", "outConnection", "Outchannel", "againConnection", "OutChannel", "inChan", "innerChannel", "oChannel", "outputChannel", "inStream", " outchannel", "oChan"]}}
{"id1": "13852596", "id2": "2461169", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"execute": ["create", "handle", "ute", "install", "load", "copy", "register", "all", "evaluate", "Exec", "test", "call", "parse", "run", "submit", "process", "exec", "transfer", "code", "server", " perform", " invoke", "report", "invoke", "start", "apply"], "resources": ["ids", "pages", "thumbnails", "images", "maps", "issues", "groups", "services", "results", "events", "relations", "works", "cells", "items", "models", "Resources", "files", "features", "roots", "stores", "apps", "workers", "flows", "writers", "strings", "scripts", "chains", "rates", "archives", "rings", "stars", "objects", "classes", "ions", "series", "locks", "params", "users", "projects", "resource", "rules", "reports", "types", "plugins"], "i": ["f", "si", "ti", "ri", "iri", "s", "ori", "j", "info", "pi", "p", "k", "ie", "is", "hi", "bi", "di", "I", "u", "multi", "ami", "qi", "l", "e", "o", "ini", "abi", "cli", "ci", "we", "h", "xi", "oi", "v", "ui", "li", "ir", "uri", "ani", "ii", "io", "id", "iu", "mu", "vi", "ic", "eni", "gi", "ai", "phi", "esi", "ip", "wei", "isi"], "classFile": ["ClassFILE", "finalUrl", "ClassPath", "fileDirectory", "ruleFiles", "CLASSEntry", "ClassEntry", "connectionStream", "finalFile", "finalfile", "Classfile", "classClass", " classFactory", "classFilename", "sessionEntry", "CLASSImage", "classfile", " classFiles", "serviceFile", "ClassClass", " classfile", "ClassDir", "classFILE", "fileFiles", "customEntry", "ClassFiles", "lassGlobal", " classPage", "classFactory", "sessionFactory", "sessionFile", "lassClass", "ClassLine", "baseFile", "ClassPage", "CLASSFile", "classLine", "ruleFile", "staticfile", "ClassFactory", "sessionFiles", "lassFile", "classPath", "connectionFiles", "classFiles", "packEntry", " classStream", "customFiles", "classImage", "servicefile", "classEntry", "packfile", " classGlobal", "CLASSFILE", "sessionfile", "basefile", "ClassStream", " classFILE", "classStream", "classesFiles", "classLoader", "CLASSUrl", " classFilename", "classesFile", " classClass", "ClassImage", "CLASSfile", "ClassFile", "ClassGlobal", "objectDir", "fileImage", "CLASSLoader", "ClassFilename", "objectFile", "lassFiles", "objectfile", "baseFILE", "CLASSFiles", "CLASSDirectory", " classLine", "ruleFilename", " classLoader", " classPath", "baseUrl", "packFile", "customFILE", "ClassDirectory", "CLASSLine", "fileLine", "finalFILE", "customFile", "CLASSPage", "staticLine", "staticFile", "classPage", "connectionfile", "serviceLine", "staticFILE", "classDirectory", " classDir", "ruleLine", "classesfile", "serviceFILE", "sessionFILE", "classesPath", "fileLoader", "fileFile", "classDir", "connectionFile", " classEntry", "classGlobal", "objectFiles", "packFILE", "filefile", "classUrl"], "inputStream": ["binaryFile", "inputFile", "childstream", " inputstream", "inputSteam", "InputSw", "outputReader", "uploadFile", "outputFile", "initStream", "binaryStream", "initSteam", "outputSw", "childStream", "InputStream", " inputReader", "InputStreamer", "rawStreamer", "inputSw", "inputContext", "binaryStreamer", "outputStreamer", "binarySteam", "uploadSw", "inputStreamer", "childContext", " inputStreamer", "outputContext", "activeStreamer", "childReader", "rawStream", "rawSteam", " inputFile", "uploadStream", "importStream", "activestream", "activeStream", "initstream", "Inputstream", "InputFile", "uploadstream", "importSteam", " inputContext", "outputSteam", "rawFile", "initStreamer", "activeSteam", "InputSteam", "inputstream", "importstream", " inputSteam", "inputReader", "outputstream", "importStreamer"], "reader": ["iter", "er", "director", "manager", "ri", "handler", "book", "worker", "seed", "stream", "sync", "layer", "shared", "ger", "arser", "per", "rc", "copy", "keeper", "inner", "loader", "wrapper", "rer", "parser", "writers", "client", "key", "dr", "rr", "row", "buffer", "source", "ner", "entry", "oder", "war", "builder", "driver", "or", "request", "reflect", "system", "context", "reading", "read", "server", "author", "io", "owner", "http", "draft", "rar", "right", "resource", "input", "riter", "report", "re", "Writer", "ler", "ee", "Reader", "editor", "rx"], "oldSize": ["OldName", "oldName", "prevLength", "oldSc", "OldSize", "oldLength", "prevName", "prevSize", "OldSc", " oldLength", " oldName", "prevSc", " oldSc", "OldLength"], "writer": ["iter", "er", "director", "data", "manager", "widget", "handler", "writ", "worker", "creator", "string", "winner", "dc", "format", "maker", "writing", "w", "loader", "wrapper", "inner", "walker", "her", "r", "engine", "e", "parser", "writers", "row", "buffer", "ner", "service", "player", "oder", "war", "child", "builder", "driver", "write", "rw", "object", "document", "read", "author", "io", "element", "wr", "wire", "draft", "wer", "word", "index", "written", "resource", "token", "riter", "report", "Writer", "ler", "ee", "Reader", "editor"], "b": ["be", "abc", "bin", "bd", "f", "g", "m", "boot", "p", "k", "eb", "binary", "base", "bb", "u", "B", "w", "br", "l", "r", "e", "rb", "buffer", "d", "bar", "emb", "db", "lb", "ba", "h", "object", "null", "ab", "c", "a", "orb", "fb", "pb", "ob"], "outputStream": ["inputSteam", "outstream", "OutputSteam", "dataContainer", "protectedStreamer", "dataStream", " outputView", "outStream", "OutputStreamer", "protectedStream", "inputContainer", "outSteam", "dataStreamer", "inputView", "OutputStream", "outputStreamer", "Outputstream", "inputStreamer", " outputstream", "outStreamer", "protectedstream", "protectedSteam", " outputContainer", " outputSteam", "outputSteam", "outputView", "dataSteam", "inputstream", " outputStreamer", "outputstream", "outputContainer", "OutputView"], "injectedClasses": ["injectionclassies", "injectionClasses", "injectedWritites", "injectedclassites", "injectionClassites", "injectedClassies", "injectedClassites", "injectedProjecties", "injectedWrits", "injectedclasss", "injectionclasss", "injectedProjectes", "injectionClasss", "injectedProjects", "injectedWrites", "injectedWrities", "injectedClasss", "injectionclasses", "injectedProjectites", "injectionclassites", "injectionClassies", "injectedclassies", "injectedclasses"], "newSize": ["NewLength", "NewSize", "newFontSize", "finalLength", " newLength", " newFontSize", "NewFontSize", "finalSize", "newStorage", "finalFontSize", "NewStorage", "newLength", "finalStorage", " newStorage"]}}
{"id1": "10383721", "id2": "15516136", "code1": "    @SuppressWarnings(\"unchecked\")\n    private ReaderFeed processEntrys(String urlStr, String currentFlag) throws UnsupportedEncodingException, IOException, JDOMException {\n        String key = \"processEntrys@\" + urlStr + \"_\" + currentFlag;\n        if (cache.containsKey(key)) {\n            return (ReaderFeed) cache.get(key);\n        }\n        List<Post> postList = new ArrayList<Post>();\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Cookie\", \"SID=\" + sid);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n        SAXBuilder builder = new SAXBuilder(false);\n        Document doc = builder.build(reader);\n        Element root = doc.getRootElement();\n        Namespace grNamespace = root.getNamespace(\"gr\");\n        Namespace namespace = root.getNamespace();\n        String newflag = root.getChildText(\"continuation\", grNamespace);\n        String title = root.getChildText(\"title\", namespace);\n        String subTitle = root.getChildText(\"subtitle\", namespace);\n        List<Element> entryList = root.getChildren(\"entry\", namespace);\n        DateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n        for (Element e : entryList) {\n            Post post = new Post();\n            post.setTitle(e.getChildText(\"title\", namespace));\n            try {\n                post.setDate(sdf.parse(e.getChildText(\"published\", namespace)));\n            } catch (ParseException e1) {\n            }\n            post.setUrl(e.getChild(\"link\", namespace).getAttributeValue(\"href\"));\n            post.setSauthor(e.getChild(\"author\", namespace).getChildText(\"name\", namespace));\n            String content = e.getChildText(\"content\", namespace);\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"description\", namespace);\n            }\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"summary\", namespace);\n            }\n            post.setContent(content);\n            postList.add(post);\n        }\n        ReaderFeed readerFeed = new ReaderFeed();\n        readerFeed.setTitle(title);\n        readerFeed.setSubTitle(subTitle);\n        readerFeed.setFlag(newflag);\n        readerFeed.setPostList(postList);\n        cache.put(key, readerFeed);\n        return readerFeed;\n    }\n", "code2": "    public static synchronized BufferedImage loadBufferedJPEGImage(URL url) {\n        BufferedImage image = null;\n        if (url != null) {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(in);\n                image = decoder.decodeAsBufferedImage();\n            } catch (Exception e) {\n                log.severe(\"URL: \" + url + \" - \" + e.getMessage());\n                image = null;\n            } finally {\n                try {\n                    if (in != null) in.close();\n                } catch (IOException ioe) {\n                    log.severe(\"URL: \" + url + \" - \" + ioe.getMessage());\n                }\n            }\n            if (image != null) {\n                log.config(\"Image type : \" + image.getType());\n                if (image.getWidth() <= 0 || image.getHeight() <= 0) {\n                    log.severe(\"URL: \" + url + \" =0\");\n                    image = null;\n                }\n            }\n        }\n        return image;\n    }\n", "label": 0, "substitutes": {"processEntrys": ["processDistriers", "processDistris", "processENTrings", "processEntris", "processEllriers", "runEntris", "processEllrys", "processEntriers", "processEllrings", "processDistrys", "processENTris", "runENTrys", "processEllris", "runEntriers", "processEntrings", "runENTris", "processDistrings", "processENTriers", "runENTrings", "runEntrys", "runENTriers", "runEntrings", "processENTrys"], "urlStr": ["uriStr", "URLSTR", "UrlStr", "httpSTR", "urlSTR", "urlString", "uriString", "httpStr", "filestr", " urlstr", "resourceSTR", " urlString", "urlstr", "uriSTR", "httpstr", "UrlSTR", "urlSt", "Urlstr", "httpString", "URLString", "resourcestr", "fileSTR", "fileStr", " urlSTR", "resourceString", " urlSt", "URLSt", "uriSt", "URLStr", "resourceStr"], "currentFlag": ["currentBit", "currentTag", "nextflag", "nextTag", " currentText", "currentField", "activeTag", " currentField", "activeFLAG", "CurrentBit", "nextFlag", "CurrentText", "reportedText", "reportedBit", "activeflag", " currentBit", "CurrentFLAG", "reportedField", "reportedFlag", "currentflag", "activeFlag", "CurrentField", "CurrentFlag", "nextFLAG", "currentFLAG", "currentText", "CurrentTag", "Currentflag"], "key": ["full", "msg", "lock", "data", "name", "point", "roy", "type", "method", "seed", "k", "field", "lease", "str", "ie", "base", "rule", "here", "match", "cache", "KEY", "text", "check", "part", "section", "mac", "query", "ace", "secret", "kid", "list", "step", "entry", "service", "value", "or", "path", "parent", "hash", "sign", "empty", "keys", "scope", "function", "id", "search", "prefix", "message", "fix", "ey", "ry", "fee", "exp", "string", "Key"], "postList": [" postlist", "postlist", "postGroup", "PostCollection", "Postlist", "POSTList", "PostList", "POSTlist", "postCollection", " postGroup", " postCollection", "POSTCollection", "POSTGroup", "PostGroup"], "url": ["sl", "director", "data", "loc", "org", "socket", "channel", "ur", "web", "base", "ssl", "log", "page", "conn", "cache", "text", "l", "client", "address", "Url", "service", "URL", "entry", "image", "build", "feed", "proxy", "path", "server", "uri", "http", "file", "www", "resource", "host", "link", "location", "string"], "connection": ["open", "director", "version", "machine", "channel", "socket", "handler", "database", "remote", "creator", "body", "to", "application", "position", "conn", "b", "wrapper", "section", " Connection", "l", "writer", "collection", "password", "client", "proxy", "connected", "URL", "condition", "connect", "response", "object", "character", "config", "document", "relation", "uri", "server", "number", "io", "http", "c", "function", "resource", "con", "out", "directory", "Connection", "communication"], "reader": ["iter", "er", "f", "data", "channel", "handler", "stream", "body", "xml", "per", "loader", "r", "writer", "parser", "client", "row", "buffer", "entry", "oder", "feed", "driver", "document", "read", "server", "reading", "io", "file", "resource", "input", "ler", "Reader", "editor"], "builder": ["er", "manager", "database", "building", "creator", "info", "xml", "base", "b", "loader", "bridge", "wrapper", "keeper", "builders", "r", "writer", "bug", "parser", "bean", "client", "row", "buffer", "entry", "build", "image", "db", "driver", "or", "editor", "Builder", "default", "config", "document", "http", "result", "runner"], "doc": ["doctor", "open", "app", "df", "f", "data", "tree", "git", "body", "Doc", "info", "div", "str", "xml", "ger", "gen", "base", "text", "r", "writer", "bug", "parser", "dr", "md", "dc", "d", "lib", "build", "db", "project", "context", "document", "file", "resource", "coll", "dir", "docs", "html", "graph", "node"], "root": ["data", "name", "archive", "container", "creator", "div", "roots", "section", "path", "default", "null", "rt", "owner", "html", "element", "tree", "error", "sys", "Root", "page", "inner", "front", "query", "rew", "back", "project", "parent", "outer", "document", "author", "result", "record", "home", "leaf", "node", "director", "ver", "remote", "first", "xml", "component", "nav", "loader", "r", "writer", "parser", "rup", "n", "empty", "http", "valid", "rss", "manager", "master", "head", "body", "zero", "bot", "rec", "top", "box", "user", "article", "comment", "entry", "db", "child", "ree", "server", "scope", "right", "cover", "string"], "grNamespace": ["grnamespe", "grNamesche", "GrNamespace", "Grnamespe", "grnamespace", "grMemberspaces", "grNamespe", "grMembersche", "grNamespaced", "Grnamescape", "grMemberspace", "grNamescape", "grnamescape", "Grnamespaces", "GrNamescape", "grnamespaced", "Grnamespace", "GrNamespaced", "grNamespaces", "grnamespaces", "GrNamespe", "GrNamesche", "grnamesche", "grMemberspaced", "GrNamespaces"], "namespace": ["workspaces", "namespec", "kesase", " namespaces", "namescape", "Namesase", "New", "kespaced", " namespaced", "Namespec", "Namespaces", " namespect", "nameternal", "inasspace", "workspect", "Namesternal", "Namespect", " namesception", " namespec", "Namesace", "Namescore", "Namescape", "namespect", "memberspace", " Namespaced", "technpace", "namesception", " Namespec", "namescore", "membersspace", "Namespaced", "membersternal", "namesase", "namespaced", "_", "memberscore", "xml", "add", "memberspaces", " Namespaces", "inaspace", "namesace", " namesspace", "this", "Namesspace", "namespaces", "feed", "memberscape", "http", "Namesception", " namescore", " namesternal", " namesace", " namescape", "namesternal", "kespace", "s", "namecape", "Namespace", " Namespace", "worksception", "namesspace", "namepace", "membersace", " namesase", "workspace", "inasace", "technspace", "nameception", "inasternal", "namepaces"], "newflag": ["lnstyle", " newStatus", " newstyle", "newStatus", "nextflag", " newFlag", "nextstyle", "newFlag", "nextStatus", "lnStatus", "lnFlag", "newstyle", "nextFlag", "lnflag"], "title": ["name", "version", "type", "body", "Title", "label", "summary", "format", "description", "itle", "text", "term", "subject", "Content", "published", "template", "itles", "filename", "author", "details", "message", "header", "resource", "html", "license"], "subTitle": ["ubTitle", " subtitle", "subName", "ubtitle", "SubTitle", " subName", "ubName", "SubName", "Subtitle", " subDescription", "subtitle", "ubDescription", "SubDescription", "subDescription"], "entryList": ["entrylist", "elementList", "ziplist", "entryLIST", "zipList", " entryQueue", "elementQueue", " entryChain", " entryL", "zipLIST", "tryList", "elementChain", "trylist", "tryChain", "elementlist", "postlist", "zipL", "entryChain", "entryL", "postL", " entryLIST", " entrylist", "postLIST", "tryQueue", "entryQueue"], "sdf": ["ssdd", "sdd", " sde", "rsdd", "ssde", "rsdf", "asdd", "scf", "asdf", "psde", "psdd", "sde", "Sdf", " scf", "psdf", "Sfd", "Sdd", "rsfd", "asde", "rsde", "ascf", "pscf", " sdd", "ssfd", "Sde", "ssdf", "sfd"], "e": ["be", "le", "er", "f", "y", "oe", " pe", "edge", "ze", "el", "m", "ente", "p", "j", "se", " event", "ge", "one", " entity", "ae", "en", "ec", "eb", "event", "me", "ie", " me", " E", "entity", "je", "r", "l", "line", "E", "o", "d", " element", "entry", "ne", "i", " ie", "t", "Element", "enter", "te", "n", "pse", "c", "eu", "ce", "ele", "ed", "ve", "ea", "de", "esi", "ee", "end", "element", "node"], "post": ["get", "edit", "archive", "posted", "head", "create", "tax", "install", "p", "one", "wp", "load", "set", "add", "copy", "page", "check", "user", "text", "part", "op", "article", "pre", "posts", "patch", "row", "list", "comment", "entry", "style", "feed", "child", "project", "mod", "Post", "POST", "object", "cross", "next", "form", "system", "default", "read", "server", "pass", "author", "the", "index", "valid", "upload", "result", "ost", "record", "link", "home", "draw", "push", "pod", "maybe", "node"], "content": ["data", "name", "version", "archive", "language", "body", "status", "summary", "description", "page", "text", "output", "size", "Content", "source", "image", "template", "value", "path", "comments", "code", "file", "draft", "script", "message", "resource", "header", "media"]}}
{"id1": "22057083", "id2": "18544890", "code1": "    private void Connect() throws NpsException {\n        try {\n            client = new FTPClient();\n            client.connect(host.hostname, host.remoteport);\n            int reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                client.disconnect();\n                client = null;\n                com.microfly.util.DefaultLog.error_noexception(\"FTP Server:\" + host.hostname + \"refused connection.\");\n                return;\n            }\n            client.login(host.uname, host.upasswd);\n            client.enterLocalPassiveMode();\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            client.changeWorkingDirectory(host.remotedir);\n        } catch (Exception e) {\n            com.microfly.util.DefaultLog.error(e);\n        }\n    }\n", "code2": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"Connect": ["Construct", "Build", "Init", "Client", "Socket", "New", "Dial", "Open", "Subscribe", " Connection", "Connector", "Remote", "connected", "connect", "Create", "Close", "Fail", "Conn", "Host", "Config", "Load", "Login", "Sync", " Close", "Process", "Connection", "Run", "Setup"], "client": ["connection", "open", "cn", "util", "manager", "force", "name", "socket", "channel", "pool", "get", "session", "handler", "remote", "command", "secure", "Client", "clean", "ci", "local", "pc", "per", "plugin", "ssl", "call", "conn", "cache", "cloud", "user", "cell", "console", "proxy", "lib", "cli", "cc", "service", "connect", "port", "api", "request", "child", "parent", "project", "cl", "cod", "config", "friend", "close", "server", "code", "core", "default", "http", "c", "ce", "co", "resource", "cm", "con", "host", "cp", "ace", "end", "grid"], "reply": ["connection", "answer", "error", "reason", "related", "respond", " replies", " response", "sync", "send", "info", "ply", "state", "bot", "rc", "status", "echo", "part", "repl", "query", "err", "address", "dy", "ret", "call", "comment", "buffer", "continue", "Reply", "request", "response", "next", "code", "read", "post", "ping", "prefix", "message", "result", "link", "replace", "resp"]}}
{"id1": "13122204", "id2": "7149578", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unpackProject", "unpackFile", "Unzipmodel", "unzipFile", "unpatchProject", "UnzipModel", "unpackmodel", "unpatchmodel", "UnarchiveProject", "unpackModel", "UnzipFile", "unzipmodel", "unzipProject", "UnarchiveFile", "unpatchModel", "Unarchivemodel", "unpatchFile", "unarchivemodel", "unarchiveFile", "unarchiveProject", "unarchiveModel", "UnarchiveModel", "UnzipProject"], "filename": ["username", "fits", "loc", "f", "name", "File", "database", "download", "fil", "SourceFile", "nil", "model", "kl", "Filename", "files", "txt", "jet", "l", "fn", "source", "path", "url", "uri", "file", "folder", "title", "module", "src", "fd", "utf", "FILE", "bf", "fp", "directory", "location", "string", "il"], "tempdir": ["temdir", "Tempfolder", "tmpdirectory", "tempDIR", "Tempdirectory", " tempDIR", "tempfolder", "temdirectory", " tempDir", "temfolder", "tempDir", " tempfolder", "tempdirectory", "tmpfolder", "tempath", "TempDir", " tempdirectory", "tmppath", " temppath", "temDir", "TempDIR", "temppath", "Tempdir", "tmpDIR", "tmpDir", "tmpdir"], "dest": ["prop", "nt", "cdn", "loc", "opt", "sup", "later", "session", "handler", "st", "cont", "sync", "comb", "gen", "proc", "log", "di", "die", "walker", "output", "inner", "txt", "done", "zip", "trans", "export", "dist", "temp", "std", "dc", "test", "source", "builder", " Dest", "delete", "ui", "exit", "walk", "transfer", "store", "default", "flat", "file", "wb", "transform", "folder", "src", "Dest", "result", "target", "dir", "dat", "usr", "home", "de", "desc", "obj", "tar", "tmp", "rest"], "fis": ["fid", "fiss", "fisa", " fid", "flisa", "fsisa", "filebis", "flis", "flbis", "fsbis", "filei", "fileisa", "fileiss", "fi", "fileis", " fi", "fliss", "fbis", "lid", "li", " fiss", "fsis", "fsiss", "liss", "lis", "fileid"], "BUFFER": ["MAFIX", "BOFFER", "BOFER", "UPVER", " BUVER", "BOPER", "BUFF", "BOFIX", " BUFF", "TAFFER", " BUFIX", "CUVER", "UPFF", " BUVEN", " BUUCK", "BUVER", "SAFFER", "CUUCK", "UPVEN", "BUVEN", "BUFIX", "BUPER", "UPFFER", " BUFER", "SAPER", "MAFFER", "TAPER", "TAVER", "CUFFER", "BUFER", "SAVER", "CUVEN", "CUFF", "MAPER", "CUPER", "BUUCK", " BUPER", "SAUCK", "MAFER", "TAUCK"], "zis": ["ji", "zins", " zbis", "zisa", "yis", "Zis", " zi", " zii", "Zas", "xis", "zii", " zin", "zas", "ziss", "zin", "zipis", "yisa", " ziss", "yIS", "zipin", "xists", "Zisa", " zIS", " zins", "xos", "xii", " zas", "zipIS", " zos", "zipisa", "dis", "jis", "zipins", "jists", "dbis", "xi", "dii", " zisa", "zIS", "zi", " zists", "xiss", "diss", "zists", "Zins", "zipas", "yin", "zbis", "xbis", "zos", "jos"], "entry": ["nt", "reader", "connection", "si", "name", "archive", "ries", "ident", "info", "ge", "se", "ie", "rc", "match", "lc", "Entry", "part", "inner", "je", "her", "zip", "ace", "line", "e", "la", "row", "cat", "pack", "image", "feed", "inc", "or", "source", "spec", "next", "enter", "iterator", "li", "server", "pe", "jo", "file", "ce", "way", "module", "valid", "id", "porter", "ry", "result", "cel", "record", "ou", "ent", "de", "end", "element"], "count": ["iter", "f", "name", "_", "current", "allow", "type", "low", "counter", "ind", "base", "log", "add", "part", "b", "size", "time", "weight", "cache", "line", "val", "max", "e", "writer", "key", "buffer", "list", "Count", "cond", "i", "limit", "feed", "use", "next", "sum", "number", "code", "read", "core", "c", "in", "file", "id", "index", "pos", "len", "last", "coll", "length", "write", "start", "end"], "data": ["reader", "name", "batch", "body", "array", "info", "load", "str", "zero", "base", "format", "shift", "size", "bytes", "content", "la", "d", "buffer", "block", "image", "pack", "feed", "media", "value", "next", "number", "raw", "read", "DATA", "pos", "index", "len", "message", "a", "id", "result", "dat", "input", "record", "length", "alpha", "write", "start"], "fos": ["xoes", "afis", " foes", "bOS", "afops", "xoos", "bos", " foos", "fOS", " fOS", "xops", "afos", "foes", "dfops", "fops", "xos", "afOS", "bis", "dfos", "bops", "dfoos", "foos", " fops", "dfoes"]}}
{"id1": "21754659", "id2": "10212189", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 0, "substitutes": {"getButtonSonido": ["getbuttonSenico", "getButtonJonendo", "getbuttonSonido", "getbuttonSonira", "getbuttonSenira", "getButtonSonico", "getButtonSonendo", "getButtonSonira", "getButtonSenira", "getButtonJonira", "getButtonSenendo", "getbuttonSenendo", "getButtonSenico", "getbuttonSenido", "getbuttonSonico", "getButtonJonido", "getButtonJonico", "getbuttonSonendo", "getButtonSenido"], "buttonSonido": ["ButtonSonado", "buttonDonido", "buttonTanado", "btnSonigo", "buttonSenini", "btnDonido", "ButtonSonido", "buttonsonado", " buttonSonida", " buttonSonardo", "buttonSonado", "buttonsonigo", "buttonSenino", " buttonSenino", "buttonTanido", " buttonSonino", "buttonDonida", "buttonDonigo", "buttonHomardo", "buttonSonini", "buttonDonardo", "btnSonardo", "ButtonSonini", "buttonSenardo", "btnDonado", " buttonSenida", "ButtonSonida", "ButtonDonido", "ButtonDonardo", " buttonSonado", "ButtonSonardo", "buttonHomida", "buttonDonino", "buttonsonido", "buttonHonino", " buttonSenido", "buttonSenido", "buttonSenado", "buttonDonini", "btnDonigo", "buttonHomido", "btnSonini", "buttonTanardo", "buttonHomado", "buttonSonida", "ButtonDonado", "buttonSonardo", "buttonHonardo", "buttonHonado", "buttonSonigo", "ButtonDonini", " buttonSenardo", "buttonHonido", "btnSonado", "buttonSenigo", "buttonSenida", "btnSonido", "buttonDonado", "ButtonDonida", "buttonsonardo", " buttonSenado", "buttonSonino", "buttonsonini", "buttonTanida", "btnDonardo"], "e": [" ev", " exp", " pe", " Event", "event", " te", " E", " exc", " ignored", " other", " cause", "E", " je", " ace", "t", "Event", " ie", " exception", " en", " inst", "ed", " caught", " ate", " fe", " events", "ee", " invoked"], "fc": ["LC", "f", "WF", "wt", "fl", "nc", "fw", "FS", "ct", "irc", "wic", "FC", "enc", "fe", "ec", "pc", "xf", "fed", " FC", "lc", "isc", "GF", "roc", "wk", "F", "fn", "fi", "WC", "fr", "lf", "PF", "bc", "Factory", "CF", "dc", "fx", "DC", "cf", "xc", "c", "fa", "af", "fd", "FE", "tc", "flo", "bf", "con", "mc", "fp", "fm", "fb", "fs", "il"], "returnVal": ["ReturnNum", "returnval", "continueVal", "continueValue", "continueval", " returnVAL", "returnNum", " returnval", "returnValue", "continueNum", "ReturnValue", " returnValue", " returnNum", "Returnval", "backVal", "backVAL", "backValue", "ReturnVAL", "returnVAL", "ReturnVal", "backval"], "file": ["full", "lock", "connection", "f", "data", "get", "name", "File", "socket", "handler", "type", "to", "info", "fe", "local", "class", "base", "binary", "per", "log", "page", "part", "user", "b", "files", "zip", "l", "single", "lib", "source", "image", "db", "ile", "cf", "feed", "path", "filename", "object", "url", "document", "uri", "io", "http", "global", "folder", "function", "php", "up", "message", "FILE", "resource", "out", "fp", "sf", "dir", "directory", "input", "use"], "rutaGlobal": ["srutaLocal", "rugaReal", " rutaGeneral", "srottaLocal", "rutaLocal", "rettaInternational", "rutiGlobal", "rutaReal", "rugaInternational", "rutoGeneral", "srutaCore", "rutiGeneral", "rundaGeneral", "rutiLocal", "srettaGlobal", "srettaReal", "srottaCore", "rottaLocal", "rutiReal", "rutoInternational", "rutoCore", "srutaReal", "rottaGlobal", "rugaGlobal", "rundaInternational", "rottaGeneral", "rutaInternational", " rutoGeneral", "srutaInternational", "srettaLocal", "rutiCore", "rucaGeneral", "rutaCore", "srettaInternational", " rutaInternational", "rutaGeneral", " rutoInternational", "srutaGeneral", "rettaGlobal", "rutiInternational", "rugaLocal", "rundaGlobal", "rottaCore", "rucaGlobal", "rucaInternational", "rettaLocal", "rettaReal", "srottaGlobal", "rutoLocal", " rutoGlobal", "srutaGlobal", "rutoGlobal", "srottaGeneral"], "rutaRelativa": ["rutaRelativ", "rutaMalativo", "rutaRelativism", "rutaRelATiva", "rutaRelATivas", "rutaRelateivo", "rutaRelarativas", "rutaRelATiv", "rutaMalariva", "rutaRelateivism", "rutaMalarivism", "rutaRelarivas", "rutaRelarativo", "rutaRelariva", "rutaMalarivo", "rutaRelateiva", "rutaRelattivas", "rutaRelattiv", "rutaRelativo", "rutaRelativas", "rutaMalarivas", "rutaMalativas", "rutaRelattivo", "rutaMalativism", "rutaRelarativa", "rutaRelateiv", "rutaRelATivo", "rutaRelattivism", "rutaRelariv", "rutaRelarativ", "rutaRelarivo", "rutaRelattiva", "rutaRelarivism", "rutaMalativa", "rutaRelarativism"], "fis": ["friss", "fiss", " fris", "fys", "vos", " fys", "FIs", "fir", "Fys", "xis", "fIs", "vis", " fIs", "viss", "Fis", "vIs", "xys", "Fiss", "fros", "Fir", " fiss", "xiss", "Fos", "fris", "xris", "Fris", " fir", "frir"], "fos": ["Fo", "tfo", "infios", "tfos", "FOS", "Fops", "focks", "fOS", " fOS", "fileos", "Focks", "Fios", "fops", "Fis", "fileo", "infos", "fios", "tfops", "infOS", "Fos", "fileocks", " fo", " focks", "fo", " fios", " fops", "tfOS", "fileops", "infis"], "canalFuente": ["canalBuence", "canalBugent", "canalKugent", "canallBuente", "canallBuenza", "canalBuento", "canallFuente", "canalJuento", "canallFugent", "canulFience", "canalFiencer", "canalFUento", "canalJuence", "canalBuent", "canalFuento", "canalFUante", "canallBuence", "canalsFuent", "canalfuente", "canalFuencer", "canalsFuente", "canalBuente", "canalJuente", "canallFuenza", "canalBuante", "canalMuence", "canulFiente", "canalFuenza", "canalMuente", "canalsBuento", "canalBuenza", "canalfugent", "canalsBuent", "canalFiente", "canalKuence", "canulFient", "canalFuante", "canalfuenza", "canulFuente", "canulFiencer", "canalFUente", "canulFuent", "canulFuencer", "canalMuent", "canalsBuante", "canalJuante", "canallBugent", "canalFugent", "canalsFuante", "canalFient", "canalsFuento", "canulFuence", "canalFUent", "canallFuence", "canalfuence", "canalKuente", "canalMuencer", "canalFuence", "canalsBuente", "canalFience", "canalKuenza", "canalJuent", "canalJuencer", "canalFuent"], "canalDestino": ["canalDestania", "canallDestinos", "canaldestination", "canalNegania", "canallDestino", "canaldestina", "canelCampino", "canelCampania", "canelDestination", "canelDestino", "canalCampinos", "canalldestinos", "canallDestania", "canalldestania", "canallDestina", "canalCampination", "canalCampino", "canalNegino", "canalNegination", "canalldestino", "canalNegina", "canelCampination", "canelDestania", "canalCampina", "canelDestina", "canaldestinos", "canalDestinos", "canaldestania", "canalDestina", "canalCampania", "canalldestina", "canalDestination", "canaldestino", "canelCampina"]}}
{"id1": "23310397", "id2": "7143591", "code1": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        mButton1 = (Button) findViewById(R.id.myButton1);\n        mButton2 = (Button) findViewById(R.id.myButton2);\n        mTextView1 = (TextView) findViewById(R.id.myTextView1);\n        mButton1.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpPost httpRequest = new HttpPost(uriAPI);\n                List<NameValuePair> params = new ArrayList<NameValuePair>();\n                params.add(new BasicNameValuePair(\"str\", \"post string\"));\n                try {\n                    httpRequest.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n        mButton2.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpGet httpRequest = new HttpGet(uriAPI);\n                try {\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        strResult = eregi_replace(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"\", strResult);\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n", "code2": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "label": 0, "substitutes": {"onCreate": ["ONCreating", "onClick", "jobCre", "ONClick", " onCreated", "OnClick", " onClick", "ONCreate", "onCreating", "OnCreating", " onCreating", " onCre", "jobClick", "jobCreated", "ONCreated", "OnCreate", "jobCreate", "OnCreated", "onCreated", "onCre", "OnCre"], "savedInstanceState": ["savingInstStates", "savingInstanceInfo", "savedInstanceConfig", "savingInstInfo", "savedCaseStates", "savedinstanceInfo", "savedanceStates", "savedInstanceData", "savingInstData", "savingInstState", "savedanceInfo", "savedinstanceData", "savedinstanceStates", "savedinstanceConfig", "savingInstanceState", "savedCaseConfig", "savingInstanceConfig", "savedInstInfo", "savedanceState", "savedInstanceInfo", "savedInstData", "savedInstanceStates", "savedInstState", "savingInstanceStates", "savedinstanceState", "savingInstanceData", "savedCaseInfo", "savedInstConfig", "savedCaseState", "savedInstStates", "savedanceData", "savingInstConfig"], "mButton1": ["MButton1", "mActionOne", "mBorder01", "mChannel1", "mText1", "mAction2", "mText01", "MAction2", "MButtonFirst", "MAction1", "MActionOne", "mChannelOne", "mOption1", "mChannelFirst", "mOptionId", "mBorder1", "MActionId", "mAction1", "mBorderFirst", "mTextFirst", "mOption2", "mBorder2", "MChannelFirst", "mButtonFirst", "mText2", "mChannelId", "mButtonId", "mChannel01", "mButton01", "MButtonId", "MChannel2", "mButtonOne", "mChannel2", "MButtonOne", "MChannel1", "mActionId", "MButton01", "MChannel01", "mOptionOne", "MButton2"], "mButton2": ["mOptionTwo", "mText1", " mText1", " mText02", "mText02", "mAction2", "mLabel1", "mActionTwo", "mOption02", " mEditorTwo", "mOption1", "mEditorTwo", "mButton02", "mAction1", "mAction02", " mEditor1", " mButtonTwo", "mOption2", " mText2", " mTextTwo", "mLabel2", "mText2", "mTextTwo", "mEditor1", " mEditor2", "mEditor2", " mButton02", "mLabelTwo", "mButtonTwo"], "mTextView1": ["mTEXTview4", "mTextView0", "mTextVIEW5", "mTEXTview11", "mTextContainer11", "mTextVIEW1", "mTextVIEWp", "mTextContainer1", "mTextVIEW0", "mTextview4", "mTextDisplay1", "mContextView0", "mTEXTview8", "mTEXTViewOne", "mTextview11", "mTEXTview5", "mTextview0", "mTextContainer2", "mTextContainer8", "mTextStream2", "mTEXTView8", "mTextViewOne", "mTextviewp", "mContextView11", "mTEXTView1", "mTextDisplay5", "mTEXTView11", "mTextView2", "mTEXTview2", "mTextView4", "mContextview1", "mTextview1", "mContextview0", "mTextStream1", "mTextDisplay4", "mTextVIEW4", "mTextForm11", "mTextVIEWOne", "mTextDisplay2", "mTextForm8", "mTextStream11", "mTextStream0", "mContextview2", "mTextview2", "mTextField5", "mTextForm1", "mTextView5", "mTEXTview1", "mTEXTView5", "mContextView5", "mTextStreamp", "mContextViewp", "mTextview5", "mTEXTviewOne", "mTextView8", "mTextView11", "mContextView2", "mTextVIEW2", "mTextVIEW11", "mTEXTView4", "mTextForm2", "mContextview5", "mTextField1", "mContextView1", "mTextview8", "mTEXTView2", "mContextviewp", "mTextField2", "mTextviewOne", "mTextViewp", "mContextview11", "mTextDisplayOne"], "v": ["x", "f", "version", "g", "m", "V", "j", "p", "en", "vv", "model", "page", "video", "b", "w", "sv", "l", "val", "Ev", "e", "env", "i", "value", "t", "port", "h", "vs", "n", "view", "conv", "server", "c", "function", "Version", "Value", "ve"], "uriAPI": ["cliPython", "URISSL", "uiAPI", "uriCA", "uriPA", "riSSL", "uiapi", "uriAP", "urlAPI", "uriPython", "durationAPI", "cliapi", "uiPython", "urlPA", "uriapi", "durationAP", "URICA", "riAPI", "urlCA", "URIAP", "directoryapi", "idCA", "cliAPI", "idAPI", "URIapi", "directoryAPI", "idPA", "directorySSL", "URIPA", "riPython", "URIAPI", "durationPython", "riAP", "URIPython", "uriSSL", "riapi"], "httpRequest": ["HttpMessage", "httpsRequest", "ttpRequest", "htmlrequest", "HttpRequest", " httpClient", "httprequest", "buildRequest", " httpMessage", "htmlRequest", "buildrequest", "httpReturn", "httpsrequest", " httpReturn", "safeResponse", "externalrequest", "httpAsk", " httpAsk", "Httprequest", "externalResponse", "uriCause", "buildMessage", "htmlResponse", "ttpClient", "saferequest", "httpsReturn", "httpClient", "uriResponse", "httpCause", "safeRequest", "ttprequest", " httpCause", "httpMessage", "safeAsk", "uriRequest", "externalRequest", "HttpResponse", "ttpReturn", " httprequest", "externalAsk", "htmlCause", "httpsClient", "buildResponse", "urirequest"], "params": ["values", "data", "eps", "type", "options", "services", "array", "results", "body", "settings", "ams", "relations", "par", "param", "arms", "items", "parts", "Parameters", "apps", "query", "posts", "ras", "list", "pins", "i", "api", "request", "response", "url", "vs", "names", "config", "uri", "ps", "http", "details", "keys", "pos", "changes", "result", "properties", "rules", "resources", "json", "string", "ip"], "httpResponse": ["ttpServer", "Httpresponse", "ttpRequest", "HttpRequest", "externalResult", "htmlResult", "HttpReply", "ttpResult", "HTTPResponse", "HTTPRequest", "httpReply", "serverResult", " httpReply", "HttpServer", " httpResult", "externalResponse", "htmlresponse", "htmlResponse", "httpServer", "htmlResp", "ttpClient", "httpresponse", "HttpResult", "HttpClient", "httpResp", " httpresponse", "httpClient", "serverResponse", "serverRequest", "ttpReply", "externalRequest", "htmlReply", "HttpResp", "HttpResponse", " httpResp", "httpResult", "ttpResp", "htmlServer", "HTTPReply", "HTTPResp", "externalClient", "serverResp", "ttpResponse"], "strResult": ["stringResult", "strresult", "StrResults", "stringResponse", " strresult", " strResponse", " strResults", "strResults", "strResponse", "stringresult", "stringResults", "StrResult", "StrResponse", "Strresult"]}}
{"id1": "62362", "id2": "3745402", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 0, "substitutes": {"convert": ["conception", " deconvert", "Convert", "converting", "subvert", "unversion", " deconverting", "CONverting", "unvert", "CONvert", "unception", "Conversion", " deconverted", "unverted", "subverted", "Converted", "conversion", " deconversion", "CONverted", "subversion", "oconvert", "CONversion", "converted", "Conception", "Converting", "CONception", "subverting", "oconversion", "oconverted", "oconverting"], "src": ["reader", "username", "cb", "sin", "loc", "RC", "name", "sn", "gb", "s", "sc", "slice", "cpp", "stream", "st", "secure", "inst", "download", "sth", "load", "gz", "proc", "sys", "rc", "SourceFile", "ssl", "component", "ource", "prot", "req", "feat", "video", "img", "href", "fn", "dist", "back", "rb", "cmp", "source", "storage", "ctx", "path", "spec", "filename", "attr", "stage", "url", "config", "code", "uri", "sit", "file", "impl", "Dest", "upload", "sel", "scene", "sb", "input", "resource", "Source", "fp", "ref", "rl", "string", "obj", "buf", "tmp", "supp"], "dest": ["bin", " destination", "cont", " dst", "class", "orig", "di", "txt", "img", "fn", "dist", "temp", "std", "dc", "test", "lib", "source", "disk", "path", "null", "Dest", "target", "dir", "dat", "home", "obj", "tmp"], "in": ["reader", "bin", "inf", "isin", "login", "f", "data", "doc", "inas", "ins", "pin", "stream", "ex", "In", "is", "win", "r", "din", "val", "IN", "err", "ini", "d", "i", "source", "inc", "t", "n", "pass", "ps", "inn", "io", "as", "up", "file", "a", "input"], "p": ["f", "lp", "tp", "s", "g", "py", "m", "j", "pi", "wp", "pc", "per", "pr", "jp", "b", "part", "op", "l", "bp", "pre", "cop", "e", "r", "parser", "o", "pp", "d", "i", "sp", "t", "h", "v", "ps", "pe", "c", "P", "pm", "np", "pa", "po", "fp", "pd", "cp", "pg", "pb"], "ds": ["data", "dl", "dd", "services", "groups", "ys", "cs", "ls", "ld", "tools", "d", " props", "js", "ded", "xs", "uds", "ps", "ils", "ges", "tests", "pd", "ads", " sd", "df", "lp", "ups", "ins", "bs", "Ds", "os", "sys", "sts", "obs", "rs", "dds", "dm", "nas", "gd", "hs", "points", "ipes", "qs", "DS", "styles", "des", "ss", "ks", "dos", "cons", "ts", "vals", "eps", "els", "icks", "da", "ns", "parts", " ps", "dist", " DS", "posts", "dc", "scripts", "ths", "dates", "vs", "gs", "ays", "dat", "docs", "dt", "s", "sync", "utils", "ans", "di", "words", "models", "lines", "db", "dp", "ants", "amps", "plugins"], "format": ["tag", "data", "f", "layout", "sche", "scale", "name", "version", "at", "ant", "handler", "type", "table", "language", "filter", "letter", "feat", "class", "plugin", "model", "part", "magic", "fn", "parser", "atter", "style", "source", "template", "t", "api", "spec", "struct", "filename", "pattern", "path", "form", "url", "config", "unit", "Format", "file", "function", "act", "prefix", "fd", "frame", "record", "host", "fp", "string", "nat"], "hasPixelData": ["hasPicturedata", "hasPictureSize", "hasByteData", " hasPixeldata", "hasPixeldata", "showsPixelDATA", "hasPixelSize", "hasPixelStyle", "showsByteStyle", " hasPixelSize", "showsBytedata", "hasByteStyle", "showsPixeldata", "showsByteData", "hasPictureData", "hasByteSize", "showsByteDATA", "hasByteDATA", "showsPixelData", "haspixeldata", "hasBytedata", "hasPixelDATA", "haspixelSize", "haspixelData", "showsPixelStyle"], "inflate": ["insflATE", "invenATE", "inflode", "inffated", "inFlated", "InFlace", "Inflace", "invenate", "insflate", "inflated", "inadequating", "inFlace", "insflating", "infolating", "infolATE", "inadequATE", "invenode", "inadequode", "insflode", "inffation", "infloated", "insvenATE", "invenating", "inffate", "inFlate", "inadequate", "inflating", "InFlated", "infolode", "infface", "Inflated", "Inflate", "InFlation", "inflation", "Inflation", "infloace", "insvenating", "insvenode", "infolate", "InFlate", "inflATE", "inflace", "infloate", "insvenate", "infloation", "inFlation"], "pxlen": ["mxlen", "fxdata", "mxpos", "campos", "pclon", "axln", "ppl", "txlen", "fxLen", "pxdata", "pxsize", "pngcount", "xpsize", "pxpos", "txln", "xpcount", "ppLen", "txlin", "mxdata", "camdata", "camln", "mxln", "axlen", "pcln", "pnglength", "pglen", "pxden", "fxden", "txlon", "pgLen", "pxl", "pxlength", "pxlon", "axlon", "pclin", "camlen", "pgden", "pxln", "mxcount", "pngsize", "fxln", "pgl", "mxlength", "mxsize", "axlin", "pclen", "fxl", "pxcount", "fxpos", "pxLen", "fxlen", "xplen", "pnglen", "ppden", "pxlin", "xplength", "pplen"], "out": ["lock", "point", "error", "session", "state", "outs", "gen", "dump", "sys", "log", "copy", "page", "cache", "user", "again", "output", "conn", "line", "work", "query", "err", "OUT", "list", "lib", "cli", "step", "parent", "v", "store", "server", "group", "post", "io", "up", "co", "inter", "pad", "re", "Out", "obj"]}}
{"id1": "13012591", "id2": "5676111", "code1": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "code2": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getPasswordHash": ["getPasswordSum", "getpasswordSecret", "getStringSum", "getHashSum", "getStringhash", " getPasswordSecret", " getpasswordSecret", "getpasswordHash", "getPasswordSecret", " getPasswordhash", " getpasswordHash", " getPasswordSum", "getStringSecret", " getpasswordhash", "getpasswordhash", "getHashhash", "getpasswordSum", "getHashSecret", "getStringHash", "getPasswordhash", "getHashHash", " getpasswordSum"], "password": ["data", "name", "email", "wd", "database", "array", "p", "words", "cache", "user", "text", "Password", "content", "account", "key", "address", "secret", "crypt", "buffer", "padding", "source", " passwords", "sword", "phrase", "path", "PASS", "pattern", "attribute", "config", "number", "code", "pass", "word", "prefix", "message", "token", "input", "security", "auth", "string", "confirmed", "username"], "md": ["bm", "meta", "gm", "bd", "vd", "mag", "mg", "gb", "dd", "m", "ma", " MD", "mt", "arm", "dig", "ld", "alg", "mb", "mac", "hm", "cmd", "dm", "dr", "material", "sm", "d", "dc", "MD", "map", "gd", "db", "mo", "mod", "amd", "mp", "metadata", "mm", "pm", "dh", "mu", "amp", "sha", "cm", "mem", "mc", "ms", "pd", "mand", "ad", "hd", "nm", "od", "mage", "pkg"], "hash": ["data", "ha", "hed", "error", "batch", "handle", "array", "filter", "body", "hex", "bh", "match", "dig", "carry", "cache", "check", "kh", "mac", "mask", "query", "dot", "key", "address", "secret", "row", "count", "map", "image", "build", "block", "square", "h", "url", "sum", "number", "code", "ashes", "index", "search", "message", "sha", "header", "ash", "diff", "cover", "host", "length", "total", "Hash", "html", "sh"], "buf": ["bin", "cb", "f", "data", "ff", "book", "array", "buff", "cap", "Buffer", "aux", "bh", "bb", "b", "box", "br", "abs", "img", "bp", "bag", "va", "rb", "abi", "buffer", "db", "ctx", "cf", "h", "v", "Buff", "conv", "cv", "pb", "ab", "nb", "src", "af", "uf", "cas", "sb", "bf", " buffer", "pad", "ref", "home", "fp", "fb", "bc", "tmp", "pkg"], "i": ["x", "ji", "f", "data", "si", "it", "ti", "ri", "s", "m", "p", "j", "pi", "k", "field", "hi", "I", "bi", "u", "b", "di", "multi", "qi", "l", "r", "fi", "e", "o", "uli", "abi", "d", "ci", "t", "h", "xi", "v", "oi", "ui", "li", "uri", "ii", "io", "c", "id", "index", "chi", "mu", "vi", "eni", "ai", "gi", "phi", "length", "ip", "end"]}}
{"id1": "1769771", "id2": "421042", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["Copyfile", "copyChannel", "copyFiles", " copyfile", " copyChannel", "transferFile", "CopyChannel", "transferfile", " copyFiles", "transferChannel", "CopyFiles", "CopyFile", "transferFiles", "copyfile"], "in": ["reader", "bin", "lock", "login", "f", "data", "name", "ins", "pin", "m", "ex", "min", "In", "base", "inner", "again", "win", "l", "work", "query", "IN", "i", "source", "image", "inc", "url", "config", "io", "inn", "c", "file", "id", "index", "lin", "input", "diff"], "out": ["x", "extra", "ext", "name", "point", "p", "ex", "outs", "plain", "base", "conn", "b", "again", "output", "w", "user", "cache", "writer", "dot", "o", "off", "OUT", "external", "call", "image", "exec", "v", "default", "n", "server", "io", "c", "file", "up", "prefix", "resource", "target", "Out", "string", "write"], "inChannel": ["InClient", " inchannel", "INChannel", "binClient", "binStream", "INChan", "binchannel", "Inchannel", "outStream", "winStream", "InChan", "InStream", "insChannel", "inchannel", "winChannel", " inChan", "outchannel", "insChan", " inStream", "binChannel", "insStream", "outChan", "winchannel", "inClient", "INchannel", "inputChan", "insClient", "inputChannel", "inChan", "inputStream", "inputchannel", "inStream", "binChan", " inClient", "InChannel", "outClient", "INStream", "winChan"], "outChannel": ["nStream", " outStream", "outputCh", "inConnection", "outputController", "inCh", " outConnection", "outputStream", "outStream", "outputChan", "outManager", "inchannel", " outManager", "outchannel", "OutChan", "nChan", " outChan", "outChan", "inManager", " outCh", "outController", "outConnection", "Outchannel", "OutConnection", "inputChan", "outputchannel", "OutChannel", "inChan", "inputChannel", "outCh", "inputchannel", "inController", "nChannel", "nManager", "inStream", " outchannel", "outputChannel", "inputController"]}}
{"id1": "3745402", "id2": "11032546", "code1": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 0, "substitutes": {"createCipher": ["createScrypt", " createCrypt", " createScursor", "createIntegipher", "createcrypt", "createcipher", " createCursor", "createcSecret", "createIntegSecret", "createScipher", "createScursor", " createCSecret", "createIntegursor", " createScipher", " createScrypt", "createCursor", "createCSecret", " createScSecret", "createIntegrypt", "createScSecret", "createCrypt", "createcursor"], "passwd": ["Passphrase", " passpassword", "passpassword", "failword", "passwordword", " password", "failwd", "passwordpassword", "PassWD", "Password", "passphrase", "Passwd", "password", "passwordphrase", " passWD", "failWD", " passphrase", "passWD", "passwordwd", "failpassword", "Passpassword"], "mode": ["Mode", "name", "manager", "version", "depth", "type", "slice", "seed", "language", "method", "command", "phase", "range", "direction", "time", "domain", "mac", "mask", "cmd", "password", "address", "source", "driver", "phrase", "path", "mod", "role", "MODE", "level", "code", "server", "core", "mm", "delay", "module", "prefix", "message", "dir", "slave"], "keySpec": ["secretSet", "keySet", "signConfig", "KeySet", "secretFactory", "KeySpec", "KeyFactory", "keyConfig", "secretSpec", "signSpec", "secretCS", " keyspec", "keyspec", " keySet", "KeyConfig", "Keyspec", " keyCS", "signspec", "KeyCS", " keyConfig", "keyCS"], "keyFactory": ["KeyService", " keyService", "kService", "secretFactory", " keyFamily", "KeySpec", "KeyFactory", "kFamily", "secretSpec", "keyFamily", "kFactory", "keyService", "kSpec", "secretService", "KeyFamily"], "key": ["data", "name", "type", "seed", "sk", "p", "pair", "state", "k", "enc", "pub", "base", "ssl", "KEY", "cache", "text", "user", "mac", "password", "temp", "secret", "ke", "source", " secret", "phrase", "ki", "hash", "sum", "config", "sign", "code", "pass", "core", "pe", "keys", "c", "file", "cert", "id", "ce", "message", "Key"], "md": ["msg", "meta", "df", "bd", "vd", "f", "mag", "cd", "dd", "m", "ma", " MD", "mt", "dig", "mb", "mac", "cmd", "dm", "dr", "material", "dc", "d", "sm", "MD", "db", "amd", "mp", "metadata", "mm", "pm", "dh", "message", "sha", "cm", "mc", "mand", "ad", "hd"], "digest": ["mdest", "demested", "digeter", " digeter", "DigEST", "Digester", "Digend", "digested", "demeter", "digester", "demest", "digEST", "mdested", "mdEST", "mdester", "demester", " digend", "signester", " digEST", "Digested", "digend", "signested", "mdend", "signest", "signeter", " digested", " digester", "Digest"], "salt": ["isodium", "Salt", "ssalt", "psort", "isalt", "sesalt", "dsodium", "secretalt", "secretsecret", "Sodium", "ssALT", "secretALT", "sort", "dsALT", "ssipher", "sesodium", "dsort", "sSalt", "sesALT", "sssecret", "sodium", "psalt", "isALT", "secretipher", "Sipher", " sALT", "SSalt", "Ssecret", "sipher", "dsalt", "sesSalt", "SALT", "isSalt", "psALT", " sort", "ssecret", "sALT", "psodium", " sodium"], "i": ["x", "f", "y", "si", "it", "ti", "ri", "at", "s", "m", "p", "j", "info", "pi", "k", "ind", "ix", "hi", "I", "di", "u", "b", "bi", "qi", "l", "e", "o", "uli", "d", "ci", "init", "z", "t", "xi", "v", "oi", "ui", "n", "li", "uri", "ii", "c", "in", "id", "index", "mu", "ai", "gi", "ip"], "paramSpec": ["aramSel", "paramSpe", "parspec", "parConfig", "aramSpe", "ParamConfig", "paramsConfig", "ParamSpec", " parameterSpe", " parameterConfig", "paramspec", "parSpec", "ParamCS", "paramsSpec", "paramSel", "Paramspec", "parCS", " parameterSpec", " parameterSel", "paramConfig", " paramSpe", "aramConfig", " paramConfig", "aramSpec", "paramsspec", "paramsCS", "paramCS", " paramSel"], "cipher": [" cursor", "conuster", "custer", "Cairo", "encoder", "Coder", "conrypt", "encairo", "pairo", "encipher", "encrypt", "Crypt", "coder", " cairo", "Cursor", "crypt", "coipher", "cursor", " coder", "Cistor", "corypt", "Cipher", "couster", "pistor", "coursor", "prypt", "conipher", "encistor", "encuster", "cistor", "pipher", "cairo", "conursor", "encursor"]}}
{"id1": "3053403", "id2": "20939940", "code1": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "code2": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "label": 0, "substitutes": {"fc": ["full", "df", "cb", "f", "loc", "central", "ff", "fl", "nc", "fen", "dl", "fw", "sc", "raf", "ct", "irc", "FC", "enc", "fe", "ec", "pc", "xf", "rc", " FC", "cs", "lc", "pl", "ll", "fat", "conn", "roc", "wk", "win", "fn", "fi", "lf", "bc", "circ", "console", "dc", "fx", "cc", "feed", "inc", "cf", "uc", "il", "exec", "vc", "xc", "hub", "cl", "io", "c", "fa", "fact", "co", "fd", "af", "hl", "flo", "bf", "sf", "fp", "mc", "con", "fm", "exp", "ref", "ac", "col", "fb", "fs", "rx"], "buff": ["bm", "bd", "cast", "xb", "bl", "loop", "b", "callback", "FF", "buffer", "abb", "ctx", "bas", "null", "grab", "both", "np", "fo", "fb", "ob", "bu", "aff", "fw", "boot", "butt", "fab", "load", "fe", "bed", "ind", "bh", "feat", "ph", "front", "uff", "bug", "back", "rb", "build", "agg", "prof", "bf", "home", "obb", "pb", "bc", "font", "app", "f", "loc", "ff", "gb", "p", "info", "eb", "lab", "pl", "bb", "txt", "cell", "feed", "bet", "form", "Buff", "config", "gg", "utf", "bo", "sb", "ref", "cp", "buf", "cb", "comp", "gap", "comb", "box", "mb", "text", "tab", "img", "bag", "pp", "fx", "cf", "hand", "fam", "bg", "cod", "uf", "now"], "encoding": ["decoding", "ecoding", "encoded", "encasing", " encoder", "Encoding", " encording", "ecoder", "decasing", "enaging", " encasing", " encaging", "encoder", "enryption", "Encording", "ecryption", "encryption", "encording", "decoder", "encaging", "enoding", "Encasing", "decoded", " encryption", "ecoded", "enoder", "decording", "Encoded", "Encryption", "Encoder", "decryption", "Encaging"]}}
{"id1": "20024612", "id2": "21363911", "code1": "    private void parse() throws Exception {\n        BufferedReader br = null;\n        InputStream httpStream = null;\n        URL fileURL = new URL(url);\n        URLConnection urlConnection = fileURL.openConnection();\n        httpStream = urlConnection.getInputStream();\n        br = new BufferedReader(new InputStreamReader(httpStream, \"UTF-8\"));\n        String ligne;\n        String post;\n        String date;\n        String titre;\n        String resume;\n        String url2DL;\n        while ((ligne = br.readLine()) != null) {\n            if (ligne.indexOf(\"div class=\\\"post\\\" id=\\\"post\") != -1) {\n                post = null;\n                date = null;\n                titre = null;\n                try {\n                    post = ligne.substring(ligne.indexOf(\"post-\") + 5, ligne.indexOf(\"\\\"\", ligne.indexOf(\"post-\")));\n                    ligne = br.readLine();\n                    date = ligne.substring(ligne.indexOf(\"<div class=\\\"date\\\"><span>\") + 24);\n                    date = date.replaceAll(\"</span>\", \"\").replaceAll(\"</div>\", \"\").trim();\n                    log.info(\"Post   : \" + post + \" du \" + date);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    titre = ligne.substring(ligne.indexOf(\">\", ligne.indexOf(\"title\")) + 1, ligne.indexOf(\"</a>\"));\n                    titre = titre.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    url2DL = ligne.substring(ligne.indexOf(\"<a href=\\\"\") + 9, ligne.indexOf(\"/\\\"\")).trim();\n                    url2DL = url2DL.replace(\"mega-films.net\", \"mega-protect.com\") + \".php\";\n                    log.info(\"Titre  : \" + titre);\n                    log.info(\"To DL  : \" + url2DL);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    resume = ligne.substring(ligne.indexOf(\"<em>\") + 4, ligne.indexOf(\"</em>\"));\n                    resume = resume.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    log.info(\"Resume : \" + resume);\n                } catch (Exception e) {\n                    log.error(\"ERREUR : Le film n'a pas pu etre parse...\");\n                }\n                log.info(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\");\n            }\n        }\n    }\n", "code2": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "label": 0, "substitutes": {"parse": ["Parser", "get", "handle", "se", "load", "setup", "xml", "format", "check", "arse", " parsing", "parser", " serve", "pack", "build", "init", "process", "request", "url", "update", "read", "raw", " parser", "split", "file", "report", "print"], "br": ["be", "mr", "Br", "cb", "HR", "ur", "arr", "vr", "bt", "div", "jar", "ger", "str", "bh", "bl", "obl", "bb", "pr", "yr", "b", "bridge", "bolt", "blog", "img", "cr", "r", "pre", "err", "fr", "cro", "dr", "rb", "bar", "ner", "BR", "sp", "hr", "ch", "next", "url", "lr", "browser", "http", "bre", "ocr", "gr", "wr", "sr", "bro", "tr", "result", "res", "bf", "orb", "bel", "report", "ber", "ler", "bc", "buf"], "httpStream": ["httpsstream", "fileCh", "httpSync", "fileConnection", "httpSteam", "httpsStream", "httpsSteam", " httpSteam", "resourceReader", "resourceSteam", "urlInput", "urlSteam", " httpstream", "databaseSteam", "httpCh", "fileSync", "databaseStream", " httpReader", "httpstream", "databaseConnection", "ttpStream", "httpInput", "databaseInput", "httpsReader", "resourcestream", "urlStream", " httpConnection", "resourceStream", "fileStream", "ttpCh", "ttpConnection", " httpSync", " httpInput", "httpReader", " httpCh", "ttpSync", "httpConnection"], "fileURL": ["FileURL", "urlUrl", "baseLocation", " fileLocation", "baseUrl", "urlLocation", " fileUrl", "fileLocation", " fileLink", "baseSR", "baseURL", "FileUrl", " fileSR", "fileUrl", "fileSR", "urlURL", "fileLink", "FileLocation", "urlSR", "baseLink", "FileLink"], "urlConnection": ["urlconnection", "fileConnection", "urlBuffer", "resourceConnection", "resourceConn", "fileConn", "fileConnect", "fileconnection", "resourceconnection", "fileBuffer", "urlConnect", "httpConnect", "inputConnection", "httpconnection", "resourceConnect", "inputConn", "inputBuffer", "httpBuffer", "urlConn", "httpConn", "inputConnect", "httpConnection"], "ligne": ["tiner", " lidable", "oligne", "luble", "zlette", "slounge", "elinea", "kline", "ylounge", "ilonge", "olitte", " liner", "klille", "iline", "lille", "toyer", "sligne", "ylige", "tauga", "tonge", "iloodle", "elidable", "lorde", "lilette", "slagi", "olonge", " linois", "lidable", "loyer", "slinea", " lffe", "liigne", "olidable", "linea", "pligne", " linea", "zuble", "zigne", "sluble", "lignment", "tinea", "ilinea", "tivia", "elourse", "liignment", "ylorde", "loodle", "slonge", "tignment", " line", "ilauga", "ilffe", " litte", "tille", " lille", "slffe", "ilourse", "ilitte", "klauga", "olounge", "lige", " loyer", "olinea", "slitte", "yline", "ylivia", " lagi", " lourse", "ilagi", " lauga", "linois", "ylitte", "lionge", "ilige", "livia", "lffe", "ilgent", "line", "tinois", "slignment", "tgent", "elitte", "litte", "pline", "iloyer", "eliner", "yloyer", "liiner", "lounge", "sline", "torde", "slourse", "tuble", "lourse", " lounge", "sliner", "slauga", "lauga", "eligne", "plounge", "yligne", "lagi", " longe", "liivia", "iluble", "elffe", "kligne", " livia", "liuble", "elounge", "liorde", "llette", "oline", "sloodle", "lgent", "slidable", "tine", "elonge", "sloyer", "plonge", "longe", " luble", "ylinea", "ylourse", " lgent", "iligne", " lige", "olourse", "tigne", " loodle", " lorde", "zauga", "ylinois", "liner", " llette", "liauga"], "post": ["meta", "tag", "data", "name", "thread", "type", "head", "dd", "tax", "body", "p", "ip", "log", "class", "add", "user", "text", "time", "zip", "bug", "pre", "posts", "patch", "password", "address", "comment", "style", "topic", "build", "image", "project", "mod", "Post", "POST", "ticket", "object", "cod", "update", "pass", "pe", "the", "id", "title", "word", "valid", "message", "po", "record", "od", "draw", "string", "media", "pod", "month"], "date": ["pose", "save", "open", "mark", "tag", "doc", "data", "name", "reason", "complete", "type", "create", "body", "change", "button", "div", "event", "grade", "status", "match", "format", "page", "user", "Date", "time", "year", "zip", "bug", "pre", "patch", "key", "md", "dr", "d", "style", "image", "value", "dates", "stage", "url", "update", "sign", "number", "rate", "pe", "duration", "file", "id", "index", "module", "message", "debug", "resource", "dat", "trade", "mate", "gender", "day", "draw", "string", "month"], "titre": ["titren", "tigritic", "atitre", "ttitsro", "titrex", "atipren", "ttitritic", "ptitsres", "ptitrone", "tibr", "atitbre", "titaret", "ntitre", "tittere", "titret", "titare", "titsret", "ticre", "titere", "tizbre", "taitret", "tittingre", "tittingrex", "tractren", "tithrell", "ttitreen", "ttitsret", "atipbre", "ntitspen", "titspen", "tithritic", "tractrer", "titsbre", "tittrone", "titsre", "tigre", "ticere", "atipre", "tuitpen", "titreen", "tibre", "tittre", "tiprer", "taitril", "tractre", "titaril", "tuitbre", "ttitro", "taitre", "tractpen", "ntitrell", "tibrex", "ttigrex", "tittres", "ptitsere", "tigreen", "ttitsre", "tibrell", "taitro", "tuitre", "tizre", "ntitsre", "titsrone", "tithre", "ntitrex", "titres", "titro", "ntittingrell", "titbre", "ttitret", "tittingr", "tittingrell", "ticrone", "ticres", "atiprer", "tithreen", "titsreen", "titrone", "tipren", "ntitsritic", "ntitritic", "titpen", "ptitre", "tithrex", "titrer", "titsere", "tractritic", "titr", "atitren", "titril", "ptitere", "tractbre", "ptitsre", "ptitsrone", "ntittingre", "tizren", "ttitrex", "titaro", "tipbre", "titrell", "tipre", "titsres", "tizrer", "ttitril", "tuitritic", "ntittingrex", "titsro", "ttigritic", "titritic", "ttigreen", "ttigre", "ttitsril", "ntitr", "atitrer", "ptitres", "titsril", "titsrex", "ntittingr", "ntitpen", "tigrex", "titsritic", "ntitbre", "tithr", "ttitre", "ntitsbre"], "resume": ["revumption", "reserve", "revume", "revend", "reverve", "presume", " resend", "preserve", "presend", "presumption", "resend", " resumption", "resumption", " reserve"], "url2DL": ["url62LR", "urlToLM", "urlTwoLC", " url6LP", "urlToNL", "urlGETLP", "url2LP", "url2NL", "url2TL", "urlTwoUL", "urlTwoLL", "url2dl", "urlGETLL", " url2TL", "url6LP", "url62LL", "url62DL", "urlBDL", "urlGETdl", " url6DL", "file2DL", "urlGETDL", "url4UL", "urlBLL", " url2dl", "urlTwoLR", "url4DL", " url2SL", "url4LL", " url6dl", "url4NL", "urlTwoDL", "urlTwodl", "url4LM", "url2UL", "fileTwoLR", "fileTwoLL", "urlToTL", "url4TL", "url6dl", "url2LM", "urlBLC", "urlTwoLP", " url2LL", " url2NL", " url2LP", " url2LM", "url2LC", "url6DL", " url2UL", "urlToDL", "url6LL", "urlBLR", "file2LL", "url2LR", "urlTwoSL", "url62LC", "url4SL", "url2LL", "fileTwoLC", "url2SL", "file2LC", "fileTwoDL", "file2LR", " url6LL"]}}
{"id1": "21488518", "id2": "88047", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"createNew": ["openOpen", "newOpen", "resourceNew", "createResource", "resourceOpen", "resourceCopy", "createCopy", "newResource", "newNew", "newCopy", "openCopy", "resourceResource", "createOpen", "openResource", "openNew"], "name": ["full", "office", "connection", "x", "missing", "ext", "ame", "data", "current", "self", "type", "non", "one", "label", "class", "base", "ix", "model", "part", "time", "size", "content", "old", "alias", "member", "e", "key", "ename", "address", "client", "comment", "style", "common", "image", "value", "anc", "large", "path", "parent", "filename", "url", "ui", "names", "Name", "n", "number", "code", "no", "default", "file", "folder", "id", "title", "prefix", "word", "search", "on", "resource", "named", "directory", "none", "string", "NAME", "end", "username"], "in": ["reader", "bin", "connection", "login", "data", "slice", "ins", "In", "inner", "size", "win", "din", "work", "IN", "plus", "ini", "buffer", "i", "source", "image", "init", "inc", "exec", "read", "raw", "pass", "thin", "up", "file", "id", "len", "src", "resource", "input", "record", "con", "diff"], "length": ["offset", "sequence", "type", "body", "Length", "timeout", "load", "ength", "time", "size", "bytes", "content", "line", "password", "buffer", "count", "padding", "limit", "path", "filename", "url", "width", "level", "number", "duration", "id", "len"], "contentType": ["ContentLength", "resourceType", " contentPath", "resourceLength", "ContentPath", "ContentType", "resourcetype", " contentLength", "contenttype", "contentPath", "Contenttype", "resourcePath", " contenttype", "contentLength"], "dest": ["prop", "trip", "cdn", "sup", "opt", "later", "tif", " destination", "cont", "destroy", "gz", "comb", "orig", "desc", "output", "conf", "txt", "img", "done", "zip", "trans", "dist", "temp", "dc", "d", "source", "parent", "config", "store", "route", "thin", "flat", "wb", "folder", "transform", "src", "Dest", "upload", "result", "target", "dir", "home", "tx", "de", "tmp"], "out": ["lock", "bin", "connection", "ext", "f", "data", "socket", "channel", "pool", "sync", "ex", "outs", "gz", "log", "copy", "page", "conn", "cache", "again", "output", "img", "zip", "cmd", "line", "writer", "err", "password", "o", "client", "flush", "OUT", "temp", "this", "buffer", "source", "image", "path", "exec", "object", "parent", "url", "view", "server", "null", "io", "file", "up", "result", "resource", "exp", "Out", "obj"], "request": ["job", "open", "ext", "get", "complete", "type", "remote", "QUEST", "reference", "quest", "wheel", "xml", "base", "req", "user", "instance", "query", "respect", "rer", "client", "external", "buffer", "call", "child", "path", "response", "object", "project", "Request", "url", "config", "transfer", "friend", "store", "route", "pe", "rate", "upload", "resource", "input", "claim", "directory", "report", "forward", "re", "access", "use"]}}
{"id1": "23510383", "id2": "20924119", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"saveProject": [" saveproject", "deleteApplication", "saveproject", " saveModel", "deleteproject", "deleteModel", "saveModel", " saveApplication", "insertModel", "insertproject", "insertProject", "saveApplication", "insertApplication", "deleteProject"], "file": ["full", "lock", "connection", "data", "File", "handler", "complete", "table", "local", "base", "log", "model", "picture", "part", "files", "zip", "line", "work", "single", "plus", "found", "image", "db", "ile", "project", "path", "parent", "filename", "object", "document", "folder", "FILE", "resource", "out", "fp", "dir", "directory", "use"], "types": ["ids", "pages", "ts", "thumbnails", "blocks", "eps", "Types", "times", "cats", "packages", "versions", "groups", "services", "options", "settings", "relations", "forms", "words", "models", "parts", "files", "features", "stores", "tools", "its", "strings", "pes", "shows", "packs", "archives", "objects", "classes", "uploads", "products", "names", "lists", "Images", "styles", "tags", "ypes", "boxes", "ions", "photos", "fields", "ames", "keys", "ports", "links", "locks", "params", "jobs", "projects", "users", "opens", "tests", "properties", "reports", "resources", "plugins"], "images": ["thumbnails", "blocks", "versions", "services", "events", "ips", "files", "features", "scripts", "assets", "image", "rooms", "png", "uploads", "Images", "actions", "styles", "tags", "boxes", "photos", "modules", "videos", "views", "users", "reports", "plugins", "media"], "trajectories": ["transjections", "tracessions", "tracessory", "transcessions", "tracessories", "transcessors", "traveyories", "tracessors", "transcessory", "transjectors", "transcessories", "transjectory", "trajectory", "traventory", "trajectors", "traveyions", "traveyory", "trajections", "transjectories", "traventions", "traveyors", "traventors", "traventories"], "databasesIncluded": ["databasesincluded", "databasesINclusion", "databasesInsclusion", "daturesIncluded", "databasesInsclusive", "databasesINcluded", "daturesInscluded", "databasesinclusive", "databasesIncluding", "databytesInhibited", "databytesIncluding", "databytesInscluded", "daturesInsclusion", "databasesOutclusion", "databytesInscluding", "databasesInclusive", "databasesOutcluding", "databytesInshibited", "databasesInscluded", "databasesInclusion", "daturesInclusion", "daturesInshibited", "daturesInhibited", "databasesInshibited", "databasesInhibited", "databasesINcluding", "databytesInsclusion", "databytesInclusion", "databasesinhibited", "databasesOutclusive", "databytesIncluded", "databasesOuthibited", "daturesInclusive", "databasesinclusion", "databasesInscluding", "databasesOutcluded", "databasesINhibited", "daturesInsclusive"], "onlyLinks": ["withlinks", "withLink", "justLinks", "OnlyFiles", " onlylinks", "allLinks", "onlylinks", "onlyLink", "alllinks", "withLinks", " onlyFiles", "justLink", "allLink", "justFiles", "OnlyLinks", "OnlyLink", "onlyFiles", " onlyLink"], "index": ["x", "offset", "point", "slice", "head", "ind", "match", "position", "page", "part", "size", "num", "weight", "old", "key", "address", "ini", "found", "i", "Index", "xxx", "inc", "value", "pattern", "default", "width", "level", "number", "tail", "id", "search", "input", "initial", "length", "string", "end"], "name": ["full", "connection", "ext", "data", "base", "part", "size", "domain", "key", "vision", "temp", "image", "large", "path", "unique", "filename", "stage", "url", "default", "Name", "number", "names", "memory", "up", "title", "id", "message", "resource", "named", "home", "none", "string", "NAME"], "format": ["offset", "data", "current", "scale", "pretty", "layout", "at", "handler", "language", "letter", "status", "base", "position", "text", "term", "export", "parser", "temp", "external", "style", "init", "template", "value", "feed", "struct", "filename", "pattern", "form", "config", "unit", "date", "Format", "transform", "function", "prefix", "header", "string"], "count": ["force", "depth", "error", "counter", "base", "match", "page", "cache", "num", "weight", "content", "call", "found", "Count", "build", "list", "child", "limit", "process", "path", "parent", "age", "sum", "level", "code", "length"], "version": ["feature", "ver", "data", "manager", "channel", "master", "versions", "database", "python", "latest", "VERSION", "application", "download", "xml", "release", "description", "video", "output", "vert", "section", "content", "journal", "vision", "image", "project", "environment", "v", "default", "config", "update", "platform", "server", "Version", "draft", "header", "target", "cover", "dir", "directory", "string"], "writer": ["reader", "er", "director", "data", "manager", "later", "widget", "handler", "book", "worker", "creator", "writ", "xml", "letter", "page", "w", "writing", "output", "wrapper", "walker", "former", "engine", "export", "journal", "parser", "writers", "temp", "buffer", "player", "war", "builder", "driver", "document", "author", "wr", "wire", "wave", "word", "W", "written", "riter", "out", "Writer", "write", "editor"], "xmlDir": [" xmlArea", "externalFolder", "imageDirectory", "imageFile", "xmlArea", "jsonDirectory", " xmlFile", "externalFile", "xmlFolder", "databaseArea", "externalDirectory", "jsonPath", "xmlPath", " xmlDirectory", "jsonArea", " xmlPath", "databaseDir", "imageDir", "xmlFile", "databasePath", "jsonDir", "databaseDirectory", "imageFolder", " xmlFolder", "xmlDirectory", "externalDir"], "databases": ["Datables", "notrooms", "variabytes", "structases", "Databases", "notabases", "notations", "drogs", "datogs", "structabytes", "arrabytes", "datases", "diations", " datases", "variations", "drations", "datables", "variabases", "arrables", "arrabases", "drabases", "databytes", "Datrooms", "Databytes", "arrases", "diabases", "Datases", "datations", "diogs", "notases", "structabases", "diabytes", "Datations", "variogs", " datations", "drabytes", " datrooms", "structables", "datrooms"], "t": ["ts", "y", "q", "ant", "task", "m", "p", "j", "ty", "class", "w", "e", "att", "o", "test", "d", "i", "template", "h", "tm", "v", "te", "n", "T", "Type", "c", " T", "title", "token", "target", "none", "string"], "type": ["data", "y", "error", "TYPE", "database", "slice", "language", "to", "p", "info", "state", "field", "ty", "definition", "set", "class", "rule", "match", "base", "model", "part", "op", "single", "e", "collection", "key", "o", "test", "comment", "style", "block", "template", "value", "ype", "parent", "like", "role", "other", "attribute", "group", "null", "pe", "Type", "function", "id", "right", "action", "result", "target", "token", "link", "string", "option"], "currentName": ["currentKey", " currentStyle", "reportedKey", "CurrentType", "CurrentFile", "thisMember", "recentName", "currentFile", "CurrentNames", "CurrentAddress", "reportedAddress", " currentFile", "thisPath", "futurePath", "currentPath", "reportedType", "recentStyle", "currentTime", "CurrentName", "futureName", "thisTime", "reportedNames", "currentAddress", "CurrentPath", "currentNames", "thisName", "currentMember", "futureNames", "currentType", "thisAddress", "futureFile", " currentKey", " currentPath", " currentMember", "thisType", " currentType", " currentNames", " currentTime", "currentStyle", "reportedPath", "recentTime", "thisStyle", "CurrentKey", "reportedName", "recentMember"], "baseCopy": ["baseCop", "baseCreate", "asecopy", " basecopy", "BaseCop", "binarycopy", "basecopy", "baseShare", "Basecopy", "baseSource", "BaseCopy", "BaseShare", "basiccopy", " baseCreate", "binaryCopy", "BaseCreate", "basicCopy", "baseName", "aseName", "aseShare", "binaryCop", "BaseSource", " baseSource", " baseName", "BaseName", " baseCop", "basicCreate", "basicSource", " baseShare", "aseCopy"], "source": ["connection", "reader", "ources", "current", "manager", "channel", "slice", "reference", "from", "stream", "remote", "ie", "base", "ource", "component", "cache", "inner", "size", "text", "section", "SOURCE", "client", "dest", "service", "proxy", "storage", "image", "parent", "object", "config", "view", "server", "unit", "core", "rate", "scope", "clone", "src", "scene", "resource", "input", "target", "Source", "result", "slave", "use", "option", "site"], "destination": ["transribution", "combination", "Destment", "Destignment", "distinator", "constinator", "destinated", "combinator", " destment", "Destinations", " destinated", "transignment", "distination", "destment", "Destination", "destinations", "Destation", "transinator", "Destinator", "combinations", "transination", "Destinated", "distribution", "externalination", "externalinator", "distignment", "externalinated", "constation", "externalment", "destinator", "constinations", "destribution", "destation", "constination", "Destribution", "combation", " destinator", "destignment"], "clefs": ["clef", "CLEf", "cleFS", " cleflows", "clebs", "CLEbs", " clebs", "Cleflows", " clef", "Clef", "Clebs", "Clefs", "CLEflows", " cleFS", "CLEfs", "CleFS", "CLEFS", "cleflows"], "st": ["sl", "ts", "statement", "sn", "sc", "ct", "ist", "mt", "inst", "ast", "sth", "bt", "str", "set", "bl", "ste", "ld", "sts", "ust", "ST", "cr", "fr", "std", "sm", "sp", "stru", "tt", "struct", "St", "sta", "rd", "sa", "src", "sb", "ss", "ost", "nd", "est", "start", "rest"], "rs": [" rc", "RC", " RS", "RS", "R", " src", "Rs", " rm", " sq", " matches", "rc", " sr", "Res", " ans", " re", " repl", " hits", "rd", " params", " success", " ra", " changes", "res", " Result", " Rs", " obj"]}}
{"id1": "19335986", "id2": "7425022", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["uncatchedexc", "Caughtexc", "CatchedEvent", "uncachedException", "uncatchedEvent", "unchandledException", "uncaughtexc", "uncachedEvent", "uncachedexc", "CaughtException", "uncatchedException", "CaughtEvent", "uncaughtEvent", "CatchedException", "unchandledexc", "unchandledEvent", "Catchedexc"], "t": ["ts", "f", "tree", "it", "s", "type", " td", "g", "m", "p", "ty", "w", "r", "l", "d", "ing", "te", "n", "T", "let", "c", " T", "title", "ed", "tr", "out", "tx"], "e": ["be", "ep", "er", "f", "data", "ception", "oe", "error", "s", "el", "m", "p", "j", "se", "ge", "event", "en", "fe", "ae", "ec", "eb", "ie", "me", "r", "err", "E", "exc", "o", "d", "i", "ne", "example", "environment", "ev", "enter", "code", "pe", "c", "eu", "ce", "ele", "ed", "es", "diff", "Exception", "de", "esi", "ace", "ee", "element"], "display": ["app", "profile", "layout", "container", "play", "monitor", "body", "p", "fe", "screen", "hide", "me", "status", "summary", "position", "description", "page", "content", "Display", "design", "console", "this", "show", "d", "style", "image", "dis", "process", "object", "default", "config", "view", "platform", "scroll", "window", "host", "report", "panel", "de"], "shell": ["lock", "app", "machine", "container", "el", "m", "body", "xml", "launch", " Shell", "log", "hell", "echo", "copy", "status", "bash", "loop", "b", "math", "mail", "l", "tools", "console", "buffer", "gui", "sound", "cli", "image", "live", "child", "poll", "kernel", "process", "h", "exec", "environment", "system", "cl", "server", "ml", "clone", "tool", "sb", "host", "help", "sym", "Shell", "sh"], "message": ["msg", "data", "error", "email", "Message", "monitor", "m", "body", "application", "event", "xml", "log", "status", "summary", "copy", "model", "page", "description", "mail", "output", "mess", "content", "member", "translation", "address", "console", "buffer", "image", "value", " exception", "request", "response", "object", "update", "document", "essage", "view", "server", "management", "flash", "header", "queue", "result", "report", " messenger", "media", "meter"], "e1": ["exc1", "e3", "e8", " e2", "E1", "exc8", "E3", "e2", "exc3", "E2", "E8", "exc2", " e8", " e3"]}}
{"id1": "3683344", "id2": "15351863", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"genRandomGUID": [" genRandomUUID", " genRandomUIP", " genRandomUuid", " genRandomGID", " genRandomGUuid", " genRandGIP", " genRandGID", " genRandomGUIP", " genRandomIGIP", " genRandUID", " genRandomGIP", " genRandomIGID", " genRandUIP", " genRandomUID", " genRandUUID", " genRandomIGUID", " genRandGUID", " genRandGuid", " genRandomIGuid", " genRandomGuid", " genRandomGUUID", " genRandUuid"], "secure": ["active", "https", "force", "depth", "q", " Secure", "session", "allow", "remote", "seed", "encrypted", "exclusive", "timeout", "str", "smart", "fast", "sys", "ssl", "require", "zip", "forced", "deep", "password", "random", "client", "sensitive", "secret", "proxy", " insecure", "sec", "close", "config", "server", "protect", "ssh", "weak", "Secure", "debug", "safe", "host", "security", "stable"], "valueBeforeMD5": ["valueBeforeMR5", "valueBeforeMD85", "valueBeforeMS5", "valueBeforeMR85", "valueBeforeMC3", "valueAfterMD55", "valueBeforeMS2", "valueBeforeMP2", "valueBeforeMD3", "valueBeforeMT5", "valueBeforeSHA1", "valueBeforemd3", "valueBeforeMP5", "valueAfterMD05", "valueBeforeSHA3", "valueBeforeSHA2", "valueAfterMD1", "valueBeforeM5", "valueBeforeMC5", "valueAfterMC8", "valueAfterMS5", "valueAfterMS3", "valueBeforeMR8", "valueBeforeMP3", "valueBeforemd8", "valueAfterMS2", "valueBeforeM3", "valueBeforemd5", "valueBeforeMR3", "valueBeforeAMD3", "valueBeforeAMD5", "valueBeforemd85", "valueBeforeSHA5", "valueBeforeMP55", "valueBeforeMS3", "valueBeforeMT20", "valueBeforeM1", "valueAfterMC3", "valueBeforeMD55", "valueBeforeMD05", "valueBeforeMD8", "valueAfterMD85", "valueBeforeAMD05", "valueBeforeMT55", "valueBeforeMD2", "valueAfterMD3", "valueBeforeMC85", "valueAfterMD20", "valueBeforeM2", "valueBeforeMT3", "valueBeforeMD1", "valueAfterMS1", "valueBeforeMD20", "valueBeforeAMD20", "valueAfterMC85", "valueBeforeMT2", "valueAfterMC5", "valueAfterMD2", "valueAfterMD8", "valueBeforeMC8", "valueBeforeMS1", "valueBeforeMT05"], "valueAfterMD5": ["valueAfterMF3", "valueAfterMFTE", "valueBeforeMP2", "valueBeforeMD3", "valueBeforeMD512", "valueBeforeMDody", "valueBeforeMP3", "valueBeforeMP1", "valueAfterDF3", "valueAfterMC1", "valueAfterHTML05", "valueAfterAST3", "valueAfterAMD3", "valueBeforeMD1", "valueAfterASTody", "valueAfterM3", "valueBeforeMPTE", "valueAfterAST5", "valueBeforeMDql", "valueAfterMC2", "valueAfterMP3", "valueBeforeMP5", "valueBeforeMDTE", "valueBeforeMC5", "valueAfterAST512", "valueAfterDM5", "valueBeforeAST2", "valueAfterHTMLTE", "valueBeforeAST3", "valueBeforeVM3", "valueAfterMC3", "valueBeforeMD2", "valueAfterDF005", "valueAfterMF5", "valueAfterHTML5", "valueAfterMC5", "valueAfterMD2", "valueAfterMP005", "valueAfterDF5", "valueAfterMCql", "valueBeforeMC3", "valueBeforeVM005", "valueAfterMDody", "valueAfterMTql", "valueAfterMD05", "valueAfterHTML512", "valueAfterHTMLody", "valueAfterGM005", "valueAfterMD005", "valueBeforeMP05", "valueAfterMF05", "valueAfterHTML3", "valueAfterMP1", "valueAfterDMody", "valueAfterMD3", "valueAfterAST005", "valueAfterM1", "valueAfterMT5", "valueAfterMD512", "valueBeforeASTody", "valueBeforeVM5", "valueAfterVM3", "valueAfterAMD005", "valueBeforeAST5", "valueAfterGM2", "valueAfterMDql", "valueAfterMP5", "valueAfterMD1", "valueBeforeAST005", "valueAfterAST2", "valueAfterMT3", "valueAfterVM5", "valueAfterGM5", "valueBeforeAST512", "valueAfterDM3", "valueAfterMP05", "valueAfterAMD5", "valueBeforeMD05", "valueAfterVM005", "valueAfterM5", "valueBeforeMD005", "valueAfterM2", "valueAfterDM512", "valueAfterGM3", "valueBeforeMCql", "valueAfterMP2", "valueAfterMPTE", "valueAfterMDTE"], "md5": ["amd512", "cmd05", "amd2", "md05", "cmdkey", "md2", " md25", " mdkey", "md1", "mand5", "amd25", "mand3", "amd5", " md3", "cmd512", " md1", "md25", "cmd1", " md05", "md65", "MD5", " md65", "mand512", " md512", "MD512", " MD05", "md512", "mand2", "cmd65", " md53", "cmd53", " MD53", " md2", "MD2", " MD3", "mand65", "md53", " MD5", "cmd5", "cmd3", "mdkey", "mandkey", "md3", "mand1", "MD25", "cmd2"], "sbValueBeforeMD5": ["sbValueWithoutMF5", "sbValueBeforeMD3", "sbValueBeforeMC5", "sbValueInsideMD5", "sbValueBetweenMD2", "sbValueBeforeMP1", "sbValueAfterMP3", "sbValueBeforeMP525", "sbValuebeforeND85", "sbValueBeforeMT005", "sbValueBeforeMP3", "sbValueBeforemd05", "sbValueBeforeMD525", "sbValueBeforeND3", "sbValueBeforemd25", "sbValueBeforeAMD3", "sbValuebeforeMD2", "sbValueBehindND25", "sbValuebeforeND5", "sbValueBeforemd3", "sbValueBeforeMP512", "sbValueBeforeMG3", "sbValueWithoutMD25", "sbValueBeforeMF25", "sbValueBetweenmd3", "sbValueWithoutMF35", "sbValueBetweenMD305", "sbValueBeforeMD05", "sbValueBeforeMP25", "sbValueBeforeAMD5", "sbValueBeforeMM005", "sbValueBeforeMM55", "sbValueBeforeMS85", "sbValueBeforeMS512", "sbValueBeforeMD55", "sbValueWithoutMD35", "sbValueBetweenmd305", "sbValuebeforeMD85", "sbValueInsideAMD5", "sbValueBeforeMP05", "sbValueBeforeMS5", "sbValuebeforeND3", "sbValueAfterMD512", "sbValueAfterMP55", "sbValueBeforeAMD512", "sbValueWithoutMD5", "sbValueBeforemd305", "sbValueBeforeMR25", "sbValueBeforeMT55", "sbValueBetweenmd2", "sbValueAfterMP005", "sbValueBeforeMC25", "sbValueBeforeMD2", "sbValueBeforeAMD1", "sbValueBeforeMD35", "sbValueBehindMD3", "sbValueAfterMP1", "sbValueWithoutMD3", "sbValueInsideAMD25", "sbValueBeforeMP2", "sbValueBeforeMF3", "sbValueBeforeMP005", "sbValueBehindMD25", "sbValueAfterMD1", "sbValueBehindMD5", "sbValueInsideAMD05", "sbValueBeforeMD1", "sbValueBeforemd2", "sbValueBeforeND25", "sbValueBeforeMP55", "sbValueBeforeMF35", "sbValuebeforeMD5", "sbValueAfterMD005", "sbValueBeforeMT3", "sbValueBeforeMF5", "sbValueBeforeMR525", "sbValueInsideMD3", "sbValueBehindND525", "sbValueBeforeND5", "sbValueBeforeAMD25", "sbValueAfterMP512", "sbValueWithoutMF3", "sbValueInsideMD05", "sbValueBeforeND525", "sbValueBeforeMD305", "sbValueBeforeAMD305", "sbValuebeforeMD3", "sbValueInsideMD25", "sbValueBeforeMS2", "sbValueBeforeMT5", "sbValueAfterMP5", "sbValueBeforeMD512", "sbValueBehindMD525", "sbValueAfterMD55", "sbValueBeforeMD25", "sbValueBeforeAMD2", "sbValueBeforeMD85", "sbValueAfterMD3", "sbValueBeforeND2", "sbValueBeforeMG5", "sbValueBeforeND85", "sbValueBeforeMP85", "sbValueBetweenMD5", "sbValueBeforeMM3", "sbValueBeforeAMD05", "sbValueBeforeMP5", "sbValueBeforeMD005", "sbValueBeforeMC35", "sbValueInsideAMD3", "sbValueBeforeMS3", "sbValueBeforemd5", "sbValueBetweenMD3", "sbValueBeforeMG25", "sbValuebeforeND2", "sbValueBehindND3", "sbValueBeforeMC3", "sbValueAfterMD5", "sbValueBeforeMS1", "sbValueBehindND5", "sbValueBeforeMM5", "sbValueWithoutMF25", "sbValueBeforeMG35", "sbValueBeforeMR3", "sbValueBetweenmd5", "sbValueBeforeMR5", "sbValueBeforeMP305"], "time": ["etime", "name", "version", "depth", "times", "q", "error", "type", "seed", "cost", "mode", "timeout", "counter", "Time", "size", "clock", "year", "TIME", "work", "random", "tz", "temp", "race", "count", "money", "ime", "value", "port", "speed", "age", "date", "rate", "duration", "delay", "id", "timer", "hour", "host", "sleep", "length", "start", "month"], "rand": ["rh", "reg", "name", "version", "depth", "q", "risk", "error", "type", "range", "seed", "clean", "rank", "winner", "rc", "rule", "mid", "rage", "win", "year", "r", "root", "bug", "raid", "dist", "max", "random", "dr", "rr", "Rand", "count", "serial", "pattern", "order", "round", "core", "ng", "rate", "delay", "id", "ro", "right", "index", "rss", "nd", "pick", "length", "re", "alpha", "bit"], "array": ["feature", "app", "vector", "batch", "archive", "database", "arr", "range", "Array", "table", "error", "pair", "expression", "sample", "cache", "all", "multi", "instance", "section", "r", "bug", "collection", "angle", "address", "row", "list", "image", "value", "arrow", "air", "object", "our", "view", "number", "element", "function", "index", "a", "module", "record", "integer", "area", "string", "now", "ray"], "strTemp": ["drTemp", "arrTemp", "arrTem", "objtemp", "brTemp", "strVar", " strTest", "objFake", "crTem", "crTemp", "crtemp", "drtemp", "brtemp", "objTemp", "drVar", "drTem", "arrTest", "strFake", "stringTem", " strtemp", " strTemplate", "stringtemp", "crTemplate", "StrBase", " strTem", "strTest", "StrTemp", "stringTemp", " strVar", "stringFake", "drTemplate", "objTem", "brTest", "strTemplate", "strtemp", "strTem", "arrBase", "brTem", " strFake", "arrtemp", "brVar", "Strtemp", "strBase", " strBase"], "i": ["x", "ji", "f", "y", "start", "si", "ti", "ri", "slice", "p", "j", "info", "pi", "k", "field", "ie", "ix", "hi", "I", "di", "u", "b", "multi", "l", "e", "o", "key", "abi", "d", "ci", "z", "h", "xi", "v", "yi", "ui", "n", "li", "uri", "ii", "io", "c", "in", "id", "index", "mu", "eni", "ai", "gi", "phi", "ip", "end"]}}
{"id1": "7396682", "id2": "22801734", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"copy": ["save", "get", "drop", "archive", "rm", "create", "remote", "change", "sync", "opy", "download", "move", "load", "dump", "share", "clip", "cop", "paste", "cat", "source", "Copy", "path", "delete", "url", "update", "transfer", "split", "file", "clone", "link", "replace", "cp", " cp", "write"], "srcFS": [" srcFC", "srcFC", "sbfs", "sourcefs", "srcFP", "rcFP", "sourceFC", "sbFS", " srcFP", "rcFC", "sbFP", "sourceFB", "rcFs", "rubyfs", "sourceFs", "srcfs", "sbFs", " srcFB", "rubyFS", "rcTS", "sourceTS", "rubyFs", " srcTS", "srcTS", "srcFs", "srcFB", "rcfs", " srcFs", " srcfs", "rubyFB", "rcFS", "sourceFS"], "src": ["inf", "sl", "cb", "sin", "loc", "RC", "sup", "name", "sn", "gb", "sc", "slice", "st", "stream", "secure", "supp", "sync", "inst", "sth", "sys", "bh", "rc", "SourceFile", "ssl", "ource", "feat", "req", "share", "img", "href", "dist", "dest", "rb", "cmp", "source", "sub", "ctx", "project", "path", "spec", "filename", "sec", "attr", "url", "config", "view", "uri", "code", "sit", "core", "http", "file", "sr", "upload", "rss", "sel", "sb", "target", "resource", "Source", "fp", "host", "obj", "username", "rest"], "dst": ["lsts", "dsts", "ldest", "cdST", "pdsc", " dsts", "lST", "cdrc", "ddST", " ddest", "cddest", "dsc", "idrest", " drc", "dST", "iddest", "pdST", "ddst", "ddest", "drc", "cdst", "DST", "pdst", " dST", "idsts", "Dst", "ddrc", "ddsc", "Ddest", "Drc", "pdrc", "lst", " dsc", "Dsts", "idst", "drest", "Drest", " drest"], "deleteSource": ["destroyMode", "copyMode", "destroySource", "DeleteSources", " deleteType", "copySource", "delOrigin", " deleteTarget", "DeleteType", "DeleteTarget", "DeleteMode", "deleteTarget", "destroyOrigin", "delSource", "destroyTarget", "delTarget", "delMode", "deleteMode", "copyOrigin", "delSources", "deleteSources", " deleteOrigin", "deleteType", "copyTarget", "DeleteSource", "delType", "deleteOrigin", "DeleteOrigin", " deleteMode", " deleteSources"], "conf": ["prop", "const", "cb", "f", "Conf", "cn", "cd", "sc", "ca", "raf", "info", "param", " Conf", "cs", "lc", "cache", "conn", "cr", "bug", "cor", "fi", "client", "comment", "cmp", "cli", "cc", "ci", "ctx", "ch", "cf", "uc", "cfg", "context", "cl", "config", "conv", "c", "cm", "con", "def", "ref", "confirmed", "bc"], "contents": ["CONTences", "ContENTS", "Contences", "contentients", "stents", "contacts", " content", "contContents", "CONTains", "ContContents", "Contains", "CONTainers", "locents", "Contils", "stacts", "latils", "contENTS", "contences", "contentents", "content", "CONTients", " contENTS", "locainers", "contains", " contients", "CONTils", "Content", "locContents", "CONTContents", "stences", "CONTents", "latacts", "contils", "contentent", "Contacts", "CONTacts", "contients", "latents", "latent", "Containers", "containers", "Contents", "CONTENTS", "locains", "stENTS", "contentENTS", "CONTent"], "i": ["x", "ji", "f", "data", "y", "name", "si", "ti", "ri", "type", "slice", "iv", "m", "p", "j", "ori", "pi", "ip", "k", "ie", "ix", "hi", "I", "di", "u", "b", "multi", "inner", "qi", "fi", "e", "o", "key", "ini", "abi", "d", "count", "ci", "init", "h", "xi", "v", "oi", "ui", "li", "n", "uri", "ii", "io", "c", "id", "index", "iu", "mu", "ai", "gi", "phi", "diff", "uni", "start"], "in": ["connection", "bin", "sin", "f", "data", "login", "doc", "socket", "inas", "ins", "min", "In", "is", "kin", "conn", "b", "part", "rin", "win", "r", "din", "l", "IN", "ax", "ini", "source", "inc", "nin", "pass", "thin", "inn", "c", "file", "as", "id", "a", "input", "out", "con", "ac", "gin", "serv"]}}
{"id1": "7948308", "id2": "19251426", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandGID", "getRandomMUID", "getRandomGuid", "getRandomMUD", "getRandGUID", "getRandomMuid", "getRandGuid", "getRandUUD", "getRandomUUD", "getRandomUID", "getRandomCuid", "getRandUuid", "getRandomGUD", "getRandomGID", "getRandUUID", "getRandomCID", "getRandomCUD", "getRandomCUID", "getRandomMID", "getRandGUD", "getRandomUuid", "getRandUID", "getRandomUUID"], "secure": ["active", "https", "secondary", "force", "depth", "session", "allow", "remote", "seed", "exclusive", "timeout", "smart", "sys", "rc", "ssl", "require", "zip", "forced", "deep", "random", "client", "sensitive", "secret", "external", "proxy", " insecure", "service", "sec", "config", "server", "weak", "Secure", "ce", "script", "unsigned", "accessible", "debug", "safe", "host", "security", "use", "stable"], "md5": [" MDql", "md2", " md64", "MDle", " MD2", "mand4", "cmd64", "mand5", "mandle", "mand3", "mp4", " md3", " md4", "cmd512", "MDql", "mandss", " mdle", "MD4", "MD5", "mdss", " mdss", " md512", "MD11", "mand2", "md512", "md11", "cmd4", " mdql", " MD11", " md2", "MD2", "mp64", "md64", "mdle", "mp5", "MDss", "mdql", "md4", " MD5", "cmd5", " md11", "md3", "mp512", "MD3"], "sbValueBeforeMD5": ["sbValueFirstMT3", "sbValueBeforeMD3", "sbValueBeforeMC5", "sbValueFirstMD50", "sbValueBeforeMT05", "sbValueBeforeMP1", "sbValueBesidesSD20", "sbValueAfterMS65", "sbValueBeforeMP3", "sbValueBesidesMD65", "sbValueAfterAMD8", "sbValueAfterMS5", "sbValueBeforeAMD3", "sbValueBeforeMDFive", "sbValueAfterMC7", "sbValueAfterAMD5", "sbValueAfterAMD3", "sbValueBeforeMS50", "sbValueWithoutMC512", "sbValueBeforeMD05", "sbValueBeforeAMD5", "sbValueAfterAMD25", "sbValueBeforeSHA1", "sbValueBeforeMOD50", "sbValueBeforeM3", "sbValueBeforeMI5", "sbValueBeforeAST20", "sbValueBeforeAMD8", "sbValueBeforeMAC20", "sbValueBeforeMSFive", "sbValueBeforeMAC512", "sbValueBeforeMS20", "sbValueAfterMD20", "sbValueBeforeMS5", "sbValueWithoutMC3", "sbValueFirstMT50", "sbValueAfterMC512", "sbValueAfterMD7", "sbValueAfterMD512", "sbValueFirstMT05", "sbValueBeforeMOD05", "sbValueBeforeM512", "sbValueBeforeSHA5", "sbValueAfterMSFive", "sbValueBeforeMD7", "sbValueBeforeSD3", "sbValueWithoutMD5", "sbValueBeforeMI3", "sbValueBeforeMR25", "sbValueBeforeMI512", "sbValueAfterMD25", "sbValueBeforeMC1", "sbValueBeforeMOD3", "sbValueBesidesSD5", "sbValueBeforeMOD5", "sbValueAfterMC5", "sbValueWithoutMD3", "sbValueAfterMS20", "sbValueBeforeSHA3", "sbValueBesidesSD65", "sbValueBeforeAST5", "sbValueBeforeMT8", "sbValueWithoutMC1", "sbValueAfterMS1", "sbValueAfterMD1", "sbValueBeforeMD20", "sbValueBeforeSHAFive", "sbValueWithoutMC5", "sbValueBeforeMD1", "sbValueBeforeAST65", "sbValueBesidesSD3", "sbValueBeforeMS65", "sbValueBeforeMI20", "sbValueBeforeMT3", "sbValueFirstMD3", "sbValueBeforeM5", "sbValueFirstMT5", "sbValueBeforeMAC65", "sbValueBesidesMD3", "sbValueBeforeMAC5", "sbValueBeforeMI7", "sbValueBeforeAMD25", "sbValueBeforeAST3", "sbValueAfterMD8", "sbValueAfterMC3", "sbValueWithoutMD1", "sbValueFirstMD5", "sbValueBeforeMT5", "sbValueBeforeMT50", "sbValueBeforeMD512", "sbValueBeforeSD20", "sbValueBeforeM1", "sbValueBeforeMD25", "sbValueBeforeMR8", "sbValueAfterMD3", "sbValueBeforeSD65", "sbValueBeforeMD8", "sbValueBeforeMD65", "sbValueBeforeMS05", "sbValueFirstMD05", "sbValueAfterMD65", "sbValueBesidesMD20", "sbValueBeforeMP5", "sbValueAfterMDFive", "sbValueBeforeMC7", "sbValueBeforeMI65", "sbValueBeforeMD50", "sbValueBeforeMS3", "sbValueAfterMS3", "sbValueBeforeMT25", "sbValueBeforeMAC3", "sbValueBeforeMC3", "sbValueAfterMD5", "sbValueBeforeMS1", "sbValueBesidesMD5", "sbValueBeforeMPFive", "sbValueBeforeMC512", "sbValueWithoutMD512", "sbValueBeforeMR3", "sbValueBeforeMAC1", "sbValueBeforeSD5", "sbValueBeforeMR5"], "time": ["etime", "name", "version", "times", "type", "cost", "seed", "mode", "tim", "timeout", "event", "counter", "Time", "size", "clock", "year", "TIME", "work", "random", "tz", "race", "count", "money", "value", "ime", "speed", "date", "rate", "duration", "delay", "id", "timer", "hour", "host", "sleep", "length", "est", "start"], "rand": ["rh", "rol", "loc", "reg", "version", "depth", "q", "range", "seed", "clean", "rank", "min", "gen", "winner", "rc", "rule", "mid", "rage", "win", "year", "r", "root", "cr", "raid", "chance", "max", "random", "rr", "row", "Rand", "count", "live", "chain", "serial", "pattern", "order", "round", "ng", "rate", "delay", "id", "ro", "right", "index", "res", "pick", "alpha", "bit"], "valueBeforeMD5": ["valueAfterMP3", "valueBeforeMC3", "valueAfterMP5", "valueBeforeMP2", "valueBeforeMD3", "valueBeforeMC73", "valueBeforeMD73", "valueBeforemd3", "valueBeforeMP5", "valueBeforeMC5", "valueAfterMD1", "valueAfterMD73", "valueBeforeMP3", "valueAfterMC73", "valueBeforeAMD3", "valueBeforemd5", "valueBeforeAMD5", "valueBeforeMD0", "valueBeforeMP0", "valueAfterMC3", "valueBeforeMD2", "valueAfterMD3", "valueAfterMC1", "valueBeforeDER0", "valueAfterMD0", "valueBeforeMC1", "valueBeforeMD1", "valueBeforeDER5", "valueBeforeDER2", "valueBeforeAMD2", "valueBeforeDER3", "valueBeforemd73", "valueAfterMC5", "valueAfterMD2", "valueAfterMP2", "valueBeforeAMD0", "valueBeforemd1", "valueAfterMP0"], "array": ["feature", "app", "error", "data", "vector", "batch", "archive", "allow", "arr", "range", "Array", "audio", "database", "pair", "any", "binary", "expression", "sample", "instance", "section", "r", "bug", "collection", "shape", "angle", "address", "row", "list", "image", "value", "api", "arrow", "object", "v", "our", "number", "view", "function", "index", "a", "message", "result", "record", "integer", "area", "string", "element", "ray"], "sb": ["SB", "BB", " SB", "bm", "cb", "sl", "ob", "sg", "lp", "bj", "gb", "s", "bs", "sth", "bt", "eb", "lab", "bh", "xb", "bl", "binary", "kb", "bb", "rob", "mb", "erb", "bp", "ruby", "rb", "sq", "buffer", "abb", "db", "lb", "zb", "bg", "lr", "sa", "pb", "ab", "wb", "nb", "src", "bsp", "bf", "sf", "orb", "usb", "obb", "fb", "bc", "ib", "buf", "tmp"], "j": ["x", "ji", "ij", "f", "y", "jj", "bj", "q", "g", "p", "k", "im", "bi", "pr", "jp", "br", "num", "part", "section", "aj", "l", "ja", "e", "key", "o", "dy", "d", "i", "block", "z", "ch", "js", "J", "v", "li", "n", "ii", "uj", "jo", "c", "index", "oj", "jl", "dj", "adj", "length", "obj"], "b": ["x", "BB", "bin", "be", "job", "cb", "f", "y", "bit", "bs", "p", "k", "eb", "base", "bb", "bi", "B", "br", "mb", "l", "bug", "e", "rb", "d", "i", "bar", "db", "lb", "n", "ab", "c", "pb", "wb", "beta", "a", "bf", "orb", "length", "fb", "nb", "ib", "ob"], "valueAfterMD5": ["valueAfterMCql", "valueAfterMP3", "valueAfterMDql", "valueAfterMPql", "valueAfterMP5", "valueBeforeMPql", "valueBeforeMD3", "valueBeforeMP5", "valueBeforeMP3", "valueBeforeMD25", "valueAfterMC3", "valueBeforeMP25", "valueAfterMD3", "valueAfterMD25", "valueAfterMP25", "valueAfterMC25", "valueAfterMC5", "valueBeforeMDql"]}}
{"id1": "14783950", "id2": "10218878", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressedWithSax", "compressedWithZip", "compresswithJar", "compresswithSax", "compressedUsingJar", "compressInSax", "compressUsingZip", "compressUsingJar", "compressUsingSax", "compressedUsingSax", "compressWithSax", "compressInJar", "compressWithJar", "compressInZip", "compressedWithJar", "compressedUsingZip", "compresswithZip"], "fileList": ["inputCollection", "FileString", "modelStream", "ziplist", "zipList", "fileString", "filelist", "fileEx", "fileSet", "inputList", "modelCollection", "wordList", " fileString", "FileStream", "modelEx", "zipName", "fileCollection", "modelList", "zipSet", "wordStream", " fileChain", "stringChain", " fileSet", "stringlist", "wordName", "fileChain", "FileSet", "FileList", " filelist", " fileEx", "FileChain", "stringName", " fileCollection", "inputStream", "fileStream", "FileName", " fileStream", "stringList", "wordString", "Filelist", "inputEx"], "zipFileName": ["zipFullDir", "folderFilename", "archiveDirDir", "folderGlobalPath", "zipGlobalNames", "zipPackageName", "archiveDirPath", "zipFilename", "folderGlobalname", "zipFileNames", "zipFullName", "zipFullPath", "zipFilePath", "zipDirDir", "zipGlobalName", "zipDirPath", "zipDirNames", "archiveFileDir", "folderFilePath", "folderFileName", "zipFileDir", "archiveFilePath", "zipGlobalPath", "archiveDirName", "zipFullname", "zipPackageDir", "zipGlobalname", "folderFileNames", "zipDirname", "folderGlobalNames", "zipDirName", "zipFullNames", "zipPackagePath", "archiveFileName", "folderGlobalName"], "fos": ["infaos", "fosh", "afis", "flis", "Faos", "FoS", "afoS", "afos", "afaos", "infoS", "Fosh", " fosh", "foS", "Fis", "infos", "flosh", "Fos", "faos", "flos", "infis"], "zos": ["lol", "webkit", "fits", "ZA", "cos", "zy", "bes", "budget", "bos", "outs", "zz", "gz", "os", "lins", "kos", "zl", "loop", "zag", "css", "rez", "zip", "oses", "ZI", "bag", "onz", "zon", "iframe", "fi", "jas", "tz", "zers", "nz", "abi", "packs", "uz", "closure", "z", "spin", "zer", "zb", "zx", "bis", "zik", "zzy", "zen", "zi", "LOS", "osi", "ozo", "jobs", "seconds", "inos", "zar", "zes", "ros", "es", "zan", "chini", "phi", "zo", "obb", "ses", "dos"], "iter": ["er", "f", "loc", "keep", "ener", "it", "ator", "gener", "inse", "slice", "el", "upper", "sort", "set", "ie", "is", "iner", "liter", "inner", "walker", "former", "fer", "ite", "e", "err", "fr", "iz", "ter", "izer", "test", "list", "i", "ner", "parse", "inc", "oper", "outer", "chain", "order", "next", "enter", "iterator", "ir", "ser", "finder", "http", "itter", "file", "Iterator", "index", "cher", "Iter", "coll", "inter", "ip", "end"], "fileName": ["FilePath", "FileString", " fileType", "fileType", "fullPath", "simplePath", "FileFull", "fileString", "FileType", "fName", "localPath", "simpleName", "FileInfo", "fileOpen", " fileInfo", " fileOpen", "fileData", " fileString", "FileLine", "fileLine", " filePart", "currentName", "pageString", "filePart", " fileUrl", "Filename", "fullOpen", "FilePart", "filenameInfo", " filePath", "currentUrl", " fileFull", "pageType", "pagename", "filenamename", "filenameFull", "localPart", "FileUrl", " fileData", "fileUrl", "filePath", "fileInfo", "filename", "fPart", " fileLine", "simpleOpen", "currentname", "fullName", "fileFull", "fname", "FileData", "fLine", "FileName", "localname", "pageName", "localName", "filenameName", "currentData", " filename"], "ind": ["x", "loc", "pt", "pend", "j", "div", "ix", "ld", "mid", "vert", "val", "end", "fr", "bind", "pull", "Ind", "d", "i", "count", "ci", "cond", "z", "inc", "ded", "wind", "mind", "eff", "ord", "ii", "inn", "in", "id", "index", "pos", "len", "rib", "dir", "nd", "length", "ad", "start", "IND"], "shortName": [" shortname", "ShortName", "fullPath", "fullname", "longName", "ShortString", " shortString", "ShortPath", "shortPath", " shortPath", "longPath", "smallPart", " shortLine", "shortLine", "longPart", "Shortname", "fullLine", "smallPath", "smallName", "ShortPart", "shortPart", "fullName", "smallname", "longname", "shortString", "longLine", "fullString", "shortname"], "fis": ["fiss", " fris", "cfos", "afis", "fisa", "gisa", "pris", "cfris", " fisa", "cfiss", "gios", "pisa", "gis", "afiss", "afos", "pis", "Fis", "pios", "Fiss", "cfs", " fiss", "afris", " fs", "fios", "Fs", "fris", "Fos", " fios", "gris", "cfis", "fs"], "buf": ["bin", "cur", "cb", "bd", "seq", "data", "loc", "ff", "bu", "batch", "lim", "buff", "bh", "rc", "feat", "bl", "bb", "b", "vec", "box", "br", "bytes", "done", "bp", "bag", "la", "rb", "buffer", "uc", "lb", "ba", "v", "Buff", "cv", "pb", "grab", "wb", "fd", "uf", "queue", "bf", "fb", "bc", "tmp"], "bytesRead": ["wordsUse", "flowsLength", "wordsWrite", " bytesUse", "bytesLength", "bytesSkip", "secondsWrite", " bytesSkip", "bitsWrite", "flowsNeed", "secondsRead", "bytesWrite", "wordsRead", " bytesWrite", "bitsRead", "tesRead", "bitsUse", "bytesNeed", "wordsLength", " bytesNeed", "bitsLoad", "tesLoad", "tesWrite", "secondsNeed", "flowsRead", " bytesLoad", "bitsLength", " bytesLength", "secondsLength", "bytesUse", "bytesLoad", "tesSkip", "flowsWrite", "bitsSkip"]}}
{"id1": "17199913", "id2": "23161545", "code1": "    protected static InputStream loadResource(String resource) throws MissingResourceException {\n        Thread thread = Thread.currentThread();\n        ClassLoader cLoader = thread.getContextClassLoader();\n        URL url = cLoader.getResource(resource);\n        if (url == null) {\n            throw new MissingResourceException(\"Unable to find resource '\" + resource + \"'.\", resource, resource);\n        }\n        try {\n            InputStream is = url.openStream();\n            return is;\n        } catch (IOException e) {\n            throw new MissingResourceException(\"Unable to load resource '\" + resource + \"' (IOException).\", resource, resource);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"loadResource": [" loadUrl", "downloadURL", "loadUrl", " loadFile", "downloadResource", "findUrl", "downloadFile", "findResource", "downloadUrl", "findURL", " loadURL", "loadURL", "loadFile", "findFile"], "resource": ["feature", "data", "name", "channel", "archive", "type", "class", "single", "ruby", "Resource", "buffer", "service", "source", "path", "uri", "route", "module", "message", "resources", "re", "element", "error", "range", "stream", "rule", "content", "query", "client", "address", "parse", "relative", "project", "parent", "context", "attribute", "document", "date", "src", "record", "use", "texture", "reader", "region", "remote", "reference", "method", "OURCE", "expression", "ource", "model", "component", "loader", "r", "collection", "style", "image", "serial", "http", "sr", "res", "rest", "connection", "base", "library", "match", "resolution", "text", "href", "pointer", "request", "filename", "role", "view", "core", "file", "scope", "right", "string", "media"], "thread": ["reader", "connection", "job", "app", "util", "Thread", "pool", "method", "worker", "task", "stream", "boot", "layer", "stack", "runtime", "class", "component", "loop", "loader", "th", "this", "kernel", "run", "build", "ctx", "t", "or", " Thread", "path", "tt", "parent", "process", "object", "system", "context", "project", "config", "http", "func", "module", "tc", "host"], "cLoader": ["cLoad", "lCl", " cConfig", "cUrl", "CConfig", " cUrl", "lConfig", "CLoad", " cCl", "CCl", " cLoad", "lLoader", "CUrl", "cDir", "cConfig", "CLoader", "CDir", "lPath", "lLoad", "lUrl", " cDir", "lDir", " cPath", "CPath", "cPath", "cCl"], "url": ["job", "sl", "f", "loc", "ur", "gl", "el", "stream", "download", "jar", "xml", "rc", "ll", "base", "ssl", "ls", "html", "bb", "conn", "loader", "l", "e", "Url", "service", "URL", "source", "image", "feed", "api", "path", "object", "lr", "server", "uri", "browser", "io", "http", "file", "impl", "id", "src", "bel", "www", "coll", "host", "ref", "location", "rl", "rel", "string", "element", "ob", "il"], "is": ["ais", "Is", "iss", "it", "ri", "iv", "bs", "inst", "web", "ics", "os", "im", "IS", "abs", "css", "was", "ar", "its", "mis", "ws", "api", "js", "bis", "ists", "ui", "vs", "uri", "ir", "ps", "ii", "ris", "as", "ils", "us", "lis", "ios", "ms", "ip", "fs", "il", "isi"]}}
{"id1": "12454178", "id2": "3252116", "code1": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "label": 0, "substitutes": {"alterar": [" crya", " cryaran", " celebraran", " cultivar", " crear", " cultiva", " cryAr", " creAr", " celebrar", " cryar", " cultivAr", " crearan", " celebra", " cultivaran", " celebrAr", " crea"], "t": ["x", "nt", "ts", "f", "y", "tree", "it", "wt", "ti", "at", "tp", "ant", "ot", "s", "type", "pt", "det", "m", "st", "table", "to", "p", "ut", "bolt", "tw", "u", "unt", "tools", "trans", "l", "e", "tf", "o", "att", "xt", "this", "d", "i", "template", "tt", "tm", "v", "te", "n", "rt", "T", "et", "let", "c", "in", "the", "flat", "tool", "tc", "tr", "ta", "tower", "target", "qt", "you", "dt", " mt"], "stmt": ["stgr", "swmt", "formmt", "tpt", "Strm", "istau", "ustau", "Stgr", "stv", "putmt", " stmb", "Stau", " stmn", " stmm", "swmd", "strdb", " stct", "smr", "spt", "sdb", " stdb", "tmr", "tdb", "Stmt", "strm", " stnt", "putmd", "Stmm", "stmm", " stbm", "stmd", "ustmd", "smt", "stbm", " stpt", "putnt", "ustmt", "swbm", "Stmb", "istmn", "Stbm", "ctgr", "ctmb", " stmr", "istmt", " strm", " stmd", "stmr", " stgr", "stau", "stdb", "strau", "Stct", "formrm", "ustnt", " stv", "swau", "stmn", "ctct", "strmt", "formv", "tmt", "istdb", "putau", "Stv", "formmm", "stmb", "stpt", "Stmd", " stau", "stnt", "stct", "strmn", "ctmt"], "sql": ["job", "lock", "statement", "sl", "QL", "where", "q", "dl", "s", "database", "seed", "mt", "printf", "lambda", "setup", " SQL", "expression", "log", "base", "SQL", "ls", "pr", "conn", "cmd", "zip", "query", "shell", "sq", "db", "limit", "url", "sol", "details", "insert", "up", "params", "stat", "ql", "result", "plan", "string", "serv"], "id_disciplina": ["id_disciplini", "id_Disciplissa", "id_Disciplineissa", "id_discomplina", "id_disciinea", "id_distrequINA", "id_disciplineana", "id_disciplineino", "id_disrequina", "id_Disciplineina", "id_Disciplini", "id_disciplissa", "id_distciplINA", "id_disrequinea", "id_disciana", "id_distciplinea", "id_distciina", "id_distciini", "id_disciplINA", "id_disciplineini", "id_discomplana", "id_discomplini", "id_distciana", "id_distciplino", "id_disciini", "id_Disciplinea", "id_Disciplina", "id_disciplino", "id_distciplina", "id_distciplini", "id_Disciplineini", "id_discomplino", "id_disciplana", "id_distrequina", "id_distciino", "id_disrequini", "id_disciina", "id_disciplineina", "id_disciplineinea", "id_disrequINA", "id_disciplinea", "id_discomplissa", "id_disciino", "id_disciplineissa", "id_distciplana", "id_distrequini", "id_Disciplineinea", "id_disciINA", "id_disguini", "id_distrequinea", "id_discomplinea", "id_disciplineINA", "id_disguina", "id_disguinea", "id_disguissa"], "item": ["reader", "er", "data", "name", "it", "q", "at", "edit", "container", "type", "m", "p", "info", "event", "seller", "items", "page", "instance", "article", "r", "e", "o", "service", "i", "entry", "bar", "hop", "source", "or", "request", "parent", "object", "order", "v", "other", "url", "server", "unit", "pe", "Item", "id", "index", "action", "result", "queue", "area", "ip", "site"]}}
{"id1": "19113613", "id2": "15351863", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"copy": ["save", "get", "archive", "rm", "create", "put", "type", "change", "sync", "p", "download", "opy", "move", "load", "Cop", "share", "zip", "clip", "cop", "paste", "cat", "Copy", "process", "delete", "update", "transfer", "ssh", "split", "clone", "upload", "replace", "cp", " cp", "write"], "in": ["reader", "bin", "connection", "login", "f", "data", "sin", "name", "get", "ins", "pin", "cin", "min", "In", "base", "plugin", "inside", "kin", "part", "inner", "again", "win", "old", "din", "work", "IN", "client", "this", "ini", "i", "image", "init", "inc", "project", "url", "update", "config", "n", "thin", "inn", "c", "as", "id", "index", "a", "ic", "lin", "on", "input", "token", "diff"], "out": ["x", "connection", "bin", "app", "ext", "outside", "name", "point", "self", "version", "at", "remote", "p", "ex", "outs", "one", "base", "page", "conn", "b", "again", "output", "cache", "vert", "goal", "part", "user", "line", "work", "root", "err", "dot", "o", "off", "client", "OUT", "this", "external", "call", "block", "image", "init", "inc", "project", "path", "exec", "object", "parent", "outer", "v", "other", "no", "n", "group", "null", "io", "net", "c", "up", "resource", "input", "with", "Out", "obj", "option"], "source": ["feature", "missing", "iter", "sin", "alt", "family", "name", "force", "origin", "type", "reference", "from", "secure", "base", "direction", "ource", "position", "component", "class", "status", "format", "size", "SOURCE", "dest", "subject", "secret", "service", "proxy", "project", "parent", "url", "attribute", "view", "uri", "unit", "route", "pe", "scope", "ce", "id", "prefix", "src", "resource", "Source", "internal", "use", "username", "site"], "target": ["wrong", "alt", "current", "name", "point", "force", "origin", "master", "arget", "reference", "detail", "top", "direction", "base", "format", "component", "output", "goal", "alias", "root", "dest", "address", "service", "cat", "template", "value", "project", "path", "parent", "pattern", "next", "url", "tail", "config", "route", "null", "Target", "prefix", "src", "resource", "about", "host", "token", "home", "site"], "files": ["pages", "f", "images", "data", "sections", "blocks", "s", "ins", "groups", "results", "Files", "cells", "items", "ls", "models", "obs", "features", "flows", "apps", "tools", "lines", "assets", "objects", "filename", "iles", "classes", "names", "ions", "keys", "jobs", "ports", "links", "users", "plugins", "resources", "docs", "fs", "children"], "file": ["le", "f", "data", "current", "name", "it", "File", "el", "layer", " File", "load", "fe", "local", "letter", "base", "binary", "per", "future", "page", "part", "b", "entity", "l", "line", "single", "e", "lib", "entry", "live", "child", "ile", "feed", "path", "filename", "object", "parent", "url", "uri", "unit", "folder", "id", "function", "item", "FILE", "resource", "dir", "fp", "directory", "string"], "inCh": ["INChannel", "INChan", " inChannel", "outCH", "InChan", "inch", "InCh", " inChan", "INCh", "outch", " inch", "Inch", "outChan", "inChannel", "INCH", "InCH", "inChan", " inCH", "outChannel", "InChannel", "inCH"], "outCh": ["outputCh", "outputChan", "outCH", "OutCh", "inch", "OutChan", "outch", "outChan", " outChannel", "inChannel", "Outch", "OutChannel", "inChan", "outputch", " outch", "outputCH", "outChannel", "inCH", " outCH", "OutCH"]}}
{"id1": "17202158", "id2": "21438069", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    public ProjectDeploymentConfiguration createNewProjectDeploymentConfig(int projectID, String name, String description) throws AdaptationException {\n        ProjectDeploymentConfiguration config = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            config = getProjectDeploymentConfiguration(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProjectDeploymentConfig\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return config;\n    }\n", "label": 0, "substitutes": {"readZoneIDs": ["loadzoneID", "readCodeNames", "readzoneID", "readCodeID", "loadZoneID", "readZoneIDS", "readZoneNames", "loadZoneIDs", "readLocationIDS", "loadzoneIDS", "readLocationID", "readzoneIDs", "loadZoneIDS", "readCodeIDs", "loadzoneNames", "readLocationNames", "loadzoneIDs", "readCodeIDS", "readzoneIDS", "loadZoneNames", "readzoneNames", "readLocationIDs", "readZoneID"], "zoneFileName": ["zoneFilesUrl", "ZonefileName", "Zonefilename", "zoneDirName", "zoneFullPath", "zonefileUrl", "zoneFilePath", "zoneDirPath", "zoneClassName", "zonefilename", "zoneFilesPath", " zoneFileUrl", "zoneFilename", "ZoneFileName", " zoneFilePath", "zoneFilesname", "zoneClassname", "zoneLinePath", " zoneDirPath", "zoneFileUrl", " zoneDirName", "ZoneFileUrl", "zoneFullname", " zoneDirUrl", "ZonefileUrl", "zoneFullUrl", "ZonefilePath", "zonefilePath", "zoneLineName", "ZoneFilePath", "zonefileName", "zoneClassPath", "ZoneFilename", "zoneFullName", "zoneLineUrl", "zoneFilesName", "zoneClassUrl", "zoneDirUrl"], "zoneids": ["sizeints", "typeids", "Zoneids", "zipids", "poids", "zoneips", "Zoneid", "typeips", "typeints", " zoneid", " zonelines", "zipIDs", "ziplines", "Zonefiles", "zoneIDs", "zipid", "pofiles", " zoneints", "poid", "poIDs", "typeid", "zoneints", "sizeips", " zoneips", "ZoneIDs", "zonefiles", " zoneIDs", "sizeids", "polines", "sizeid", "zoneid", " zonefiles", "zonelines"], "url": ["reader", "job", "connection", "sl", "f", "data", "name", "channel", "ur", "stream", "base", "class", "ssl", "page", "b", "loader", "user", "l", "r", "client", "address", "this", "Url", "service", "URL", "source", "buffer", "feed", "api", "hub", "path", "server", "uri", "io", "http", "file", "ball", "resource", "bel", "location", "re", "string"], "lnr": ["rlr", "lenb", "lnw", "linr", "slb", "linp", "lenp", "rlb", "slrb", "nlw", "rlrb", "linrb", "sln", "nlb", "slr", "lenw", "lnb", "nlp", "lnn", "lnp", "linb", "lenr", "rln", "nlr", "linn", "lnrb", "linw"], "line": ["le", "sl", "data", "name", "char", "el", "ge", "str", "letter", "log", "rule", "base", "inline", "lc", "page", "part", "l", "cell", "lines", "key", "lf", "column", "row", "comment", "ne", "entry", "parse", "block", "Line", "response", "no", "cl", "number", "code", "nl", "unit", "jo", "c", "file", "id", "LINE", "word", "message", "sel", "lin", "header", "link", "col", "string", "look"]}}
{"id1": "1473212", "id2": "21608109", "code1": "    @Test\n    public void test_validate_geo_getEvents() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=geo.getevents&location=madrid&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "code2": "    public static boolean loadContentFromURL(String fromURL, String toFile) {\n        try {\n            URL url = new URL(\"http://bible-desktop.com/xml\" + fromURL);\n            File file = new File(toFile);\n            URLConnection ucon = url.openConnection();\n            InputStream is = ucon.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            ByteArrayBuffer baf = new ByteArrayBuffer(50);\n            int current = 0;\n            while ((current = bis.read()) != -1) {\n                baf.append((byte) current);\n            }\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baf.toByteArray());\n            fos.close();\n        } catch (IOException e) {\n            Log.e(TAG, e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"test_validate_geo_getEvents": ["test_validate_geo_GetEvent", "test_validate_geo_myEvents", "test_validate_geo_myEvent", "test_validate_geo_Getevents", "test_validate_geo_GetEvents", "test_validate_geo_getEvent", "test_validate_geo_getevents", "test_validate_geo_myevents"], "factory": ["infcf", " fantom", "ufuture", "confactory", "ufactory", "affactory", "affuture", "fcf", "future", "infactory", "affancy", "fault", "ifancy", " fcf", "confcf", " flesh", "infantom", "inflesh", "fantom", "flesh", "confantom", "affault", "fancy", "ufault", "ufancy", "ifault", "ifuture", "conflesh", "ifactory"], "schemaLocation": ["schemasLocation", "schmaDirectory", "schemaLoc", "defmaLocation", "schegelocation", "schegeLoc", "defmalocation", "schemlDirectory", "schemeDirectory", "schmaFile", "schmlFile", "schemaslocation", "schmlDirectory", "schealLocation", "schmaLocation", "defalLocation", "schegeLocation", "defalDirectory", "schemaFile", "defmaDirectory", "schemalocation", "schealLoc", "schemeLocation", "schemeFile", "schemasFile", "schemlFile", "schealDirectory", "schmlLocation", "schemllocation", "defalLoc", "schmalocation", "schemasDirectory", "defmaLoc", "schemaDirectory", "schmllocation", "schemelocation", "defallocation", "scheallocation", "schemasLoc", "schemlLocation", "schegeDirectory"], "schema": ["schformation", "herma", "Scheme", "herml", "chemar", "validmar", "Schemar", "Scheformation", "scheme", "cheme", "schml", "validme", "scheformation", "schemar", "Schemas", "scheml", "chemas", "validma", "herformation", "hermas", "schemas", "validmas", "chema", "schmas", "Scheml", "schma", "Schema"], "validator": ["validation", " validation", "valer", " invalidator", "Validor", "valger", "scheor", "scheer", " valider", "valator", " invalidation", "generma", "valor", " validma", "scheator", " invalidma", "Validger", "scheger", " invalider", "validger", "valider", "validma", "Valider", "generator", "generation", "generer", "validor", "Validator"], "url": ["connection", "sl", "name", "org", "channel", "email", "method", "stream", "web", "event", "ssl", "page", "b", "user", "l", "key", "address", "Url", "buffer", "URL", "image", "feed", "api", "large", "path", "uri", "server", "browser", "http", "file", "tool", "resource", "coll", "www", "host", "location"], "inputStream": [" inputstream", "inputSteam", "InputForm", "InputPath", "outputStream", "pullForm", "InputStream", "InputSource", " inputPath", "InputString", " inputForm", "inputSource", "outputPath", "outputString", "pullSource", "pullStream", "pullSteam", " inputString", "Inputstream", " inputSource", "inputPath", "InputSteam", "inputstream", "inputString", " inputSteam", "inputForm", "outputstream"], "source": ["reader", "connection", "sl", "iter", "data", "ources", " sources", "channel", "session", "s", "handler", "method", "stream", "class", "ource", "format", "instance", "SOURCE", "client", "service", "proxy", "response", "spec", "object", "context", "level", "document", "view", "uri", "file", "src", "scene", "resource", "input", "result", "Source", "out", "resources", "slave", "string"]}}
{"id1": "7468819", "id2": "11645260", "code1": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"run": ["open", "login", "get", "stop", "info", "download", "loop", "check", "work", "test", "call", "build", "process", "exec", "url", "close", "update", "exit", "server", "debug", "running", "resource", "execute", "Run", "start", "runner"], "con": ["x", "connection", "open", "cur", "ver", "login", "cn", "socket", "un", "pin", "ca", "ct", "sync", "non", "en", "pc", "rc", "per", "plain", "log", "conn", "cache", "conf", "can", "cr", "pre", "Con", "ran", "client", "sub", "ctx", "connect", "CON", "cf", "ocon", "exec", "url", "cl", "close", "conv", "Conn", "c", "http", "fa", "co", "cas", "on", "cm", "ctrl", "cover", "cons", "cp", "re", "fc", "bc", "rx", "act"], "encodedPassword": ["encapedPass", "encoderPassword", "encryptedPassword", "encryptedpassword", "encapedPassword", "encoderAccount", "enccodedpassword", "enccodedSecret", "decodedPassword", "encodedpassword", "enoderpassword", "encapedpassword", "enccodedPassword", "encoderSecret", "encodedSecret", "encryptedPass", "enodedpassword", "enoderPassword", "encryptedSecret", "decodedPass", "deccodedpassword", "enccodedPass", "encapedAccount", "deccodedPassword", "encodedAccount", "deccodedSecret", "encoderpassword", "decodedSecret", "encoderPass", "encryptedAccount", "enoderPass", "enoderAccount", "decodedpassword", "deccodedPass", "enodedAccount", "encodedPass", "enodedPass", "enodedPassword"], "encoder": ["decoding", "encoding", "encoded", "enoded", "Encode", "enoder", "Encoding", "encode", "decode", "Encoded", "enoding", "decoder", "Encoder", "decoded", "enode"], "is": ["ais", "Is", "iss", "isl", "get", "ri", "iri", "s", "ins", "stream", "has", "os", "im", "rc", "isa", "IS", "ls", "isc", "conn", "was", "can", "rs", "r", "ar", "its", "i", "ci", "isu", "il", "bis", "url", "ir", "ser", "rt", "ris", "inn", "as", "in", "act", "id", "iris", "src", "are", "rss", "sel", "es", "ai", "out", "us", "ios", "res", "re", "serv", "rx", "isi"], "rd": ["rh", "reader", "mr", "bd", "rn", "RD", "rm", "ds", "respond", "dd", "stream", "Rs", "rex", "rod", "ru", "ld", "rob", "cr", "rs", "r", "td", "ra", "fr", "dr", "rost", "rr", "rb", "d", "gd", "hr", "ws", "rw", "rg", "lr", "dra", "rt", "wr", "fd", "rss", "xd", "nd", "pd", "rl", "ud", "rx"], "line": ["reader", "data", "name", "error", "body", "str", "letter", "log", "inline", "lc", "page", "part", "text", "output", "content", "l", "r", "err", "lines", "cell", "key", "lf", "row", "buffer", "i", "entry", "comment", "source", "continue", "feed", "style", "Line", "object", "character", "url", "cl", "code", "unit", "pe", "LINE", "len", "message", "lin", "header", "link", "re", "string", "end", "strip"], "response": ["connection", "answer", "data", "tree", "version", "error", "respond", "audio", "array", "body", "application", "Response", "binary", "four", "model", "description", "page", "more", "output", "content", "success", "collection", "reply", "respons", "secret", "buffer", "image", "value", "feed", "request", "object", "second", "default", "esi", "server", "uri", "memory", "wave", "function", "message", "rss", "resource", "header", "cover", "report", "json", "string", "serv", "resp", "site"], "lastIteraction": ["last_it", "lastiterative", "lastinteraction", "lastInteraction", "lastiteraction", " lastitertime", "lastInterit", "lastintertime", "last_ative", "lastitertime", "lastIntertime", " lastiterit", "lastinterit", " last_it", "lastInterative", " lastiteraction", "lastiterit", "last_time", " last_action", "lastinterative", " last_ative", "last_action", " lastiterative", " last_time"], "result": ["lock", "answer", "error", "session", "array", "results", "info", "status", "page", "user", "Result", "success", "query", "account", "secret", "row", "entry", "source", "next", "pass", "server", "date", "message", "resource", "report", "json"], "e": ["x", "be", "er", "f", "ception", "oe", "error", "ze", "s", "type", "g", "m", "p", "j", "se", "ae", "fe", "ec", "eb", "me", "ie", "u", "b", "je", "ite", "l", "r", "E", "o", "exc", "err", "this", "ke", "d", "i", "ne", "t", "or", "h", "ev", "te", "n", "null", "pe", "c", "eu", "a", "es", "ea", "de", "esi", "ace", "ee", "element"]}}
{"id1": "160739", "id2": "10212189", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 0, "substitutes": {"createOutputStream": [" createOutputSteam", "createInputStream", " createInputSteam", "createOutputSteam", " createByteSteam", " createOutputFile", " createOutputReader", " createIOSteam", "createInputReader", " createByteFile", " createByteReader", " createIOStream", " createByteStream", "createInputSteam", " createInputFile", " createInputReader", " createIOReader", "createOutputReader", "createOutputFile", "createInputFile", " createIOFile", " createInputStream"], "inFile": ["inputFile", "outFiles", "insfile", "infile", "inputfile", "outfile", "outStream", "incFiles", "sourceFiles", "incfile", "inFiles", "insStream", "sourceStream", "incFile", "insFile", "sourcefile", "inputFiles", "inputStream", "sourceFile", "insFiles", "inStream", "incStream"], "outFile": ["inputFile", "workingDirectory", "workDir", " outStream", "targetFile", "outDir", "inputTime", "infile", "inputfile", "outfile", "outStream", "inDir", "workingFile", "targetStream", " outDirectory", "targetfile", "inputDir", " outfile", "workingfile", "outTime", "workfile", "targetDirectory", "inTime", "workFile", "workingStream", "outDirectory", "workTime"], "k_blockSize": ["k_lineInfo", "k_BlockCount", "k_blockLength", "k_BlockLength", "k_lockCount", "k_blockInfo", "k_BlockSize", "k_blockCode", "k_blocksLen", "k_blocksSize", "k_blocksCount", "k_lineCount", "k_byteCount", "k_BlockCode", "k_bitInfo", "k_lockLength", "k_byteLen", "k_lockLen", "k_blockCount", "k_blocksLength", "k_bitCount", "k_byteSize", "k_blockLen", "k_lockSize", "k_byteInfo", "k_lineSize", "k_byteCode", "k_byteLength", "k_lockCode", "k_bitSize"], "byteCount": [" byteSize", "ByteCount", "blockSize", "flushLength", "flushcount", " byteLen", "bytecount", "ByteLen", "byteSum", "blockLength", "characterCount", "flushSize", "ByteSize", "ByteSum", "byteLen", " byteSum", "blockSum", " byteLength", "characterLen", "characterLength", "ByteLength", " bytecount", "byteLength", "blockCount", "flushCount", "characterSize", "byteSize", "Bytecount"], "buf": ["border", "cb", "seq", "data", "loc", "background", "batch", "alloc", "buff", "cap", "Buffer", "bh", "rc", "feat", "base", "b", "vec", "bytes", "img", "cmd", "bag", "exc", "flush", "font", "la", "rb", "buffer", "ctx", "feed", "ucc", "Buff", "config", "cv", "brace", "len", "src", "fd", "uf", "cas", "queue", "bf", "append", "result", "fb", "tmp"], "ofp": ["Oftp", "OFt", "afc", "Ofl", "Ofp", "oftp", "fortp", "forp", "OFtp", "ofl", "fort", "ofnp", "oft", "afl", "Ofnp", "afnp", "OFp", "OFl", "OFc", "forc", "Ofc", "afp", "ofc", "OFnp", "Oft"], "zos": ["lol", "cos", "zy", "bes", "outs", "ls", "css", "rez", "tz", "nz", "uz", "ws", "zyk", "zn", "js", "cfg", "zx", "nox", "ozo", "modules", "bitcoin", "ros", "ZA", "ses", "webkit", "fits", "ogl", "enos", "liquid", "bs", "os", "lins", "kos", "zl", "zag", "zin", "obs", "zip", "oses", "ZI", "iffs", "abi", "packs", "z", "rons", "osi", "inos", "zar", "los", "zo", "obb", "zona", "budget", "bos", "ossus", "ops", "jas", "zers", "zh", "zb", "zik", "zen", "zi", "soon", "zig", "zes", "forge", "owicz", "oS", "hz", "robe", "gz", "utils", "zon", "iframe", "zer", "oda", "dylib", "core", "za"], "osw": ["ossd", "issw", "osd", "osfw", "oswd", "isnow", "ishell", "esww", "bx", "osshell", "esy", "esnow", " osww", "oshell", "iswd", "eshell", "ossow", "ossy", "ossfw", "bws", "bsx", "lsx", "osy", "ossww", "osssw", "bsws", "bsw", "esfw", "isy", "osx", "ossw", "isd", " osfw", "lsw", "ossnow", "esow", "osws", " osow", "lswo", "osswd", "isw", "bwo", "essw", "osow", "esw", "esd", "oswo", "osnow", "eswd", "lsws", "osww", "bswo"], "bw": ["bbwa", " bz", "lbsw", "bbaw", "bbwu", "abW", "abwd", " bwa", "bx", " bew", "fw", "bz", "fbwe", "ebwd", "bbws", "fsw", "lbw", "lw", "bws", "fwa", "ebwe", " baw", "ow", "lbx", "abwe", "bbz", " bws", "owu", "oaw", "Bw", "bew", "lbwa", "bwu", "bsw", "lx", "fr", "bbwh", "lbws", "baw", "ebw", "fx", "bwe", "bbew", "fwh", "abw", "lsw", "bwh", "lbr", "ebW", "Bwa", " bwu", "Bws", "fbW", "lbwh", "Bew", "owa", "bwd", "fbw", "fbwd", "bwa", "bbw", " bwh", "lbz", "bW", "lwa"], "zot": ["azor", "jit", "Zit", "ziot", " zor", "zerot", "jori", "azit", "Zita", "azot", "jot", "Zott", "zerott", "zerita", "zeros", "zita", "Zot", "zerori", "aziot", " zori", "Zor", "azita", "zott", "azott", "zerit", "zor", " ziot", "zori", "jos", "Ziot"], "ifp": ["ifb", " ifc", "Iff", "ifl", "ifi", "ipl", "IFp", " ifi", " ifb", "Ifi", "ipc", "ipp", "Ifc", " iff", "IFl", "ipb", " ifl", "IFc", "iff", "IFi", "Ifp", "ifc", "IFb", "IFf"], "zis": ["zenIS", "Ziss", "zipits", "jit", "Zis", "jisi", "xits", "zeits", "xisi", "zenais", "xis", "zeiss", "zisi", "ziss", "zeis", "zipis", "zip", "xIS", "xib", " zisi", "zipip", " zIS", "jits", "zenib", "zeip", "jis", " zits", "zIS", "zenis", " zais", "zib", "xais", " zib", "zits", "zipiss", "xit", "Zip", "Zits", "zais"], "isr": ["risr", "iscr", "rispr", "irpr", "ISr", "irr", "irrb", " iscr", "ISrs", "isrs", "IScr", "isrc", "issr", "ISpr", "ISrc", "ISrb", "isrb", "ISsr", "issrs", "isscr", "isssr", " issr", "risrc", "irrc", "ispr", "risrb", " isrs"], "br": ["mr", "Br", "ob", "HR", "ibr", "arr", "ctr", "body", "kr", "div", "str", "bh", " fr", "bl", "obl", " BR", "yr", "b", "img", " Br", "r", "bp", "rs", "err", "fr", "cro", "rb", "bar", "BR", "sp", "shr", "hr", "ch", "lr", "ibl", "browser", "ocr", "gr", "sr", "bsp", "rib", "bro", "tr", " dr", "ber", "obi", "bc"], "zit": ["zipith", "ji", "zipits", "jit", "zipit", "zIT", "zite", " zite", "zipitter", "zipita", " zi", "jip", " zic", "xic", "zeits", "zeIT", "jIT", " zith", "zith", "zita", "zip", "jic", "zipip", "zenitter", "jits", "jith", "zipite", "zeita", "zenith", "zitter", "xi", "jite", " zits", "zipIT", "zi", "xith", " zip", "jita", "zits", "zic", "zeit", "zeitter", "zenit", "xit", "zeith", "zenits"]}}
{"id1": "23296117", "id2": "12078471", "code1": "    public static void extractNativeLib(String sysName, String name, boolean load, boolean warning) throws IOException {\n        String fullname = System.mapLibraryName(name);\n        String path = \"native/\" + sysName + \"/\" + fullname;\n        URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n        if (url == null) {\n            if (!warning) {\n                logger.log(Level.WARNING, \"Cannot locate native library: {0}/{1}\", new String[] { sysName, fullname });\n            }\n            return;\n        }\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        File targetFile = new File(getExtractionDir(), fullname);\n        OutputStream out = null;\n        try {\n            if (targetFile.exists()) {\n                long targetLastModified = targetFile.lastModified();\n                long sourceLastModified = conn.getLastModified();\n                if (targetLastModified + 1000 > sourceLastModified) {\n                    logger.log(Level.FINE, \"Not copying library {0}. Latest already extracted.\", fullname);\n                    return;\n                }\n            }\n            out = new FileOutputStream(targetFile);\n            int len;\n            while ((len = in.read(buf)) > 0) {\n                out.write(buf, 0, len);\n            }\n            in.close();\n            in = null;\n            out.close();\n            out = null;\n            targetFile.setLastModified(conn.getLastModified());\n        } catch (FileNotFoundException ex) {\n            if (ex.getMessage().contains(\"used by another process\")) {\n                return;\n            }\n            throw ex;\n        } finally {\n            if (load) {\n                System.load(targetFile.getAbsolutePath());\n            }\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n        logger.log(Level.FINE, \"Copied {0} to {1}\", new Object[] { fullname, targetFile });\n    }\n", "code2": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "label": 0, "substitutes": {"extractNativeLib": ["extractnativeLib", "extractNativelib", "extractednativeLib", "extractLibraryLib", "extractRemoteLib", "extractedNativeLib", "extractLibraryLibrary", "extractnativelib", "extractednativelib", "extractnativeLibrary", "extractednativeLibrary", "extractRemoteLibrary", "extractedNativeLibrary", "extractedNativelib", "extractNativeLibrary", "extractLibrarylib", "extractRemotelib"], "sysName": [" sysPath", "libPath", "sysPath", "systemTitle", "systemPath", " sysDir", "libname", "sysTitle", "ysPath", "ysname", "sysFull", "SysFull", " sysname", "Sysname", "SysPath", "libName", "systemname", "systemFull", "libTitle", "SysName", "ysName", "sysname", "systemName", "sysDir", "systemDir", "SysDir", " sysFull", " sysTitle"], "name": ["connection", "data", "type", "na", "nam", "label", "base", "plugin", "part", "cache", "loader", "size", "root", "key", "source", "filename", "system", "no", "nice", "Name", "n", "number", "default", "file", "title", "word", "prefix", "id", "resource", "named", "nm", "string", "NAME", "username"], "load": ["lock", "save", "open", "loaded", "start", "get", "force", "play", "create", " reload", "sync", "ck", "download", "dump", "launch", "set", "rc", "add", "copy", "require", "check", "LOAD", "loader", "loading", "cache", "include", "callback", "l", "zip", "pull", "test", "call", "comment", "oad", "parse", "cli", "pack", "init", "loads", "close", "cl", "delete", "read", "null", "Load", "hack", "fail", "skip", "link", "leaf", "progress", "push", "write", "use", "wait", "remove"], "warning": ["Warning", "ew", "error", "alert", "ww", "fw", "auto", "WARN", "web", "only", "warn", "wild", "misc", "acl", "loader", "loading", "notice", "blocking", "success", "watch", "random", "lang", "external", "comment", " warnings", "war", "wa", "breaking", "ws", "aw", "weak", "message", "WARNING", "resource", "initial", "fp", "leaf", "generation", " warn"], "fullname": ["realpath", "fulbase", " fullnode", "fullbase", "realName", "fullNAME", "flatpath", "fullpath", " fullnamed", " fullbase", "fulName", "Fullname", "FullNAME", " fullName", "fullybase", "flatName", "fullyName", " fullkey", "fulkey", " fullNAME", "fullykey", "fullypath", "flatnamed", "fullnode", "Fullnode", "realnamed", "Fullpath", " fullnumber", "fulname", "realname", "fullName", "realNAME", " fullpath", "fulpath", "Fullnumber", "FullName", "fullynumber", "Fullnamed", "fullyname", "fullnumber", "fullnamed", "flatname", "fulnode", "fullkey"], "path": ["full", "data", "type", "method", "filter", "enc", "str", "base", "log", "part", "loader", "text", "cache", "work", "root", "key", "pointer", "image", "api", "parent", "object", "filename", "pattern", "context", "config", "uri", "code", "route", "file", "id", "PATH", "ath", "Path", "resource", "link", "ref", "location", "string"], "url": ["connection", "sl", "f", "loc", "org", "fl", "channel", "ur", "download", "log", "base", "ll", "ssl", "bb", "blog", "loader", "l", "fr", "address", "Url", "lib", "URL", "source", "image", "service", "api", "lr", "config", "uri", "server", "http", "file", "impl", "src", "resource", "www", "coll", "bel", "link", "location", "rl", "string", "serv", "ob", "il"], "conn": ["connection", "nt", "open", "lock", "cb", "loc", "cn", "reg", "org", "socket", "nc", "channel", "session", "ct", "sync", "dn", "enc", "ann", "rc", "log", "ssl", "conf", "l", "err", "client", "cmp", "cli", "init", "ctx", "connect", "ch", "api", "config", "n", "conv", "rt", "io", "net", "c", "Conn", "http", "coll", "con", "fp", "cp", "Connection", "serv", "ob", "resp", "act"], "in": ["reader", "bin", "connection", "lock", "login", "f", "data", "socket", "s", "ins", "pin", "sync", "cin", "min", "In", "ie", "ssl", "inside", "kin", "b", "inner", "again", "part", "cache", "win", "din", "r", "pre", "IN", "err", "client", "pull", "ini", "this", "i", "source", "init", "image", "inc", "child", "nin", "request", "exec", "like", "config", "n", "inn", "c", "file", "up", "id", "index", "a", "src", "ic", "on", "lin", "input", "con", "resource", "ac", "gin", "serv"], "targetFile": [" targetDirectory", "argetClass", "hostDir", "sourceDir", "resourceDir", "hostStream", " targetFolder", "TargetDir", "argetFiles", "targetDir", "sourceDirectory", " targetPath", " targetfile", "targetStream", "sourceFiles", "TargetDirectory", "targetfile", "resourcefile", "TargetStream", " targetLine", "argetfile", "TargetClass", "argetFile", "hostFile", "targetPath", " targetStream", "Targetfile", "sourcePath", "targetClass", "hostfile", "targetFiles", " targetDir", "sourcefile", " targetClass", "TargetPath", "argetPath", "TargetFile", "targetDirectory", "sourceLine", "targetLine", "resourceLine", "sourceFolder", "resourceFile", "TargetFiles", "sourceFile", "argetFolder", "resourceDirectory", " targetFiles", "targetFolder"], "out": ["connection", "bin", "lock", "app", "ext", "login", "doc", "socket", "at", "error", "sync", "ex", "one", "plain", "log", "page", "cache", "again", "output", "inner", "w", "part", "user", "cmd", "writer", "line", "err", "o", "client", "key", "OUT", "temp", "off", "call", "comment", "source", "block", "init", "image", "inc", "exec", "outer", "parent", "sum", "default", "n", "group", "null", "server", "io", "net", "post", "file", "up", "prefix", "co", "result", "resource", "on", "target", "token", "exp", "Out", "obj", "option", "buf"], "targetLastModified": ["targetFirstMODed", "targetFirstModed", "targetLastModed", "targetLastPedIFIED", "targetFirstMinified", "targetLastModocked", "targetFirstMODified", "targetFirstMinIFIED", "targetLastPedamed", "targetLastMODamed", "targetLastMODified", "targetLastMODIFIED", "targetFirstModamed", "targetLastMinIFIED", "targetLastModamed", "targetLastMified", "targetLastModIFIED", "targetFirstModIFIED", "targetLastSemocked", "targetLastMocked", "targetFirstMODification", "targetFirstMined", "targetLastMODocked", "targetLastSemified", "targetFirstModification", "targetLastMed", "targetFirstModocked", "targetLastMification", "targetLastSemification", "targetLastPeded", "targetLastMinified", "targetFirstModified", "targetLastMinamed", "targetLastPedified", "targetLastMODed", "targetFirstMinamed", "targetFirstMODocked", "targetLastModification", "targetLastSemed", "targetLastMined", "targetLastMODification"], "sourceLastModified": ["sourceFirstMODified", "sourceLastImated", "sourceLastmoded", "sourceLastmodIFIED", "sourceFirstMODated", "sourceFirstMODIFIED", "sourceLastMODed", "sourceLastModed", "sourceLastImed", "sourceLastMated", "sourceLastImified", "sourceFirstMODed", "sourceLastMODated", "sourceFirstModated", "sourceFirstMODification", "sourceFirstModIFIED", "sourceFirstModification", "sourceLastMODified", "sourceLastModated", "sourceLastMODIFIED", "sourceLastMed", "sourceLastModIFIED", "sourceLastMined", "sourceLastModification", "sourceLastImification", "sourceLastmodified", "sourceLastMinIFIED", "sourceLastMification", "sourceLastMified", "sourceFirstModed", "sourceLastMinified", "sourceFirstModified", "sourceLastMODification"], "len": ["nt", "bin", "le", "sl", "iter", "f", "data", "fl", "lim", "el", "body", "min", "en", "str", "lc", "part", "size", "num", "lon", "l", "line", "val", "err", "lf", "count", "z", "limit", "no", "cl", "n", "li", "net", "id", "pos", "lin", "fin", "Len", "length", "ln", "ler", "end"]}}
{"id1": "1954410", "id2": "18489832", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "label": 1, "substitutes": {"doExecute": ["doSendute", "doexecuteute", "submitexecuteApply", "doSendApply", "submitExecRun", "doSendutes", "submitexecuteutes", "doexecuteutes", "doexecuteRun", "doExecApply", "submitExecutes", "doSendRun", "submitexecuteRun", "doexecuteApply", "submitExecute", "doExecRun", "submitexecuteute", "submitExecApply", "doExecutes"], "mapping": [" mapper", "mapper", "amatching", "finding", "amapping", "minding", "aminding", "matching", "fapper", "fatching", " matching", " minding", "amapper", "fapping"], "form": ["app", "FORM", "command", "method", "field", "forms", "xml", "definition", "control", "component", "format", "page", "dom", "flow", "formation", "template", "feed", "submit", "builder", " forms", "object", "pattern", "Form", "url", "config", "post", "owner", "transform"], "request": ["reader", "Bytes", "current", "data", "name", "self", "_", "q", "session", "complete", "QUEST", "method", "create", "type", "worker", "s", "application", "ware", "xml", "Response", "add", "req", "model", "format", "user", "instance", "query", "client", "address", "pull", "this", "call", "requ", "Reply", "submit", "path", "object", "parent", "Request", "context", "url", "Accept", "view", "server", "uri", "route", "hello", "HTTP", "Upload", "message", "frame", "resource", "input", "queue", "result", "report", "re", "json", "use"], "response": ["Resp", "data", "handler", "application", "xml", "Response", "status", "req", "model", "page", "output", "client", "reply", "object", "v", "view", "server", " Response", "message", "resource", " responses", "result", "res", "report", "json", "resp"], "errors": [" managers", " replies", " flashes", " management", " commands", "mess", " failures", " this", " acc", " status", " translations", " session", " messages", " payload", " warnings", " error", " problems", " logger", " updates", " logs", " streams", " mess", " messaging", " changes", " responses", " Messages", " calls", " messenger", " events"], "isMultipart": ["isMultipPart", "isMultompPart", "isMultIPPart", "isMultompart", "isMultippedound", "isMultipparts", "isMultippedart", "isMultippedost", "isMultitage", "isMultipated", "isMultompound", "isMultiIPost", "isMultiage", "isMultitarts", "isMultiparts", "isMultipound", "isMultompost", "isMultIPart", "isMultitart", "isMultippated", "isMultiated", "isMultiipart", "isMultiart", "isMultippart", "isMultiIPound", "isMultiipost", "isMultIPound", "isMultiipound", "isMultipage", "isMultiipPart", "isMultippedPart", "isMultiIPPart", "isMultiarts", "isMultippage", "isMultipost", "isMultitated", "isMultIPost", "isMultiIPart"], "mailInstance": ["fileInst", " emailinstance", " mailUsage", "mailManager", " mailManager", " emailInst", " mailInst", " emailUsage", " mailinstance", "fileInstance", "emailInstance", "fileinstance", " emailInstance", "mailInst", "fileManager", "fileUsage", "mailUsage", "mailinstance", "emailManager", "emailinstance", "emailInst"], "fields": ["forces", "ids", "pages", "data", "rows", "maps", "s", "groups", "services", "acks", "events", "field", "forms", "utils", "gets", "cells", "words", "parts", "models", "files", "members", "features", "flows", "posts", "lines", "strings", "ments", "facts", "packs", "archives", "qs", "loads", "objects", "dates", "atts", "classes", "uploads", "comments", "lists", "tags", "checks", "boxes", "details", "keys", "params", "links", "locks", "views", "holders", "states", "users", "changes", "headers", "input", "properties", "rules", "types", "plugins"], "attachments": ["payresses", "achresses", " attachresses", "attlements", "Attachps", "attachparts", "Attachers", "attps", "attachlements", "attachment", " attachment", "Attachlements", "supplements", "attees", "extps", "attachps", "payment", "attment", "extments", "achments", "atters", "attments", "suppments", "achparts", "Attachments", "attachers", "achment", "Attachment", "attachions", "extions", "payparts", "exters", "Attachees", "suppees", "attachees", "attions", "suppment", "payments", "attachresses", "Attachions", " attachparts"], "items": ["ids", "pages", "apters", "data", "rows", "ins", "groups", "phones", "results", "events", "ips", "parts", "models", "files", "apps", "ops", "lines", "its", "alls", "orders", "list", "qs", "objects", "lists", "names", "keys", "links", "locks", "Items", "es", "reports", "types", "plugins", "ers", "children"], "iter": ["ul", "reader", "er", "ver", "loc", "keep", "it", "ator", "gener", "master", "edit", "slice", "el", "altern", "event", "upper", "loop", "page", "inner", "walker", "former", "ite", "zip", "err", "ter", "izer", "list", "i", "ner", "inc", "oper", "chain", "outer", "order", "enter", "iterator", "li", "ir", "ser", "finder", "http", "itter", "file", "Iterator", "cher", "Iter", "coll", "inter", "skip", "exp", "ip", "end"], "item": ["missing", "data", "current", "name", "issue", "container", "type", "art", "section", "val", "service", "hop", "source", "storage", "next", "other", "url", "update", "coll", "custom", "resource", "element", "volume", "it", "handler", "load", "album", "page", "inner", "entity", "anything", "or", "example", "order", "attribute", "li", "up", "folder", "result", "reader", "app", "widget", "complete", "info", "atom", "all", "temp", "image", "api", "Item", "area", "ip", "obj", "site", "full", "extra", "er", "get", "slice", "layer", "event", "base", "plugin", "more", "user", "instance", "i", "entry", "object", "server", "post", "original", "file", "index", "token"], "aux": ["abc", "extra", "ext", "union", "offs", "data", "sup", "ux", " Aux", "aff", "packages", "ups", "array", "ru", " auxiliary", "lc", "abs", "auc", "alias", "etc", "aus", "off", "lang", "strings", "ox", "ras", "frac", "fax", "sub", "cmp", "anc", "uc", "asc", "aw", "axe", "ants", "prefix", "des", "af", "aos", "amp", "cas", "uf", "except", "ou", "au", "imp", "buf", "pkg"], "part": ["full", "connection", "f", "data", "start", "point", "name", "error", "type", "change", "comp", "layer", "p", "pair", "partial", "info", "field", "pi", "one", "art", "per", "base", "class", "component", "format", "plugin", "parts", "b", "user", "Part", "instance", "section", "l", "pre", "and", "val", "patch", "key", "back", "PART", " Part", "list", "step", "player", "block", "but", "ch", "parent", "object", "no", "group", "file", "fact", "pos", "word", "id", "co", "action", "po", "on", "add", "diff", "join", "joined", "ref", "area", "html", "obj", "element", "act"], "baos": ["boo", "BAis", " bao", "abaOs", "BAosh", "abais", "paot", "hao", " bais", "pao", "boOS", "haoss", " baoS", "bois", "boot", " baOS", "BAoss", "baosi", "abaos", "baosh", "hais", "bao", "Baosi", "BAos", "haos", "paos", " baoss", "bais", "boosh", "pais", "baot", "baOs", "Bais", "paosh", "BaOs", "baoss", "BaoS", "paOS", "Bao", "BAOs", " baot", "baoS", "boos", "baOS", "BAoS", "Baos", "BAosi", "BAo", "abaosi"], "body": ["full", "connection", "data", "tree", "name", "type", "options", "state", "binary", "summary", "description", "parts", "text", "output", "size", "b", "content", "html", "zip", "shell", "query", "translation", "reply", "comment", "source", "common", "template", "port", "value", "object", "url", "document", "pass", "null", "Body", "params", "message", "flash", "header", "headers", "resource", "length", "fee", "json", "string", "media", "end"], "preferencesInstance": ["prefiesinstance", "prefiesClient", "prefeesClient", "prefferencesInstance", "preffeesInstance", "prefirmsClient", "preferencesinstance", "prefferencesinstance", "preferencesClient", "prefferencesClient", "prefirmsInstance", "prefeesInstance", "prefiesInstance", "prefirmsinstance", "prefeesinstance", "preffeesClient", "preffeesinstance"]}}
{"id1": "19251426", "id2": "5414088", "code1": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"recurseFiles": [" recursiveFiles", "recorderFiles", "recerveFiles", "recursivefiles", "reiveFiles", "recursiveImages", "recursiveChildren", "recorderImages", "reivefiles", " recurseChildren", "recerveItems", " recurseItems", "recursefiles", " recursiveChildren", "reurseFile", "reiveFile", "reciveFile", "recieveChildren", "recursiveFiles", "recorderfiles", " recurseFile", "reurseImages", "recivefiles", "reursefiles", "recorderFile", "recursiveFile", "recursiveItems", "recerveFile", "recieveFile", "recerveChildren", "reciveImages", "recurseChildren", "reurseFiles", "recieveFiles", "reciveFiles", " recursiveItems", "recurseImages", "reiveImages", "recieveItems", "recurseFile", " recursiveFile", "recurseItems"], "root": ["reader", "bin", "f", "loc", "tree", "name", "ver", "archive", "remote", "array", "xml", "base", "rule", "Root", "roots", "loader", "output", "b", "box", "user", "zip", "r", "writer", "rew", "back", "this", "source", "or", "project", "path", "parent", "object", "url", "ree", "default", "server", "uri", "folder", "ro", "prefix", "module", "resource", "result", "dir", "out", "cover", "home", "directory", "oot", "string", "node"], "file": ["full", "binary", "f", "data", "tree", "name", "get", "File", "force", "handler", "type", "table", "auto", "info", "xml", "local", "letter", "base", "log", "class", "model", "future", "page", "cache", "b", "time", "content", "zip", "work", "single", "e", "collection", "line", "comment", "style", "source", "entry", "image", "db", "child", "ile", "or", "project", "path", "parent", "object", "url", "document", "code", "server", "uri", "number", "pe", "http", "folder", "function", "module", "FILE", "resource", "dir", "fp", "queue", "directory", "leaf", "use"], "zaos": ["zaas", "naos", "gaos", "zeos", "gaes", "ziot", "zeoss", "zaose", "qaOS", "zios", "yaoS", "zeoS", "zioss", "zeo", "qaoS", "ziis", "waoS", "zaot", "zeis", "zaoS", "gaOS", "waos", "naas", "yaos", "zoos", "zis", "zoose", "zeose", "gao", "qaos", "naoss", "naose", "qais", "wais", "zooss", "yaes", "yao", "qaoss", "zeas", "ziOS", "zoas", "zaOS", "zes", "zaoss", "waOS", "zaes", "zioS", "zo", "gaot", "zos", "zao", "zoS", "qaot", "wao", "zais", "waoss", "gaoS"], "absolute": ["active", "full", "required", "multiple", "aggressive", "reverse", "offset", "fixed", "al", "complete", "ical", "simple", "auto", "physical", "encrypted", "exclusive", "supported", "able", "positive", "optional", "base", "inline", "abs", "atomic", "alias", "based", "olute", "external", "enable", "relative", "mobile", "Abs", "attribute", "ative", "automatic", "document", "uri", "empty", "negative", "http", "valid", "append", "international", "total", "compatible", "always", "alpha", "use", "apply"], "files": ["pages", "f", "images", "blocks", "rows", "s", "groups", "ples", "results", "balls", "events", "ips", "log", "Files", "ls", "items", "cells", "models", "features", "apps", "lines", "alls", "pes", "qs", "iles", "objects", "books", "classes", "names", "keys", "sites", "split", "links", "users", "projects", "es", "plugins", "docs", "fs"], "file2": ["files2", "file02", "letter1", " filetwo", "filename1", "letterSub", "letter2", "filename2", "filenametwo", "object2", " file02", "files1", "file1", "object1", "fileSub", "files02", "filename02", "filetwo", "filestwo", " fileSub", "objectSub", " file1"], "filename": ["ema", "connection", "ame", "sl", "f", "loc", "family", "name", "archive", "email", "database", "slice", "language", "kn", "download", "fil", "letter", "binary", "nil", "SourceFile", "summary", "description", "Filename", "kl", "size", "txt", "zip", "l", "shell", "whatever", "ppa", "password", "ename", "subject", "which", "path", "il", "phrase", "url", "uri", "metadata", "folder", "wb", "title", "word", "module", "message", "sheet", "utf", "token", "append", "fp", "length", "directory", "location", "json", "string", "username"], "zae": ["zecoe", "zeade", " zanne", " zace", "zcoe", " zoe", "zobe", " zobe", "zeae", "foe", "zoda", " zcoe", "zape", "zaoda", "ezade", "ezcoe", "zipae", "zade", "zeace", "Zade", "Zoe", "zace", "zipobe", "zipape", "zaobe", "fade", "zanne", "fanne", "Zae", "zaape", "ezace", " zoda", " zape", " zade", "zaae", "zoe", "fae", "Zanne", "ezae", "zipoda"], "fis": ["sfisc", " fris", "fwas", "fisa", " fisa", "cais", "lais", " fais", "lisa", " fwas", "zis", "lris", "zisc", " fisc", "sfais", "cis", "sfwas", "zwas", "cisa", "fris", "fais", "lis", "fisc", "sfis", "cris", "zais"]}}
{"id1": "11477906", "id2": "9236363", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadApplicationSettings", "loaddefaultParameters", "loadGlobalSettings", "loadApplicationParameters", "loadGlobalConfiguration", "getdefaultsettings", "getDefaultSettings", "getdefaultSettings", "loadDefaultParameters", "getDefaultParameters", "loaddefaultsettings", "getDefaultsettings", "loaddefaultConfiguration", "getdefaultParameters", "loadApplicationsettings", "loadDefaultsettings", "getdefaultConfiguration", "loadApplicationConfiguration", "loaddefaultSettings", "loadGlobalParameters", "loadGlobalsettings", "getDefaultConfiguration", "loadDefaultConfiguration"], "configFileName": ["configFullLocation", "ConfigModuleName", "configFullUrl", "configModuleName", "configPlaceName", "configFilesTime", "ConfigFileString", "fileFILELocation", "configFileType", "ConfigModuleString", "ConfigFileUrl", "ConfigFileLocation", "configFileUrl", "fileFileType", "configFILETime", "configFILEType", "configFilenameName", "configModuleUrl", "configModuleString", "fileFILETime", "configFilenameType", "configFILELocation", "configFileString", "fileFileName", "configFilesType", "ConfigModuleUrl", "fileFileLocation", "fileFileTime", "configFilenameLocation", "configFilesName", "configPlaceLocation", "fileFILEName", "configFilesLocation", "ConfigModuleLocation", "configFileTime", "configFILEName", "ConfigFileName", "configModuleLocation", "configFilenameTime", "configFullString", "configFullName", "configPlaceUrl", "fileFILEType", "configPlaceString", "configFileLocation"], "in": ["reader", "bin", "login", "f", "data", "it", "socket", "ins", "pin", "m", "stream", "cin", "In", "pc", "base", "is", "log", "inside", "ssl", "conn", "inner", "again", "din", "r", "work", "IN", "err", "plus", "pull", "this", "ini", "i", "source", "init", "inc", "nin", "url", "config", "n", "read", "pass", "inn", "as", "up", "id", "a", "resource", "input", "con", "diff"], "out": ["connection", "bin", "ext", "f", "data", "name", "point", "it", "version", "socket", "error", "s", "sync", "to", "ex", "outs", "one", "timeout", "able", "set", " file", "log", "copy", "conn", "user", "again", "output", "instance", "all", "writer", "and", "err", "password", "o", "off", "client", "OUT", "back", " back", "this", "d", "lib", "image", "inc", "t", "exec", "object", "parent", "default", " output", "view", "server", "config", "null", "io", "net", "c", "up", "file", "prefix", "ou", "exp", "Out", "string", "write", "obj"]}}
{"id1": "14758866", "id2": "5414088", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getResourceAsStream": ["getResourcesasFile", "getResourceASStream", "getResourceasFile", "getResourceToString", "getResourceasStream", "getResourcesasSteam", "getResourcesAsFile", "getResourcesasString", "getResourceToSteam", "getResourceAsString", "getResourcesAsStream", "getResourcesAsSteam", "getResourcesasStream", "getResourceASString", "getResourceASSteam", "getResourceToFile", "getResourceASFile", "getResourceToStream", "getResourceAsSteam", "getResourceasSteam", "getResourceAsFile", "getResourcesAsString", "getResourceasString"], "name": ["full", "connection", "ame", "data", "version", "type", "remote", "info", "ip", "str", "base", "part", "cache", "time", "size", "domain", "alias", "key", "address", "source", "path", "parent", "filename", "object", "hash", "Name", "config", "uri", "names", "memory", "file", "id", "prefix", "word", "resource", "named", "location", "string", "NAME", "username"], "inputStream": [" inputstream", "inputSteam", "cachestream", "currentBody", "InputConnection", " inputBody", "currentstream", "InputChannel", "InputStream", "currentStream", " inputChannel", "cacheSteam", "pullChannel", "inputBody", "pullConnection", "inputConnection", "cacheStream", "pullStream", "pullSteam", "inputFeed", "InputFeed", " inputConnection", "Inputstream", "inputChannel", "currentSteam", "InputBody", "cacheFeed", "InputSteam", "inputstream", " inputSteam", " inputFeed"], "in": ["reader", "bin", "data", "socket", "ins", "m", "In", "rec", "log", "inner", "din", "r", "IN", "err", "buffer", "source", "image", "path", "exec", "read", "c", "src", "input", "re", "Out"], "out": ["lock", "bin", "msg", "data", "point", "error", "pool", "state", "outs", "ex", "gen", "proc", "dump", "ger", "sys", "log", "copy", "page", "part", "conn", "user", "output", "cache", "cmd", "r", "line", "writer", "pre", "err", "query", "key", "client", "flush", "OUT", "temp", "list", "buffer", "cli", "bar", "outer", "object", "group", "server", "raw", "io", "up", "file", "params", "println", "inter", "window", "debug", "ref", "Out", "obj"], "url": ["full", "connection", "https", "open", "sl", "f", "data", "loc", "org", "socket", "ur", "gl", "remote", "stream", "web", "download", "event", "base", "log", "ssl", "page", "cache", "b", "user", "l", "r", "left", "client", "address", "pull", "Url", "service", "URL", "source", "image", "feed", "api", "path", "object", "update", "config", "li", "server", "uri", "route", "browser", "http", "file", "resource", "result", "coll", "bel", "location", "rel", "string", "ob"], "remoteName": ["fullPath", "localPath", "Remotename", "remoteUrl", "fullname", "fullKey", "remotename", "RemoteUrl", "RemotePath", "localUrl", " remotePath", "RemoteKey", "remotePath", " remoteUrl", "localKey", "remoteKey", "fullName", "RemoteName", " remoteKey", " remotename"], "localName": ["remoteFile", "locString", "locName", "globalString", "locname", "localPath", "LocalKey", " localname", "localFile", "LocalPath", "locUrl", "LocalName", "remoteUrl", " localKey", "locPath", "localString", " localString", "remotename", "localUrl", "globalFile", "remotePath", " localUrl", " localFile", "localKey", "remoteKey", "globalname", "globalName", "globalKey", "globalPath", "localname", "remoteString", " localPath", "Localname"], "host": ["localhost", "loc", "hard", "database", "head", "type", "remote", "format", "conn", "domain", "address", "proxy", "hop", "service", "driver", "path", "h", "config", "arch", "server", "uri", "http", "Host", "prefix", "src", "header", "target", "dir", "home", "addr", "string", "ip", "username"], "prot": ["prop", "family", "channel", "addr", "pt", "lat", "proc", " plat", "ssl", "ht", "conn", "part", " proto", "Prot", "txt", "att", "password", "client", " protocol", "cli", "api", "col", "pattern", "config", "conv", "platform", "pass", "afi", "cert", "pos", "prefix", "ocol", "stat", "ios", "pro", "ref", "def", "rel", "serv", " protocols", "rot", "nat"], "port": ["f", "version", "point", "phone", "PORT", "type", "slice", "allow", "p", "pi", "timeout", "position", "direction", "future", "pr", "time", "size", "Port", "patch", "password", "address", "service", "hop", "proxy", "ort", "select", "value", "limit", "project", "path", "pid", "width", "number", "server", "uri", "pass", "file", "ports", "index", "priority", "target", "length", "string", "ip", "rest"], "cacheFile": ["remoteFile", "CacheDirectory", "basefile", "outputConnection", "localfile", " cacheLine", " cachefile", "cacheConnection", "proxyHandle", "localFile", "outputFile", "baseFile", "CacheDir", "achePlace", "cacheMessage", "storageFile", "cacheDirectory", " cacheDir", "cacheLine", "remoteUrl", "fakeFile", "sessionDir", " cacheFiles", "localDir", "tempDir", "acheFiles", "sessionFiles", "cacheUrl", "tempfile", "fakeUrl", "storageFiles", "localFiles", "cacheHandle", "Cachefile", "cachePlace", "storagePlace", "proxyfile", "cacheFiles", " cacheHandle", "CacheUrl", "cachefile", "proxyDir", "fakeLine", "tempHandle", "remoteLine", "outputMessage", " cachePlace", "baseMessage", "CacheFile", " cacheConnection", "remotefile", "outputfile", "acheFile", "fakefile", " cacheMessage", "sessionUrl", "cacheDir", " cacheDirectory", " cacheUrl", "CacheFiles", "proxyFile", "localDirectory", "baseConnection", "tempFile", "sessionFile"], "urlConnection": ["URLconnection", "sslFile", "URLConnection", "slCode", "urlconnection", "slChannel", "httpCode", " urlFile", "cacheConnection", "cachePool", "cacheConn", "downloadEntry", "downloadConnection", " urlconnection", "webConnect", "fileConnection", "URLResponse", " urlChannel", " urlConnect", "urlPool", "slConnection", "cacheConnect", "fileConn", "urlEntry", "sslConnection", "urlPart", "filePart", "fileConnect", "downloadconnection", "slCommand", "sslResponse", "httpChannel", " urlCommand", "httpPool", "httpCon", "urlCon", "urlResponse", "urlConnect", "sslConn", "httpConnect", "downloadFile", " urlCode", "URLConn", "sslConnect", "urlCommand", " urlPool", "urlChannel", "httpconnection", "URLCon", "sslEntry", "urlCode", "sslconnection", "urlConn", " urlConn", "URLConnect", "httpResponse", " urlPart", "webconnection", " urlEntry", "URLPart", "webConnection", "httpCommand", "httpConn", "webCon", "urlFile", "httpConnection"], "httpURLConnection": ["httpCLConnector", "httpCLConnection", "httpREConnection", "httpSLCode", "upperRTransaction", "httpURLCode", "httpRNode", "upperRNode", " httpLLConstruction", "httpSLConnection", "httpRLConnector", "httpHTTPFunction", "httpREStatement", "httpHTTPQuery", "httpURQuery", "httpCLConnect", "httpSLconnection", "httpurlConnection", "httpRLClient", "httpURLConn", "httpMconnection", "upperURLNode", "httpWSNode", "httpLLconnection", "httpURNode", "httpBLQuery", "httpLLConnection", " httpUrlFunction", "httpUrlconnection", "httpDOMconnection", " httpUrlConnection", "httpMLFunction", "cacheURLClient", "httpUrlConnection", " httpHTTPConnection", " httpURLconnection", "httpRLConnection", "urlUrlClient", "httpBLFunction", "httpDateconnection", "httpURFunction", " httpLLConn", "cacheURLConnection", "httpBLOperation", "upperURLConnection", "httpREConstruction", "httpurlconnection", "httpurlStatement", "urlUrlStatement", "httpFormConnection", "httpURLFunction", "shortURLConnection", "httpREconnection", "httpMLconnection", "httpREClient", "upperURLconnection", "urlURLconnection", "httpRLConnect", "httpURLOperation", " httpHTTPQuery", "cacheURLConnect", "cacheUrlClient", "httpHTTPOperation", "httpWSTransaction", "httpURLClient", "httpMCode", "currentURLCode", "upperURLTransaction", "httpBLConnection", " httpUrlconnection", "httpUROperation", "shortSLConnection", " httpURLConn", "shortSLconnection", "httpURConnection", "httpURLNode", " httpLLConnection", "shortSLConnect", "httpUrlConnect", "httpFormConnect", "httpDateConstruction", "currentURLConnection", " httpHTTPFunction", "httpCLClient", "httpURLConstruction", " httpLLconnection", "httpURLconnection", "httpFormconnection", "httpURLStatement", "httpUrlFunction", "httpHTTPConnection", "httpSLConnect", " httpURLQuery", "urlUrlconnection", "httpWSconnection", " httpURLConnect", "currentURLconnection", "shortURLConnect", " httpURLOperation", "httpDOMFunction", "httpRConnection", "httpURTransaction", "currentURLConnect", "urlURLStatement", "httpDOMConnect", "httpUrlConnector", "httpMLConnect", "cacheUrlConnector", "httpDOMConnection", "httpUrlStatement", " httpURLFunction", " httpURLConstruction", "urlUrlConnection", "upperRconnection", "httpREConn", "urlURLClient", "httpMLConnection", "httpURconnection", "httpURLQuery", "httpLLConn", "httpURLConnector", " httpUrlConnect", "httpUrlClient", "urlURLConnection", "httpURLTransaction", "cacheURLConnector", "httpRLconnection", "httpurlClient", "httpLLConstruction", "cacheUrlConnect", "shortURLconnection", "httpWSConnection", " httpHTTPOperation", "httpDateConnection", "cacheUrlConnection", "httpRTransaction", "httpRconnection", "httpMConnection", "httpURLConnect", "upperRConnection", "httpDateConn", "httpMConnect"], "responseCode": ["statusStatus", "ResponseMessage", "statusCount", "ResponseCode", "statusType", "ResponseStatus", "replyMessage", "ResponseType", "statusCode", "replyType", "responseStatus", "replyCode", "ResponseCount", " responseMessage", "statusMessage", " responseStatus", "replyCount", "responseCount", "responseType", "responseMessage", " responseType"], "lastModified": ["lastModed", "lastMODIFIED", " lastMODined", "lastMinified", "lastEdIFIED", "New", "nextMODified", " lastModied", "lastEdified", "lastModIFIED", "lastmoded", "nextMODed", "lastMODied", "nextModIFIED", "nextMODied", "nextModied", "lastmodIFIED", " lastModined", " lastMODied", " lastMODIFIED", "lastEded", "lastmodified", "_", "lastMODified", "lastMinIFIED", " lastMODified", "lastmodied", "lastModied", "lastMinied", "this", "lastMODification", "lastmodification", "nextModification", "nextMODIFIED", "lastEdification", "lastMODed", " lastModIFIED", "lastModined", "s", "nextModified", "lastModification", "lastMinined", "lastMODined", "nextMODification", "nextModed"]}}
{"id1": "14324112", "id2": "4501356", "code1": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "code2": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "label": 1, "substitutes": {"innerProcess": ["innerprocess", "middleAccept", " innerMethod", " outerMethod", " innerAccept", "middleMethod", "middleprocess", "innerMethod", " outerAccept", "innerAccept", " innerprocess", "middleProcess", " outerProcess", " outerprocess"], "curi": ["luni", "numi", "lciri", "cuid", "Ciri", "biri", "lcri", "bURI", "cuni", "nuri", "lumi", "cui", "ctiri", "cacheuri", "funi", "cdu", "fri", " cuni", "furi", "CURI", "ctURI", "requuni", "ciri", "cURI", "requiri", "cturi", "luid", "ucURI", "buri", " cdu", "cacheui", " cui", "Cui", "cachedu", "cdirectory", " cuid", "requumi", " cURI", "ctuid", "lri", " cdirectory", "ucuri", "uciri", "lcui", "fURI", "lURI", "liri", "Cri", "fcri", " couri", "ldirectory", "lcURI", "Curi", " ciri", "fcumi", "firi", "Couri", "cacheURI", "Cdu", "cumi", "bdirectory", "ucuni", " cri", "lcuri", "couri", "luri", "requuri", "fui", "fcURI", " cumi", "lcouri", "cri", "fcuri", "nri", "nURI"], "maxsize": ["axize", "axsize", "totalsize", "Maxsize", "MaxSIZE", " maxSIZE", " maxname", "lastsize", "minSize", "defaultsize", "axSize", "MAXname", "MaxSize", " maxscale", "lastSize", "totalize", "maxname", "totalscale", "MAXSIZE", "minsize", "maxSIZE", "maxaddress", " maxSize", "Maxscale", "Maxname", "maxSize", "maxscale", "lastaddress", "minaddress", "Maxize", " maxaddress", " maxize", "defaultize", "MAXsize", "maxize", "defaultSize", "totalSize", "MAXSize"], "regexpr": ["replayor", "rerePr", "perepr", "regexpl", "pegexPr", "REgexr", "regexpp", "refgexpp", "regexexpr", "regexpect", "requpr", "refgexPr", "regexPR", "refgexpl", "egexpr", "egexPr", "rentaxexpr", "rereexpr", "reqor", "pegexexpr", "rerePR", "regexr", "rerexpr", "replaypt", "reuxpr", "rentaxPR", "replexexpr", "requpect", "REgexpr", "reuxpl", "REqpr", "egexps", "replexPR", "replaypr", "equpect", "REgexor", "regexpt", "perePR", "rerexps", "requPr", "rexpr", "resexPr", "reuxPr", "REgexpt", "replexpl", "refplexpp", "pereexpr", "resexps", "regexps", "REqor", "refplexpr", "refgexpr", "resexpr", "refplexpl", "rexpl", "rerexPr", "replexpr", "regexPr", "rentaxpr", "reuxpp", "REqpt", "pegexpr", "rexPr", "replexPr", "refplexPr", "resexpect", "replexpp", "rerexpect", "reqpr", "rerepr", "pegexPR", "egexpect", "perePr", "rexpp", "requps", "regexor", "replayr", "equps", "equPr", "equpr", "reqr", "rentaxPr", "REqr", "reqpt"], "cs": ["ts", "cn", "cos", "sc", "TS", "ds", "ca", "GC", "bs", "ences", "ins", "acks", "sync", "ns", "cms", "ics", "str", "ec", "pc", "lc", "ls", "cells", "cache", "css", "cr", "rs", "wcs", "ras", "ks", "cc", "ci", "ctx", "qs", "cf", "js", "ces", "spec", "ch", "cl", "gs", "ps", "c", "ce", "acs", "cks", "tc", "coll", "cas", "cm", "mc", "CS", "ches", "cons", "ms", "cp", "cus", "fs", "Cs", "acts"], "digest": ["signEST", "signusher", "returnEST", " diger", "DigEST", "diggest", "Digester", "Digusher", " digusher", "shaher", "shaest", "returnester", "digester", "digEST", "returnest", "signester", "shaer", " digEST", "digher", "returngest", "diger", "digusher", "Diggest", "Diger", "signest", "Digher", "shaEST", " digester", "Digest", " diggest", " digher"], "s": ["sl", "su", "f", "si", "session", "g", "groups", "services", "sets", "sync", "p", "ns", "str", "summary", "ls", "cells", "u", "b", "w", "sv", "l", "r", "single", "o", "lines", "strings", "d", "i", "S", "ws", "t", "js", "h", "v", "n", "ps", "details", "c", "params", "states", "sb", "ss", "ms", "string"], "m": ["bm", "gm", "f", "machine", "rm", "g", "p", "arm", "im", "b", "text", "imm", "am", "M", "wm", "mac", "l", "r", "dm", "ym", "um", "sm", "i", "d", "mo", "t", "h", "tm", "v", "mi", "n", "mm", "pm", "cm", "mc", "fm", "ms", "nm"]}}
{"id1": "17947247", "id2": "17557289", "code1": "    public String postURL(String urlLocation, ArrayList headers, String content, HashMap postVariables, RenderEngine c) throws Exception {\n        String postContent = null;\n        if (postVariables != null) {\n            boolean firstElement = true;\n            postContent = new String();\n            Iterator elements = postVariables.keySet().iterator();\n            while (elements.hasNext()) {\n                String key = (String) elements.next();\n                String val = (String) postVariables.get(key);\n                if (firstElement) {\n                    postContent += Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                    firstElement = false;\n                } else {\n                    postContent += \"&\" + Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                }\n            }\n            elements = null;\n        } else {\n            postContent = content;\n        }\n        Debug.log(\"Connecting to URL '\" + urlLocation + \"', content '\" + postContent + \"'\");\n        URL url = null;\n        try {\n            url = new URL(urlLocation);\n        } catch (MalformedURLException e) {\n            Debug.log(\"Unable to retrieve URL '\" + urlLocation + \"': \" + e.getMessage());\n            return null;\n        }\n        StringBuffer lines = new StringBuffer();\n        HttpURLConnection conn = null;\n        boolean contentLengthFound = false;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            loadCookies(urlLocation, conn, c);\n            if (headers != null) {\n                for (int i = 0; i < headers.size(); i++) {\n                    String header = (String) headers.get(i);\n                    String key = header.substring(0, header.indexOf(\":\"));\n                    String value = header.substring(header.indexOf(\":\") + 2);\n                    if (key != null && key.equalsIgnoreCase(\"content-length\")) {\n                        contentLengthFound = true;\n                    }\n                    Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                    conn.setRequestProperty(key, value);\n                }\n            }\n            if (!contentLengthFound) {\n                Debug.log(\"Adding new request header 'Content-Length'='\" + postContent.length() + \"'\");\n                conn.setRequestProperty(\"Content-Length\", Integer.toString(postContent.length()));\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(postContent);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                lines.append(line);\n                lines.append(\"\\r\\n\");\n            }\n            handleHeaders(urlLocation, conn.getHeaderFields());\n            wr.close();\n            rd.close();\n            wr = null;\n            rd = null;\n        } catch (IOException e) {\n            if (conn != null) {\n                lines = new StringBuffer();\n                try {\n                    throw new Exception(\"Server returned error code '\" + conn.getResponseCode() + \"': \" + conn.getResponseMessage());\n                } catch (IOException ee) {\n                    throw new Exception(\"Unable to report error codes: \" + ee.getMessage());\n                }\n            }\n            Debug.log(\"I/O Exception occurred while communicating with endpoint: \" + e.getMessage());\n            return lines.toString().trim();\n        } catch (Exception e) {\n        }\n        url = null;\n        conn = null;\n        return lines.toString().trim();\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 0, "substitutes": {"postURL": ["PostUrl", "Posturl", " postUrl", " postSSL", "POSTSSL", "PostURL", "POSTUrl", "posturl", "POSTURL", "postUrl", "POSTurl", " posturl", "PostSSL", "postSSL"], "urlLocation": ["urlLOC", "queuePath", "slRegion", "urlLocated", "resourceLoc", " urllocation", "URLPath", " urlLocated", "slLoc", "httpLoc", "baseLocation", "resourcePath", "URLLocation", "queueLocation", "httpDirectory", "httplocation", "queueLoc", "queueLOC", "URLSource", "urlLoc", "buildlocation", " urlDirectory", "fileLocation", "baselocation", "URLLocated", "URLDirectory", "resourceLocation", " urlAddress", "buildLocation", "urllocation", "fileLOC", "resourcelocation", "filePath", "urlDirectory", "URLlocation", "httpSource", "urlRegion", "httpLocation", "resourceRegion", "sllocation", "URLAddress", "resourceLOC", "urlAddress", " urlPath", "urlSource", " urlSource", "buildPath", "baseDirectory", "urlPath", "baseLoc", "httpAddress", "URLLoc", "slLocation", "buildLocated", "URLRegion", "resourceDirectory", "fileLoc"], "headers": ["ids", "heads", "pages", "players", "vals", "values", "liners", "breaks", "rows", "cats", "head", "ors", "groups", "versions", "body", "results", "services", "events", "vers", "quarters", "codes", "cells", "hers", "parts", "files", "features", "builders", "drivers", "workers", "authors", "blogs", "posts", "writers", "strings", "archives", "rooms", "qs", "response", "books", "frames", "comments", "names", "errors", "styles", "ppers", "boxes", "http", "keys", "fields", "details", "params", "links", "users", "properties", "host", "types", "resources", "plugins", "html", "ers", "limits"], "content": ["connection", "data", "current", "container", "create", "body", "string", "stream", "cont", "array", "load", "xml", "activity", "status", "model", "description", "page", "cache", "text", "output", "address", "Content", "temp", "buffer", "comment", "continue", "cf", "request", "response", "object", "context", "comments", "document", "code", "raw", "server", "memory", "script", "title", "message", "resource", "input", "location", "resources", "json", "html", "media"], "postVariables": ["postvariars", "postGenerams", "postvariams", "postvariable", "postVarories", "Postvariars", " postvariables", "postVariars", "postVariories", "postvariories", " postVariable", "postVarables", "postVarants", "postVariants", "postParatures", "postIterams", "PostVariars", "postParams", "postParants", "postGenerable", "Postvariables", " postVariants", "postVariable", "postVariatures", "postParable", "postIterants", "Postvariories", "postvariables", " postvariants", "Postvariants", "PostVariories", "postParories", "postVarars", " postVariams", "postIterables", " postvariable", "postIteratures", " postvariatures", "postvariatures", "postParables", "postVariams", "postGenerants", " postVariatures", "PostVariables", "PostVariants", "postvariants", "postGenerables", "postParars", " postvariams"], "c": ["cb", "f", "container", "g", " C", "C", " controller", "p", "enc", "ec", "rc", " ec", "cs", "lc", "cache", "w", "b", "conf", "cr", "r", "engine", "l", "e", " dc", " cr", "client", "dc", "d", "cli", "cc", "ci", "ctx", "vc", "t", "or", "driver", "cf", "h", "context", "config", "code", "ce", " cc", "tc", "cp"], "postContent": ["endContent", "preString", "postString", "postText", "objectValue", " postEntity", "putValue", "endContents", "putcontent", "endMessage", "POSTValue", "PostText", "putContent", "precontent", "preContent", "postMessage", "postcontent", " postString", "uploadMessage", "preValue", " postValue", "preMessage", "objectMessage", "uploadValue", "ostMessage", " postHeader", "POSTContent", "PostMessage", " postMessage", "postHeader", "Postcontent", "PostContent", "POSTText", "objectContent", "uploadcontent", " postcontent", "ostHeader", "PostValue", "uploadContent", "PostString", "objectcontent", " postContents", "ostContent", "putEntity", " postText", "POSTMessage", "postContents", "postValue", "ostContents", "endHeader", "postEntity", "objectEntity"], "elements": ["eachers", "Evers", "euachers", "feodes", "ellers", " ellers", "Eachers", "eelem", "Eators", "elem", "Elem", "seators", "eators", " evers", "eelements", "eodes", " eators", "eulements", " elem", "nelement", "beators", "severs", " element", "neodes", "Elements", "selements", "eeodes", "nelem", "selem", "felem", "bevers", "Element", "felement", "Ellers", "nelements", "evers", "felements", "eulem", "eullers", "belements", "belement", "eelement", " eachers", "element"], "key": ["feature", "lock", "data", "name", "type", "field", "letter", "ie", "section", "ke", "service", "step", "hop", "cookie", "property", "sign", "function", "wire", "search", "item", "coll", "pick", "option", "element", "point", "string", "variable", "label", "rule", "page", "query", "parent", "hash", "order", "code", "group", "keys", "id", "word", "Key", "start", "ray", "x", "ver", "f", "loc", "my", "seed", "info", "param", "model", "part", "check", "var", "root", "e", "patch", "cell", "temp", "style", "ry", "col", "ip", "y", "kw", "q", "reason", "head", "change", "ge", "k", "base", "match", "req", "KEY", "mac", "life", "entry", "block", "child", "object", "role", "v", "pe", "index", "fix", "right", "link", "ace", "ee"], "val": ["x", "sl", "vals", "ver", "data", "doc", "loc", "alt", "al", "iv", "el", "py", "string", "pt", "vr", "ol", "Val", "base", "vol", "text", "var", "la", "ret", "eval", "v", "li", "sol", "pos", "valid", "len", "vi", "sel", "item", "Value", "VAL", "ref", "rel", "arg", "serv", "element", "il"], "firstElement": ["nextEl", "singleElement", " firstEntry", " firstAddress", "nextElement", " firstLine", "nextLetter", "lastElement", " firstelement", "FirstElement", "singleEntry", "FirstEntry", "firstEntry", "Firstelement", "lastelement", "lastEl", "lastEntry", "FirstLine", "firstAddress", "FirstAddress", " firstLetter", "firstLetter", " firstEl", "lastLetter", "lastAddress", "singleelement", "firstEl", "singleLine", "firstLine", "nextelement", "firstelement"], "url": ["connection", "sl", "f", "loc", "org", "fl", "channel", "session", "ur", "gl", "el", "download", "base", "ssl", "log", "ls", "ll", "page", "b", "loader", "user", "l", "fr", "client", "pull", "Url", "proxy", "URL", "source", "image", "entry", "service", "build", "path", "object", "config", "server", "uri", "http", "file", "cert", "impl", "resource", "result", "www", "host", "link", "coll", "location"], "lines": ["data", " data", "s", "body", "str", " msg", " buffers", "ls", "b", "l", "strings", " messages", "buffer", " r", "Line", "response", " params", " strings", "result", " results", "out", " code", "string", " Lines", " text", "buf"], "conn": ["connection", "lock", "open", "cb", "loc", "cn", "reg", "socket", "nc", "session", "oss", "ca", "ct", "sync", "dn", "ns", "enc", "en", "pc", "ann", "rc", "ssl", "cache", "conf", "l", "client", "dc", "cat", "ci", "cli", "ctx", "connect", "ch", "cf", "db", "h", "exec", "config", "conv", "Conn", "http", "net", "co", "coll", "con", "auth", "cp", "Connection", "col", "serv", "resp", "act"], "i": ["x", "f", "y", "si", "it", "ti", "ri", "depth", "type", "slice", "p", "j", "info", "pi", "k", "ori", "ix", "hi", "I", "di", "u", "b", "multi", "inner", "bi", "qi", "r", "fi", "e", "ini", "d", "count", "ci", "z", "h", "xi", "v", "oi", "ui", "li", "n", "uri", "ii", "io", "id", "index", "mu", "chi", "iu", "eni", "ai", "gi", "phi", "ip", "end"], "header": ["iter", "data", "name", "version", "type", "field", "definition", "detail", "letter", "format", "section", "buffer", "service", "cookie", "h", "property", "Header", "message", "queue", "host", "length", "border", "standard", "profile", "handler", "rule", "description", "page", "inner", "protection", "her", "member", "client", "address", "dr", "back", "column", "port", "second", "character", "code", "date", "metadata", "result", "offset", "reader", "heading", "filter", "component", "writer", "patch", "hr", "title", "prefix", "connection", "er", "head", "handle", "body", "layer", "event", "comment", "player", "entry", "padding", "request", "response", "driver", "filename", "server", "index", "frame", "token", "cover", "string"], "value": ["feature", "alt", "data", "current", "name", "version", "vector", "widget", "type", "range", "language", "variable", "definition", "label", "option", "letter", "expression", "lc", "format", "description", "model", "text", "section", "sv", "VALUE", "va", "test", "style", "padding", "object", "v", "property", "default", "hello", "server", "null", "valid", "message", "vi", "item", "Value", "json", "string", "media", "end", "element"], "contentLengthFound": ["contentSizefound", "contentLengthfound", "contentLenfound", " contentSizefound", "contentlengthFound", "loadLengthFound", "contentlengthfound", " contentLengthLost", "contentLenLost", " contentLengthfound", "contentBufferFound", " contentlengthfound", " contentSizeLost", " contentlengthFound", " contentLengthLeft", "contentlengthLeft", "contentStringFound", "contentStringfound", "loadSizefound", " contentlengthLeft", "contentStringLeft", "contentBufferLost", "contentLengthLeft", "contentBufferfound", " contentSizeFound", "contentSizeLost", "loadLengthfound", "contentLengthLost", "loadSizeFound", "contentSizeFound", "contentSizeLeft", "contentLenFound"]}}
{"id1": "3584508", "id2": "364438", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": ["copyUrl", " downloadUrl", "transferresource", " copyresource", "copyFile", " downloadResource", " copyUrl", "transferUrl", " downloadresource", "transferResource", " downloadFile", "copyresource", "transferFile", " copyFile"], "url": ["connection", "sl", "f", "data", "loc", "name", "remote", "stream", "web", "download", "xml", "base", "ssl", "ource", "ls", "page", "loader", "l", "r", "address", "Url", "URL", "source", "image", "feed", "path", "object", "lr", "uri", "server", "http", "file", "id", "src", "resource", "bel", "www", "host", "ref", "re", "string"], "input": ["active", "reader", "bin", "connection", "inf", "qa", "open", "f", "data", "current", "get", "socket", "error", "session", "ack", "audio", "stream", "load", "xml", "binary", "base", "ssl", "bb", "cache", "inner", "instance", "l", "plus", "client", "address", "pull", "temp", "this", "buffer", "i", "source", "parse", "image", "but", "inc", "api", "feed", "request", "exec", "form", "context", "config", "http", "in", "file", "index", "upload", "resource", "out", "accept", "progress", "Input", "element", "act"], "output": ["connection", "data", "current", "socket", "put", "stream", "operation", "layer", "application", "web", "binary", "log", "control", "copy", "cache", "writer", "flow", "address", "console", "external", "buffer", "source", "image", "production", "response", "outer", "object", "environment", "other", "default", "config", "document", "unit", "file", "resource", "out", "result", "queue", "target", "ou", "network", "write", "Output"], "b": ["x", "be", "bin", "cb", "ob", "f", "bit", "batch", "bs", "m", "p", "k", "base", "binary", "bb", "bi", "B", "mb", "br", "abs", "l", "line", "r", "e", "bc", "rb", "d", "buffer", "i", "bar", "db", "lb", "h", "v", "n", "ab", "pb", "c", "file", "a", "sb", "bf", "fb", "nb", "buf"]}}
{"id1": "11484416", "id2": "16378239", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "label": 1, "substitutes": {"moveFile": [" movedDirectory", " moveDirectory", "MoveFiles", " movedFiles", "moveFiles", "MoveDirectory", " movedPath", " movedFile", " moveFiles", "movePath", "moveDirectory", " movePath", "MovePath", "MoveFile"], "orig": ["bin", "iter", "ext", "Orig", "f", "loc", "org", "origin", "archive", "ctr", "remote", "raf", "array", "ori", "info", "comb", "base", "prev", "copy", "img", "old", "coord", "raid", "dest", "imag", "temp", "rb", "exe", "proxy", "source", "real", "init", "image", "build", "bas", "original", "file", "folder", "id", "impl", "src", "transform", "frame", "coll", "home", "internal", "obj", "buf", "tmp"], "target": ["nt", "f", "current", "it", "force", "origin", "manager", "master", "archive", "arget", "remote", "reference", "auto", "to", "base", "prot", "format", "copy", "match", "eth", "dest", "temp", "this", "ret", "external", "source", "build", "template", "t", "project", "path", "parent", "object", "next", "platform", "original", "Target", "resource", "join", "result", "replace", "compatible", " Target", "tmp"], "buffer": ["bin", "iter", "uffer", "sequence", "data", "batch", "reference", "slice", "layer", "buff", "stack", "Buffer", "binary", "base", "position", "copy", "bb", "cache", "b", "bytes", "content", "address", "padding", "source", "block", "feed", "request", "url", "transfer", "read", "code", "raw", "null", "repeat", "file", "wave", "message", "frame", "header", "result", "resource", "input", "queue", "length", "write", "buf"], "bread": ["ffe", "rows", "bat", "fen", "batch", "robe", "piece", "fle", "ble", "fall", "good", "web", "rub", "div", "fe", "eb", "zero", "str", "fine", "fed", "bn", "loop", "bb", "die", "beat", "cook", "num", "zip", "wake", "bare", "key", "circ", "design", "bc", "abi", "meal", "feed", "cake", "raft", "brew", "choice", "fred", "food", "wen", "bee", "width", "hello", "inn", "knife", "buck", "grain", "sleep", "fee", "length", "fif", "rib", "four", "broken"], "fis": ["fiss", "lfos", "afis", "ufiss", "hIs", "fisa", " fisa", "his", "qils", "lfis", "fIs", " fIs", "fxIs", "fxis", "fxisa", "afiss", "afos", "afIs", "fxos", "qos", "fils", "hisa", "qiss", " fiss", "lfIs", "ufils", " fils", "lfiss", "qis", "ufis", "hos", "ufos"], "fos": ["infaos", " foss", "flens", "Foses", "foses", "flois", "fose", "flose", "Fose", "gros", "Fois", "Faos", "gis", "flaos", "Fros", " fose", "flors", "floses", "gos", "Fens", " foses", "Fis", "infos", "infois", "fors", "fros", "Foss", "goss", "foss", " fens", "Fos", " fros", "fois", "faos", "flos", "Fors", "fens", "infors"]}}
{"id1": "160739", "id2": "19739421", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createOutputSteam", "createInputStream", " createInputSteam", "createOutputSteam", " createByteSteam", " createOutputFile", " createOutputReader", " createIOSteam", "createInputReader", " createByteFile", " createByteReader", " createIOStream", " createByteStream", "createInputSteam", " createInputFile", " createInputReader", " createIOReader", "createOutputReader", "createOutputFile", "createInputFile", " createIOFile", " createInputStream"], "inFile": ["inputFile", "outFiles", "insfile", "infile", "inputfile", "outfile", "outStream", "incFiles", "sourceFiles", "incfile", "inFiles", "insStream", "sourceStream", "incFile", "insFile", "sourcefile", "inputFiles", "inputStream", "sourceFile", "insFiles", "inStream", "incStream"], "outFile": ["inputFile", "workingDirectory", "workDir", " outStream", "targetFile", "outDir", "inputTime", "infile", "inputfile", "outfile", "outStream", "inDir", "workingFile", "targetStream", " outDirectory", "targetfile", "inputDir", " outfile", "workingfile", "outTime", "workfile", "targetDirectory", "inTime", "workFile", "workingStream", "outDirectory", "workTime"], "k_blockSize": ["k_lineInfo", "k_BlockCount", "k_blockLength", "k_BlockLength", "k_lockCount", "k_blockInfo", "k_BlockSize", "k_blockCode", "k_blocksLen", "k_blocksSize", "k_blocksCount", "k_lineCount", "k_byteCount", "k_BlockCode", "k_bitInfo", "k_lockLength", "k_byteLen", "k_lockLen", "k_blockCount", "k_blocksLength", "k_bitCount", "k_byteSize", "k_blockLen", "k_lockSize", "k_byteInfo", "k_lineSize", "k_byteCode", "k_byteLength", "k_lockCode", "k_bitSize"], "byteCount": [" byteSize", "ByteCount", "blockSize", "flushLength", "flushcount", " byteLen", "bytecount", "ByteLen", "byteSum", "blockLength", "characterCount", "flushSize", "ByteSize", "ByteSum", "byteLen", " byteSum", "blockSum", " byteLength", "characterLen", "characterLength", "ByteLength", " bytecount", "byteLength", "blockCount", "flushCount", "characterSize", "byteSize", "Bytecount"], "buf": ["border", "cb", "seq", "data", "loc", "background", "batch", "alloc", "buff", "cap", "Buffer", "bh", "rc", "feat", "base", "b", "vec", "bytes", "img", "cmd", "bag", "exc", "flush", "font", "la", "rb", "buffer", "ctx", "feed", "ucc", "Buff", "config", "cv", "brace", "len", "src", "fd", "uf", "cas", "queue", "bf", "append", "result", "fb", "tmp"], "ofp": ["Oftp", "OFt", "afc", "Ofl", "Ofp", "oftp", "fortp", "forp", "OFtp", "ofl", "fort", "ofnp", "oft", "afl", "Ofnp", "afnp", "OFp", "OFl", "OFc", "forc", "Ofc", "afp", "ofc", "OFnp", "Oft"], "zos": ["lol", "cos", "zy", "bes", "outs", "ls", "css", "rez", "tz", "nz", "uz", "ws", "zyk", "zn", "js", "cfg", "zx", "nox", "ozo", "modules", "bitcoin", "ros", "ZA", "ses", "webkit", "fits", "ogl", "enos", "liquid", "bs", "os", "lins", "kos", "zl", "zag", "zin", "obs", "zip", "oses", "ZI", "iffs", "abi", "packs", "z", "rons", "osi", "inos", "zar", "los", "zo", "obb", "zona", "budget", "bos", "ossus", "ops", "jas", "zers", "zh", "zb", "zik", "zen", "zi", "soon", "zig", "zes", "forge", "owicz", "oS", "hz", "robe", "gz", "utils", "zon", "iframe", "zer", "oda", "dylib", "core", "za"], "osw": ["ossd", "issw", "osd", "osfw", "oswd", "isnow", "ishell", "esww", "bx", "osshell", "esy", "esnow", " osww", "oshell", "iswd", "eshell", "ossow", "ossy", "ossfw", "bws", "bsx", "lsx", "osy", "ossww", "osssw", "bsws", "bsw", "esfw", "isy", "osx", "ossw", "isd", " osfw", "lsw", "ossnow", "esow", "osws", " osow", "lswo", "osswd", "isw", "bwo", "essw", "osow", "esw", "esd", "oswo", "osnow", "eswd", "lsws", "osww", "bswo"], "bw": ["bbwa", " bz", "lbsw", "bbaw", "bbwu", "abW", "abwd", " bwa", "bx", " bew", "fw", "bz", "fbwe", "ebwd", "bbws", "fsw", "lbw", "lw", "bws", "fwa", "ebwe", " baw", "ow", "lbx", "abwe", "bbz", " bws", "owu", "oaw", "Bw", "bew", "lbwa", "bwu", "bsw", "lx", "fr", "bbwh", "lbws", "baw", "ebw", "fx", "bwe", "bbew", "fwh", "abw", "lsw", "bwh", "lbr", "ebW", "Bwa", " bwu", "Bws", "fbW", "lbwh", "Bew", "owa", "bwd", "fbw", "fbwd", "bwa", "bbw", " bwh", "lbz", "bW", "lwa"], "zot": ["azor", "jit", "Zit", "ziot", " zor", "zerot", "jori", "azit", "Zita", "azot", "jot", "Zott", "zerott", "zerita", "zeros", "zita", "Zot", "zerori", "aziot", " zori", "Zor", "azita", "zott", "azott", "zerit", "zor", " ziot", "zori", "jos", "Ziot"], "ifp": ["ifb", " ifc", "Iff", "ifl", "ifi", "ipl", "IFp", " ifi", " ifb", "Ifi", "ipc", "ipp", "Ifc", " iff", "IFl", "ipb", " ifl", "IFc", "iff", "IFi", "Ifp", "ifc", "IFb", "IFf"], "zis": ["zenIS", "Ziss", "zipits", "jit", "Zis", "jisi", "xits", "zeits", "xisi", "zenais", "xis", "zeiss", "zisi", "ziss", "zeis", "zipis", "zip", "xIS", "xib", " zisi", "zipip", " zIS", "jits", "zenib", "zeip", "jis", " zits", "zIS", "zenis", " zais", "zib", "xais", " zib", "zits", "zipiss", "xit", "Zip", "Zits", "zais"], "isr": ["risr", "iscr", "rispr", "irpr", "ISr", "irr", "irrb", " iscr", "ISrs", "isrs", "IScr", "isrc", "issr", "ISpr", "ISrc", "ISrb", "isrb", "ISsr", "issrs", "isscr", "isssr", " issr", "risrc", "irrc", "ispr", "risrb", " isrs"], "br": ["mr", "Br", "ob", "HR", "ibr", "arr", "ctr", "body", "kr", "div", "str", "bh", " fr", "bl", "obl", " BR", "yr", "b", "img", " Br", "r", "bp", "rs", "err", "fr", "cro", "rb", "bar", "BR", "sp", "shr", "hr", "ch", "lr", "ibl", "browser", "ocr", "gr", "sr", "bsp", "rib", "bro", "tr", " dr", "ber", "obi", "bc"], "zit": ["zipith", "ji", "zipits", "jit", "zipit", "zIT", "zite", " zite", "zipitter", "zipita", " zi", "jip", " zic", "xic", "zeits", "zeIT", "jIT", " zith", "zith", "zita", "zip", "jic", "zipip", "zenitter", "jits", "jith", "zipite", "zeita", "zenith", "zitter", "xi", "jite", " zits", "zipIT", "zi", "xith", " zip", "jita", "zits", "zic", "zeit", "zeitter", "zenit", "xit", "zeith", "zenits"]}}
{"id1": "17791385", "id2": "659316", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyStream", "Copyfile", "copyFiles", " copyfile", " copyStream", "transferFile", "transferfile", " copyFiles", "transferStream", "CopyFiles", "CopyFile", "transferFiles", "copyfile", "copyStream"], "src": ["inf", "sl", "sin", "loc", "sup", "s", "sc", "ins", "stream", "st", "ipl", "inst", "rc", "ls", "b", "files", "txt", "img", "dist", "dest", "back", "rb", "source", "image", "filename", "url", "config", "uri", "sit", "http", "file", "upload", "sel", "sb", "input", "resource", "obj"], "dst": ["fdst", "Dlt", "fdft", "pdfd", "dsts", " dsts", " ddest", "dft", " dlt", "fdfd", "pdsp", "dsp", "ddst", "ddest", "ddfd", "pdft", "pdst", "dlt", "fdsp", "Dst", "stdest", "Ddest", "stlt", "stst", "ddft", "Dsts", "dfd", "ststs", "ddsp"], "in": ["reader", "bin", "sin", "f", "login", "data", "socket", "ins", "pin", "m", "cin", "In", "is", "inside", "kin", "conn", "inner", "again", "rin", "win", "r", "din", "IN", "err", "pull", "ini", "i", "init", "inc", "nin", "h", "url", "n", "inn", "oin", "as", "file", "id", "impl", "lin", "input", "con", "ln", "gin"], "out": ["x", "bin", "ext", "f", "self", "at", "s", "sync", "ex", "outs", "plain", "copy", "conn", "w", "again", "output", "cache", "part", "writer", "line", "err", "o", "off", "client", "OUT", "temp", "i", "inc", "exec", "outer", "parent", "other", "n", "raw", "server", "post", "null", "io", "net", "file", "up", "exp", "Out", "obj"], "buf": ["bin", "cur", "cb", "bd", "seq", "data", "loc", "ff", "fl", "lim", "batch", "cap", "buff", "bh", "rc", "base", "bl", "bb", "b", "vec", "br", "bytes", "cmd", "val", "bag", "off", "rb", "buffer", "count", "cat", "ctx", "uc", "v", "raw", "c", "wb", "fd", "uf", "queue", "bf", "pad", "length", "fb", "bc"], "len": ["nt", "bin", "lt", "le", "sl", "f", "data", "name", "fl", "lim", "el", "rev", "cap", "en", "ind", "ll", "base", "lc", "ix", "part", "all", "size", "l", "line", "val", "err", "lf", "count", "i", "no", "cl", "n", "li", "c", "split", "pos", "fd", "lin", "fin", "Len", "length", "ln", "end"]}}
{"id1": "949327", "id2": "5135688", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    private boolean saveNodeMeta(NodeInfo info, int properties) {\n        boolean rCode = false;\n        String query = mServer + \"save.php\" + (\"?id=\" + info.getId());\n        try {\n            URL url = new URL(query);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            byte[] body = Helpers.EncodeString(Helpers.ASCII, createURLEncodedPropertyString(info, properties));\n            conn.setAllowUserInteraction(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            setCredentials(conn);\n            conn.setDoOutput(true);\n            conn.getOutputStream().write(body);\n            rCode = saveNode(info, conn);\n        } catch (Exception ex) {\n            System.out.println(\"Exception: \" + ex.toString());\n        }\n        return rCode;\n    }\n", "label": 0, "substitutes": {"f": ["x", "inf", "df", "name", "ff", "self", "fen", "s", "g", "m", "p", "j", "fe", "fun", "b", "w", "rf", "F", "l", "r", "fn", "fi", "e", "tf", "fr", "lf", "fold", "this", "d", "fx", "feed", "t", "cf", "path", "h", "filename", "of", "v", "form", "n", "io", "flat", "c", "file", "function", "fa", "folder", "a", "fd", "bf", "sf", "fp", "fo", "fm", "ref", "fc", "fs"], "in": ["lock", "login", "data", "str", "vin", "is", "ssl", "b", "w", "win", "IN", "err", "d", "source", "t", "exec", "c", "it", "socket", "session", "g", "ins", "pin", "m", "fe", "inner", "rin", "init", "nin", "or", "thin", "up", "fa", "gin", "reader", "p", "cin", "In", "part", "with", "r", "ini", "image", "inc", "config", "n", "con", "serv", "connection", "bin", "isin", "get", "ex", "min", "gen", "rec", "again", "l", "din", "v", "pass", "inn", "a", "ic", "lin", "token", "input", "diff", "ac"], "cbuf": ["bault", "bcault", "bbull", "cbull", "bcurs", "CBuff", "rbux", "cbuu", "zbutf", "bcull", "dbuc", "bcuf", "CBuc", "bcux", "zbuu", "cbault", "cfuff", "buff", "dbuff", "rbul", "bbuff", "CBuf", "cfur", "cfuc", "rbbuf", "rbutf", "cburs", "rbull", "rburs", "zbuff", "ebutf", "cbur", "CBul", "ebuff", "ebuf", "rbuu", "dbuf", "bcul", "fbuc", "cbul", "rbuf", "cbuff", "bcuff", "bux", "rbault", "bburs", "cbutf", "fbbuf", "ebuu", "buf", "fbuf", "bcuc", "rbuff", "cbuc", "cbux", "dbur", "cfuf", "cfbuf", "bcur", "fbuff", "bbuf", "rbuc", "cbbuf", "zbuf"], "read": ["iter", "data", "name", "type", "put", "know", "only", "find", "reads", "orig", "loop", "w", "work", "val", "d", "buffer", "select", "want", "fill", "close", "update", "io", "cel", "length", "report", "print", "re", "end", "wait", "READ", "open", "it", "socket", "Read", "error", "allow", "g", "play", "stream", "se", "load", "en", "ind", "log", " write", "ok", "key", "bind", "call", "count", "parse", "build", "level", "oct", "id", "last", "record", "insert", "use", "start", "bit", "x", "reader", "ride", "un", "create", "send", "add", "check", " READ", "old", "r", "each", "ak", "seek", "run", "lex", "ing", "feed", "connect", "inc", "config", "raw", "valid", "full", "er", "readable", "y", "get", "q", "ack", "change", "sync", "k", "used", "hex", "rc", "text", "size", "num", "child", " Read", "reading", "view", "pass", "pe", "ink", "repeat", "index", "ed", "input", "ize", "skip", " reading", "sleep", "draw", "write"], "totRead": ["ntottReader", "tottDraw", "TotaRead", "ntottLoad", "tobyFind", "tollRead", "toyDraw", "totoRead", "TotLoad", "tottFind", "totaLink", "ntotLoad", "tollLoad", "octotoRead", "tottReader", "tcotLoad", "tntRead", "dotReader", "tottLength", "dotWrite", "totoUse", "tottClose", "dottFind", "ntottRead", "octotoWrite", "totalWrite", "totingGet", " totalLink", "totingSearch", "tottSearch", "tottedRead", "nottLoad", "dottLoad", "totLength", "tobyRead", " totalBuild", "ntotReader", "tollReading", "tottedWrite", "totalLoad", "totaReader", "TotSearch", "notLoad", "tochReader", "TottLoad", " totalRead", "tottAccept", "tottConnect", "totiRead", "towAccept", "tatWrite", "tatReader", "TottGet", "totGet", "tottRead", "TottReading", "totoWrite", "TottReader", "tazonClose", "totiBuild", "tetReading", "octotRead", "TottFollow", "tottFollow", "TotConnect", "TotReader", "notWrite", "tntReader", "octotLength", "totoSearch", "totoLength", "tntWrite", "totaBuild", "tatRead", "tottLoad", "intottRead", "totalAccept", "tottReading", "totingRead", "totFollow", "TotWrite", "totDraw", "tntLoad", "TottWrite", "totalRead", "towWrite", "toyRead", "dottUse", "totSearch", "tetLoad", "tottUse", "tottedFollow", "nottRead", "TottRead", "dottReading", "dotReading", "tcotClose", "TottSearch", "totoReading", "tobyUse", "totLink", "TotReading", "totalLink", "towReading", "ntottWrite", "TotGet", "tottedGet", "tetWrite", "totBuild", "tochWrite", "totoFind", "totReader", "totingConnect", "towRead", "totingFollow", "dotRead", "dottReader", "TotaWrite", "intottClose", "tobyLoad", "toyWrite", "totoConnect", "intotBuild", "totAccept", "intotRead", "tazonBuild", "notAccept", "dotLoad", "toyLoad", "totWrite", " totBuild", "TottConnect", "towLoad", "tochLoad", "tazonRead", "TotRead", "TotaLoad", " totWrite", "totoLoad", "totaLoad", "totiLink", "tottWrite", "totClose", "octotoLength", "dotFind", "tetRead", "intotLoad", "octotReading", "ntotRead", "tottBuild", "totalBuild", "towLength", "tollWrite", "tochRead", "octotoReading", "intotClose", "totaDraw", "TotaDraw", "totLoad", "totaWrite", " totalWrite", "nottWrite", "tazonLoad", "tcotRead", "totaRead", "TotDraw", "totingWrite", "tottGet", "totUse", "ntotWrite", "totConnect", "intottLoad", "intottBuild", "totFind", "totiWrite", "dottWrite", "octotWrite", "tatLoad", "notRead", "tcotBuild", "nottAccept", "dotUse", "totReading", "totaReading", "dottRead", "TotFollow", " totLink"], "out": ["x", "connection", "bin", "ext", "socket", "s", "g", "sync", "p", "ex", "outs", "In", "conn", "b", "w", "output", "again", "part", "conf", "l", "r", "fn", "writer", "err", "plus", "o", "off", "client", "OUT", "d", "init", "inc", "t", "h", "exec", "parent", "v", "outer", "n", "io", "net", "c", "file", "up", "a", "exp", "ac", "Out", "obj"], "i": ["data", "current", "name", "ie", "me", "is", "bi", "b", "o", "d", "buffer", "source", "h", "xi", "uri", "io", "c", "gi", "length", "si", "it", "g", "m", "ori", "ind", "ix", "I", "u", "key", "abi", "init", "z", "yi", "mi", "ui", "li", "id", "ai", "start", "x", "ti", "my", "j", "info", "p", "one", "hi", "ei", "multi", "qi", "r", "fi", "e", "ini", "ci", "api", "ik", "oi", "zi", "ii", "ni", "iu", "eni", "phi", "ip", "ji", "y", "ri", "q", "slice", "pi", "k", "di", "l", "v", "index", "chi", "ic", "input"]}}
{"id1": "11377441", "id2": "1005108", "code1": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void googleImageSearch(String search, String start) {\n        try {\n            String u = \"http://images.google.com/images?q=\" + search + start;\n            if (u.contains(\" \")) {\n                u = u.replace(\" \", \"+\");\n            }\n            URL url = new URL(u);\n            HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();\n            httpcon.addRequestProperty(\"User-Agent\", \"Mozilla/4.76\");\n            BufferedReader readIn = new BufferedReader(new InputStreamReader(httpcon.getInputStream()));\n            googleImages.clear();\n            String text = \"\";\n            String lin = \"\";\n            while ((lin = readIn.readLine()) != null) {\n                text += lin;\n            }\n            readIn.close();\n            if (text.contains(\"\\n\")) {\n                text = text.replace(\"\\n\", \"\");\n            }\n            String[] array = text.split(\"\\\\Qhref=\\\"/imgres?imgurl=\\\\E\");\n            for (String s : array) {\n                if (s.startsWith(\"http://\") || s.startsWith(\"https://\") && s.contains(\"&amp;\")) {\n                    String s1 = s.substring(0, s.indexOf(\"&amp;\"));\n                    googleImages.add(s1);\n                }\n            }\n        } catch (Exception ex4) {\n            MusicBoxView.showErrorDialog(ex4);\n        }\n        MusicBoxView.jButton7.setEnabled(true);\n        ImageIcon icon;\n        try {\n            icon = new ImageIcon(new URL(googleImages.elementAt(MusicBoxView.googleImageLocation)));\n            ImageIcon ico = new ImageIcon(icon.getImage().getScaledInstance(100, 100, Image.SCALE_SMOOTH));\n            MusicBoxView.albumArtLabel.setIcon(ico);\n        } catch (MalformedURLException ex1) {\n            MusicBoxView.showErrorDialog(ex1);\n        }\n    }\n", "label": 0, "substitutes": {"resolvePlugins": ["resolvePluginplugins", "resolvingPlugings", "resolvePluginings", "resolvePluginin", "resolvePlugINS", "resolvingPlugplugins", "resolvePluginINS", "resolvingPluginplugins", "resolvingPlugin", "resolvePlugings", "resolveplugins", "resolvingPlugINS", "resolvingPluginins", "resolvingPluginings", "resolvePlugplugins", "resolveplugings", "resolvePluginins", "resolvingPluginINS", "resolveInstallins", "resolveplugplugins", "resolveInstallplugins", "resolveInstallin", "resolvingPluginin", "resolveInstallINS", "resolvingPlugins", "resolvePlugin", "resolveplugin"], "cacheDir": ["acheDirectory", "cacheFolder", " cacheFolder", "CacheFolder", "outputDIR", "CacheDir", "pluginDir", "cacheDirectory", "acheDIR", "outputDir", "CacheDIR", "pluginDIR", "CachePath", "baseFolder", "pluginFolder", "pluginPath", "outputPath", "baseDir", "acheFolder", "cachePath", "acheDir", "baseDirectory", "outputFolder", " cacheDirectory", "baseDIR", " cacheDIR", "cacheDIR"], "pluginsFile": ["driversUrl", "insfile", "resultsFILE", " pluginsFolder", "pluginDir", " pluginsDir", " pluginsFILE", "driversfile", "pluginsFILE", "resultsfile", "pluginFile", "pluginsUrl", "pluginFILE", "versionsFile", "driversFILE", "pluginFolder", "pluginsFolder", "resultsDir", "insDir", "resultsFile", "insFile", "driversFile", "versionsUrl", "pluginsfile", "versionsFILE", "pluginsDir", "pluginfile", "insFolder", " pluginsUrl", "versionsfile", " pluginsfile"], "pluginURL": ["pluginsUR", "PluginURL", "configUR", "plugUrl", "plugURL", "pluginsurl", "pluginsUrl", "pluginFile", "configURL", " pluginUrl", "configurl", "pluginCL", "pluginurl", "plugFile", "pluginUrl", "PluginUrl", "pluginsURL", "configUrl", "pluginUR", "pluginsCL", " pluginurl", "PluginCL", "PluginFile", "plugCL", " pluginUR"], "is": ["x", "ais", "Is", "iss", "cos", "ri", "s", "bs", "ins", "bos", "ori", "info", "has", "ics", "isa", "IS", "was", "ops", "ar", "its", "i", "ci", "api", "or", "ois", "bis", "ui", "vs", "ists", "uri", "ir", "io", "ps", "osi", "as", "in", "iso", "ris", "id", "iris", "ours", "opens", "ai", "out", "us", "ios", "ss", "ms", "lis", "ip", "fs"], "os": ["oS", "ais", "cos", "ot", "s", "oss", "bs", "oos", "bos", "ori", "ol", "oid", "ies", "obs", "oses", "o", "i", "OS", "mos", "Os", "bis", "oes", "ois", "io", "osi", "as", "otes", "iso", "aos", "ours", "ears", "ros", "es", "ss", "us", "ios", "los", "so", "nos", "dos"]}}
{"id1": "22441244", "id2": "4618237", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"send": ["open", "get", "create", "from", "set", "add", "text", "mail", "export", "address", "Send", "reply", "parse", "build", "submit", "exec", "delete", "transfer", "post", "message", "sent", "append", "execute", "write", "start", "end"], "hsession": ["HSessions", "openssession", "hsess", "opensessions", "hsSession", "hmession", "hhsession", "hhessions", "hession", "hsort", "hessions", "HSsession", "hmsession", "HSSession", "hsessions", "hhSession", "hessession", "hSession", "opensort", "hmSession", "hhess", "opensession", "hhort", "HSession", "opensSession", "hhession", "hssession", "hesort", "opensess", "hesession", "hmessions", "hesess"], "session": ["connection", "sl", "manager", "application", "state", "event", "class", "Session", "cache", "mail", "essions", "client", "proxy", "port", "project", "response", "parent", "context", "document", "server", "ession", "message", "chat", "resource", "host", "security", "site"], "repositoryName": ["repoositoryAddress", "repositoryFamily", "reposicleFamily", "repoositoryNAME", "repoitoryPath", "repositoryPath", "reposicleName", "repoitoryAddress", "reposessionNAME", "reposositoryNAME", "reposositoryPath", "reposicleAddress", "reposositoryName", "repoitoryEmail", "reposositoryFamily", "reposicationFamily", "reposicationName", "repoositoryName", "reposicationAddress", "reposositoryEmail", "repoitoryName", "repositoryAddress", "repoitoryFamily", "reposicleEmail", "reposessionName", "reposessionPath", "repositiveEmail", "repositoryNAME", "repositoryEmail", "repoositoryPath", "repositiveNAME", "reposositoryAddress", "reposicationEmail", "repoositoryFamily", "repositiveName", "reposessionEmail", "repoositoryEmail", "repoitoryNAME", "repositivePath"], "ideIdint": ["ideAuthints", "ideIdInt", "ideNameint", "ideidints", "IDEIdints", "ideIdints", "ideTimeInt", "ideAuthn", "ideidInt", "ideInn", "ideInint", "IDEidInt", "IDENameout", "IDEidint", "ideTimeout", "IDEIdInt", "ideIdout", "ideNameInt", "ideidn", "IDEIdout", "IDEidints", "IDENamenumber", "ideidint", "ideInfoout", "ideIdnumber", "IDENameint", "ideTimeint", "IDEIdn", "ideInfoint", "IDENameInt", "IDEIdnumber", "ideAuthint", "ideNameout", "ideInInt", "IDEIdint", "ideNamenumber", "ideAuthInt", "ideInints", "IDEidn", "ideInfonumber", "ideIdn", "ideTimenumber", "ideInfoInt"], "to": ["office", "name", "phone", "TO", "options", "from", "settings", "To", "top", "summary", "with", "mail", "by", "account", "client", "address", "reply", "sub", "source", "template", "mobile", "response", "tel", "uri", "title", "prefix", "message", "po", "token", "target", "about", "contact", "location", "company", "site"], "cc": ["cb", "cn", "phone", "nc", "card", "sc", "cca", "ca", "from", "ct", "ck", "ec", "rc", "cs", "lc", "cr", "account", "password", "client", "address", "dc", "comment", "ci", "uc", "cf", "CC", "cl", "code", "c", "ce", "tc", "contact", "company", "ac", "cus"], "bcc": ["abc", "pck", " bc", " brc", "fck", "bbrc", "pc", " bce", "bce", " bck", "pcc", "brc", "fcc", "bbck", "abcc", "bbc", "pce", "frc", "abce", "abck", "bck", "fc", "bc", "bbcc"], "subject": ["phone", "reason", "head", "method", "state", "format", "description", "mail", "content", "reply", "comment", "sub", "Subject", "template", "ject", "request", "response", "object", "filename", "uri", "author", "title", "prefix", "message", "header", "host", "username"], "body": ["connection", "lock", "data", "tree", "name", "reason", "how", "string", "plain", "base", "summary", "description", "part", "text", "inner", "wrapper", "content", "zip", "left", "line", "shell", "password", "normal", "secret", "comment", "style", "source", "template", "money", "response", "bound", "object", "foot", "url", "code", "view", "empty", "pass", "Body", "function", "message", "header", "resource", "length", "html", "media", "pod"], "attachments": ["embedings", "attachents", "messents", "embedment", "attachings", "Attachings", "embedments", "Attachents", "Attachments", "messment", "embedents", "Attachment", "messings", "messments"], "isHtml": ["isPhttp", "isChtml", "isPhhtml", " isChhtml", "isCtml", "isHive", " isHttp", " isWhail", "isWhtml", " isWhive", "isWhail", "isChhtml", " isWhhtml", "isCive", " isHail", "isCail", "isHhtml", "isChive", "isPhtml", " isWhtml", " isChail", "isHaail", "isWhive", "isChail", "isHattp", " isChtml", " isHhtml", "isHatml", "isHahtml", "isChttp", "isHail", "isWhhtml", " isHive", " isChttp", "isPhail", "isHttp"], "charset": ["charsET", "chaseset", "chasET", "chanset", "chaseting", "CharsET", "chasets", "chanspace", "chARSetting", "chearsete", "chansetter", "chearspace", "cheanset", "chansete", "chearsetter", "chARSET", "chARSeting", "Charseting", "charsetting", "chashesetter", "chARSets", "cheansET", "chackset", "charsetter", "chansetting", "chasheset", "chacksET", "chasetter", "Charsetting", "chaset", "cheansete", "chasetting", "cheansetter", "Charsets", "chacksetting", "chaseseting", "chaspace", "cheanspace", "chARSete", "Charset", "chearset", "charsets", "chearsET", "chashesET", "chansET", "cheansetting", "charsete", "charseting", "chARSet", "charspace", "chashespace", "chacksete", "chasesetting", "chearsetting", "chasesET"], "headers": ["mails", "options", "groups", "settings", " cookies", "status", "files", "content", "authors", "lines", "writers", " messages", "strings", " emails", " recipients", "classes", "comments", "names", "errors", "metadata", "params", "users", "header", "properties", "types", "ers"], "priority": ["phone", "reason", "language", "theme", "state", "mode", "status", "class", " title", "lang", "reply", "secret", "comment", "template", " severity", " recipients", "quote", "comments", "level", "code", "date", "author", "title", "prefix", "queue", "security", "length"], "email": ["office", "gmail", "ext", "data", "name", "oe", "ilo", "note", "create", "el", "auto", "em", "info", "install", "event", "en", "xml", "Email", "letter", "base", "ssl", "model", "text", "mail", "output", "online", "article", "entity", "zip", "line", "engine", "export", "account", "password", "e", "address", "external", "service", "fax", "test", "lex", "business", "template", "generic", "example", "response", "object", "url", "update", "enter", "document", "view", "server", "default", "core", "pm", "message", "contact", "result", "international", "print", "html", "liner", "element", "username"], "user": ["connection", "er", "profile", "data", "name", "type", "creator", "info", "ip", "me", "plugin", "model", "people", "account", "e", "member", "client", "User", "mobile", "object", "role", "character", "friend", "USER", "consumer", "author", "person", "id", "users", "uid", "resource", "token", "unknown", "string", "use", "username"], "identity": ["ethnicifier", "identication", "authorentity", "authority", "idITY", "ethnicity", "electricITY", "authoronymous", "authentonymous", "idifier", "authorities", "entityity", "IDENTity", "personITY", "idity", "personentity", "IdentITY", "authorication", "ethniciciary", "identiciary", "electriconymous", "ethnicITY", "installITY", "Identity", "IDENTities", "IDENTITY", "personity", "entityifier", "installonymous", "electricity", "authentITY", "publicity", "authentization", "authoriciary", "idization", "ethnicentity", "electricentity", "identonymous", "installentity", "authentication", "authentity", "idication", "publicITY", "entityonymous", "publicentity", "identization", "Identities", "Idententity", "IDENTentity", "entityization", "ethnicication", "identITY", "publiciciary", "authorifier", "idonymous", "authentifier", "idententity", "authorITY", "identifier", "identities", "installity", "personifier"], "_returnPath": ["_correctId", "_returnMid", "_resultPath", "_responseType", " _returnTo", " _backHalf", "_resultTo", "_returnHalf", " _returnUrl", "_resultHalf", "_displayPath", "_displayPart", "_backHalf", "_responsepath", "_backpath", "_displayUrl", "_inputMid", "_returnNode", "_returnPart", "_backName", "_returnText", "_inputPath", "_backType", "_returnDirectory", "_displayNode", "_successText", " _backTo", "_addType", "_backPath", "_backPart", " _backUrl", "_relationPath", "_backUrl", "_successId", "_resultName", "_returnTo", "_addPath", "_correctText", "_successPath", "_replyUrl", " _backPath", "_relationId", " _backPart", "_returnType", " _backName", "_replyMid", "_returnId", "_replyNode", "_correctPath", "_returnUrl", "_inputUrl", "_backTo", "_returnpath", "_relationDirectory", "_successDirectory", "_replyPart", "_addpath", "_correctDirectory", " _returnHalf", "_replyPath", "_displayMid", "_relationText", " _returnName", "_responsePath", "_returnName", "_inputNode", " _returnPart"], "_from": ["_for", "placeowner", "workwho", "worksource", "blockFrom", "_From", "_with", "blockerror", " _error", " _source", "workfrom", "blockto", " _owner", "existingto", "_source", "_who", "existingfrom", "_error", "blockfrom", "_owner", " _for", " _with", "existingowner", "placefrom", "workto", " _who", "placefor", " _From", "placeto", "existingfor"], "_replyTo": ["_replyFrom", "_returnUrl", "_respondTo", "_returnTo", "_respondTO", "_returnOf", " _returnTo", "_addFrom", "_reasonUrl", " _replyTO", "_closeTO", "_replyUrl", " _returnTO", "_reasonTo", "_replyTO", "_addAddress", "_commentOf", " _replyFrom", "_reasonTO", "_respondAddress", "_commentFrom", "_respondFrom", "_commentTO", "_replyAddress", "_commentTo", "_respondPoint", " _returnFrom", "_replyPoint", "_replyOf", " _replyUrl", "_returnAddress", " _returnUrl", "_returnPoint", "_addTo", "_respondUrl", "_returnFrom", "_addPoint", "_returnTO", "_closeTo", "_reasonFrom", "_closeOf", "_closeFrom"], "_to": [" _target", "_target", " _about", "Jfrom", "Jabout", "Jtarget", "_about", "Jto"], "_cc": [" _cd", " _ce", " _cf", "_cd", "_ce", "_cf"], "_bcc": [" _abc", " _bce", "_rbcs", " _bcs", "_abce", "_rbc", "_sbcs", "_sbc", " _bc", " _abcs", "_abcs", "_sbcc", "_abc", "_rbce", "_bce", "_bcs", "_rbcc", " _abce", "_sbce", "_bc", "_abcc", " _abcc"]}}
{"id1": "22338097", "id2": "6987642", "code1": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "code2": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"createMD5": ["createmd512", " createSHA2", "createMD2", "createmd256", " createMD2", "createSHA256", " createMD512", "createSHA512", " createSHA256", "createMAC256", "createmd5", " createSHA5", " createSHA512", "createMAC2", "createmd2", "createMD512", " createMD256", "createMAC5", "createMAC512", "createMD256", "createSHA5", "createSHA2"], "pwd": ["cWD", "hwm", "cpassword", " pWD", "Ppassword", "hw", "hwd", "cwd", "hWD", "Pwd", "pwm", "ppassword", "pw", "Pw", "pWD", " pw", "PWD", " pwm", "Pwm", "cw", " ppassword"], "md": ["meta", "df", "bd", "vd", "mag", "mg", "cd", "rm", "wd", "dd", "m", "py", " MD", "mt", "ind", "dig", "di", "mb", "am", "mac", "hm", "cmd", "dm", "um", "d", "MD", "gd", "mo", "mod", "amd", "mp", "metadata", "mm", "pm", "po", "cm", "bf", "mc", "mand", "ad", "hd", "mk", "od", "de", "tmp", "pkg"], "pd": ["PD", "bd", "vd", "pat", "lp", "cd", "sd", "tp", "ds", "dl", "wd", "dd", "py", "p", "pi", "da", "wp", "pc", "ld", "sv", "ppa", "td", "pp", "std", "d", "pins", "gd", "dp", "pid", "ps", "pe", "ppo", "ped", "pm", "np", "fd", "po", "xd", "od", "hd", "cp", "pg", "pb"], "app": ["msg", "keep", "data", "fac", "App", "container", "s", "g", "arr", "py", "allow", "array", "ang", "aa", "p", "buff", "cap", "application", "ip", "bb", "html", "page", "cache", "b", "instance", "conf", "mac", "apps", "acc", "cell", "pp", "test", "buffer", "cmp", "sp", "APP", "db", "pack", "api", "ch", "ap", "ask", "ape", "form", "mp", "ab", "ce", "amp", "sb", "append", "host", "pad", "ac", "string", "fb", "bc", "apply"], "i": ["x", "ji", "f", "data", "si", "ti", "ri", "s", "slice", "p", "j", "info", "pi", "ori", "ix", "hi", "I", "bi", "u", "b", "multi", "di", "inner", "qi", "l", "fi", "e", "o", "key", "uli", "ini", "abi", "d", "ci", "z", "t", "xi", "v", "oi", "ui", "n", "li", "zi", "uri", "ii", "io", "c", "ni", "id", "index", "chi", "mu", "ai", "gi", "ip", "end"], "s2": ["s3", "pass12", "s182", "sl2", "palt", "stwo", " s3", "p1", "ses6", " s12", "pass2", "s1", "ds6", "s6", "s12", "sl1", "ds2", "p2", "pass1", "passtwo", "p3", "p182", "p12", "salt", " s1", "sl182", "ptwo", " s6", "ses2", " s182", " stwo", " salt", "sestwo", "dstwo"]}}
{"id1": "1362", "id2": "5951961", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubblerCompare", "bubblesOrder", "bubblerOrder", "ubbleSort", "ubbleOrder", "bubblerSort", "ubblingOrder", "ubblesort", "ubblingsort", "ubblingSort", "ubblingCompare", "bubblesort", "bubbleOrder", "bubblessort", "bubblesCompare", "bubblingCompare", "bubblingSort", "bubblersort", "bubblesSort", "bubblingsort", "ubbleCompare", "bubblingOrder", "bubbleCompare"], "a": ["active", "f", "data", "sup", "oa", "at", "something", "s", "ack", "m", "aa", "aaa", "ma", "array", "p", "aux", "auto", "na", "any", "ae", "another", "ama", "ans", "u", "abs", "b", "all", "am", "A", "img", "access", "apps", "aj", "l", "work", "e", "o", "la", "va", "address", "d", "list", "ata", "ba", "empty", "aw", "sa", "an", "ab", "as", "c", "ga", "index", "result", "tta", "ad", "area", "alpha", "ac", "au"], "swapped": ["swoped", "Swoped", " swaped", "wap", "swap", "flapped", "Swaped", "Swap", "wapping", "swaps", " swapping", "rewaps", " swap", "waped", "Swapping", "swapping", " swaps", "rewaped", "rewapping", "swaped", "flap", "floped", "rewapped", "waps", "rewap", "flapping", "Swapped", "rewoped", "wapped"], "i": ["x", "f", "y", "sup", "si", "it", "start", "ti", "ri", "mini", "iv", "m", "p", "j", "info", "pi", "k", "ori", "ind", "ie", "ix", "hi", "I", "bi", "u", "b", "ami", "di", "multi", "qi", "l", "fi", "e", "key", "ini", "d", "anti", "ci", "init", "api", "h", "ki", "xi", "v", "mi", "ui", "oi", "next", "li", "uri", "ii", "io", "in", "ni", "id", "index", "iu", "module", "eni", "ai", "gi", "adi", "uni", "ip"], "tmp": ["x", "f", "sup", "opp", "stuff", "addr", "qq", "m", "emp", "st", "p", "j", "ie", "tv", "bb", "prev", "part", "b", "yy", " ff", "alpha", "txt", "front", "pre", "angle", "dest", "pp", "temp", "test", "xxx", "cmp", "vt", "mmm", "t", "tt", "v", "mp", "amp", "tc", "kk", "append", "pad", "area", "foo", "obj", "nb"]}}
{"id1": "5274228", "id2": "659316", "code1": "    public String put(String resourceID, Map<String, String> headersMap) {\n        HttpClient httpClient = new DefaultHttpClient();\n        httpClient.getParams().setParameter(\"http.useragent\", \"sla@soi OCCI Client v0.2\");\n        HttpPut httpPut = new HttpPut(resourceID);\n        List<Header> headersList = this.convert2Headers(headersMap);\n        for (Iterator<Header> iterator = headersList.iterator(); iterator.hasNext(); ) {\n            httpPut.addHeader(iterator.next());\n        }\n        logger.info(httpPut.getRequestLine());\n        logger.info(httpPut.getAllHeaders());\n        Header[] headersArray = httpPut.getAllHeaders();\n        String[] fields = { Response.Location };\n        HashMap<String, String> occiHeaders = new HashMap<String, String>();\n        for (int H = 0; H < headersArray.length; H++) {\n            Header header = headersArray[H];\n            logger.info(\"header - request  -\" + header.toString());\n            logger.info(\"\theaderName - \" + header.getName());\n            logger.info(\"\theaderValue - \" + header.getValue());\n        }\n        String statusLine = null;\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpPut);\n            statusLine = httpResponse.getStatusLine().toString();\n            int statusCode = httpResponse.getStatusLine().getStatusCode();\n            logger.info(\"----------------------------------------\");\n            logger.info(\"StatusLine - (full) - \" + httpResponse.getStatusLine());\n            logger.info(\"\tStatusCode - \" + statusCode);\n            logger.info(\"\tReason - \" + httpResponse.getStatusLine().getReasonPhrase());\n            logger.info(\"\tProtocol - \" + httpResponse.getStatusLine().getProtocolVersion().toString());\n            logger.info(\"----------------------------------------\");\n            if (StatusCode.validate(statusCode)) {\n                logger.info(\"Response Validated\");\n            } else {\n                logger.error(\"Response NOT Validated\");\n                return null;\n            }\n            Header[] headers = httpResponse.getAllHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                Header header = headers[i];\n                logger.info(\"header - response - \" + header.toString());\n                logger.info(\"\theaderName - \" + header.getName());\n                logger.info(\"\theaderValue - \" + header.getValue());\n                for (int h = 0; h < fields.length; h++) {\n                    logger.info(\"\tLooking for  - \" + fields[h]);\n                    if (fields[h].equals(header.getName().toString())) {\n                        logger.info(\"\tFound an OCCI Header - \" + header.getName());\n                        occiHeaders.put(header.getName(), header.getValue());\n                    }\n                }\n            }\n        } catch (org.apache.http.conn.HttpHostConnectException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } finally {\n            httpClient.getConnectionManager().shutdown();\n        }\n        logger.info(\"occiHeaders - \" + occiHeaders);\n        if (occiHeaders.containsKey(Response.Location)) {\n            logger.info(\"Valid Provision\" + statusLine);\n            return occiHeaders.get(Response.Location).toString().replaceAll(Response.jobs, \"\");\n        }\n        logger.info(\"NOT a Valid Provision - \" + statusLine);\n        return statusLine;\n    }\n", "code2": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "label": 0, "substitutes": {"put": ["data", "get", "create", "operation", "st", "PUT", "add", "format", "cache", "output", "UT", "patch", "client", "pull", "parse", "build", "submit", "Put", "update", "transfer", "post", "file", "transform", "resource", "replace", "string", "write"], "resourceID": ["objectIDs", "resourceURL", "resourceid", "serviceIDs", "resourceId", "ResourceIDs", "ResourceURL", "resourceKey", "serviceID", "serviceId", "objectId", "serviceid", "requestKey", "objectID", "ResourceId", "Resourceid", "responseKey", "responseURL", "requestURL", "ResourceKey", "resourceIDs", "requestID", "objectid", "ResourceID", "responseID", "requestId", "responseId"], "headersMap": ["headerArray", "headerSet", " headersFile", "ersArray", "headerMap", "headerFile", "headersFile", "httpList", "httpArray", "httpSet", "ersFile", "headersSet", " headersSet", "headerList", "ersList", "httpMap", "ersMap"], "httpClient": ["phpPut", "httpsBase", "httpsContext", "httpBase", "httpContext", "phpCall", "ttpBase", "phpClient", "httpsPut", "HttpCase", " httpBase", "HttpPut", "HttpServer", "HttpCall", "httpServer", "ttpClient", " httpContext", "HttpClient", "httpsServer", "HttpContext", " httpConnection", "httpCase", " httpCase", "ttpPut", "httpsConnection", " httpCall", "ttpConnection", "httpCall", "phpCase", "httpsClient", " httpServer", "httpConnection"], "httpPut": ["webPUT", "phpPut", "httpPush", "httpsput", "viewPush", "internalGet", "webGet", "phpPush", "httpsDo", " httpPUT", "HttpGet", "viewput", "httpsPut", "httpPUT", "viewPut", "phpSplit", "phpAdd", "httpDo", "HttpPut", "phpGet", "webPut", "HttpDo", "httpsPUT", "Httpput", " httpDo", "httpsGet", "HttpClient", "HttpPUT", "httpsAdd", "httpsPush", "httpWrite", "httpGet", " httpPush", "httpsSplit", "httpSplit", "phpWrite", "viewPUT", "internalPush", "httpput", " httpGet", "httpAdd", "internalPut", "httpsClient", "webPush", " httpSplit", "internalWrite", " httpAdd", " httpWrite", "HttpPush"], "headersList": ["headerArray", "headerSet", "driversL", "ersArray", "headerL", "headerMap", "driversMap", "headersL", "headersSet", "driversArray", " headersSet", "ersL", "headerList", "driversList", "ersList", "ersSet", " headersL"], "iterator": ["reader", "iter", "sequence", "division", "ator", "gener", "vector", "basic", "handler", "later", "slice", "started", "creator", "stream", "set", "adder", "ie", "loop", "walker", "loader", "former", "size", "inner", "multi", "done", "instance", "engine", "writer", "collection", "parser", "random", "ter", "pointer", "step", "interstitial", "entry", "init", "starter", "driver", "oper", "outer", "kick", "next", "li", "finder", "Iterator", "Iter", "operator", "eni", "inter", "append", "processor", "start", "end", "runner", "ski"], "headersArray": [" headersAr", "hersList", "headsArray", "headsList", "ersArray", "headsLength", "ersAr", "filesMap", "headersAr", "headersHash", "filesHash", "filesArray", "hersArray", " headersHash", "hersLength", "hersAr", "headsAr", "filesAr", " headersLength", "headersLength", "ersHash", "ersMap"], "fields": ["region", "values", "data", "rows", "body", "FIELD", "field", "codes", "format", "Field", "files", "content", "zip", "lines", "dates", "pattern", "comments", "errors", "details", "keys", "params", "prefix", "dir", "properties", "types", "json"], "occiHeaders": ["ocsiHeaderers", "ocsiBufflers", "occiHoster", "ocsiBuffer", "ocsiHeadlers", "occiBufferers", "occiBuffers", "occiHostlers", "occiBuilders", "ocsiBuffers", "occiBuffer", "ocsiHeaders", "occiHosterers", "occiBufflers", "occiHeadlers", "occiBuilderers", "occiBuilder", "occiHeaderers", "occiHosters", "occiHeader", "occiBuildlers", "ocsiBufferers", "ocsiHeader"], "H": ["rh", "HT", "SH", "HC", "HH", "HR", "TH", "R", "D", "Length", "V", "C", "Handler", "HI", "HS", "Q", "EH", "OH", "DH", "MH", "I", "B", "U", "HE", "F", "M", "X", "L", "K", "Index", "S", "Head", "J", "G", "NH", "Header", "T", "N", "HTTP", "ID", "CH", "P", "HB", "W", "Hop", "HM", "Y"], "header": ["feature", "reader", "ker", "extra", "er", "f", " request", "manager", "later", "handler", "head", "layer", "info", "event", "definition", "detail", "per", "rule", "inner", "former", "bridge", "her", "writer", "key", "ter", "dr", "back", "row", "comment", "ler", "entry", "block", "buffer", "player", "value", "service", "builder", "request", "response", "outer", "driver", "second", "Header", "document", "consumer", "server", "http", "metadata", "file", "holder", "cher", "message", "frame", "cover", "result", "token", "string", "liner"], "statusLine": [" statusText", " statusBody", "responseCode", "statusBody", "errorCode", "StatusText", "statusFile", "responseLine", "errorString", "responseText", "StatusCode", "errorLine", "StatusLine", "statusText", "StatusBody", "StatusFile", " statusString", "StatusString", "statusString", "errorBody", "responseFile", " statusFile"], "httpResponse": ["httpsRequest", " httpBlock", "Httpresponse", "ttpRequest", "templateResp", "HttpRequest", "HttpPage", "httpsPage", "HttpLine", " httpBody", "httpLine", " httpStatus", "httpPage", "ttpResult", "statusBlock", "actualLine", "httpBody", " httpEnvironment", "statusBody", "statusResponse", "httpsEnvironment", "templateStatus", " httpResult", "httpRequest", "httpEnvironment", "statusResult", "httpsResponse", "httpsBody", "httpresponse", "actualRequest", "actualResponse", " httpRequest", "HttpResult", "httpResp", " httpLine", " httpresponse", "httpBlock", "httpsResult", "templateLine", " httpPage", "templateResponse", "HttpResp", "HttpResponse", " httpResp", "HttpStatus", "httpResult", "actualresponse", "ttpResp", "HttpBlock", "HttpEnvironment", "HttpBody", "ttpResponse", "httpStatus"], "statusCode": ["resultCode", "statusCount", "resultcode", "statusType", "statuscode", "responseCode", "errorCode", " statuscode", "StatusText", "errorType", "responseLine", " StatusData", "StatusData", "responseText", "StatusCode", "errorLine", "StatusLine", "resultLine", "statusText", "statusData", " StatusType", "StatusCount", " statusData", " StatusCode", "resultCount", " statusCount", " StatusLine", "Statuscode", "errorText", "responseType", "StatusType", " statusType"]}}
{"id1": "20623709", "id2": "3375718", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "label": 0, "substitutes": {"split": ["open", "archive", "sync", "sort", "set", "match", "add", "copy", "format", "part", "share", "cmp", "parse", "build", "init", "run", "process", "exec", "Split", "delete", "update", "transfer", "diff", "join", "append", "execute", "start"], "targetDirectory": ["targetRoot", "targetFile", " targetRoot", " targetFolder", "destDir", "masterDir", "baseFile", "outputFile", "currentRoot", " targetFile", "targetDatabase", "masterDatabase", "TargetDir", "targetDir", "outputDir", "currentFolder", " targetPath", "basePath", "baseDatabase", "currentPath", "masterDirectory", "TargetDirectory", "TargetDatabase", "baseFolder", "TargetRoot", "baseDir", "TargetFolder", "targetPath", "destFile", " targetDir", "TargetPath", "destFolder", "masterPath", "TargetFile", "baseDirectory", "currentDir", "outputFolder", "currentDirectory", "outputDirectory", "destDirectory", "targetFolder"], "prefix": ["offset", "FIX", "sequence", "fixed", "name", "type", "first", " suffix", "timeout", "base", "ix", "prot", "format", "resolution", "cache", "Pref", "domain", "txt", "pre", "root", "patch", "temp", "padding", "template", "path", "filename", "pattern", "config", "number", "uri", "unit", "folder", "fix", "index", "resource", "queue", "append", "fp", "directory", "string", "username"], "maxUnitBases": ["maxUnitAliases", "maxUnitEaches", "maxunitBails", "maxunitBaches", "maxUnitChasing", "maxUnitChase", "maxUnitQueasing", "maxUnitAliails", "maxunitAliasing", "maxunitAliues", "maxUnitAliase", "maxunitAliaches", "maxunitAliase", "maxUnitQueues", "maxUnitEails", "maxUnitPlases", "maxUnitEase", "maxunitBues", "maxUnitQueases", "maxUnitPlaches", "maxUnitPlails", "maxUnitQuease", "maxUnitChases", "maxUnitBaches", "maxUnitAliaches", "maxUnitPlase", "maxUnitEases", "maxunitAliails", "maxUnitChues", "maxUnitBues", "maxUnitAliues", "maxUnitBasing", "maxunitBases", "maxunitBase", "maxunitBasing", "maxUnitBails", "maxunitAliases", "maxUnitBase", "maxUnitAliasing"], "maxUnitEntries": ["maxUnitIntrys", "maxUnitOrdries", "maxUnitEntryies", "maxUnitOrdry", "maxUnitAddry", "maxUnitCountrations", "maxUnitOrdies", "maxUnitEntryresses", "maxUnitEntines", "maxUnitCountry", "maxUnitEntrys", "maxunitEntryrys", "maxLineEntries", "maxLineOrdrations", "maxUnitEntures", "maxunitEntries", "maxunitEnties", "maxUnitEntry", "maxUnitAddresses", "maxLineOrdry", "maxUnitIntries", "maxUnitIntresses", "maxUnitAddries", "maxUnitEnties", "maxunitEntryies", "maxUnitEntrations", "maxUnitEntresses", "maxUnitEntryures", "maxUnitErry", "maxLineEntrations", "maxUnitOrdresses", "maxunitEntryresses", "maxLineOrdines", "maxUnitCountines", "maxUnitEntryrys", "maxunitEntrys", "maxUnitCountries", "maxUnitOrdrys", "maxUnitAddures", "maxLineOrdries", "maxUnitOrdrations", "maxUnitErries", "maxLineEntry", "maxUnitInties", "maxLineEntines", "maxUnitOrdines", "maxUnitEntryries", "maxUnitErines", "maxUnitEntryry", "maxUnitErrations", "maxunitEntryries", "maxunitEntresses"], "fis": [" fai", "fiss", "forisc", " fris", "fisa", " fisa", "foriss", "fai", "forris", "forai", "forIs", "fIs", "vis", " fIs", "Fis", "vIs", "forisa", " fisc", "vai", "Fiss", "visa", " fiss", "foris", "fris", "Fris", "Fisc", "fisc"], "fci": ["Fco", "Fci", "efci", "bai", " fai", "fii", "vci", "hco", "Foci", "fai", "bci", "foci", "hai", " fii", "Fis", "efai", "hci", "Fai", "vai", "fcos", "dci", "bis", "dii", "hcos", "efco", "efcos", "bco", "Fii", "vcos", "vco", "dco", "doci", " foci"], "fos": ["fscos", "ifios", " fcos", "ifo", "fsos", "fsios", "fso", "ifos", "Foes", "foes", "infoss", "toes", "Fis", "infoes", "infos", "fcos", "Foss", "foss", "tis", "tos", "toss", "fios", "Fos", " fo", " fios", "fo", "infis", "ifcos"], "fco": ["Fco", "Fci", "dcos", "hco", "fbo", " fcos", "hgo", "fgo", "fileico", " fico", "lci", "lro", "fileci", "lcos", "fro", "hci", " fbo", "Fico", "fcos", "dci", "fico", "hcos", "lgo", "dro", "Fbo", "filebo", "dco", "fileco", "lco", " fgo", " fro"], "buffer": ["offset", "bin", "border", "reader", "uffer", "iter", "data", "texture", "scale", "channel", "batch", "reference", "layer", "buff", "info", "Buffer", "timeout", "zero", "counter", "binary", "base", "expression", "position", "copy", "cache", "loader", "size", "callback", "writer", "capacity", "translation", "flush", "bar", "entry", "block", "comment", "image", "feed", "source", "request", "response", "context", "transfer", "document", "server", "pause", "view", "null", "rate", "read", "memory", "message", "queue", "resource", "header", "result", "pad", "length", "window", "input", "bc", "device", "buf"], "currentBasesCount": ["currentBatchesNum", "currentChasesCounter", "currentChaseNum", "currentBasesNum", "currentChaseCounter", "currentBaseCounter", "currentChaseCount", "currentChasecount", "currentBasescount", "currentChasesCount", "currentBatchescount", "currentBasingCount", "currentBasingcount", "currentBaseNum", "currentBaseCount", "currentBasingCounter", "currentBatchesCount", "currentBatchesCounter", "currentBasingNum", "currentChasesNum", "currentBasecount", "currentBasesCounter", "currentChasescount"], "currentEntriesCount": ["currentEntursSize", "currentAddriesCount", "currentEntursCount", "currentEntriesSize", "currentAdduresSize", "currentAdduresLimit", "currentEntrasCount", "currentAdduresOffset", "currentAdduresCount", "currentEnturesCount", "currentAddriesSize", "currentEntriesOffset", "currentEntrasSize", "currentEnturesLimit", "currentEntrasLimit", "currentEntursLimit", "currentEntrasOffset", "currentAddriesOffset", "currentEnturesSize", "currentEntriesLimit", "currentAddriesLimit", "currentEntursOffset", "currentEnturesOffset"], "targetCount": ["TargetSum", "argetSize", "patterncount", "patternSize", "argetcount", "TargetSize", "targetcount", "targetSize", "argetSum", "patternCount", "argetCount", "TargetCount", "targetSum", "patternSum", "Targetcount"], "fastaChannel": ["fastasColumn", "fastanContainer", "fastaqColumn", "fastaqConnection", "fastaContext", " fastABuffer", " fastaContainer", " fastaConnection", "fastAConnection", " fastaContext", "fastaqChannel", "fastAContext", "fastasContext", "fastasConnection", "fastaContainer", "fastABuffer", "fastanBuffer", " fastAColumn", "fastasBuffer", " fastAContainer", "fastanContext", "fastAContainer", "fastaqBuffer", " fastAChannel", " fastAContext", "fastAColumn", "fastaConnection", "fastaColumn", "fastAChannel", "fastanChannel", "fastasContainer", " fastAConnection", " fastaColumn", "fastasChannel"], "totalSeqCount": ["totalSeqCounter", "totalQueqcount", "totalSeQCount", "totalQueQcount", "totalSeqcount", "totalSeqsCounter", "totalSeQcount", "totalSeqsCount", "totalSeuxcount", "totalQueQCount", "totalSeqscount", "totalSeuxCount", "totalSeqNum", "totalQueQNum", "totalSeQCounter", "totalSeuxNum", "totalSeuxCounter", "totalQueqCount", "totalQueqNum", "totalQueqCounter", "totalSeQNum", "totalQueQCounter", "totalSeqsNum"], "totalResiduesCount": ["totalResiduingSize", "totalResiduationcount", "totalResiduesNum", "totalResiduingNum", "totalResiduresSize", "totalResiduresCount", "totalResiduationSize", "totalResiduingcount", "totalResiduingCount", "totalResqueurescount", "totalResqueuresCount", "totalResqueuesCount", "totalResqueuescount", "totalResiduescount", "totalResiduationCount", "totalResqueuesSize", "totalResiduesSize", "totalResiduationNum", "totalResidurescount", "totalResiduresNum", "totalResqueuresNum", "totalResqueuesNum", "totalResqueuresSize"], "prevTime": ["PrevFile", " prevFile", "prevFile", " prevValue", " prevSize", "PrevValue", "commitTime", "PrevSize", "PrevTime", "prevSize", "commitFile", "commitSize", "commitValue", "prevValue"], "fastaFileSize": ["fastasFileName", "fastAFileCount", "fastaPageName", "fastaLineLength", "fastaPageAddress", "fastaFilesSize", "fastaBufferCount", "fastaFilesAddress", "fastABufferSize", "fastAFileAddress", "fastaHeaderAddress", "fastABufferCount", "fastaLineCount", "fastaBlockLength", "fastasFileSize", "fastaPageSize", "fastasHeaderSize", "fastasFileAddress", "fastaHeaderSize", "fastABufferAddress", "fastaFileAddress", "fastaFileName", "fastaFileCount", "fastasHeaderLength", "fastaBlockSize", "fastaFilesLength", "fastaFileLength", "fastaHeaderName", "fastaBlockAddress", "fastaBufferAddress", "fastaPageLength", "fastABufferLength", "fastaBufferSize", "fastaLineAddress", "fastasFileLength", "fastaHeaderLength", "fastasHeaderAddress", "fastaLineSize", "fastAFileSize", "fastaBlockCount", "fastAFileLength", "fastaFilesName", "fastasHeaderName", "fastaBufferLength"], "fastaFileReadOffset": ["fastaFileWriteOff", "fastaFileWriteoffset", "fastaBufferReadAmount", "fastaDirectoryWriteOff", "fastaFileLoadLength", "fastaFileRunoffset", "fastaFilesReadoffset", "fastaFilereadOff", "fastaFilesWriteOffset", "fastaFilereadoffset", "fastaBufferWriteOffset", "fastaFilereadOffset", "fastaBufferWriteoffset", "fastaFileStartOff", "fastaBufferReadoffset", "fastaFileLengthoffset", "fastaFileReadAmount", "fastaFileLoadOffset", "fastaDirectoryWriteOffset", "fastaFileRunEntry", "fastaDirectoryReadOff", "fastaFilesReadOff", "fastaDirectoryReadOffset", "fastaFilereadLength", "fastaFileReadoffset", "fastaFileRunOff", "fastaFileReadEntry", "fastaFilesReadOffset", "fastaFileStartoffset", "fastaFilesWriteoffset", "fastaFileReadOff", "fastaDirectoryReadEntry", "fastaFileWriteOffset", "fastaFilesWriteOff", "fastaDirectoryWriteoffset", "fastaDirectoryReadoffset", "fastaFileWriteEntry", "fastaFileRunOffset", "fastaFileLoadoffset", "fastaFileLengthOffset", "fastaDirectoryWriteEntry", "fastaBufferReadLength", "fastaFileLengthAmount", "fastaFileWriteAmount", "fastaFileStartOffset", "fastaFileStartEntry", "fastaFileReadLength", "fastaFilesWriteLength", "fastaBufferReadOffset", "fastaFileWriteLength", "fastaFileLengthOff", "fastaBufferWriteAmount", "fastaFileLoadAmount", "fastaBufferWriteLength", "fastaFilesReadLength", "fastaFileLengthLength"], "partitionStartOffset": ["partitionStopOrder", "partitionBufferOffset", "partitionStartOff", "partitionStopOffset", "partitionEndOff", "partitionsEndOffset", "partitionBufferOrder", "partitionBufferRange", "partitionEndOrder", "partitionsStartOff", "partitionsStartOrder", "partitionStartOrder", "partitionsStartRange", "partitionEndRange", "partitionsEndRange", "partitionsEndOrder", "partitionsEndOff", "partitionStopOff", "partitionBufferOff", "partitionStartRange", "partitionStopRange", "partitionsStartOffset"], "bufferSize": ["processSize", "processSIZE", "bufferCount", " bufferCount", " bufferSIZE", "BufferC", " bufferType", "processType", " bufferC", "BufferSize", "BufferCount", "queueCount", "bufferType", "bufferC", "BufferType", "queueSize", "bufferSIZE", "processC", "BufferSIZE"], "fastaBuffer": ["fastaceBuffer", "fastanContainer", " fastasContainer", "fastAFile", " fastasFile", "fastaQueue", "fastanFile", "fastacePtr", "fastaPtr", "fastasBuff", "FastasBuff", "FastasPtr", "fastaaStream", " fastABuffer", " fastaContainer", " fastAFile", "fastasFile", "FastaStream", "fastaStream", "FastasBuffer", "fastaaBuffer", "FastaChannel", " fastaFile", "fastaContainer", " fastasBuffer", "fastaFile", "fastanBuffer", " fastasChannel", "FastaBuffer", "fastanBuff", "fastaaPtr", "fastasBuffer", "FastasStream", "fastaceBuff", "fastaaBuff", "fastasQueue", "fastaBuff", "fastAContainer", " fastAChannel", "fastaceChannel", "fastanQueue", " fastaQueue", "fastAQueue", "fastasStream", " fastAQueue", "fastABuff", " fastaBuff", "FastaPtr", "FastaBuff", "fastanPtr", "fastAChannel", "fastanChannel", "fastasContainer", "fastasPtr", "fastanStream", "fastAPtr", "FastasChannel", " fastABuff", "fastABuffer", "fastasChannel"], "fastaReadState": ["fastaReadingMode", "fastaReadstate", "fastaReadType", "fastaReaderstate", "fastaFileState", "fastaReadingState", "fastaFileMode", "fastaReaderMode", "fastaFilestate", "fastaFileType", "fastasReadState", "fastaReadingstate", "fastaReaderType", "fastaReaderState", "fastaReadingType", "fastasReaderState", "fastasReaderMode", "fastasReaderstate", "fastasReadType", "fastaReadMode", "fastasReadstate", "fastasReadMode", "fastasReaderType"], "nBytes": ["oParts", "lenFrames", "NBytes", "pByte", " nByte", "oBytes", "lenBytes", "pBytes", "NByte", "pbytes", " nbytes", "obytes", "numBytes", "numbytes", "oFiles", "pParts", "nFiles", " nFrames", "numFiles", "lenFiles", "numFrames", "nbytes", "Nbytes", "nFrames", " nParts", "nParts", "NParts", "NFiles", "nByte", " nFiles", "lenbytes"]}}
{"id1": "21754659", "id2": "11484416", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "label": 1, "substitutes": {"getButtonSonido": ["getbuttonSenico", "getButtonJonendo", "getbuttonSonido", "getbuttonSonira", "getbuttonSenira", "getButtonSonico", "getButtonSonendo", "getButtonSonira", "getButtonSenira", "getButtonJonira", "getButtonSenendo", "getbuttonSenendo", "getButtonSenico", "getbuttonSenido", "getbuttonSonico", "getButtonJonido", "getButtonJonico", "getbuttonSonendo", "getButtonSenido"], "buttonSonido": ["ButtonSonado", "buttonDonido", "buttonTanado", "btnSonigo", "buttonSenini", "btnDonido", "ButtonSonido", "buttonsonado", " buttonSonida", " buttonSonardo", "buttonSonado", "buttonsonigo", "buttonSenino", " buttonSenino", "buttonTanido", " buttonSonino", "buttonDonida", "buttonDonigo", "buttonHomardo", "buttonSonini", "buttonDonardo", "btnSonardo", "ButtonSonini", "buttonSenardo", "btnDonado", " buttonSenida", "ButtonSonida", "ButtonDonido", "ButtonDonardo", " buttonSonado", "ButtonSonardo", "buttonHomida", "buttonDonino", "buttonsonido", "buttonHonino", " buttonSenido", "buttonSenido", "buttonSenado", "buttonDonini", "btnDonigo", "buttonHomido", "btnSonini", "buttonTanardo", "buttonHomado", "buttonSonida", "ButtonDonado", "buttonSonardo", "buttonHonardo", "buttonHonado", "buttonSonigo", "ButtonDonini", " buttonSenardo", "buttonHonido", "btnSonado", "buttonSenigo", "buttonSenida", "btnSonido", "buttonDonado", "ButtonDonida", "buttonsonardo", " buttonSenado", "buttonSonino", "buttonsonini", "buttonTanida", "btnDonardo"], "e": [" ev", " exp", " pe", " Event", "event", " te", " E", " exc", " ignored", " other", " cause", "E", " je", " ace", "t", "Event", " ie", " exception", " en", " inst", "ed", " caught", " ate", " fe", " events", "ee", " invoked"], "fc": ["LC", "f", "WF", "wt", "fl", "nc", "fw", "FS", "ct", "irc", "wic", "FC", "enc", "fe", "ec", "pc", "xf", "fed", " FC", "lc", "isc", "GF", "roc", "wk", "F", "fn", "fi", "WC", "fr", "lf", "PF", "bc", "Factory", "CF", "dc", "fx", "DC", "cf", "xc", "c", "fa", "af", "fd", "FE", "tc", "flo", "bf", "con", "mc", "fp", "fm", "fb", "fs", "il"], "returnVal": ["ReturnNum", "returnval", "continueVal", "continueValue", "continueval", " returnVAL", "returnNum", " returnval", "returnValue", "continueNum", "ReturnValue", " returnValue", " returnNum", "Returnval", "backVal", "backVAL", "backValue", "ReturnVAL", "returnVAL", "ReturnVal", "backval"], "file": ["full", "lock", "connection", "f", "data", "get", "name", "File", "socket", "handler", "type", "to", "info", "fe", "local", "class", "base", "binary", "per", "log", "page", "part", "user", "b", "files", "zip", "l", "single", "lib", "source", "image", "db", "ile", "cf", "feed", "path", "filename", "object", "url", "document", "uri", "io", "http", "global", "folder", "function", "php", "up", "message", "FILE", "resource", "out", "fp", "sf", "dir", "directory", "input", "use"], "rutaGlobal": ["srutaLocal", "rugaReal", " rutaGeneral", "srottaLocal", "rutaLocal", "rettaInternational", "rutiGlobal", "rutaReal", "rugaInternational", "rutoGeneral", "srutaCore", "rutiGeneral", "rundaGeneral", "rutiLocal", "srettaGlobal", "srettaReal", "srottaCore", "rottaLocal", "rutiReal", "rutoInternational", "rutoCore", "srutaReal", "rottaGlobal", "rugaGlobal", "rundaInternational", "rottaGeneral", "rutaInternational", " rutoGeneral", "srutaInternational", "srettaLocal", "rutiCore", "rucaGeneral", "rutaCore", "srettaInternational", " rutaInternational", "rutaGeneral", " rutoInternational", "srutaGeneral", "rettaGlobal", "rutiInternational", "rugaLocal", "rundaGlobal", "rottaCore", "rucaGlobal", "rucaInternational", "rettaLocal", "rettaReal", "srottaGlobal", "rutoLocal", " rutoGlobal", "srutaGlobal", "rutoGlobal", "srottaGeneral"], "rutaRelativa": ["rutaRelativ", "rutaMalativo", "rutaRelativism", "rutaRelATiva", "rutaRelATivas", "rutaRelateivo", "rutaRelarativas", "rutaRelATiv", "rutaMalariva", "rutaRelateivism", "rutaMalarivism", "rutaRelarivas", "rutaRelarativo", "rutaRelariva", "rutaMalarivo", "rutaRelateiva", "rutaRelattivas", "rutaRelattiv", "rutaRelativo", "rutaRelativas", "rutaMalarivas", "rutaMalativas", "rutaRelattivo", "rutaMalativism", "rutaRelarativa", "rutaRelateiv", "rutaRelATivo", "rutaRelattivism", "rutaRelariv", "rutaRelarativ", "rutaRelarivo", "rutaRelattiva", "rutaRelarivism", "rutaMalativa", "rutaRelarativism"], "fis": ["friss", "fiss", " fris", "fys", "vos", " fys", "FIs", "fir", "Fys", "xis", "fIs", "vis", " fIs", "viss", "Fis", "vIs", "xys", "Fiss", "fros", "Fir", " fiss", "xiss", "Fos", "fris", "xris", "Fris", " fir", "frir"], "fos": ["Fo", "tfo", "infios", "tfos", "FOS", "Fops", "focks", "fOS", " fOS", "fileos", "Focks", "Fios", "fops", "Fis", "fileo", "infos", "fios", "tfops", "infOS", "Fos", "fileocks", " fo", " focks", "fo", " fios", " fops", "tfOS", "fileops", "infis"], "canalFuente": ["canalBuence", "canalBugent", "canalKugent", "canallBuente", "canallBuenza", "canalBuento", "canallFuente", "canalJuento", "canallFugent", "canulFience", "canalFiencer", "canalFUento", "canalJuence", "canalBuent", "canalFuento", "canalFUante", "canallBuence", "canalsFuent", "canalfuente", "canalFuencer", "canalsFuente", "canalBuente", "canalJuente", "canallFuenza", "canalBuante", "canalMuence", "canulFiente", "canalFuenza", "canalMuente", "canalsBuento", "canalBuenza", "canalfugent", "canalsBuent", "canalFiente", "canalKuence", "canulFient", "canalFuante", "canalfuenza", "canulFuente", "canulFiencer", "canalFUente", "canulFuent", "canulFuencer", "canalMuent", "canalsBuante", "canalJuante", "canallBugent", "canalFugent", "canalsFuante", "canalFient", "canalsFuento", "canulFuence", "canalFUent", "canallFuence", "canalfuence", "canalKuente", "canalMuencer", "canalFuence", "canalsBuente", "canalFience", "canalKuenza", "canalJuent", "canalJuencer", "canalFuent"], "canalDestino": ["canalDestania", "canallDestinos", "canaldestination", "canalNegania", "canallDestino", "canaldestina", "canelCampino", "canelCampania", "canelDestination", "canelDestino", "canalCampinos", "canalldestinos", "canallDestania", "canalldestania", "canallDestina", "canalCampination", "canalCampino", "canalNegino", "canalNegination", "canalldestino", "canalNegina", "canelCampination", "canelDestania", "canalCampina", "canelDestina", "canaldestinos", "canalDestinos", "canaldestania", "canalDestina", "canalCampania", "canalldestina", "canalDestination", "canaldestino", "canelCampina"]}}
{"id1": "771802", "id2": "16142024", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createOutputSteam", "createInputStream", " createInputSteam", "createOutputSteam", " createByteSteam", " createOutputFile", " createOutputReader", " createIOSteam", "createInputReader", " createByteFile", " createByteReader", " createIOStream", " createByteStream", "createInputSteam", " createInputFile", " createInputReader", " createIOReader", "createOutputReader", "createOutputFile", "createInputFile", " createIOFile", " createInputStream"], "inFile": ["inputFile", "outFiles", "insfile", "infile", "inputfile", "outfile", "outStream", "incFiles", "sourceFiles", "incfile", "inFiles", "insStream", "sourceStream", "incFile", "insFile", "sourcefile", "inputFiles", "inputStream", "sourceFile", "insFiles", "inStream", "incStream"], "outFile": ["inputFile", "workingDirectory", "workDir", " outStream", "targetFile", "outDir", "inputTime", "infile", "inputfile", "outfile", "outStream", "inDir", "workingFile", "targetStream", " outDirectory", "targetfile", "inputDir", " outfile", "workingfile", "outTime", "workfile", "targetDirectory", "inTime", "workFile", "workingStream", "outDirectory", "workTime"], "k_blockSize": ["k_lineInfo", "k_BlockCount", "k_blockLength", "k_BlockLength", "k_lockCount", "k_blockInfo", "k_BlockSize", "k_blockCode", "k_blocksLen", "k_blocksSize", "k_blocksCount", "k_lineCount", "k_byteCount", "k_BlockCode", "k_bitInfo", "k_lockLength", "k_byteLen", "k_lockLen", "k_blockCount", "k_blocksLength", "k_bitCount", "k_byteSize", "k_blockLen", "k_lockSize", "k_byteInfo", "k_lineSize", "k_byteCode", "k_byteLength", "k_lockCode", "k_bitSize"], "byteCount": [" byteSize", "ByteCount", "blockSize", "flushLength", "flushcount", " byteLen", "bytecount", "ByteLen", "byteSum", "blockLength", "characterCount", "flushSize", "ByteSize", "ByteSum", "byteLen", " byteSum", "blockSum", " byteLength", "characterLen", "characterLength", "ByteLength", " bytecount", "byteLength", "blockCount", "flushCount", "characterSize", "byteSize", "Bytecount"], "buf": ["border", "cb", "seq", "data", "loc", "background", "batch", "alloc", "buff", "cap", "Buffer", "bh", "rc", "feat", "base", "b", "vec", "bytes", "img", "cmd", "bag", "exc", "flush", "font", "la", "rb", "buffer", "ctx", "feed", "ucc", "Buff", "config", "cv", "brace", "len", "src", "fd", "uf", "cas", "queue", "bf", "append", "result", "fb", "tmp"], "ofp": ["Oftp", "OFt", "afc", "Ofl", "Ofp", "oftp", "fortp", "forp", "OFtp", "ofl", "fort", "ofnp", "oft", "afl", "Ofnp", "afnp", "OFp", "OFl", "OFc", "forc", "Ofc", "afp", "ofc", "OFnp", "Oft"], "zos": ["lol", "cos", "zy", "bes", "outs", "ls", "css", "rez", "tz", "nz", "uz", "ws", "zyk", "zn", "js", "cfg", "zx", "nox", "ozo", "modules", "bitcoin", "ros", "ZA", "ses", "webkit", "fits", "ogl", "enos", "liquid", "bs", "os", "lins", "kos", "zl", "zag", "zin", "obs", "zip", "oses", "ZI", "iffs", "abi", "packs", "z", "rons", "osi", "inos", "zar", "los", "zo", "obb", "zona", "budget", "bos", "ossus", "ops", "jas", "zers", "zh", "zb", "zik", "zen", "zi", "soon", "zig", "zes", "forge", "owicz", "oS", "hz", "robe", "gz", "utils", "zon", "iframe", "zer", "oda", "dylib", "core", "za"], "osw": ["ossd", "issw", "osd", "osfw", "oswd", "isnow", "ishell", "esww", "bx", "osshell", "esy", "esnow", " osww", "oshell", "iswd", "eshell", "ossow", "ossy", "ossfw", "bws", "bsx", "lsx", "osy", "ossww", "osssw", "bsws", "bsw", "esfw", "isy", "osx", "ossw", "isd", " osfw", "lsw", "ossnow", "esow", "osws", " osow", "lswo", "osswd", "isw", "bwo", "essw", "osow", "esw", "esd", "oswo", "osnow", "eswd", "lsws", "osww", "bswo"], "bw": ["bbwa", " bz", "lbsw", "bbaw", "bbwu", "abW", "abwd", " bwa", "bx", " bew", "fw", "bz", "fbwe", "ebwd", "bbws", "fsw", "lbw", "lw", "bws", "fwa", "ebwe", " baw", "ow", "lbx", "abwe", "bbz", " bws", "owu", "oaw", "Bw", "bew", "lbwa", "bwu", "bsw", "lx", "fr", "bbwh", "lbws", "baw", "ebw", "fx", "bwe", "bbew", "fwh", "abw", "lsw", "bwh", "lbr", "ebW", "Bwa", " bwu", "Bws", "fbW", "lbwh", "Bew", "owa", "bwd", "fbw", "fbwd", "bwa", "bbw", " bwh", "lbz", "bW", "lwa"], "zot": ["azor", "jit", "Zit", "ziot", " zor", "zerot", "jori", "azit", "Zita", "azot", "jot", "Zott", "zerott", "zerita", "zeros", "zita", "Zot", "zerori", "aziot", " zori", "Zor", "azita", "zott", "azott", "zerit", "zor", " ziot", "zori", "jos", "Ziot"], "ifp": ["ifb", " ifc", "Iff", "ifl", "ifi", "ipl", "IFp", " ifi", " ifb", "Ifi", "ipc", "ipp", "Ifc", " iff", "IFl", "ipb", " ifl", "IFc", "iff", "IFi", "Ifp", "ifc", "IFb", "IFf"], "zis": ["zenIS", "Ziss", "zipits", "jit", "Zis", "jisi", "xits", "zeits", "xisi", "zenais", "xis", "zeiss", "zisi", "ziss", "zeis", "zipis", "zip", "xIS", "xib", " zisi", "zipip", " zIS", "jits", "zenib", "zeip", "jis", " zits", "zIS", "zenis", " zais", "zib", "xais", " zib", "zits", "zipiss", "xit", "Zip", "Zits", "zais"], "isr": ["risr", "iscr", "rispr", "irpr", "ISr", "irr", "irrb", " iscr", "ISrs", "isrs", "IScr", "isrc", "issr", "ISpr", "ISrc", "ISrb", "isrb", "ISsr", "issrs", "isscr", "isssr", " issr", "risrc", "irrc", "ispr", "risrb", " isrs"], "br": ["mr", "Br", "ob", "HR", "ibr", "arr", "ctr", "body", "kr", "div", "str", "bh", " fr", "bl", "obl", " BR", "yr", "b", "img", " Br", "r", "bp", "rs", "err", "fr", "cro", "rb", "bar", "BR", "sp", "shr", "hr", "ch", "lr", "ibl", "browser", "ocr", "gr", "sr", "bsp", "rib", "bro", "tr", " dr", "ber", "obi", "bc"], "zit": ["zipith", "ji", "zipits", "jit", "zipit", "zIT", "zite", " zite", "zipitter", "zipita", " zi", "jip", " zic", "xic", "zeits", "zeIT", "jIT", " zith", "zith", "zita", "zip", "jic", "zipip", "zenitter", "jits", "jith", "zipite", "zeita", "zenith", "zitter", "xi", "jite", " zits", "zipIT", "zi", "xith", " zip", "jita", "zits", "zic", "zeit", "zeitter", "zenit", "xit", "zeith", "zenits"]}}
{"id1": "19584877", "id2": "6840241", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToStream", "encodeFiletoStream", "encodeString2Stream", "encodeFiletoFile", "encodeStringToString", "encodeString2String", "encodeFileToStream", "encodeFileToString", "encodeFileFromFiles", "encodeFile2Files", "encodeStringToFiles", "encodeFile2String", "encodeStringToFile", "encodeFileFromString", "encodeString2Files", "encodeFileFromFile", "encodeFiletoString", "encodeFile2Stream", "encodeFileToFiles", "encodeFiletoFiles", "encodeString2File", "encodeFile2File", "encodeFileFromStream"], "infile": ["inputFile", "inputfilename", "Infiles", "outfilename", "infilename", "inputfile", "outFile", "inputfiles", "outfiles", "infp", "inputfp", "outfp", " infilename", " infp", " infiles", "infiles", "Infilename", "InFile", "Infile", "inFile"], "outfile": ["newFile", "outputfilename", "Outfile", "outfilename", "infilename", "outFile", "Outfolder", " outfp", " outfilename", "infp", "newfolder", "outname", "outfp", " outname", " outFile", "Outname", " outfolder", "outputfp", "newname", "newfile", "outputfile", "infolder", "OutFile", "outputfolder", "outfolder"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "vin", "base", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "image", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "copy", "conn", "cache", "again", "output", "inner", "writer", "work", "line", "err", "off", "client", "o", "OUT", "lib", "source", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "post", "io", "net", "file", "up", "co", "on", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "reader", "border", "uffer", "iter", "data", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "len", "queue", "input", "result", "length", "write", "fb", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "close", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "input", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "modified", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "respons", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "5399593", "id2": "13783898", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"encrypt": [" encipher", "escipher", " encress", "decrypt", "escress", "encipher", "encryption", "escryption", "encress", "decress", "decryption", "decipher", " encryption", "escrypt"], "plaintext": [" plaincontent", "foreTEXT", " plainform", "ainText", "plainTEXT", "raincontent", "rainTEXT", "singleText", "plaincontent", "plainform", "singleform", " plainTEXT", "foreText", "foretext", "ainTEXT", " plainText", "aintext", "plainText", "rainText", "forecontent", "ainform", "singleTEXT", "raintext", "singletext"], "UnsupportedEncodingException": ["UnsupportedCodedEx", "UnsupportedEncryptionEx", "UnsupportedEncodedEx", "UnsupportedEncodingError", "UnsupportedCodedError", "UnsupportedEncgorithmError", "UnsupportedEncodedException", "UnsupportedCodingException", "UnsupportedEncodingEx", "UnsupportedCodedException", "UnsupportedCodingError", "UnsupportedEncgorithmException", "UnsupportedEncodedError", "UnsupportedEncryptionError", "UnsupportedEncryptionException", "UnsupportedCodingEx", "UnsupportedEncgorithmEx"], "md": ["meta", "bd", "mag", "mg", "hed", "cd", "rm", "wd", "mad", "dd", "m", "ma", " MD", "mt", "mage", "me", "dig", "mb", "am", "mac", "hm", "cmd", "dm", "mn", "material", "dc", "d", "MD", "map", "db", "mo", "mod", "amd", "sum", "mp", "code", "metadata", "mm", "pm", "mu", "message", "sha", "po", "bf", "mem", "mc", "ms", "od", "mand", "hd", "nm", "Cmd"], "raw": ["full", "missing", "blocks", "ack", "array", "dec", "clean", "RAW", "enc", "load", "shared", "hex", "ghost", "wrap", "Raw", "instance", "rew", "row", "buffer", "block", "serial", "sign", "empty", "null", "ng", "original", "unsigned", "message", "flash", "sha", "input", "initial", "aws", "unknown", "alpha", "micro", "buf"], "hash": ["rh", "data", "ha", "hed", "version", "array", "shared", "hex", "base", "log", "html", "cache", "text", "math", "mac", "kh", "ruby", "key", "password", "secret", "abi", "block", "image", "build", "h", "url", "sum", "code", "ashes", "id", "message", "flash", "sha", "header", "ash", "hh", "auth", "Hash", "alpha", "string", "sh"]}}
{"id1": "17158020", "id2": "23620712", "code1": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["decryptPass", "decipherpassword", "encipherPassword", "encryptPass", "decryptPassword", "encipherString", "decryptString", "decipherPassword", "decryptpassword", "encresspassword", "decipherPass", "encryptpassword", "encryptString", "encressPassword", "encressString", "encipherPass", "encressPass", "encipherpassword", "decipherString"], "passwordString": ["passBytes", " passwordText", "passPassword", "passStr", " passwordStr", "PasswordStr", "passwordText", "passwordPassword", "passwordStr", "PasswordBytes", "passwordBytes", " passwordPassword", "passText", "PasswordString", "PasswordText", "PasswordPassword", " passwordBytes", "passString"], "digest": ["signEST", "hedested", "mainit", "generest", " diger", "digit", "DigEST", "diggest", "Digester", "heder", "mainested", "compit", "generester", "digested", "mainest", "mainHash", "digester", "Digse", "compHash", "digEST", "compest", "digHash", "digse", "hedester", "signester", "compested", " digEST", " digHash", "Digested", "diger", "signer", "genergest", "Diggest", "Diger", "signest", " digse", " digit", "hedest", " digested", "generer", "signse", " digester", "Digest", " diggest"], "raw": ["missing", "full", "channel", "array", "dec", "clean", "RAW", "enc", "load", "shared", "local", "hex", "binary", "wrap", "Raw", "wrapper", "instance", "rew", "random", "pure", "temp", "secret", "row", "buffer", "block", "image", "feed", "serial", "empty", "null", "ng", "original", "unsigned", "input", "out", "initial", "aws", "unknown", "none", "alpha"], "hash": ["rh", "data", "ha", "hed", "version", "array", "hex", "base", "dig", "cache", "mac", "her", "kh", "ruby", "key", "secret", "row", "block", "image", "response", "h", "url", "sum", "pass", "ashes", "id", "index", "message", "sha", "utf", "header", "input", "ash", "auth", "Hash", "html", "sh"]}}
{"id1": "19335986", "id2": "755203", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["uncatchedexc", "Caughtexc", "CatchedEvent", "uncachedException", "uncatchedEvent", "unchandledException", "uncaughtexc", "uncachedEvent", "uncachedexc", "CaughtException", "uncatchedException", "CaughtEvent", "uncaughtEvent", "CatchedException", "unchandledexc", "unchandledEvent", "Catchedexc"], "t": ["ts", "f", "tree", "it", "s", "type", " td", "g", "m", "p", "ty", "w", "r", "l", "d", "ing", "te", "n", "T", "let", "c", " T", "title", "ed", "tr", "out", "tx"], "e": ["be", "ep", "er", "f", "data", "ception", "oe", "error", "s", "el", "m", "p", "j", "se", "ge", "event", "en", "fe", "ae", "ec", "eb", "ie", "me", "r", "err", "E", "exc", "o", "d", "i", "ne", "example", "environment", "ev", "enter", "code", "pe", "c", "eu", "ce", "ele", "ed", "es", "diff", "Exception", "de", "esi", "ace", "ee", "element"], "display": ["app", "profile", "layout", "container", "play", "monitor", "body", "p", "fe", "screen", "hide", "me", "status", "summary", "position", "description", "page", "content", "Display", "design", "console", "this", "show", "d", "style", "image", "dis", "process", "object", "default", "config", "view", "platform", "scroll", "window", "host", "report", "panel", "de"], "shell": ["lock", "app", "machine", "container", "el", "m", "body", "xml", "launch", " Shell", "log", "hell", "echo", "copy", "status", "bash", "loop", "b", "math", "mail", "l", "tools", "console", "buffer", "gui", "sound", "cli", "image", "live", "child", "poll", "kernel", "process", "h", "exec", "environment", "system", "cl", "server", "ml", "clone", "tool", "sb", "host", "help", "sym", "Shell", "sh"], "message": ["msg", "data", "error", "email", "Message", "monitor", "m", "body", "application", "event", "xml", "log", "status", "summary", "copy", "model", "page", "description", "mail", "output", "mess", "content", "member", "translation", "address", "console", "buffer", "image", "value", " exception", "request", "response", "object", "update", "document", "essage", "view", "server", "management", "flash", "header", "queue", "result", "report", " messenger", "media", "meter"], "e1": ["exc1", "e3", "e8", " e2", "E1", "exc8", "E3", "e2", "exc3", "E2", "E8", "exc2", " e8", " e3"]}}
{"id1": "3801655", "id2": "19608872", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "code2": "    public void genDropSchema(DiagramModel diagramModel, boolean foreignKeys) {\n        try {\n            con.setAutoCommit(false);\n            stmt = con.createStatement();\n            Collection boxes = diagramModel.getBoxes();\n            BoxModel box;\n            String sqlQuery;\n            if (foreignKeys) {\n                for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                    box = (BoxModel) x.next();\n                    if (!box.isAbstractDef()) {\n                        dropForeignKeys(box);\n                    }\n                }\n            }\n            int counter = 0;\n            for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                box = (BoxModel) x.next();\n                if (!box.isAbstractDef()) {\n                    sqlQuery = sqlDropTable(box);\n                    System.out.println(sqlQuery);\n                    try {\n                        stmt.executeUpdate(sqlQuery);\n                        counter++;\n                    } catch (SQLException e) {\n                        String tableName = box.getName();\n                        System.out.println(\"// Problem while dropping table \" + tableName + \" : \" + e.getMessage());\n                        String msg = Para.getPara().getText(\"tableNotDropped\") + \" -- \" + tableName;\n                        this.informUser(msg);\n                    }\n                }\n            }\n            con.commit();\n            if (counter > 0) {\n                String msg = Para.getPara().getText(\"schemaDropped\") + \" -- \" + counter + \" \" + Para.getPara().getText(\"tables\");\n                this.informUser(msg);\n            } else {\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage() + \" // Problem with the JDBC schema generation! \");\n            try {\n                con.rollback();\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection rollback! \");\n            }\n        } finally {\n            try {\n                con.setAutoCommit(true);\n                stmt.close();\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection disconnect! \");\n            }\n        }\n    }\n", "label": 0, "substitutes": {"helper": ["helmer", "workmer", "Heler", "harler", "scheper", "harper", "sher", "worker", "heller", "scheler", "scheHelper", "shmer", "helpherd", "workp", "helppherd", "harpherd", "helHelper", "Helper", "helpper", "harHelper", "helpHelper", "heler", "schepherd", "Helmer", "workper", "shper", "shp", "helpler", "help", "Help"], "dataset": ["datacET", "datAsets", "datASET", "dataseter", "metasET", "datASheet", "datapsert", "DatASet", "datasert", "DatASET", "datrasET", "datAsET", "datassET", " Datasheet", "datraseter", "Datasets", "datasets", "datAsheet", "datacheet", "datasset", "Dataseter", "datasteter", "datasheet", "metassheet", "metassET", "datASeter", "datassheet", " DatASets", "datASet", " DatASET", "DatASeter", "datapsET", "metasheet", "datacet", "DatasET", "datASets", " Datasets", "datastET", "metasert", "datassets", " Dataset", " DatASet", " DatasET", "Dataset", "datastets", "metassert", " DatASheet", "datacert", "datAset", "metasset", "datrasets", "datapsheet", "datastet", "datapset", "datassert", "datasET", "metaset", "DatASets", "datraset"], "zip": ["lock", "pipe", "sl", "f", "data", "git", "archive", "handler", "slice", "py", "pdf", "secure", "p", "se", "gz", "jar", "xml", "binary", "plugin", "ssl", "copy", "loop", "wrap", "sea", "bug", "bag", "zone", "service", "pack", "parse", "z", "source", "system", "java", "code", "io", "flat", "file", "split", "folder", "out", "dir", "window", "directory", "Zip", "ip", "tar", "pkg"], "entries": [" entlements", "entrees", "ntents", "entsrants", "contents", "entents", "entlements", "ENTrants", "ntrys", "entities", "entsries", "entrylements", "contry", " entlines", "entslections", "infries", "infrees", "deents", "entlections", "iterries", "ENTries", "itries", "delements", "infities", "inflections", "contries", "intries", "intlements", "entsrees", "entlines", "entryents", " entities", "contrys", "itents", "intlines", "iterlements", "iterents", "inflements", "inflines", "deries", "infrants", "entrys", "entrants", "entryries", "itry", "intities", "ENTrees", "ENTlections", "ntry", "itrys", "ntries"], "performance": ["ul", "union", "util", " units", "it", "book", "Unit", " Unit", "rank", " group", "units", "U", " Units", " u", "work", " split", "its", "each", " suite", " unit", "stats", "exec", "ui", " ratio", " output", "unit", "slave", " result", "runner", " writers"], "index": ["x", "offset", "iter", "name", "depth", "type", "head", "position", "page", "num", "key", "count", "Index", "i", "limit", "value", "path", "order", "level", "number", "unit", "id", "pos", "length", "write"], "entry": ["nt", "office", "connection", "data", "si", "it", "archive", "stream", "install", "info", "se", "xml", "ie", "add", "lc", "Entry", "part", "inner", "section", "her", "r", "export", "e", "cell", "key", "row", "service", "parse", "style", "child", "feed", "or", "pattern", "server", "uri", "post", "route", "pe", "in", "file", "folder", "ry", "result", "cel", "record", "input", "write", "obj", "element"], "temp": ["full", "lock", "pipe", "office", "iter", "f", "data", "layout", "Temp", "archive", "session", "thread", "table", "stable", "emp", "p", "partial", "clean", "local", "binary", "base", "copy", "wrap", "cache", "part", "w", "output", "txt", "tem", "single", "dest", "porary", "test", " temporary", "storage", "template", "ctx", "path", "parent", "context", "config", "store", "empty", "io", "http", "original", "flat", "file", "folder", "valid", "cel", "tc", "input", "out", "fake", "directory", "tmp"], "writer": ["iter", "er", "manager", "handler", "worker", "stream", "layer", "per", "log", "w", "writing", "output", "inner", "wrapper", "loader", "r", "engine", "key", "writers", "player", "ws", "war", "feed", "builder", "write", "driver", "rw", "or", "outer", "sw", "server", "author", "io", "element", "wr", "wave", "wire", "holder", "wer", "file", "written", "riter", "out", "Writer", "ler", "editor"], "reader": ["iter", "er", "f", "ri", "handler", "worker", "stream", "upper", "per", "loader", "inner", "wrapper", "r", "rer", "ter", "rr", "i", "oder", "ner", "feed", "or", "driver", "builder", "write", "reading", "server", "iterator", "ser", "io", "http", "element", "file", "rar", "ry", "input", "ler", "Reader", "editor"], "buffer": ["offset", "uffer", "iter", "sequence", "data", "channel", "batch", "slice", "table", "seed", "reference", "layer", "buff", "Buffer", "binary", "position", "size", "bytes", "capacity", "flush", "address", "row", "source", "limit", "feed", "character", "document", "server", "transfer", "null", "memory", "wave", "message", "queue", "input", "header", "resource", "result", "length", "initial", "write", "device", "buf"], "read": ["x", "READ", "open", "save", "iter", "readable", "data", "get", "start", "current", "ride", "Read", "book", "play", "allow", "g", "type", "create", "sync", "send", "se", "download", "k", "load", "find", "ind", "reads", "add", "copy", "check", "text", "size", "old", "work", "max", "count", "parse", "run", "build", "seek", "feed", "connect", "process", "select", "exec", "fill", "child", "eval", "next", "close", "default", "config", "reading", "view", "pass", "raw", "id", "input", "skip", "sleep", "print", "report", "length", "ad", "available", "write", "use", "end", "wait"], "outfile": ["logdata", "inf", "Outfile", "outstream", "outfilename", "infilename", "againstream", "infile", "Outf", "outFile", "againline", " outfilename", " outstream", "logfile", "againfile", "inline", "outf", " outf", "logfilename", "outdata", " outline", " outFile", "indata", "Outline", "instream", "logFile", "againdir", "Outdir", "indir", "Outstream", " outdata", "outdir", "outline", "inFile"], "line": ["job", "le", "data", "name", "side", "error", "type", "range", "el", "filter", "sync", "str", "letter", "log", "status", "inline", "cle", "page", "text", "section", "l", "val", "cell", "lines", "lf", "column", "ine", "comment", "style", "block", "parse", "row", "Line", "band", "object", "url", "code", "pass", "split", "file", "LINE", "word", "frame", "sel", "lin", "header", "item", "on", "link", "string", "ip", "end", "look", "strip"], "parser": ["Parser", "er", "umper", "data", "lp", "angler", "manager", "pool", "handler", "book", "type", "worker", "string", "p", "par", "xml", "arser", "per", "plugin", "class", "loader", "wrapper", "r", "test", "parse", "oder", "builder", "driver", "pattern", "system", "server", "function", "params", "cher", "plan", "processor", "ler"], "list": ["er", "data", "get", "lp", "pool", "table", "type", "array", "filter", "p", "info", "set", "base", "match", "part", "all", "can", "l", "r", "collection", "val", "member", "and", "left", "best", "test", "map", "listed", "chain", "parent", "v", "other", "lists", "li", "group", "right", "LIST", "result", "out", "join", "plan"], "rule": ["rol", "ul", "ule", "er", "data", "tree", "ri", "table", "range", "layer", "field", "event", "str", "class", "plugin", "model", "base", "per", "match", "r", "val", "row", "service", "style", "parse", "Rule", "lr", "li", "group", "pe", "rate", "function", "item", "header", "record", "rules", "rl", "ee", "dict"], "measure": ["Measure", "feasure", "speasure", "speasured", "measured", "feasuring", "measures", "feasures", "Measures", "speasures", "Measuring", "measuring", "Measured", "speasuring", "feasured"]}}
{"id1": "11562173", "id2": "7911686", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"checkInputStream": [" checkOutputSteam", "checkInputstream", "checkFileSteam", " checkInputstream", "checkInputChannel", "checkOutputStream", " checkOutputChannel", "checkInputSteam", "checkIOstream", " checkOutputStream", "checkOutputChannel", " checkOutputstream", "checkFileStream", " checkInputChannel", "checkIOStream", "checkFilestream", "checkFileChannel", " checkInputSteam", "checkIOSteam", "checkIOChannel", "checkOutputSteam", "checkOutputstream"], "in": ["x", "reader", "bin", "connection", "isin", "login", "data", "into", "ack", "ins", "comp", "p", "min", "In", "is", "inner", "again", "din", "IN", "plus", "ini", "source", "image", "inc", "io", "inn", "c", "as", "up", "index", "src", "ic", "input", "con"], "cmp": ["cb", "sup", "loc", "cpp", "comp", "p", "mom", "proc", "pc", "cup", "rc", "sort", "cs", "lc", "match", "prev", "cache", "roc", "pixel", "op", "clip", "pre", "cop", "upp", "comment", "ci", "cc", "ctx", "ch", "spec", "asc", "config", "mp", "conv", "code", "c", "up", "index", "com", "prefix", "co", "amp", "np", "coll", "ctrl", "diff", "fp", "omp", "cho", "cp"], "all": ["full", "al", "allow", "auto", "array", "partial", "p", "any", "not", "only", "one", "local", "ann", "match", "acl", "ALL", "am", "l", "and", "each", "best", "list", "call", "All", "process", "asc", "parent", "cl", "default", "sum", "null", "global", "both", "a", "valid", "coll", "except", "total", "none", "always", "alpha"], "stream": ["reader", "ream", "self", "channel", "socket", "pool", "ack", "comp", "cont", "stack", "per", "model", "roll", "user", "output", "instance", "wrapper", "trans", "client", "temp", "this", "test", "track", "source", "feed", "port", "response", "object", "speed", "v", "sw", "form", "context", "iterator", "raw", "platform", "round", "null", "document", "up", "transform", "impl", "src", "result", "input", "coll", "host", "progress", "string", "Stream", "steam"], "out": ["x", "full", "bin", "extra", "data", "name", "point", "array", "sync", "p", "outs", "not", "copy", "part", "user", "again", "output", "b", "o", "OUT", "this", "list", "comment", "block", "image", "inc", "project", "response", "outer", "parent", "v", "other", "sum", "null", "io", "c", "up", "index", "prefix", "result", "exp", "Out", "obj", "option"], "i": ["x", "ji", "f", "strength", "si", "it", "ti", "ri", "type", "slice", "p", "j", "info", "pi", "k", "ind", "ix", "hi", "lc", "I", "bi", "u", "b", "di", "multi", "qi", "l", "r", "fi", "e", "key", "ini", "abi", "d", "ci", "init", "h", "xi", "v", "oi", "ui", "mi", "n", "li", "uri", "ii", "io", "c", "id", "index", "ai", "gi", "start", "end"]}}
{"id1": "9081749", "id2": "14691829", "code1": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 1, "substitutes": {"encrypt": ["esccrypt", "Enccrypt", "Encrypt", "escipher", "encipher", "encryption", "escryption", "Encryption", "deccrypt", "decryption", "decipher", "enccrypt", "decrypt", "Encipher", "escrypt"], "password": ["wallet", "data", "name", "email", "wd", "database", "command", "seed", "python", "array", "encrypted", "description", "words", "picture", "user", "text", "cache", "Password", "css", "weight", "mask", "root", "account", "parser", "key", "address", "secret", "crypt", "buffer", "padding", "this", " passwords", "image", "sword", "value", "project", "phrase", "PASS", "pattern", "parent", "pass", "null", "params", "word", "prefix", "message", "token", "pad", "auth", "string", "strip", "username"], "encryptType": ["encertType", "acrypttype", "encryptClass", "encrupttype", "encipherClass", "encryptionTypes", "encrypttype", "acryptionTyp", "encruptTyp", "acryptTypes", "ecryptClass", "ecipherKey", "acryptionTypes", "encerttype", "acryptionType", "enciphertype", "encPTKey", "encPTType", "ecryptKey", "encryptTypes", "encryptKey", "acryptType", "encriptTyp", "encruptTypes", "encryptionTyp", "encripttype", "encryptionType", "encPTtype", "encipherKey", "encriptTypes", "encruptType", "acryptiontype", "encPTClass", "encipherType", "ecipherClass", "encertKey", "ecipherType", "ecryptType", "acryptTyp", "encryptTyp", "eciphertype", "encriptType", "encertClass", "encryptiontype", "ecrypttype"], "md": ["df", "bd", "vd", "f", "mag", "hed", "cd", "rm", "grad", "mad", "dd", "m", " MD", "mt", "dig", "di", "mb", "mac", "hm", "cmd", "dm", "um", "d", "MD", "gd", "mo", "mod", "amd", "der", "mp", "rpm", "metadata", "mm", "pm", "dh", "mc", "pd", "mand", "hd", "od", "nm", "Cmd"], "hash": ["full", "ver", "data", "ha", "hed", "hard", "char", "digit", "version", "error", "handle", "how", "array", "filter", "body", "str", "hex", "log", "base", "cache", "check", "part", "throw", "kh", "her", "mac", "bug", "query", "dot", "key", "count", "style", "build", "image", "block", "value", "h", "fill", "url", "sum", "code", "number", "ashes", "memory", "id", "index", "search", "len", "message", "flash", "sha", "header", "ash", "diff", "print", "Hash", "html", "chip", "sh", "bit"], "hexString": ["pixelBuffer", "squareField", "blackString", "hexstring", "hexArray", "hexLine", " hexArray", " hexField", "blackFile", "hexField", " hexBuffer", "rawBuffer", " hexSet", "rawstring", "blackLine", "alphFile", "zipString", "blackstring", "hexFile", "squareArray", "hexBuffer", "hashArray", "squareString", "zipSet", "pixelString", "rawArray", "zipField", "squareSet", "zipArray", "hashString", "alphLine", "alphString", "rawString", "hexSet", "hashFile", "hashstring", "pixelstring", "rawFile", " hexstring", "alphstring", " hexLine", " hexFile", "pixelFile"], "i": ["x", "ji", "f", "data", "si", "start", "it", "ti", "ri", "s", "slice", "p", "j", "info", "pi", "ie", "ix", "I", "bi", "u", "b", "di", "multi", "qi", "l", "r", "e", "o", "off", "ini", "abi", "temp", "count", "ci", "h", "xi", "v", "oi", "ui", "li", "n", "uri", "ii", "io", "c", "id", "index", "ai", "gi", "phi", "length", "ip", "end"]}}
{"id1": "17522011", "id2": "11556231", "code1": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "code2": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "label": 0, "substitutes": {"read": ["reader", "READ", "open", "readable", "data", "get", "Read", "create", "type", "play", "send", "load", "find", "reads", "class", "add", "check", "include", "work", "parse", "build", "run", "select", "use", "connect", "feed", "process", "exec", "eval", "default", "reading", "resource", "input", "print", "report", "resources", "invoke", "write", "start"], "classLoader": ["resourceLoader", "ClassReader", "ClassPath", "resourceReader", " classPath", "classLoad", "resourceLoading", "fileDir", " classLoad", "ClassLoading", "classPath", "fileLoad", "ClassLoader", " classloader", " classDir", " classLoading", "classLoading", "filePath", "ClassDir", "resourceloader", "fileLoader", "fileloader", "ClassLoad", "classReader", " classReader", "classDir", "classloader", "Classloader"], "name": ["x", "connection", "active", "ame", "data", "type", "str", "class", "base", "part", "time", "size", "old", "alias", "root", "key", "address", "comment", "image", "child", "value", "large", "path", "parent", "filename", "default", "names", "n", "Name", "pass", "code", "null", "no", "file", "id", "word", "prefix", "search", "resource", "named", "home", "none", "string", "NAME"], "all": ["active", "full", "app", "f", "al", "at", "batch", "allow", "auto", "sync", "array", "partial", "any", "not", "only", "one", "local", "sort", "ann", "part", "ALL", "am", "with", "left", "l", "and", "each", "alls", "this", "call", "list", "All", "process", "attribute", "pass", "global", "both", "total", "named", "none", "alpha", "apply"], "sm": ["bm", "gm", "sl", "su", "sam", "si", "sn", "rm", "m", "sk", "em", "Sm", "im", "ama", "asm", "om", "imm", "sv", "hm", "wm", "zip", "vm", "ym", "smith", "service", "source", "sp", "mo", "api", "SM", "tm", "sw", "sum", "spe", "sa", "sy", "mm", "sr", "sb", "cm", "sf", "ss", "fm", "ms", "sym", "sim", "nm", "so", "km", "serv", "sh"], "enu": ["anun", " ennu", "Enu", "anus", "ennus", "venu", "ENu", "munU", "Enus", "enc", "encu", " enus", "venus", "enou", "ENus", "Ennu", "munu", "enU", "ennnu", "munus", "Enou", "enun", "venc", "ENc", "Encu", "ENou", "ennu", "venou", "Enun", "anu", "enncu", "anU", "munun", "EnU", "Enc", " encu", "enus"], "url": ["job", "connection", "sl", "f", "loc", "ur", "layer", "web", "download", "str", "ll", "base", "ls", "ssl", "page", "loader", "plug", "zip", "l", "r", "key", "address", "pull", "Url", "i", "URL", "source", "image", "path", "li", "server", "uri", "browser", "http", "in", "file", "id", "impl", "resource", "rel", "string"], "is": ["app", "ais", "Is", "iss", "isl", "si", "it", "ri", "ins", "p", "info", "ori", "has", "cms", "web", "os", "im", "ie", "isa", "IS", "ls", "isc", "abs", "inner", "was", "ops", "ar", "its", "i", "mis", "init", "image", "api", "or", "js", "ois", "vs", "close", "bis", "ir", "uri", "ii", "http", "ris", "as", "io", "iso", "id", "in", "iris", "ic", "act", "are", "es", "us", "ios", "lis", "esi", "serv", "ip", "ignore", "il", "isi"], "s": ["sl", "su", "f", "sg", "ts", "si", "rows", "ds", "g", "ins", "session", "m", "services", "sets", "sc", "p", "als", "se", "ns", "results", "ips", "outs", "os", "ows", "ssl", "ls", "ans", "u", "w", "abs", "ies", "les", "sv", "l", "r", "rs", "e", "o", "its", "lines", "strings", "ments", "d", "i", "S", "storage", "ws", "ings", "js", "spec", "h", "cs", "comments", "gs", "n", "ps", "details", "ions", "c", "es", "ss", "sf", "sb", "ches", "ms", "string", "ks", "ses"]}}
{"id1": "17974661", "id2": "9109613", "code1": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"requestServerModifications": ["requestServerModifies", "requestClientModurations", "requestServerModification", "requestServerMutifications", "requestServerModurations", "requestClientmodifications", "requestServerMutification", "requestServerMuturations", "requestClientmodification", "requestClientmodurations", "requestServermodifications", "requestServermodification", "requestServermodurations", "requestServermodifies", "requestClientModifies", "requestClientModifications", "requestClientmodifies", "requestServerMutifies", "requestClientModification"], "sessionId": [" sessionInfo", "sessionID", "connectionId", "sessionName", "connectionInfo", "essionKey", "Sessionid", "SessionId", "essionName", "essionId", "connectionID", "sessionid", "sessionKey", " sessionName", "sessionInfo", "connectionName", "connectionid", " sessionid", "SessionID", "SessionInfo", "essionID", " sessionID", " sessionKey", "connectionKey"], "out": ["lock", "data", "name", "socket", "session", "remote", "ex", "outs", "timeout", "log", "cache", "conn", "again", "output", "user", "content", "writer", "err", "o", "flush", "OUT", "external", "buffer", "image", "path", "exec", "object", "parent", "url", "config", "server", "io", "in", "file", "resource", "result", "report", "Out", "write"], "client": ["connection", "https", "app", "self", "channel", "socket", "session", "handler", "Client", "web", "per", "base", "ssl", "conn", "proxy", "call", "cli", "service", "connect", "api", "request", "driver", "url", "config", "server", "uri", "bird", "io", "http", "c", "ce", "php", "resource", "con", "host"], "builder": ["reader", "building", "filter", "array", "info", "str", "xml", "letter", "base", "log", "b", "keeper", "builders", "built", "r", "writer", "parser", "bean", "address", "row", "buffer", "build", "image", "db", "api", "request", "path", "object", "Builder", "url", "v", "door", "uri", "http", "prefix", "message", "result", "sb", "orb", "length", "string", "runner"], "method": ["connection", "job", "trip", "data", "name", "session", "type", "METHOD", "operation", "stream", "send", "event", "plugin", "user", "wrapper", "instance", "r", "ter", "pull", "service", "call", "build", "api", "request", "process", "path", "url", "view", "server", "http", "function", "module", "message", "resource", "invoke", "string", "use", "end", "Method"], "response": ["full", "connection", "data", "version", "ception", "error", "session", "respond", "stream", "results", "body", "application", "received", "Response", "status", "page", "output", "success", "reply", "service", "found", "entry", "image", "feed", "value", "request", "object", "next", "default", "document", "relation", "server", "view", "http", "wave", "function", "index", "message", "result", "resource", "res", "report", "onse", "json", "serv", "resp", "site"], "header": ["connection", "er", "director", "data", "name", "manager", "version", "error", "handler", "head", "body", "layer", "info", "field", "event", "param", "status", "prev", "inner", "content", "her", "line", "writer", "err", "key", "dr", "buffer", "entry", "block", "hr", "value", "port", "cookie", "h", "request", "second", " Header", "Header", "url", "attribute", "document", "server", "number", "metadata", "holder", "message", "headers", "result", "token", "cover", "host", "forward", "string"], "code": ["be", "x", "Code", "f", "coded", "name", "ception", "error", "reason", "complete", "type", "change", "ge", "state", "mode", "one", "ec", "codes", "ie", "status", "rule", "ide", "zip", "done", "line", " status", "success", "e", "key", "CE", "see", "expected", "reply", "back", "zone", "call", "count", "go", "ode", "age", "cod", "close", "level", "score", "ose", "number", "rate", "c", "xx", "ce", "id", "message", "co", "last", "scene", "result", "cause", "charge", "length", "none", "re", "de"], "expectedLength": ["pectedlength", "actualLength", "pectedLength", "expectedLen", "pectedLen", "actualLen", "actualSize", " expectedlength", " expectedLen", "pectedSize", "expectedlength", " expectedSize", "actuallength", "expectedSize"], "is": ["x", "ire", "mark", "ais", "Is", "data", "iss", "si", "isl", "_", "name", "ri", "error", "s", "bs", "ins", "stream", "non", "info", "not", "os", "im", "set", "isa", "IS", "status", "ish", "isc", "was", "ops", "its", "key", "i", "ci", "select", "ws", "js", "bis", "uri", "io", "ii", "ris", "as", "in", "iso", "id", "params", "iris", "are", "es", "res", "us", "lis", "ms", "ios", "serv", "ip", "fs", "isi"]}}
{"id1": "6171406", "id2": "16623181", "code1": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createTar": [" createJar", "buildJar", "makeHar", "makeJar", "buildHar", "createJar", "buildTar", "makeTar", "createHar", " createHar"], "directoryToPack": ["directionTOSave", " directoryToSave", "dirtoPack", "databaseTopack", "directoryTOPack", "directorySyncPush", "directorySyncpack", "dirToSave", "directorytoZip", "dirtoPush", "directory2Pack", "filenameToPack", "directoryPoPush", "directoryFromPush", "categoryPoPush", "Directorytopack", "dirTopack", " directorytoPack", "directoryTopack", "directory2pack", "filenametopack", "directoryTOSave", "directoryTOpack", "directoryWillPush", "dirToPack", "DirectoryToPack", "filenameTopack", "directorySyncPack", "directoryToHack", "filenametoPack", "directoryOfPack", "directorytoHack", " directorytoHack", "databaseToSave", "directoryFromPack", "directoryTOUse", "directionTopack", " directorytoPush", "dirToPush", "directorytopack", "databaseTOPack", "directionToSave", "directory2Push", "DirectorytoZip", "directoryWillSave", "directionToPush", "categoryPopack", "categoryToPack", "directoryOfUse", "filenameToSave", "categoryToPush", "DirectoryToZip", "directorytoSave", " directoryToPush", "directoryOfSave", "dirtoSave", "categoryTopack", " directorytoUse", " directorytoSave", "databaseToPack", " directorytopack", "directoryFromSave", "directoryOfpack", "directoryWillPack", "directoryWillpack", "dirtopack", "directoryTOPush", "directorytoPush", "directionToPack", " directoryToUse", "directorytoPack", "filenametoPush", "DirectoryToSave", " directoryTopack", "directoryToPush", "directoryWillZip", "directorySyncSave", "DirectorytoSave", "directionTOPack", "directoryPoPack", "categoryPoPack", "directoryPopack", "filenametoSave", "directoryWillHack", "filenameToPush", "directoryTOHack", "directionTOpack", "directoryToUse", "databaseTOpack", "DirectoryTopack", "directoryToZip", "directoryToSave", " directoryToHack", "databaseTOSave", "directory2Save", "directoryFrompack", "directorytoUse", "directionTOPush", "DirectorytoPack"], "targetTarFile": ["targetTargetfile", " targetScarFiles", "targetHarfile", "targetWarPath", "targetHarFile", "argetScarU", " targetHarFiles", "argetTransferString", "targetRaPath", "targetTarString", "targetTarFunction", "targetJarPath", "targetRafile", " targetHarPlace", " targetHarFile", "argetTransferFile", "targetTarFiles", "targetWarFunction", "argetScarFiles", "targetFilePath", " targetTarfile", "argetTarPath", "targetHarEntry", "targetWarString", " targetTarEntry", "targetTransferFile", "argetTarFunction", "argetTarString", "targetScarFile", "targetTransferFiles", "targetJarString", " targetScarPath", "targetScarfile", "targetJarEntry", " targetHarPath", "targetTransferString", " targetHarMessage", "targetTarMessage", " targetTarMessage", "targetJarFunction", "targetFileFile", "targetFilefile", "targetJarFiles", "targetTarPath", " targetHarfile", "targetWarFiles", "argetTarFile", "targetWarFile", "targetTarfile", "targetHarPath", "targetHarPlace", "targetWarfile", "targetWarU", "targetHarU", "targetScarFiles", " targetTarPath", "targetTargetPath", " targetScarfile", "targetJarFile", "argetScarPath", "targetJarfile", "argetTransferFunction", " targetScarFile", "targetScarPath", " targetTarFiles", "targetRaMessage", "targetTargetPlace", "targetScarPlace", "targetTarPlace", "targetTransferFunction", "targetScarU", "argetTarU", "targetRaFile", " targetHarEntry", "targetHarFiles", "targetFileEntry", "argetScarFile", "argetTarFiles", "targetTarEntry", " targetTarPlace", "argetTransferFiles", "targetTargetFile", "targetTarU", "targetWarPlace", "targetHarMessage"], "buffer": ["offset", "data", "channel", "type", "reference", "array", "buff", "info", "Buffer", "position", "copy", "cache", "writer", "key", "address", "source", "block", "map", "image", "object", "memory", "header", "input", "resource", "queue", "length", "buf"], "targetOutput": ["targetFile", "externalOutput", "targetInput", " targetFile", "sourceoutput", "externalFile", " targetTar", "sourceTar", "tarOutput", "TargetInput", "taroutput", "tarInput", "sourceInput", "TargetOutput", "TargetFile", "tarTar", "externalInput", "targetTar", "externaloutput", "targetoutput", " targetoutput", "Targetoutput", " targetInput", "sourceOutput"], "targetOutputTar": ["targetConnectionFile", "targetOutputT", " targetInputTar", " targetOutputHar", "targetoutputStream", " targetOutputStream", "TargetOutputFile", "targetInputFile", "targetoutputTar", "TargetOutputDirectory", "targetOutputFile", "targetOutputHar", "targetConnectionHar", "targetConnectionStream", "targetoutputFile", "targetoutputT", "TargetOutputTar", "TargetOutputT", "targetInputDirectory", "targetConnectionTar", "targetInputHar", "targetOutputStream", " targetInputFile", " targetOutputFile", "targetoutputHar", "TargetoutputTar", "targetInputTar", " targetInputStream", "targetoutputDirectory", "TargetoutputT", " targetInputHar", "targetInputT", "targetInputStream", "targetOutputDirectory", "TargetoutputFile", "TargetoutputDirectory"], "fileList": [" fileQueue", "queueList", "filelist", "fileSet", "FileStream", "dirStream", "dirSet", "queueQueue", " fileChain", " fileSet", " fileSt", "FileSet", "fileChain", "FileList", " filelist", "FileSt", "fileSt", "FileChain", "fileQueue", "fileStream", "dirList", " fileStream", "dirSt", "Filelist", "FileQueue", "queuelist", "queueChain"], "iter": ["reader", "er", "keep", "loc", "ver", "it", "ator", "gener", "info", "upper", "set", "ipper", "loop", "walker", "loader", "inner", "former", "her", "ite", "r", "e", "err", "ter", "izer", "list", "i", "ner", "init", "inc", "chain", "outer", "oper", "order", "other", "enter", "iterator", "li", "ir", "ser", "finder", "itter", "ele", "cher", "Iter", "coll", "inter", "dir", "skip", "ider", "ler", "ip", "over"], "file": ["current", "data", "name", "self", "archive", "type", "only", "letter", "binary", "class", "format", "b", "single", "flow", "service", "source", "ile", "path", "url", "uri", "route", "flat", "function", "module", "message", "item", "resource", "queue", "directory", "element", "profile", "it", "File", "handler", "session", "play", "py", "stream", "fe", "local", "log", "page", "cache", "entity", "zip", "key", "back", "pull", "template", "project", "parent", "document", "let", "folder", "use", "il", "f", "_", "place", "un", "complete", "remote", "phase", "info", "fil", "plain", "model", "part", "check", "root", "line", "e", "show", "style", "image", "live", "http", "ball", "same", "FILE", "dir", "fp", "full", "connection", "er", "get", "force", "where", "change", "layer", "application", "base", "plugin", "future", "files", "l", "comment", "entry", "db", "child", "filename", "object", "core", "pe", "index", "link", "string"], "filePathInTar": ["fileNameInEar", "filePathINHar", "fileNameInPrivate", "filePathinTar", "filePathedInEar", "filePathintar", "filePathInTr", "filepathedIntar", "filepathinTr", "filePathOutsidePrivate", "filePathInHar", "filePathInPrivate", "filePathINJar", "filePathInsideTr", "filepathInHar", "filePathForEar", "filepathedInJar", "filePathINTar", "fileNameInJar", "filepathinJar", "filePathedInTr", "fileNameInTar", "fileNameedInPrivate", "filepathInTr", "filePathInsideJar", "filepathInJar", "filepathedInTar", "filePathOutsideTar", "filePathForPrivate", "filePathedIntar", "filePathedInTar", "filePathedInPrivate", "filepathinTar", "filePathInsideTar", "filePathinHar", "filePathOutsideEar", "filePathedInJar", "filepathedInHar", "fileNameedInEar", "fileNameedInTar", "filePathINtar", "fileNameedInJar", "filePathIntar", "filePathInJar", "filePathForTar", "filepathInTar", "filepathIntar", "filePathInEar", "filePathinJar", "filePathOutsideJar", "filePathedInHar", "filePathinTr", "filePathForJar"], "tarAdd": ["tarCopy", "tarCreate", " tarAdded", "catadd", "arAdd", "catCopy", "catAdded", "parseCreate", "carCreate", "carAdd", "TarCopy", "TarAdd", "parseAdd", "tarAdded", "drCreate", "carAdded", "parseEntry", " tarEntry", "drAdd", "TarAdded", "rarAdded", "arCopy", "rarEntry", "carEntry", "aradd", "drAdded", " tarCreate", "parseAdded", "rarCreate", "drEntry", "Taradd", "taradd", "arAdded", "tarEntry", "catAdd", "rarAdd"], "in": ["bin", "outside", "sin", "it", "at", "s", "ins", "from", "In", "en", "under", "gen", "per", "is", "inside", "inline", "ans", "inner", "by", "and", "IN", "this", "d", "sub", "inc", "yn", "nin", "of", "ass", "n", "thin", "inn", "an", "the", "id", "index", "on", "out", "inv", "internal", "gin"]}}
{"id1": "16232202", "id2": "11865906", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "code2": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"doPost": ["doPOST", " doPut", "doSend", "doingPost", "didSend", "didPut", "doPut", "doingPOST", " doPOST", "doingSend", "doingPut", "didPost", "didPOST", " doSend"], "request": ["reader", "save", "er", "data", "current", "get", "self", "q", "error", "session", "complete", "QUEST", "method", "type", "press", "create", "remote", "info", "application", "web", "state", "event", "load", "xml", "req", "page", "register", "user", "rf", "instance", "query", "e", "client", "subject", "external", "list", "condition", "row", "parse", "image", "select", "child", "submit", "parent", "object", "project", "order", "next", "Request", "url", "enter", "context", "view", "server", "hello", "post", "route", "rate", "store", "message", "upload", "result", "input", "resource", "initial", "queue", "join", "report", "you", "re", "use"], "response": ["fire", "su", "tree", "ception", "pool", "error", "session", "respond", "complete", "body", "application", "web", "ae", "en", "Response", "status", "model", "page", "output", "writer", "shell", "query", "e", "subject", "reply", "service", "we", "image", "wa", "feed", "api", "parent", "environment", "object", "next", "exit", "document", "view", "server", "uri", "http", " Response", "index", "message", "result", "resource", "res", "report", "onse", "forward", "re", "esi", "serv", "de", "resp", "site"], "cu": ["ul", "cur", "su", "aca", "loc", "CU", "cum", "uu", "cca", "ca", "cin", "ru", "rc", "lc", "cci", "u", "agu", "U", "asu", "usa", "lu", "Cu", "cli", "ci", "cc", "vc", "uc", "cf", "ucc", "xc", "ku", "ue", "ui", "UC", "du", "uci", "c", "eu", "ce", "VC", "hu", "chu", "co", "tc", "cul", "coll", "ou", "mc", "CA", "cy", "CI", "ac", "uni", "cus", "nu", "tu", "gu"], "ud": ["UD", "df", "su", "vd", "util", "ub", "udi", "gb", "uu", "ur", "dd", "ut", "da", "ck", "ru", "pub", "utils", "rc", "ug", "wik", "usc", "u", "user", "bug", "asu", "usa", "um", "lu", "uli", "cli", "ci", "storage", "db", "ada", "uc", "ku", "uds", "uda", "ui", "ue", "li", "uri", "du", "uv", "eu", "au", "chu", "upload", "uf", "uid", "ou", "us", "usr", "pd", "auth", "ad", "od", "stri", "cus", "tu", "gu"], "returnTo": ["replyto", "replyTO", "returnTO", "exitTo", "outputto", "replyTo", "outputTO", "outputTo", "ReturnTo", "accessFrom", "returnto", "exitFrom", "ReturnTO", "accessTo", "backTO", "returnFrom", "Returnto", "backTo", "accessTO", "backto", "replyFrom", "accessto", "outputFrom", "exitTO", "exitto", "backFrom", "ReturnFrom"], "password": ["wallet", "login", "data", "name", "email", "wd", "encrypted", "user", "Password", "mac", "mask", "account", "key", "patch", "address", "secret", "crypt", "padding", "sword", "phrase", "PASS", "sum", "ass", "code", "null", "params", "word", "pa", "message", "sha", "token", "diff", "pad", "auth", "pg", "string", "confirmed", "username"], "md": [" Md", "meta", "df", "bd", "vd", "f", "mag", "mg", "cd", "rm", "wd", "mad", "dd", "m", "ma", " MD", "mt", "dig", "mb", "am", "mac", "managed", "cmd", "dm", "mn", "sm", "d", "dc", "MD", "db", "mo", "amd", "mp", "rpm", "mm", "sha", "diff", "mc", "ms", "od", "mand", "hd", "pg"], "hash": ["rh", "tag", "hed", "version", "char", "array", "hex", "base", "dig", "cache", "user", "mac", "her", "kh", "dot", "key", "secret", "row", "block", "db", "h", "confirmed", "url", "no", "sum", "ass", "number", "code", "raw", "sha", "ash", "diff", "total", "ref", "auth", "Hash", "sh"], "pass": ["sl", "login", " Pass", "wd", " passed", " def", " mac", "gen", "Pass", "az", "conn", "user", "text", "conf", "mess", " login", "mac", "r", "key", "secret", "row", "db", "ask", " secret", "phrase", "PASS", "sum", "ass", "sign", " auth", "id", "pos", "pa", " mess", "ss", "fail", "diff", "def", "ref", "auth", "push", "string", "strip", "act"], "vis": ["VIS", "su", "qa", "keep", "name", "fac", "tri", "type", "press", "na", "state", "ex", "mit", "miss", "lab", "class", "status", "san", "feat", "nav", "nat", "vest", "vert", "Vis", "acc", "travel", "shape", "vid", "att", "see", "circ", "design", "secret", "dc", "style", "mis", "wa", "spot", "nic", "cross", "sign", "view", "ravis", "c", "act", "id", "stat", "lit", "coll", "virt", "host", "ref", "exp", "visible", "skip", "access", "ip", "rib", "gu"]}}
{"id1": "5142039", "id2": "14619453", "code1": "    public static String uncompress(String readPath, boolean mkdir) throws Exception {\n        ZipArchiveInputStream arcInputStream = new ZipArchiveInputStream(new FileInputStream(readPath));\n        BufferedInputStream bis = new BufferedInputStream(arcInputStream);\n        File baseDir = new File(readPath).getParentFile();\n        String basePath = baseDir.getPath() + \"/\";\n        if (mkdir) {\n            String[] schema = readPath.split(\"/\");\n            String baseName = schema[schema.length - 1].replaceAll(\".zip\", \"\");\n            FileUtils.forceMkdir(new File(basePath + baseName));\n            basePath = basePath + baseName + \"/\";\n        }\n        ArchiveEntry entry;\n        while ((entry = arcInputStream.getNextEntry()) != null) {\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(basePath + entry.getName()));\n            } else {\n                String writePath = basePath + entry.getName();\n                String dirName = FilenameUtils.getPath(writePath);\n                FileUtils.forceMkdir(new File(dirName));\n                BufferedOutputStream bos = new BufferedOutputStream(FileUtils.openOutputStream(new File(writePath)));\n                int i = 0;\n                while ((i = bis.read()) != -1) {\n                    bos.write(i);\n                }\n                IOUtils.closeQuietly(bos);\n            }\n        }\n        IOUtils.closeQuietly(bis);\n        return basePath;\n    }\n", "code2": "    public Set<String> getAvailableRoles() {\n        if (availableRoles == null) {\n            availableRoles = new HashSet<String>();\n            try {\n                Enumeration<URL> resources = org.springframework.util.ClassUtils.getDefaultClassLoader().getResources(ROLE_FILE_LOCATION);\n                while (resources.hasMoreElements()) {\n                    URL url = resources.nextElement();\n                    InputStream is = null;\n                    try {\n                        URLConnection con = url.openConnection();\n                        con.setUseCaches(false);\n                        is = con.getInputStream();\n                        List<String> lines = IOUtils.readLines(is, \"ISO-8859-1\");\n                        if (lines != null) {\n                            for (String line : lines) {\n                                availableRoles.add(line.trim());\n                            }\n                        }\n                    } finally {\n                        if (is != null) {\n                            is.close();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return availableRoles;\n    }\n", "label": 0, "substitutes": {"uncompress": [" uncompression", " unompress", "uncompzip", " unompressed", "unompress", " uncompressed", " uncompzip", "unompzip", "uncopressed", " unompression", "unompressed", "uncopression", "unCompress", " unompzip", "uncompressed", "unCompzip", "uncopzip", "unCompression", "unompression", "uncopress", "uncompression", "unCompressed"], "readPath": ["loadPo", "scanDir", "readerPath", "baseTree", "writeCase", "baseFile", "readPo", "checkFile", "checkPo", "scanCase", "scanpath", "workPath", "readerFile", "readFile", "readDir", "loadCase", "readerpath", "readpath", "loadDir", "scanPath", "baseWith", "checkDir", "writeFile", "readWith", "writepath", " readFile", " readpath", "basepath", "readTree", " readWith", "workpath", "readerTree", "writeDir", "workFile", "workTree", "readCase", "checkPath", "loadpath", "writePo", "loadPath", "loadWith", "loadFile"], "mkdir": ["kkdir", "mutdir", "muturl", "kkzip", " mkurl", " mkrel", "kkDir", "MKzip", "ckDir", " mkDir", "MKDir", "mkrel", "mutDir", "mutdb", "mkzip", "ckurl", " mkdb", "mkurl", "kkrel", "ckdir", " mkzip", "MKdir", "ckdb", "MKrel", "mkdb", "mkDir"], "arcInputStream": ["arcImportChannel", "arcInputSteam", "cInputSteam", "arcFileSt", "cOutputSteam", "ancOutputFile", "ancOutputForm", "arcFileStream", "arcOutputForm", "ancOutputStream", "arcFileSync", "cOutputStream", "arcInputFile", "arcReadSt", "ancOutputstream", "arcOutputstream", "cOutputSt", "arcInputChannel", "ancInputFile", "ancOutputSteam", "cInputSt", "ancInputForm", "arcHttpSteam", "arcImportStream", "arcReadSync", "arcOutputSt", "ancInputstream", "arcOutputStream", "cOutputSync", "arcReaderstream", "ancInputStream", "arcOutputChannel", "cInputStream", "arcReaderChannel", "arcOutputFile", "arcInputstream", "arcInputSt", "arcInputSync", "arcReadStream", "arcImportstream", "arcReaderStream", "arcHttpStream", "cInputSync", "arcOutputSync", "ancInputSteam", "arcReaderFile", "arcHttpstream", "arcImportFile", "ancInputChannel", "arcInputForm", "arcOutputSteam", "arcReadForm", "arcReadstream", "arcHttpForm", "arcFileSteam", "arcReadSteam", "ancOutputChannel"], "bis": ["isin", "cb", "BUS", "cos", "oss", "bs", "ins", "boot", "ubs", "raf", "idis", "os", "lins", "binary", "kos", "is", "bb", "bi", "ls", "abs", "parts", "bits", "obs", "lus", "phis", "ubis", "bus", "abi", "ras", "pins", "bid", "mis", "phys", "uds", "alis", "vs", "ois", "banks", "bps", "ris", "oris", "ours", "ros", "sis", "ios", "usb", "onis", "obb", "fb", "ses"], "baseDir": ["fileFolder", "rootDir", " baseDirectory", "fileDirectory", "rootFolder", "BaseDirectory", "fileDir", "Basedir", " baseFolder", "baseFolder", "BasePath", "rootDirectory", "filedir", "BaseFolder", "BaseDir", " basedir", "baseDirectory", "basedir", "rootPath"], "basePath": ["basicDir", "BaseCondition", "readInfo", "baseHost", "BaseFile", "baseInfo", "outDir", " baseType", "parentFile", "fileName", "basicInfo", "baseFile", "parentPath", "baseUrl", "BaseUrl", "basicPath", "resourcePath", " basepath", "baseStream", "readUrl", "buildHost", "baseCondition", "basedHost", "outPath", "parentName", "fileDir", "readDir", "writeHome", "viewOrder", "Basepath", "basicCondition", "baseType", " baseHost", "writeStream", "viewHome", " baseFile", "basedDir", "BasePath", "viewStream", " baseStream", "outUrl", "resourcepath", "baseHome", "buildDir", "fileUrl", "filePath", "parentUrl", "viewPath", " baseHome", "outName", "BaseDir", "resourceName", " baseUrl", "basedType", "baseOrder", "buildPath", "writeOrder", "BaseName", "BaseInfo", " baseOrder", "readName", "basedPath", "buildType", "readCondition", "resourceDir", "basepath"], "schema": ["syme", "syaga", "Scheme", " schemar", "chemar", "syma", "mamas", " schemas", "Schemar", "symas", "scheme", "mapa", "scheaga", "cheme", "issme", "issma", "cheaga", "isspa", "schemar", "Schemas", "Scheaga", " scheme", "chemas", "mama", "Schepa", "schemas", "issmas", "chema", "schepa", "Schema", "mame"], "baseName": ["normalPath", " baseInfo", "basPath", "baseInfo", "basInfo", "normalName", "basName", "corePath", " baseTitle", "basicPath", "normalTitle", "areaKey", "coreName", "normalKey", "basicKey", "coreInfo", "baseTitle", "BasePath", "BaseTitle", "areaPath", "basicName", "baseKey", "areaName", "coreDir", "basDir", "BaseKey", "BaseName", " baseKey"], "entry": ["nt", "reader", "connection", "extra", "office", "le", "data", "name", "it", "si", "card", "archive", "install", "ries", "info", "ge", "se", "ae", "letter", "ie", "base", "lc", "add", "Entry", "part", "inner", "entity", "je", "sea", "zip", "her", "ace", "line", "article", "e", "section", "key", "la", "journal", "row", "comment", "parse", "style", "service", "feed", "child", "or", "inc", "path", "editor", "object", "next", "system", "no", "enter", "iterator", "uri", "server", "post", "pe", "index", "valid", "ry", "cel", "result", "record", "obj", "exp", "ent", "de", "element"], "writePath": ["writerEx", "writingPath", "writingDir", " writeEx", "writeName", "writeCase", "WriteDir", "writeEx", " writeCh", "baseStream", "writtenPoint", "writtenName", "readDir", "writeCh", " writeDir", "writerCh", "readPoint", "writeStream", " writePoint", "writePoint", "WriteCh", "readStream", "WriteEx", "writingPoint", "writerDir", "writerPath", "writeDir", "readCase", "writtenStream", "writingCase", " writeCase", "writtenPath", "readName", "WritePath", "basePoint"], "dirName": ["DIRPath", "DirAlias", "dirUrl", "Dirname", "orderUrl", " dirDef", "dirDef", " dirname", "dirAlias", "DirName", "DIRAlias", "ordername", " dirPath", "DIRDef", " dirUrl", " dirAlias", "orderName", "DIRName", "dirname", "dirPath", "DirUrl", "DirPath", "DirDef"], "bos": ["bott", "osa", "opus", "fits", "las", "gb", "bes", "oos", "asio", "bs", "bies", "boot", "ubs", "rots", "os", "lins", "obos", "kos", "atis", "bb", "bi", "ko", "obs", "dies", "oks", "ubis", "nas", "bas", "ois", "uds", "obo", "banks", "osi", "aos", "bo", "ros", "boards", "los", "ios", "zo", "zos", "oids", "obb", "obi", "bc", "bones"], "i": ["x", "ji", "f", "si", "it", "start", "ri", "batch", "mini", "slice", "s", "p", "info", "j", "pi", "is", "hi", "I", "bi", "di", "b", "multi", "inner", "qi", "l", "r", "e", "o", "ini", "abi", "ci", "z", "limit", "exec", "xi", "v", "ui", "li", "zi", "uri", "ii", "io", "c", "in", "ni", "id", "index", "chi", "a", "ai", "phi", "length", "you", "ip"]}}
{"id1": "11183087", "id2": "6987642", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"doPost": ["doPOST", "doingSearch", " doPut", "doingPost", "handlePut", "doingPOST", "doPut", " doPOST", "handlePOST", "handlePost", "doingPut", " doSearch", "handleSearch", "doSearch"], "request": ["er", "data", "get", "current", "q", "error", "complete", "QUEST", "type", "create", "remote", "press", "info", "application", "web", "state", "event", "xml", "req", "model", "user", "rf", "instance", "r", "query", "e", "client", "subject", "pull", "external", "call", "buffer", "image", "child", "project", "object", "parent", "order", "Request", "url", "enter", "config", "view", "server", "hello", "post", "route", "rate", "pe", "http", "the", "right", "message", "frame", "context", "result", "input", "resource", "initial", "queue", "join", "report", "forward", "use", "have"], "response": ["connection", "pool", "respond", "body", "results", "application", "web", "Response", "status", "model", "page", "output", "writer", "client", "reply", "template", "api", "parent", "object", "next", "document", "view", "server", "http", "message", "guide", "result", "resource", "res", "report", "onse", "resp", "site"], "senha": ["sanha", "tonha", "zenHa", "suitsha", "zenha", " senwa", "snhi", "snha", "suithi", "sensha", "tonHa", "zenla", "snla", "zenca", "tonlah", "tonwa", " senlah", "renha", "senla", "senlah", " senaka", "sanwa", "zenhi", "renaka", "zenaka", "renHa", " senHa", "senHa", "sanlah", " senca", "zensha", "senaka", "suitla", "snsha", "sanHa", "senhi", "renca", "senca", "senwa", "suitha"], "email": ["office", "login", "data", "name", "language", "xml", "label", "Email", "letter", "model", "user", "mail", "zip", "alias", "line", "account", "password", "e", "address", "secret", "service", "fax", "business", "mobile", "example", "phrase", "environment", "url", "hello", "server", "file", "id", "message", "home", "string", "ip", "username"], "messageDigest": ["messageDend", "meDigher", "messagedigester", "meDigest", " messagedigEST", " messageDester", "medigester", " messagedigest", " messageDEST", "messageMailEST", " messageDest", "messagedigend", "messageDigester", "medigest", "medigher", "messagedigest", "messageDEST", "medigEST", " messageDigEST", "messageDher", "messageDigEST", "messageMailester", "messagedigEST", " messageDigester", "messageMailest", " messagedigester", "messageDigend", "meDigEST", "messageMailend", " messageDigend", "messagedigher", "messageDigher", "messageDester", " messageDend", "messageDest", "meDigester"], "usuario": ["ususillo", "usuirio", " usuiasio", "suluario", "usueario", "usguarius", "usguario", "usuiasio", "usuitasio", "ususarius", "usuariat", "sulurio", "usuiario", "usuitarium", " usuasio", " usuarius", "usituasio", " usuariat", "usuearius", "ussurio", "suuasio", " usuiario", "suurio", "usiturio", " ususarius", "uslurio", "ussuarium", "usuarial", "usluario", "ussuario", "usuarium", "usuiarium", "usuitrio", "usituario", "usueariat", "ussuasio", "suluarial", " usurio", " ususariat", "usuarius", "usguillo", "usluarial", "suuarial", "suuario", " ususario", "usurio", " usuarium", "usuasio", " usuirio", "usluasio", " ususillo", "ussuarial", " usuiarium", "usguariat", "ususariat", "usituarial", "usuitario", "usuillo", " usuillo", "usueillo", "suluasio", "ususario"], "redirect": ["reroute", "indrict", "predroute", " redurl", "Redirect", "indirection", "preduce", "predrict", "reirect", "redition", " redition", "redRECT", "RedRECT", " reduce", "edirection", "rerict", "Redroute", "Redirection", "predirect", "redurl", "induce", "Redition", "predRECT", "Redrict", "reduce", "indirect", " redirection", " redrict", "edurl", "reirection", "edition", "Redurl", " redRECT", "edirect", "redirection", "redroute", "redrict", "predirection"], "session": ["connection", "app", "sl", "data", "info", "state", "event", "Session", "ssl", "page", "cache", "user", "query", "client", "proxy", "service", "storage", "sp", "comment", "image", "child", "cookie", "object", "system", "config", "document", "view", "server", "group", "browser", "ession", "http", "person", "flash", "message", "result", "input", "sid", "use", "node", "site"]}}
{"id1": "14303294", "id2": "11933797", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"getServerHash": ["getSessionAddress", "getSessionSHA", " getSecureAddress", "getserverAddress", " getServerSalt", " getSecureSalt", "getSessionSalt", "getSecureSalt", "getserverSHA", "getServerSalt", " getServerSHA", "getSecureAddress", " getServerAddress", "getserverHash", "getserverSalt", "getSessionHash", "getSecureHash", " getSecureSHA", " getSecureHash", "getSecureSHA", "getServerAddress", "getServerSHA"], "passwordHash": ["privatehash", " PasswordCode", "privatePassword", "privateHash", "Passwordhash", "passwordPassword", " passwordhash", "passwordCode", "PasswordCode", "privateSalt", " PasswordHash", "passwordPass", "PasswordPass", "passwordhash", " passwordPassword", " passwordCode", "passwordSalt", " passwordPass", " PasswordPass", "PasswordPassword", "PasswordHash", " passwordSalt"], "PasswordSalt": [" PasswordPassword", " Password256", " PasswordSecret", "passwordPassword", " PasswordHash", "passwordSecret", "PASSSalt", " passwordSecret", "Password256", "password256", " passwordPassword", "PASSPassword", "passwordSalt", "PasswordSecret", "PasswordPassword", "PASS256", "PasswordHash", "PASSHash", " passwordSalt"], "hash": ["data", "ha", "pool", "error", "array", "change", "hex", "base", "log", "dig", "copy", "html", "cache", "check", "user", "size", "content", "her", "kh", "mac", "work", "password", "key", "address", "crypt", "row", "buffer", "build", "image", "block", "value", "response", "h", "url", "update", "sum", "number", "code", "search", "message", "sha", "result", "ash", "auth", "Hash", "string", "sh"], "digest": ["mdest", "generest", " diger", "digener", "Digester", "Digusher", "generester", "hashester", "digested", " digusher", "integester", "integested", "digester", "hashener", "mdested", "Digener", "integall", "mdester", "hasher", " digger", "digger", "signester", "digher", "digall", "Digested", " digall", "integest", "diger", "Digger", "digusher", "signer", "signher", "Diger", "signest", "signger", "Digher", "hashest", "generested", "generall", " digener", " digested", " digester", "Digest", "mdusher", " digher"]}}
{"id1": "2017833", "id2": "17029388", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    public static InputStream getConfigIs(String path, String name) throws ProgrammerException, DesignerException, UserException {\n        InputStream is = null;\n        try {\n            URL url = getConfigResource(new MonadUri(path).append(name));\n            if (url != null) {\n                is = url.openStream();\n            }\n        } catch (IOException e) {\n            throw new ProgrammerException(e);\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"hash": ["get", "create", "string", "str", "dump", "hex", "set", "base", "add", "format", "check", "crypt", "parse", "build", "block", "h", "sum", "update", "number", "transform", "message", "sha", "ash", "replace", "print", "Hash", "html"], "text": ["ext", " TEXT", "data", "name", "version", "str", " Text", "hex", "letter", "class", "binary", "format", "output", "contract", "txt", "content", "bytes", "EXT", "translation", "password", "key", "secret", "test", "buffer", "source", "image", "template", "value", "Text", "editor", "path", "struct", "object", "pattern", "context", "url", "number", "code", "word", "message", "token", "TEXT", "input", "out", "length", "string", "font"], "UnsupportedEncodingException": ["UnsupportedEncodedception", "UnsupportedEncasingWarning", "UnsupportedEncasingException", "UnsupportedEncodedWarning", "UnsupportedencodedException", "UnsupportedEncodingception", "UnsupportedEncgorithmception", "UnsupportedEncgorithmWarning", "UnsupportedencodingWarning", "UnsupportedEncodedException", "UnsupportedEncodingWarning", "UnsupportedencodingException", "UnsupportedEncgorithmException", "UnsupportedEncasingception", "Unsupportedencodedception", "UnsupportedencodedWarning", "Unsupportedencodingception"], "md": ["bm", "meta", "bd", "vd", "f", "mag", "mg", "rm", "ds", "wd", "mad", "dd", "m", "ma", " MD", "mt", "ind", "ld", "dig", "mb", "am", "mac", "hm", "cmd", "dm", "um", "d", "MD", "gd", "mo", "mod", "amd", "mp", "metadata", "mm", "pm", "message", "sha", "bf", "mc", "ms", "od", "mand", "ad", "hd", "nm"], "sha1hash": ["sha2h", "ha2match", "SHA1hex", "sha256Hash", "sha4hash", "shaonematch", "sha2hex", "sha1sum", "sha1hex", "ha2hex", "sha2match", "SHA2h", "shaonesum", "sha3match", "SHA2Hash", "ha1sum", "sha3hex", "sha256hash", "sha256h", "sha5Hash", "shaonehex", "sha5h", "SHA1sum", "sha3hash", "sha4hex", "sha5hex", "sha5sum", "SHA1h", "sha256sum", "ha1hex", "sha4Hash", "SHA1Hash", "sha2sum", "ha2hash", "sha3sum", "sha1match", "ha2sum", "ha1hash", "SHA1hash", "sha1h", "sha2Hash", "sha1Hash", "sha4sum", "SHA2sum", "SHA2hash", "sha5hash", "sha2hash", "shaonehash", "ha1match"]}}
{"id1": "6379126", "id2": "15757836", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    private int[] sort(int n) {\n        int[] mas = new int[n];\n        Random rand = new Random();\n        for (int i = 0; i < n; i++) {\n            mas[i] = rand.nextInt(10) + 1;\n        }\n        boolean t = true;\n        int tmp = 0;\n        while (t) {\n            t = false;\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    tmp = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = tmp;\n                    t = true;\n                }\n            }\n        }\n        return mas;\n    }\n", "label": 0, "substitutes": {"gerarTutorialPage": ["riarTourpage", "riarTutorialElement", "riarTravisElement", "riarTravisDir", "riartutorialDir", "riarTourElement", "riarTravisPage", "riarTutorialpage", "riartourpage", "riarTutorialPage", "riartutorialPage", "riartourElement", "riarTinyPage", "riarTinyDir", "riartutorialElement", "riartourDir", "riartourPage", "riarTourDir", "riarTravispage", "riarTourPage", "riartutorialpage", "riarTinypage", "riarTutorialDir", "riarTinyElement"], "indexDir": ["indexTier", "includeDir", "zipDIR", "zipDir", "indexJar", "includeJar", "IndexJar", "IndexDIR", "indexDIR", "includeTier", "zipTier", "includeDIR", "IndexDir", "IndexTier", "zipJar"], "cssDir": ["gzDir", "javascriptDar", "CSSDar", "cssDIR", "catsDir", "piecesDie", "codesDoc", "piecesDIR", "piecesD", "codesDir", "fontDie", "cssDie", "cssUrl", "gzDirectory", "ssDirectory", "fontDir", "javascriptDir", "CSSUrl", "CSSDb", "cssLen", "fontD", "cssD", "catsDoc", "ssUrl", "javascriptDb", "cssDoc", "ssDIR", "cssDar", "gzUrl", "cssDb", "javascriptDIR", "piecesDir", "gzDIR", "fontDIR", "catsLen", "CSSDir", "CSSDirectory", "ssDb", "ssDie", "ssDir", "cssDirectory", "CSSLen", "CSSDoc", "codesLen", "ssD", "ssDar", "CSSDIR"], "capDir": ["apsVol", "apsDir", "casDirectory", "casDir", "apsDirectory", "capDirectory", "CapVol", "casdir", "capVol", "capdir", "CapDirectory", "apsdir", "casVol", "Capdir", "CapDir"], "licDir": ["lifDoc", "licDoc", "volDoc", "volDir", "voldir", "lifdir", "lifManager", "libdir", "libDoc", "volManager", "licdir", "licManager", "lifDir", "libDir", "libManager"], "midDir": ["casTier", "middir", "midTier", "limTier", "mindDIR", "casDir", "limDIR", "mindTier", "casdir", "mindDir", "limDir", "casDIR", "minddir", "limdir", "midDIR"], "filesDir": ["filesDIR", " filesPos", "stylesDir", "opensDirectory", "locksDir", "videosFolder", "pagesPos", "stylesDur", "locksDirectory", "FilesDir", "filesDur", "imagesDirectory", "imagesFolder", "locksDur", "pagesDir", "filesDirectory", "filesFolder", "opensDir", "videosFile", "FilesDirectory", "imagesDir", "pagesVol", "stylesDirectory", "locksDIR", "filesPos", "opensDur", "stylesDIR", "ballsVol", "imagesFile", "FilesFile", "ballsPos", "filesFile", " filesVol", "ballsDir", "videosDirectory", "FilesFolder", "opensDIR", "filesVol"], "videosDir": ["imagesDb", "viewsDirectory", "videosUrl", "videoDir", "videoUrl", " videosDb", "videosFile", "imagesDir", " videosUrl", "videoDirectory", "viewsUrl", " videosFile", "videosDb", "videoFile", " videosDirectory", "videosDirectory", "viewsDir", "viewsFile", "videoDb"], "imagensDir": ["imgensFile", "imagersDIR", "imagersDir", "imagenJar", "imgentsDir", "imagersFile", "imgentsFile", "imagenciesDIR", "imgensDIR", "imagenDir", "imagersJar", "imagentsJar", "imagenciesDir", " imagensDirectory", "imagersDirectory", "imagentsDir", "imagentsFile", "imagentsDirectory", "imagenciesDirectory", "imgensDir", "imgentsDIR", "imgentsDirectory", "imagensJar", " imagersJar", "imagensDIR", "imgensDirectory", " imagensFile", "imagensFile", "imagensDirectory", " imagersFile", " imagensJar", " imagersDirectory", "imagentsDIR", "imagenDirectory", " imagersDir", "imagenFile", "imagenciesFile"], "local": ["active", "lock", "localhost", " Local", "standard", "specified", "loc", "name", "data", "current", "present", "util", "where", "basic", "self", "remote", "input", "p", "partial", "personal", "state", "shared", "base", "log", "part", "user", "inner", "conf", "managed", "LOC", "l", "back", "temp", "defined", "d", "relative", "request", "path", "serial", "pal", "small", "tmp", "pass", "http", "Local", "file", "global", "prefix", "valid", "same", "Location", "upload", "safe", "dir", "initial", "total", "home", "directory", "location", "available", "internal", "json", "username"], "srcCss1": ["srcCcss4", "srcCfgPre", "srcCse1", "srcCcss0", "srcCass1", "srcCcss11", "srcCse2", "srcCpe2", "srcPcssPre", "srcCrss2", "srcPss81", "srcPcss81", "srcCrss3", "srcRss81", "srcRss2", "srcCse11", "srcPss4", "srcCcss1", "srcRss1", "srcCfg2", "srcCass0", "srcPss2", "srcCcss81", "srcCcssPre", "srcCss81", "srcCrss1", "srcCrss81", "srcPcss1", "srcCass11", "srcRss0", "srcCss11", "srcPssPre", "srcPcss3", "srcPss3", "srcCpe4", "srcCass3", "srcCfg4", "srcCfg1", "srcCass81", "srcCss0", "srcRcss11", "srcPss1", "srcCpe1", "srcRcss1", "srcRcss0", "srcCcss2", "srcPcss2", "srcRss11", "srcRcss2", "srcCrss11", "srcCcss3", "srcCass2", "srcCpePre", "srcRcss81", "srcCse0", "srcCssPre", "srcPcss4"], "destCss1": ["destCxx2", "destPssCard", "destPcss1", "destCfg0", "destCrss2", "destCcss1", "destCcss2", "destPcss0", "destCcss0", "destCrss81", "destCcss81", "destCass3", "destCfg2", "destPcssCard", "destCass1", "destCassCard", "destCcss3", "destPcss2", "destCxxCard", "destCss0", "destCss81", "destCxx1", "destCxx3", "destCrss1", "destCfg3", "destPss81", "destCass2", "destPcss81", "destPcss3", "destPss3", "destCcssCard", "destPss0", "destPss1", "destCrss0", "destPss2", "destCssCard", "destCass81", "destCrss3", "destCfg1"], "srcCss2": ["srcUss1", "srcCcss4", "srcCfgL", "srcChessTwo", "srcChess1", "srcCass1", "srcCrss2", "srcCrss3", "srcPssL", "srcPcssL", "srcCssL", "srcUcss1", "srcCcss1", "srcCssB", "srcUcssB", "srcCass4", "srcUssTwo", "srcCfg2", "srcCcss52", "srcCss27", "srcPss2", "srcAccss52", "srcCross52", "srcCross4", "srcAcss1", "srcCrss27", "srcCfg3", "srcCrss1", "srcPcss27", "srcCssTwo", "srcPcss1", "srcPcss3", "srcCcssB", "srcPss3", "srcCng27", "srcCng1", "srcAcss4", "srcCfg1", "srcCross2", "srcChessB", "srcPss1", "srcAcss2", "srcCass52", "srcCcssTwo", "srcCng2", "srcCss52", "srcCcss2", "srcPcss2", "srcAccss2", "srcCfgB", "srcCcss27", "srcCrssL", "srcCcss3", "srcCcssL", "srcUss2", "srcCass2", "srcPss27", "srcUcss2", "srcAccss4", "srcUcssTwo", "srcAccss1", "srcUssB", "srcCross1", "srcCfgTwo", "srcAcss52", "srcChess2"], "destCss2": ["destCest1", "destNcss4", "destCcss32", "destCest3", "destCcss4", "destCcss72", "destCss32", "destNcss2", "destCcss1", "destCcss2", "destNcss3", "destCfg2", "destNss32", "destCess2", "destNssB", "destNcss32", "destCcss3", "destCfg4", "destNss4", "destCess32", "destNss2", "destCfgB", "destCfg3", "destCess1", "destNcss1", "destNss3", "destCest2", "destNss1", "destCess4", "destCssB", "destNcssB", "destCss72", "destCestB", "destNss72", "destNcss72", "destCfg72", "destCess72", "destCcssB", "destCfg1", "destCfg32"], "srcCss3": ["srcScss15", "srcCcss4", "srcCcssThird", "srcCshThird", "srcCstyle2", "srcScss3", "srcRcss4", "srcRss1", "srcCcss183", "srcCstyle15", "srcCfg3", "srcCcss6", "srcRss183", "srcCsh2", "srcCfg4", "srcCfg1", "srcScstyle93", "srcCrssAND", "srcPss6", "srcCass1", "srcPcss6", "srcRss2", "srcScss93", "srcRcss183", "srcPcssAND", "srcRcssThird", "srcClass15", "srcScstyle2", "srcCcss1", "srcPss2", "srcCstyle93", "srcPcss3", "srcClass93", "srcRcss1", "srcClass3", "srcCcssAND", "srcRcss2", "srcCsh183", "srcCsh3", "srcClass2", "srcCsl3", "srcCssAND", "srcCrss3", "srcPssAND", "srcRcss3", "srcCssThird", "srcRssThird", "srcRss3", "srcCcss2", "srcPcss2", "srcCass2", "srcCstyle6", "srcScss2", "srcCsl2", "srcCstyle3", "srcCrss2", "srcCss93", "srcCslThird", "srcCcss15", "srcRss4", "srcCass4", "srcCfg2", "srcCrss6", "srcCsl183", "srcScstyle3", "srcPss3", "srcCass3", "srcCss15", "srcCcss3", "srcCstyleAND", "srcCss183", "srcCcss93", "srcScstyle15"], "destCss3": ["destScrss6", "destCja6", "destCross03", "destNcss2", "destCrss2", "destCcss2", "destCstyle43", "destCss183", "destCrss6", "destScss2", "destPcss03", "destCcss53", "destCstyle03", "destNcss3", "destCass3", "destCja3", "destCja2", "destCcss3", "destScss6", "destCss03", "destCstyle2", "destCcss6", "destScss183", "destCcss183", "destScrss2", "destPcss2", "destNss2", "destNcss43", "destPss53", "destPcss53", "destNss3", "destCss43", "destCcss43", "destPss03", "destNss43", "destCass2", "destCstyle53", "destScrss183", "destCcss03", "destPcss3", "destPss3", "destCross2", "destScrss3", "destCross3", "destCross53", "destCass43", "destCstyle3", "destScss3", "destCss53", "destCrss183", "destPss2", "destCrss3", "destCja183"], "srcCss4": ["srcCcss4", "srcCass1", "srcPssFour", "srcCrss4", "srcCrss2", "srcPss4", "srcCcss1", "srcCass4", "srcPss2", "srcCrss1", "srcPcss1", "srcPss1", "srcCssFour", "srcCcss2", "srcPcss2", "srcPcssFour", "srcCass2", "srcCcssFour", "srcCassFour", "srcCrssFour", "srcPcss4"]}}
{"id1": "14473711", "id2": "6866575", "code1": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 1, "substitutes": {"str2md5": ["str2mdse", "str2MD512", "str_md512", "str2MDse", "str2MD5", "str2md512", "str2MD3", "str2h3", "str2h512", "str_md3", "str_mdse", "str2dig5", "str_MD512", "str_MDse", "str2md3", "str_MD5", "str2h5", "str2hse", "str_MD3", "str2dig512", "str_md5", "str2dig3", "str2digse"], "str": ["msg", "er", "f", "data", "name", "char", "s", "arr", "st", "kr", "p", "enc", "hex", "format", "br", "text", "inner", "txt", "bytes", "Str", "r", "cr", "err", "fr", "dr", "strings", "test", "buffer", "i", "source", "sp", "t", "spec", "url", "code", "pass", "empty", "STR", "in", "sr", "tr", "input", "result", "exp", "string", "obj", "dict"], "alga": ["Alja", "alqa", "ALja", "ala", "elda", "Alsa", "Algas", "ALgas", " alja", "ALga", " algas", "algas", "alsa", " alqa", "elga", "ALda", "alsqa", " ala", " alca", " alsa", "ela", "ALca", "elgas", "Alga", "alca", "ALqa", " alda", "alsca", "alsga", "alda", "ALsa", "alja", "ALa", "alsda"], "digesta": ["diffsta", "finesta", "badera", "digeste", "diffosta", "codsta", "diffesta", "fineste", "digsta", "badza", "badesta", "digosta", "codosta", "codeste", "finosta", "igosta", "diffeste", "igera", "igza", "igesta", "finsta", "digza", "badosta", "codera", "codza", "codesta", "digera"]}}
{"id1": "8778962", "id2": "8490297", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeFileAsStream", "decodeFileToFiles", "decodeFile2File", "decodeFileToString", "decodeStringToStream", "decodeStringToString", "decodeFileAsString", "decodeFileAsFile", "decodeString2File", "decodeFileFromFiles", "decodeFileFromFile", "decodeString2Stream", "decodeString2String", "decodeFileFromStream", "decodeStringToFiles", "decodeString2Files", "decodeFileToStream", "decodeFile2Stream", "decodeFileAsFiles", "decodeStringToFile", "decodeFile2Files", "decodeFileFromString"], "infile": ["inputfilename", "outfilename", "infilename", " instream", "inputfile", "inputfiles", "minfile", "outfiles", "infp", "Instream", "inputfp", "Inbase", "outfp", "minstream", " infilename", " infp", " infiles", " inbase", " inFile", "instream", "infiles", "minFile", "inbase", "minbase", "InFile", "Infile", "inFile"], "outfile": ["inputFile", "outputfilename", "outfilename", "infilename", "inputfile", "outpath", "outputFile", "outFile", " outfilename", "inputdatabase", " outdatabase", "inputpath", " outpath", " outFile", "outputdatabase", "outdatabase", " outfolder", "outputfile", "infolder", "outputpath", "outputfolder", "outfolder", "inFile"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "lin", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "channel", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "log", "copy", "conn", "cache", "again", "output", "inner", "line", "writer", "work", "err", "off", "client", "o", "OUT", "lib", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "pass", "post", "io", "net", "file", "up", "co", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "bin", "reader", "border", "uffer", "iter", "data", "channel", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "queue", "input", "result", "length", "write", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "r", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "positive", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "13783898", "id2": "4716110", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToStream", "encodeFiletoStream", "encodeString2Stream", "encodeFiletoFile", "encodeStringToString", "encodeString2String", "encodeFileToStream", "encodeFileToString", "encodeFileFromFiles", "encodeFile2Files", "encodeStringToFiles", "encodeFile2String", "encodeStringToFile", "encodeFileFromString", "encodeString2Files", "encodeFileFromFile", "encodeFiletoString", "encodeFile2Stream", "encodeFileToFiles", "encodeFiletoFiles", "encodeString2File", "encodeFile2File", "encodeFileFromStream"], "infile": ["inputFile", "inputfilename", "Infiles", "outfilename", "infilename", "inputfile", "outFile", "inputfiles", "outfiles", "infp", "inputfp", "outfp", " infilename", " infp", " infiles", "infiles", "Infilename", "InFile", "Infile", "inFile"], "outfile": ["newFile", "outputfilename", "Outfile", "outfilename", "infilename", "outFile", "Outfolder", " outfp", " outfilename", "infp", "newfolder", "outname", "outfp", " outname", " outFile", "Outname", " outfolder", "outputfp", "newname", "newfile", "outputfile", "infolder", "OutFile", "outputfolder", "outfolder"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "vin", "base", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "image", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "copy", "conn", "cache", "again", "output", "inner", "writer", "work", "line", "err", "off", "client", "o", "OUT", "lib", "source", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "post", "io", "net", "file", "up", "co", "on", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "reader", "border", "uffer", "iter", "data", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "len", "queue", "input", "result", "length", "write", "fb", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "close", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "input", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "modified", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "respons", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "937612", "id2": "9033639", "code1": "    public String new2Password(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            String clearPassword = passwd;\n            md.update(clearPassword.getBytes());\n            byte[] digestedPassword = md.digest();\n            return new String(digestedPassword);\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"MD5 doesn't exist\");\n            System.out.println(e.toString());\n            return null;\n        }\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"new2Password": [" gen2Secret", " gen3Secret", "hash2Secret", "hash4Password", " gen2WD", "hash2WD", "hash4Word", "hash3Word", "hashBasePassword", "hash4Secret", " gen2Password", " gen3Word", "hashBaseSecret", "hash2Password", "hashBaseWord", " gen2Word", " gen3Password", "hash4WD", "hash2Word", "hash3Password", "hash3Secret", "hashBaseWD", "hash3WD", " gen3WD"], "passwd": [" passpassword", "assWD", "passpass", "passpassword", "asspassword", " passpass", "asswd", " password", "asspass", "PassWD", "Password", "Passwd", "password", " passWD", "Passpass", "assword", "passWD", "Passpassword"], "md": ["meta", "df", "bd", "vd", "f", "mag", "mg", "wd", "grad", "dd", "m", "ma", " MD", "mt", "ind", "ld", "dig", "di", "mb", "am", "mac", "cmd", "dm", "password", "sm", "d", "MD", "mo", "hash", "amd", "mp", "metadata", "mm", "pm", "dh", "sha", "po", "mc", "ms", "pd", "mand", "hd", "od", "ad", "nm", "editor"], "clearPassword": [" clearWord", "clearWord", " clearMessage", "passpassword", " clearword", "plainPass", "passWord", "passMessage", "passPassword", "clearString", " clearPass", "hashPassword", "clearMessage", "password", "plainPassword", "hashMessage", " clearpassword", "hashWord", "plainString", "clearword", "plainpassword", "hashword", "passPass", "clearpassword", "clearPass", " clearString", "passString"], "digestedPassword": ["digustedPassword", " digestPat", "digestedPad", "diguredPad", "DigestedPass", "digustedPass", " digestedPass", "digestPad", "DigestPad", "digestingpassword", "DigestedPassword", "digestingPassword", "digashedPassword", "digustedPat", "digestPass", "DigestPassword", "diguredpassword", "digestpassword", " digestedPat", "digestPassword", "digestedPass", "digestPat", "DigestedPad", "diguredPassword", "Digestedpassword", "digashedPat", "digestedpassword", "DigestPass", "digestedPat", " digestPass", "digestingPad", "digestingPass", "Digestpassword", "diguredPass", "digashedPass", " digestPassword"]}}
{"id1": "1966310", "id2": "9450274", "code1": "    public void init() {\n        super.init();\n        Runnable doActions = new Runnable() {\n\n            public void run() {\n                if (_plot == null) {\n                    _plot = newPlot();\n                }\n                getContentPane().add(plot(), BorderLayout.NORTH);\n                int width;\n                int height;\n                String widthspec = getParameter(\"width\");\n                if (widthspec != null) {\n                    width = Integer.parseInt(widthspec);\n                } else {\n                    width = 400;\n                }\n                String heightspec = getParameter(\"height\");\n                if (heightspec != null) {\n                    height = Integer.parseInt(heightspec);\n                } else {\n                    height = 400;\n                }\n                _setPlotSize(width, height);\n                plot().setButtons(true);\n                Color background = Color.white;\n                String colorspec = getParameter(\"background\");\n                if (colorspec != null) {\n                    background = PlotBox.getColorByName(colorspec);\n                }\n                setBackground(background);\n                plot().setBackground(background);\n                getContentPane().setBackground(background);\n                Color foreground = Color.black;\n                colorspec = getParameter(\"foreground\");\n                if (colorspec != null) {\n                    foreground = PlotBox.getColorByName(colorspec);\n                }\n                setForeground(foreground);\n                plot().setForeground(foreground);\n                plot().setVisible(true);\n                String dataurlspec = getParameter(\"dataurl\");\n                if (dataurlspec != null) {\n                    try {\n                        showStatus(\"Reading data\");\n                        URL dataurl = new URL(getDocumentBase(), dataurlspec);\n                        InputStream in = dataurl.openStream();\n                        _read(in);\n                        showStatus(\"Done\");\n                    } catch (MalformedURLException e) {\n                        System.err.println(e.toString());\n                    } catch (FileNotFoundException e) {\n                        System.err.println(\"PlotApplet: file not found: \" + e);\n                    } catch (IOException e) {\n                        System.err.println(\"PlotApplet: error reading input file: \" + e);\n                    }\n                }\n            }\n        };\n        try {\n            SwingUtilities.invokeAndWait(doActions);\n        } catch (Exception ex) {\n        }\n    }\n", "code2": "    public void seeURLConnection() throws Exception {\n        URL url = new URL(\"http://wantmeet.iptime.org\");\n        URLConnection uc = url.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n        String s = null;\n        StringBuffer sb = new StringBuffer();\n        while ((s = br.readLine()) != null) {\n            sb.append(s);\n        }\n        br.close();\n        log.debug(\"sb=[\" + sb.toString() + \"]\");\n    }\n", "label": 0, "substitutes": {"init": ["bin", "open", "it", " Init", "basic", "Init", "create", " initialize", "alloc", "boot", "info", "clean", "load", "setup", "gen", "set", "base", "plugin", "conf", "initialized", "done", "construct", "reset", "ini", "clear", "build", "pack", "connect", "ci", "exec", "close", "config", "empty", "prep", "core", "action", "ize", "initial", "start", "act"], "doActions": [" animationActions", " plotAaction", " plotCaAction", " animationCaactions", " animationCaAction", " plotAlaction", " plotAlctions", " plotActionctions", " animationAactions", " plotAlAction", " animationCactions", " plotActionactions", " plotAactions", " plotAAction", " plotActions", " plotCaaction", " plotAlactions", " animationAaction", " plotCaactions", " animationAAction", " plotActionAction", " animationCaaction", " plotActionaction", " plotCactions"], "_plot": ["_chart", "_fit", "_pl", "_project", "_patch", "_log"], "width": ["border", "layout", "density", "name", "high", "widget", "down", "fw", "amount", "crop", "fall", "Width", "space", "wp", "page", "w", "size", "weight", "lon", "left", "work", "writer", "capacity", "shape", "flow", "dim", "pull", "idth", "wn", "hop", "style", "padding", "image", "wa", "value", "port", "large", "filename", "fill", "speed", "age", "number", "platform", "duration", "west", "index", "window", "length", "gender", "draw", "area", "write", "fb", "wait"], "height": ["volume", "gravity", "density", "data", "thumbnails", "y", "layout", " heights", "depth", "radius", "rows", "slice", "head", "crop", "gap", "rank", "upper", "resolution", "wrap", "size", "weight", "th", "capacity", "shape", "deep", "Height", "pull", "row", "padding", "style", "build", "image", "port", "arrow", "h", "bottom", "level", "thin", "duration", "shadow", "id", "index", "right", "window", "pad", "length", "draw", "stroke", "alpha", "inches", "ip", "grow", "quality"], "widthspec": [" widthstring", " widthset", "Widthpec", "WidthSpec", " widthparse", "poolset", "sizescale", "widthparse", "widthpec", " widthpec", "weightspec", "widthSpec", "lengthset", "sizestring", "widthstring", "sizeSpec", " widthSpec", "weightstyle", "Widthstyle", "weightpec", "poolspec", "poolparse", "widthstyle", " widthscale", " widthstyle", "weightscale", "widthscale", "weightstring", "lengthparse", "Widthspec", "lengthspec", "weightSpec", "widthset", "lengthSpec", "sizespec", "poolSpec"], "heightspec": ["heaksync", "heowsSpec", "weowspec", "peatsync", "heckspec", "heightspe", "heakspect", "peightspe", "peatsspec", "weightspect", "heakspec", "peightsspec", "heowsync", "heowspect", "weowspect", "heetspec", "heeksspec", "peightslip", "heightsspec", "hecksspec", "heatsSpec", "peatspect", "heatsync", "heightslip", "heetspe", "weightspec", "heekslip", "heekspe", "heightsSpec", "weowsSpec", "heatspect", "peatslip", "heowspec", "heatslip", "heatspec", "heightspect", "heowsspec", "hecksSpec", "heekspec", "peatspe", "heetsspec", "weightsSpec", "heaksspec", "peightsync", "heckspect", "weowsspec", "heetslip", "peatspec", "peightspect", "heightsync", "weightsspec", "heatspe", "peightspec", "heatsspec"], "background": ["border", "profile", "ha", "pool", "support", "gold", "reference", "theme", "blue", "gradient", "ghost", "rc", "base", "focus", "ground", "summary", "description", "foundation", "wrapper", "clip", "callback", "shell", "collection", "ruby", "bc", "back", "gray", "pull", "Background", "buffer", "sound", "comment", "image", "brush", "brown", "ba", "large", "fill", "pattern", "bg", "regular", "default", "color", "null", "shadow", "shield", "prefix", "black", "resource", "draw", "area", "alpha", "panel", "ignore"], "colorspec": ["colarship", "colandspect", "colionslip", "colionsnp", "colourspec", "colourspect", "Colorspect", "Colorspace", "colourspir", "Coloresnp", "colarsspec", "Colonslip", "colionspir", "Colonspace", "colonship", "colourspace", "colorsspec", "Colorsnp", "colorsSpec", "Colorspir", "coloursnp", "coloresnp", "coloresSpec", "Colorespir", "colionsspec", "colorespace", "colonslip", "colloresspec", "collorspace", "colionspec", "Colorsspec", "Colorespec", "collorspect", "coloreslip", "collorespec", "colororspec", "colonsSpec", "Colorespect", "collectionsspec", "colororsspec", "colorslip", "colororsSpec", "coloursspec", "colonspect", "Coloreship", "collorsspec", "colororspect", "colarspec", "colorsnp", "collorespace", "colonspace", "collorespect", "Colonsspec", "colorship", "colororespect", "colonsspec", "colandspec", "colorspir", "collectionspec", "colorespect", "colorespir", "Colorship", "colandsspec", "colororesspec", "colandsSpec", "colororesSpec", "Colorslip", "colorspace", "colarspect", "collectionspect", "collorspec", "Coloresspec", "colorspect", "colororespec", "colorespec", "coloresspec", "colionspace", "Colonspec", "colonspec", "Colorspec", "coloreship"], "foreground": ["flyground", "underground", "undercast", " forebackground", "forebackground", "Foreground", "Forecast", "fterGROUND", "backpoint", "broadellow", "flyellow", "underparent", "foreGROUND", "broadcast", "backmission", "forepoint", " foreparent", "ForeGROUND", "flycast", "roughmission", "roughground", "foreparent", "roughcast", " forecast", "roughbackground", "Foremission", "roughpoint", " foreGROUND", "fterbackground", "fterground", "broadfill", "broadground", "Foreparent", "forefill", "roughfill", "underbackground", "foreellow", "backbackground", "forecast", "Forepoint", "roughellow", "flyfill", "foremission", "ftercast", "Forebackground"], "dataurlspec": ["datastringspe", "dataurlstr", "dataURLstr", " datalogstr", " datalogspec", " dataUrlspe", "datalogstr", " datalogparse", "dataUrlSpec", "datalogspec", " dataurlspace", " dataurlparse", " dataUrlSpec", " dataurlspe", "datalogparse", " dataUrlspec", "dataurlspace", "datafilestr", "datafilespec", "dataurlparse", "datafeedspec", " dataurlSpec", "datafileparse", " dataurlstr", "datastringSpec", "dataURLspe", "datastringspec", "dataurlSpec", "dataURLSpec", "dataUrlspec", " datalogspace", "dataurlspe", "dataURLspec", "datafilespace", "datafeedSpec", "dataURLparse", "datalogspace", "dataUrlspe", "dataURLspace"], "dataurl": ["Datafile", "DataURL", "database", "thisfile", "datafile", "thisURL", "ataURL", " datafile", "dataUrl", " database", " dataURL", "DataUrl", "ataurl", " dataUrl", "atabase", "thisurl", "Dataurl", "dataURL", "thisUrl", "Database", "ataUrl"], "in": ["reader", "bin", "isin", "login", "f", "data", "socket", "inas", "ins", "body", "stream", "p", "In", "b", "inner", "win", "r", "din", "IN", "err", "ini", "d", "i", "source", "image", "inc", "t", "h", "url", "server", "inn", "c", "as", "a", "resource", "input", "out", "con", "record", "serv"]}}
{"id1": "22441244", "id2": "16931472", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"send": ["open", "get", "create", "from", "set", "add", "text", "mail", "export", "address", "Send", "reply", "parse", "build", "submit", "exec", "delete", "transfer", "post", "message", "sent", "append", "execute", "write", "start", "end"], "hsession": ["HSessions", "openssession", "hsess", "opensessions", "hsSession", "hmession", "hhsession", "hhessions", "hession", "hsort", "hessions", "HSsession", "hmsession", "HSSession", "hsessions", "hhSession", "hessession", "hSession", "opensort", "hmSession", "hhess", "opensession", "hhort", "HSession", "opensSession", "hhession", "hssession", "hesort", "opensess", "hesession", "hmessions", "hesess"], "session": ["connection", "sl", "manager", "application", "state", "event", "class", "Session", "cache", "mail", "essions", "client", "proxy", "port", "project", "response", "parent", "context", "document", "server", "ession", "message", "chat", "resource", "host", "security", "site"], "repositoryName": ["repoositoryAddress", "repositoryFamily", "reposicleFamily", "repoositoryNAME", "repoitoryPath", "repositoryPath", "reposicleName", "repoitoryAddress", "reposessionNAME", "reposositoryNAME", "reposositoryPath", "reposicleAddress", "reposositoryName", "repoitoryEmail", "reposositoryFamily", "reposicationFamily", "reposicationName", "repoositoryName", "reposicationAddress", "reposositoryEmail", "repoitoryName", "repositoryAddress", "repoitoryFamily", "reposicleEmail", "reposessionName", "reposessionPath", "repositiveEmail", "repositoryNAME", "repositoryEmail", "repoositoryPath", "repositiveNAME", "reposositoryAddress", "reposicationEmail", "repoositoryFamily", "repositiveName", "reposessionEmail", "repoositoryEmail", "repoitoryNAME", "repositivePath"], "ideIdint": ["ideAuthints", "ideIdInt", "ideNameint", "ideidints", "IDEIdints", "ideIdints", "ideTimeInt", "ideAuthn", "ideidInt", "ideInn", "ideInint", "IDEidInt", "IDENameout", "IDEidint", "ideTimeout", "IDEIdInt", "ideIdout", "ideNameInt", "ideidn", "IDEIdout", "IDEidints", "IDENamenumber", "ideidint", "ideInfoout", "ideIdnumber", "IDENameint", "ideTimeint", "IDEIdn", "ideInfoint", "IDENameInt", "IDEIdnumber", "ideAuthint", "ideNameout", "ideInInt", "IDEIdint", "ideNamenumber", "ideAuthInt", "ideInints", "IDEidn", "ideInfonumber", "ideIdn", "ideTimenumber", "ideInfoInt"], "to": ["office", "name", "phone", "TO", "options", "from", "settings", "To", "top", "summary", "with", "mail", "by", "account", "client", "address", "reply", "sub", "source", "template", "mobile", "response", "tel", "uri", "title", "prefix", "message", "po", "token", "target", "about", "contact", "location", "company", "site"], "cc": ["cb", "cn", "phone", "nc", "card", "sc", "cca", "ca", "from", "ct", "ck", "ec", "rc", "cs", "lc", "cr", "account", "password", "client", "address", "dc", "comment", "ci", "uc", "cf", "CC", "cl", "code", "c", "ce", "tc", "contact", "company", "ac", "cus"], "bcc": ["abc", "pck", " bc", " brc", "fck", "bbrc", "pc", " bce", "bce", " bck", "pcc", "brc", "fcc", "bbck", "abcc", "bbc", "pce", "frc", "abce", "abck", "bck", "fc", "bc", "bbcc"], "subject": ["phone", "reason", "head", "method", "state", "format", "description", "mail", "content", "reply", "comment", "sub", "Subject", "template", "ject", "request", "response", "object", "filename", "uri", "author", "title", "prefix", "message", "header", "host", "username"], "body": ["connection", "lock", "data", "tree", "name", "reason", "how", "string", "plain", "base", "summary", "description", "part", "text", "inner", "wrapper", "content", "zip", "left", "line", "shell", "password", "normal", "secret", "comment", "style", "source", "template", "money", "response", "bound", "object", "foot", "url", "code", "view", "empty", "pass", "Body", "function", "message", "header", "resource", "length", "html", "media", "pod"], "attachments": ["embedings", "attachents", "messents", "embedment", "attachings", "Attachings", "embedments", "Attachents", "Attachments", "messment", "embedents", "Attachment", "messings", "messments"], "isHtml": ["isPhttp", "isChtml", "isPhhtml", " isChhtml", "isCtml", "isHive", " isHttp", " isWhail", "isWhtml", " isWhive", "isWhail", "isChhtml", " isWhhtml", "isCive", " isHail", "isCail", "isHhtml", "isChive", "isPhtml", " isWhtml", " isChail", "isHaail", "isWhive", "isChail", "isHattp", " isChtml", " isHhtml", "isHatml", "isHahtml", "isChttp", "isHail", "isWhhtml", " isHive", " isChttp", "isPhail", "isHttp"], "charset": ["charsET", "chaseset", "chasET", "chanset", "chaseting", "CharsET", "chasets", "chanspace", "chARSetting", "chearsete", "chansetter", "chearspace", "cheanset", "chansete", "chearsetter", "chARSET", "chARSeting", "Charseting", "charsetting", "chashesetter", "chARSets", "cheansET", "chackset", "charsetter", "chansetting", "chasheset", "chacksET", "chasetter", "Charsetting", "chaset", "cheansete", "chasetting", "cheansetter", "Charsets", "chacksetting", "chaseseting", "chaspace", "cheanspace", "chARSete", "Charset", "chearset", "charsets", "chearsET", "chashesET", "chansET", "cheansetting", "charsete", "charseting", "chARSet", "charspace", "chashespace", "chacksete", "chasesetting", "chearsetting", "chasesET"], "headers": ["mails", "options", "groups", "settings", " cookies", "status", "files", "content", "authors", "lines", "writers", " messages", "strings", " emails", " recipients", "classes", "comments", "names", "errors", "metadata", "params", "users", "header", "properties", "types", "ers"], "priority": ["phone", "reason", "language", "theme", "state", "mode", "status", "class", " title", "lang", "reply", "secret", "comment", "template", " severity", " recipients", "quote", "comments", "level", "code", "date", "author", "title", "prefix", "queue", "security", "length"], "email": ["office", "gmail", "ext", "data", "name", "oe", "ilo", "note", "create", "el", "auto", "em", "info", "install", "event", "en", "xml", "Email", "letter", "base", "ssl", "model", "text", "mail", "output", "online", "article", "entity", "zip", "line", "engine", "export", "account", "password", "e", "address", "external", "service", "fax", "test", "lex", "business", "template", "generic", "example", "response", "object", "url", "update", "enter", "document", "view", "server", "default", "core", "pm", "message", "contact", "result", "international", "print", "html", "liner", "element", "username"], "user": ["connection", "er", "profile", "data", "name", "type", "creator", "info", "ip", "me", "plugin", "model", "people", "account", "e", "member", "client", "User", "mobile", "object", "role", "character", "friend", "USER", "consumer", "author", "person", "id", "users", "uid", "resource", "token", "unknown", "string", "use", "username"], "identity": ["ethnicifier", "identication", "authorentity", "authority", "idITY", "ethnicity", "electricITY", "authoronymous", "authentonymous", "idifier", "authorities", "entityity", "IDENTity", "personITY", "idity", "personentity", "IdentITY", "authorication", "ethniciciary", "identiciary", "electriconymous", "ethnicITY", "installITY", "Identity", "IDENTities", "IDENTITY", "personity", "entityifier", "installonymous", "electricity", "authentITY", "publicity", "authentization", "authoriciary", "idization", "ethnicentity", "electricentity", "identonymous", "installentity", "authentication", "authentity", "idication", "publicITY", "entityonymous", "publicentity", "identization", "Identities", "Idententity", "IDENTentity", "entityization", "ethnicication", "identITY", "publiciciary", "authorifier", "idonymous", "authentifier", "idententity", "authorITY", "identifier", "identities", "installity", "personifier"], "_returnPath": ["_correctId", "_returnMid", "_resultPath", "_responseType", " _returnTo", " _backHalf", "_resultTo", "_returnHalf", " _returnUrl", "_resultHalf", "_displayPath", "_displayPart", "_backHalf", "_responsepath", "_backpath", "_displayUrl", "_inputMid", "_returnNode", "_returnPart", "_backName", "_returnText", "_inputPath", "_backType", "_returnDirectory", "_displayNode", "_successText", " _backTo", "_addType", "_backPath", "_backPart", " _backUrl", "_relationPath", "_backUrl", "_successId", "_resultName", "_returnTo", "_addPath", "_correctText", "_successPath", "_replyUrl", " _backPath", "_relationId", " _backPart", "_returnType", " _backName", "_replyMid", "_returnId", "_replyNode", "_correctPath", "_returnUrl", "_inputUrl", "_backTo", "_returnpath", "_relationDirectory", "_successDirectory", "_replyPart", "_addpath", "_correctDirectory", " _returnHalf", "_replyPath", "_displayMid", "_relationText", " _returnName", "_responsePath", "_returnName", "_inputNode", " _returnPart"], "_from": ["_for", "placeowner", "workwho", "worksource", "blockFrom", "_From", "_with", "blockerror", " _error", " _source", "workfrom", "blockto", " _owner", "existingto", "_source", "_who", "existingfrom", "_error", "blockfrom", "_owner", " _for", " _with", "existingowner", "placefrom", "workto", " _who", "placefor", " _From", "placeto", "existingfor"], "_replyTo": ["_replyFrom", "_returnUrl", "_respondTo", "_returnTo", "_respondTO", "_returnOf", " _returnTo", "_addFrom", "_reasonUrl", " _replyTO", "_closeTO", "_replyUrl", " _returnTO", "_reasonTo", "_replyTO", "_addAddress", "_commentOf", " _replyFrom", "_reasonTO", "_respondAddress", "_commentFrom", "_respondFrom", "_commentTO", "_replyAddress", "_commentTo", "_respondPoint", " _returnFrom", "_replyPoint", "_replyOf", " _replyUrl", "_returnAddress", " _returnUrl", "_returnPoint", "_addTo", "_respondUrl", "_returnFrom", "_addPoint", "_returnTO", "_closeTo", "_reasonFrom", "_closeOf", "_closeFrom"], "_to": [" _target", "_target", " _about", "Jfrom", "Jabout", "Jtarget", "_about", "Jto"], "_cc": [" _cd", " _ce", " _cf", "_cd", "_ce", "_cf"], "_bcc": [" _abc", " _bce", "_rbcs", " _bcs", "_abce", "_rbc", "_sbcs", "_sbc", " _bc", " _abcs", "_abcs", "_sbcc", "_abc", "_rbce", "_bce", "_bcs", "_rbcc", " _abce", "_sbce", "_bc", "_abcc", " _abcc"]}}
{"id1": "13362846", "id2": "5299276", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"setContenu": ["setContonenu", "setContineuer", "setContenuer", "setContenuit", "setContenues", "setContennuer", "setContennuit", "setContonenuit", "setContonenuer", "setContennues", "setContineu", "setContineues", "setTenuit", "setTonenuer", "setTenuer", "setTonenues", "setContennu", "setTonenu", "setTonenuit", "setContonenues", "setTenues", "setTenu", "setContineuit"], "contenuFichier": ["contenuFichoyer", "contenuFchier", "contenuFicie", "contenuPhactoryiere", "contenuFrenchery", "contenuFicheieri", "contenuFichtier", "contenuTicheery", "contenuFichie", "contenuFichtieri", "contenuFiciere", "contenuMichieri", "contenuFicheique", "contenuTicheerer", "contenuPFichique", "contenuPhactoryier", "contenuFicheery", "contenuPFochier", "contenuFrenchique", "contenuMrenchiere", "contenuPhactoryoyer", "contenuFicheerer", "contenuMaffier", "contenuFichtiere", "contenuFaffier", "contenuFicheier", "contenuMaffieri", "contenuPrefaffie", "contenuFicher", "contenuMaffie", "contenuPFochique", "contenuPrefichiere", "contenuMrenchier", "contenuPhichiere", "contenuFochier", "contenuFrenchiere", "contenuPFochiere", "contenuPrefaffiers", "contenuFchery", "contenuPrefaffiere", "contenuPrefichier", "contenuFactoryiere", "contenuFichiers", "contenuMichie", "contenuMrenchique", "contenuFochie", "contenuFichieri", "contenuTicheier", "contenuFicheer", "contenuFaffiers", "contenuPrefichie", "contenuFichery", "contenuFrenchie", "contenuFactoryie", "contenuFichique", "contenuPhichier", "contenuFicherer", "contenuFichiere", "contenuPhichie", "contenuMichiers", "contenuFaffique", "contenuTichier", "contenuFocher", "contenuPrefichiers", "contenuFichtie", "contenuFaffiere", "contenuFaffie", "contenuMaffiere", "contenuFchiere", "contenuPFocher", "contenuFaffer", "contenuPFichiere", "contenuFrencherer", "contenuPFichier", "contenuFicheie", "contenuFichtique", "contenuTichery", "contenuPFicher", "contenuMichier", "contenuFicoyer", "contenuFcherer", "contenuFicheiere", "contenuTicheiere", "contenuFrenchier", "contenuPrefaffier", "contenuFochiers", "contenuTichiere", "contenuMrenchie", "contenuFrenchiers", "contenuFactoryoyer", "contenuFochiere", "contenuFaffieri", "contenuFrenchoyer", "contenuMichique", "contenuPhichoyer", "contenuTicherer", "contenuMaffiers", "contenuFochique", "contenuMichiere", "contenuPhactoryie", "contenuFicier", "contenuFactoryier"], "fichierElectronique": ["fichierElectroneier", "fichierElectroniques", "fichierElectonlique", "fichierElectronsiques", "fichierElectronsique", "fichierElectronsie", "fichierElectrolie", "fichierElectonier", "fichierAdministronsistic", "fichierElectpronistic", "fichierElectorniques", "fichierElectronsistic", "fichierElectronical", "fichierCentorniques", "fichierElectolonique", "fichierElectroniere", "fichierAustrolique", "fichierElectronlique", "fichierElectornique", "fichierElectproniques", "fichierCentornlique", "fichierElectromiques", "fichierAdministronslique", "fichierCentronier", "fichierAustroliere", "fichierAdministronsiques", "fichierAdministronlique", "fichierAdministronsier", "fichierElectron\u00e9e", "fichierAdministronsie", "fichierElectpronical", "fichierElectronelique", "fichierElectronie", "fichierElectronsical", "fichierElectoloniere", "fichierElectromical", "fichierAdministrons\u00e9e", "fichierElectronistic", "fichierElectroneique", "fichierAustronier", "fichierCentronique", "fichierAdministronie", "fichierAustroliques", "fichierAustroniere", "fichierCentornier", "fichierElectoloniques", "fichierAdministronique", "fichierElectroneiques", "fichierElectronsier", "fichierElectronica", "fichierAdministronsique", "fichierElectaron\u00e9e", "fichierAdministronistic", "fichierElectrolique", "fichierElectaronie", "fichierAdministronsical", "fichierElectrons\u00e9e", "fichierAdministronical", "fichierAdministroniques", "fichierElectrol\u00e9e", "fichierAdministronier", "fichierElectroliere", "fichierElectornlique", "fichierElectrolica", "fichierElectroneie", "fichierElectornier", "fichierElectronsiere", "fichierElectonique", "fichierElectaronier", "fichierElectromistic", "fichierCentroniques", "fichierAustrolier", "fichierCentornique", "fichierAustroniques", "fichierAdministron\u00e9e", "fichierElectroliques", "fichierElectroneiere", "fichierElectpronique", "fichierElectromique", "fichierElectonie", "fichierElectronier", "fichierAustronique", "fichierElectolonica", "fichierElectronsica", "fichierElectronslique", "fichierElectaronique", "fichierElectrolier", "fichierCentronlique"], "utilisateurCourant": ["utilisateurApplicateur", "utilisationApplicant", "utilisateurParticipateur", "utilisationCourant", "utilisateurCourants", "utilisationApplicateur", "utilisateurApplicante", "utilisateurGovernant", "utilisateurApplicants", "utilisationCourante", "utilisateurGovernants", "utilisateurParticipante", "utilisationApplicants", "utilisateurCourante", "utilisateurApplicant", "utilisateurGovernateur", "utilisateurGovernante", "utilisationCourateur", "utilisateurCourateur", "utilisationCourants", "utilisationApplicante", "utilisateurParticipant", "utilisateurParticipants"], "support": ["feature", "util", "force", "allow", "services", "info", "settings", "know", "utils", "supported", "ann", "control", "library", "plugin", "format", "summary", "Support", "share", "protection", "evidence", "concept", "respect", "client", "best", "pull", "knowledge", "service", "proxy", "storage", "media", "review", "system", "bank", "config", "document", "friend", "facebook", "Library", "contact", "cover", "help", "pport", "accept", "compatible", "push", " Support", "supp"], "ficheDocument": ["ficheFeature", "FcheDoc", " ficheDocuments", "fineFeature", "financeDocument", "fielCompany", "fruitdocument", "fruitNumber", "enfoiceDirectory", "enficheDocument", "foineDoc", "FicheDoc", "infichedocument", "enfoiceCompany", "fraudDirectory", "fineDoc", "frauddocument", "FcheDocument", " ficheMatrix", "fineDocument", "fchadocument", "ficheDoc", "foiceCatalog", "financedocument", "Fichedocument", "FicheContent", "inficheDoc", " fcheMatrix", "fcheContent", " ficheDirectory", "foineDocument", "fetchdocument", "fraudCatalog", "Fchedocument", "enficheCatalog", "affineDoc", "financeDoc", "fagueDocuments", "FcheContent", "friqueDocument", "infrauddocument", "fruitDocument", "foiceCompany", "enfoiceCatalog", "fcheMatrix", "fruitDoc", "affineDocument", "enficheDirectory", "fraudNumber", "fetchFeature", "fetchDocument", "ficheCatalog", "afficheFeature", "fichedocument", "friqueContent", "fraudDoc", "facheDirectory", "enfoiceDocument", "friqueDoc", "fcheDocuments", "ficheCompany", "inficheDocument", "affichedocument", "fagueMatrix", "fchaDoc", "fielDirectory", "fetchDoc", "infraudDoc", "facheDocument", "ficheDirectory", "foineFeature", "enficheCompany", "fagueDocument", "fielDocument", "foinedocument", "fcheDirectory", "foiceDirectory", " fcheDocument", "infraudNumber", "fagueDirectory", "affineFeature", "fraudCompany", "fcheDocument", "fchedocument", "fchaContent", " fcheDocuments", "foiceDocument", "afficheDoc", "afficheDocument", "fcheDoc", "fielCatalog", "inficheNumber", "friquedocument", "affinedocument", "FicheDocument", "ficheNumber", "financeNumber", "ficheDocuments", "facheDocuments", "fchaDocument", "facheMatrix", "fraudDocument", "finedocument", "ficheMatrix", " fcheDirectory", "infraudDocument", "ficheContent"], "nomFichier": ["nomFichiller", "nomF\u00e9tier", "nomFachrier", "nomFitherer", "nomPrefchrier", "nomFrencher", "nomNichtiller", "nomWchiere", "nomVcher", "nomFiqurier", "nomFichtieri", "nomFichieri", "nomF\u00e9tery", "nomFochiere", "nomPhachier", "nomFichiere", "nomFacherer", "nomFiscer", "nomFrenchieri", "nomFiquieri", "nomPrefchire", "nomF\u00e9tien", "nomFisciller", "nomPhachieri", "nomVichier", "nomFochier", "nomFach\u00e8re", "nomFrench\u00e8re", "nomFichtire", "nomPchien", "nomFachire", "nomFchier", "nomFachiere", "nomPhacherer", "nomFiscery", "nomPhachiere", "nomFch\u00e8re", "nomPrefchier", "nomPrefichier", "nomFcher", "nomFichrier", "nomWchier", "nomWichery", "nomVchieri", "nomFacher", "nomNichiller", "nomFichter", "nomNichtier", "nomPchery", "nomFchery", "nomFichery", "nomVichieri", "nomFichire", "nomFichiner", "nomFichtiller", "nomFiscy", "nomFachier", "nomPichery", "nomPrefichire", "nomFchire", "nomNichtiner", "nomFithier", "nomPhichiere", "nomWichire", "nomWchire", "nomFichtery", "nomFachieri", "nomWchery", "nomFiquire", "nomFicherer", "nomNicher", "nomFachiller", "nomVch\u00e8re", "nomFichtier", "nomPichier", "nomFichy", "nomFochery", "nomFrenchier", "nomVicher", "nomFiscier", "nomFchiere", "nomPrefchieri", "nomFithiere", "nomPichy", "nomFicher", "nomPchier", "nomFiquier", "nomFchrier", "nomFchien", "nomPchy", "nomWichiere", "nomPhichier", "nomWichier", "nomFich\u00e8re", "nomFichterer", "nomF\u00e9ty", "nomFithieri", "nomPrefichrier", "nomFchieri", "nomFchy", "nomFiscien", "nomPhicherer", "nomNichiner", "nomFisciner", "nomFochire", "nomPichien", "nomFichien", "nomNichter", "nomPhichieri", "nomFichtiner", "nomFachiner", "nomPrefichieri", "nomFichtiere", "nomNichier", "nomVchier", "nomVich\u00e8re"], "extension": ["extression", "encension", "exression", "Extion", "anchension", "extensions", "exension", "Extception", "EXTensions", "anchensions", "exception", "EXTime", "extception", "anchime", "encion", "extime", "extion", "Extensions", "EXTension", "Extression", "encression", "encception", "Extension", "Extime", "exion"], "fichierElectroniqueExistant": ["fichierElectroniqueXclusive", "fichierElectroniquesXilingual", "fichierElectroniquesXistent", "fichierElectroniqueExplists", "fichierElectroniqueExists", "fichierElectroniquesExclusive", "fichierElectroniqueExplistant", "fichierElectroniqueexilingual", "fichierElectroniqueXivist", "fichierElectroniquesExistant", "fichierElectroniquesXclusive", "fichierElectroniqueexist", "fichierElectroniquesExistent", "fichierElectroniqueExclusive", "fichierElectroniquesExivist", "fichierElectroniqueXist", "fichierElectroniqueexclusive", "fichierElectroniqueExplist", "fichierElectroniqueexistent", "fichierElectroniqueSistance", "fichierElectroniqueExist", "fichierElectroniqueXists", "fichierElectroniqueExivist", "fichierElectroniquesXist", "fichierElectroniquesXivist", "fichierElectroniquesExists", "fichierElectroniqueExistent", "fichierElectroniqueXistant", "fichierElectroniqueExistance", "fichierElectroniqueExilingual", "fichierElectroniqueExplistance", "fichierElectroniqueXistance", "fichierElectroniqueexists", "fichierElectroniqueExplclusive", "fichierElectroniquesExilingual", "fichierElectroniqueXistent", "fichierElectroniqueSilingual", "fichierElectroniqueXilingual", "fichierElectroniquesExist", "fichierElectroniqueexivist", "fichierElectroniqueexistant", "fichierElectroniqueSistent", "fichierElectroniquesXists", "fichierElectroniquesExistance", "fichierElectroniquesXistance", "fichierElectroniquesXistant", "fichierElectroniqueSistant", "fichierElectroniqueExplivist", "fichierElectroniqueexistance"], "idIgid": ["idUguID", "idIguname", "idIgnod", "idIgnid", "idIogdid", "idIgnID", "idIggod", "idEgbit", "idEgids", "idEGids", "idUgID", "idUguname", "idIguids", "idIogids", "idIgID", "idIgmname", "idEgid", "idIGid", "idEgdid", "idIgubit", "idIgmID", "idIgdid", "idIgenname", "idIgenids", "idUguid", "idEGdid", "idIgudid", "idIgname", "idIggid", "idUgid", "idEGid", "idIguid", "idIgnids", "idUgids", "idIggids", "idIguod", "idEGbit", "idIGbit", "idIgenID", "idIgbit", "idIGids", "idIgmid", "idIgod", "idUgname", "idIgmids", "idIggID", "idIGdid", "idUguids", "idIgids", "idIguID", "idIgenid", "idIogbit", "idIogid"], "inputStream": [" inputstream", "inputSteam", "outputLength", "eventStream", "InputStream", "InputStreamer", "eventstream", "outputStreamer", "inputStreamer", "inputThread", "outputThread", "InputThread", "InputLength", "inputLength", "Inputstream", " inputLength", "outputSteam", "eventSteam", "InputSteam", "inputstream", "eventStreamer", " inputSteam", " inputThread", "outputstream"], "outputStream": ["officeStream", "entityStream", "inputSteam", "OutputSteam", "officeSteam", "officestream", "inputContext", "OutputStream", "outputStreamer", "Outputstream", "inputStreamer", "outputContext", " outputstream", "entityStreamer", "OutputContext", "entitySteam", " outputSteam", " outputContext", "officeStreamer", "outputSteam", "inputstream", "entitystream", "outputstream", "OutputStreamer"], "typeMime": ["typeMetangle", "typeMatime", "typeSmide", "typeMatimes", "typeMatangle", "TypeSmangle", "TypeSmide", "typeMatide", "TypeMimes", "typeMetide", "TypeSmimes", "typeMangle", "typeSmangle", "typeMimes", "TypeMide", "TypeSmime", "typeSmimes", "TypeMangle", "typeMetime", "typeSmime", "typeMetimes", "typeMide", "TypeMime"], "tailleFichier": [" tailleFochiers", " tailleFigniers", " taillefocher", " tailleFocher", " taillefichiers", " taillefochie", " tailleFochie", " tailleFigner", " tailleFichiers", " tailleFicheier", " taillefichier", " tailleFicheiers", " taillefichie", " tailleFicheer", " taillefochiers", " tailleFochier", " tailleficher", " tailleFignie", " tailleFicher", " taillefochier", " tailleFignier", " tailleFichie", " tailleFicheie"]}}
{"id1": "21425787", "id2": "4461350", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 0, "substitutes": {"copyFile": ["CopyStream", "Copyfile", "copyFiles", " copyfile", " copyStream", "transferFile", "transferfile", " copyFiles", "transferStream", "CopyFiles", "CopyFile", "transferFiles", "copyfile", "copyStream"], "in": ["reader", "bin", "connection", "login", "data", "name", "at", "ins", "m", "ex", "min", "In", "base", "b", "inner", "again", "work", "IN", "ini", "i", "source", "image", "inc", "or", "exec", "url", "io", "inn", "c", "file", "up", "id", "index", "a", "input", "ac"], "out": ["x", "connection", "data", "name", "point", "at", "to", "p", "ex", "outs", "base", "conn", "w", "b", "output", "again", "cache", "user", "part", "writer", "off", "o", "dest", "OUT", "temp", "client", "call", "source", "inc", "exec", "object", "v", "n", "server", "io", "c", "file", "up", "prefix", "result", "target", "Out"], "sourceChannel": ["srcSocket", "sourceChan", " sourceConnection", "ourceChan", "resourceConnection", " sourceSocket", "SourceChan", " sourceStream", "targetStream", "targetchannel", "resourcechannel", "sourceConnection", "targetChannel", "srcChannel", "resourceChannel", "srcChan", "sourceStream", "resourceChan", "sourcechannel", " sourcechannel", "ourceSocket", "ourceConnection", "sourceSocket", "SourceConnection", "ourcechannel", "SourceStream", "ourceChannel", "SourceChannel", "srcConnection", "Sourcechannel", " sourceChan", "targetChan"], "destinationChannel": ["destinatedFile", "DestinationChannel", "destinatorConnection", "destationConnection", "Destinatorchannel", "destinatedConnection", "destinateConnection", "destationchannel", "DestinationStream", "destinationFile", "destationFile", "destinationStream", "Destinationchannel", "destructionChannel", "destinationConnection", "DestinationFile", "DestinatingChan", "DestinatorChannel", "DestinationConnection", "DestinatingStream", "destinatorChannel", "destinatedStream", "destinationchannel", "destinatingChannel", "destinatorChan", "DestinatorConnection", "destinatorStream", "destationChannel", "destinateChan", "DestinatorChan", "destinatingManager", "destructionConnection", "destinatedchannel", "destinationManager", "DestinatorFile", "destinatingChan", "destinatorManager", "DestinationManager", "destinationChan", "DestinatingChannel", "destinatedChan", "destinatingStream", "destinatorFile", "destinatedManager", "DestinationChan", "destinatorchannel", "destructionChan", "DestinatingManager", "destinateChannel", "destinatedChannel"]}}
{"id1": "6421904", "id2": "11933797", "code1": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"addRecord": ["appendrecord", "appendRec", "createRec", " addrecord", "addRec", "addrecord", "createrecord", "createRecord", "appendRecord", "appendFile", "createFile", " addFile", " addRec", "addFile"], "input": ["active", "reader", "inf", "data", "current", "error", "session", "audio", "stream", "load", "xml", "hole", "conn", "text", "instance", "flow", "back", "temp", "this", "buffer", "source", "storage", "image", "value", "request", "exec", "form", "context", "config", "document", "raw", "null", "http", "up", "php", "resource", "out", "progress", "Input", "media"], "temporary": ["exporary", "temacher", "tmemporary", "thetemp", "tytemp", "typerature", "timporary", "formtemp", "transporal", "emporary", "destemporary", "tempporal", "transolute", "temolute", "Temporal", "destporal", "formmanent", "semmanent", "tmporal", "temptemp", "destporary", "tomperature", "Temmanent", "emporal", "tommanent", "temtemp", "timemporary", "experature", "semperature", "tomporal", "timporal", "mporal", "tempperature", "typoral", "timermanent", "tmtemp", "tmermanent", "separporary", "exolute", "temperature", "mporary", "formporal", "timolute", "theperature", "timperature", "theemporary", "transperature", "transporary", "theermanent", "destacher", "exporal", "tacher", "temporal", "tememporary", "Temperature", "tmperature", "temmanent", "Temtemp", "typorary", "tymanent", "Temporary", "semporary", "separporal", "tmporary", "emperature", "theporal", "mperature", "theporary", "semporal", "formporary", "separmanent", "temermanent", "tporal", "separperature", "tempporary", "tempemporary", "tomporary", "tporary", "tmacher"], "tempId": ["tmpId", "tmpID", "fakeId", "inputID", " tempid", "tempPath", "tempid", "inputId", "tempName", "fakeid", "fakeName", "TempID", "tempID", "Tempid", "TempId", "TempPath", " tempName", "tmpPath", "poraryid", "inputPath", "tmpid", "poraryId", "TempName", "inputid"], "length": ["full", "lock", "offset", "open", "volume", "ext", "sequence", "loc", "data", "name", "version", "slice", "type", "range", "audio", "Length", "array", "download", "load", "library", "position", "description", "time", "size", "text", "section", "content", "l", "distance", "shape", "capacity", "key", "angle", "count", "style", "value", "limit", "driver", "path", "filename", "url", "width", "number", "code", "read", "duration", "id", "len", "result", "total", "json", "string", "write", "ob"], "digest": ["signEST", " digraph", "generest", "decEST", "Digist", " digests", "DigEST", "fester", "Digester", "fest", " Digest", "fraph", "digested", "signests", "digester", "digraph", "digEST", "digist", "signraph", "generist", "decested", "decest", "fests", "signester", " digEST", "Digested", "decist", "signested", " Digester", "generEST", "signest", " DigEST", "digests", "generested", " digested", " digester", "Digest"], "output": ["connection", "office", "data", "channel", "socket", "put", "operation", "application", "web", "letter", "binary", "log", "control", "plain", "copy", "writer", "export", "address", "temp", "console", "external", "source", "image", "response", "object", "outer", "other", "exit", "config", "document", "unit", "null", "tube", "message", "cut", "result", "out", "resource", "target", "queue", "write", "Output"], "file": ["lock", "data", "current", "name", "self", "pool", "type", "letter", "binary", "class", "picture", "work", "single", "buffer", "source", "real", "ile", "path", "other", "url", "uri", "null", "function", "message", "resource", "queue", "directory", "open", "it", "File", "socket", "handler", "play", "auto", "fe", "local", "log", "rule", "page", "cache", "entity", "zip", "or", "document", "code", "let", "up", "folder", "id", "php", "word", "home", "use", "f", "place", "complete", "create", "p", "per", "plain", "model", "line", "e", "temp", "this", "show", "lib", "style", "image", "live", "feed", "http", "po", "FILE", "dir", "fp", "full", "connection", "get", "force", "base", "future", "user", "time", "l", "comment", "child", "filename", "object", "view", "server", "unit", "pe", "string"], "parent": ["full", "Parent", "data", "current", "name", "master", "container", "handler", "type", "remote", "create", "to", "p", "per", "parents", "base", "class", "copy", "fat", "cache", "part", "root", "and", "key", "temp", "source", "block", "image", "child", "port", "or", "large", "path", "unit", "null", "id", "pa", "resource", "out", "dir", "home", "directory", " Parent", "location"], "now": ["active", "cur", "once", "current", "cycle", "lim", "type", "low", " NOW", "first", "from", "comp", "since", "ct", "info", "auto", "today", "wait", "load", "Now", "not", "gen", "currently", "set", "ow", "node", "time", "size", "max", "this", "cmp", "ci", "or", "age", "next", "night", "view", "date", "post", "id", "NOW", "co", "last", "hour", "day", "always", "start"]}}
{"id1": "9954926", "id2": "19467540", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    @Override\n    public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) {\n        Connection conexion = null;\n        PreparedStatement select = null;\n        PreparedStatement update = null;\n        ResultSet rs = null;\n        boolean exito = false;\n        try {\n            conexion = pool.getConnection();\n            conexion.setAutoCommit(false);\n            select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\");\n            update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\");\n            String codigoProd;\n            int filasAfectadas = 0;\n            Iterator<String> iterador = carro.keySet().iterator();\n            while (iterador.hasNext()) {\n                codigoProd = iterador.next();\n                select.setString(1, codigoProd);\n                rs = select.executeQuery();\n                if (rs.next() == false) {\n                    Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\");\n                    iterador.remove();\n                    conexion.rollback();\n                } else {\n                    Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\"));\n                    select.clearParameters();\n                    if (carro.get(codigoProd) > prod.getStock()) {\n                        Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\");\n                        iterador.remove();\n                        conexion.rollback();\n                    } else {\n                        update.setInt(1, prod.getStock() - carro.get(codigoProd));\n                        update.setString(2, codigoProd);\n                        filasAfectadas = update.executeUpdate();\n                        if (filasAfectadas != 1) {\n                            Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\");\n                            conexion.rollback();\n                        }\n                        update.clearParameters();\n                        listado.put(prod, carro.get(codigoProd));\n                    }\n                }\n            }\n            conexion.commit();\n            exito = true;\n        } catch (SQLException ex) {\n            logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex);\n            try {\n                conexion.rollback();\n            } catch (SQLException ex1) {\n                logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1);\n            }\n        } finally {\n            cerrarConexionYStatement(conexion, select, update);\n            cerrarResultSet(rs);\n        }\n        return exito;\n    }\n", "label": 0, "substitutes": {"simulate": ["imulation", "simulation", "animulator", "animure", "animulate", "Simure", "animulation", "imulator", "imure", "imulate", "simulator", "Simulator", "simure", "Simulation", "Simulate"], "out": ["lock", "data", "name", "pool", "down", "outs", "w", "err", "flow", "o", "flush", "buffer", "cli", "exit", "null", "io", "co", "resource", "report", "exp", "tmp", "point", "error", "session", "table", "sys", "log", "page", "cache", "conn", "output", "key", "client", "outer", "parent", "group", "up", "word", "result", "info", "state", "dump", "plain", "copy", "part", "writer", "line", "pre", "temp", "external", "lib", "store", "raw", "prefix", "con", "Out", "obj", "full", "bin", "ex", "gen", "base", "user", "again", "OUT", "comment", "list", "db", "object", "view", "server", "post", "net", "in", "window", "string", "write", "now"], "file": ["full", "connection", "le", "f", "data", "name", "File", "socket", "handler", "book", "stream", "fe", "log", "base", "rule", "page", "cache", "b", "loader", "output", "files", "l", "line", "collection", "address", "buffer", "source", "feed", "ile", "port", "path", "filename", "url", "unit", "pe", "in", "message", "FILE", "resource", "fp", "queue", "report"], "obtainUserReputationRequest": ["obtainUserRepurationQuery", "obtainUserReputedResponse", "obtainUserReputationInput", "obtainUserReputablerequest", "obtainUserReputionRequest", "obtainUserRepentionResponse", "obtainUserRelentionrequest", "obtainUserReputionResponse", "obtainUserReputableRequest", "obtainUserRelutationGrant", "obtainUserComputationEntry", "obtainUserRelutationRequest", "obtainUserComputeInput", "obtainUserReputedRequest", "obtainUserReputableResponse", "obtainUserReputationrequest", "obtainUserReputationGrant", "obtainUserReputeRequest", "obtainUserAnnutationQuery", "obtainUserAnnigrationResponse", "obtainUserReputeEntry", "obtainUserComputationInfo", "obtainUserReputedrequest", "obtainUserRelentionResponse", "obtainUserRelutationResponse", "obtainUserReputeQuery", "obtainUserAnnigrationRequest", "obtainUserRepositoryrequest", "obtainUserRepigrationrequest", "obtainUserReputionGrant", "obtainUserRepigrationResponse", "obtainUserRepulationResponse", "obtainUserRepurationGrant", "obtainUserReputedGrant", "obtainUserRepulationInput", "obtainUserComputerequest", "obtainUserComputeEntry", "obtainUserComputationInput", "obtainUserReputerequest", "obtainUserRepositoryRequest", "obtainUserRepigrationRequest", "obtainUserAnnutationResponse", "obtainUserComputeInfo", "obtainUserAnnigrationGrant", "obtainUserComputeRequest", "obtainUserRepurationRequest", "obtainUserRepurityInput", "obtainUserRepulationEntry", "obtainUserRepigrationGrant", "obtainUserAnnutationRequest", "obtainUserReputeResponse", "obtainUserRelentionRequest", "obtainUserRepentionGrant", "obtainUserRelutationrequest", "obtainUserComputationRequest", "obtainUserReputeInfo", "obtainUserComputationrequest", "obtainUserRepurityRequest", "obtainUserRepentionrequest", "obtainUserComputeResponse", "obtainUserReputationQuery", "obtainUserRepositoryInfo", "obtainUserAnnutationGrant", "obtainUserRepurityEntry", "obtainUserReputeGrant", "obtainUserRepigrationQuery", "obtainUserReputeInput", "obtainUserRepigrationInfo", "obtainUserRepositoryResponse", "obtainUserReputationInfo", "obtainUserComputationResponse", "obtainUserRelentionGrant", "obtainUserRepulationRequest", "obtainUserRepurationResponse", "obtainUserRepentionRequest", "obtainUserReputionrequest", "obtainUserReputationEntry", "obtainUserRepurityResponse", "obtainUserAnnigrationQuery"], "obtainUserReputationResponse": ["obtainUserExputationRequest", "obtainUserRepositoryRequest", "obtainUserExpositoryResp", "obtainUserExputationResponse", "obtainUserRepositoryResp", "obtainUserRepurationRequest", "obtainUserExpositoryResponse", "obtainUserRepositoryResponse", "obtainUserReputationResp", "obtainUserReputeResponse", "obtainUserRepurationResponse", "obtainUserExputationResp", "obtainUserRepurationResp", "obtainUserReputeRequest", "obtainUserExpositoryRequest", "obtainUserReputeResp"], "rateUserRequest": ["rateMachineVersion", "rateFileCommand", "ratedUserFunction", " rateUserUser", "ratedFileCommand", "rateUForce", "rateLineCustomer", "RateFileQUEST", "rateUsageForce", "ratePostRequest", "rateHumanRequest", " rateUserQuery", "ratedUserrequest", "rateServiceCommand", "rateUSERRequest", "rateUserResult", "ratedFileQuery", " rateuserrequest", "rateServiceFunction", "RateFileRequest", "ratedUserRequest", "rateCustomerQUEST", "rateUsageRequest", "featureUserResult", "RateUserRequest", "rateUrequest", "rateUserQUEST", "rateCustomerForce", "rateUsageReturn", "issueCustomerQUEST", "ratedUsageQUEST", "rateUResponse", "rateApplicationUser", "rateApplicationRequest", "gradeLineError", "rateUserReturn", "rateLinerequest", "rateFileVersion", " rateuserQUEST", "rateUSERQUEST", "rateUsReturn", "rateUQuery", "rateUsageGrant", "rateServiceRequest", "rateHumanrequest", "rateServiceQuery", "ratePostQUEST", "ratedUsageQuery", "rateUError", "ratedFileRequest", "gradeLineCustomer", "rateWordQuery", "ratedUserForce", "rateUserError", "featureMachineRequest", "featureUserRequest", "rateClientrequest", "rateUserCommand", "gradeLineRequest", "rateUsageQUEST", "issueUserRequest", "rateMachineResult", "issueUserReturn", "ratedUserQuery", "rateLineQuery", "ratedUsagerequest", " rateApplicationUser", "issueCustomerRequest", "rateFileQUEST", "issueUserForce", "gradeUserError", "rateFileFunction", "RateFilerequest", "RateUserResponse", "rateuserrequest", "rateURequest", "rateFileRequest", "rateLineGrant", " rateuserRequest", "ratedUserQUEST", " rateApplicationRequest", " rateUserQUEST", "rateHumanVersion", "featureMachinerequest", " rateApplicationQuery", "featureMachineVersion", "RateUserrequest", "gradeUserrequest", " rateClientrequest", "rateMachineRequest", "ratePostrequest", "rateUserVersion", "rateUSERForce", "rateUCommand", "rateCustomerReturn", "rateUCustomer", "rateLineResponse", "rateFileResponse", "issueCustomerReturn", "rateUsagerequest", " rateUserGrant", "RateFileResponse", "rateUsRequest", "rateWordrequest", " rateClientRequest", "RateUserQUEST", "rateLineError", "rateUQUEST", "rateWordError", "rateCustomerRequest", "rateUFunction", "ratePostResponse", "rateuserResponse", "ratedUserCommand", "rateFileUser", "ratedUsageRequest", "rateLineRequest", "rateUserUser", "rateClientGrant", "rateLineQUEST", "rateHumanResult", "rateFilerequest", "gradeUserRequest", "rateUserQuery", " rateClientGrant", "featureMachineResult", "rateuserRequest", "rateUserCustomer", "gradeLinerequest", "rateUsQUEST", " rateuserResponse", "issueUserQUEST", "rateUserFunction", "rateUSERrequest", "ratedFileFunction", "rateFileQuery", " rateUserrequest", "rateClientRequest", "rateApplicationResponse", "rateUserForce", "ratedUsageForce", "rateMachinerequest", "featureUserrequest", "rateUserGrant", "gradeUserCustomer", "rateFileResult", "rateUsageUser", "issueCustomerForce", "rateUsageResponse", "rateUserrequest", "rateApplicationQuery", "rateUsForce", "rateUsageQuery", "rateWordCustomer", "featureUserVersion", " rateApplicationResponse", "rateWordRequest", "rateuserQUEST"], "rateUserResponse": ["rateClientStatus", " rateUresponse", " rateApplicationResp", " rateUReply", "rateClientResponse", " rateUResponse", "RateUserCustomer", "rateUserResult", "RateUserRequest", "rateCustomResponse", "rateUResponse", "rateUserReference", "rateUserStatus", " rateUserResp", "rateuserresponse", "rateUsersResource", "rateCustomResp", "rateClientResp", "rateUReply", "RateTimeStatus", "RateUserStatus", "rateUsersResult", " rateApplicationReference", "rateUsersRequest", "rateFileResp", "rateTimeCustomer", "rateUserResp", "rateUserResource", "rateClientCustomer", "rateApplicationResp", "RateUserResponse", "rateCustomerResp", "RateTimeResp", " rateUResp", "rateUserresponse", "rateCustomCustomer", "rateApplicationReference", " rateUserStatus", "rateuserStatus", "rateCustomerData", "rateUresponse", "rateTimeStatus", "rateCustomStatus", " rateApplicationData", "rateUsersStatus", "rateFileResponse", " rateFileResult", "rateuserReference", " rateUserReference", "rateUResp", "rateApplicationData", "rateFileStatus", "rateCustomerRequest", "rateuserResponse", "rateTimeResp", " rateFileResponse", "rateFileReply", "rateTimeResponse", "RateTimeCustomer", "rateuserResp", "RateTimeResponse", "rateUserCustomer", "rateCustomerResource", "rateuserReply", "rateCustomerReference", " rateUserResult", "RateUserResource", "rateFileresponse", " rateFileStatus", "rateuserResult", "rateApplicationResponse", " rateUserReply", " rateUserresponse", "rateUsersResponse", "rateuserData", "rateUsersResp", "rateUserReply", "rateCustomerResponse", "rateFileResult", " rateFileResp", "RateUserResp", "rateUserData", " rateApplicationResponse", " rateUserData"], "fis": ["fiss", " fris", "bIs", "sfIs", "sfris", "sfiss", "FIs", "fIs", " fIs", "Fis", "bris", "Fiss", "bis", " fiss", "fris", "Fris", "sfis", "biss"], "br": ["reader", "Br", "ob", "arr", "bs", "body", "str", "bed", " fr", "bl", " bio", "pr", "b", "bridge", "cr", "r", "bp", "err", "fr", "bc", "dr", "rb", "buffer", "BR", "sp", "hr", "brush", "ch", "sw", "lr", "browser", "io", "wr", "gr", "bro", "tr", "result", "res", "fin", "ref", "ber", "ler", " tr", "Reader", "buf"], "call": ["msg", "f", "data", "doc", "name", "loc", "phone", "called", "type", "play", "sc", "ack", "body", "create", "info", "ck", "load", "str", "xml", "check", "roll", "text", "output", "user", "throw", "callback", "query", "line", "work", "e", "cell", "flow", "address", "buffer", "comment", "fax", "Call", "cat", "request", "response", "Line", "url", "cod", "cl", "code", "calling", "cu", "c", "ell", "message", "co", "result", "input", "contact", "charge", "voice", "claim", "push", "string", "use", "invoke"]}}
{"id1": "15799935", "id2": "841724", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedPart", "saveAttachedBody", "saveAppensionFile", "saveAttPartPart", "saveAttachmentPart", "saveAttachedFile", "saveAttensionBody", "saveAttPartFile", "saveAppachmentbody", "saveAppensionbody", "saveAttensionbody", "saveAppensionPart", "saveAttachedbody", "saveAttachmentFile", "saveAppachmentFile", "saveAttachmentbody", "saveAttPartBody", "saveAppachmentPart", "saveAttensionFile", "saveAppensionBody", "saveAppachmentBody", "saveAttensionPart", "saveAttPartbody"], "context": ["connection", "reader", "current", "Context", "version", "manager", "present", "channel", "container", "support", "cca", "ca", "state", "cms", "event", "definition", "center", "component", "cache", "text", "front", "concept", "content", "collection", "translation", "client", "subject", "service", "kernel", "ctx", "template", "cf", "request", "parent", "driver", "project", "environment", "system", "config", "document", "view", "c", "ce", "message", "community", "resource", "input", "queue", "mc", "coll", "contact", "host", "network", "processor", "media"], "part": ["connection", "app", "name", "point", "channel", "place", "type", "from", "body", "to", "p", "partial", "state", "phase", "event", "art", "per", "base", "component", "position", "parts", "Part", "section", " parts", "pre", "translation", "patch", "mission", "PART", " Part", "comment", "service", "source", "block", "pod", "image", "or", "media", "parent", "object", "file", "message", "upload", "po", "chapter", "plan", "area", "html", "Parts", "start"], "localAttachment": ["LocalAssachment", " localAttachachment", "localPartribution", "localAttachension", "localAttension", "localAvacher", " localAttrollment", "LocalAttment", "localAvacement", "localInstribution", "localAttacement", "localArtment", " localAttribution", " localAttention", "localAddment", "localAttment", " localAttacement", " localExtachment", " localPartension", "LocalAttention", "localattention", "localattrollment", "localAssention", " localPartribution", "LocalAssail", "localAvachment", "localPartension", "localAvention", "localArtail", "localAssment", " localPartention", "localAttachrollment", "LocalAttachment", "localAssail", " localExtacement", "localAddrollment", "localAttachention", "LocalAttail", "localPartention", "localExtacher", " localAttension", "localAttachacement", "localAttacher", "localPartachment", "localAttribution", "localAddail", " localExtacher", "LocalAssment", "localattachment", "localArtention", " localExtention", "localAttention", " localAttachrollment", "localAttrollment", " localAttacher", "localArtachment", "localAttail", "localAssachment", " localPartachment", " localAttment", "localExtacement", "localExtachment", "localAttachachment", "localAttachribution", "LocalAssention", "localInstachment", "localInstention", " localAttachention", "localExtention", "localInstension", "localAddachment", "localattment", "localAddention", "localAttachacher"], "accountId": ["contractId", "contractName", "jobid", "accountInfo", "contactid", "jobId", "appInfo", " accountID", "AccountName", "appId", "accountid", "feedID", "Accountid", "appID", "accInfo", " accountid", "feedid", "accId", "accountID", "appid", "feedName", "feedId", "AccountId", "jobName", "jobID", "accID", "AccountID", "accid", " accountInfo", "accountName", "contractid", "contactName", "contactId", " accountName"], "attachmentId": ["addachmentID", "attociationID", "attlementName", "attmentId", "atachmentReference", "attociationType", "addachmentType", "extachmentid", "adachmentID", "attentionId", "addentionID", "attmissionID", "attmissionId", "extachmentId", "atachmentName", "atociationReference", "attensionSource", "attentionSource", "adachmentInfo", "atociationName", "attlementId", "attmentName", "attmentReference", "attociationId", "attachmentID", "attachedType", "attentionIndex", "attentionUrl", "attociationReference", "atociationID", "extachmentSource", "attociationUrl", "attlementReference", "attociationName", "attachmentReference", "attlementID", "attensionid", "attachmentSource", "attentionType", "attachedID", "attentionid", "extensionSource", "atociationId", "attachedUrl", "attptionID", "adachmentIndex", "attensionID", "addentionId", "extensionid", "attptionId", "adentionIndex", "attmissionSource", "attmissionid", "attachmentType", "attachmentIndex", "attachmentInfo", "addachmentId", "adentionInfo", "attagramIndex", "attachmentUrl", "attagramInfo", "atachmentID", "adachmentId", "atachmentId", "addachmentUrl", "attachmentName", "attptionIndex", "attmentID", "extachmentID", "attentionID", "attachmentid", "attptionInfo", "attachedId", "extensionId", "attentionInfo", "adentionId", "extensionID", "addentionUrl", "attensionId", "attagramID", "attagramId", "adentionID", "addentionType"], "in": ["reader", "bin", "login", "f", "data", "it", "socket", "slice", "ins", "pin", "p", "cin", "info", "load", "In", "is", "inside", "copy", "conn", "inner", "again", "din", "IN", "err", "plus", "pull", "ini", "i", "source", "init", "image", "inc", "nin", "or", "url", "pass", "inn", "file", "as", "id", "up", "a", "input", "con", "ac", "gin"], "saveIn": [" savein", "savIn", "aveIn", "avein", "saveOut", "saveIN", "aveAs", " saveIns", "stageIn", "savAs", "writeIN", " saveOut", "SaveIns", "writeIn", "aveOut", "savOut", "stageOut", "savein", "stageIns", "SaveIn", "saveIns", "stageAs", " saveIN", "savin", "writeOut", "SaveAs", "aveIN", "SaveOut", "writein"], "saveAs": ["openAs", "copyAs", "saveAt", "openAS", "saveOut", "createAt", "copyas", " saveOut", "copyIn", "writeIn", " saveas", " saveAS", "writeAs", "SaveAS", "createAS", "saveAS", "SaveIn", "createAs", "saveFile", " saveFile", "copyAS", " saveAt", "writeOut", "openAt", "openFile", "SaveAs", "saveas", "writeAS", "SaveOut", "createFile", "Saveas"], "out": ["bin", "ext", "data", "name", "at", "s", "sync", "to", "ex", "outs", "copy", "page", "conn", "again", "output", "cache", "inner", "line", "writer", "err", "flow", "o", "client", "off", "OUT", "temp", "this", "plus", "source", "init", "image", "inc", "path", "exec", "outer", "v", "other", "default", "null", "io", "c", "file", "as", "up", "a", "Out", "string"], "copySize": ["CopyTime", " copyTime", "saveLength", "leSize", "byteTime", " copySIZE", "saveSize", "savesize", "lesize", "copyAddress", "CopySize", "openSIZE", "copyTime", "leLength", "copySIZE", "leSIZE", "Copysize", " copysize", "bytesize", "copysize", "byteAddress", " copyLength", "openLength", "copyLength", "saveAddress", "CopyLength", "byteLength", "opensize", " copyAddress", "openSize", "byteSize"], "contentUriString": ["contentUioStr", "contentIiByte", "contentUiniByte", "contentUridStr", "contentUrisString", "contentUioInt", "contentUpiInt", "contentUriUnit", "contentUpiStr", "contentUriByte", "contentUiNumber", "contentUriStr", "contentIrisInt", "contentUrisstring", "contentUiByte", "contentIrisStr", "contentUiostring", "contentUpiString", "contentIriStr", "contentIrisUnit", "contentUuriByte", "contentIriInt", "contentIiStr", "contentUridString", "contentUuriString", "contentUrisUnit", "contentUiString", "contentIrisString", "contentIriByte", "contentUuriNumber", "contentIiNumber", "contentIiString", "contentIristring", "contentUioString", "contentUiStr", "contentIrisstring", "contentUiniNumber", "contentUridUnit", "contentUiniStr", "contentUriInt", "contentUriNumber", "contentUuriStr", "contentUrisStr", "contentUiUnit", "contentUpistring", "contentUrisInt", "contentIriNumber", "contentUiniString", "contentIriString", "contentUristring", "contentIriUnit"], "mSize": ["pLength", "iLength", "cCount", "cSize", "mCount", "mLength", "pSize", "cLength", "mName", "pName", "iCount", "iSize", "iName", "cName", "pCount"], "mContentUri": ["mContentIci", "mResourceUric", "mContentUrci", "mResourceIris", "mContentUci", "mResourceUri", "mContentUric", "mContentOUri", "mContentUrris", "mContentIric", "mResourceUci", "mContentUris", "mContentIris", "mContentOUris", "mResourceUris", "mResourceIri", "mResourceIci", "mResourceIric", "mContentOUci", "mContentUrri", "mContentIri", "mContentOUric", "mContentUrric"], "cv": ["nv", "GV", "cb", "keep", "loc", "cd", "nc", "CV", "av", "vp", "sc", "iv", "ca", "cap", "vr", "enc", "vv", "rc", "cs", "lc", "iq", "auc", "csv", "content", "sv", "cr", "vm", "um", "bc", "cc", "ctx", "vc", "uc", "cf", "xc", "v", "vs", "conv", "core", "cu", "uv", "c", "lv", "VC", "co", "ov", "coll", "cm", "cover", "mc", "fp", "que", "ctrl", "cp", "fc", "pb", "buf"], "uri": ["URI", " url", "data", "point", "ri", "gb", "iri", "iv", "range", "pi", "universal", "base", "oid", "format", " ur", "href", "qi", "query", "address", "proxy", "i", "cli", "ci", "storage", "api", "path", "environment", "url", " scheme", "ui", "mi", "attribute", " Uri", "route", "metadata", "http", "id", "prefix", "resource", "uid", "location", "uni", "string", " URI", "username"]}}
{"id1": "21348951", "id2": "15757836", "code1": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "code2": "    private int[] sort(int n) {\n        int[] mas = new int[n];\n        Random rand = new Random();\n        for (int i = 0; i < n; i++) {\n            mas[i] = rand.nextInt(10) + 1;\n        }\n        boolean t = true;\n        int tmp = 0;\n        while (t) {\n            t = false;\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    tmp = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = tmp;\n                    t = true;\n                }\n            }\n        }\n        return mas;\n    }\n", "label": 0, "substitutes": {"processAddByURLSubmit": ["processAddByURLSubmission", "processAddByURLSummitted", "processAddByURlsubmit", "processAddByURLSUBmit", "processAddByURLSsubmitter", "processAddByURlsUBmission", "processAddByURLSsubmission", "processAddByURLSubmitted", "processAddByURlsUBmitted", "processAddByURlsubmitted", "processAddByURlsubmitter", "processAddByURLSummitter", "processAddByURlsUBmitter", "processAddByURLSUBmission", "processAddByURLSUBmitter", "processAddByURlsubmission", "processAddByURLSummit", "processAddByURLSsubmit", "processAddByURlsUBmit", "processAddByURLSUBmitted", "processAddByURLSubmitter", "processAddByURLSummission", "processAddByURLSsubmitted"], "url": ["connection", "sl", "data", "loc", "org", "email", "ur", "secure", "stream", "str", "xml", "ug", "base", "ssl", "ll", "log", "ls", "page", "user", "l", "e", "address", "Url", "buffer", "URL", "source", "image", "entry", "feed", "path", "server", "uri", "route", "io", "http", "file", "src", "resource", "www", "host", "link", "ref", "location", "string", "ob"], "invalidUrlMsg": ["invalidTimeStr", "invalidTimemsg", "invalidURLmsg", "invalidUrlMessage", "invalidFileMsg", "invalidURLog", "invalidURLUrl", "invalidURLStr", "inbadFileMsg", "invalidUrlmsg", "inInvalidURLmsg", "invalidUrmsg", "invalidFileog", "invalidUrog", "invalidStringMessage", "invalidStringUrl", "invalidTimeMessage", "inInvalidUrlMessage", "inInvalidUrlUrl", "inInvalidUrlStr", "invalidStringmsg", "inbadFilemsg", "invalidUrlUrl", "inInvalidURLMessage", "inbadUrlmsg", "invalidUrlStr", "inbadUrlMsg", "invalidFileUrl", "inbadFileMessage", "invalidURLMessage", "invalidFileStr", "invalidUrlog", "invalidStringMsg", "inbadUrlog", "inbadUrlMessage", "inInvalidUrlMsg", "invalidFileMessage", "inInvalidURLMsg", "inInvalidURLUrl", "invalidUrMessage", "invalidFilemsg", "invalidURLMsg", "inInvalidUrlmsg", "invalidTimeMsg", "inInvalidURLStr", "inbadFileog", "invalidUrMsg"], "xmlSourceWriter": [" xmlSourceString", "jsonStringwriter", " xmlourceWritten", "xmlResourceWritten", "xmlSourceWrite", "xmlourceWriter", "xmlResourceReader", "xmlSourceString", "xmlInputWriter", "xmlReaderWrite", "xmlResourceString", "xmlInputWritten", "xmlStringWrite", "xmlourceString", "jsonSourceWrite", "jsonStringReader", "xmlStringWriter", " xmlourceReader", "jsonSourceReader", "xmlStrWrite", "jsonReaderReader", "jsonSourceWritten", "xmlStrwriter", "xmlStrWriter", "xmlSourceReader", "xmlReaderWriter", "xmlReaderWritten", "xmlResourceWriter", "xmlSourceWritten", "jsonReaderWritten", " xmlSourceWritten", " xmlourceWriter", "jsonSourceWriter", "xmlSourcewriter", "xmlServiceWriter", "xmlServiceWritten", "jsonStringWrite", "jsonReaderWrite", "xmlStringReader", "xmlourceReader", "jsonStringWriter", "xmlServicewriter", "xmlServiceWrite", "jsonReaderWriter", "xmlInputWrite", " xmlourceString", "xmlInputString", "xmlourceWritten", "xmlInputReader", "jsonSourcewriter", "xmlStringwriter", "xmlStrReader", "xmlServiceReader", " xmlSourceReader", "xmlReaderReader"]}}
{"id1": "807346", "id2": "324679", "code1": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "code2": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"runScript": ["execJS", " runJS", "runscript", " runscript", "runJS", "RunCode", "execscript", "execCode", " runCode", "RunScript", "runCode", "RunJS", "Runscript", "execScript"], "scriptName": ["scriptNames", "scriptPath", "codeNames", "scriptUrl", "fileName", "codePath", "ScriptName", "scriptname", "ScriptUrl", " scriptNames", " scriptPath", " scriptname", "ScriptFile", "ScriptPath", " scriptUrl", " scriptFile", "fileUrl", "filePath", "Scriptname", "fileFile", "codename", "scriptFile", "ScriptNames", "codeName"], "data": ["missing", "layout", "name", "error", "batch", "complete", "type", "body", "results", "partial", "info", "one", "div", "str", "base", "format", "html", "part", "text", "output", "alpha", "content", "key", "this", "buffer", "i", "source", "ata", "value", "api", "feed", "write", "response", "template", "next", "no", "number", "raw", "code", "empty", "split", "function", "DATA", "script", "a", "valid", "message", "action", "index", "result", "dat", "input", "append", "out", "json", "string", "media", "start"], "url": ["connection", "open", "sl", "f", "stream", "web", "base", "ll", "ssl", "ls", "bb", "log", "page", "b", "user", "zip", "l", "Url", "buffer", "URL", "source", "i", "image", "feed", "service", "path", "server", "uri", "browser", "http", "up", "file", "impl", "id", "ball", "resource", "www", "bel", "host", "rl"], "in": ["reader", "bin", "login", "f", "socket", "s", "ins", "stream", "cms", "In", "is", "ssl", "with", "b", "inner", "conn", "win", "din", "r", "IN", "err", "client", "ini", "buffer", "i", "source", "inc", "pass", "inn", "file", "as", "id", "a", "fd", "resource", "input", "out", "ac", "gin", "serv"], "buffIn": ["bufin", "bbOut", "buffin", "buffIns", "ufIn", "BuffOut", "bufIn", "buffedIn", "bufferIn", "bufferedIn", "bufferin", "bbIn", "bufIns", "Buffin", "bufferIns", "BuffIn", "buffOut", "BuffIns", "ufIns", "BuffedIn", "ufin", "bbIns", "ufedIn", "bbin", "bufOut"], "temp": ["offset", "extra", "iter", "f", "current", "start", "char", "Temp", "type", "pt", "stable", "emp", "partial", "enc", "div", "base", "ptr", "size", "num", "output", "content", "tem", "zip", "flow", "dest", "test", "buffer", "count", "i", "pointer", "source", "number", "read", "raw", "empty", "unit", "c", "index", "len", "tc", "cut", "input", "cel", "total", "fake", "length", " Temp", "wait", "tmp"]}}
{"id1": "22479286", "id2": "13981689", "code1": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"md5": ["m4", "sha4", "m512", "m2", "sha512", "md2", "sha5", "MD2", "m5", "MD4", "MD5", "MD512", "md512", "sha2", "md4"], "plainText": ["plainSecret", "messageContent", "coreTEXT", "publicTEXT", "regularText", "plainTEXT", " plainContent", "rubyText", "messageText", " plainByte", "regularSecret", " plainWidth", "publicText", "flattext", "messageSecret", "regularCode", " plainSecret", "singleText", "rubyValue", "plainByte", " plainTEXT", "regularShort", "encryptedtext", "coreContent", "rubyByte", "encryptedContent", " plainString", "flatShort", "flatTEXT", "publicContent", " plainCode", "plainCode", "plainValue", "plainContent", "coreValue", " plainValue", "flatKey", "regulartext", " plainKey", "plaintext", "encryptedText", "encryptedTEXT", "singleTEXT", "rubyContent", "extraByte", "extraContent", "regularContent", "publictext", "plainString", "extraText", " plainShort", "flatString", "plainWidth", "singleWidth", "messageCode", "flatWidth", "extraTEXT", "coreText", "flatText", "regularString", "rubyTEXT", "plainKey", "plainShort", "publicKey", " plaintext"], "md": ["meta", "df", "bd", "vd", "f", "mag", "mg", "cd", "rm", "gb", "wd", "dd", "m", " MD", "mt", "me", "dig", "mb", "am", "mac", "hm", "cmd", "dm", "sm", "d", "MD", "mo", "mod", "hash", "amd", "mp", "rpm", "metadata", "mm", "pm", "message", "sha", "mc", "ms", "pd", "mand", "ad", "hd", "Cmd", "de"], "digest": ["mdest", "digit", "dedested", "DigEST", "Digester", "compit", "digested", "dedEST", "dester", "dedex", "dimEST", "digitest", "dimex", "digitester", "digester", "dimest", "digitested", "digEST", "digitEST", "dest", "mdEST", "compest", "digger", "dimested", "dedest", " digEST", "Digested", "compEST", "Digger", "Digest", "mdit", "Digit", "Digex", "digex", " digested", "dEST", " digester", "compger", "dested", "mdger"], "hexString": ["exContent", "longText", "hexArray", "hexstring", "hexSingle", " hexArray", " hexBuffer", "exstring", "hexText", "rawBuffer", "longString", "exBuffer", " hexService", "longContent", "tempstring", "stringBuffer", "hexBuffer", "exText", "stringSingle", " hexSingle", "rawArray", "tempService", "tempBuffer", "tempString", "rawSingle", "rawString", "exService", "exString", "hexService", "stringArray", "hexContent", " hexContent", "longService", " hexstring", "stringString", " hexText"], "i": ["x", "f", "si", "it", "ti", "ri", "at", "s", "type", "slice", "m", "p", "j", "info", "pi", "k", "I", "di", "u", "b", "multi", "part", "bi", "qi", "l", "e", "o", "d", "count", "ci", "z", "t", "xi", "v", "oi", "ui", "number", "n", "li", "uri", "ii", "io", "c", "in", "id", "index", "a", "mu", "ai", "gi", "phi", "length", "start", "end"]}}
{"id1": "18217985", "id2": "20924119", "code1": "    public static String fromHtml(URL url, String defaultEncoding, boolean overrideEncoding) throws IOException, BadDocumentException {\n        URLConnection conn = url.openConnection();\n        String contentType = conn.getContentType();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) {\n            int i = contentType.indexOf(\"charset\");\n            if (i >= 0) {\n                String s = contentType.substring(i);\n                i = s.indexOf('=');\n                if (i >= 0) {\n                    s = contentType.substring(i + 1).trim();\n                    encoding = s.replace(\"\\'\", \"\").replace(\"\\\"\", \"\").trim();\n                    if (encoding.equals(\"\")) {\n                        encoding = defaultEncoding;\n                    }\n                }\n            } else {\n                encoding = defaultEncoding;\n            }\n        }\n        String expected = \"text/html\";\n        if (contentType == null) {\n            DefaultXMLNoteErrorHandler.warning(null, 90190, \"Returned content type for url.openConnection() is null\");\n            contentType = expected;\n        }\n        int index = contentType.indexOf(';');\n        if (index >= 0) {\n            contentType = contentType.substring(0, index).trim();\n        }\n        if (!contentType.equals(expected)) {\n            String msg = translator.translate(\"The content type of url '%s' is not '%s', it is '%s'\");\n            throw new BadDocumentException(String.format(msg, url.toString(), expected, contentType));\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        return fromHtml(in, encoding);\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 0, "substitutes": {"fromHtml": ["fromShText", "fromBushml", " fromPhtml", "fromHText", "fromPhml", " fromHml", " fromHHTML", "fromPhtml", "fromChUrl", " fromPhHTML", " fromPhttp", " fromHUrl", "fromShhtml", "fromHttptml", "fromChtml", " fromChUrl", "fromHttpText", " fromChhtml", "fromBushtml", "fromHml", "fromHhtml", "fromHttphtml", "fromHttpml", "fromShUrl", "fromPhHTML", "fromHttpHTML", "fromHttpttp", "fromHHTML", "fromHttpUrl", " fromHText", "fromChText", "fromHttp", "fromChhtml", " fromHttp", "fromHUrl", " fromChtml", " fromPhml", "fromBushHTML", "fromPhttp", "fromBushttp", " fromChText", " fromHhtml", "fromShtml"], "url": ["connection", "open", "sl", "f", "loc", "name", "org", "email", "ur", "remote", "web", "download", "str", "xml", "base", "ssl", "html", "blog", "page", "loader", "text", "domain", "article", "l", "r", "client", "address", "Url", "service", "URL", "cli", "image", "source", "ch", "or", "builder", "path", "api", "object", "response", "lr", "config", "uri", "server", "browser", "http", "file", "id", "www", "resource", "input", "host", "link", "ref", "location", "string", "obj", "il"], "defaultEncoding": ["defaultCoder", "defaultCoding", " defaultEncoder", "defaultChasing", "currentEnode", "currentEncoding", "defaultEnode", " defaultencasing", "currentEnasing", "defaultEncoder", "currentEnoding", "defaultEncasing", "defaultEngoding", "defaultEngoded", " defaultencoded", "defaultencoding", "defaultCasing", "defaultEngasing", "currentEnoded", "defaultencasing", "defaultChoding", " defaultEncoded", "defaultEncode", "defaultencoder", "defaultEnoded", "defaultChode", "currentEncoded", "defaultEnoder", "defaultEnasing", " defaultencoder", "defaultEncoded", "currentEncasing", "defaultencode", " defaultCoding", "defaultCoded", " defaultencoding", "defaultChoded", " defaultCasing", "defaultEnoding", "defaultEngoder", "currentEncode", " defaultEncasing", " defaultCoder", "defaultencoded", " defaultCoded"], "overrideEncoding": ["overrideencasing", "overwriteEnasing", "overwriteEnoded", "overwriteEncasing", "overwriteEncoding", "overrideencoder", "overrideCoder", "overrideEnoder", "overrideCoded", "overrideEncasing", "overrideEnoded", "overrideEncoder", "overrideencoded", "overrideencoding", "overrideEncoded", "overwriteEncoder", "overwriteEnoder", "overwriteEncoded", "overrideEnasing", "overrideCasing", "overrideCoding", "overwriteEnoding", "overrideEnoding"], "conn": ["connection", "nt", "open", "cb", "f", "loc", "cn", "reg", "socket", "nc", "session", "ct", "sync", "dn", "enc", "ann", "ssl", "conf", "cmd", "l", "err", "client", "dc", "cli", "ctx", "connect", "ch", "db", "api", "exec", "close", "config", "conv", "n", "server", "http", "c", "Conn", "co", "coll", "con", "out", "sql", "cp", "Connection", "ad", "serv", "act"], "contentType": ["contentLine", "worktype", " contentStyle", "ontentName", "filetype", " contentName", "resourceLength", "languageType", "Contenttype", "documentName", "ontentLength", "ContentFormat", "encLength", " contentUnit", "contenttype", "workToken", " contenttype", " contentPath", "resourceUnit", "codeType", "languageInfo", "documentText", "contentClass", "documentType", "contentFile", "languageStyle", "wordName", "filePath", "languagetype", " contentLine", "resourceName", "codeInfo", " contentFile", " contentInfo", "inputUnit", "codeName", "fileType", " contentText", "inputType", "encType", "ContentUnit", " contentLength", "resourcetype", "contentUnit", " contentFormat", "codeStyle", "ContentFile", "encToken", "ContentPath", " contentClass", "ContentType", "ContentName", "contentInfo", "resourceInfo", "ContentLine", "inputPath", "ontentClass", "ontentType", "contentStyle", "documentInfo", "contentToken", "ContentLength", "ontentPath", "contentText", "wordtype", "ontentFormat", "contentName", "inputtype", "wordType", "workLength", "ContentClass", "enctype", "contentLength", "ContentInfo", " contentToken", "workType", "inputLine", "contentFormat", "codeFile", "fileFile", "codetype", "contentPath", "codeUnit", "ContentText", "resourceType"], "encoding": ["ecoding", "encoded", "encasing", "engasing", " encoder", "coded", "execoded", "Encoding", "execasing", "encode", "execoder", "encapping", "ecoder", "Encaching", "enaching", "execoding", "engoding", "encoder", " encasing", "enoded", "ecasing", "caching", "engapping", "encaching", "enhryption", "casing", "equoder", "encryption", "equoded", "coding", " encosing", "equapping", "coder", "enoding", "Encasing", "Encode", " encapping", "equosing", "encosing", "enasing", "colloder", "equoding", "engoder", " encryption", "ecoded", "colloding", "enoder", "engosing", "enhasing", "enhoding", " encode", "engoded", "Encoded", "enhode", "Encryption", "colloded", "Encoder", "enosing", "collasing"], "i": ["x", "ji", "f", "si", "ti", "ri", "slice", "p", "j", "ori", "pi", "info", "ie", "ix", "is", "hi", "ei", "I", "di", "bi", "u", "multi", "lc", "qi", "l", "fi", "e", "o", "ini", "abi", "cli", "ci", "init", "api", "t", "h", "xi", "v", "yi", "ui", "oi", "mi", "li", "zi", "uri", "io", "ii", "c", "ni", "id", "iu", "mu", "eni", "gi", "ai", "phi", "adi", "area", "ip"], "s": ["sl", "su", "f", "ts", "sg", "si", "ds", "g", "session", "ins", "m", "sync", "p", "ns", "settings", "enc", "str", "en", "os", "ssl", "ls", "u", "abs", "b", "sv", "l", "r", "e", "o", "strings", "d", "service", "S", "source", "ws", "t", "js", "h", "v", "gs", "n", "ps", "details", "c", "as", "a", "sb", "ss", "es", "sym", "string", "fs", "ses", "site"], "expected": ["wrong", "required", "specified", "actual", "current", " expectation", "pretty", "ception", "force", "now", "error", "allowed", "email", "type", "pect", "pecting", "latest", "encrypted", "info", " received", " event", " Expect", "illegal", "event", "received", "supported", "ie", " e", "needed", "format", " email", " expect", " accepted", "forced", "opened", "nexpected", "e", "updated", "found", "style", "pected", "entry", "provided", " ie", "example", "response", "yet", "next", "default", "seen", " expecting", "handled", "acceptable", "ed", " expects", "target", "host", "fake", "failed", " unexpected", "reported", "element"], "index": ["x", "offset", "active", "open", "loc", "current", "point", "version", "where", "edit", "type", "slice", "array", "info", "option", "sort", "ind", "find", "ix", "match", "position", "page", "all", "size", "num", "weight", "output", "shape", "key", "address", "pull", "column", "ini", "list", "condition", "Index", "inc", "value", "connect", "object", "update", "level", "number", "width", "unit", "date", "id", "search", "pos", "prefix", "input", "diff", "length", "none", "alpha", "end", "element"], "msg": ["Msg", "ag", "mr", "gm", "sg", "doc", "name", "reg", "error", "reason", "Message", "g", "MS", "ma", "info", "mt", "printf", "str", "gen", "mit", "ug", "log", "format", "mid", "text", "mess", "cmd", "err", "lang", "dr", "og", "rr", " message", "comm", "fg", "gs", "agg", "details", "title", "message", "ms", "sim", "desc"], "in": ["reader", "bin", "connection", "login", "data", "tin", "inas", "ins", "stream", "p", "In", "xml", "b", "inner", "rin", "win", "din", "r", "IN", "err", "fr", "ax", "dr", "ini", "buffer", "inc", "read", "io", "inn", "c", "as", "id", "impl", "input", "out", "con", "gin", "rx"]}}
{"id1": "3806532", "id2": "8490297", "code1": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"createNew": ["writeRemote", " createnew", "requestFile", "requestnew", "writeFile", "createRemote", "createnew", "requestNew", " createRemote", "writenew", " createFile", "createFile", "requestRemote", "writeNew"], "name": ["x", "connection", "ame", "ext", "data", "self", "type", "space", "base", "part", "time", "size", "domain", "content", "old", "alias", "e", "key", "address", "this", "source", "common", "value", "child", "request", "path", "parent", "filename", "url", "default", "names", "Name", "server", "n", "uri", "null", "code", "file", "id", "prefix", "word", "action", "resource", "host", "named", "none", "string", "NAME", "username"], "in": ["reader", "bin", "connection", "isin", "login", "f", "data", "type", "ins", "pin", "cin", "info", "min", "In", "inside", "conn", "part", "inner", "size", "win", "r", "work", "IN", "plus", "pull", " IN", "ini", "i", "source", "image", "inc", "path", "exec", "url", "config", "read", "pass", "thin", "id", "index", "len", "resource", "input", "record", "con", "diff"], "length": ["offset", "lock", "sequence", "type", "Length", "body", "info", "load", "timeout", "ength", "time", "size", "content", "capacity", "address", "buffer", "count", "padding", "limit", "path", "filename", "level", "width", "number", "duration", "id", "len", "string"], "contentType": ["ContentLength", "contentToken", " contentToken", "acceptToken", "acceptType", "ContentType", " contentLength", " contenttype", "contenttype", "Contenttype", "accepttype", "acceptLength", "ContentToken", "contentLength"], "dest": ["cdn", "trip", "data", "sup", "opt", "loc", "later", "down", " destination", "cont", "comb", "destroy", "gen", "proc", "output", "txt", "img", "done", "fn", "coord", "dist", "temp", "this", "dc", "d", "source", "ctx", "uc", "project", "path", "asc", "parent", " Dest", "cl", "default", "config", "store", "null", "route", "flat", "func", "folder", "wb", "up", "file", "src", "Dest", "resource", "target", "dir", "home", "de", "desc", "obj", "through", "tmp", "rest"], "out": ["ext", "data", "version", "channel", "pool", "outs", "loop", "b", "cmd", "err", "flow", "off", "o", "exec", "url", "null", "io", "exp", "point", "socket", "session", "log", "page", "conn", "cache", "output", "plus", "key", "client", "call", "init", "parent", "up", "home", "gin", "bit", "x", "job", "qa", "f", "one", "copy", "part", "all", "line", "writer", "temp", "lib", "image", "inc", "n", "raw", "Out", "obj", "connection", "bin", "extra", "array", "sync", "ex", "base", "again", "password", "OUT", "child", "v", "view", "pass", "file", "diff", "window"]}}
{"id1": "807346", "id2": "19251426", "code1": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 0, "substitutes": {"runScript": ["execJS", " runJS", "runscript", " runscript", "runJS", "RunCode", "execscript", "execCode", " runCode", "RunScript", "runCode", "RunJS", "Runscript", "execScript"], "scriptName": ["scriptNames", "scriptPath", "codeNames", "scriptUrl", "fileName", "codePath", "ScriptName", "scriptname", "ScriptUrl", " scriptNames", " scriptPath", " scriptname", "ScriptFile", "ScriptPath", " scriptUrl", " scriptFile", "fileUrl", "filePath", "Scriptname", "fileFile", "codename", "scriptFile", "ScriptNames", "codeName"], "data": ["missing", "layout", "name", "error", "batch", "complete", "type", "body", "results", "partial", "info", "one", "div", "str", "base", "format", "html", "part", "text", "output", "alpha", "content", "key", "this", "buffer", "i", "source", "ata", "value", "api", "feed", "write", "response", "template", "next", "no", "number", "raw", "code", "empty", "split", "function", "DATA", "script", "a", "valid", "message", "action", "index", "result", "dat", "input", "append", "out", "json", "string", "media", "start"], "url": ["connection", "open", "sl", "f", "stream", "web", "base", "ll", "ssl", "ls", "bb", "log", "page", "b", "user", "zip", "l", "Url", "buffer", "URL", "source", "i", "image", "feed", "service", "path", "server", "uri", "browser", "http", "up", "file", "impl", "id", "ball", "resource", "www", "bel", "host", "rl"], "in": ["reader", "bin", "login", "f", "socket", "s", "ins", "stream", "cms", "In", "is", "ssl", "with", "b", "inner", "conn", "win", "din", "r", "IN", "err", "client", "ini", "buffer", "i", "source", "inc", "pass", "inn", "file", "as", "id", "a", "fd", "resource", "input", "out", "ac", "gin", "serv"], "buffIn": ["bufin", "bbOut", "buffin", "buffIns", "ufIn", "BuffOut", "bufIn", "buffedIn", "bufferIn", "bufferedIn", "bufferin", "bbIn", "bufIns", "Buffin", "bufferIns", "BuffIn", "buffOut", "BuffIns", "ufIns", "BuffedIn", "ufin", "bbIns", "ufedIn", "bbin", "bufOut"], "temp": ["offset", "extra", "iter", "f", "current", "start", "char", "Temp", "type", "pt", "stable", "emp", "partial", "enc", "div", "base", "ptr", "size", "num", "output", "content", "tem", "zip", "flow", "dest", "test", "buffer", "count", "i", "pointer", "source", "number", "read", "raw", "empty", "unit", "c", "index", "len", "tc", "cut", "input", "cel", "total", "fake", "length", " Temp", "wait", "tmp"]}}
{"id1": "17724879", "id2": "15262411", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    String fetch_pls(String pls) {\n        InputStream pstream = null;\n        if (pls.startsWith(\"http://\")) {\n            try {\n                URL url = null;\n                if (running_as_applet) {\n                    url = new URL(getCodeBase(), pls);\n                } else {\n                    url = new URL(pls);\n                }\n                URLConnection urlc = url.openConnection();\n                pstream = urlc.getInputStream();\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        if (pstream == null && !running_as_applet) {\n            try {\n                pstream = new FileInputStream(System.getProperty(\"user.dir\") + System.getProperty(\"file.separator\") + pls);\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        String line = null;\n        while (true) {\n            try {\n                line = readline(pstream);\n            } catch (Exception e) {\n            }\n            if (line == null) {\n                break;\n            }\n            if (line.startsWith(\"File1=\")) {\n                byte[] foo = line.getBytes();\n                int i = 6;\n                for (; i < foo.length; i++) {\n                    if (foo[i] == 0x0d) {\n                        break;\n                    }\n                }\n                return line.substring(6, i);\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"getDigest": ["getdigest", "getdigHash", "createdigHash", "createDigHash", "getdigester", "getMDest", "getdigests", "createDigester", "getMDests", "createDigest", "createdigester", "getSignests", "createDigests", "getSignest", "getMDHash", "getSignHash", "getMDester", "getDigests", "createdigests", "getSignester", "getDigHash", "createdigest", "getDigester"], "attribute": ["feature", "connection", "username", "data", "name", "manager", "type", "reference", "audio", "device", "operation", "ident", "pair", "layer", "application", "variable", "event", "definition", "set", "expression", "class", "plugin", "component", "instance", "entity", "att", "Attribute", "client", "address", "subject", "entry", "image", "value", "api", "object", "attr", "property", "character", "config", "document", "argument", "uri", "route", "metadata", "ribute", "function", "prefix", "message", "resource", "directory", "individual", "element", "node"], "digestAlgorithm": ["digesterAlgo", "digESTAlger", "digestalgebra", "digestAlgo", "digesterAlgebra", "digestALgorithm", "digesterAlgorithm", "digESTAlgo", "digestElgo", "digestAlger", "digestAlgorith", "digESTAlgorithm", "digestALgebra", "digesterAlgorith", "digestalgo", "digestAlg", "digestalg", "digestalgorithm", "digestAlgebra", "digestElgorithm", "digestElger", "digestElg", "digestALgo", "digestALgorith", "digESTAlg", "digestalgorith", "digestalger"], "digest": ["multiplest", "diguration", "labEST", "digtest", "DigEST", "diggest", "Digester", "biggest", "longest", "dger", "digested", "dester", "multiplEST", "longEST", "multipluration", "labest", "digester", "Digtest", "digEST", "bigester", " digtest", " diguration", "dest", "bigest", "labtest", "digger", "longester", "labester", "signester", " digEST", "Digested", "dgest", "signgest", "multiplester", "signest", "signger", "longested", " digested", " digester", "Digest", "Diguration", "bigger"], "md": ["mr", "meta", "df", "bd", "app", "cb", "doc", "mag", "manager", "cd", "sd", "rm", "ds", "wd", "my", "dev", "dd", "m", "mad", "ma", " MD", "mt", "arm", "plugin", "ld", "kg", "di", "ht", "mid", "mb", "mac", "cmd", "own", "dm", "um", "mn", "sm", "d", "MD", "db", "mo", "mod", "der", "amd", "mi", "ui", "mp", "ml", "ng", "metadata", "mm", "pm", "id", "module", "po", "cm", "mc", "nd", "ms", "pd", "od", "ad", "hd", "nm", "editor"]}}
{"id1": "442381", "id2": "6756635", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doversioncheck", "doBuildCheck", "doReleasecheck", " doVersionWork", "doVersionWork", " doBuildWork", "doversionTest", " doReleaseCheck", " doBuildcheck", " doBuildCheck", "doReleaseTest", " doVersioncheck", "doReleaseCheck", " doVersionTest", "doVERSIONcheck", " doReleasecheck", "doBuildWork", "doVersionTest", " doBuildTest", "doVERSIONTest", "doBuildTest", " doReleaseTest", "doBuildcheck", "doVERSIONWork", "doReleaseWork", "doVersioncheck", "doversionCheck", "doVERSIONCheck"], "view": ["full", "reader", "lock", "app", "layout", "self", "q", "edit", "widget", "session", "el", "body", "change", "div", "View", "event", "screen", "vis", "model", "page", "cache", "box", "can", "l", "e", "display", "cell", "see", "client", "this", "row", "buffer", "show", "comment", "style", "image", "block", "port", "gui", "request", "object", "v", "ui", "update", "config", "form", "server", "http", "views", "sel", "input", "window", "out", "VIEW", "accept", "html", "use", "gu"], "url": ["connection", "open", "sl", "f", "socket", "channel", "stream", "web", "base", "ssl", "log", "ll", "bb", "blog", "user", "loader", "zip", "l", "client", "address", "Url", "buffer", "URL", "source", "build", "image", "service", "lib", "hub", "path", "server", "uri", "browser", "http", "file", "resource", "input", "bel", "host", "string", "ob"], "in": ["reader", "isin", "sin", "login", "data", "socket", "s", "ins", "stream", "cin", "In", "binary", "is", "b", "inner", "rin", "win", "din", "IN", "ini", "buffer", "i", "source", "init", "inc", "nin", "bis", "n", "inn", "file", "as", "lin", "resource", "input", "out", "con", "ac", "gin"], "bin": ["reader", "border", "lock", "sin", "data", "socket", "pin", "body", "cin", "bn", "bot", "binary", "log", "kin", "bb", "bi", "inline", "part", "b", "loader", "inner", "win", "din", "IN", "ruby", "abi", "buffer", "lib", "run", "init", "spin", "browser", "inn", "oin", "file", "lin", "fin", "input", "out", "record", "con", "ln", "gin", "nb"], "line": ["job", "le", "data", "name", "lo", "el", "layer", "non", "ge", "load", "str", "definition", "letter", "log", "base", "inline", "lc", "rule", "page", "b", "text", "part", "model", "l", "e", "cell", "lines", "key", "lf", "ine", "row", "i", "source", "comment", "style", "block", "entry", "parse", "Line", "band", "object", "no", "cl", "code", "pass", "unit", "nl", "pe", "file", "split", "up", "LINE", "word", "valid", "message", "id", "lin", "link", "home", "day", "string", "ip", "end", "look", "site"], "develBuild": ["dellRelease", "deVELBuilt", "deelBuild", "deviousBuild", "deploybuild", "desvenBuilt", "DEvelBuilt", "desvenBuild", "desvenRun", "develbuild", "deelRelease", "desvelBuild", "deVELRun", "dewardbuild", "desvelRun", "desvelBuilt", "desvenBuilder", "deelRun", "develBuilder", "desvenbuild", "DEVELBuilt", "devenbuild", "devenRun", "DEVELBuilder", "DEVELBuild", "devenRelease", "deVELBuild", "deployBuilt", "desvelBuilder", "DEVELbuild", "deviousbuild", "deelBuilder", "DEvelbuild", "deVELbuild", "develRun", "deviousBuilt", "deployRun", "develRelease", "dellRun", "desvelRelease", "devenBuilder", "deployBuilder", "dewardBuild", "devenBuilt", "dellBuilder", "dellBuild", "DEvelBuild", "dewardBuilt", "deployBuild", "desvenRelease", "dewardBuilder", "develBuilt", "desvelbuild", "devenBuild", "deVELBuilder", "DEvelBuilder"], "stableBuild": ["stableVersion", "compatibleBuild", "validbuild", "latestBuild", "baseBuilder", "securebuild", "staticBuilder", " stableVersion", "prettyBuild", "baseBuild", "validBuilder", "basebuild", "prettyVersion", "baseVersion", "compatibleBuilder", "staticbuild", "latestbuild", "prettyBuilder", "prettybuild", "staticBuild", "validBuild", " stablebuild", " stableBuilder", "compatiblebuild", "stablebuild", "secureBuild", "stableBuilder", "latestBuilder", "secureBuilder"]}}
{"id1": "17296916", "id2": "5148212", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 1, "substitutes": {"logging": [" logger", "logger", "Logting", "loging", "blogging", "blogger", "logting", "bloging", "blogting", " logting", "Logger", "Logging", "Loging", " loging"], "wrap": [" wrapped", "lock", "pipe", "f", "util", "get", "self", "force", "widget", "handler", "create", "handle", "rap", "stream", "p", "web", "wp", "div", "wra", "binary", "ow", "format", "cache", "b", "wrapper", "w", "box", "work", "bag", " Wrap", "parse", "we", "image", "ws", "war", "wa", "api", "process", "build", "h", "or", "init", "run", "sw", "default", "wb", "wire", "transform", "nw", "word", "message", "flash", "frame", "cover", "ad", "use", "now"], "buffer": ["bm", "msg", "reader", "bin", "cb", "uffer", "iter", "ob", "manager", " buf", "batch", "table", "reference", "BU", "layer", "buff", "Buffer", " buffers", "log", "binary", "base", "copy", "bb", "cache", "b", "wrapper", "bridge", "loader", " receive", "board", "shell", "writer", "reply", "surface", "bar", "player", "source", "comment", "template", "feed", "image", "builder", "response", "url", "transfer", "view", "server", "pause", "code", "null", "document", "pb", "nb", "flash", "message", "frame", "uf", "header", "queue", "result", "cover", "ref", "print", "report", "fb", "bc", "buf"], "encoding": ["decoding", "ecoding", "encoded", "coded", "Encet", "Encoding", "encode", "decode", "packet", "ecoder", "encoder", "enoded", "ecryption", "unicoder", "encryption", "decoder", "coding", "cet", "packoder", "coder", "enoding", "packoding", "packoded", "unicode", "decoded", "enode", "unicoded", "ecoded", "enoder", "encet", "unicoding", "Encoded", "Encryption", "Encoder", "decryption"], "getEncoding": ["getCoding", "getEnoding", "getencoder", "getencasing", "getEncasing", "getEnoded", "getEncoded", "getCoder", "getencocol", "getEncocol", "getEncoder", "getencoding", "getCasing", " getEncocol", " getEnoder", " getEnocol", " getEnasing", " getEncoder", " getEnoding", "getEnasing", " getEncasing", " getEncoded", "getEnocol", " getEnoded", "getCoded", "getencoded", "getCocol", "getEnoder"], "headers": ["ids", "heads", "breaks", "vals", "values", "blocks", "s", "head", "options", "groups", "body", "settings", "relations", "str", "parts", "wrapper", "files", "bits", "features", "content", "rs", "workers", "caps", "lines", "writers", "strings", "padding", "ings", "h", "ints", "objects", "frames", "names", "ppers", "http", "keys", "fields", "details", "params", "ports", "ters", "links", "header", "properties", "host", "types", "plugins", "ers", "dict"], "is": ["ais", "Is", "iss", "isl", "las", "isol", "oss", "s", "bs", "ins", "ori", "has", "cms", "os", "isa", "IS", "abs", "obs", "was", "ops", "its", "i", "mis", "ws", "api", "or", "js", "nis", "\u00eds", "bas", "bis", "ists", "ui", "ois", "tis", "io", "http", "ris", "as", "in", "iso", "iris", "aos", "are", "es", "sis", "out", "us", "ios", "ms", "lis", "so", "fs", "ses", "isi"], "bos": ["bott", "osa", "bin", "opus", "fits", "ses", "cos", "las", "org", "bes", "oos", "bs", "ubs", "cms", "outs", "os", "bh", "bot", "obos", "base", "lins", "bi", "ko", "obs", "bits", "bots", "ops", "oses", "oks", "ubis", "bc", "abi", "pins", "mis", "ws", "mobi", "mos", "bas", "beans", "bis", "oes", "uds", "ois", "obo", "oops", "tis", "osi", "shadow", "aos", "bo", "ros", "flo", "los", "ios", "home", "zo", "zos", "so", "obi", "fs", "ob", "bones"], "e": ["x", "be", "er", "f", "ception", "oe", "error", "ze", "type", "p", "se", "one", "ae", "fe", "ec", "ie", "me", "je", "ale", "ite", "l", "E", "o", "exc", "err", "ke", "d", "i", "ev", "esi", "pe", "ise", "c", "ce", "a", "ea", "de", "re", "ee"]}}
{"id1": "22479286", "id2": "15166511", "code1": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"md5": ["m4", "sha4", "m512", "m2", "sha512", "md2", "sha5", "MD2", "m5", "MD4", "MD5", "MD512", "md512", "sha2", "md4"], "plainText": ["plainSecret", "messageContent", "coreTEXT", "publicTEXT", "regularText", "plainTEXT", " plainContent", "rubyText", "messageText", " plainByte", "regularSecret", " plainWidth", "publicText", "flattext", "messageSecret", "regularCode", " plainSecret", "singleText", "rubyValue", "plainByte", " plainTEXT", "regularShort", "encryptedtext", "coreContent", "rubyByte", "encryptedContent", " plainString", "flatShort", "flatTEXT", "publicContent", " plainCode", "plainCode", "plainValue", "plainContent", "coreValue", " plainValue", "flatKey", "regulartext", " plainKey", "plaintext", "encryptedText", "encryptedTEXT", "singleTEXT", "rubyContent", "extraByte", "extraContent", "regularContent", "publictext", "plainString", "extraText", " plainShort", "flatString", "plainWidth", "singleWidth", "messageCode", "flatWidth", "extraTEXT", "coreText", "flatText", "regularString", "rubyTEXT", "plainKey", "plainShort", "publicKey", " plaintext"], "md": ["meta", "df", "bd", "vd", "f", "mag", "mg", "cd", "rm", "gb", "wd", "dd", "m", " MD", "mt", "me", "dig", "mb", "am", "mac", "hm", "cmd", "dm", "sm", "d", "MD", "mo", "mod", "hash", "amd", "mp", "rpm", "metadata", "mm", "pm", "message", "sha", "mc", "ms", "pd", "mand", "ad", "hd", "Cmd", "de"], "digest": ["mdest", "digit", "dedested", "DigEST", "Digester", "compit", "digested", "dedEST", "dester", "dedex", "dimEST", "digitest", "dimex", "digitester", "digester", "dimest", "digitested", "digEST", "digitEST", "dest", "mdEST", "compest", "digger", "dimested", "dedest", " digEST", "Digested", "compEST", "Digger", "Digest", "mdit", "Digit", "Digex", "digex", " digested", "dEST", " digester", "compger", "dested", "mdger"], "hexString": ["exContent", "longText", "hexArray", "hexstring", "hexSingle", " hexArray", " hexBuffer", "exstring", "hexText", "rawBuffer", "longString", "exBuffer", " hexService", "longContent", "tempstring", "stringBuffer", "hexBuffer", "exText", "stringSingle", " hexSingle", "rawArray", "tempService", "tempBuffer", "tempString", "rawSingle", "rawString", "exService", "exString", "hexService", "stringArray", "hexContent", " hexContent", "longService", " hexstring", "stringString", " hexText"], "i": ["x", "f", "si", "it", "ti", "ri", "at", "s", "type", "slice", "m", "p", "j", "info", "pi", "k", "I", "di", "u", "b", "multi", "part", "bi", "qi", "l", "e", "o", "d", "count", "ci", "z", "t", "xi", "v", "oi", "ui", "number", "n", "li", "uri", "ii", "io", "c", "in", "id", "index", "a", "mu", "ai", "gi", "phi", "length", "start", "end"]}}
{"id1": "12389873", "id2": "13159394", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public HttpResponse fetch(HttpServletRequest request) throws IOException {\n        GUI = SwingUI.getApplicatoin();\n        DefaultHttpClient httpclient = new DefaultHttpClient();\n        CookieSpecFactory csf = new CookieSpecFactory() {\n\n            public CookieSpec newInstance(HttpParams params) {\n                return new BrowserCompatSpec() {\n\n                    @Override\n                    public void validate(Cookie cookie, CookieOrigin origin) throws MalformedCookieException {\n                    }\n                };\n            }\n        };\n        if (Helper.useProxy()) {\n            HttpHost proxy = new HttpHost(Helper.getProxyServer(), Helper.getProxyPort());\n            httpclient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);\n        }\n        httpclient.getCookieSpecs().register(\"easy\", csf);\n        httpclient.getParams().setParameter(ClientPNames.COOKIE_POLICY, \"easy\");\n        String currentRemoteGAEHost = Helper.getRemoteServer();\n        try {\n            HttpUriRequest httpRequest = createRequest(request);\n            addHeader(request, httpRequest);\n            HttpResponse response = httpclient.execute(httpRequest);\n            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_FORBIDDEN) {\n                challengeProxy(currentRemoteGAEHost);\n            }\n            logger.info(Helper.count.incrementAndGet() + \" Response received from \" + request.getRequestURL().toString() + \", status is \" + response.getStatusLine());\n            GUI.updateFetchCount();\n            return response;\n        } catch (ClientProtocolException e) {\n            logger.error(\"Fetch ClientProtocol Error\", e);\n            throw e;\n        } catch (IOException e) {\n            logger.error(\"Fetch IO Error\", e);\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"load": ["save", " Load", "Loading", "get", " loads", " loading", " reload", "sync", "ready", "download", "dump", "add", "loading", "construct", "test", "build", "init", "select", "process", "config", "transfer", "read", "clone", "Load", "link", " loaded", "write"], "conn": ["connection", "nt", "loc", "cn", "reg", "util", "nc", "session", "pt", "ca", "ct", "p", "dn", "state", "ns", "enc", "pub", "ec", "pc", "ann", "ls", "pr", "cache", "conf", "Exec", "cr", "client", "oci", "dc", "cat", "ci", "cc", "db", "connect", "ch", "ctx", "h", "exec", "col", "config", "n", "rt", "Conn", "c", "dh", "co", "coll", "sb", "con", "mc", "sql", "pg", "Connection", "cp", "act"], "stmt": ["stmi", "Stnt", " stts", "estql", " stmc", "Stmr", "stpl", "STbl", " stct", "putbt", " stnt", "str", "playor", "themt", "strk", "STmt", "flmd", "ostager", "playpl", "stmc", "putts", "elmt", "clmn", "putml", "stmr", "dnt", "stpr", "Stct", "stdb", "slmn", "strdo", "stql", "StMT", "Stpr", "Stts", "acttor", "cltr", "ostpl", "tpl", "ostmn", "putur", "elmi", "ostpr", "stnt", "Stmc", " stbl", "putmt", "slk", "Stmn", "estdo", " stmb", "estMT", " stpr", "Stmt", " stdb", "acttr", "estct", "STml", "stmd", "estmr", " stm", "Stmb", "actmt", "theb", "ostct", "playmn", "sttor", "themn", " stmr", "stth", " stml", "stts", "Stbl", "themc", " sttr", "atMT", "stml", "atb", "elml", " stager", "osttr", "playml", "plmn", "Stql", " stth", "slmt", "astk", "Stm", " strs", "Stmd", "slager", "fldo", "stct", "STager", "astmn", "ostmt", " stbt", "dMT", "estmt", "Stml", "STmd", "stager", " sttor", " stmn", "STk", "elrs", "STnt", "flmt", " stor", "STpl", "putmn", "estmd", "astql", "Stor", "STct", "playtr", "Stb", "clur", "plr", "putrs", "atmn", "plMT", "Stpl", "clmt", "atmt", "Stager", "tm", "puttr", "stbl", "dmd", "stmn", "stor", "strmt", "Sttor", "tmt", "stm", "tct", "stmb", " stk", "stb", "esttr", "Stur", "plb", "sttr", "stk", "playmt", "plmt", " stql", "Sttr", "Stbt", "stMT", "STmn", "STMT", "putmb", " stMT", "Stth", "strmd", "estk", " stb", "putmi", "slr", "Stdb", " stmi", "STdb", "estth", " stpl", "STql", "strs", "astmt", "flk", "dmt", "stdo", "slnt", "actbl", "stbt", "plnt", "stur", " str"]}}
{"id1": "22441244", "id2": "812803", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"send": ["open", "get", "create", "from", "set", "add", "text", "mail", "export", "address", "Send", "reply", "parse", "build", "submit", "exec", "delete", "transfer", "post", "message", "sent", "append", "execute", "write", "start", "end"], "hsession": ["HSessions", "openssession", "hsess", "opensessions", "hsSession", "hmession", "hhsession", "hhessions", "hession", "hsort", "hessions", "HSsession", "hmsession", "HSSession", "hsessions", "hhSession", "hessession", "hSession", "opensort", "hmSession", "hhess", "opensession", "hhort", "HSession", "opensSession", "hhession", "hssession", "hesort", "opensess", "hesession", "hmessions", "hesess"], "session": ["connection", "sl", "manager", "application", "state", "event", "class", "Session", "cache", "mail", "essions", "client", "proxy", "port", "project", "response", "parent", "context", "document", "server", "ession", "message", "chat", "resource", "host", "security", "site"], "repositoryName": ["repoositoryAddress", "repositoryFamily", "reposicleFamily", "repoositoryNAME", "repoitoryPath", "repositoryPath", "reposicleName", "repoitoryAddress", "reposessionNAME", "reposositoryNAME", "reposositoryPath", "reposicleAddress", "reposositoryName", "repoitoryEmail", "reposositoryFamily", "reposicationFamily", "reposicationName", "repoositoryName", "reposicationAddress", "reposositoryEmail", "repoitoryName", "repositoryAddress", "repoitoryFamily", "reposicleEmail", "reposessionName", "reposessionPath", "repositiveEmail", "repositoryNAME", "repositoryEmail", "repoositoryPath", "repositiveNAME", "reposositoryAddress", "reposicationEmail", "repoositoryFamily", "repositiveName", "reposessionEmail", "repoositoryEmail", "repoitoryNAME", "repositivePath"], "ideIdint": ["ideAuthints", "ideIdInt", "ideNameint", "ideidints", "IDEIdints", "ideIdints", "ideTimeInt", "ideAuthn", "ideidInt", "ideInn", "ideInint", "IDEidInt", "IDENameout", "IDEidint", "ideTimeout", "IDEIdInt", "ideIdout", "ideNameInt", "ideidn", "IDEIdout", "IDEidints", "IDENamenumber", "ideidint", "ideInfoout", "ideIdnumber", "IDENameint", "ideTimeint", "IDEIdn", "ideInfoint", "IDENameInt", "IDEIdnumber", "ideAuthint", "ideNameout", "ideInInt", "IDEIdint", "ideNamenumber", "ideAuthInt", "ideInints", "IDEidn", "ideInfonumber", "ideIdn", "ideTimenumber", "ideInfoInt"], "to": ["office", "name", "phone", "TO", "options", "from", "settings", "To", "top", "summary", "with", "mail", "by", "account", "client", "address", "reply", "sub", "source", "template", "mobile", "response", "tel", "uri", "title", "prefix", "message", "po", "token", "target", "about", "contact", "location", "company", "site"], "cc": ["cb", "cn", "phone", "nc", "card", "sc", "cca", "ca", "from", "ct", "ck", "ec", "rc", "cs", "lc", "cr", "account", "password", "client", "address", "dc", "comment", "ci", "uc", "cf", "CC", "cl", "code", "c", "ce", "tc", "contact", "company", "ac", "cus"], "bcc": ["abc", "pck", " bc", " brc", "fck", "bbrc", "pc", " bce", "bce", " bck", "pcc", "brc", "fcc", "bbck", "abcc", "bbc", "pce", "frc", "abce", "abck", "bck", "fc", "bc", "bbcc"], "subject": ["phone", "reason", "head", "method", "state", "format", "description", "mail", "content", "reply", "comment", "sub", "Subject", "template", "ject", "request", "response", "object", "filename", "uri", "author", "title", "prefix", "message", "header", "host", "username"], "body": ["connection", "lock", "data", "tree", "name", "reason", "how", "string", "plain", "base", "summary", "description", "part", "text", "inner", "wrapper", "content", "zip", "left", "line", "shell", "password", "normal", "secret", "comment", "style", "source", "template", "money", "response", "bound", "object", "foot", "url", "code", "view", "empty", "pass", "Body", "function", "message", "header", "resource", "length", "html", "media", "pod"], "attachments": ["embedings", "attachents", "messents", "embedment", "attachings", "Attachings", "embedments", "Attachents", "Attachments", "messment", "embedents", "Attachment", "messings", "messments"], "isHtml": ["isPhttp", "isChtml", "isPhhtml", " isChhtml", "isCtml", "isHive", " isHttp", " isWhail", "isWhtml", " isWhive", "isWhail", "isChhtml", " isWhhtml", "isCive", " isHail", "isCail", "isHhtml", "isChive", "isPhtml", " isWhtml", " isChail", "isHaail", "isWhive", "isChail", "isHattp", " isChtml", " isHhtml", "isHatml", "isHahtml", "isChttp", "isHail", "isWhhtml", " isHive", " isChttp", "isPhail", "isHttp"], "charset": ["charsET", "chaseset", "chasET", "chanset", "chaseting", "CharsET", "chasets", "chanspace", "chARSetting", "chearsete", "chansetter", "chearspace", "cheanset", "chansete", "chearsetter", "chARSET", "chARSeting", "Charseting", "charsetting", "chashesetter", "chARSets", "cheansET", "chackset", "charsetter", "chansetting", "chasheset", "chacksET", "chasetter", "Charsetting", "chaset", "cheansete", "chasetting", "cheansetter", "Charsets", "chacksetting", "chaseseting", "chaspace", "cheanspace", "chARSete", "Charset", "chearset", "charsets", "chearsET", "chashesET", "chansET", "cheansetting", "charsete", "charseting", "chARSet", "charspace", "chashespace", "chacksete", "chasesetting", "chearsetting", "chasesET"], "headers": ["mails", "options", "groups", "settings", " cookies", "status", "files", "content", "authors", "lines", "writers", " messages", "strings", " emails", " recipients", "classes", "comments", "names", "errors", "metadata", "params", "users", "header", "properties", "types", "ers"], "priority": ["phone", "reason", "language", "theme", "state", "mode", "status", "class", " title", "lang", "reply", "secret", "comment", "template", " severity", " recipients", "quote", "comments", "level", "code", "date", "author", "title", "prefix", "queue", "security", "length"], "email": ["office", "gmail", "ext", "data", "name", "oe", "ilo", "note", "create", "el", "auto", "em", "info", "install", "event", "en", "xml", "Email", "letter", "base", "ssl", "model", "text", "mail", "output", "online", "article", "entity", "zip", "line", "engine", "export", "account", "password", "e", "address", "external", "service", "fax", "test", "lex", "business", "template", "generic", "example", "response", "object", "url", "update", "enter", "document", "view", "server", "default", "core", "pm", "message", "contact", "result", "international", "print", "html", "liner", "element", "username"], "user": ["connection", "er", "profile", "data", "name", "type", "creator", "info", "ip", "me", "plugin", "model", "people", "account", "e", "member", "client", "User", "mobile", "object", "role", "character", "friend", "USER", "consumer", "author", "person", "id", "users", "uid", "resource", "token", "unknown", "string", "use", "username"], "identity": ["ethnicifier", "identication", "authorentity", "authority", "idITY", "ethnicity", "electricITY", "authoronymous", "authentonymous", "idifier", "authorities", "entityity", "IDENTity", "personITY", "idity", "personentity", "IdentITY", "authorication", "ethniciciary", "identiciary", "electriconymous", "ethnicITY", "installITY", "Identity", "IDENTities", "IDENTITY", "personity", "entityifier", "installonymous", "electricity", "authentITY", "publicity", "authentization", "authoriciary", "idization", "ethnicentity", "electricentity", "identonymous", "installentity", "authentication", "authentity", "idication", "publicITY", "entityonymous", "publicentity", "identization", "Identities", "Idententity", "IDENTentity", "entityization", "ethnicication", "identITY", "publiciciary", "authorifier", "idonymous", "authentifier", "idententity", "authorITY", "identifier", "identities", "installity", "personifier"], "_returnPath": ["_correctId", "_returnMid", "_resultPath", "_responseType", " _returnTo", " _backHalf", "_resultTo", "_returnHalf", " _returnUrl", "_resultHalf", "_displayPath", "_displayPart", "_backHalf", "_responsepath", "_backpath", "_displayUrl", "_inputMid", "_returnNode", "_returnPart", "_backName", "_returnText", "_inputPath", "_backType", "_returnDirectory", "_displayNode", "_successText", " _backTo", "_addType", "_backPath", "_backPart", " _backUrl", "_relationPath", "_backUrl", "_successId", "_resultName", "_returnTo", "_addPath", "_correctText", "_successPath", "_replyUrl", " _backPath", "_relationId", " _backPart", "_returnType", " _backName", "_replyMid", "_returnId", "_replyNode", "_correctPath", "_returnUrl", "_inputUrl", "_backTo", "_returnpath", "_relationDirectory", "_successDirectory", "_replyPart", "_addpath", "_correctDirectory", " _returnHalf", "_replyPath", "_displayMid", "_relationText", " _returnName", "_responsePath", "_returnName", "_inputNode", " _returnPart"], "_from": ["_for", "placeowner", "workwho", "worksource", "blockFrom", "_From", "_with", "blockerror", " _error", " _source", "workfrom", "blockto", " _owner", "existingto", "_source", "_who", "existingfrom", "_error", "blockfrom", "_owner", " _for", " _with", "existingowner", "placefrom", "workto", " _who", "placefor", " _From", "placeto", "existingfor"], "_replyTo": ["_replyFrom", "_returnUrl", "_respondTo", "_returnTo", "_respondTO", "_returnOf", " _returnTo", "_addFrom", "_reasonUrl", " _replyTO", "_closeTO", "_replyUrl", " _returnTO", "_reasonTo", "_replyTO", "_addAddress", "_commentOf", " _replyFrom", "_reasonTO", "_respondAddress", "_commentFrom", "_respondFrom", "_commentTO", "_replyAddress", "_commentTo", "_respondPoint", " _returnFrom", "_replyPoint", "_replyOf", " _replyUrl", "_returnAddress", " _returnUrl", "_returnPoint", "_addTo", "_respondUrl", "_returnFrom", "_addPoint", "_returnTO", "_closeTo", "_reasonFrom", "_closeOf", "_closeFrom"], "_to": [" _target", "_target", " _about", "Jfrom", "Jabout", "Jtarget", "_about", "Jto"], "_cc": [" _cd", " _ce", " _cf", "_cd", "_ce", "_cf"], "_bcc": [" _abc", " _bce", "_rbcs", " _bcs", "_abce", "_rbc", "_sbcs", "_sbc", " _bc", " _abcs", "_abcs", "_sbcc", "_abc", "_rbce", "_bce", "_bcs", "_rbcc", " _abce", "_sbce", "_bc", "_abcc", " _abcc"]}}
{"id1": "5061606", "id2": "18748516", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNecccessary", "createSettingsIfNecesary", "createSettingsIfNequccessnecessary", "createSettingsIfNecesarily", "createSettingsIfNececarily", "createSettingsIfNequccessarily", "createSettingsIfNequccessary", "createSettingsIfNecesseless", "createSettingsIfNecessnecessary", "createSettingsIfNecessarily", "createSettingsIfNececary", "createSettingsIfNecesnecessary", "createSettingsIfNecccesseless", "createSettingsIfNequccesseless", "createSettingsIfNececeless", "createSettingsIfNececnecessary", "createSettingsIfNecccessnecessary", "createSettingsIfNequessary", "createSettingsIfNeceseless", "createSettingsIfNecccessarily", "createSettingsIfNequesseless", "createSettingsIfNequessnecessary", "createSettingsIfNequessarily"], "out": ["connection", "bin", "lock", "app", "data", "name", "socket", "at", "pool", "error", "channel", "array", "sync", "ex", "outs", "timeout", "plain", "log", "plugin", "copy", "model", "page", "conn", "cache", "again", "output", "user", "by", "writer", "err", "password", "o", "flush", "client", "OUT", "off", "this", "i", "source", "image", "init", "cookie", "path", "exec", "object", "parent", "exit", "url", "config", "group", "server", "null", "io", "net", "file", "up", "index", "a", "prefix", "result", "window", "Out", "write", "obj", "editor"], "fSettings": ["FConfig", "fConfig", "fileSettings", "fJs", "Fsettings", "sfsettings", "fileSetting", " fSetting", "fsConfig", "fettings", " fFs", "filesettings", "FSettings", "fSetting", "fmSettings", " fJs", "sfJs", "FJs", "sfettings", "fsSettings", "fsSetting", "sfSetting", "fmSetting", "FSetting", "rfSettings", "sfSettings", "fmSetup", " fConfig", " fettings", "rfSetting", "rfFs", "fFs", "fmConfig", "fsSetup", "fileettings", "rfConfig", "FSetup", " fsettings", "fsettings", "fsFs", "fSetup"], "src": ["cur", "sl", "cb", "loc", "gb", "sc", "ins", "ctr", "stream", "st", "settings", "str", "rc", "base", "prot", "ource", "ssl", "req", "b", "text", "img", "lower", "dist", "dest", "rb", "source", "storage", "sub", "uc", "path", "filename", "attr", "url", "config", "uri", "route", "file", "sr", "sel", "sb", "fp", "ref", "string", "tmp"], "in": ["reader", "bin", "connection", "sin", "f", "data", "login", "s", "ins", "stream", "In", "kin", "copy", "b", "inner", "again", "rin", "win", "din", "l", "r", "IN", "err", "ini", "i", "source", "image", "init", "inc", "path", "url", "n", "thin", "inn", "c", "file", "id", "index", "input", "con", "gin"]}}
{"id1": "15799935", "id2": "10795866", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedPart", "saveAttachedBody", "saveAppensionFile", "saveAttPartPart", "saveAttachmentPart", "saveAttachedFile", "saveAttensionBody", "saveAttPartFile", "saveAppachmentbody", "saveAppensionbody", "saveAttensionbody", "saveAppensionPart", "saveAttachedbody", "saveAttachmentFile", "saveAppachmentFile", "saveAttachmentbody", "saveAttPartBody", "saveAppachmentPart", "saveAttensionFile", "saveAppensionBody", "saveAppachmentBody", "saveAttensionPart", "saveAttPartbody"], "context": ["connection", "reader", "current", "Context", "version", "manager", "present", "channel", "container", "support", "cca", "ca", "state", "cms", "event", "definition", "center", "component", "cache", "text", "front", "concept", "content", "collection", "translation", "client", "subject", "service", "kernel", "ctx", "template", "cf", "request", "parent", "driver", "project", "environment", "system", "config", "document", "view", "c", "ce", "message", "community", "resource", "input", "queue", "mc", "coll", "contact", "host", "network", "processor", "media"], "part": ["connection", "app", "name", "point", "channel", "place", "type", "from", "body", "to", "p", "partial", "state", "phase", "event", "art", "per", "base", "component", "position", "parts", "Part", "section", " parts", "pre", "translation", "patch", "mission", "PART", " Part", "comment", "service", "source", "block", "pod", "image", "or", "media", "parent", "object", "file", "message", "upload", "po", "chapter", "plan", "area", "html", "Parts", "start"], "localAttachment": ["LocalAssachment", " localAttachachment", "localPartribution", "localAttachension", "localAttension", "localAvacher", " localAttrollment", "LocalAttment", "localAvacement", "localInstribution", "localAttacement", "localArtment", " localAttribution", " localAttention", "localAddment", "localAttment", " localAttacement", " localExtachment", " localPartension", "LocalAttention", "localattention", "localattrollment", "localAssention", " localPartribution", "LocalAssail", "localAvachment", "localPartension", "localAvention", "localArtail", "localAssment", " localPartention", "localAttachrollment", "LocalAttachment", "localAssail", " localExtacement", "localAddrollment", "localAttachention", "LocalAttail", "localPartention", "localExtacher", " localAttension", "localAttachacement", "localAttacher", "localPartachment", "localAttribution", "localAddail", " localExtacher", "LocalAssment", "localattachment", "localArtention", " localExtention", "localAttention", " localAttachrollment", "localAttrollment", " localAttacher", "localArtachment", "localAttail", "localAssachment", " localPartachment", " localAttment", "localExtacement", "localExtachment", "localAttachachment", "localAttachribution", "LocalAssention", "localInstachment", "localInstention", " localAttachention", "localExtention", "localInstension", "localAddachment", "localattment", "localAddention", "localAttachacher"], "accountId": ["contractId", "contractName", "jobid", "accountInfo", "contactid", "jobId", "appInfo", " accountID", "AccountName", "appId", "accountid", "feedID", "Accountid", "appID", "accInfo", " accountid", "feedid", "accId", "accountID", "appid", "feedName", "feedId", "AccountId", "jobName", "jobID", "accID", "AccountID", "accid", " accountInfo", "accountName", "contractid", "contactName", "contactId", " accountName"], "attachmentId": ["addachmentID", "attociationID", "attlementName", "attmentId", "atachmentReference", "attociationType", "addachmentType", "extachmentid", "adachmentID", "attentionId", "addentionID", "attmissionID", "attmissionId", "extachmentId", "atachmentName", "atociationReference", "attensionSource", "attentionSource", "adachmentInfo", "atociationName", "attlementId", "attmentName", "attmentReference", "attociationId", "attachmentID", "attachedType", "attentionIndex", "attentionUrl", "attociationReference", "atociationID", "extachmentSource", "attociationUrl", "attlementReference", "attociationName", "attachmentReference", "attlementID", "attensionid", "attachmentSource", "attentionType", "attachedID", "attentionid", "extensionSource", "atociationId", "attachedUrl", "attptionID", "adachmentIndex", "attensionID", "addentionId", "extensionid", "attptionId", "adentionIndex", "attmissionSource", "attmissionid", "attachmentType", "attachmentIndex", "attachmentInfo", "addachmentId", "adentionInfo", "attagramIndex", "attachmentUrl", "attagramInfo", "atachmentID", "adachmentId", "atachmentId", "addachmentUrl", "attachmentName", "attptionIndex", "attmentID", "extachmentID", "attentionID", "attachmentid", "attptionInfo", "attachedId", "extensionId", "attentionInfo", "adentionId", "extensionID", "addentionUrl", "attensionId", "attagramID", "attagramId", "adentionID", "addentionType"], "in": ["reader", "bin", "login", "f", "data", "it", "socket", "slice", "ins", "pin", "p", "cin", "info", "load", "In", "is", "inside", "copy", "conn", "inner", "again", "din", "IN", "err", "plus", "pull", "ini", "i", "source", "init", "image", "inc", "nin", "or", "url", "pass", "inn", "file", "as", "id", "up", "a", "input", "con", "ac", "gin"], "saveIn": [" savein", "savIn", "aveIn", "avein", "saveOut", "saveIN", "aveAs", " saveIns", "stageIn", "savAs", "writeIN", " saveOut", "SaveIns", "writeIn", "aveOut", "savOut", "stageOut", "savein", "stageIns", "SaveIn", "saveIns", "stageAs", " saveIN", "savin", "writeOut", "SaveAs", "aveIN", "SaveOut", "writein"], "saveAs": ["openAs", "copyAs", "saveAt", "openAS", "saveOut", "createAt", "copyas", " saveOut", "copyIn", "writeIn", " saveas", " saveAS", "writeAs", "SaveAS", "createAS", "saveAS", "SaveIn", "createAs", "saveFile", " saveFile", "copyAS", " saveAt", "writeOut", "openAt", "openFile", "SaveAs", "saveas", "writeAS", "SaveOut", "createFile", "Saveas"], "out": ["bin", "ext", "data", "name", "at", "s", "sync", "to", "ex", "outs", "copy", "page", "conn", "again", "output", "cache", "inner", "line", "writer", "err", "flow", "o", "client", "off", "OUT", "temp", "this", "plus", "source", "init", "image", "inc", "path", "exec", "outer", "v", "other", "default", "null", "io", "c", "file", "as", "up", "a", "Out", "string"], "copySize": ["CopyTime", " copyTime", "saveLength", "leSize", "byteTime", " copySIZE", "saveSize", "savesize", "lesize", "copyAddress", "CopySize", "openSIZE", "copyTime", "leLength", "copySIZE", "leSIZE", "Copysize", " copysize", "bytesize", "copysize", "byteAddress", " copyLength", "openLength", "copyLength", "saveAddress", "CopyLength", "byteLength", "opensize", " copyAddress", "openSize", "byteSize"], "contentUriString": ["contentUioStr", "contentIiByte", "contentUiniByte", "contentUridStr", "contentUrisString", "contentUioInt", "contentUpiInt", "contentUriUnit", "contentUpiStr", "contentUriByte", "contentUiNumber", "contentUriStr", "contentIrisInt", "contentUrisstring", "contentUiByte", "contentIrisStr", "contentUiostring", "contentUpiString", "contentIriStr", "contentIrisUnit", "contentUuriByte", "contentIriInt", "contentIiStr", "contentUridString", "contentUuriString", "contentUrisUnit", "contentUiString", "contentIrisString", "contentIriByte", "contentUuriNumber", "contentIiNumber", "contentIiString", "contentIristring", "contentUioString", "contentUiStr", "contentIrisstring", "contentUiniNumber", "contentUridUnit", "contentUiniStr", "contentUriInt", "contentUriNumber", "contentUuriStr", "contentUrisStr", "contentUiUnit", "contentUpistring", "contentUrisInt", "contentIriNumber", "contentUiniString", "contentIriString", "contentUristring", "contentIriUnit"], "mSize": ["pLength", "iLength", "cCount", "cSize", "mCount", "mLength", "pSize", "cLength", "mName", "pName", "iCount", "iSize", "iName", "cName", "pCount"], "mContentUri": ["mContentIci", "mResourceUric", "mContentUrci", "mResourceIris", "mContentUci", "mResourceUri", "mContentUric", "mContentOUri", "mContentUrris", "mContentIric", "mResourceUci", "mContentUris", "mContentIris", "mContentOUris", "mResourceUris", "mResourceIri", "mResourceIci", "mResourceIric", "mContentOUci", "mContentUrri", "mContentIri", "mContentOUric", "mContentUrric"], "cv": ["nv", "GV", "cb", "keep", "loc", "cd", "nc", "CV", "av", "vp", "sc", "iv", "ca", "cap", "vr", "enc", "vv", "rc", "cs", "lc", "iq", "auc", "csv", "content", "sv", "cr", "vm", "um", "bc", "cc", "ctx", "vc", "uc", "cf", "xc", "v", "vs", "conv", "core", "cu", "uv", "c", "lv", "VC", "co", "ov", "coll", "cm", "cover", "mc", "fp", "que", "ctrl", "cp", "fc", "pb", "buf"], "uri": ["URI", " url", "data", "point", "ri", "gb", "iri", "iv", "range", "pi", "universal", "base", "oid", "format", " ur", "href", "qi", "query", "address", "proxy", "i", "cli", "ci", "storage", "api", "path", "environment", "url", " scheme", "ui", "mi", "attribute", " Uri", "route", "metadata", "http", "id", "prefix", "resource", "uid", "location", "uni", "string", " URI", "username"]}}
{"id1": "4398382", "id2": "3745402", "code1": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 1, "substitutes": {"digest": ["mdest", "digress", "encse", "generest", " digests", "generests", "Digester", "generester", "digested", " digress", "digester", "Digse", "mdested", "mdests", "mdester", "digse", "encest", " digse", "digests", "generested", "encress", "Digress", " digested", " digester", "Digest", "encester"], "algorithm": ["algebra", "Alignment", "malgorithm", "alenge", "Algorithm", "Algo", "maloding", " algebra", "malignment", " alenge", "challgorithm", "challenge", "algo", "malgebra", " algo", "argorithm", "challgo", "aloding", "Alenge", "alignment", "challgebra", "arignment", "Algebra", "aroding", "Aloding", "argebra"], "text": ["connection", "ext", "sequence", "data", "name", "str", "letter", "format", "output", "txt", "content", "bytes", "password", "address", "secret", "test", "buffer", "source", "image", "value", "feed", "Text", "path", "struct", "object", "pattern", "url", "attribute", "config", "code", "word", "message", "token", "TEXT", "input", "length", "string", "username"], "mDigest": ["amDigested", "MDigester", "mCodested", "mSignge", "MDest", "amDigest", "mGest", "mCodest", "MDigenge", "amPostest", "mDigester", "mCodener", "mDgest", "mDigested", "mdigest", "mDigEST", "mDigener", "mDesigner", "mPostener", "mDesigngest", "mSignester", "MDiggest", "mGast", "mSignest", "mDer", " mDigast", " mGest", "MDigest", "mEncester", "mDigenge", "mSignast", "mGge", "mdigested", " mDigge", "mdigester", "mdiger", "mSignenge", "amDigener", "mdiggest", "mPostested", "mDEST", "MDiger", "mDest", "mSignEST", "mDigge", "mDesignester", " mGge", "MDgest", "MDer", "mGester", " mGast", "mDigast", "mDenge", "mdigener", "mDiger", " mDigester", "mDiggest", "amPostener", "mEncest", "mEncge", "mEncast", "mDester", "amPostested", "mDesignest", " mGester", "mPostest", "MDigEST", "MDester"], "raw": ["full", "data", "container", "array", "partial", "clean", "RAW", "enc", "hex", "binary", "orig", "wrap", "Raw", "instance", "output", "content", "row", "buffer", "source", "image", "feed", "response", "serial", "default", "null", "original", "unsigned", "message", "input", "result", "initial", "none", "internal", "json", "buf"], "encoder": ["ecoding", "decoding", "encoded", " encoding", "Encoding", "encode", "deccode", "decode", "ecoder", "encoding", " encoded", "decoder", "eccode", "enoding", "Encode", "enode", "ecoded", "enoder", " encode", "Encoded", "Encoder", "enccode", "ecode"]}}
{"id1": "7143591", "id2": "20886320", "code1": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"getWebByUrl": ["getwebByLocation", "getWebByLocation", "getwebbyurl", "getWebFromurl", "getwebbyUrl", "getwebByUrl", "getWebByURL", "getwebByURL", "getWebFromLocation", "getWebByIdURL", "getwebByurl", "getwebbyURL", "getWebByIdLocation", "getWebByIdurl", "getWebByIdUrl", "getWebFromURL", "getWebbyLocation", "getwebbyLocation", "getWebbyUrl", "getWebFromUrl", "getWebByurl", "getWebbyurl", "getWebbyURL"], "strUrl": [" strURL", "arrUrl", "strFile", "strPath", "StrFile", "srurl", " strFile", "srURL", "arrUr", "stFile", "srUrl", "strUr", "Strurl", "StrURL", "StrPath", "arrRoute", "wrURL", "StrRoute", "arrurl", " strRoute", "slUrl", "strLink", "objUr", "srLink", " strUr", " strurl", "STRUr", "StrUrl", "objFile", "STRURL", "strEmail", "wrUr", "StrBase", "slURL", "STRUrl", "stUrl", "arrPath", "sturl", "STRFile", "objURL", "objUrl", "stUr", "stURL", "arrURL", "wrUrl", "wrEmail", " strLink", "StrEmail", "strURL", "stEmail", "slUr", " strPath", "slBase", "StrUr", "strRoute", "strBase", "StrLink", "strurl", " strBase"], "charset": ["charsET", " Charsetting", "chasET", "chARSetting", "charsec", "chARSET", "chARSec", "charsetting", " ChARSet", "chactersetting", "chactersec", "chasec", "chaset", "chactersET", " CharsET", "chasetting", " ChARSET", " Charset", "chacterset", " ChARSec", "chARSet", " ChARSetting", " Charsec"], "fileIndex": [" fileNumber", "FilePath", "fullPath", "webName", "fileName", "fileVersion", "Fileindex", "FileIndex", "fileNumber", "fileindex", " fileindex", "webindex", "fullIndex", "FileVersion", "fullNumber", "fullindex", " fileVersion", "webVersion", "webIndex", "FileName", "FileNumber", " fileName"], "url": ["connection", "open", "sl", "f", "org", "fl", "ur", "web", "download", "str", "base", "ssl", "ll", "ls", "bb", "blog", "b", "loader", "page", "zip", "l", "r", "client", "address", "Url", "proxy", "URL", "source", "service", "image", "api", "path", "config", "server", "uri", "http", "file", "id", "www", "bel", "resource", "host", "link", "string", "serv", "ib"], "conn": ["connection", "nt", "open", "cb", "f", "loc", "cn", "nc", "sn", "ca", "sync", "enc", "ann", "ssl", "b", "w", "conf", "r", "l", "client", "Url", "cli", "ci", "ctx", "connect", "ch", "api", "exec", "config", "n", "conv", "server", "http", "c", "Conn", "con", "cp", "Connection", "ac", "serv"], "is": ["x", "iter", "ais", "Is", "iss", "si", "it", "ri", "s", "oss", "ins", "info", "jar", "os", "im", "ie", "isa", "IS", "ls", "ssl", "isc", "b", "was", "internet", "ar", "err", "its", "i", "mis", "init", "h", "bis", "ui", "li", "ir", "browser", "ps", "http", "ris", "in", "as", "iso", "io", "ii", "iris", "src", "ab", "are", "es", "ai", "out", "us", "ios", "lis", "serv", "ip", "fs", "ib", "ob", "il", "isi"], "filePath": ["FilePath", " fileBase", "outputHome", "baseLocation", "cachepath", "basePath", " fileUrl", "fileLocation", "baseIndex", "pagepath", "cacheLocation", "cacheIndex", "FileHome", "fileHome", "outputPath", "FileUrl", "fileUrl", "pageLocation", "pagePath", "pageIndex", "cachePath", "outputUrl", "filepath", "fileBase", "FileBase", " fileHome", "outputBase", "basepath"], "pw": ["ppws", "ppw", "Pws", " pwr", "PW", "pwb", "Psw", "spv", "ppwa", "pv", "Pwb", " pwb", "pwa", "pW", "pwr", "Pb", " pwa", "cpw", "spwb", "Pow", "Pwr", " pb", " pv", "spws", "Pw", "spow", "ppW", " pW", "pow", " pow", "Pwa", "psw", "cpwr", "ppb", "cpW", "spw", " pws", "cpwa", "spW", "ppsw", "ppow", "pb", " psw", "pws", "Pv"], "fos": ["fis", "fsos", " fis", "FOS", "Fops", "fOS", " fOS", "Faos", "fsops", "Fis", "fops", " faos", "pOS", "fsis", "Fos", "pos", "pops", "fsaos", "faos", " fops"], "writer": ["reader", "er", "director", "angler", "wt", "handler", "writ", "worker", "xml", "format", "wrap", "w", "walker", "output", "writing", "r", "writers", "buffer", "wa", "ws", "war", "builder", "driver", "rw", "store", "null", "io", "file", "wr", "wire", "wer", "wb", "wave", "fd", "out", "riter", "Writer", "write", "ee", "editor"], "bReader": ["rbRead", "bWriter", "bRead", "rReader", "bbWriter", "rbReader", "rbWriter", "BRead", "bResource", "rCh", "bbRead", "bCh", "rRead", " bCh", " bRead", "bbResource", "BReader", " bResource", " bWriter", "rWriter", "BResource", "BWriter", "rbCh", "bbReader"], "sb": ["SB", "bm", "cb", "sg", "si", "lp", "gb", "sth", "wp", "lab", "xb", "ssl", "kb", "bb", "rob", "b", "mb", "erb", "bp", "rb", "sq", "sm", "abb", "db", "lb", "stab", "zb", "bg", "bps", "sa", "pb", "ab", "wb", "src", "bsp", "bf", "sf", "usb", "obb", "fb", "nb", "ib", "tmp"], "rLine": ["lrLin", "prLine", "lrLine", " rLo", "arLine", "rUrl", "srUrl", "lrBlock", "lrRange", "rtWr", "rWr", "rRange", "arWr", "prBlock", " rline", "rrUrl", " rLin", "arline", "rBlock", "rline", "rrLine", "prLin", "rtline", " rBlock", " rWr", "rrBlock", "rLo", "arLo", "prRange", "srBlock", "rtLo", "rrLin", " rRange", "srLine", "srLin", "rtLine", " rUrl", "rLin"], "tmp_rLine": ["tmp_roFile", "tmp_rLink", "tmp_RItem", "tmp_RBlock", "tmp_RRecord", "tmp_rSe", "tmp_brLine", "tmp_rnLine", "tmp_vrCopy", "tmp_vrLink", "tmp_Rline", "tmp_RLine", "tmp_errLink", "tmp_prLine", "tmp_rline", "tmp_vrline", "tmp_rbLine", "tmp_rtline", "tmp_rFile", "tmp_RFile", "tmp_rtLine", "tmp_RValue", "tmp_roLine", "tmp_RLetter", "tmp_roPage", "tmp_errLine", "tmp_rItem", "tmp_lLine", "tmp_prSe", "tmp_rCopy", "tmp_RSe", "tmp_rbline", "tmp_lFile", "tmp_rValue", "tmp_rnLink", "tmp_rBlock", "tmp_rtBlock", "tmp_rLetter", "tmp_prValue", "tmp_roRecord", "tmp_nrFile", "tmp_roSe", "tmp_nrline", "tmp_rtItem", "tmp_errline", "tmp_vrLine", "tmp_rbBlock", "tmp_brFile", "tmp_nrLine", "tmp_rRecord", "tmp_errCopy", "tmp_brLetter", "tmp_prFile", "tmp_lBlock", "tmp_rPage", "tmp_rnline", "tmp_rbItem", "tmp_rnCopy", "tmp_nrBlock", "tmp_lRecord", "tmp_roBlock", "tmp_RPage", "tmp_lPage", "tmp_roValue", "tmp_lLetter"], "str_len": ["str2len", "str_pos", "str_length", "dr_len", "str64len", "stri_len", "dr_Len", "str2lin", "str64lin", "str5pos", "str5lin", "str_Len", "dr_length", "str5len", "str64ler", "dr_ln", "str_lin", "str2ler", "str64pos", "stri_pos", "str5ler", "stri5len", "str2pos", "stri_lin", "str_ln", "stri_ler", "stri5lin", "stri5ler", "str_ler", "stri5pos"]}}
{"id1": "14390569", "id2": "13886238", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"title": ["msg", "layout", "data", "name", "version", "type", "heading", "body", "theme", "Title", "label", "TIT", "summary", "format", "description", "html", "itle", "part", "text", "size", "term", "content", "section", "page", "ppa", "subject", "image", "phrase", "itles", "filename", "notes", "url", "details", "id", "prefix", "message", "header", "resource", "chapter", " Title", "alpha", "string", "desc", "license"], "imageURL": ["imageURI", "pictureurl", "imgURI", "imagePath", " imageURI", "fileURL", "imgPath", " imageurl", "pictureURL", "ImagePath", "mediaURL", "imageurl", "ImageURI", "mediaURI", "fileUrl", "filePath", "imgUrl", "pictureUrl", "ImageUrl", "fileURI", "pictureURI", "imgURL", " imageUrl", "imageUrl", "fileurl", "ImageURL", "mediaUrl"], "jd": [" jf", "jackf", "argd", "zdd", "jobb", "ajdi", "Jl", "ajD", "jobd", "jD", "Jb", "je", "jsd", "ssdo", "ajdos", "zd", "qd", "jsb", "jjdh", "ajdh", "zdo", "zds", "jackdd", "ssD", " jdd", "ajdl", "jobdo", "adjdos", "jackd", "ze", "qdom", " jdi", "jf", "zl", " jdom", "Jdom", " je", "ssdi", "argf", "jdom", "ajb", "Jds", "ajf", "JD", "Jf", " jdo", "jdl", "jsdo", "jds", "jjb", " jdh", "jdo", " jdl", "jobD", "Jd", " jD", "jsdh", "jdd", "zb", "adjb", "qdo", "Jdo", "jackb", "qdh", "ajdo", "jdh", "Jdos", "argdo", "adjd", "jdi", "jdos", "ssd", "qb", "zf", "Je", " jds", "jjd", "adjdo", "argdl", "ajd", "jjdo"], "jl": ["ji", "elt", "vd", "chal", "jj", "bj", "lp", "dl", "el", "kj", "j", "kn", "syn", "bn", "eb", "label", "bl", "ll", "ld", "zl", "kl", "iji", "jon", "wl", "l", "ja", "lf", "lu", "jc", "Label", "cli", "NJ", "JM", "lb", "li", "nl", "elly", "uj", "iol", "lv", "hl", "dj", "adj", "fp", "kel", "oji", "igl", "il"], "icon": ["pic", "cn", "cha", " image", "note", "gn", "info", "bn", "label", "ann", "icons", "plugin", "picture", "css", "text", "size", "Icon", "content", "img", "alias", "ico", "image", "iao", "png", "artist", "ion", "url", "ui", "n", "uri", "eye", "core", "io", "ic", " Icon", "action", "on", "token", "header", "resource", "uni", "fc"], "chooser": ["Chooses", "choer", " choosen", "closer", "dialose", "Choose", "Chooder", "Choer", "chooses", "booser", " choose", "chooder", "jooser", "dialosen", "jooder", "closen", "choose", "Choosen", "clressor", " chooder", "choressor", "cler", " choressor", "choosen", "dialer", "boose", "close", "jooses", "Chooser", "dialoser", "boressor", "boosen", " chooses", "joose"], "jp": ["ji", "bj", " plugin", " robot", " JM", "j", " bar", " mp", " pane", "Panel", " cm", " j", " bridge", " app", " dj", "ja", "JP", " np", " je", " sp", " pa", " pic", " gp", " tmp", " js", " ax", " cp", " obj", " dock"], "jb": [" jf", "ajcb", "qcb", "qsb", "djcb", "jf", "djb", "jsd", "ajsb", "qb", "ajb", "jsb", " jbb", "ajf", "jcb", "jbb", "qf", "djd", " jcb", "jsbb", " jsb", "jscb", "djbb"], "e": ["x", "f", "ception", " Event", "event", "ae", "ec", "ie", " E", "je", "E", "exc", "ctx", "t", "ev", "v", "te", "et", "pe", "c", "in", "ce", "a", " ate", " fe", "de", "ee"], "returnVal": ["ReturnNum", "returnval", " returnVAL", "replyval", "replyVAL", "returnNum", "resultVal", "replyVal", " returnval", "resultNum", "returnValue", "ReturnValue", " returnValue", " returnNum", "Returnval", "resultval", "replyValue", "ReturnVAL", "resultValue", "returnVAL", "ReturnVal"], "file": ["lock", "data", "name", "pool", "book", "type", "letter", "binary", "die", "picture", "b", "work", "single", "buffer", "ile", "path", "ban", "url", "io", "function", "module", "message", "queue", "out", "directory", "File", "handler", "play", "auto", "load", "local", "log", "rule", "page", "zip", "parse", "build", "parent", "document", "folder", "home", "use", "il", "f", "info", "model", "part", "line", "show", "lib", "image", "live", "http", "po", "FILE", "dir", "fp", "full", "get", "force", "body", "base", "future", "user", "files", "l", "comment", "db", "filename", "object", "unit", "core", "pe"], "fileName": ["FilePath", "imageName", " fileType", "fileType", "binaryPath", "imagename", "singleInfo", "FileType", "imagePath", "FileInfo", " fileInfo", "resourcePath", "singleType", " fileUrl", "Filename", "binaryUrl", "imageInfo", " filePath", "singlePath", "binaryName", "fileUrl", "filePath", "fileInfo", "filename", "singleName", "resourceName", "imageUrl", "resourceInfo", "FileName", " filename", "resourcename", "singlename"], "ext": ["abc", "extra", "f", "name", "version", "type", "ct", "p", "ex", "enc", "fb", "class", "feat", "orig", "format", "ension", "Ext", "alg", "txt", "EXT", "xp", "ax", " Ext", "xt", "lib", "t", "ch", "path", "phrase", "sec", "v", "eng", "oct", "pe", "word", " extension", "exp", "qt", "ace", "desc", "obj"], "i": ["y", "si", "ti", "ri", "mini", "m", "j", "info", "p", "pi", "is", "I", "di", "u", "bi", "b", "multi", "o", "ini", "cli", "ci", "z", "api", "xi", "ion", "ment", "v", "ui", "mi", "bis", "li", "uri", "io", "ii", "c", "ni", "id", "iu", "a", "gi", "ai", "phi", "ip"], "doIt": ["hoIt", "hoit", "doYou", "addNot", "diIt", "hoIT", "addit", "poIt", "diit", "diIT", " doit", "odoWhich", "poit", "poYou", "doIts", "doNot", "doWhich", "skipIts", "doit", "hoYou", " doWhich", "poIT", "skipIT", "skipIt", "odoIt", "DOit", " doIts", "odoit", " doNot", " doYou", "DOWhich", "odoNot", " doIT", "doIT", "addIT", "DOIt", "skipit", "odoIT", "diIts", "addIt", "DOIT"], "src": ["cdn", "sl", "cb", "cur", "loc", "RC", "ources", "sup", "cos", "ff", "socket", "sn", "gb", "sc", "slice", "stream", "secure", "st", "sync", "inst", "sth", "gz", "rc", "ssl", "ource", "bb", "b", "img", "r", "rs", "fi", "dist", "pull", "rb", "sq", "cmp", "source", "storage", "sub", "ctx", "uc", "path", "attr", "url", "conv", "tmp", "split", "impl", "Dest", "upload", "sel", "sb", "target", "input", "us", "rel", "fc", "desc", "bc", "buf", "rx", "rest"], "dest": ["prop", "cdn", "loc", "sup", "later", "wd", "ctr", "dev", "st", "cont", "inst", "destroy", "dep", "comb", "gen", "proc", "di", "die", "output", "img", "done", "trans", "dist", "std", "dc", "gd", "source", "uc", " Dest", "exit", "config", "route", "uv", "wb", "Dest", "target", "dat", "dir", "usr", "home", "desc", "tmp", "rest"]}}
{"id1": "18731843", "id2": "11933797", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"doBody": ["DoBytes", " doFile", "DoFile", "DoBody", "handleBody", "handleBytes", "doResponse", "handleResponse", " doBytes", "doBytes", "handleFile", " doResponse", "doFile", "DoResponse"], "req": ["rh", "reader", "data", "reg", "q", "respond", "qq", "comp", "info", "download", "proc", "sem", "rec", "conn", "jp", "r", "query", "err", "fr", "rr", "this", "requ", "request", "spec", "Request", "config", "http", "cgi", "src", "rss", "crit", "resource", "res", "def", "report", "ref", "qt", "serv", "obj", "rx"], "resp": ["job", "cb", "Resp", "data", "respond", "rev", "comp", "p", "download", "Response", "proc", "rec", "prot", "bb", "jp", "b", "part", "cache", "r", "pre", "val", "err", "exc", "reply", "rr", "respons", "ret", "cmp", "sp", "api", "request", "response", "rep", "pos", "result", "res", "ref", "report", "inv", "re", "html", "serv", "obj"], "bis": ["bin", "isin", "ais", "sin", "iss", "bes", "bs", "boot", "ori", "rots", "os", "bh", "binary", "obos", "is", "bian", "atis", "bi", "lins", "bb", "b", "obs", "bits", "phis", "ubis", "abi", "pins", "bid", "mis", "nis", "bas", "uds", "ois", "alis", "fb", "bps", "tis", "ris", "iris", "oris", "sb", "sis", "los", "ios", "usb", "lis", "obb", "obi", "ses"], "bos": ["bott", "osa", "lol", "bin", "oS", "opus", "fits", "las", "bes", "oos", "bs", "boot", "os", "bh", "lins", "obos", "bi", "obs", "bits", "antis", "ops", "oses", "phis", "oks", "ubis", "abi", "bris", "mos", "bas", "ois", "uds", "obo", "oops", "tis", "bps", "osi", "oros", "aos", "bo", "ros", "los", "ios", "zo", "zos", "obb", "obi", "bones"]}}
{"id1": "13362846", "id2": "18211588", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"setContenu": ["setContonenu", "setContineuer", "setContenuer", "setContenuit", "setContenues", "setContennuer", "setContennuit", "setContonenuit", "setContonenuer", "setContennues", "setContineu", "setContineues", "setTenuit", "setTonenuer", "setTenuer", "setTonenues", "setContennu", "setTonenu", "setTonenuit", "setContonenues", "setTenues", "setTenu", "setContineuit"], "contenuFichier": ["contenuFichoyer", "contenuFchier", "contenuFicie", "contenuPhactoryiere", "contenuFrenchery", "contenuFicheieri", "contenuFichtier", "contenuTicheery", "contenuFichie", "contenuFichtieri", "contenuFiciere", "contenuMichieri", "contenuFicheique", "contenuTicheerer", "contenuPFichique", "contenuPhactoryier", "contenuFicheery", "contenuPFochier", "contenuFrenchique", "contenuMrenchiere", "contenuPhactoryoyer", "contenuFicheerer", "contenuMaffier", "contenuFichtiere", "contenuFaffier", "contenuFicheier", "contenuMaffieri", "contenuPrefaffie", "contenuFicher", "contenuMaffie", "contenuPFochique", "contenuPrefichiere", "contenuMrenchier", "contenuPhichiere", "contenuFochier", "contenuFrenchiere", "contenuPFochiere", "contenuPrefaffiers", "contenuFchery", "contenuPrefaffiere", "contenuPrefichier", "contenuFactoryiere", "contenuFichiers", "contenuMichie", "contenuMrenchique", "contenuFochie", "contenuFichieri", "contenuTicheier", "contenuFicheer", "contenuFaffiers", "contenuPrefichie", "contenuFichery", "contenuFrenchie", "contenuFactoryie", "contenuFichique", "contenuPhichier", "contenuFicherer", "contenuFichiere", "contenuPhichie", "contenuMichiers", "contenuFaffique", "contenuTichier", "contenuFocher", "contenuPrefichiers", "contenuFichtie", "contenuFaffiere", "contenuFaffie", "contenuMaffiere", "contenuFchiere", "contenuPFocher", "contenuFaffer", "contenuPFichiere", "contenuFrencherer", "contenuPFichier", "contenuFicheie", "contenuFichtique", "contenuTichery", "contenuPFicher", "contenuMichier", "contenuFicoyer", "contenuFcherer", "contenuFicheiere", "contenuTicheiere", "contenuFrenchier", "contenuPrefaffier", "contenuFochiers", "contenuTichiere", "contenuMrenchie", "contenuFrenchiers", "contenuFactoryoyer", "contenuFochiere", "contenuFaffieri", "contenuFrenchoyer", "contenuMichique", "contenuPhichoyer", "contenuTicherer", "contenuMaffiers", "contenuFochique", "contenuMichiere", "contenuPhactoryie", "contenuFicier", "contenuFactoryier"], "fichierElectronique": ["fichierElectroneier", "fichierElectroniques", "fichierElectonlique", "fichierElectronsiques", "fichierElectronsique", "fichierElectronsie", "fichierElectrolie", "fichierElectonier", "fichierAdministronsistic", "fichierElectpronistic", "fichierElectorniques", "fichierElectronsistic", "fichierElectronical", "fichierCentorniques", "fichierElectolonique", "fichierElectroniere", "fichierAustrolique", "fichierElectronlique", "fichierElectornique", "fichierElectproniques", "fichierCentornlique", "fichierElectromiques", "fichierAdministronslique", "fichierCentronier", "fichierAustroliere", "fichierAdministronsiques", "fichierAdministronlique", "fichierAdministronsier", "fichierElectron\u00e9e", "fichierAdministronsie", "fichierElectpronical", "fichierElectronelique", "fichierElectronie", "fichierElectronsical", "fichierElectoloniere", "fichierElectromical", "fichierAdministrons\u00e9e", "fichierElectronistic", "fichierElectroneique", "fichierAustronier", "fichierCentronique", "fichierAdministronie", "fichierAustroliques", "fichierAustroniere", "fichierCentornier", "fichierElectoloniques", "fichierAdministronique", "fichierElectroneiques", "fichierElectronsier", "fichierElectronica", "fichierAdministronsique", "fichierElectaron\u00e9e", "fichierAdministronistic", "fichierElectrolique", "fichierElectaronie", "fichierAdministronsical", "fichierElectrons\u00e9e", "fichierAdministronical", "fichierAdministroniques", "fichierElectrol\u00e9e", "fichierAdministronier", "fichierElectroliere", "fichierElectornlique", "fichierElectrolica", "fichierElectroneie", "fichierElectornier", "fichierElectronsiere", "fichierElectonique", "fichierElectaronier", "fichierElectromistic", "fichierCentroniques", "fichierAustrolier", "fichierCentornique", "fichierAustroniques", "fichierAdministron\u00e9e", "fichierElectroliques", "fichierElectroneiere", "fichierElectpronique", "fichierElectromique", "fichierElectonie", "fichierElectronier", "fichierAustronique", "fichierElectolonica", "fichierElectronsica", "fichierElectronslique", "fichierElectaronique", "fichierElectrolier", "fichierCentronlique"], "utilisateurCourant": ["utilisateurApplicateur", "utilisationApplicant", "utilisateurParticipateur", "utilisationCourant", "utilisateurCourants", "utilisationApplicateur", "utilisateurApplicante", "utilisateurGovernant", "utilisateurApplicants", "utilisationCourante", "utilisateurGovernants", "utilisateurParticipante", "utilisationApplicants", "utilisateurCourante", "utilisateurApplicant", "utilisateurGovernateur", "utilisateurGovernante", "utilisationCourateur", "utilisateurCourateur", "utilisationCourants", "utilisationApplicante", "utilisateurParticipant", "utilisateurParticipants"], "support": ["feature", "util", "force", "allow", "services", "info", "settings", "know", "utils", "supported", "ann", "control", "library", "plugin", "format", "summary", "Support", "share", "protection", "evidence", "concept", "respect", "client", "best", "pull", "knowledge", "service", "proxy", "storage", "media", "review", "system", "bank", "config", "document", "friend", "facebook", "Library", "contact", "cover", "help", "pport", "accept", "compatible", "push", " Support", "supp"], "ficheDocument": ["ficheFeature", "FcheDoc", " ficheDocuments", "fineFeature", "financeDocument", "fielCompany", "fruitdocument", "fruitNumber", "enfoiceDirectory", "enficheDocument", "foineDoc", "FicheDoc", "infichedocument", "enfoiceCompany", "fraudDirectory", "fineDoc", "frauddocument", "FcheDocument", " ficheMatrix", "fineDocument", "fchadocument", "ficheDoc", "foiceCatalog", "financedocument", "Fichedocument", "FicheContent", "inficheDoc", " fcheMatrix", "fcheContent", " ficheDirectory", "foineDocument", "fetchdocument", "fraudCatalog", "Fchedocument", "enficheCatalog", "affineDoc", "financeDoc", "fagueDocuments", "FcheContent", "friqueDocument", "infrauddocument", "fruitDocument", "foiceCompany", "enfoiceCatalog", "fcheMatrix", "fruitDoc", "affineDocument", "enficheDirectory", "fraudNumber", "fetchFeature", "fetchDocument", "ficheCatalog", "afficheFeature", "fichedocument", "friqueContent", "fraudDoc", "facheDirectory", "enfoiceDocument", "friqueDoc", "fcheDocuments", "ficheCompany", "inficheDocument", "affichedocument", "fagueMatrix", "fchaDoc", "fielDirectory", "fetchDoc", "infraudDoc", "facheDocument", "ficheDirectory", "foineFeature", "enficheCompany", "fagueDocument", "fielDocument", "foinedocument", "fcheDirectory", "foiceDirectory", " fcheDocument", "infraudNumber", "fagueDirectory", "affineFeature", "fraudCompany", "fcheDocument", "fchedocument", "fchaContent", " fcheDocuments", "foiceDocument", "afficheDoc", "afficheDocument", "fcheDoc", "fielCatalog", "inficheNumber", "friquedocument", "affinedocument", "FicheDocument", "ficheNumber", "financeNumber", "ficheDocuments", "facheDocuments", "fchaDocument", "facheMatrix", "fraudDocument", "finedocument", "ficheMatrix", " fcheDirectory", "infraudDocument", "ficheContent"], "nomFichier": ["nomFichiller", "nomF\u00e9tier", "nomFachrier", "nomFitherer", "nomPrefchrier", "nomFrencher", "nomNichtiller", "nomWchiere", "nomVcher", "nomFiqurier", "nomFichtieri", "nomFichieri", "nomF\u00e9tery", "nomFochiere", "nomPhachier", "nomFichiere", "nomFacherer", "nomFiscer", "nomFrenchieri", "nomFiquieri", "nomPrefchire", "nomF\u00e9tien", "nomFisciller", "nomPhachieri", "nomVichier", "nomFochier", "nomFach\u00e8re", "nomFrench\u00e8re", "nomFichtire", "nomPchien", "nomFachire", "nomFchier", "nomFachiere", "nomPhacherer", "nomFiscery", "nomPhachiere", "nomFch\u00e8re", "nomPrefchier", "nomPrefichier", "nomFcher", "nomFichrier", "nomWchier", "nomWichery", "nomVchieri", "nomFacher", "nomNichiller", "nomFichter", "nomNichtier", "nomPchery", "nomFchery", "nomFichery", "nomVichieri", "nomFichire", "nomFichiner", "nomFichtiller", "nomFiscy", "nomFachier", "nomPichery", "nomPrefichire", "nomFchire", "nomNichtiner", "nomFithier", "nomPhichiere", "nomWichire", "nomWchire", "nomFichtery", "nomFachieri", "nomWchery", "nomFiquire", "nomFicherer", "nomNicher", "nomFachiller", "nomVch\u00e8re", "nomFichtier", "nomPichier", "nomFichy", "nomFochery", "nomFrenchier", "nomVicher", "nomFiscier", "nomFchiere", "nomPrefchieri", "nomFithiere", "nomPichy", "nomFicher", "nomPchier", "nomFiquier", "nomFchrier", "nomFchien", "nomPchy", "nomWichiere", "nomPhichier", "nomWichier", "nomFich\u00e8re", "nomFichterer", "nomF\u00e9ty", "nomFithieri", "nomPrefichrier", "nomFchieri", "nomFchy", "nomFiscien", "nomPhicherer", "nomNichiner", "nomFisciner", "nomFochire", "nomPichien", "nomFichien", "nomNichter", "nomPhichieri", "nomFichtiner", "nomFachiner", "nomPrefichieri", "nomFichtiere", "nomNichier", "nomVchier", "nomVich\u00e8re"], "extension": ["extression", "encension", "exression", "Extion", "anchension", "extensions", "exension", "Extception", "EXTensions", "anchensions", "exception", "EXTime", "extception", "anchime", "encion", "extime", "extion", "Extensions", "EXTension", "Extression", "encression", "encception", "Extension", "Extime", "exion"], "fichierElectroniqueExistant": ["fichierElectroniqueXclusive", "fichierElectroniquesXilingual", "fichierElectroniquesXistent", "fichierElectroniqueExplists", "fichierElectroniqueExists", "fichierElectroniquesExclusive", "fichierElectroniqueExplistant", "fichierElectroniqueexilingual", "fichierElectroniqueXivist", "fichierElectroniquesExistant", "fichierElectroniquesXclusive", "fichierElectroniqueexist", "fichierElectroniquesExistent", "fichierElectroniqueExclusive", "fichierElectroniquesExivist", "fichierElectroniqueXist", "fichierElectroniqueexclusive", "fichierElectroniqueExplist", "fichierElectroniqueexistent", "fichierElectroniqueSistance", "fichierElectroniqueExist", "fichierElectroniqueXists", "fichierElectroniqueExivist", "fichierElectroniquesXist", "fichierElectroniquesXivist", "fichierElectroniquesExists", "fichierElectroniqueExistent", "fichierElectroniqueXistant", "fichierElectroniqueExistance", "fichierElectroniqueExilingual", "fichierElectroniqueExplistance", "fichierElectroniqueXistance", "fichierElectroniqueexists", "fichierElectroniqueExplclusive", "fichierElectroniquesExilingual", "fichierElectroniqueXistent", "fichierElectroniqueSilingual", "fichierElectroniqueXilingual", "fichierElectroniquesExist", "fichierElectroniqueexivist", "fichierElectroniqueexistant", "fichierElectroniqueSistent", "fichierElectroniquesXists", "fichierElectroniquesExistance", "fichierElectroniquesXistance", "fichierElectroniquesXistant", "fichierElectroniqueSistant", "fichierElectroniqueExplivist", "fichierElectroniqueexistance"], "idIgid": ["idUguID", "idIguname", "idIgnod", "idIgnid", "idIogdid", "idIgnID", "idIggod", "idEgbit", "idEgids", "idEGids", "idUgID", "idUguname", "idIguids", "idIogids", "idIgID", "idIgmname", "idEgid", "idIGid", "idEgdid", "idIgubit", "idIgmID", "idIgdid", "idIgenname", "idIgenids", "idUguid", "idEGdid", "idIgudid", "idIgname", "idIggid", "idUgid", "idEGid", "idIguid", "idIgnids", "idUgids", "idIggids", "idIguod", "idEGbit", "idIGbit", "idIgenID", "idIgbit", "idIGids", "idIgmid", "idIgod", "idUgname", "idIgmids", "idIggID", "idIGdid", "idUguids", "idIgids", "idIguID", "idIgenid", "idIogbit", "idIogid"], "inputStream": [" inputstream", "inputSteam", "outputLength", "eventStream", "InputStream", "InputStreamer", "eventstream", "outputStreamer", "inputStreamer", "inputThread", "outputThread", "InputThread", "InputLength", "inputLength", "Inputstream", " inputLength", "outputSteam", "eventSteam", "InputSteam", "inputstream", "eventStreamer", " inputSteam", " inputThread", "outputstream"], "outputStream": ["officeStream", "entityStream", "inputSteam", "OutputSteam", "officeSteam", "officestream", "inputContext", "OutputStream", "outputStreamer", "Outputstream", "inputStreamer", "outputContext", " outputstream", "entityStreamer", "OutputContext", "entitySteam", " outputSteam", " outputContext", "officeStreamer", "outputSteam", "inputstream", "entitystream", "outputstream", "OutputStreamer"], "typeMime": ["typeMetangle", "typeMatime", "typeSmide", "typeMatimes", "typeMatangle", "TypeSmangle", "TypeSmide", "typeMatide", "TypeMimes", "typeMetide", "TypeSmimes", "typeMangle", "typeSmangle", "typeMimes", "TypeMide", "TypeSmime", "typeSmimes", "TypeMangle", "typeMetime", "typeSmime", "typeMetimes", "typeMide", "TypeMime"], "tailleFichier": [" tailleFochiers", " tailleFigniers", " taillefocher", " tailleFocher", " taillefichiers", " taillefochie", " tailleFochie", " tailleFigner", " tailleFichiers", " tailleFicheier", " taillefichier", " tailleFicheiers", " taillefichie", " tailleFicheer", " taillefochiers", " tailleFochier", " tailleficher", " tailleFignie", " tailleFicher", " taillefochier", " tailleFignier", " tailleFichie", " tailleFicheie"]}}
{"id1": "23246123", "id2": "9319440", "code1": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "code2": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "label": 1, "substitutes": {"createDialogArea": ["createControlPanel", " createDialogarea", "createControlArea", " createButtonarea", "createMessagePanel", " createDialogPanel", " createButtonGroup", " createHelparea", "createHelpPanel", "createDialogPanel", "createButtonArea", "createEditorArea", "createEditorarea", " createButtonArea", "createHelpGroup", "createButtonarea", " createHelpPanel", "createHelpArea", "createControlarea", "createDialogGroup", "createDialogarea", "createMessagearea", "createHelparea", "createMessageArea", " createHelpArea", "createEditorGroup", " createDialogGroup", "createButtonGroup"], "parent": ["connection", "Parent", "sup", "current", "self", "container", "g", " child", " scene", "comp", "p", " sup", "parents", "class", "component", "page", "wrapper", "instance", "section", "clip", "root", "parser", "client", "this", "image", "ctx", "child", "port", "builder", "object", "context", "cl", "document", "null", "c", "menu", "message", "resource", "host", "panel"], "composite": ["comppositable", "Complexiting", "compositionitor", "comppositor", "compositionitable", "comppositionitable", "comosites", "comvalitor", "compositionited", "compositionite", "complexitor", "comPOSites", "comppositionitor", "comppositive", "comvalitive", "Complexitable", "comppositionite", "comPOSiting", "composites", "compposite", "complexite", "comosited", "compositable", "compositive", "complexiting", "comositable", "comPOSited", "compposited", "comvalite", "Compositing", "compositor", "composited", "comvalites", "Complexites", "comosite", "comppositionited", "comPOSitable", "comppositionitive", "Compositable", "compositionites", "complexitable", "compositing", "Composites", "Composite", "comPOSite", "complexites", "compositioniting", "complexitive", "compositionitive", "comppositionites", "compposites", "Complexite"], "content": ["connection", "app", "version", "container", "complete", "create", "cont", "layer", "application", "cms", "load", "xml", "activity", "plugin", "control", "component", "format", "copy", "page", "conn", "model", "output", "loader", "section", "cell", "client", "address", "Content", "comment", "source", "image", "child", "feed", "object", "exec", "context", "config", "document", "code", "server", "scroll", "folder", "file", "title", "message", "header", "cm", "resource", "ez", "host", "report", "json", "html", "media"], "ncol": ["nbCol", " nrow", "nbcol", "nrow", "numrow", "Ncolumn", "numcolumn", " ncolumn", "nblock", "Ncol", "NCol", " nCol", "pblock", "pcolumn", " nblock", "ncolumn", "nCol", "pcol", "nbcolumn", "Nblock", "nbrow", "pCol", "numCol", "numcol"], "layout": ["offset", "lock", "lay", "data", "scale", "mount", "where", "container", "widget", "edit", " layouts", "layer", "xml", "base", "control", "lc", "model", "inline", "nav", "position", "Layout", "section", "zip", "board", "l", "shape", "flow", "translation", "address", "design", "list", "padding", "entry", "block", "closure", "build", "feed", "image", "ui", "config", "figure", "nl", "group", "view", "scroll", "flat", " Layout", "split", "shadow", "holder", "follow", "join", "location", "draw", "alpha", "font", "grid"], "numColumns": ["numColes", "numcolumnn", "numcolumnows", "numControln", "numControls", "nbColumnes", "numControles", "nbcolumnows", "numCols", "numControlows", "numColows", "nbcolumnn", "nbcolumns", "nbColumns", "numColumnows", "numColn", "numColumnn", "numColumnes", "nbColumnows", "nbcolumnes", "nbColumnn", "numcolumns", "numcolumnes"], "browser": ["Browser", "feature", "open", "agent", "webkit", "ver", "manager", "session", "book", "remote", "theme", "web", "jar", "ger", "bot", "binary", "plugin", "ssl", "page", "nav", "br", "loader", "vert", "front", "box", "css", "img", "root", "fox", "iframe", "client", "design", "test", "chrome", "comment", "lib", "proxy", "image", "bar", "feed", "cookie", "driver", "js", "mobile", "config", "facebook", "server", "platform", "uri", "finder", "http", "io", "roller", "shadow", "cart", "river", "graph", "flash", "google", "coll", "window", "host", "report", "sim", "html", "editor", "runner", "fire"], "text": ["connection", "ext", "data", "name", "it", "pdf", "info", "ut", "str", " Text", "label", "letter", "binary", "plugin", "format", "user", "vert", "txt", "term", "output", "inner", "writer", "off", "client", "abs", "test", "atter", "service", "comment", "source", "image", "select", "feed", "entry", "Text", "driver", "path", "struct", "object", "port", "form", "context", "config", "unit", "element", "title", "message", "TEXT", "input", "report", "string", "desc", "editor", "font"], "url": ["connection", "open", "sl", "f", "ur", "gl", "web", "download", "base", "ssl", "page", "user", "zip", "l", "address", "pull", "Url", "service", "URL", "source", "image", "feed", "api", "path", "lr", "config", "uri", "server", "io", "http", "file", "id", "resource", "www", "bel", "host", "ref", "re", "rel", "string"], "in": ["x", "reader", "bin", "er", "f", "data", "login", "it", "ri", "s", "ins", "el", "pin", "stream", "p", "min", "In", "str", "xml", "rc", "rec", "is", "conn", "b", "w", "inner", "rin", "again", "br", "l", "IN", "ar", "err", "din", "fr", "dr", "o", "ini", "rb", "d", "i", "init", "image", "inc", "nin", "or", "arin", "pass", "inn", "c", "a", "ic", "lin", "resource", "input", "out", "on", "re", "gin", "serv"], "r": ["rh", "reader", "mr", "er", "f", "ri", "ur", "R", "m", "kr", "p", "vr", "ru", "rc", "pr", "rob", "b", "br", "rf", "cr", "rs", "l", "ar", "err", "fr", "o", "dr", "rb", "rr", "i", "ner", "d", "hr", "or", "rw", "rg", "h", "lr", "ir", "nr", "rt", "c", "gr", "ro", "sr", "rar", "right", "rss", "res", "out", "rl", "re", "rel", "rx"], "sb": ["SB", " SB", "bm", "cb", "ob", "sg", "si", "lp", "bj", "sn", "gb", "s", "bs", "sth", "eb", "lab", "xb", "bh", "binary", "ssl", "kb", "bb", "library", "ls", "rob", "b", "mb", "abs", "erb", "sv", "bp", "ruby", "rb", "sm", "buffer", "storage", "sp", "abb", "db", "lb", "lr", "nl", "sa", "pb", "ab", "wb", "sr", "src", "bsp", "bf", "sf", "usb", "obb", "fb", "bc", "ib", "buf"], "line": ["le", "sl", "f", "data", "name", "char", "el", "ge", "se", "str", "letter", "base", "inline", "cle", "lc", "page", "b", "part", "l", "cell", "lines", "key", "lf", "row", "comment", "i", "entry", "block", "source", "ne", "Line", "object", "character", "cl", "li", "code", "n", "nl", "pass", "pe", "split", "id", "LINE", "message", "lin", "header", "record", "stroke", "col", "string", "obj", "end"], "e": ["be", "le", "er", "f", "oe", "ception", "error", "ze", "p", "ge", "se", "one", "ae", "en", "ec", "fe", "me", "ie", "je", "ale", "ite", "err", "exc", "E", "o", "ke", "d", "ne", "i", "ime", "or", "ev", "ue", "te", "ef", "pe", "ise", "ce", "ele", "es", "ea", "ve", "de", "esi", "ee"]}}
{"id1": "494226", "id2": "4593012", "code1": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"linesep": ["lineeps", "ineseps", "nseper", "linerseter", "linersew", "linpace", "linseter", "lineearch", "linersearch", " linesupp", "ringspec", "linerseng", "lineseper", "gesyp", "gesep", "linepace", "inesep", "lineps", "linespace", "geseps", "linedep", "linepec", "linspec", "linep", "lineseng", "lineseps", " lineseps", "linsep", "linersep", "linesew", "timesep", " linesaper", " lineseter", "lineseter", "ringspace", "lineep", "linyp", " linesew", "linspace", "nseps", " linesearch", "nsep", "linesyp", "linesaper", "timesyp", "linedew", "inesaper", "lineupp", "linespec", "linseps", "ineseper", "nsaper", "linsew", "codeseps", "gespe", "linseng", "linerseps", "timespe", "linesupp", "ringsep", "timeseps", "linesip", "linpec", "linesearch", "linedip", " linespec", "linersip", " lineseper", " lineseng", "linpe", "codesew", "ringsupp", " linespace", "linedeps", "codesip", "linespe", "linerspec", "codesep"], "fos": ["coes", "FOs", "cos", "infops", "foses", "FOS", "focks", " fOS", "fes", "infotes", "loadOs", "foros", " foses", "loadoS", "Fios", "go", "fotes", "cols", "eol", "poes", "fats", "Fats", " fats", "loados", "infoses", "fo", "Foser", " fops", "Foses", "fingocks", "infes", "coos", "Foes", "foes", "Focks", "foS", "Fis", "fops", "fOs", "poos", "fullis", "pols", "infols", "Fes", "Fos", "forOS", "foser", " fo", "zotes", "zo", "loadops", "zol", " fOs", "fingos", "infios", "eos", "info", "gocks", "Fops", "gos", "fingoss", "infoos", "eotes", "infoes", "infos", " foser", "eo", "fulloser", "fios", "pos", "foos", " fios", "fulloes", " fes", "Fo", "fol", "forats", "fis", " foes", " fis", "fOS", "fullos", "FoS", "foroses", "goss", "Foss", "foss", " foS", "infol", "fols", "zos", "fingo", "infis"], "files": ["ids", "pages", "scenes", "f", "images", "blocks", "thumbnails", "data", "rows", "bs", "groups", "services", "balls", "results", "ins", "events", "lets", "Files", "ls", "items", "models", "members", "obs", "features", "apps", "l", "workers", "tools", "lines", "strings", "facts", "archives", "iles", "objects", "books", "classes", "names", "boxes", "http", "keys", "file", "jobs", "ports", "locks", "states", "users", "projects", "tests", "headers", "bugs", "rules", "plugins", "resources", "docs", "fs"], "i": ["ji", "f", "current", "y", "si", "it", "start", "ti", "ri", "type", "slice", "m", "p", "j", "info", "pi", "ie", "ix", "hi", "I", "di", "u", "b", "multi", "inner", "qi", "fi", "e", "ini", "d", "count", "ci", "z", "t", "xi", "v", "oi", "ui", "yi", "li", "uri", "ii", "io", "c", "id", "index", "iu", "eni", "ai", "gi", "phi", "col", "ip"], "metaprops": ["metoprops", "metoppropes", "metapropps", "metaprpps", "metaparps", "metaprope", "metopprop", "metoprope", "metapPropps", "metepropps", "metaprobpe", "metapprope", "metopropp", "metaprobps", "meteprope", "metaporeps", "metaporepps", "metapproperties", "metaporepe", "meteppropes", "metaprop", "metopprops", "metaproperties", "metopropps", "metaporepes", "metaprobpps", "metaprobp", "metaprobpes", "metappropes", "metapprop", "metaprospes", "metaparpps", "metoppropps", "metopprope", "metopproperties", "metaprosps", "metappropp", "metapropp", "metappropps", "meteppropps", "metopropes", "metepprope", "metoproperties", "metaprpes", "metaparpp", "metapropes", "metaprospps", "metaprobpp", "metaprps", "metapProps", "metapprops", "metoprop", "meteprops", "metepprops", "metaprpe", "metaprosperties", "metaprobperties", "metapPrope", "metoppropp", "metapPropes", "metaparp", "metepropes"], "itsect": ["Itect", "itssection", "itersect", "litrupt", "Itsector", "itrupt", " itsector", "iterrupt", "itsector", " itsection", "litna", " itect", "Itna", " itconnect", "itsection", "itssect", "litect", "itconnect", "Itrupt", "Itsection", "itect", " itrupt", "Itconnect", "Itsect", "itna", "litsect", "iterect", "itssector", "iterconnect", " itna"], "section": ["job", " Section", "division", "loc", "name", "version", "sect", "sections", "array", "j", "sector", "set", "ie", "rc", "description", "page", "part", "text", "protection", "year", "line", "account", "key", "vision", "esc", "mission", "service", "step", "entry", "sub", "closure", "child", " sections", "sec", "ion", "environment", "second", "config", "route", "Section", "function", " subsection", "script", "search", "edition", "header", "ect", "ection", "area", "string", "element"]}}
{"id1": "16142024", "id2": "18693224", "code1": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyDirectory", "Copyfile", " copyfile", "copyFolder", "copyDirectory", "transferFile", "transferFolder", "transferfile", " copyFolder", "CopyFolder", " copyDirectory", "CopyFile", "transferDirectory", "copyfile"], "srcFile": ["rcDir", "rcFile", " srcPath", "rcDirectory", "srcFiles", "rcPath", "srcDirectory", "srcClass", "sourceDir", " srcFolder", "rcFiles", "sourceDirectory", " srcDir", "sourceFiles", " srcFiles", "rcfile", " srcDirectory", " srcClass", "sourcePath", "sourcefile", "srcPath", "srcFolder", "destFiles", "srcfile", " srcfile", "sourceFolder", "destClass", "sourceFile", "rcFolder", "sourceClass", "srcDir"], "destDir": ["DestFile", "srcDirectory", "DestFolder", "targetFolder", "sourceDir", "targetDir", "sourceDirectory", "Destdir", "targetdir", "DestDir", " destFolder", "destdir", " destDirectory", "destFolder", "DestDirectory", "targetDirectory", "srcFolder", "sourceFolder", "sourcedir", "destDirectory", "srcDir"], "buffer": ["border", "uffer", "iter", "data", "batch", "slice", "reference", "seed", "array", "buff", "info", "Buffer", "received", "position", "cache", "b", "text", "size", "flush", "address", "padding", "source", "entry", "feed", "value", "request", "phrase", "url", "transfer", "read", "document", "raw", "null", "memory", "file", "message", "queue", "resource", "input", "result", "header", "length", "buf"], "destFile": ["DestFile", "DestFolder", "targetFile", "targetDir", " destinationDir", "destModel", "DestDir", " destFolder", " destDirectory", " destModel", "destFolder", "DestModel", "DestDirectory", "targetDirectory", " destinationFile", " destinationDirectory", " destinationModel", "destDirectory", "targetFolder"], "in": ["reader", "bin", "lock", "f", "data", "socket", "ins", "m", "stream", "ex", "min", "In", "is", "inside", "part", "inner", "again", "win", "din", "r", "l", "IN", "err", "client", "pull", "ini", "i", "source", "init", "image", "inc", "nin", "h", "url", "n", "pass", "inn", "up", "as", "id", "file", "a", "lin", "token", "input", "con", "gin", "serv"], "out": ["bin", "ext", "data", "name", "s", "ex", "outs", "one", "plain", "base", "conn", "w", "inner", "output", "cache", "again", "part", "writer", "work", "line", "err", "o", "client", "OUT", "source", "image", "inc", "exec", "outer", "parent", "other", "v", "n", "post", "null", "io", "net", "file", "up", "co", "Out", "obj"], "bytesRead": ["bytesread", "classesWrite", "bytesOpen", "classesNeed", "bytesCount", " bytesFollow", "Bytesread", "sizeRead", "piecesWrite", "filesWrite", " bytesUse", " bytesread", "sizeWritten", " bytesOpen", "linesCount", "linesWrite", "bytesWrite", " bytesWrite", "sizeOpen", "bytesNeed", "classesFollow", "filesFollow", "filesRead", "linesRead", "BytesWritten", "BytesRead", " bytesWritten", " bytesCount", " bytesNeed", "BytesOpen", "bytesWritten", "piecesCount", "piecesUse", "sizeread", "linesUse", "piecesRead", "bytesUse", "filesNeed", "bytesFollow", "classesRead"]}}
{"id1": "17627195", "id2": "1141361", "code1": "    public Document getContentAsDocument() {\n        synchronized (this.url) {\n            URLConnection connection = this.url.openConnection();\n            if (doReload(connection)) {\n                InputSource inputSource = new InputSource(connection.getInputStream());\n                DocumentBuilderFactory factory = new DocumentBuilderFactoryImpl();\n                this.document = factory.newDocumentBuilder().parse(inputSource);\n            }\n            return this.document;\n        }\n    }\n", "code2": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 0, "substitutes": {"getContentAsDocument": ["getContentasString", "getContentOfDoc", "getConnectionasDocuments", "getConnectionAsDocuments", "getContentInDocument", "getContentasDocument", "getConnectionasDoc", "getContentAsDoc", "getContentAsString", "getContentInDoc", "getConnectionasString", "getConnectionAsDoc", "getContentInString", "getContentOfString", "getConnectionasDocument", "getContentInDocuments", "getConnectionAsString", "getConnectionAsDocument", "getContentOfDocuments", "getContentasDocuments", "getContentOfDocument", "getContentAsDocuments", "getContentasDoc"], "connection": ["reader", "open", "loc", "channel", "socket", "session", "handler", "database", "closed", "application", "lc", "conn", "instance", "section", "collection", "client", "this", "service", "connected", "source", "pointer", "proxy", "db", "connect", "condition", "builder", "driver", "response", "ctx", "image", "ion", "character", "url", "context", "config", "relation", "server", "io", "c", "function", "result", "con", "which", "directory", "Connection", "communication"], "inputSource": ["imageSource", " inputStream", "inputPoint", "InputConnection", "InputReader", "dataStream", "dataPoint", "InputStream", "dataProvider", " inputReader", "InputSource", " inputPoint", "imageStream", "sourceSource", "sourceStream", "inputProvider", "inputConnection", "imageReader", "sourceProvider", "dataSource", " inputProvider", " inputConnection", "inputStream", "imageConnection", "sourcePoint", "inputReader"], "factory": ["fii", "Flesh", "confuture", "confactory", "FFactory", "facuture", "future", "confii", "facound", "confound", "cfound", "confence", "Factory", "cfactory", " fii", "cfence", " flesh", "found", "fFactory", "facactory", "fence", "flesh", "confFactory", "facence", "cfuture", "Fii", " fFactory", "conflesh"], "document": ["director", "layout", "doc", "version", "master", "database", "layer", "application", "xml", "library", "model", "page", "cache", "entity", "content", "root", "collection", "Document", "design", "proxy", "source", "image", "project", "response", "parent", "object", "url", "server", "element", "message", "result", "record", "docs", "html", "media", "graph", "node"]}}
{"id1": "20365090", "id2": "14878593", "code1": "        public HttpResponseExchange execute() throws Exception {\n            HttpResponseExchange forwardResponse = null;\n            int fetchSizeLimit = Config.getInstance().getFetchLimitSize();\n            while (null != lastContentRange) {\n                forwardRequest.setBody(new byte[0]);\n                ContentRangeHeaderValue old = lastContentRange;\n                long sendSize = fetchSizeLimit;\n                if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) {\n                    sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1);\n                }\n                if (sendSize <= 0) {\n                    break;\n                }\n                lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength());\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_RANGE, lastContentRange);\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sendSize));\n                forwardResponse = syncFetch(forwardRequest);\n                if (sendSize < fetchSizeLimit) {\n                    lastContentRange = null;\n                }\n            }\n            return forwardResponse;\n        }\n", "code2": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"execute": [" ping", " await", " proceed", " end", " initialize", " handle", " poll", " current", " open", " refresh", " go", " feed", " finish", " parse", " serve", " dispatch", " generate", " async", " exec", " perform", " produce", " work", " flush", " prepare", " future", " fulfill", " pull", " transfer", " resolve"], "forwardResponse": ["wardView", " forwardresponse", "ForwardView", "Forwardresponse", " forwardServer", "forwardresponse", "ForwardResp", " backwardAnswer", "forwardAnswer", "forwardResp", "wardRequest", "ForwardResponse", "ForwardRequest", "publicServer", " forwardRequest", "publicResponse", " forwardResp", " forwardView", "wardResponse", "publicAnswer", "publicRequest", "forwardRequest", " backwardServer", "forwardView", " backwardRequest", "forwardServer", "wardResp", " backwardResponse", "wardresponse", " forwardAnswer"], "fetchSizeLimit": ["fatchLengthRange", "faitLimitLimit", "faitSizeBlock", "fetchCountRange", "fetchLimitLimit", "fetchsizeLimit", "fatchSizeRange", "fetchLengthLim", "faitSizeLimit", "fatchSizePosition", "faitLimitLock", "fetchRangeUnit", "fetchRangeRange", "fetchLengthLimit", "fetchCountUnit", "faitSizeGlobal", "faitSizeLock", "fetchsizeBlock", "fetchLengthUnit", "fushSizePage", "fatchSizeLock", "fatchSizeLim", "fushCountPage", "fetchsizeGlobal", "fetchSizeLimited", "fatchLengthLimited", "fatchSizeBlock", "fushCountRange", "fetchSizeGlobal", "fetchSizeUnit", "fatchLengthBlock", "fetchLimitGlobal", "fetchsizeLock", "fetchLengthPosition", "fetchCountBlock", "fetchLimitLock", "fatchLengthLim", "fatchLengthLock", "fetchLengthLock", "fetchsizeLimited", "fetchSizeRange", "fetchRangeLimit", "fetchLengthGlobal", "fushSizeUnit", "fetchCountPosition", "fetchsizeLim", "fetchLimitRange", "fetchSizePosition", "fetchCountPage", "faitLimitGlobal", "faitLimitBlock", "fetchSizeLock", "fetchSizeLim", "fushSizeLimit", "fatchSizeLimited", "fetchLengthRange", "fetchLengthLimited", "fatchLengthLimit", "fetchLengthBlock", "fushCountLimit", "fushCountUnit", "fetchLengthPage", "fushSizeRange", "fetchRangePage", "fetchLimitBlock", "fetchLimitPosition", "fetchSizePage", "fetchSizeBlock", "fatchSizeLimit", "fetchCountLimit", "fatchLengthPosition"], "lastContentRange": ["lastContentArea", "lastReadRegion", "lastCharacterOrigin", "lastResourceInfo", "lastContentSpace", "lastFileRow", "lastSizeRange", " lastContentInfo", " lastSizeArea", " lastHeaderRegion", "lastSizeRegion", "lastResourceRegion", "lastContentRegion", "LastContentResource", "lastCharacterRegion", "lastHeaderRegion", "lastHeaderRange", "lastResourceRange", "lastCharacterRow", "lastResourceRow", "lastContentLine", "lastMessageLine", "lastCharacterRange", "lastReadRange", " lastReadInfo", "lastContentInfo", "lastContentRow", "LastContentSpace", "lastSizeArea", "lastReadArea", " lastSizeRegion", "lastVersionResource", "lastReadSpace", "latestContentRange", " lastContentResource", "LastMessageResource", "lastContentOrigin", "lastContentResource", "lastResourcerange", "lastFileRange", " lastSizeSpace", "lastResourceResource", " lastContentRow", "lastHeaderResource", "lastMessageSpace", "LastContentRange", " lastSizeRange", "LastMessageRange", "lastHeaderRow", "lastResourceOrigin", " lastHeaderOrigin", "lastReadInfo", "lastSizeSpace", "lastResourceArea", " lastContentArea", "lastContentrange", "LastMessageLine", "LastMessageSpace", "LastContentLine", "lastReadResource", "latestContentResource", " lastReadResource", "lastFileResource", " lastReadrange", "latestFileResource", "lastCurrentResource", "lastHeaderOrigin", "lastCurrentSpace", "lastHeaderLine", "lastReadrange", "latestFileRow", "latestContentRow", " lastContentrange", " lastContentSpace", "lastMessageRange", "lastCurrentLine", " lastContentRegion", " lastHeaderRow", " lastContentOrigin", "lastMessageResource", "lastVersionInfo", "lastCurrentRange", " lastHeaderRange", "lastVersionrange", "lastMessageRow", "latestFileRange", "lastHeaderSpace", "lastReadRow", " lastReadRange", "lastResourceSpace", "lastVersionRange"], "old": ["full", "ext", "current", "ant", "later", "slice", "low", "el", "from", "handle", "after", "to", "past", "local", "base", "plugin", "orig", "prev", "ld", "format", "OLD", "older", "Old", "part", "add", "inner", "less", "future", "l", "val", " Old", "and", "before", "la", "normal", "expected", "client", "list", "common", "build", "arrow", "or", "object", "form", "other", "small", "update", "front", "original", "element", "folder", "existing", "file", "last", "ore", "diff", "string", "obj", "now"], "sendSize": ["endSIZE", "sendSIZE", " sendSIZE", "forceTime", "endLength", "endStorage", "drawSize", "writeLength", "loadSIZE", "updateSize", " sendTime", "drawSIZE", "drawLength", "pushLength", "sentSize", "drawLimit", "loadOffset", "SendSize", "forceSIZE", "writeSize", "sendLen", "endTime", "SendEnd", "endEnd", "sendEnd", "pushSize", "forceLength", "pushLimit", "sendTime", "SendLength", "loadTime", " sendStorage", " sendLimit", " sendLen", "forceSize", "updateLimit", "endLimit", "sendLimit", "endSize", "writeOffset", "SendStorage", "loadRange", " sendEnd", "updateSIZE", "pushSIZE", "sendOffset", " sendLength", "pushTime", "pushLen", "writeRange", "transferSize", "sendRange", "sentSIZE", "sentLength", "transferOffset", "transferLength", "sentLimit", "sendStorage", "transferRange", "sendLength", "loadLength", "loadSize", "updateLen"]}}
{"id1": "335223", "id2": "15768167", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrap", "readandRewrites", "readAndRewwrite", "readandrewrites", "readandRewrap", "readAndSwwrite", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readAndRebrites", "readAndRewrites", "readAndrewrites", "readandrewrite", "readandRewwrite", "readandrewrap", "readAndRebrite", "readAndSwrites", "readAndSwrite", "readAndRebrap", "readAndrewrap", "readandrewwrite", "readAndRewrap", "readandRewrite"], "inFile": ["inputFile", "outFiles", "oldFile", "loginfile", "oldFilename", "infile", "inputfile", "outfile", "loginFile", " inSourceFile", "loginFiles", "inSourceFile", "outSourceFile", "loginFilename", "inFiles", "InFiles", " infile", "InSourceFile", "oldfile", "oldFiles", "inputFiles", "outFilename", " inFilename", "inFilename", "InFile", "Infile", " inFiles", "inputFilename"], "outFile": ["processFILE", "newFile", "newStream", "Outfile", " outStream", "thisFILE", "outDir", "thisfile", "outfile", " outDir", "outStream", "outputFile", "processFile", "processPlace", "offFile", "processFilename", "outputPlace", "offFilename", " outfile", "OutStream", "newDir", "outputFILE", "outputFilename", "thisFile", "outPlace", "exFILE", "exFilename", "newfile", "exFile", "outFilename", "outputfile", "offPlace", "OutDir", "outFILE", "thisFilename", "exfile", "OutFile", "offFILE"], "iis": ["iais", "Iais", " iIs", "iiss", "Iis", "IIS", " iiss", "iiIs", "iniis", "iniiss", " iris", "iniIs", "ciris", "iniIS", "iiis", "ciIs", "iiris", "iniris", "Iiss", "iiiss", " iIS", "ciIS", "iiIS", "iIS", "iris", "ciis", "iIs", "ciiss", "ciais", " iais"], "dcmParser": ["dcrParser", " dpmPar", "dmParser", "dcmJar", "dcrPar", "DcmInstallation", "dmissionReader", "dpmPlugin", "dmissionParser", " dpmReader", "dkmParser", "dcrLoader", "dhemInstallation", " dcrReader", " dcmReader", "dmcJar", "dmissionPlugin", "dcmPar", "dpmInstallation", "dcmHandler", "dpmHandler", " dpmparser", "dmLoader", "dpmPolicy", "dpmParser", "dcmPlugin", "dmmParser", " dcmLoader", " dpmJar", "dcmLanguage", "DcmJar", "dcrPlugin", " dpmarser", " dcmparser", "dmcPar", " dcmPar", "dmcParser", " dcrPlugin", "dkmPolicy", "dpmPar", "dCMLoader", "dpmLoader", "dbmPlugin", "dCMParser", " dpmHelper", "fcmReader", "dbmParser", "dCMHandler", "fpmReader", "dcrReader", "dkmPlugin", " dcmPolicy", "fpmHandler", "fcmparser", "dpmarser", "dmmparser", " dcmarser", "dbmPolicy", "dpmLanguage", "dcrJar", "dmoduleJar", "dmoduleparser", " dpmParser", "fcmHandler", "dmcarser", "dpmReader", "dcmPolicy", "dcmLoader", "dcmHelper", " dcmJar", " dcmPlugin", " dpmPlugin", "dpmparser", "dmoduleReader", "dmPlugin", " dcmHelper", "dhemJar", "dcmarser", "fpmparser", "dbmHelper", " dpmLoader", " dpmLanguage", "dmReader", " dcrLoader", "dcmparser", " dpmPolicy", "dmissionLanguage", "dhemParser", "dmmLoader", "dmodulePlugin", "dcrarser", "fpmParser", "dCMReader", "dCMPlugin", "fcmParser", "dCMparser", " dcmLanguage", "dcmInstallation", "dmoduleParser", " dcrParser", "DcmReader", "dhemReader", "dpmHelper", "dpmJar", "dmmPlugin", "dcmReader", "DcmParser", "dkmHelper"], "ds": ["cdn", "df", "ts", "asi", "data", "iss", "vals", "eps", "s", "icks", "bs", "dd", "ins", "services", "sync", "session", "ns", "da", "Ds", "utils", "os", "sys", "cs", "ld", "ls", "ys", "di", "conn", "parts", "is", "rs", "drivers", "dds", "Db", "dr", "dc", "d", "ras", "nas", "gd", "db", "points", "qs", "js", "ws", "tes", "DS", "Os", "xs", "uds", "vs", "gs", "ays", "ps", "details", "ils", "ants", "des", "src", "amps", "ros", "dat", "ss", "pd", "ads", "tx", "ks", "dt"], "pdReader": ["hdLoader", "pdRunner", "pbReader", "hdStream", "ddRunner", "dsreader", "dsReader", "ddLoader", "pdLoader", "pdStream", "pcLoader", "xdReader", "pcReader", "dsRead", "pbRunner", "pdreader", "pcWriter", "ddStream", "ddReader", "hdreader", "xdreader", "dsLoader", "xdWriter", "pdRead", "pbLoader", "pcRead", "hdWriter", "hdRead", "xdRead", "pbStream", "hdRunner", "hdReader", "dsWriter"], "out": ["lock", "ext", "login", "data", "doc", "name", "at", "down", "outs", "ssl", "w", "err", "flow", "o", "dot", "cli", "oder", "exec", "url", "default", "null", "io", "as", "co", "exp", "over", "point", "later", "session", "auto", "to", "sys", "page", "cache", "conn", "inner", "output", "term", "her", "key", "client", "builder", "outer", "parent", "order", "group", "code", "up", "word", "result", "director", "copy", "model", "with", "part", "line", "writer", "temp", "external", "lib", "image", "inc", "store", "Out", "obj", "device", "full", "connection", "manager", "s", "dev", "array", "sync", "layer", "ex", "gen", "base", "user", "again", "img", "password", "OUT", "list", "db", "child", " in", "object", "pass", "net", "in", "file", "diff", "write"], "dcmEncParam": ["dcmEstPar", "dcmDecPart", "dcmEncParameter", "dcmEncPart", "dcmElType", "dcmEnParameter", "dcmArchParameter", "dcmEnPar", "dcmDecArg", "dcmEnType", "dcmEstParameter", "dcmEstParam", "dcmArchArg", "dcmSecPart", "dcmDecParameter", "dcmEnPart", "dcmDecType", "dcmDecParam", "dcmEncPar", "dcmSecPar", "dcmSecParam", "dcmEncArg", "dcmEncType", "dcmElPar", "dcmEstType", "dcmElParameter", "dcmDecPar", "dcmEnArg", "dcmSecType", "dcmEnParam", "dcmArchParam", "dcmElParam"], "pdWriter": ["dsWrite", "PDWriting", "dpWriter", "pdWriting", "dsReader", "hdWrite", "dpWrite", "htWriting", "PDReader", "ddWrite", "dsOutput", "hdOutput", "PDWrite", "ddReader", "dpReader", "htReader", "pdOutput", "ddWriter", "pdWrite", "htWrite", "ddOutput", "PDWriter", "htWriter", "hdWriter", "hdReader", "dsWriter", "dpWriting"]}}
{"id1": "19235551", "id2": "1097147", "code1": "    protected BufferedImage handleFCLAException() {\n        if (params.uri.startsWith(\"http://image11.fcla.edu/cgi\")) try {\n            params.uri = params.uri.substring(params.uri.indexOf(\"q1=\") + 3);\n            params.uri = params.uri.substring(0, params.uri.indexOf(\"&\"));\n            params.uri = \"http://image11.fcla.edu/m/map/thumb/\" + params.uri.substring(params.uri.length() - 3, params.uri.length() - 2) + \"/\" + params.uri.substring(params.uri.length() - 2, params.uri.length() - 1) + \"/\" + params.uri.substring(params.uri.length() - 1, params.uri.length()) + \"/\" + params.uri + \".jpg\";\n            URL url = new URL(params.uri);\n            URLConnection connection = url.openConnection();\n            return processNewUri(connection);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"handleFCLAException": [" handlePCLError", " handleFCLError", " handleFCMAException", " handlePCLAError", " handleFCAError", " handlePCLAException", " handleFCMA1", " handleFCLception", " handleFCLA1", " handlePCLception", " handleFCLAception", " handlePCLAception", " handleFCMAception", " handlePCLException", " handlePCL1", " handleFCA1", " handleFCMAError", " handleFCAException", " handleFCLException", " handleFCL1", " handlePCLA1", " handleFCLAError", " handleFCAception"], "params": ["data", "type", "services", "ls", "css", "members", "features", "source", "ps", "as", "module", "resources", "images", "ams", "cache", "apps", "rs", "parse", "points", "phys", "spec", "names", "errors", "styles", "tags", "global", "series", "result", "es", "rules", "json", "eps", "database", "options", "param", "model", "parts", "ops", "Parameters", "posts", "vm", "temp", "external", "pins", "image", "api", "vs", "config", "details", "http", "pos", "same", "res", "site", "manager", "master", "s", "results", "settings", "relations", "base", "plugin", "status", "words", "models", "video", "files", "list", "i", "request", "server", "core", "photos", "changes", "plugins", "types", "media"], "uri": ["sequence", "version", "git", "archive", "iri", "type", "detail", "binary", "oid", "picture", "service", "source", "cli", "path", "transfer", "route", "io", "module", "message", "resource", "gi", "directory", "tile", "volume", "origin", "theme", "ori", "description", "query", "distance", "nuclear", "doi", "address", "mi", "ui", "general", "metadata", "duration", "folder", "id", "containing", "database", "remote", "verb", "umi", "component", "multi", "ini", "image", "api", "http", "title", "prefix", "eni", "location", "username", "site", "uin", "URI", "force", "ri", "slice", "course", "pi", "mode", "wiki", "direction", "plugin", "future", "domain", "href", "i", "nexus", "response", "filename", "server", "unit", "core", "menu", "link", "uni", "license"], "url": ["open", "sl", "director", "loc", "channel", "layer", "web", "base", "ssl", "plugin", "control", "page", "conn", "user", "l", "client", "Url", "proxy", "URL", "source", "image", "path", "object", "system", "config", "li", "server", "browser", "http", "file", "id", "resource", "target", "window", "orb", "link", "location", "string"], "connection": ["open", "data", "channel", "socket", "handler", "database", "body", "application", "communication", "control", "conn", "section", "client", "proxy", "service", "connected", "condition", "image", "db", "connect", "i", "response", "object", "ion", "character", "context", "close", "config", "document", "relation", "server", "io", "http", "c", "result", "resource", "con", "Connection", "string"]}}
{"id1": "23310397", "id2": "13333160", "code1": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        mButton1 = (Button) findViewById(R.id.myButton1);\n        mButton2 = (Button) findViewById(R.id.myButton2);\n        mTextView1 = (TextView) findViewById(R.id.myTextView1);\n        mButton1.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpPost httpRequest = new HttpPost(uriAPI);\n                List<NameValuePair> params = new ArrayList<NameValuePair>();\n                params.add(new BasicNameValuePair(\"str\", \"post string\"));\n                try {\n                    httpRequest.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n        mButton2.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpGet httpRequest = new HttpGet(uriAPI);\n                try {\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        strResult = eregi_replace(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"\", strResult);\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 0, "substitutes": {"onCreate": ["ONCreating", "onClick", "jobCre", "ONClick", " onCreated", "OnClick", " onClick", "ONCreate", "onCreating", "OnCreating", " onCreating", " onCre", "jobClick", "jobCreated", "ONCreated", "OnCreate", "jobCreate", "OnCreated", "onCreated", "onCre", "OnCre"], "savedInstanceState": ["savingInstStates", "savingInstanceInfo", "savedInstanceConfig", "savingInstInfo", "savedCaseStates", "savedinstanceInfo", "savedanceStates", "savedInstanceData", "savingInstData", "savingInstState", "savedanceInfo", "savedinstanceData", "savedinstanceStates", "savedinstanceConfig", "savingInstanceState", "savedCaseConfig", "savingInstanceConfig", "savedInstInfo", "savedanceState", "savedInstanceInfo", "savedInstData", "savedInstanceStates", "savedInstState", "savingInstanceStates", "savedinstanceState", "savingInstanceData", "savedCaseInfo", "savedInstConfig", "savedCaseState", "savedInstStates", "savedanceData", "savingInstConfig"], "mButton1": ["MButton1", "mActionOne", "mBorder01", "mChannel1", "mText1", "mAction2", "mText01", "MAction2", "MButtonFirst", "MAction1", "MActionOne", "mChannelOne", "mOption1", "mChannelFirst", "mOptionId", "mBorder1", "MActionId", "mAction1", "mBorderFirst", "mTextFirst", "mOption2", "mBorder2", "MChannelFirst", "mButtonFirst", "mText2", "mChannelId", "mButtonId", "mChannel01", "mButton01", "MButtonId", "MChannel2", "mButtonOne", "mChannel2", "MButtonOne", "MChannel1", "mActionId", "MButton01", "MChannel01", "mOptionOne", "MButton2"], "mButton2": ["mOptionTwo", "mText1", " mText1", " mText02", "mText02", "mAction2", "mLabel1", "mActionTwo", "mOption02", " mEditorTwo", "mOption1", "mEditorTwo", "mButton02", "mAction1", "mAction02", " mEditor1", " mButtonTwo", "mOption2", " mText2", " mTextTwo", "mLabel2", "mText2", "mTextTwo", "mEditor1", " mEditor2", "mEditor2", " mButton02", "mLabelTwo", "mButtonTwo"], "mTextView1": ["mTEXTview4", "mTextView0", "mTextVIEW5", "mTEXTview11", "mTextContainer11", "mTextVIEW1", "mTextVIEWp", "mTextContainer1", "mTextVIEW0", "mTextview4", "mTextDisplay1", "mContextView0", "mTEXTview8", "mTEXTViewOne", "mTextview11", "mTEXTview5", "mTextview0", "mTextContainer2", "mTextContainer8", "mTextStream2", "mTEXTView8", "mTextViewOne", "mTextviewp", "mContextView11", "mTEXTView1", "mTextDisplay5", "mTEXTView11", "mTextView2", "mTEXTview2", "mTextView4", "mContextview1", "mTextview1", "mContextview0", "mTextStream1", "mTextDisplay4", "mTextVIEW4", "mTextForm11", "mTextVIEWOne", "mTextDisplay2", "mTextForm8", "mTextStream11", "mTextStream0", "mContextview2", "mTextview2", "mTextField5", "mTextForm1", "mTextView5", "mTEXTview1", "mTEXTView5", "mContextView5", "mTextStreamp", "mContextViewp", "mTextview5", "mTEXTviewOne", "mTextView8", "mTextView11", "mContextView2", "mTextVIEW2", "mTextVIEW11", "mTEXTView4", "mTextForm2", "mContextview5", "mTextField1", "mContextView1", "mTextview8", "mTEXTView2", "mContextviewp", "mTextField2", "mTextviewOne", "mTextViewp", "mContextview11", "mTextDisplayOne"], "v": ["x", "f", "version", "g", "m", "V", "j", "p", "en", "vv", "model", "page", "video", "b", "w", "sv", "l", "val", "Ev", "e", "env", "i", "value", "t", "port", "h", "vs", "n", "view", "conv", "server", "c", "function", "Version", "Value", "ve"], "uriAPI": ["cliPython", "URISSL", "uiAPI", "uriCA", "uriPA", "riSSL", "uiapi", "uriAP", "urlAPI", "uriPython", "durationAPI", "cliapi", "uiPython", "urlPA", "uriapi", "durationAP", "URICA", "riAPI", "urlCA", "URIAP", "directoryapi", "idCA", "cliAPI", "idAPI", "URIapi", "directoryAPI", "idPA", "directorySSL", "URIPA", "riPython", "URIAPI", "durationPython", "riAP", "URIPython", "uriSSL", "riapi"], "httpRequest": ["HttpMessage", "httpsRequest", "ttpRequest", "htmlrequest", "HttpRequest", " httpClient", "httprequest", "buildRequest", " httpMessage", "htmlRequest", "buildrequest", "httpReturn", "httpsrequest", " httpReturn", "safeResponse", "externalrequest", "httpAsk", " httpAsk", "Httprequest", "externalResponse", "uriCause", "buildMessage", "htmlResponse", "ttpClient", "saferequest", "httpsReturn", "httpClient", "uriResponse", "httpCause", "safeRequest", "ttprequest", " httpCause", "httpMessage", "safeAsk", "uriRequest", "externalRequest", "HttpResponse", "ttpReturn", " httprequest", "externalAsk", "htmlCause", "httpsClient", "buildResponse", "urirequest"], "params": ["values", "data", "eps", "type", "options", "services", "array", "results", "body", "settings", "ams", "relations", "par", "param", "arms", "items", "parts", "Parameters", "apps", "query", "posts", "ras", "list", "pins", "i", "api", "request", "response", "url", "vs", "names", "config", "uri", "ps", "http", "details", "keys", "pos", "changes", "result", "properties", "rules", "resources", "json", "string", "ip"], "httpResponse": ["ttpServer", "Httpresponse", "ttpRequest", "HttpRequest", "externalResult", "htmlResult", "HttpReply", "ttpResult", "HTTPResponse", "HTTPRequest", "httpReply", "serverResult", " httpReply", "HttpServer", " httpResult", "externalResponse", "htmlresponse", "htmlResponse", "httpServer", "htmlResp", "ttpClient", "httpresponse", "HttpResult", "HttpClient", "httpResp", " httpresponse", "httpClient", "serverResponse", "serverRequest", "ttpReply", "externalRequest", "htmlReply", "HttpResp", "HttpResponse", " httpResp", "httpResult", "ttpResp", "htmlServer", "HTTPReply", "HTTPResp", "externalClient", "serverResp", "ttpResponse"], "strResult": ["stringResult", "strresult", "StrResults", "stringResponse", " strresult", " strResponse", " strResults", "strResults", "strResponse", "stringresult", "stringResults", "StrResult", "StrResponse", "Strresult"]}}
{"id1": "530882", "id2": "12783713", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrap", "readandRewrites", "readAndRewwrite", "readandrewrites", "readandRewrap", "readAndSwwrite", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readAndRebrites", "readAndRewrites", "readAndrewrites", "readandrewrite", "readandRewwrite", "readandrewrap", "readAndRebrite", "readAndSwrites", "readAndSwrite", "readAndRebrap", "readAndrewrap", "readandrewwrite", "readAndRewrap", "readandRewrite"], "inFile": ["inputFile", "outFiles", "oldFile", "loginfile", "oldFilename", "infile", "inputfile", "outfile", "loginFile", " inSourceFile", "loginFiles", "inSourceFile", "outSourceFile", "loginFilename", "inFiles", "InFiles", " infile", "InSourceFile", "oldfile", "oldFiles", "inputFiles", "outFilename", " inFilename", "inFilename", "InFile", "Infile", " inFiles", "inputFilename"], "outFile": ["processFILE", "newFile", "newStream", "Outfile", " outStream", "thisFILE", "outDir", "thisfile", "outfile", " outDir", "outStream", "outputFile", "processFile", "processPlace", "offFile", "processFilename", "outputPlace", "offFilename", " outfile", "OutStream", "newDir", "outputFILE", "outputFilename", "thisFile", "outPlace", "exFILE", "exFilename", "newfile", "exFile", "outFilename", "outputfile", "offPlace", "OutDir", "outFILE", "thisFilename", "exfile", "OutFile", "offFILE"], "iis": ["iais", "Iais", " iIs", "iiss", "Iis", "IIS", " iiss", "iiIs", "iniis", "iniiss", " iris", "iniIs", "ciris", "iniIS", "iiis", "ciIs", "iiris", "iniris", "Iiss", "iiiss", " iIS", "ciIS", "iiIS", "iIS", "iris", "ciis", "iIs", "ciiss", "ciais", " iais"], "dcmParser": ["dcrParser", " dpmPar", "dmParser", "dcmJar", "dcrPar", "DcmInstallation", "dmissionReader", "dpmPlugin", "dmissionParser", " dpmReader", "dkmParser", "dcrLoader", "dhemInstallation", " dcrReader", " dcmReader", "dmcJar", "dmissionPlugin", "dcmPar", "dpmInstallation", "dcmHandler", "dpmHandler", " dpmparser", "dmLoader", "dpmPolicy", "dpmParser", "dcmPlugin", "dmmParser", " dcmLoader", " dpmJar", "dcmLanguage", "DcmJar", "dcrPlugin", " dpmarser", " dcmparser", "dmcPar", " dcmPar", "dmcParser", " dcrPlugin", "dkmPolicy", "dpmPar", "dCMLoader", "dpmLoader", "dbmPlugin", "dCMParser", " dpmHelper", "fcmReader", "dbmParser", "dCMHandler", "fpmReader", "dcrReader", "dkmPlugin", " dcmPolicy", "fpmHandler", "fcmparser", "dpmarser", "dmmparser", " dcmarser", "dbmPolicy", "dpmLanguage", "dcrJar", "dmoduleJar", "dmoduleparser", " dpmParser", "fcmHandler", "dmcarser", "dpmReader", "dcmPolicy", "dcmLoader", "dcmHelper", " dcmJar", " dcmPlugin", " dpmPlugin", "dpmparser", "dmoduleReader", "dmPlugin", " dcmHelper", "dhemJar", "dcmarser", "fpmparser", "dbmHelper", " dpmLoader", " dpmLanguage", "dmReader", " dcrLoader", "dcmparser", " dpmPolicy", "dmissionLanguage", "dhemParser", "dmmLoader", "dmodulePlugin", "dcrarser", "fpmParser", "dCMReader", "dCMPlugin", "fcmParser", "dCMparser", " dcmLanguage", "dcmInstallation", "dmoduleParser", " dcrParser", "DcmReader", "dhemReader", "dpmHelper", "dpmJar", "dmmPlugin", "dcmReader", "DcmParser", "dkmHelper"], "ds": ["cdn", "df", "ts", "asi", "data", "iss", "vals", "eps", "s", "icks", "bs", "dd", "ins", "services", "sync", "session", "ns", "da", "Ds", "utils", "os", "sys", "cs", "ld", "ls", "ys", "di", "conn", "parts", "is", "rs", "drivers", "dds", "Db", "dr", "dc", "d", "ras", "nas", "gd", "db", "points", "qs", "js", "ws", "tes", "DS", "Os", "xs", "uds", "vs", "gs", "ays", "ps", "details", "ils", "ants", "des", "src", "amps", "ros", "dat", "ss", "pd", "ads", "tx", "ks", "dt"], "pdReader": ["hdLoader", "pdRunner", "pbReader", "hdStream", "ddRunner", "dsreader", "dsReader", "ddLoader", "pdLoader", "pdStream", "pcLoader", "xdReader", "pcReader", "dsRead", "pbRunner", "pdreader", "pcWriter", "ddStream", "ddReader", "hdreader", "xdreader", "dsLoader", "xdWriter", "pdRead", "pbLoader", "pcRead", "hdWriter", "hdRead", "xdRead", "pbStream", "hdRunner", "hdReader", "dsWriter"], "out": ["lock", "ext", "login", "data", "doc", "name", "at", "down", "outs", "ssl", "w", "err", "flow", "o", "dot", "cli", "oder", "exec", "url", "default", "null", "io", "as", "co", "exp", "over", "point", "later", "session", "auto", "to", "sys", "page", "cache", "conn", "inner", "output", "term", "her", "key", "client", "builder", "outer", "parent", "order", "group", "code", "up", "word", "result", "director", "copy", "model", "with", "part", "line", "writer", "temp", "external", "lib", "image", "inc", "store", "Out", "obj", "device", "full", "connection", "manager", "s", "dev", "array", "sync", "layer", "ex", "gen", "base", "user", "again", "img", "password", "OUT", "list", "db", "child", " in", "object", "pass", "net", "in", "file", "diff", "write"], "dcmEncParam": ["dcmEstPar", "dcmDecPart", "dcmEncParameter", "dcmEncPart", "dcmElType", "dcmEnParameter", "dcmArchParameter", "dcmEnPar", "dcmDecArg", "dcmEnType", "dcmEstParameter", "dcmEstParam", "dcmArchArg", "dcmSecPart", "dcmDecParameter", "dcmEnPart", "dcmDecType", "dcmDecParam", "dcmEncPar", "dcmSecPar", "dcmSecParam", "dcmEncArg", "dcmEncType", "dcmElPar", "dcmEstType", "dcmElParameter", "dcmDecPar", "dcmEnArg", "dcmSecType", "dcmEnParam", "dcmArchParam", "dcmElParam"], "pdWriter": ["dsWrite", "PDWriting", "dpWriter", "pdWriting", "dsReader", "hdWrite", "dpWrite", "htWriting", "PDReader", "ddWrite", "dsOutput", "hdOutput", "PDWrite", "ddReader", "dpReader", "htReader", "pdOutput", "ddWriter", "pdWrite", "htWrite", "ddOutput", "PDWriter", "htWriter", "hdWriter", "hdReader", "dsWriter", "dpWriting"]}}
{"id1": "14567939", "id2": "14609912", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    private static String lastModified(URL url) {\n        try {\n            URLConnection conn = url.openConnection();\n            return long2date(conn.getLastModified());\n        } catch (Exception e) {\n            SWGAide.printDebug(\"cach\", 1, \"SWGCraftCache:lastModified: \" + e.getMessage());\n        }\n        return \"0\";\n    }\n", "label": 0, "substitutes": {"baseHash": ["basehash", " generateHash", " chainSecret", "BaseFile", "BaseSecret", " generateSecret", " generateFile", "Basehash", " chainhash", " chainFile", "baseFile", "baseSecret", " generatehash", " chainHash", "BaseHash"], "name": ["ame", "data", "type", "create", "definition", "base", "class", "part", "user", "alias", "account", "key", "member", "normal", "address", "secret", "style", "image", "path", "parent", "hash", "object", "names", "Name", "n", "hello", "file", "id", "word", "prefix", "resource", "host", "named", "string", "NAME"], "password": ["wallet", "profile", "data", "wd", "seed", "words", "text", "Password", "account", "key", "paste", "secret", "crypt", "padding", "source", "sword", "value", "path", "PASS", "hash", "pattern", "phrase", "attribute", "code", "pass", "priv", "word", "prefix", "token", "input", "diff", "security", "auth", "stroke", "string", "device", "username"], "digest": ["mdest", "moder", "modested", "signusher", "decEST", " diger", "DigEST", "Digester", "Digusher", "modester", "digested", "mdr", " digusher", "digester", "digEST", "mdEST", "mdester", " digger", "digger", "decest", "signester", "digr", "Digested", "Digger", "diger", "digusher", "signer", "Diger", "modest", "signest", "signger", "Digr", "decr", " digested", "decester", " digester", "Digest"]}}
{"id1": "823074", "id2": "13516684", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["conception", " deconvert", "Convert", "converting", "subvert", "unversion", " deconverting", "CONverting", "unvert", "CONvert", "unception", "Conversion", " deconverted", "unverted", "subverted", "Converted", "conversion", " deconversion", "CONverted", "subversion", "oconvert", "CONversion", "converted", "Conception", "Converting", "CONception", "subverting", "oconversion", "oconverted", "oconverting"], "src": ["reader", "username", "cb", "sin", "loc", "RC", "name", "sn", "gb", "s", "sc", "slice", "cpp", "stream", "st", "secure", "inst", "download", "sth", "load", "gz", "proc", "sys", "rc", "SourceFile", "ssl", "component", "ource", "prot", "req", "feat", "video", "img", "href", "fn", "dist", "back", "rb", "cmp", "source", "storage", "ctx", "path", "spec", "filename", "attr", "stage", "url", "config", "code", "uri", "sit", "file", "impl", "Dest", "upload", "sel", "scene", "sb", "input", "resource", "Source", "fp", "ref", "rl", "string", "obj", "buf", "tmp", "supp"], "dest": ["bin", " destination", "cont", " dst", "class", "orig", "di", "txt", "img", "fn", "dist", "temp", "std", "dc", "test", "lib", "source", "disk", "path", "null", "Dest", "target", "dir", "dat", "home", "obj", "tmp"], "in": ["reader", "bin", "inf", "isin", "login", "f", "data", "doc", "inas", "ins", "pin", "stream", "ex", "In", "is", "win", "r", "din", "val", "IN", "err", "ini", "d", "i", "source", "inc", "t", "n", "pass", "ps", "inn", "io", "as", "up", "file", "a", "input"], "p": ["f", "lp", "tp", "s", "g", "py", "m", "j", "pi", "wp", "pc", "per", "pr", "jp", "b", "part", "op", "l", "bp", "pre", "cop", "e", "r", "parser", "o", "pp", "d", "i", "sp", "t", "h", "v", "ps", "pe", "c", "P", "pm", "np", "pa", "po", "fp", "pd", "cp", "pg", "pb"], "ds": ["data", "dl", "dd", "services", "groups", "ys", "cs", "ls", "ld", "tools", "d", " props", "js", "ded", "xs", "uds", "ps", "ils", "ges", "tests", "pd", "ads", " sd", "df", "lp", "ups", "ins", "bs", "Ds", "os", "sys", "sts", "obs", "rs", "dds", "dm", "nas", "gd", "hs", "points", "ipes", "qs", "DS", "styles", "des", "ss", "ks", "dos", "cons", "ts", "vals", "eps", "els", "icks", "da", "ns", "parts", " ps", "dist", " DS", "posts", "dc", "scripts", "ths", "dates", "vs", "gs", "ays", "dat", "docs", "dt", "s", "sync", "utils", "ans", "di", "words", "models", "lines", "db", "dp", "ants", "amps", "plugins"], "format": ["tag", "data", "f", "layout", "sche", "scale", "name", "version", "at", "ant", "handler", "type", "table", "language", "filter", "letter", "feat", "class", "plugin", "model", "part", "magic", "fn", "parser", "atter", "style", "source", "template", "t", "api", "spec", "struct", "filename", "pattern", "path", "form", "url", "config", "unit", "Format", "file", "function", "act", "prefix", "fd", "frame", "record", "host", "fp", "string", "nat"], "hasPixelData": ["hasPicturedata", "hasPictureSize", "hasByteData", " hasPixeldata", "hasPixeldata", "showsPixelDATA", "hasPixelSize", "hasPixelStyle", "showsByteStyle", " hasPixelSize", "showsBytedata", "hasByteStyle", "showsPixeldata", "showsByteData", "hasPictureData", "hasByteSize", "showsByteDATA", "hasByteDATA", "showsPixelData", "haspixeldata", "hasBytedata", "hasPixelDATA", "haspixelSize", "haspixelData", "showsPixelStyle"], "inflate": ["insflATE", "invenATE", "inflode", "inffated", "inFlated", "InFlace", "Inflace", "invenate", "insflate", "inflated", "inadequating", "inFlace", "insflating", "infolating", "infolATE", "inadequATE", "invenode", "inadequode", "insflode", "inffation", "infloated", "insvenATE", "invenating", "inffate", "inFlate", "inadequate", "inflating", "InFlated", "infolode", "infface", "Inflated", "Inflate", "InFlation", "inflation", "Inflation", "infloace", "insvenating", "insvenode", "infolate", "InFlate", "inflATE", "inflace", "infloate", "insvenate", "infloation", "inFlation"], "pxlen": ["mxlen", "fxdata", "mxpos", "campos", "pclon", "axln", "ppl", "txlen", "fxLen", "pxdata", "pxsize", "pngcount", "xpsize", "pxpos", "txln", "xpcount", "ppLen", "txlin", "mxdata", "camdata", "camln", "mxln", "axlen", "pcln", "pnglength", "pglen", "pxden", "fxden", "txlon", "pgLen", "pxl", "pxlength", "pxlon", "axlon", "pclin", "camlen", "pgden", "pxln", "mxcount", "pngsize", "fxln", "pgl", "mxlength", "mxsize", "axlin", "pclen", "fxl", "pxcount", "fxpos", "pxLen", "fxlen", "xplen", "pnglen", "ppden", "pxlin", "xplength", "pplen"], "out": ["lock", "point", "error", "session", "state", "outs", "gen", "dump", "sys", "log", "copy", "page", "cache", "user", "again", "output", "conn", "line", "work", "query", "err", "OUT", "list", "lib", "cli", "step", "parent", "v", "store", "server", "group", "post", "io", "up", "co", "inter", "pad", "re", "Out", "obj"]}}
{"id1": "6966398", "id2": "7499186", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"reader": ["connection", "df", "iter", "er", "manager", "ri", "handler", "book", "raf", "stream", "p", "se", "cms", "k", "load", "rc", "per", "reads", "cer", "keeper", "loader", "instance", "her", "r", "writer", "parser", "o", "pp", "dr", "rr", "row", "buffer", "client", "ner", "oder", "source", "feed", "or", "builder", "driver", "rw", "context", "config", "reading", "read", "server", "io", "pe", "file", "rake", "rar", "ry", "resource", "input", "ler", "Reader"], "ks": ["rows", "inks", "ds", "icks", "bs", "sk", "acks", "se", "ips", "ck", "k", "ics", "ns", "gets", "works", "cs", "reads", "kb", "ans", "kies", "ls", "ko", "ops", "rs", "ke", "hs", "ctx", "qs", "KS", "ki", "DS", "books", "ku", "orks", "vs", "kes", "powers", "akes", "ps", "checks", "keys", "co", "acs", "cks", "opens", "ss", "es", "ges", "CS", "ches", "ms", "fs", "acts"], "key": ["lock", "court", "point", "char", "type", "seed", "ca", "p", "pair", "state", "k", "base", "ssl", "cache", "user", "client", "secret", "ke", "service", "value", "ki", "sign", "code", "transfer", "server", "read", "pe", "io", "keys", "c", "file", "ring", "ce", "trust", "co", "pg", "Key", "ee"], "chain": ["lock", "sequence", "family", "scale", "container", "table", "range", "slice", "stack", "pair", "wheel", "enc", "set", "base", "rule", "wrap", "cache", "box", "circle", "cr", "root", "collection", "Chain", "crypt", "secret", "list", "chains", "block", "image", "path", "object", "config", "store", "code", "c", "file", "coll", "mc", "network", "none"], "os": ["cos", "ds", "oss", "ot", "options", "s", "bos", "p", "outs", "ol", "oid", "is", " o", "op", "ops", "rs", "oses", "o", " bos", "OS", "Os", "object", "io", "ps", "osi", "iso", "pos", "aos", "rss", "ros", "res", "ou", "los", "ios", "es", "opens", "ms", "fs", "ob"], "stamper": ["spamler", "data", "stAMmer", "_", "streamler", "stammpper", " nostamler", " nostameler", "streammer", "stAMper", "s", "g", "spAMmer", "stammer", "stampper", " nostamper", "spampe", "starmper", " nostampper", " nostamepper", "stammler", "starmler", "streamper", "stammpe", "stammmer", "streampe", "stAMpe", "spAMpe", "spamper", "this", "starmple", "stameler", "stammper", "stampe", "path", "stamler", "stameper", " nostameper", "function", "spAMper", "starmpper", "stample", "stamepper", "stammple", "spAMler", "stAMler", " nostample", "stameple", " nostameple", "spammer"], "appearance": ["Appearing", "installearance", "suppfacing", "applier", "askfacing", " applier", "appeared", "askeared", "ppasion", " appear", "installearing", "signlier", "formearance", " appence", " appeared", "suppasion", "formismo", "signointment", "ppaser", "ppearance", "formearing", "atteared", " appismo", "formaser", "appears", "appointment", "appismo", "appfacing", "askence", "appearing", "feedointment", "ppearing", " appaser", "byearing", "suppearing", "signearing", "installear", "appasion", "ppear", "Appears", "appaser", "appear", "signearance", "byismo", "feedear", " appfacing", "feedearance", "signfacing", "suppear", "feedfacing", "byearance", "Appearance", "appence", "attearance", "installasion", "formear", "Applier", "signears", "suppearance", "attence", "suppointment", "attfacing", " appears", "signear", "byear", "askearance", " appearing"]}}
{"id1": "12078471", "id2": "14590676", "code1": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "code2": "    public static void download(String address, String localFileName) {\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            URL url = new URL(address);\n            out = new BufferedOutputStream(new FileOutputStream(localFileName));\n            conn = url.openConnection();\n            in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n            System.out.println(localFileName + \"\\t\" + numWritten);\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"tryLoadURL": ["tryReadString", "tryloadSSL", "tryLoadingSSL", " tryLoadSSL", "tryReadUrl", "tryLoadingUrl", "tryLoadString", "tryLoadingURL", " tryLoadString", " tryReadSSL", "tryReadSSL", " tryReadURL", " tryReadString", "tryReadURL", " tryReadUrl", "tryLoadSSL", "tryloadUrl", "tryloadURL", "tryloadString", " tryLoadUrl", "tryLoadUrl", "tryLoadingString"], "url": ["connection", "sl", "f", "loc", "name", "version", "ur", "language", "download", "str", "xml", "base", "ssl", "ll", "page", "text", "href", "l", "address", "Url", "service", "URL", "source", "image", "feed", "path", "filename", "config", "uri", "server", "http", "file", "id", "resource", "input", "host", "link", "location", "string"], "format": ["feature", "agent", "f", "version", "at", "handler", "type", "method", "language", "filter", "info", "settings", "mode", "field", "printf", "str", "class", "feat", "magic", "content", "writer", "and", "export", "att", "key", "atter", "style", "template", "value", "feed", "api", "object", "pattern", "filename", "form", "attribute", "environment", "stage", "config", "platform", "unit", "Format", "et", "file", "transform", "function", "host", "print"], "c": ["connection", "cb", "f", "cn", "cd", "nc", "sc", "m", "C", "ct", "p", "enc", "ec", "pc", "rc", "cs", "lc", "conn", "b", "u", "cr", "l", "r", "e", "client", "dc", "d", "i", "ci", "cc", "ctx", "ch", "cf", "exec", "cl", "n", "conv", "cu", "ce", "tc", "coll", "cm", "mc", "con", "cp", "ac", "fc"], "data": ["reader", "bin", "connection", "f", "name", "s", "type", "database", "body", "stream", "p", "da", "str", "base", "u", "text", "output", "bytes", "content", "alpha", "key", "la", "o", "d", "buffer", "source", "ata", "storage", "value", "response", "empty", "in", "DATA", "id", "a", "message", "resource", "input", "dat", "result", "json", "string", "media"], "model": ["reader", "Model", "df", "f", "lp", "channel", "handler", "type", "m", "ca", "layer", "xml", "base", "lc", "copy", "models", "instance", "content", "zip", "l", "query", "client", "row", "style", "image", "value", "child", "feed", "builder", "response", "parent", "object", "pattern", "api", "form", "config", "document", "view", "code", "server", "file", "ga", "module", "message", "bel", "coll", "record", "cm", "fp", "json"]}}
{"id1": "9096319", "id2": "13666876", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"handleNodeRegainedService": ["handleNodeReginedEvent", "handleNodeRegainingServices", "handleNodeRegainedEvent", "handleNodeReginedServices", "handleNodeReginedService", "handleNodeRegainingEvent", "handleNodeRegainedServices", "handleNodeRegainsService", "handleNoderegainsEvent", "handleNoderegainedServices", "handleNodeRegainsServices", "handleNodeRegainingService", "handleNodeRegainsEvent", "handleNoderegainsService", "handleNoderegainsServices", "handleNoderegainedService", "handleNoderegainedEvent"], "eventID": ["issueid", "eventid", "updateId", "nodeId", "eventId", "serviceId", "nodeTime", "eventName", " eventid", "serviceid", "issueName", "issueId", "updateid", "nodeName", "updateName", " eventId", "serviceName", "issueID", "updateID", " eventName", "serviceTime"], "nodeID": [" nodeName", "siteID", "eventid", " nodeid", "odeID", "odeId", "sourceID", "eventKey", " nodePath", "packageID", "nodeId", "siteid", "sourceRI", " nodeKey", "packageId", "odeResult", "resourceId", "odeName", "sourceId", "resourceKey", "globalid", "siteName", "eventId", "nodePath", "serviceId", "resourceID", "eventName", "objectId", "serviceid", "objectID", "globalId", "odeRI", "nodeName", "objectName", "nodeRI", " nodeRI", "globalPath", "nodeResult", " nodeResult", "nodeKey", "objectid", "eventResult", "globalID", "eventPath", "packageid", "nodeid", "siteId", " nodeId"], "ipAddr": ["ipAdr", "ipAddressr", " ipAttri", "ipChn", "ipAttvr", " ipAppvr", "ipAttrs", "ipAtter", "IPAddressrt", "ipAddvr", "ipAttr", "ipAdn", "ipOffrs", " ipAttr", "ipaddvr", "ipCher", "ipAddressrs", "IPAddressrs", "ipAddresser", "ipaddress", "ipAdrs", " ipAddress", "ipadder", "ipAttri", " ipAttvr", "ipAppvr", "ipAddri", "ipAdder", "IPAddresser", "ipAddn", " ipAttrs", "IPAddrt", "ipChr", " ipAppr", "ipaddrs", "ipAddrt", "ipApprs", "ipOffr", "ipOffrt", "ipAddressress", " ipApprs", "IPAddrs", "IPAddressn", " ipAdder", "ipAddress", "ipAddressrt", "IPAddr", "IPAdder", "ipAder", " ipAtter", "ipAddressri", "IPAddn", "ipOffri", "IPAddressr", "IPAddressri", "ipAddrs", "ipChrs", "IPAddri", "ipAddressvr", " ipAddrs", " ipAddri", " ipAddvr", "ipaddri", "ipAppr", "ipAddressn", "ipaddr"], "serviceID": ["serverID", "ServiceType", "ServiceId", "featureID", "ServiceName", "serviceIDs", " serviceName", " serviceX", "resourceId", "serverName", "featureId", " serviceNAME", "featureHandle", "serverId", "eventId", "serviceId", "skillId", "resourceID", " serviceHandle", "processName", "serviceNAME", "eventName", " serviceId", " serviceIDs", "featureIP", "serverX", "ServiceIP", "skillNAME", "serviceX", "ServiceNAME", "skillID", "processId", "serviceType", "skillName", "eventX", " serviceType", "serviceName", "ServiceHandle", "ServiceID", "serviceIP", "processID", "serviceHandle", "ServiceIDs", " serviceIP", "resourceType", "eventIDs"], "eventTime": ["EventTime", "errorPoint", "changeType", "changePoint", " eventTIME", " eventPoint", "errorTIME", "EventName", "errorType", "EventID", "eventTim", "processName", " eventTim", "eventName", "errorTime", "processTime", "eventPoint", "eventType", "changeTIME", "changeTime", "eventTIME", " eventType", "EventTim", "processID", " eventName", "processTim"], "log": ["full", "connection", "lock", "tag", "get", "it", "pool", "stop", "error", "thread", "type", "put", "lo", "info", "ge", "event", "gen", "pl", "loop", "model", "blog", "conn", "w", "format", "plug", "LOG", "contract", "output", "cache", "l", "bug", "key", "og", "temp", "call", "cat", "lex", "entry", "db", "feed", "port", "or", "path", "ch", "sec", "build", "url", "cl", "config", "level", "sign", "pe", "http", "c", "net", "com", "stat", "crit", "debug", "tool", "fail", "out", "host", "exp", "write", "Log"], "dbConn": ["bbconn", "DBCt", " dbCon", "databaseconn", "Dbconn", "realCt", "dbCt", "dbConnection", " dbConnection", "bbConn", "dbConnect", "DbConn", "cbConn", "cbconn", "databaseConn", "logconn", " dbLoc", "cbConnect", "dbCon", "bbConnect", "bbCon", "DbConnection", "dbColl", " dbconn", "fbConn", "fbCon", "fbCt", "DbConnect", "bbConnection", "dbDb", "realCon", "databaseConnection", "DBConnection", "dbconn", "realConn", "DBConn", "logConnect", " dbDb", "fbColl", "realColl", "DBCon", " dbColl", "logConn", " dbCt", "databaseLoc", "logDb", "DbDb", "DBConnect", "cbConnection", "dbLoc", "DbCt", "DbLoc", " dbConnect", "DBconn"], "outageUpdater": ["outageUptatable", "outageUpdatedatable", "outageUpdoder", "outageUpdatedratter", "outageUplatter", "outageChdoder", "outageUpdrator", "outageUpdatedrapper", "outageUpdter", "outageAppnter", "outageUpdatedater", "outageUpdapper", "outageUpdatATER", "outageUppATER", "outageChdrator", "outageUtdatatter", "outageUpmator", "outageUpdatarer", "outageUpmter", "outageUpdatedapper", "outageAppnager", "outageUpdrusher", "outageChdoster", "outageUpnator", "outageUpdatarter", "outageUpdatatter", "outageUdater", "outageUpmager", "outageUpdatedaser", "outageUnaser", "outageUnarer", "outageUpdatedrarer", "outageUppaser", "outageUtdatater", "outageUpndater", "outageUpdatedatter", "outageUpdator", "outageAppdator", "outageUpdATER", "outageUpnaser", "outageChdroster", "outageUtdatter", "outageUpndarter", "outageUpratter", "outageUppater", "outageUpdatedrATER", "outageUpdaser", "outageUpnter", "outageUpnATER", "outageUpdrater", "outageUpparter", "outageUptarer", "outageUnATER", "outageUplapper", "outageuplater", "outageUpdsoster", "outageAppdter", "outageUprusher", "outageUpstater", "outageAppdager", "outageUppatter", "outageUpfatter", "outageupdusher", "outageUpdrATER", "outageUpnater", "outageupdaser", "outageUplater", "outageUdATER", "outageChdroder", "outageUppter", "outageUpdroder", "outageAppnator", "outageUpdroster", "outageUnater", "outageUplaser", "outageUpnarer", "outageUpstager", "outageUpraser", "outageChdater", "outageUpdatater", "outageUtdatarter", "outageUpdrarer", "outageuplaser", "outageUpdraser", "outageUpdatedATER", "outageAppdater", "outageUpdatedrater", "outageUpdratable", "outageUpdager", "outageUprater", "outageUpdatatable", "outageUpmater", "outageUpdarter", "outageupdater", "outageupdatter", "outageUtdarter", "outageUpdsator", "outageuplatter", "outageAppnater", "outageUpstter", "outageUpndter", "outageUtdter", "outageChdator", "outageUpfater", "outageUdarer", "outageUpfaser", "outageUpdsoder", "outageUptater", "outageUpndatter", "outageUpdrapper", "outageUpstator", "outageUpdoster", "outageUpdatable", "outageUpdsater", "outageUpdatedratable", "outageUpnager", "outageUpfapper", "outageUdaser", "outageUtdater", "outageuplusher", "outageUpdratter", "outageUpdarer", "outageUplusher", "outageUpdataser", "outageUpnoster", "outageUpdusher", "outageUpdatedarer", "outageUpdatedraser", "outageUpnoder", "outageChdrater", "outageUptaser", "outageUpdatter"]}}
{"id1": "8064604", "id2": "11377441", "code1": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"init": ["connection", "open", "it", "Init", "activate", "create", "boot", "install", "info", "load", "setup", "launch", "set", "client", "construct", "reset", "cli", "build", "exec", "update", "config", "transfer", "initial", "sleep", "start"], "mgr": ["mr", "pigr", "prr", "marr", "Mr", "amrr", "ctr", "amigr", "Marr", "Mgr", "amgr", "mtr", "carr", " mbr", "mrr", "ambr", " marr", "cr", "cgr", " mrr", " migr", " mtr", "mbr", "migr", "pbr", "pgr", " mr", "Mtr"], "cfg": ["Msg", "bm", " ssh", "cb", "Conf", " configuration", " cache", "g", "MC", "gen", "cache", " img", "conf", " conf", " cf", "password", "map", "db", "cf", "chain", "gate", " config", "config", "file", "mem", "mc", "gp", "Hash", " chain"], "sock": ["Sock", "socks", "gesocket", "opensocket", "socket", "Socket", " socket", "Sib", "opensib", "sink", "gesink", "opensock", "Sink", "gesock", "sib", " socks", " sink", "Socks", "opensocks", "gesocks", " sib"], "_cman": ["_gman", "_mcfg", " _mcmn", "_cmn", "_mcmn", "_cfg", "_mgr", "_ggr", " _cmn", "_mfg", "_mcgr", "_gmn", "_mcman", " _mcman", "_mman", " _mcfg", " _mcgr", " _cfg", "_cgr", " _cgr", "_gfg", "_mmn"], "_sock": ["_nsrc", "_svc", "_jsocks", "_nsocks", "_docks", "_opensocket", "_bort", "_dock", " _socks", "_unsock", "_Socket", "_serve", "longnsockets", "longsock", "_Sock", "_csock", "_dort", "_openserve", "_unsocks", "_jsock", "_bocks", "_sockets", "_sdk", "_opensvc", "_Socks", "_asock", "_socks", "_opensort", "_Serve", "_bocket", "_jsdk", "_src", "_bock", "_csrc", "_nsockets", " _svc", "longsrc", "_sort", "_asocks", "longnsrc", "longnsocks", " _serve", "longsocks", "_csockets", "_asrc", "_csocks", "_docket", "longnsock", "_Sdk", "_opensocks", "_nsock", "_asockets", "_unsdk", "_unsocket", "_Svc", "_opensock", "_jsocket", "longsockets", "_socket"], "i": ["x", "ji", "f", "y", "si", "it", "ti", "ri", "q", "my", "s", "slice", "m", "j", "info", "p", "pi", "k", "field", "ie", "ix", "is", "hi", "bi", "I", "u", "b", "inner", "multi", "di", "qi", "l", "r", "e", "o", "ini", "d", "ci", "value", "h", "xi", "v", "mi", "ui", "oi", "li", "uri", "n", "ii", "io", "in", "ni", "id", "index", "iu", "chi", "gi", "ai", "phi", "ip"], "key": ["lock", "data", "name", "type", "ck", "field", "str", "ie", "shift", "kh", "section", "source", "ask", "ki", "sign", "number", "wire", "search", "pick", "length", "fee", "cy", "point", "string", "label", "rule", "op", "query", "mix", "secret", "kid", "row", "value", "pid", "order", "code", "id", "json", "Key", "check", "qi", "root", "patch", "temp", "phrase", "nice", "sum", "trust", "prefix", "ip", "connection", "char", "q", "change", "pair", "k", "base", "match", "KEY", "text", "mac", "entry", "cert", "fix", "index", "token", "link", "ace"], "_sout": ["_Sin", "_sbOut", "_sein", "_seio", "_sio", "_Sout", "_sbout", "_sbio", "_seout", "_sOut", "_seOut", "_sin", "_sbin", "_Sio", "_SOut"], "_sinp": ["_inp", "_sinpc", "_sinb", "_siner", "_diser", "_dispc", "_srpc", "_inb", "_disp", "_srp", "_disb", "_srb", "_inpc", "_srer", "_iner"], "seed": ["finger", "data", "name", "scale", "char", "digit", "slice", "dd", "theme", "sudo", "sample", "shift", "kh", "zip", "root", "shape", "password", "random", "parser", "address", "ruby", "secret", "test", "row", "kid", "source", "feed", "cookie", "driver", "serial", "pattern", "prime", "sum", "delay", "shadow", "id", "folder", "index", "black", "eed", "sha", "token", "input", "host", "pad", "grain", "sql", "pick", "sleep", "slave", "json", "string", "username"], "rand": ["rh", "reg", "grad", "range", "dev", "NG", "min", "gen", "bot", "rc", "ind", "sample", "roll", "user", "win", "cr", "r", "max", "gram", "dist", "random", "dr", "go", "rr", "Rand", "chain", "der", " random", "next", "round", "bird", "ng", "id", "rar", "nd", "pick", "who", "draw", "re", "start"], "hex": ["lock", "iter", "digit", "rex", "div", "letter", "loop", "shift", "kh", "sex", "pex", "cookie", "wh", "chain", "sha", "lit", "pad", "exp", "length", "rh", "alph", "ph", "zip", "mix", "secret", "row", "pack", "closure", "cross", "pattern", "code", "oct", "id", "json", "x", "loc", "tri", "scale", "quant", "check", "temp", "cmp", "serial", "form", "sum", "raw", "transform", "auth", "cube", "ip", "bin", "char", "batch", "buff", "hess", "ex", "box", "text", "num", "ch", "cf", "ticket", "view", "shadow", "index", "token", "alpha", "string"], "pass": ["lock", "login", "ride", "session", "oss", "press", "handle", "allow", "task", "worker", "gen", "proc", "Pass", "mail", "Password", "line", "password", "secret", "test", "step", "parse", "run", "service", "feed", "process", "PASS", "path", "cross", "ass", "sign", "code", "oct", "post", "read", "route", "fix", "ress", "prefix", "flash", "rss", "fail", "ss", "skip", "push", "auth", "report", "access", "strip", "act"], "md5": [" md\t", "sha512", "md2", "sha5", "MD7", "md85", " MD\t", "mand5", "mandody", "mand3", " md3", " md4", "md\t", "sha4", " md\n", "sha3", "MD4", "MD5", " md512", "ma5", "MD85", "sha2", "MD512", "md512", "mand2", "MD\n", " MD\n", "ma4", " md2", "ma85", "MD2", " mdody", "md\n", "md4", "ma2", "mdody", "md7", " md7", " md85", "md3", "sha7", "MDody", "MD\t", "MD3"], "hash": ["rh", "lock", "alt", "ha", "hed", "version", "base", "dig", "html", "cache", "text", "kh", "her", "mac", "password", "ruby", "secret", "block", "build", "db", "h", "url", "sum", "code", "id", "sha", "header", "ash", "host", "auth", "addr", "string"], "banner": ["binorer", "warnnel", "banker", "binner", "banler", "ironning", "bannet", "annnet", "banning", "banorer", "Bannel", "warnler", "warnker", "blueker", "ironnet", "plannet", "Bann", "banners", "Banner", "planners", "blueler", "Banorer", "Banning", "bann", "binn", "binning", "bluenel", "planner", "bluener", "annners", "plann", "annning", "Banler", "annner", "bannel", "warnner", "ironner", "planning", "Banker", "planorer", "ironners"], "txt": ["cb", "ext", "elt", "data", "tin", "git", "ff", "email", "wd", "gold", "pdf", "tty", "info", "buff", "gz", "str", "xml", "bot", "fb", "text", "bytes", "img", "zip", "lines", "parser", "utt", "xt", "test", "xxx", "vt", "Text", "js", "struct", "notes", "pty", "hea", "config", "rpm", "thin", "details", "flat", "file", "rx", "np", "rss", "kt", "TEXT", "diff", "qt", "htm", "json", "tx", "obj", " text", "buf", "tmp"], "sname": ["nsnamed", "vesnames", "snames", "asnames", "sdata", "nsnames", " sName", "esname", " snamed", "vesnamed", "asnamed", "snamed", "sName", "esnames", "asname", " snames", "esName", "esnamed", "vesName", "nsdata", " sdata", "asdata", "vesname", "nsname"], "spass": ["espad", "Spass", "Spasses", "aspash", "aspasses", "SPasses", "slass", "splash", "espash", "SPass", "sloss", "spill", "spasses", "SPill", "aspass", "aspad", "espasses", "Sposs", "Spill", "slasses", "sposs", "spash", "splad", "splass", "splasses", "spad", "SPoss", "espass", "slill"], "sseed": [" spassword", "ssslave", "dentry", "submitseed", "dpassword", "gsgrain", "pssecret", "symgrain", "submittoken", "symseed", "sslave", "dtoken", "Skey", "psslave", "pslave", "Sgrain", "sssecret", "symkey", "skey", "sgrain", "sroot", "spassword", "gsseed", "submitpassword", "symeed", "gseed", "psseed", "Sseed", "psroot", "Seed", "stoken", "ssseed", "dseed", "ssecret", " stoken", "gskey", "psecret", "sentry", "proot", "ssroot", "submitentry", "pseed", " sentry"], "items": ["ids", "pages", "values", "data", "images", "rows", "cats", "articles", "groups", "phones", "results", "events", "ips", "xml", "units", "cells", "models", "abs", "files", "bits", "bytes", "parts", "members", "apps", "ops", "flows", "posts", "lines", "orders", "pins", "pieces", "rooms", "owners", "js", "loads", "objects", "qs", "names", "lists", "styles", "boxes", "keys", "photos", "ants", "params", "locks", "links", "Items", "projects", "item", "opens", "plugins", "ends"]}}
{"id1": "3558512", "id2": "14168494", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"serialize": ["normalized", "erialize", "Serialized", "normalify", "serialify", "normalze", "erializable", "serialze", "finalze", "Serialze", "finalify", "normalize", "serialized", "erialze", "Serialize", "Serializable", " serialze", " serializable", "erialization", "Serialify", "finalize", "Serialization", "finalized", "serializable", "serialization", " serialization"], "out": ["bin", "data", "name", "pool", "archive", "ex", "outs", "gen", "dump", "copy", "page", "conn", "w", "loader", "output", "cache", "content", "writer", "err", "o", "client", "OUT", "temp", "buffer", "i", "source", "image", "png", "parent", "filename", "exec", "raw", "server", "io", "file", "up", "a", "report", "Out", "string", "obj"], "parser": ["reader", "Parser", "er", "lp", "manager", "master", "handler", "pillar", "worker", "seed", "p", "xml", "arser", "per", "base", "class", "plugin", "copy", "cache", "loader", "instance", "wrapper", "txt", "writer", "pp", "test", "parse", "tt", "builder", "parent", "system", "server", "pe", "file", "as", "up", "php", "rar", "upload", "ss", "cp", "processor", "pkg"], "on_disk": ["onnetdrive", "onbootdisk", "onnetspace", "on_demand", "onbookdisk", "onJdrive", "onbootlock", "on_storage", "off_file", "off_demand", "on_space", "on_file", "off_space", "onbootstorage", "onbookdelete", "onJlock", "onbookdrive", "off_lock", "onJdemand", "onnetfile", "onjdrive", "onJdisk", "onjfile", "onjspace", "on_lock", "onbootdrive", "off_disk", "on_delete", "off_drive", "onnetdisk", "off_delete", "on_drive", "off_storage", "onjdisk", "onnetdemand"], "in": ["reader", "bin", "connection", "login", "f", "data", "socket", "inas", "ins", "pin", "stream", "info", "min", "In", "kin", "copy", "conn", "inner", "again", "rin", "win", "din", "r", "IN", "ax", "o", "ini", "i", "source", "inc", "pass", "thin", "inn", "c", "file", "as", "lin", "input", "con", "ac"]}}
{"id1": "13852596", "id2": "21608109", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public static boolean loadContentFromURL(String fromURL, String toFile) {\n        try {\n            URL url = new URL(\"http://bible-desktop.com/xml\" + fromURL);\n            File file = new File(toFile);\n            URLConnection ucon = url.openConnection();\n            InputStream is = ucon.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            ByteArrayBuffer baf = new ByteArrayBuffer(50);\n            int current = 0;\n            while ((current = bis.read()) != -1) {\n                baf.append((byte) current);\n            }\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baf.toByteArray());\n            fos.close();\n        } catch (IOException e) {\n            Log.e(TAG, e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"execute": ["create", "handle", "ute", "install", "load", "copy", "register", "all", "evaluate", "Exec", "test", "call", "parse", "run", "submit", "process", "exec", "transfer", "code", "server", " perform", " invoke", "report", "invoke", "start", "apply"], "resources": ["ids", "pages", "thumbnails", "images", "maps", "issues", "groups", "services", "results", "events", "relations", "works", "cells", "items", "models", "Resources", "files", "features", "roots", "stores", "apps", "workers", "flows", "writers", "strings", "scripts", "chains", "rates", "archives", "rings", "stars", "objects", "classes", "ions", "series", "locks", "params", "users", "projects", "resource", "rules", "reports", "types", "plugins"], "i": ["f", "si", "ti", "ri", "iri", "s", "ori", "j", "info", "pi", "p", "k", "ie", "is", "hi", "bi", "di", "I", "u", "multi", "ami", "qi", "l", "e", "o", "ini", "abi", "cli", "ci", "we", "h", "xi", "oi", "v", "ui", "li", "ir", "uri", "ani", "ii", "io", "id", "iu", "mu", "vi", "ic", "eni", "gi", "ai", "phi", "esi", "ip", "wei", "isi"], "classFile": ["ClassFILE", "finalUrl", "ClassPath", "fileDirectory", "ruleFiles", "CLASSEntry", "ClassEntry", "connectionStream", "finalFile", "finalfile", "Classfile", "classClass", " classFactory", "classFilename", "sessionEntry", "CLASSImage", "classfile", " classFiles", "serviceFile", "ClassClass", " classfile", "ClassDir", "classFILE", "fileFiles", "customEntry", "ClassFiles", "lassGlobal", " classPage", "classFactory", "sessionFactory", "sessionFile", "lassClass", "ClassLine", "baseFile", "ClassPage", "CLASSFile", "classLine", "ruleFile", "staticfile", "ClassFactory", "sessionFiles", "lassFile", "classPath", "connectionFiles", "classFiles", "packEntry", " classStream", "customFiles", "classImage", "servicefile", "classEntry", "packfile", " classGlobal", "CLASSFILE", "sessionfile", "basefile", "ClassStream", " classFILE", "classStream", "classesFiles", "classLoader", "CLASSUrl", " classFilename", "classesFile", " classClass", "ClassImage", "CLASSfile", "ClassFile", "ClassGlobal", "objectDir", "fileImage", "CLASSLoader", "ClassFilename", "objectFile", "lassFiles", "objectfile", "baseFILE", "CLASSFiles", "CLASSDirectory", " classLine", "ruleFilename", " classLoader", " classPath", "baseUrl", "packFile", "customFILE", "ClassDirectory", "CLASSLine", "fileLine", "finalFILE", "customFile", "CLASSPage", "staticLine", "staticFile", "classPage", "connectionfile", "serviceLine", "staticFILE", "classDirectory", " classDir", "ruleLine", "classesfile", "serviceFILE", "sessionFILE", "classesPath", "fileLoader", "fileFile", "classDir", "connectionFile", " classEntry", "classGlobal", "objectFiles", "packFILE", "filefile", "classUrl"], "inputStream": ["binaryFile", "inputFile", "childstream", " inputstream", "inputSteam", "InputSw", "outputReader", "uploadFile", "outputFile", "initStream", "binaryStream", "initSteam", "outputSw", "childStream", "InputStream", " inputReader", "InputStreamer", "rawStreamer", "inputSw", "inputContext", "binaryStreamer", "outputStreamer", "binarySteam", "uploadSw", "inputStreamer", "childContext", " inputStreamer", "outputContext", "activeStreamer", "childReader", "rawStream", "rawSteam", " inputFile", "uploadStream", "importStream", "activestream", "activeStream", "initstream", "Inputstream", "InputFile", "uploadstream", "importSteam", " inputContext", "outputSteam", "rawFile", "initStreamer", "activeSteam", "InputSteam", "inputstream", "importstream", " inputSteam", "inputReader", "outputstream", "importStreamer"], "reader": ["iter", "er", "director", "manager", "ri", "handler", "book", "worker", "seed", "stream", "sync", "layer", "shared", "ger", "arser", "per", "rc", "copy", "keeper", "inner", "loader", "wrapper", "rer", "parser", "writers", "client", "key", "dr", "rr", "row", "buffer", "source", "ner", "entry", "oder", "war", "builder", "driver", "or", "request", "reflect", "system", "context", "reading", "read", "server", "author", "io", "owner", "http", "draft", "rar", "right", "resource", "input", "riter", "report", "re", "Writer", "ler", "ee", "Reader", "editor", "rx"], "oldSize": ["OldName", "oldName", "prevLength", "oldSc", "OldSize", "oldLength", "prevName", "prevSize", "OldSc", " oldLength", " oldName", "prevSc", " oldSc", "OldLength"], "writer": ["iter", "er", "director", "data", "manager", "widget", "handler", "writ", "worker", "creator", "string", "winner", "dc", "format", "maker", "writing", "w", "loader", "wrapper", "inner", "walker", "her", "r", "engine", "e", "parser", "writers", "row", "buffer", "ner", "service", "player", "oder", "war", "child", "builder", "driver", "write", "rw", "object", "document", "read", "author", "io", "element", "wr", "wire", "draft", "wer", "word", "index", "written", "resource", "token", "riter", "report", "Writer", "ler", "ee", "Reader", "editor"], "b": ["be", "abc", "bin", "bd", "f", "g", "m", "boot", "p", "k", "eb", "binary", "base", "bb", "u", "B", "w", "br", "l", "r", "e", "rb", "buffer", "d", "bar", "emb", "db", "lb", "ba", "h", "object", "null", "ab", "c", "a", "orb", "fb", "pb", "ob"], "outputStream": ["inputSteam", "outstream", "OutputSteam", "dataContainer", "protectedStreamer", "dataStream", " outputView", "outStream", "OutputStreamer", "protectedStream", "inputContainer", "outSteam", "dataStreamer", "inputView", "OutputStream", "outputStreamer", "Outputstream", "inputStreamer", " outputstream", "outStreamer", "protectedstream", "protectedSteam", " outputContainer", " outputSteam", "outputSteam", "outputView", "dataSteam", "inputstream", " outputStreamer", "outputstream", "outputContainer", "OutputView"], "injectedClasses": ["injectionclassies", "injectionClasses", "injectedWritites", "injectedclassites", "injectionClassites", "injectedClassies", "injectedClassites", "injectedProjecties", "injectedWrits", "injectedclasss", "injectionclasss", "injectedProjectes", "injectionClasss", "injectedProjects", "injectedWrites", "injectedWrities", "injectedClasss", "injectionclasses", "injectedProjectites", "injectionclassites", "injectionClassies", "injectedclassies", "injectedclasses"], "newSize": ["NewLength", "NewSize", "newFontSize", "finalLength", " newLength", " newFontSize", "NewFontSize", "finalSize", "newStorage", "finalFontSize", "NewStorage", "newLength", "finalStorage", " newStorage"]}}
{"id1": "5607440", "id2": "18097962", "code1": "    public void updateShoppingBean(String userId) {\n        Connection connection = null;\n        PreparedStatement preparedStatement1 = null;\n        PreparedStatement preparedStatement2 = null;\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            connection = DriverManager.getConnection(this.jdbcURL);\n            connection.setAutoCommit(false);\n            String preparedQuery = \"INSERT INTO dbComputerShopping.order(name,product_id,quantity,date,status)VALUES(?,?,?,?,?)\";\n            preparedStatement1 = connection.prepareStatement(preparedQuery);\n            Date date = new Date();\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            String orderDate = format.format(date);\n            Iterator iterator = this.cart.iterator();\n            Object[] shoppingInfo = null;\n            while (iterator.hasNext()) {\n                shoppingInfo = (Object[]) iterator.next();\n                ProductBean product = (ProductBean) shoppingInfo[0];\n                int quantity = (Integer) shoppingInfo[1];\n                preparedStatement1.setString(1, userId);\n                preparedStatement1.setInt(2, product.getId());\n                preparedStatement1.setInt(3, quantity);\n                preparedStatement1.setString(4, orderDate);\n                preparedStatement1.setString(5, \"confirmed\");\n                preparedStatement1.executeUpdate();\n            }\n            Object[] cartInfo = null;\n            preparedQuery = \"UPDATE components SET quantity=quantity-? WHERE comp_id=?\";\n            preparedStatement2 = connection.prepareStatement(preparedQuery);\n            for (Iterator i = this.cart.iterator(); i.hasNext(); ) {\n                cartInfo = (Object[]) i.next();\n                ProductBean product = (ProductBean) cartInfo[0];\n                int quantity = (Integer) cartInfo[1];\n                ProductListBean productList = new ProductListBean(jdbcURL);\n                ArrayList components = productList.getComponents(product.getId());\n                for (Iterator j = components.iterator(); j.hasNext(); ) {\n                    ComponentBean component = (ComponentBean) j.next();\n                    preparedStatement2.setInt(1, quantity);\n                    preparedStatement2.setInt(2, component.getId());\n                    preparedStatement2.executeUpdate();\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n            }\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement1.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement2.close();\n            } catch (SQLException ex) {\n            }\n        }\n    }\n", "code2": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "label": 0, "substitutes": {"updateShoppingBean": ["updateShoppingBoan", "updateShoppingBan", "updateShippingBeAN", "updateShoppingBans", "updateShoppingBeAN", "updateShoppingBeans", "updateShippingBean", "updateShoppingBoAN", "updateShoppingBoans", "updateShippingBeaning", "updateShippingBeans", "updateShippingBAN", "updateShoppingBeaning", "updateShippingBan", "updateShoppingBaning", "updateShoppingBAN", "updateShoppingBEAN", "updateShoppingBoaning", "updateShoppingBEan", "updateShoppingBEans", "updateShippingBans", "updateShoppingBEaning", "updateShippingBaning"], "userId": ["clientName", "userName", "userData", " userPath", " userName", "clientData", " userType", "clientId", "UserType", "clientPath", "userPath", " userID", "clientID", " userData", "userID", "UserId", "UserPath", "UserData", "UserName", "userType", "clientType", "UserID"], "connection": ["lock", "statement", "data", "name", "manager", "machine", "channel", "pool", "container", "session", "database", "BC", "table", "handler", "application", "state", "class", "log", "conn", "cache", "section", " Connection", "engine", "writer", "collection", "query", "client", "subject", "service", "connected", "condition", "db", "connect", "driver", "ion", "context", "general", "config", "document", "relation", "server", "c", "function", "management", "index", "result", "resource", "con", "directory", "sql", "Connection", "communication", "bc", "graph"], "preparedStatement1": ["preparedDocumentB", "preparedComment1", "preparedstatement01", "preparedDatabase2", "preasterObject01", "preakedQuery1", "preparedCommentl", "preakedQuery4", "preppedStatement1", "preparedContextone", "preparedMaterial1", "preparedEvent01", "preparedContext4", "preparedDocumentn", "preparedMaterial17", "preasterObject1001", "prearedSession0", "preparedStruct31", "preparedQueryl", "preparedComment1001", "preparedSession1", "preparedStatone", "preparedContext31", "preparedDatabase4", "preparedState1", "preparedStatement0", "preppedStatement3", "prefixedStruct0", "preakedQuery2", "preparedMaterial2", "prearedStatement1", "preculatedStatement01", "prearedSession1", "preuredStat4", "preasterObjectone", "preppedStatl", "preparedQuery4", "preparedTransaction9", "preparedSessionB", "preparedDatabase17", "preparedCommentone", "preuredStat1", "preferredQuery17", "prefixedStruct31", "preparedObject01", "preculatedStatement1", "preparedStatementone", "preparedstatement1", "preferredStatement2", "prefixedStatement0", "preppedStat3", "preparedSession2", "preparedStat3", "preparedDocument1", "preparedDocument2", "prefixedStatement9", "preparedstatementone", "preasterStatementone", "preparedQuery3", "preuredStatement4", "preparedComment3", "prearedStatementB", "prearedStatement2", "preparedQueryn", "preparedStatement3", "preparedQuery1", "prearedSession2", "preasterStatement01", "preparedDocumentone", "preakedQueryn", "preakedStatement2", "preppedStatementl", "preparedStruct9", "preparedSession0", "preparedStatement1001", "prefixedStruct9", "preparedState9", "preparedStatementB", "prefixedStatement1", "preparedstatement1001", "preuredStat31", "preasterObject1", "preparedEvent1", "prefixedStatement31", "preparedDatabasen", "preculatedEvent01", "preparedStatement31", "preparedStat31", "preparedQuery17", "preparedStatement17", "preparedObject1001", "preasterStatement1001", "preparedTransaction0", "preppedStat1", "preakedStatementn", "preparedObjectone", "preparedStatement4", "preparedTransaction31", "preparedStat1", "preparedStat4", "preuredStatone", "preparedStruct0", "preparedObject1", "preparedDocument4", "preparedStatementl", "preuredStatement1", "preparedDatabase1", "preuredStatement31", "preferredQuery2", "preparedStatement9", "prearedSessionB", "preferredStatement1", "preparedStatl", "preakedStatement1", "preparedStatement01", "preparedComment01", "preparedState31", "preasterStatement1", "preparedContext1", "preparedDocument0", "preakedStatement4", "preparedQuery2", "preparedQueryB", "preparedState0", "prearedStatement0", "preferredQuery1", "preparedDocument31", "preparedTransaction1", "preparedStatementn", "preparedStruct1", "prefixedStruct1", "preparedState01", "preferredStatement17", "preuredStatementone", "preparedQuery0", "preculatedEvent1"], "preparedStatement2": ["preparedSession52", "preparedStatement404", "preparedResult2", "prearedStatement1", "preuredstatementtwo", "preparedstatement404", "prearedSession1", "preparedConfiguration2", "prearedSession52", "preparedSession0", "preparedstatement8", "preparedStatement52", "preparedScopetwo", "preparedResult1", "preparedConfiguration52", "preparedScope404", "preuredStatementtwo", "preparedScope2", "preparedstatement2", "preparedCondition8", "prearedStatement0", "prearedSession0", "prearedStatement52", "preuredStatement8", "preuredstatement8", "preuredstatement2", "preparedStatementtwo", "preparedSession1", "preparedResult0", "preuredStatement2", "preparedSession2", "preparedConfiguration1", "prearedSession2", "preparedScope8", "preparedCondition404", "preuredstatement404", "preparedStatement0", "preparedCondition2", "preparedStatement8", "prearedStatement2", "preparedConfiguration0", "preparedResult52", "preuredStatement404", "preparedConditiontwo", "preparedstatementtwo"], "preparedQuery": ["previsedquery", "PreparedQuery", "preplannedquery", "perparedStatement", "precedStatement", "precedquery", "perparedquery", "PrearedQu", "Preparedquery", "prearedStatement", "PreppedStatement", "previsedStatement", "prevertedBody", "PrearedFunction", "PreparedStatement", "preppedQu", "PrearedQuery", "Preppedquery", "prevertedFunction", "prearedInfo", "preplannedCommand", "preppedBody", "preppedquery", "prevertedQu", "prearedCommand", "PreppedQuery", "PreparedInfo", "prearedQuery", "preparedBody", "perparedBody", "preparedInfo", "PreppedQu", "preplannedQuery", "perparedQuery", "prearedquery", "PrearedInfo", "perppedBody", "previsedBody", "PreparedFunction", "preculatedQuery", "PreparedQu", "precedCommand", "prevertedquery", "perparedCommand", "perppedquery", "perppedQuery", "peraredCommand", "precedQuery", "perppedStatement", "preculatedInfo", "preparedFunction", "prearedQu", "prevertedStatement", "preppedQuery", "preparedquery", "preparedQu", "peraredStatement", "peraredquery", "previsedQuery", "prevertedQuery", "preparedStatement", "prearedFunction", "previsedQu", "preculatedFunction", "preplannedStatement", "preculatedQu", "peraredQuery", "preparedCommand", "preppedStatement", "prevertedInfo"], "date": ["open", "tag", "data", "name", "version", "complete", "type", "change", "event", "grade", "set", "status", "log", "match", "model", "Date", "time", "year", "bug", "d", "style", "db", "use", "order", "form", "stage", "age", "update", "number", "document", "rate", "duration", "ate", "file", "index", "module", "message", "resource", "dat", "record", "day", "string", "start", "month", "dt"], "format": [" formatted", "data", "name", " formatting", "scale", "pretty", "point", "at", "handler", "type", "handle", "table", "method", "filter", "info", "printf", "str", " fmt", "set", "letter", "class", "sort", "add", "html", "wrap", "part", "time", "term", "writer", "and", "export", "dot", "parser", "atter", " Format", "parse", "style", "value", "process", "struct", "pattern", "form", "prep", "unit", "Format", "split", "transform", "function", "prefix", "cut", "join", "replace", "report", "print", "string"], "orderDate": ["OrderTime", "serverdate", "OrderName", "orderDat", " orderData", "OrderDate", "OrderData", "requestDate", " orderDat", " orderdate", "orderName", "orderTime", "orderDay", " orderDay", "serverData", "orderdate", " orderTime", "serverDate", "requestDay", "OrderDay", "requestName", "requestDat", " orderName", "orderData", "serverTime", "Orderdate", "OrderDat"], "iterator": ["reader", "iter", "er", "sequence", "it", "ator", "gener", "vector", "later", "runners", "database", "started", "slice", "creator", "atio", "stream", "ident", "set", "ie", "adder", "ater", "loop", "inner", "instance", "walker", "loader", "ators", "former", "until", "done", "engine", "writer", "collection", "parser", "random", "ter", "pointer", "step", "entry", "interstitial", "storage", "init", "starter", "driver", "oper", "outer", "path", "choice", "wrapper", "context", "enter", "uri", "server", "finder", "metadata", "runner", "Iterator", "series", "consider", "Iter", "river", "holder", "timer", "header", "inter", "append", "you", "processor", "start", "selection", "ski"], "shoppingInfo": ["shppingInfo", "shoutingInfo", "swoppingArea", "shoppingINFO", "hoppingMeta", "swopingInfo", "shppingMeta", "shoutingInf", "swoppingInf", "shoutingINFO", "hillingId", "shoppingInf", "shoppingData", "shopingArea", "shillingArea", "shillinginfo", "shopingInf", "shppingInf", "shopingMeta", "shillingMeta", "hoppingInfo", "hillinginfo", "swopingObj", "swoppingInfo", "shillingInf", "shoppingObj", "shoppinginfo", "hoppingInf", "shoppingArea", "shippingInf", "hillingInfo", "shillingInfo", "shppinginfo", "shoppingId", "shashingId", "shppingArea", "hillingMeta", "shillingData", "hoppingId", "swoppingObj", "shppingObj", "shippingInfo", "ShoppingInf", "hoppinginfo", "shillingObj", "hillingData", "shopingData", "shashingInfo", "shopingObj", "swopingInf", "hoppingData", "shashingInf", "shppingId", "shillingINFO", "ShippingINFO", "ShippingInf", "shillingId", "ShippingInfo", "shppingData", "hillingInf", "swopingArea", "shoppingMeta", "ShoppingInfo", "ShoppingINFO", "shopingInfo", "shippingINFO", "shashinginfo"], "product": ["feature", "data", "version", "type", "creator", "filter", "p", "Product", "per", "class", "plugin", "copy", "model", "position", "seller", "user", "output", "collection", "client", "pp", "payment", "service", "source", "image", "child", "production", "project", "process", "parent", "object", "band", "order", "property", "attribute", "products", "config", "relation", "pe", "cart", "module", "result", "resource", "contact", "target", "input", "company", "processor"], "quantity": ["compification", "necessification", "quantification", "primITY", "compance", "authority", "necessifier", "necessity", "quantality", "quantance", "mentality", "commentality", "compality", "primality", "authorance", "aquicity", "authorality", "quantifier", "primification", "quanticity", "compity", "aquality", "aquity", "compifier", "authoricity", "primity", "mentITY", "quantITY", "mentity", "commentifier", "primation", "quantation", "commentity", "compicity", "commentITY", "compation", "primifier", "necessation", "mentifier", "aquance"], "cartInfo": ["cartMeta", " cartList", " cartMeta", " cartSize", "frontInf", "cartList", "productSize", "contactList", "frontInfo", "cartData", " cartObj", "productInfo", "contactInf", " cartStyle", "cartObj", "carInf", "contactInfo", "carInfo", "productData", " cartData", "frontStyle", "carMeta", "cartStyle", "carSize", "cartSize", "cartInf", " cartInf", "productObj", "productInf", "carStyle", "carObj", "frontMeta", "contactData", "frontObj"], "i": ["f", "si", "it", "ri", "info", "p", "pi", "ori", "ie", "is", "hi", "I", "di", "bi", "ami", "multi", "qi", "l", "e", "ini", "abi", "list", "cli", "ci", "init", "api", "xi", "v", "oi", "ui", "n", "uri", "li", "ani", "ii", "io", "c", "id", "index", "iu", "ic", "chi", "vi", "ai", "ati", "phi", "ip"], "productList": ["pageArray", "resourceList", "productArray", "configCollection", "productGroup", "cartList", " productlist", "resourceCollection", "configList", "pagelist", "resourcelist", " productArray", "pageGroup", "productlist", "productSet", "pageList", "productCollection", "cartlist", " productCollection", " productSet", " productGroup", "configSet", "resourceSet", "cartGroup", "configlist", "cartArray"], "components": [" complements", "commonents", "depients", "suppositories", "productarts", " compositories", "cproducts", "productategories", "comonents", "compenses", "compients", "commositories", "supponents", "comositories", "complements", "comlements", "productonents", "parts", "supplements", "depositories", "compositories", "compproducts", "compategories", "comenses", "suppenses", "comparts", "deponent", "categories", "comonent", "conents", "commients", "commonent", "carts", "ponents", "pategories", "comients", "productproducts", "pproducts", "deponents", " compenses"], "j": ["ji", "ij", "er", "f", "jj", "bj", "_", "where", "database", "p", "k", "ie", "add", "jp", "b", "all", "r", "l", "query", "o", "jc", "this", "z", "js", "J", "Select", "v", "other", " ii", "update", "config", "url", "n", "jo", "index", "id", "Config", "adj", "sql", "Insert", "area", "obj", "Query"]}}
{"id1": "17190057", "id2": "18211588", "code1": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"encode": ["unode", "Enescape", "Encode", "unescape", "encescape", "uncode", "Enode", "enccode", "enescape", "enode"], "input": ["reader", "inf", "data", "addin", "audio", "secure", "stream", "string", "array", "str", "hex", "binary", "ssl", "format", "text", "output", "instance", "img", "plus", "password", "address", "temp", "this", "buffer", "xxx", "source", "i", "image", "crypt", "request", "pattern", "form", "context", "config", "raw", "empty", "null", "in", "prefix", "amp", "result", "def", "alpha", "Input"], "NoSuchAlgorithmException": ["NoSuchAlodingError", "NoSuchEdgorithmWarning", "NoSuchEdgorithmException", "NoSuchEdryptionError", "NoSuchAlgoement", "NoSuchAlryptionWarning", "NoSuchAlodingException", "NoSuchAlgorithmement", "NoSuchAlgorithmError", "NoSuchEdgorithmError", "NoSuchAlryptionement", "NoSuchAlodingWarning", "NoSuchAlryptionException", "NoSuchAlgorithmWarning", "NoSuchAlgoWarning", "NoSuchEdgorithmement", "NoSuchAlgoException", "NoSuchEdryptionException", "NoSuchAlgoError", "NoSuchEdryptionement", "NoSuchEdryptionWarning", "NoSuchAlodingement", "NoSuchAlryptionError"], "md": ["meta", "df", "bd", "doc", "mag", "cd", "wd", "mad", "dd", "m", "ma", " MD", "mt", "me", "dig", "mb", "mac", "cmd", "zip", "dm", "key", "um", "dc", "d", "MD", "db", "mo", "mod", "hash", "amd", "mi", "sum", "mp", "code", "metadata", "mm", "pm", "message", "sha", "mc", "ms", "pd", "mand", "ad", "hd", "od", "nm"]}}
{"id1": "20426057", "id2": "8320469", "code1": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 0, "substitutes": {"createKeyStore": ["createkeystore", "createKeystore", "getKeyFactory", "getKeystore", "getkeystore", "createTrustChain", "createTrustFactory", "createSecretChain", "createKeyFactory", "createTrustStore", "createTruststore", "createkeyStore", "createSecretstore", "getKeyChain", "getkeyChain", "createkeyFactory", "createKeyChain", "createkeyChain", "createSecretFactory", "getkeyFactory", "createSecretStore", "getkeyStore", "getKeyStore"], "url": ["connection", "sl", "lib", "f", "loc", "data", "manager", "org", "email", "gl", "el", "stream", "str", "xml", "log", "ssl", "base", "ll", "class", "page", "html", "text", "loader", "zip", "l", "plus", "key", "client", "address", "Url", "proxy", "URL", "source", "entry", "image", "feed", "api", "buffer", "service", "path", "db", "filename", "config", "store", "uri", "server", "http", "file", "id", "src", "resource", "www", "coll", "host", "ref", "location", " URL", "string", "ob"], "password": ["wallet", "data", "name", "channel", "wd", "press", "seed", "language", "array", "p", "words", "Password", "alias", "work", "key", "patch", "address", "column", "secret", "crypt", "padding", "fax", " passwords", "sword", "api", "phrase", "path", "hash", "pattern", "PASS", "attribute", "pass", "params", "word", "prefix", "token", "help", "pad", "auth", "string", "username"], "keystore": ["kcache", "keybase", "Keystorage", " keyStore", "signstorage", "kstore", "keyspace", " keyspace", "webStore", " keybase", "keycache", " keycache", "kbase", "keyStore", "signtool", "truststore", "keystorage", "lockstorage", "truststorage", "trustspace", "lockspace", "trustbase", " keytool", "kserver", "webstore", " keyserver", "signstore", "webstorage", "lockbase", "KeyStore", "lockstore", "Keycache", "Keyserver", "keyserver", "kStore", "Keystore", "Keybase", "webserver", "Keytool", " keystorage", "signbase", "keytool"]}}
{"id1": "18793482", "id2": "7425022", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"modifyApplicationMessage": ["modifyapplicationmessage", "modifyApplicationMsg", "modifyApplicationContent", "modifiedApplicationMessage", "modifyAppContent", "modifiedapplicationMessage", "modifyapplicationContent", "modifiedApplicationContent", "modifiedApplicationMsg", "modifyExternalMessage", "modifyapplicationMessage", "modifiedapplicationContent", "modifyExternalmessage", "modifyAppMsg", "modifyapplicationMsg", "modifyExternalMsg", "modifiedapplicationMsg", "modifiedapplicationmessage", "modifyExternalContent", "modifiedApplicationmessage", "modifyApplicationmessage", "modifyAppmessage", "modifyAppMessage"], "locale": ["localales", "locationale", "localALE", "placeame", "localue", "localame", "locame", "localator", "locator", "localale", "placeALE", "locales", "Locator", " locator", "locue", "Locales", "Locame", "locationales", " locame", "LocALE", "Locale", "placeales", "placeale", "locationue", " locales", "Locue", "locALE", "locationALE"], "messageName": ["reasonValue", "msgKey", "phraseType", "MessageKey", "messagename", "MessageValue", "msgName", " messagename", "msgType", "reasonname", "MessageName", "MessageType", "Messagename", "messageType", "phraseValue", "reasonType", "msgValue", "reasonName", "phraseKey", "messageKey", " messageType", " messageKey", "phraseName"], "messageValue": ["messageVal", " messageVal", "MessageValue", "msgName", "MessageVal", "msgType", "MessageName", "MessageType", "responseName", "responseVal", "messageType", "msgValue", "responseType", "msgVal", " messageType", "responseValue"], "properties": ["prop", "Property", "data", "options", "py", "perties", "settings", "ips", "xml", "Pro", "conf", "txt", "ops", " props", "api", "stats", " Properties", "property", "config", "ps", "metadata", "params", "pro", "resources", "json", "obj", "pb", "tmp"], "i18nPath": ["i11fCorp", "i32ninUrl", "i18fUrl", "i18nFile", "i18napath", "i18nsFile", "i18onLocation", "i18bStr", "i32nUrl", "i18bPart", "i32nPath", "i18nepath", "i18nStr", "i18fPath", "i18onPath", "i18ninUrl", "i16npath", "i16nsPart", "i11fUrl", "i18npath", "i16nPath", "i11fPath", "i18ninFile", "i32ninPath", "i18nsPath", "i32ninFile", "i32ninLocation", "i18nsUrl", "i11npath", "i11fpath", "i18neUrl", "i18nsCorp", "i18ninPath", "i16nsStr", "i16nsPath", "i18nLocation", "i18bPath", "i18naPath", "i16nPart", "i11nUrl", "i18fCorp", "i18nsLocation", "i18onFile", "i18naStr", "i18nCorp", "i11nPath", "i18nePath", "i18nspath", "i18naPart", "i18onUrl", "i18nUrl", "i18fpath", "i18ninLocation", "i18nPart", "i18nsPart", "i16nspath", "i11nCorp", "i32nLocation", "i18bpath", "i18nsStr", "i16nStr", "i32nFile", "i18neCorp"], "englishFile": ["propertiesPath", "propertiesFile", "ianaJar", " englishJar", "Englishfile", "EnglishFolder", "EnglishPath", "EnglishFiles", " englishPath", "englishPath", "propertiesfile", "ianaFile", "EnglishFile", " englishfile", "languageJar", "ianaDir", "englishJar", "examplefile", "englishFiles", "englishfile", "examplePath", "exampleFolder", "languageFiles", " englishFiles", "englishDir", "ianaPath", "languagefile", "exampleFile", " englishDir", "languagePath", "propertiesFolder", "englishFolder", "languageDir", "languageFile"], "propertiesFilePath": ["propertiesFilesUrl", "propertiesFileName", "propertiesFilesName", "propertiesDirpath", "propertiesSourceFilePath", "propertiesSourceFileURL", "pertiesfileURL", "propertiesFileUrl", "propertiesDirUrl", "propertiesfilePath", "propertiesFileURL", "propertiesFilespath", "pertiesfilepath", "pertiesFilepath", "pertiesfileName", "propertiesfileName", "propertiesSourceFilepath", "propertiesSourceFileName", "pertiesDirName", "propertiesfileURL", "propertiesfilepath", "pertiesDirpath", "propertiesFilesPath", "propertiesFilesURL", "pertiesfilePath", "pertiesDirPath", "pertiesFileURL", "pertiesDirUrl", "propertiesDirPath", "propertiesfileUrl", "propertiesDirName", "pertiesFileName", "pertiesFileUrl", "propertiesFilepath", "pertiesFilePath"], "file": ["lock", "le", "data", "name", "book", "language", "field", "letter", "binary", "class", "format", "die", "b", "single", "buffer", "source", "ile", "path", "h", "property", "url", "function", "module", "message", "resource", "directory", "it", "File", "socket", "handler", "play", "stream", "fe", "log", "page", "entity", "content", "zip", "or", "parent", "up", "folder", "php", "word", "use", "reader", "f", "p", "one", "model", "part", "show", "http", "FILE", "fp", "full", "connection", "force", "application", "base", "future", "text", "files", "l", "child", "filename", "object", "unit", "pe", "string", "media"], "in": ["reader", "bin", "isin", "sin", "er", "f", "login", "into", "it", "ri", "s", "ins", "pin", "p", "cin", "In", "inside", "kin", "b", "inner", "again", "rin", "win", "l", "r", "din", "IN", "err", "plus", "ini", "d", "i", "init", "image", "inc", "nin", "or", "n", "io", "inn", "ic", "lin", "input", "con", "gin"], "out": ["full", "bin", "ext", "f", "socket", "error", "s", "sync", "to", "p", "ex", "outs", "one", "plain", "part", "w", "b", "output", "again", "inner", "by", "r", "work", "err", "and", "o", "OUT", "i", "lib", "cli", "image", "inc", "builder", "outer", "exec", "v", "n", "io", "net", "up", "word", "co", "ou", "home", "exp", "Out", "string", "write", "end"], "c": ["x", "abc", "cur", "arc", "f", "char", "sc", "C", "ct", "p", "dec", "cont", "k", "enc", "ec", "pc", "rc", "lc", "b", "w", "size", "cr", "l", "r", "o", "esc", "ice", "dc", "d", "i", "pointer", "ci", "cc", "ch", "t", "cf", "uc", "h", "xc", "v", "character", "cl", "code", "n", "cu", "ce", "a", "con", "ac", "col", "bc", "cy"], "is": ["iter", "ais", "Is", "iss", "get", "si", "it", "ri", "does", "s", "ins", "stream", "info", "has", "str", "os", "isa", "IS", "its", "i", "isu", "api", "bis", "ui", "ir", "ps", "ris", "as", "iso", "id", "are", "es", "res", "us", "ios", "re", "serv", "ib"], "breader": ["feedamer", "breadler", "breadr", "feediter", " cakeER", "brewr", " cakeler", " Breader", "weber", " breadler", " Breadler", " cakeer", "breadER", " breaders", "brewiter", "feedr", " breadER", " BreadER", "webiter", " Breaders", "breaders", "webamer", "webr", "feeder", "brewer", " cakeers", "breadamer", "breaditer", "brewamer"], "line": ["le", "sl", "data", "name", "side", "error", "lo", "el", "body", "sync", "one", "str", "definition", "letter", "log", "rule", "status", "base", "inline", "page", "part", "text", "lc", "model", "liner", "section", "l", "cell", "key", "lines", "lf", "row", "comment", "style", "parse", "block", "entry", "feed", "value", "Line", "response", "phrase", "band", "lined", "character", "url", "no", "next", "plugin", "li", "code", "pass", "nl", "split", "LINE", "word", "message", "frame", "lin", "header", "item", "link", "day", "string", "write", "ip", "end", "look", "strip"], "strBuilder": [" strBuffer", " strbuilder", "brbuilder", "strBlock", "stringbuilder", "brBuffer", "stringBuilder", "strBuilding", "StrBlock", "stringBuffer", "stringBuilding", "StrBuilding", "brBuilding", "StrBuild", "stringBuild", " strBuilding", "StrBuffer", "StrBuilder", "brBuild", "strbuilder", "strBuffer", " strBlock", "brBlock", " strBuild", "Strbuilder", "brBuilder", "strBuild"], "pieces": ["cuts", "pages", "vals", "values", "pots", "blocks", "sections", "nets", "tips", "piece", "phones", "groups", "services", "cards", "ips", "forms", "cells", "items", "words", "parts", "planes", "circle", "bits", "features", "bytes", "files", "ops", "flows", "apps", "lines", "steps", "letters", "strings", "pins", "places", "packs", "marks", "rings", "tops", "objects", "lists", "names", "styles", "boxes", "keys", "split", "seconds", "bones"], "found": ["full", "missing", "required", "matched", "f", "loaded", "true", "fixed", "fl", " Found", "made", "got", "first", "created", "successfully", "fall", "identified", "not", "filled", "used", "find", "given", "letter", "all", "successful", "built", "old", "left", "l", "val", "based", "err", "changed", "lost", "updated", "printed", "expected", "normal", "Found", "count", "defined", "temp", "finding", "null", "search", "valid", "still", "result", "sent", "failed", "confirmed", "broken"]}}
{"id1": "2834524", "id2": "2113444", "code1": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "code2": "    private VelocityEngine newVelocityEngine() {\n        VelocityEngine velocityEngine = null;\n        InputStream is = null;\n        try {\n            URL url = ClassPathUtils.getResource(VELOCITY_PROPS_FILE);\n            is = url.openStream();\n            Properties props = new Properties();\n            props.load(is);\n            velocityEngine = new VelocityEngine(props);\n            velocityEngine.init();\n        } catch (Exception e) {\n            throw new RuntimeException(\"can not find velocity props file, file=\" + VELOCITY_PROPS_FILE, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n        return velocityEngine;\n    }\n", "label": 0, "substitutes": {"write": ["save", "open", "create", "handle", "sync", "after", "download", "load", " rewrite", "check", "all", "output", "zip", "writer", "flush", "parse", "rite", "run", "process", "Write", "delete", "update", "post", "file", "println", "append", "out", "end"], "jarOut": ["JarOUT", "JarOutput", " jarIn", "JarCatalog", "serOut", "javaIn", "jarOutput", "sheetOutput", "tarOut", "Jarout", "sheetIn", "JarIn", "garOut", " jarout", "javaOutput", "serIn", "tarOutput", " jarOUT", "sheetOut", "jarout", "serout", " jarOutput", "garout", "jarCatalog", "jarOUT", "garIn", "sheetOUT", "JarOut", "javaOUT", " jarCatalog", "tarout", "tarOUT", "javaOut", "serOUT", "garOUT", "javaout", "javaCatalog", "jarIn"], "allEntries": ["allChrys", "Allentry", "allentories", "allEntrys", "AllEntrs", " allEntrys", " allEntories", "allEntrs", "allTrs", "allEntry", "allAddry", "allentry", " allEnties", "allTry", "allEnties", "allTries", "allTrys", "Allentrys", "allentrs", "allAddries", "allentries", "allEntories", "Allentrs", "AllEntry", "allChries", "AllEntrys", "allAddrys", "allChies", "allenties", "AllEntries", "Allentries", "allentrys", "allChories"], "iterator": ["reader", "iter", "er", "division", "ator", "gener", "basic", "later", "handler", "former", "started", "creator", "slice", "stream", "filter", "inst", "set", "ie", "loop", "keeper", "walker", "size", "loader", "inner", "ators", "section", "done", "instance", "query", "engine", "collection", "end", "parser", "ter", "list", "i", "entry", "step", "cmp", "init", "starter", "or", "outer", "oper", "order", "next", "uri", "finder", "Iterator", "consider", "river", "Iter", "eni", "running", "inter", "skip", "pie", "processor", "start", "heid", "now", "runner", "ski"], "jar": ["job", "jam", "er", "tag", "drop", "start", "mag", "archive", "container", "audio", "space", "binary", "base", "plugin", "ssl", "ski", "keeper", "tab", "magic", "zip", "ar", "bag", "docker", "zone", "bar", "entry", "image", "parse", "war", "pack", "cookie", "style", "url", "java", "config", "ser", "browser", "jo", "in", "file", "folder", "Jar", "module", "record", "dir", "json", "ler", "pod", "tar", "star", "sheet", "pkg"], "jarEntries": ["parseEntrs", "jarEntryrys", "jarIntrs", " jarEnires", " jarEnries", "jarEnies", "jarIntries", " jarEnories", "parseEntories", "jarEries", "JarEnties", "jarEntrys", "jarEntires", "jarEntryies", "jarEnries", "jarEntryorts", "jarEntriers", "jarAries", "jarTories", "jarEnties", " jarEntories", "jarErs", "jarEnories", "jarTries", "jarEntories", " jarEnies", "jarTires", "jarErrys", "jarErries", "parseEntries", "parseEriers", "parseEntriers", "jarIntories", "jarErorts", "jarAires", "jarEories", "jarEriers", "jarEntrs", "jarEntorts", "JarEntrys", "JarEntries", "jarAies", " jarEntires", " jarEnties", "jarAories", "JarEntorts", "parseEries", "parseEories", "jarEntryries", "jarIntriers", "jarEnires", "parseErs", "jarTies"], "o1": ["oe1", "opart", "oa91", "oa1", "o91", "oinf", " o0", "oe91", "oaOne", "op3", "oone", "oeinf", "po4", "oaone", "po11", " o4", " o3", " oinf", "oa0", "oe3", "so3", "oepart", " o91", " o11", "oa4", "O3", "op1", "opOne", "oainf", "o3", "oeone", "po1", "oa11", "OOne", "oe11", " opart", "O11", "o11", "O1", "so1", "soOne", "o4", "Opart", " oOne", " oone", "o0", "oOne", "O0"], "entryStream": ["EntrySteam", " entrySteam", "inputSteam", "connectionReader", "EntryString", "entryString", "zipString", "connectionStream", " entryReader", " entrystream", "zipSteam", "Entrystream", "zipStream", "entrySteam", "zipstream", "EntryStream", "inputStream", " entryString", "entryReader", "entrystream", "connectionSteam", "inputReader"]}}
{"id1": "5607440", "id2": "8064604", "code1": "    public void updateShoppingBean(String userId) {\n        Connection connection = null;\n        PreparedStatement preparedStatement1 = null;\n        PreparedStatement preparedStatement2 = null;\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            connection = DriverManager.getConnection(this.jdbcURL);\n            connection.setAutoCommit(false);\n            String preparedQuery = \"INSERT INTO dbComputerShopping.order(name,product_id,quantity,date,status)VALUES(?,?,?,?,?)\";\n            preparedStatement1 = connection.prepareStatement(preparedQuery);\n            Date date = new Date();\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            String orderDate = format.format(date);\n            Iterator iterator = this.cart.iterator();\n            Object[] shoppingInfo = null;\n            while (iterator.hasNext()) {\n                shoppingInfo = (Object[]) iterator.next();\n                ProductBean product = (ProductBean) shoppingInfo[0];\n                int quantity = (Integer) shoppingInfo[1];\n                preparedStatement1.setString(1, userId);\n                preparedStatement1.setInt(2, product.getId());\n                preparedStatement1.setInt(3, quantity);\n                preparedStatement1.setString(4, orderDate);\n                preparedStatement1.setString(5, \"confirmed\");\n                preparedStatement1.executeUpdate();\n            }\n            Object[] cartInfo = null;\n            preparedQuery = \"UPDATE components SET quantity=quantity-? WHERE comp_id=?\";\n            preparedStatement2 = connection.prepareStatement(preparedQuery);\n            for (Iterator i = this.cart.iterator(); i.hasNext(); ) {\n                cartInfo = (Object[]) i.next();\n                ProductBean product = (ProductBean) cartInfo[0];\n                int quantity = (Integer) cartInfo[1];\n                ProductListBean productList = new ProductListBean(jdbcURL);\n                ArrayList components = productList.getComponents(product.getId());\n                for (Iterator j = components.iterator(); j.hasNext(); ) {\n                    ComponentBean component = (ComponentBean) j.next();\n                    preparedStatement2.setInt(1, quantity);\n                    preparedStatement2.setInt(2, component.getId());\n                    preparedStatement2.executeUpdate();\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n            }\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement1.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement2.close();\n            } catch (SQLException ex) {\n            }\n        }\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 0, "substitutes": {"updateShoppingBean": ["updateShoppingBoan", "updateShoppingBan", "updateShippingBeAN", "updateShoppingBans", "updateShoppingBeAN", "updateShoppingBeans", "updateShippingBean", "updateShoppingBoAN", "updateShoppingBoans", "updateShippingBeaning", "updateShippingBeans", "updateShippingBAN", "updateShoppingBeaning", "updateShippingBan", "updateShoppingBaning", "updateShoppingBAN", "updateShoppingBEAN", "updateShoppingBoaning", "updateShoppingBEan", "updateShoppingBEans", "updateShippingBans", "updateShoppingBEaning", "updateShippingBaning"], "userId": ["clientName", "userName", "userData", " userPath", " userName", "clientData", " userType", "clientId", "UserType", "clientPath", "userPath", " userID", "clientID", " userData", "userID", "UserId", "UserPath", "UserData", "UserName", "userType", "clientType", "UserID"], "connection": ["lock", "statement", "data", "name", "manager", "machine", "channel", "pool", "container", "session", "database", "BC", "table", "handler", "application", "state", "class", "log", "conn", "cache", "section", " Connection", "engine", "writer", "collection", "query", "client", "subject", "service", "connected", "condition", "db", "connect", "driver", "ion", "context", "general", "config", "document", "relation", "server", "c", "function", "management", "index", "result", "resource", "con", "directory", "sql", "Connection", "communication", "bc", "graph"], "preparedStatement1": ["preparedDocumentB", "preparedComment1", "preparedstatement01", "preparedDatabase2", "preasterObject01", "preakedQuery1", "preparedCommentl", "preakedQuery4", "preppedStatement1", "preparedContextone", "preparedMaterial1", "preparedEvent01", "preparedContext4", "preparedDocumentn", "preparedMaterial17", "preasterObject1001", "prearedSession0", "preparedStruct31", "preparedQueryl", "preparedComment1001", "preparedSession1", "preparedStatone", "preparedContext31", "preparedDatabase4", "preparedState1", "preparedStatement0", "preppedStatement3", "prefixedStruct0", "preakedQuery2", "preparedMaterial2", "prearedStatement1", "preculatedStatement01", "prearedSession1", "preuredStat4", "preasterObjectone", "preppedStatl", "preparedQuery4", "preparedTransaction9", "preparedSessionB", "preparedDatabase17", "preparedCommentone", "preuredStat1", "preferredQuery17", "prefixedStruct31", "preparedObject01", "preculatedStatement1", "preparedStatementone", "preparedstatement1", "preferredStatement2", "prefixedStatement0", "preppedStat3", "preparedSession2", "preparedStat3", "preparedDocument1", "preparedDocument2", "prefixedStatement9", "preparedstatementone", "preasterStatementone", "preparedQuery3", "preuredStatement4", "preparedComment3", "prearedStatementB", "prearedStatement2", "preparedQueryn", "preparedStatement3", "preparedQuery1", "prearedSession2", "preasterStatement01", "preparedDocumentone", "preakedQueryn", "preakedStatement2", "preppedStatementl", "preparedStruct9", "preparedSession0", "preparedStatement1001", "prefixedStruct9", "preparedState9", "preparedStatementB", "prefixedStatement1", "preparedstatement1001", "preuredStat31", "preasterObject1", "preparedEvent1", "prefixedStatement31", "preparedDatabasen", "preculatedEvent01", "preparedStatement31", "preparedStat31", "preparedQuery17", "preparedStatement17", "preparedObject1001", "preasterStatement1001", "preparedTransaction0", "preppedStat1", "preakedStatementn", "preparedObjectone", "preparedStatement4", "preparedTransaction31", "preparedStat1", "preparedStat4", "preuredStatone", "preparedStruct0", "preparedObject1", "preparedDocument4", "preparedStatementl", "preuredStatement1", "preparedDatabase1", "preuredStatement31", "preferredQuery2", "preparedStatement9", "prearedSessionB", "preferredStatement1", "preparedStatl", "preakedStatement1", "preparedStatement01", "preparedComment01", "preparedState31", "preasterStatement1", "preparedContext1", "preparedDocument0", "preakedStatement4", "preparedQuery2", "preparedQueryB", "preparedState0", "prearedStatement0", "preferredQuery1", "preparedDocument31", "preparedTransaction1", "preparedStatementn", "preparedStruct1", "prefixedStruct1", "preparedState01", "preferredStatement17", "preuredStatementone", "preparedQuery0", "preculatedEvent1"], "preparedStatement2": ["preparedSession52", "preparedStatement404", "preparedResult2", "prearedStatement1", "preuredstatementtwo", "preparedstatement404", "prearedSession1", "preparedConfiguration2", "prearedSession52", "preparedSession0", "preparedstatement8", "preparedStatement52", "preparedScopetwo", "preparedResult1", "preparedConfiguration52", "preparedScope404", "preuredStatementtwo", "preparedScope2", "preparedstatement2", "preparedCondition8", "prearedStatement0", "prearedSession0", "prearedStatement52", "preuredStatement8", "preuredstatement8", "preuredstatement2", "preparedStatementtwo", "preparedSession1", "preparedResult0", "preuredStatement2", "preparedSession2", "preparedConfiguration1", "prearedSession2", "preparedScope8", "preparedCondition404", "preuredstatement404", "preparedStatement0", "preparedCondition2", "preparedStatement8", "prearedStatement2", "preparedConfiguration0", "preparedResult52", "preuredStatement404", "preparedConditiontwo", "preparedstatementtwo"], "preparedQuery": ["previsedquery", "PreparedQuery", "preplannedquery", "perparedStatement", "precedStatement", "precedquery", "perparedquery", "PrearedQu", "Preparedquery", "prearedStatement", "PreppedStatement", "previsedStatement", "prevertedBody", "PrearedFunction", "PreparedStatement", "preppedQu", "PrearedQuery", "Preppedquery", "prevertedFunction", "prearedInfo", "preplannedCommand", "preppedBody", "preppedquery", "prevertedQu", "prearedCommand", "PreppedQuery", "PreparedInfo", "prearedQuery", "preparedBody", "perparedBody", "preparedInfo", "PreppedQu", "preplannedQuery", "perparedQuery", "prearedquery", "PrearedInfo", "perppedBody", "previsedBody", "PreparedFunction", "preculatedQuery", "PreparedQu", "precedCommand", "prevertedquery", "perparedCommand", "perppedquery", "perppedQuery", "peraredCommand", "precedQuery", "perppedStatement", "preculatedInfo", "preparedFunction", "prearedQu", "prevertedStatement", "preppedQuery", "preparedquery", "preparedQu", "peraredStatement", "peraredquery", "previsedQuery", "prevertedQuery", "preparedStatement", "prearedFunction", "previsedQu", "preculatedFunction", "preplannedStatement", "preculatedQu", "peraredQuery", "preparedCommand", "preppedStatement", "prevertedInfo"], "date": ["open", "tag", "data", "name", "version", "complete", "type", "change", "event", "grade", "set", "status", "log", "match", "model", "Date", "time", "year", "bug", "d", "style", "db", "use", "order", "form", "stage", "age", "update", "number", "document", "rate", "duration", "ate", "file", "index", "module", "message", "resource", "dat", "record", "day", "string", "start", "month", "dt"], "format": [" formatted", "data", "name", " formatting", "scale", "pretty", "point", "at", "handler", "type", "handle", "table", "method", "filter", "info", "printf", "str", " fmt", "set", "letter", "class", "sort", "add", "html", "wrap", "part", "time", "term", "writer", "and", "export", "dot", "parser", "atter", " Format", "parse", "style", "value", "process", "struct", "pattern", "form", "prep", "unit", "Format", "split", "transform", "function", "prefix", "cut", "join", "replace", "report", "print", "string"], "orderDate": ["OrderTime", "serverdate", "OrderName", "orderDat", " orderData", "OrderDate", "OrderData", "requestDate", " orderDat", " orderdate", "orderName", "orderTime", "orderDay", " orderDay", "serverData", "orderdate", " orderTime", "serverDate", "requestDay", "OrderDay", "requestName", "requestDat", " orderName", "orderData", "serverTime", "Orderdate", "OrderDat"], "iterator": ["reader", "iter", "er", "sequence", "it", "ator", "gener", "vector", "later", "runners", "database", "started", "slice", "creator", "atio", "stream", "ident", "set", "ie", "adder", "ater", "loop", "inner", "instance", "walker", "loader", "ators", "former", "until", "done", "engine", "writer", "collection", "parser", "random", "ter", "pointer", "step", "entry", "interstitial", "storage", "init", "starter", "driver", "oper", "outer", "path", "choice", "wrapper", "context", "enter", "uri", "server", "finder", "metadata", "runner", "Iterator", "series", "consider", "Iter", "river", "holder", "timer", "header", "inter", "append", "you", "processor", "start", "selection", "ski"], "shoppingInfo": ["shppingInfo", "shoutingInfo", "swoppingArea", "shoppingINFO", "hoppingMeta", "swopingInfo", "shppingMeta", "shoutingInf", "swoppingInf", "shoutingINFO", "hillingId", "shoppingInf", "shoppingData", "shopingArea", "shillingArea", "shillinginfo", "shopingInf", "shppingInf", "shopingMeta", "shillingMeta", "hoppingInfo", "hillinginfo", "swopingObj", "swoppingInfo", "shillingInf", "shoppingObj", "shoppinginfo", "hoppingInf", "shoppingArea", "shippingInf", "hillingInfo", "shillingInfo", "shppinginfo", "shoppingId", "shashingId", "shppingArea", "hillingMeta", "shillingData", "hoppingId", "swoppingObj", "shppingObj", "shippingInfo", "ShoppingInf", "hoppinginfo", "shillingObj", "hillingData", "shopingData", "shashingInfo", "shopingObj", "swopingInf", "hoppingData", "shashingInf", "shppingId", "shillingINFO", "ShippingINFO", "ShippingInf", "shillingId", "ShippingInfo", "shppingData", "hillingInf", "swopingArea", "shoppingMeta", "ShoppingInfo", "ShoppingINFO", "shopingInfo", "shippingINFO", "shashinginfo"], "product": ["feature", "data", "version", "type", "creator", "filter", "p", "Product", "per", "class", "plugin", "copy", "model", "position", "seller", "user", "output", "collection", "client", "pp", "payment", "service", "source", "image", "child", "production", "project", "process", "parent", "object", "band", "order", "property", "attribute", "products", "config", "relation", "pe", "cart", "module", "result", "resource", "contact", "target", "input", "company", "processor"], "quantity": ["compification", "necessification", "quantification", "primITY", "compance", "authority", "necessifier", "necessity", "quantality", "quantance", "mentality", "commentality", "compality", "primality", "authorance", "aquicity", "authorality", "quantifier", "primification", "quanticity", "compity", "aquality", "aquity", "compifier", "authoricity", "primity", "mentITY", "quantITY", "mentity", "commentifier", "primation", "quantation", "commentity", "compicity", "commentITY", "compation", "primifier", "necessation", "mentifier", "aquance"], "cartInfo": ["cartMeta", " cartList", " cartMeta", " cartSize", "frontInf", "cartList", "productSize", "contactList", "frontInfo", "cartData", " cartObj", "productInfo", "contactInf", " cartStyle", "cartObj", "carInf", "contactInfo", "carInfo", "productData", " cartData", "frontStyle", "carMeta", "cartStyle", "carSize", "cartSize", "cartInf", " cartInf", "productObj", "productInf", "carStyle", "carObj", "frontMeta", "contactData", "frontObj"], "i": ["f", "si", "it", "ri", "info", "p", "pi", "ori", "ie", "is", "hi", "I", "di", "bi", "ami", "multi", "qi", "l", "e", "ini", "abi", "list", "cli", "ci", "init", "api", "xi", "v", "oi", "ui", "n", "uri", "li", "ani", "ii", "io", "c", "id", "index", "iu", "ic", "chi", "vi", "ai", "ati", "phi", "ip"], "productList": ["pageArray", "resourceList", "productArray", "configCollection", "productGroup", "cartList", " productlist", "resourceCollection", "configList", "pagelist", "resourcelist", " productArray", "pageGroup", "productlist", "productSet", "pageList", "productCollection", "cartlist", " productCollection", " productSet", " productGroup", "configSet", "resourceSet", "cartGroup", "configlist", "cartArray"], "components": [" complements", "commonents", "depients", "suppositories", "productarts", " compositories", "cproducts", "productategories", "comonents", "compenses", "compients", "commositories", "supponents", "comositories", "complements", "comlements", "productonents", "parts", "supplements", "depositories", "compositories", "compproducts", "compategories", "comenses", "suppenses", "comparts", "deponent", "categories", "comonent", "conents", "commients", "commonent", "carts", "ponents", "pategories", "comients", "productproducts", "pproducts", "deponents", " compenses"], "j": ["ji", "ij", "er", "f", "jj", "bj", "_", "where", "database", "p", "k", "ie", "add", "jp", "b", "all", "r", "l", "query", "o", "jc", "this", "z", "js", "J", "Select", "v", "other", " ii", "update", "config", "url", "n", "jo", "index", "id", "Config", "adj", "sql", "Insert", "area", "obj", "Query"]}}
{"id1": "7169984", "id2": "17901739", "code1": "    public static String connRemote(JSONObject jsonObject, String OPCode) {\n        String retSrc = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(AZConstants.validateURL);\n            HttpParams httpParams = new BasicHttpParams();\n            List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>();\n            nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode));\n            nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString()));\n            httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair));\n            httpPost.setParams(httpParams);\n            HttpResponse response = httpClient.execute(httpPost);\n            retSrc = EntityUtils.toString(response.getEntity());\n        } catch (Exception e) {\n            Log.e(TAG, e.toString());\n        }\n        return retSrc;\n    }\n", "code2": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "label": 0, "substitutes": {"connRemote": ["invokeLocal", " execIP", "execURL", " execURL", " execLocal", "invokeIP", "execIP", "invokeRemote", " executeLocal", " execRemote", " executeURL", " executeIP", "execRemote", "execLocal", "invokeURL", " executeRemote"], "jsonObject": ["customObj", "JSONArray", "javaBody", "jsonBody", "httpObject", " jsonString", "jsonString", "customOperation", "jsonOb", "httpArray", "JSONBody", "JSONObj", "JSONOb", "customObject", " jsonOb", " jsonBody", "jsonArray", "JSONOperation", "javaOb", "jsonObj", "JSONString", "jsonOperation", "javaObject", "httpOperation", "httpObj", "javaString", "customArray", "JSONObject"], "OPCode": ["OPcode", "OpCode", "OpAction", "OPERcode", "opName", "OPName", " OPName", "OPERCode", "OpName", " OPcode", "opAction", "OPAction", " OPAction", "OPERName", "opCode", "Opcode", "opcode"], "retSrc": ["retSck", "retInuc", "retNrt", "retDrc", "retSsrc", "retOsRC", "RetAsck", "retAsrc", "retSvc", "retOssrc", "retAsuc", "retSrt", "retInck", "retNrc", " retSRC", "retOsrc", "retDck", "retAsRC", "retDRC", " retDrt", "RetSrc", "RetAsuc", "RetAsrc", "retPsrc", "retDsrc", " retSsrc", "retDrt", "retSuc", "retPRC", " retSvc", "RetAsRC", "retNsrc", "RetSuc", "retInRC", " retDsrc", " retDrc", "retDuc", "retPvc", "retPrc", " retSrt", "RetSRC", "RetSck", "retAsck", "retSRC", "retNRC", "retInrc", " retDRC", "retOsrt", "retNvc"], "httpClient": ["xmlConnection", "xmlProxy", " httpProxy", "httpProxy", "apiPost", "apiCall", "apiClient", "apiclient", "phpCall", "phpClient", "HttpCase", "HttpProxy", "xmlCase", "HttpConnection", "xmlClient", "HttpClient", "httpsCall", " httpConnection", "httpsclient", "httpCase", " httpCase", "httpsPost", "phpclient", "httpCall", "httpsClient", "httpclient", "httpConnection", "phpPost"], "httpPost": ["htmlDo", "htmlCopy", "HttpRequest", "httpsPOST", "webPost", "httpPre", "workPost", "htmlPOST", "httppost", " httppost", "autoPOST", "httpPOST", "httpDo", "webpost", "phpPOST", " httpPOST", "HttpDo", "httpRequest", "HttpPost", " httpDo", "httpsCopy", "httpsPre", " httpRequest", "HttpPOST", "workpost", "workDo", "webDo", "autoCopy", "HttpCopy", "webPre", "autoPre", "workPre", "htmlPost", " httpPre", "autoPost", "phpRequest", "httpsPost", "HttpPre", "httpCopy", "phpDo", " httpCopy", "phpPost"], "httpParams": ["httpCatars", "httpPums", "httpVariums", "httpCatam", " httpParars", "httpArgams", "httpParam", " httpPums", "httpArgam", "hrParms", "hrParars", "httpPerums", "httpVariars", "httpParars", "httpPeram", "hrParams", "hrPams", "hrPars", "httpPms", "httpPam", "httpArgars", "httpPars", " httpPam", "httpPerars", "httpCatams", "httpParums", "httpPerams", "httpArgms", "hrPam", " httpPars", "httpVariams", " httpPams", "httpParms", "hrPms", "httpVariam", "httpCatms", "httpPams", " httpParam", " httpParums", "hrParam"], "nameValuePair": ["nameValueLatch", "nameValueCait", "nameValuePointore", "nameValuePhair", "nameValueCpair", "nameNameProtore", "nameValuePointpair", "nameValueSair", "nameNamePiece", "nameNameProtpair", "nameValuepair", "nameValuePointair", "nameNameProtair", "nameNameProtenter", "nameValuePiece", "nameValueSenter", "nameVPpair", "nameVCpair", "nameValuepolder", "nameVPait", "nameValueProtpair", "nameValuePolder", "nameNamePolder", "nameValuepait", "nameValuePhiece", "nameValuePerolder", "nameValueFiece", "nameNameLolder", "nameValuePortion", "nameNamePatch", "nameNamePpair", "nameNamePenter", "nameNamePore", "nameNameLatch", "nameValueSore", "nameValueFortion", "nameValuePeratch", "nameValuepatch", "nameNamePortion", "nameValueProtenter", "nameNamePair", "nameNamepair", "nameVPair", "nameValuePerair", "nameValueProtore", "nameNameLair", "nameValuePait", "nameValuepiece", "nameValuePhortion", "nameValueFair", "nameValueParait", "nameValuePointenter", "nameValuePenter", "nameValuePpair", "nameValueParair", "nameValueParpair", "nameValuePatch", "nameValuePore", "nameNamepiece", "nameValueportion", "nameValueProtair", "nameVCait", "nameValueSpair", "nameNameportion", "nameValueLair", "nameValueCair", "nameValueLolder", "nameVCair", "nameValueppair"], "response": ["full", "connection", "f", "data", "tree", "channel", "session", "respond", "method", "body", "application", "Response", "status", "page", "output", "entity", "throw", "jet", "success", "e", "reply", "i", "block", "feed", "api", "request", "object", "environment", "v", "view", "server", " Response", "http", "wave", "message", "result", "resource", "res", "json", "resp", "site"]}}
{"id1": "15241397", "id2": "10795866", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"doGet": ["doGET", "handleget", " doPut", " doget", "doget", "handlePut", "didPut", "doPut", "didget", "handleGET", "handleGet", "didGet", "didGET", " doGET"], "request": ["connection", "reader", "er", "data", "complete", "QUEST", "method", "type", "info", "application", "web", "event", "received", "xml", "req", "user", "instance", "query", "client", "subject", "buffer", "image", "object", "Request", "url", "context", "document", "uri", "server", "http", "message", "input", "result", "resource", "queue", "initial", "report"], "response": ["full", "connection", "data", "version", "error", "pool", "session", "respond", "body", "results", "application", "Response", "status", "model", "page", "output", "writer", "collection", "client", "reply", "image", "parent", "object", "next", "other", "esi", "document", "view", "server", "wave", "function", "message", "resource", "result", "out", "queue", "host", "report", "onse", "generation", "json", "resp", "site"], "rewrittenQueryString": ["rewwrittenQueryList", "rewrittenUrlService", "rewrittenqueryString", "rewrittenQueryText", "rewwrittenRequestString", "rewrittenQueryList", "rewrittenRequestService", "rewwrittenQueryLine", "rewrittenPageList", "rewrittenqueryStr", "rewrittenQueryArray", "rewwrittenQueryArray", "rewrittenQuestionList", "rewrittenPageLine", "rewrittenUrlString", "rewwrittenRequestArray", "rewwrittenRequestLine", "rewrittenqueryService", "rewwrittenQueryStr", "rewrittenRequestText", "rewrittenQueryService", "rewrittenUrlText", "rewrittenQuestionArray", "rewwrittenRequestStr", "rewrittenqueryLine", "rewrittenPageArray", "rewrittenQuestionText", "rewwrittenQueryString", "rewwrittenRequestService", "rewrittenRequestStr", "rewrittenQueryLine", "rewwrittenQueryText", "rewrittenQuestionStr", "rewrittenRequestString", "rewwrittenRequestText", "rewwrittenQueryService", "rewrittenRequestLine", "rewrittenQuestionString", "rewrittenUrlLine", "rewrittenQuestionLine", "rewrittenRequestList", "rewrittenqueryText", "rewwrittenRequestList", "rewrittenRequestArray", "rewrittenQueryStr", "rewrittenPageString"], "rewrittenUrl": ["RewwrittenUrl", "rewilledUrl", "rewriteUrl", "rewardedLanguage", "rewardedInt", "rewwrittenInt", "rewmatchedUrl", "rerittenLanguage", "rewrapedUrl", "rewmatchedURL", "rewrittenInt", "rewardedUrl", "rewrittenLanguage", "rewardedJar", "rewardedUr", "RewrittenFile", "RewrittenUr", "rewilledURL", "rewatchedServer", "RewwrittenLocation", "rewardedURL", "rewatchedURL", "RewrittenServer", "rewrittenText", "rewwrittenServer", "rewcraftedUrl", "rewrapedUr", "rewwrittenJar", "rewrittenurl", "rewwrittenLanguage", "rewedurl", "rewcraftedUr", "rewwrittenLocation", "rewwrittenText", "Rewwrittenurl", "rewrapedFile", "rewriteText", "rewrittenURL", "rewodedUrl", "RewwrittenInt", "rewwrittenUr", "rewrittenServer", "rewrapedURL", "rewrittenJar", "RewrittenURL", "RewrittenLocation", "RewwrittenText", "rewodedFile", "rewriteServer", "rewmatchedFile", "rerittenUrl", "RewrittenInt", "rerittenURL", "rewatchedUrl", "rewwrittenUrl", "rewedURL", "rewmatchedurl", "RewrittenUrl", "rewrittenUr", "rewrittenLocation", "rewwrittenFile", "rewedUrl", "rewriteURL", "rewcraftedURL", "RewwrittenURL", "RewwrittenUr", "rewcraftedLocation", "rewilledJar", "RewrittenText", "rerittenFile", "RewwrittenFile", "rewatchedText", "rewodedLanguage", "rewardedLocation", "RewrittenJar", "rewedFile", "RewwrittenServer", "rewardedFile", "rewrittenFile", "rerittenUr", "rewilledInt", "rewodedURL", "rewwrittenURL", "rewedUr", "RewwrittenJar", "rewwrittenurl", "Rewrittenurl"], "httpURLConnection": ["httpCLConnection", "httpURIConnect", "apacheURLFlow", "httpURLCode", "httpURLService", "webSSLClient", "httpurlCurrent", "httpurlConnection", "httpURLConn", "httpURConn", "apacheURLConnect", "httpStreamconnection", "httpSSLConnection", "httpURIClient", "HttpChannelconnection", "httpUrlconnection", " httpURConn", " httpUrlConnection", "httpUrlConnection", "httpStreamSession", " httpURLconnection", "httpStreamConnection", " httpURConnect", "httpurlFlow", "httpUrlContext", "httpChannelService", "HttpURLConnection", "httpURLContext", " httpUrlConn", "httpCLConn", " httpStreamCurrent", "webSSLConnection", "httpURIconnection", "HttpURLconnection", "httpPathCurrent", "webURLContext", "webSSLContext", "httpurlconnection", "httpUrlConn", "httpURLCurrent", "apacheGEConnect", "httpURConnect", " httpStreamSession", "httpWebConnect", "httpSSLContext", "httpPathConnection", "httpPathconnection", "httpurlSession", "HttpChannelConnect", "httpGEconnection", " httpURLSession", "httpURIFlow", "httpURIContext", "httpURLClient", "httpurlConn", " httpURLConn", "httpUrlService", "httpStreamCurrent", "httpURConnection", "httpUrlConnect", "apacheGEConnection", "HttpURLConnect", " httpStreamConnection", " httpURConnection", "httpGEConnection", "httpURIConnection", "httpURLconnection", "httpurlConnect", " httpURLCurrent", "httpChannelconnection", "httpELConn", " httpURLConnect", "httpChannelConnection", "httpWebConn", "webURLClient", "apacheGEFlow", "httpSSLConn", " httpStreamconnection", "apacheURLconnection", "HttpURLService", "httpSSLClient", "httpELConnection", "HttpChannelConnection", "httpGEFlow", "webURLConnection", "webURLConn", "httpChannelConnect", "httpGEConnect", "httpUrlCode", "HttpChannelService", "httpWebConnection", "httpURconnection", " httpURLCode", "httpURService", " httpUrlCode", "httpUrlClient", "httpPathSession", "apacheGEconnection", "httpURLFlow", "httpCLCode", "webSSLConn", "apacheURLConnection", "httpurlCode", "httpURIConn", "httpURLConnect", "httpELConnect", "httpURLSession"], "header": ["feature", "iter", "er", "director", "data", "version", "channel", "master", "error", "handler", "head", "reference", "filter", "layer", "pair", "info", "after", "field", "event", "definition", "rule", "match", "component", "part", "bridge", "section", "her", "writer", "line", "member", "key", "ter", "dr", "column", "back", "buffer", "list", "entry", "player", "comment", "block", "driver", "outer", "hash", "second", "character", "Header", "next", "default", "attribute", "document", "group", "server", "date", "consumer", "author", "metadata", "function", "index", "message", "item", "token", "headers", "queue", "result", "cover", "string"], "value": ["office", "values", "data", "current", "name", "version", "now", "get", "type", "language", "V", "info", "field", "variable", "option", "label", "letter", "expression", "set", "format", "description", "model", "text", "content", "sv", "val", "VALUE", "key", "password", "comment", "entry", "child", "parent", "object", "v", "property", "attribute", "default", "document", "hello", "server", "function", "valid", "message", "item", "gi", "Value", "json", "string", "media", "end", "element"], "inputStream": ["pullStreamer", "inputSteam", "resourceSteam", "InputChannel", "InputStream", "InputStreamer", "outputStreamer", "pullstream", "inputStreamer", "resourceChannel", "pullStream", "pullSteam", "resourcestream", "resourceStream", "inputChannel", "Inputstream", "outputChannel", "outputSteam", "InputSteam", "inputstream", "outputstream"], "outputStream": ["inputSteam", " outputChannel", "OutputSteam", "outputFile", "OutputChannel", " outputFile", "OutputStream", "outputStreamer", "externalstream", "Outputstream", "inputStreamer", "externalSteam", "externalStreamer", "responseStream", "responseSteam", " outputSteam", "responseFile", "outputChannel", "outputSteam", "responseChannel", "externalStream", "inputstream", "OutputFile", "outputstream", "OutputStreamer"]}}
{"id1": "4056444", "id2": "12744653", "code1": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"hashPassword": ["hashWord", "updateWord", "hashSecret", "hashpassword", " hashWord", "updateSecret", "updatePassword", "printPassword", " hashpassword", "printSecret", "updatepassword", "printWord", "printpassword", " hashSecret"], "password": ["login", "data", "name", "pool", "email", "wd", "database", "create", "p", "param", "words", "cache", "user", "text", "Password", "account", "random", "address", "crypt", "secret", "padding", " passwords", "sword", "phrase", "path", "PASS", "attribute", "code", "pass", "null", "word", "prefix", "message", "sha", " Password", "token", "input", "out", "security", "auth", "string", "SHA", "confirmed", "username"], "md": ["bd", "f", "mag", "mg", "rm", "wd", "grad", "mad", "dd", "m", "ma", " MD", "mt", "rod", "dig", "di", "mb", "am", "mac", "hm", "cmd", "dm", "sm", "d", "MD", "mo", "mod", "amd", "sum", "mp", "metadata", "mm", "pm", "dh", "sha", "bf", "mc", "nd", "od", "mand", "hd", "pd", "ad"], "hash": ["rh", "full", "data", "ha", "hed", "version", "array", "body", "string", " hashing", "dump", "hex", "log", "match", "dig", "format", "check", "cache", "user", "mac", "her", "kh", "dot", "key", "address", "secret", "style", "build", "image", "db", "value", "block", "h", "url", "sum", "number", "code", "pass", "file", "ho", "shadow", "id", "search", "sha", "header", "ash", "length", "Hash", "html", "SHA", "sh", "username"]}}
{"id1": "23672408", "id2": "22993368", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyIconFiles": [" copyiconImages", " copyiconFiles", " copyIconFile", "copyFileTypes", "copyIconImages", "copyFileFiles", "copyiconTypes", " copyiconFile", "copyImageTypes", "copyIconFile", "copyiconFiles", "copyImageImages", " copyiconTypes", " copyIconImages", "copyImageFiles", "copyImageFile", "copyiconImages", "copyFileImages", " copyIconTypes", "copyFileFile", "copyiconFile", "copyIconTypes"], "clazz": ["Claz", "sluster", " cllass", " clance", "llazz", "Clclass", "clclass", "llclass", "CLazz", "llobe", "flaz", " closed", "slazz", "closed", "closer", "classe", "cluster", "hellasso", "Clab", "slod", "sloss", "hellosed", "hellance", " claz", "CLance", "Clunk", "cllass", "clance", "CLaz", " classe", "fluster", " cluster", "claz", " clclass", "clunk", "slosed", " clunk", "llaz", "slaz", "hellobe", "slance", "plclass", "Clazz", "pllass", "clab", "llab", "Closs", "helllass", "glaz", "closs", "llasse", "flunk", "Cluster", "ploser", "hellasse", "glance", "glazz", " clab", " closs", "glod", "classo", "sllass", "CLod", "Closer", "plazz", "flazz", " clobe", " closer", " classo", "clod", "Cllass", "hellazz", "llasso", "clobe"], "i16": ["I14", "pi16", "ii16", "i17", "ini14", "si2016", "pi24", "ini2016", "l24", "si14", "ini16", "ai14", "si64", "io15", "int16", "ini17", "si15", "I15", "i2016", "ii24", "si16", "int2016", "io16", "i15", "ai2016", "I17", "i24", "ii14", "i64", "pi15", "io2016", "si24", "l64", "l15", "ii15", "ai15", "pi64", "int15", "ii17", "ai16", "io24", "i14", "ini15", "I16", "ii2016", "l16", "int24"], "fileType": ["fileState", " fileAuth", "imageUnit", "filePatch", "imagePath", "filetype", "imageType", "fileStyle", "singleStyle", " filetype", "messagePatch", "documentState", " filePatch", "fileBlock", "feedInfo", "iconTy", "iconType", "singleTime", "iconAuth", "fileTy", "FileType", " fileLength", "FileFamily", " fileBlock", "FileStyle", "documentType", "fileLike", "imageFamily", "messagetype", " fileUnit", "filePath", "playType", "letterType", "transferFamily", "letterState", "feedPatch", "imageTime", "letterSpread", "feedLike", "fileAuth", "fileFamily", " fileState", "FileInfo", "singleFile", "feedtype", "singleType", "letterBlock", " fileStyle", "feedPath", "feedType", "letterFamily", "fileKey", "fileLocation", "transferTy", "playSpread", "iconPath", " fileFamily", " fileFile", "transferSpread", "fileInfo", "messageType", "iconKey", "iconStyle", "wordTy", "fileTime", " fileLike", " fileTime", "documenttype", "fileSpread", "wordAuth", "wordLength", "imageFile", "FileLike", " fileLocation", "transferType", " fileInfo", "feedLocation", "lettertype", " fileKey", "fileLength", "wordType", " filePath", "playFamily", "messagePath", "imageKey", "letterTy", "playTy", "imageStyle", "FileUnit", "fileFile", "FileLocation", "documentBlock", "iconLength", " fileTy", "fileUnit"], "desti16": ["destsi32", "targeti016", "destsi16", "destabi2016", "combi16", "combini32", "desturi15", "desti15", "targeti16", "targeti2016", "destabi15", "combi32", "desturi16", "destabi016", "destf2016", "destini32", "destsi64", "destsi15", "destI016", "destI16", "targetI15", "combi15", "combi64", "desturi64", "destini64", "combini15", "targeti15", "combini16", "desti64", "destf16", "targetI2016", "desturi32", "destini15", "destini16", "desti2016", "targetI16", "destI15", "destI2016", "destf15", "desti016", "combini64", "targetI016", "destf016", "destabi16"], "src": ["https", "sl", "thumbnails", "data", "support", "sc", "crop", "inst", "proc", "ssl", "rob", "b", "console", "source", "ctx", "url", "default", "conv", "uri", "null", "resource", "ctrl", "coll", "usr", "tmp", "cur", "socket", "gl", "bs", "secure", "stream", "iv", "load", "sys", "bh", "output", "front", "dest", "back", "pull", "rb", "scene", "target", "pkg", "scenes", "cdn", "loc", "gb", "grad", "ug", "ource", "r", "root", "dist", "lib", "cmp", "image", "hub", "attr", "config", "ser", "cv", "http", "sr", "upload", "rss", "rl", "buf", "cb", "s", "st", "sync", "download", "gz", "rc", "req", "video", "img", "sq", "uc", "filename", "view", "uv", "in", "file", "func", "sel", "input", "desc"], "dst": ["dedst", "dsst", "sdsc", "nrest", " ddest", "dste", "dsc", "ldst", "ddest", "idest", " dest", "drst", "adbl", " dsc", "idsl", "drest", " dsl", "dct", "idsc", " dbl", "dsts", "idbl", "adst", "sdsl", "rdsc", "Dbl", "iddest", "adost", "Dste", "drd", "nste", "dest", "dput", "Dst", "ldbl", "adct", "ddr", " drd", "Dct", "Dsts", "ldost", "sddest", "sdst", " dsts", "dsput", "deddr", "idrd", "dedput", "drsc", "drST", "idst", "dsl", "dedost", " drest", "nst", "dost", "Dost", "Dput", "sdbl", "dST", "dsost", "dsdr", " dST", "sdrd", "dbl", " dput", "rdput", "rdST", " dste", "sdest", "drput", "ldct", "Ddr", "Drest", "rdst", "nsts"], "i32": ["in15", "I31", "ini32", "ri42", "iu15", "i31", "i35", "qi15", "ini35", " i35", "ini33", "qi34", "ri33", " i31", " i30", "i22", "I32", "ui30", "qi32", "ui32", "I34", "iu32", "iu33", "ui31", " i34", "ini22", "si35", "i15", "in34", "in32", "i30", " i42", "I42", "si33", "ri35", "I35", "si22", "I30", "I33", "in33", "si32", "i34", " i22", "qi33", "i33", "ri32", "iu34", "i42", "ui34", " i33"], "desti32": ["destsi32", "destsi16", "desti22", "targetiu32", "destic32", "destin32", " destsi22", " destsi32", "desti15", "destii34", "destic16", "destabi15", "desti33", "destiu33", "destabi32", " destsi15", " desti15", "destii28", "targeti32", "targetiu28", "destsi15", "desti28", "destii32", " desti22", "destii33", "targeti28", "destin28", "destiu34", "targeti34", "destic22", "destin34", "destic15", "destiu32", "destabi22", "targeti33", "desti34", "destiu28", "targetiu33", "destsi22", " destsi16", "targetiu34", "destin33", "destabi16"]}}
{"id1": "7276377", "id2": "11546108", "code1": "    public static String checksum(URL url, String algorithm) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(algorithm);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex);\n        }\n        byte[] bytes = new byte[4 * 1024];\n        try {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                int nBytesRead = 0;\n                while ((nBytesRead = in.read(bytes)) > 0) {\n                    messageDigest.update(bytes, 0, nBytesRead);\n                }\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm);\n        }\n        byte[] checksumValue = messageDigest.digest();\n        return digestAsString(checksumValue);\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"checksum": ["cksums", "checksums", "decum", "decums", " checksums", "checkssum", "cksum", "checksumb", "decsum", "ckssum", " checkssum", "cksumb", "decumb", " checksumb"], "url": ["connection", "sl", "f", "loc", "name", "manager", "email", "ur", "gl", "stream", "download", "str", "base", "rule", "ssl", "ll", "user", "loader", "text", "href", "l", "fr", "address", "Url", "proxy", "URL", "service", "image", "source", "feed", "or", "path", "filename", "config", "uri", "server", "http", "file", "cert", "id", "src", "resource", "host", "location", "string", "username"], "algorithm": [" algorith", "algebra", "Alignment", "malgorithm", "exgorith", "Algo", "Algorithm", "ALgo", "malgo", " algebra", "malignment", "allgo", "Algorith", "ALgorith", " alignment", "exgo", "algo", "allgorith", " algo", "malgebra", "ALgebra", "allgebra", "alignment", "exgebra", "ALgorithm", "exgorithm", "Algebra", "malgorith", "algorith", "allgorithm"], "messageDigest": ["messageMixest", "messageDer", "messagedigess", "messagedigester", "messageMixester", "messagediger", "MessageDesignator", "messageDade", "messagedigator", "messageDigess", "messageDge", "messageRegester", "messageDpe", "MessageDesignest", "messageDse", "MessageDesignester", "messageDigge", "messageDigpe", "MessageMixer", "MessageDse", "messageDigse", "messageDigester", "MessageSignest", "messagedigse", "messageDigator", "messagedigpe", "messageDesignester", "messageSignester", "MessageDade", "MessageDester", "messageRegator", "MessageDigse", "MessageSignester", "messageSignest", "MessageDigest", "MessageDiger", "messageDesignest", "messagedigest", "messageSignge", "messageMixpe", "MessageMixester", "MessageDigess", "messageSignse", "MessageDesigness", "messagedigade", "MessageSignge", "MessageSignse", "messageRegest", "MessageMixest", "MessageDest", "messageRegess", "MessageDigge", "messagedigge", "MessageDigpe", "MessageDigester", "MessageMixpe", "MessageDigade", "messageDesignator", "messageDiger", "messageMixer", "MessageDigator", "messageDesigness", "messageDester", "messageDigade", "messageDest"], "bytes": ["pages", "vals", "values", "blocks", "eps", "rows", "bs", "boot", "ips", "outs", "units", "os", "gets", "reads", "cells", "ls", "words", "items", "parts", "files", "size", "bits", "bles", "zip", "lines", "steps", "resses", "buffer", "pieces", "ipes", "loads", "tes", "objects", "classes", "frames", "vs", "errors", "bps", "seconds", "ones", "es", "resources", "Bytes", "limits"], "in": ["reader", "bin", "isin", "login", "f", "data", "version", "socket", "s", "ins", "m", "stream", "ex", "min", "In", "fe", "gen", "is", "kin", "ssl", "conn", "b", "again", "inner", "rin", "win", "r", "l", "din", "IN", "err", "fr", "client", "ini", "i", "source", "init", "inc", "nin", "n", "inn", "c", "file", "as", "id", "impl", "a", "token", "input", "out", "con", "ac", "gin", "serv"], "nBytesRead": ["nFramesFound", "nByteWritten", " nByteCount", " nByteRead", " nBytesWritten", " nBytesFound", "nBytesWritten", "nCharactersRead", "nByteLength", "nPagesWritten", " nBytesLoad", "nBytesFound", "nPartsWritten", "nFramesRead", "nBytesLength", "nByteRead", "nPagesLength", "nByteFound", "nWordsRead", "nBytesCount", "nPagesRead", "nCharactersCount", "nCharactersLength", " nBytesLength", "nByteCount", "nWordsWritten", "nPartsRead", "nByteLoad", " nByteFound", "nWordsLength", "nCharactersWritten", "nWordsCount", "nBytesLoad", "nPagesFound", "nFramesLength", " nByteLoad", " nBytesCount", " nByteWritten", "nFramesWritten", "nPartsLoad", " nByteLength"], "checksumValue": ["checksupData", "checkssumData", "checksumVal", " checkssumText", " checkssumArray", "checksumberString", "checksupString", " checkssumData", "checkssumString", "checksumText", "checksumberValue", "checksumberText", "checksummValue", " checkssumPath", " checksumText", "checksramValue", "checksummVal", " checksumData", "checksupValue", " checksumString", "checkssumText", " checkssumVal", "checksramArray", "checksupText", " checksumVal", "checksumberData", "checkssumArray", "checksummPath", "checkssumValue", "checksumPath", " checkssumValue", " checkssumString", " checksumArray", "checkssumPath", "checksummArray", "checksramVal", "checksumArray", "checkssumVal", "checksumData", "checksramPath", "checksumString", " checksumPath"]}}
{"id1": "9275622", "id2": "11334468", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"copyFile": ["moveFolder", "copyFiles", " copyfile", "copyFolder", "transferFile", "transferFolder", "moveFiles", "transferfile", " copyFiles", " copyFolder", "transferFiles", "movefile", "copyfile", "moveFile"], "_file1": ["_files1", "_files01", "_File2", "_fileone", "_resourceOne", "_mail2", "_file0", "_resource1", "_fFirst", "_resourceone", "_zip1", "_zipFirst", "_fileOne", "_zipOne", "_file01", "_fone", "_fOne", "_File0", "_f1", "_mail1", "_File01", "_mail0", "_File1", "_mail01", "_zipone", "_files2", "_files0", "_resourceFirst", "_fileFirst"], "_file2": ["_files4", "_filesecond", "_Filesecond", "_File5", "_File2", "jfile1", "_file4", " _filesTwo", " _files3", "jmodelsecond", "_model1", "_model5", "_file5", "_modelsecond", "_files3", "_file3", "jfile5", "_play2", "jfilesecond", " _file3", "_playTwo", "jmodel1", "jmodel5", "_play1", "_model2", "_playsecond", "_filesTwo", "_fileTwo", "_File1", "_play5", " _files4", "_files2", "_play4", " _file4", " _fileTwo", "jfile2", "_play3", "jmodel2", " _files2"], "fis": ["fiss", "infiss", "lfais", "lfi", "afis", "cfos", " fris", "afais", "cfiss", "lfis", "cfas", "Fils", " fais", "infils", "afiss", "fi", "Fas", "Fis", " fi", "fils", "infos", "Fiss", "fas", " fiss", "afi", " fils", "lfiss", "Fos", "fris", "Fris", "fais", "cfis", "cfris", "infis", " fas"], "fos": ["infaos", "Fo", "fus", "infus", "Foos", "Foses", "foses", "infios", "feos", "floes", "goses", "Fus", "info", " foos", "fOS", "flis", "infros", "gis", "Faos", "Fros", " fus", "gos", "feoses", "foes", "pis", "Fios", "Fis", "infoos", "infos", "fros", "poes", " faos", "pOS", "feus", "fios", "Fos", "pos", "feis", "foos", " fo", "flOS", " fios", "los", "lis", "faos", "lOS", "flos", "fo", " fros", "loes", "gus"], "canalFuente": ["canalBuence", "canalCraencia", "canaledBuje", "canaledBuze", "canalKuze", "canallBuente", "canallFuente", "canalBuento", "canalFuze", "canalsBuence", "canaledBuente", "canalSuente", "canalFuento", "canallBuence", "canalsFuente", "canalBuente", "canalBuje", "canalSuje", "canalFUje", "canaledFuente", "canalSuestro", "canaledFuestro", "canallFuze", "canalsFuence", "canalsBuento", "canalFUestro", "canalFuencia", "canalKuence", "canalsFuencia", "canalFUente", "canalBuencia", "canaledBuestro", "canaledFuje", "canalKuento", "canalsFuento", "canalFuje", "canallBuze", "canallFuence", "canalsBuencia", "canaledFuze", "canalBuestro", "canallFuencia", "canalKuente", "canalKuencia", "canalFuence", "canalFUencia", "canalSuze", "canalCraence", "canalsBuente", "canalFUze", "canalCraente", "canalCraento", "canalFUence", "canalBuze", "canallBuencia", "canalFuestro"]}}
{"id1": "11865906", "id2": "18570190", "code1": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"testIdentification": ["testIdentify", "Testidentifier", "Testidentification", "testidentification", "TestIdentify", "TestIdentity", "TestIdentification", "testidentifier", "testPersonifier", "testidentify", "testAuthentification", "testPersonity", "Testidentify", "testIdentifier", "testPersonify", "testAuthentifier", "testAuthentity", "testPersonification", "Testidentity", "TestIdentifier", "testidentity", "testIdentity", "testAuthentify"], "username": ["job", "uin", "ame", "profile", "login", "name", "email", "database", "uu", "creator", "verb", "ug", "sudo", "nil", "plugin", "whatever", "account", "subject", "address", "your", "nick", "ername", "staff", "sword", "mobile", "driver", "filename", "property", "character", "ui", "url", "rue", "hello", "consumer", "USER", "uri", "person", "uno", "word", "prefix", "utf", "users", "uid", "token", "host", "usr", "home", "company", "string", "month", "purpose"], "password": ["wallet", "profile", "login", "name", "email", "wd", "database", "session", "seed", "p", "sudo", "Pass", "description", "picture", "cache", "words", "w", "Password", "text", "mac", "account", "key", "patch", "address", "secret", "crypt", "fax", "padding", " passwords", "sword", "value", "driver", "phrase", "PASS", "filename", "hash", "attribute", "pass", "null", "params", "word", "prefix", "token", "diff", "security", "pad", "auth", "string"], "md5": ["sha512", "md2", "sha5", "md1", "sha1", "md75", " md3", " md4", "dd512", "sha4", "MDob", "mdob", " md1", "sha3", "MD75", "MD4", "MD5", "sha75", " md512", "MD512", "md512", " mdob", "MD1", "ddob", " md2", "MD2", " md75", "md4", "dd5", "dd2", "md3", "MD3"], "logServiceMock": ["logServiceManocks", "logServicemOCK", "logServiceManOCK", "logClientMock", "logServicePick", "logServiceManock", "logServicePock", "logServiceAMOCK", "logClientMocker", "logModuleMocks", "logServiceBck", "logModuleManock", "logServiceBocker", "logServiceMick", "logServicemock", "logModuleManocks", "logServiceFock", "logClientMOCK", "logModuleManocker", "logServiceBOCK", "logModuleMOCK", "logModuleMick", "logServiceManagerocks", "logModuleMock", "logServiceManocked", "logServiceBick", "logServiceFOCK", "logModulePock", "logModuleMocker", "logServicePOCK", "logServiceFck", "logServicemocks", "logServiceMocks", "logServiceBock", "logClientBck", "logServiceMocker", "logClientBock", "logServiceManocker", "logServiceManagerocker", "logClientBocker", "logClientMck", "logServiceBocks", "logServiceFocks", "logServiceVOCK", "logServiceMocked", "logServiceFocker", "logServiceFocked", "logModuleManOCK", "logServiceManagerOCK", "logServiceMck", "logClientBOCK", "logModulePick", "logServiceMOCK", "logServiceVocks", "logServiceVocker", "logServicemick", "logServiceManagerock", "logServiceAMocker", "logServiceVock", "logModulePocks", "logServiceAMocked", "logServiceVck", "logServicePocks", "logModulePOCK", "logServiceAMock"], "dbServiceMock": ["dbServiceFOCK", "dbClientFocker", "dbServiceFick", "dbServiceVox", "dbClientMocked", "dbServicesMocker", "dbServiceDock", "dbServiceManick", "dbServicesManox", "dbServiceFox", "dbServiceMOCK", "dbServicesMock", "dbServiceCMocker", "dbServicesMick", "dbServiceCMick", "dbClientMick", "dbServiceCMock", "dbServiceMocked", "dbServicemock", "dbServiceBox", "dbServicesManick", "dbserviceMock", "dbServiceCMocked", "dbClientFick", "dbServiceVocker", "dbServiceManox", "dbServicemox", "dbserviceMox", "dbServiceManocker", "dbServiceDocker", "dbClientMock", "dbserviceMocker", "dbServicemick", "dbServicemocker", "dbServicesManocker", "dbClientMOCK", "dbServiceMick", "dbServicesManock", "dbServiceVOCK", "dbServiceMocker", "dbserviceMOCK", "dbServiceManagerOCK", "dbServiceBock", "dbClientFOCK", "dbClientMocker", "dbServiceManagerocker", "dbServiceManagerock", "dbServiceDick", "dbServiceManagerick", "dbServiceVock", "dbServiceDOCK", "dbServicemocked", "dbServiceManock", "dbServiceMox", "dbServiceVick", "dbServicemOCK", "dbClientFock", "dbservicemox", "dbServicesMox", "dbClientFocked", "dbServiceBocker", "dbservicemOCK", "dbServiceBOCK", "dbServiceFocker", "dbservicemock", "dbservicemocker", "dbServiceFock", "dbServiceFocked"], "user": ["connection", "job", "lock", "profile", "login", "data", "current", "name", "type", "creator", "info", "ee", "per", "class", "log", "rule", "model", "plugin", "blog", "page", "me", "instance", "match", "by", "bug", "account", "key", "client", "member", "usa", "User", "row", "proxy", "real", "db", "api", "or", "project", "object", "role", "other", "config", "pass", "server", "author", "person", "USER", "up", "follow", "result", "token", "resource", "record", "usr", "auth", "you", "use"]}}
{"id1": "20660203", "id2": "17029388", "code1": "    public static void main(String args[]) {\n        int temp;\n        int[] a1 = { 6, 2, -3, 7, -1, 8, 9, 0 };\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < a1.length; i++) {\n            System.out.print(\" \" + a1[i]);\n        }\n    }\n", "code2": "    public static InputStream getConfigIs(String path, String name) throws ProgrammerException, DesignerException, UserException {\n        InputStream is = null;\n        try {\n            URL url = getConfigResource(new MonadUri(path).append(name));\n            if (url != null) {\n                is = url.openStream();\n            }\n        } catch (IOException e) {\n            throw new ProgrammerException(e);\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"temp": ["iter", "f", "current", "Temp", "modified", "mini", "pt", "stable", "m", "emp", "p", "partial", "pi", "k", "str", "cache", "output", "num", "size", "tem", "max", "pre", "e", "test", "count", "style", "source", "z", "t", "parent", "v", "default", "level", "n", "empty", "null", "flat", "c", "index", "prefix", "tc", "adj", "diff", "fake", "length", " Temp", "perature", "tmp"], "a1": ["alphaOne", " a51", "ha2", "aa001", "eOne", "a91", "aa1", "p1", "as4", "an1", "Aone", "hafirst", "A100", "p0", "alphaone", "p2", " a5", "aa91", "A2", "alpha0", "A91", "ama51", "arrayOne", "aone", " a100", "aa2", "e1", "alpha9", " afirst", "ama4", "safirst", "ama127", "a0", "array1", "an5", "a5", " a4", " a9", " a0", "A1", " aOne", "as1", "saOne", "ha100", "alpha4", "ama100", "a127", "e127", "aOne", "alpha2", "an0", "saone", "Afirst", "a001", "as2", "ha1", "A0", "aa4", "a4", "e100", "aa51", "afirst", "A5", "a9", " aone", "an2", "anfirst", "a100", "a2", "an100", " a001", "asone", "A4", "sa5", "a51", " a2", "amaOne", " a127", "alpha1", "sa1", "arrayfirst", "ama1", "aaone", "p4", "array5", "A9", " a91", "AOne", "ama001"], "j": ["x", "ji", "ij", "f", "y", "jj", "bj", "si", "it", "g", "m", "p", "pi", "k", "ind", "bi", "di", "jp", "b", "u", "I", "l", "aj", "ja", "e", "o", "jc", "d", "ci", "z", "js", "J", "h", "ik", "xi", "v", "oi", "li", "n", "ii", "c", "ni", "a", "jl", "length"], "i": ["x", "ji", "f", "y", "si", "it", "ti", "ri", "mini", "slice", "g", "ori", "info", "pi", "ie", "ix", "is", "bi", "I", "u", "b", "di", "jp", "ami", "multi", "qi", "r", "l", "fi", "e", "o", "ini", "abi", "cli", "ci", "anti", "z", "init", "api", "h", "ik", "xi", "ki", "oi", "mi", "ui", "v", "yi", "li", "uri", "ii", "io", "c", "in", "ni", "id", "iu", "index", "vi", "a", "ai", "gi", "phi", "adi", "ip"]}}
{"id1": "810342", "id2": "14609912", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private static String lastModified(URL url) {\n        try {\n            URLConnection conn = url.openConnection();\n            return long2date(conn.getLastModified());\n        } catch (Exception e) {\n            SWGAide.printDebug(\"cach\", 1, \"SWGCraftCache:lastModified: \" + e.getMessage());\n        }\n        return \"0\";\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doversioncheck", "doChangeCheck", "doVersionUpdate", " doVersionUpdate", " doversionScan", " doVersionScan", "doChangecheck", " doVersioncheck", "doFeaturecheck", "doFeatureUpdate", "doversionUpdate", "doChangeUpdate", " doversioncheck", "doFeatureScan", "doFeatureCheck", "doVersionScan", "doChangeScan", " doversionCheck", "doversionScan", "doVersioncheck", "doversionCheck", " doversionUpdate"], "view": ["lock", "self", "container", "edit", "pool", "div", "screen", "see", "review", "update", "out", "html", "gu", "session", "el", "page", "cache", "query", "display", "client", "row", "port", "value", "ui", "group", "up", "fail", "use", "widget", "View", "im", "vis", "model", "vol", "check", "by", "e", "cell", "this", "show", "style", "image", "form", "config", "http", "VIEW", "full", "layout", "manager", "head", "body", "change", "event", "base", "box", "video", "user", "can", "comment", "list", "block", "object", "v", "server", "index", "views", "sel", "input", "window", "ou", "ve", "link"], "url": ["ul", "open", "sl", "f", "loc", "name", "socket", "email", "gl", "stream", "web", "download", "log", "base", "ssl", "bb", "ls", "ll", "blog", "b", "loader", "zip", "l", "bug", "fr", "address", "Url", "buffer", "URL", "source", "image", "builder", "hub", "path", "server", "uri", "null", "browser", "http", "file", "impl", "id", "resource", "www", "host", "link", "location", "length", "rel", "string", "ob"], "in": ["reader", "isin", "sin", "login", "data", "doc", "socket", "s", "ins", "pin", "m", "stream", "cin", "In", "binary", "is", "b", "inner", "again", "rin", "win", "din", "IN", "err", "ini", "buffer", "source", "init", "inc", "nin", "bis", "inn", "file", "as", "lin", "resource", "input", "out", "con", "ac"], "bin": ["reader", "border", "lock", "sin", "login", "socket", "pin", "body", "cin", "bn", "vin", "binary", "bot", "is", "bb", "bi", "b", "loader", "inner", "win", "din", "IN", "ruby", "ini", "abi", "buffer", "lib", "run", "init", "spin", "arin", "ban", "browser", "inn", "oin", "file", "lin", "fin", "input", "out", "record", "con", "gin", "nb"], "line": ["job", "le", "sl", "data", "name", "type", "pin", "range", "el", "ge", "one", "str", "definition", "letter", "log", "base", "lc", "inline", "page", "b", "text", "part", "user", "zip", "l", "val", "e", "cell", "lines", "lf", "key", "ine", "comment", "row", "entry", "block", "parse", "Line", "object", "cl", "code", "nl", "unit", "pe", "jo", "file", "up", "id", "LINE", "word", "lin", "out", "link", "string", "write", "ip", "end", "look"], "version": ["feature", "ver", "name", "support", "type", "dev", "python", "versions", "install", "VERSION", "latest", "download", "release", "plugin", "position", "model", "format", "video", "user", "vert", "section", "bug", "patch", "vision", "pull", "secret", "image", "value", "project", "driver", "v", "update", "server", "unit", "date", "author", "null", "code", "Version", "id", "beta", "cover", "host", "string", "option", "device", "license"], "build": ["lock", "job", "ver", "tag", "get", "mount", "Build", "hold", "how", "building", "boot", "install", "info", "clean", "load", "lease", "release", "log", "add", "built", "bug", "work", "uild", "patch", "pull", "row", "show", "style", "image", "block", "run", "feed", "builder", "update", "unit", "make", "post", "http", "valid", "follow", "help", "home", "print", "link", "rel", "use"]}}
{"id1": "3375718", "id2": "812803", "code1": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"importarHistoricoDeCotacoesDoDolar": [" importarHistoricoDeCotacoesDomD", " importarHistoricoDeCotacoesdoDo", " importarHistoricoDeCotacoesDOd", " importarHistoricoDeCotacosDOD", " importarHistoricoDeCotacoesDomDo", " importarHistoricoDeCotacosDoDo", " importarHistoricoDeCotacosDoDi", " importarHistoricoDeCotacoesDODi", " importarHistoricoDeCotacosDOd", " importarHistoricoDeCotacosDODo", " importarHistoricoDeCotacoesDoDo", " importarHistoricoDeCotacoesDomDi", " importarHistoricoDeCotacoesDOD", " importarHistoricoDeCotacoesDODo", " importarHistoricoDeCotacosDODi", " importarHistoricoDeCotacoesdod", " importarHistoricoDeCotacosDoD", " importarHistoricoDeCotacoesDomd", " importarHistoricoDeCotacoesdoD", " importarHistoricoDeCotacoesDod", " importarHistoricoDeCotacosDod", " importarHistoricoDeCotacoesDoDi", " importarHistoricoDeCotacoesdoDi", " importarHistoricoDeCotacoesDoD"], "pAndamento": ["pButementano", "pAndmente", "pAndiationi", " pAnditecte", "pAndagemento", " pAnditecto", " pANDitecto", "pAndemento", "pAndimentano", "pButmente", "pAndimento", " pAnditectado", " pAndimento", "pNotamentO", " pAndamentO", "pButamente", "pAndiationor", "pAndiationo", "pAndementano", " pAndmente", "pAndeye", " pAndmento", "pButamentor", " pANDitectado", "pAndamentO", "pButementi", "pAndiationO", "pNotimentor", "pButamentano", "pAndimente", "pAndementi", "pNotamento", "pAndmentor", "pAndagementO", " pANDamentO", "pButamento", "pAndemente", "pButemento", "pAndamenti", "pAndeyi", "pAndimentO", "pAndmenti", " pANDitectO", " pANDamente", "pAndagemente", " pAndmentado", " pAndimentO", "pNotamenti", "pNotimento", "pAndeyano", "pNotamentor", "pNotimentO", "pAndeyo", " pANDamentado", "pAndamente", "pButamenti", "pButemente", " pAndimente", "pAndamentor", "pNotimenti", " pAndamentado", " pAndmentO", "pAndimentor", "pButmentor", "pButmento", " pANDitecte", "pAndimenti", "pButmenti", "pAndagementor", " pAnditectO", " pAndamente", " pAndimentado", "pAndagementi", "pAndmento", "pAndamentano", " pANDamento"], "cotacoesPendentesDoDolar": ["cotacoesPendentesDoDiolar", "cotacoesPendentesdoDiollar", "cotacoesPendentesDoSollar", "cotacoesPendentesdoSollar", "cotacoesPendentesDoVSolar", "cotacoesPendentesdoDolar", "cotacoesPendentesDoDoSolar", "cotacoesPendentesDODiolar", "cotacoesPendentesDoVolate", "cotacoesPendentesDoFSolar", "cotacoesPendentesDoDolo", "cotacoesPendentesDOdolar", "cotacoesPendentesDoTSolar", "cotacoesPendentesDoDiolo", "cotacoesPendentesDodolar", "cotacoesPendentesDoDolate", "cotacoesPendentesDoDolic", "cotacoesPendentesdoDolo", "cotacoesPendentesDoFolar", "cotacoesPendentesDoPolar", "cotacoesPendentesdoDSolar", "cotacoesPendentesDoDiolate", "cotacoesPendentesDoDoolo", "cotacoesPendentesdoSolar", "cotacoesPendentesDoSolar", "cotacoesPendentesDODolar", "cotacoesPendentesDoFocal", "cotacoesPendentesDodSolar", "cotacoesPendentesDoDoollar", "cotacoesPendentesDoDocal", "cotacoesPendentesDoTolar", "cotacoesPendentesDOdSolar", "cotacoesPendentesDODSolar", "cotacoesPendentesDoDoolic", "cotacoesPendentesDOdollar", "cotacoesPendentesDodocal", "cotacoesPendentesDoTollar", "cotacoesPendentesdodSolar", "cotacoesPendentesdodollar", "cotacoesPendentesDoPollar", "cotacoesPendentesDoSolo", "cotacoesPendentesDODiolo", "cotacoesPendentesDoSSolar", "cotacoesPendentesDoDiSolar", "cotacoesPendentesDodollar", "cotacoesPendentesDoDiollar", "cotacoesPendentesDoPolic", "cotacoesPendentesDoDSolar", "cotacoesPendentesDodolo", "cotacoesPendentesdoSolo", "cotacoesPendentesdoDollar", "cotacoesPendentesdodolar", "cotacoesPendentesDoDiolic", "cotacoesPendentesDoPolo", "cotacoesPendentesDoTolo", "cotacoesPendentesdoDiSolar", "cotacoesPendentesdodolate", "cotacoesPendentesDODolic", "cotacoesPendentesdoSSolar", "cotacoesPendentesDODollar", "cotacoesPendentesdoDiolar", "cotacoesPendentesDODiolic", "cotacoesPendentesDODiollar", "cotacoesPendentesDOdolo", "cotacoesPendentesdoDiocal", "cotacoesPendentesDoVollar", "cotacoesPendentesDODolo", "cotacoesPendentesDoDollar", "cotacoesPendentesDoVolar", "cotacoesPendentesDoDoolar", "cotacoesPendentesDodolate", "cotacoesPendentesdoDocal", "cotacoesPendentesDoFollar", "cotacoesPendentesDoDiocal", "cotacoesPendentesdoDolate"], "sql": ["lock", "sl", "statement", "su", "QL", "util", "sg", "data", "values", "where", "dl", "s", "database", "dd", "seed", "string", "el", "mt", "str", "spr", "local", "utils", " SQL", "expression", "log", "ssl", "SQL", "ls", "base", "pr", "b", "model", "math", "models", "csv", "html", "repl", "l", "query", "zip", "shell", "fr", "parser", "lang", "expr", "sq", "comment", "storage", "select", "db", "api", "spec", "serial", "object", "general", "nl", "sol", "orm", "http", "details", "params", "ql", "es", "fp", "aws", "rl", "pg", "software", "json", "insert", "types", "il"], "stmtDestino": ["stmtDistinos", "stordestaco", "stordestini", "stmtdestINO", "stmtOrdin", "stctDestining", "stmdestro", "stmbRestino", "stmtStino", "stmbRestorno", "stmtRestino", "stmtDocin", "stmDestro", "stctOrdino", "stmbDestini", "stmtRestro", "stmtStination", "stordestinos", "stmtDistINO", "stmtDestini", "stmtDocining", "stmtdestaco", "stmtDestaco", "stmtCombinos", "stmbDestINO", "stctOrdination", "stmtOrdination", "stmtRestINO", "stmtDistino", "stctOrdining", "stmtOrdino", "stmtDestining", "stmtdestinos", "stmtDestinos", "stmDestINO", "stmdestINO", "stmtdestino", "stctDestination", "stptdestINO", "stptDestINO", "stctDestino", "stmtOrdining", "storDestinos", "stmtDestination", "stmtDestin", "stmtDocino", "stmtRestini", "stmtDocination", "storDestino", "stctDestin", "stmtCombino", "stmtdestorno", "stptdestinos", "stmdestino", "stctOrdin", "stptdestino", "stmdestinos", "stmtStorno", "stmtStINO", "stmtDistro", "stptDestinos", "stmbDestino", "stmtRestinos", "storDestini", "stmDestinos", "stmtStining", "stmtCombini", "stmtDestINO", "stmbRestini", "storDestaco", "stmtDistini", "stmbRestINO", "stmtCombaco", "stmtStin", "stmtStini", "stmtdestro", "stmtDestorno", "stordestino", "stmtdestini", "stptDestro", "stptdestro", "stmDestino", "stptDestino", "stmtRestorno", "stmbDestorno", "stmtDistaco", "stmtDestro"], "quantidadeDeRegistrosASeremImportados": ["quantidadeDeRegistrosSeremimportados", "quantidadeDeRegistrosSeremPortada", "quantidadeDeRegistrosSeremPortado", "quantidadeDeRegistrosSeremsPortada", "quantidadeDeRegistrosSeremsImportadas", "quantidadeDeRegistrosSeremsPortadas", "quantidadeDeRegistrosSeremPortadas", "quantidadeDeRegistrosSeremImportadas", "quantidadeDeRegistrosSeremimportado", "quantidadeDeRegistrosSeremortadas", "quantidadeDeRegistrosSeremsImportados", "quantidadeDeRegistrosSeremimportadas", "quantidadeDeRegistrosSeremsPortado", "quantidadeDeRegistrosSeremsImportado", "quantidadeDeRegistrosSeremortada", "quantidadeDeRegistrosSeremsPortados", "quantidadeDeRegistrosSeremortados", "quantidadeDeRegistrosSeremsImportada", "quantidadeDeRegistrosSeremortado", "quantidadeDeRegistrosSeremImportada", "quantidadeDeRegistrosSeremImportado", "quantidadeDeRegistrosSeremimportada", "quantidadeDeRegistrosSeremPortados", "quantidadeDeRegistrosSeremImportados"], "quantidadeDeRegistrosImportados": ["quantidadeDeRegistronsImportants", "quantidadeDeRegistrosImportants", "quantidadeDeRegistrosOperadas", "quantidadeDeRegistrosOperants", "quantidadeDeRegistrosInstos", "quantidadeDeRegistrosImos", "quantidadeDeRegistrosImadas", "quantidadeDeRegistrosImants", "quantidadeDeRegistrosOperos", "quantidadeDeRegistrosInstadas", "quantidadeDeRegistronsOperadas", "quantidadeDeRegistronsOperos", "quantidadeDeRegistrosImados", "quantidadeDeRegistronsImportos", "quantidadeDeRegistronsImportadas", "quantidadeDeRegistrosImportadas", "quantidadeDeRegistrosImportos", "quantidadeDeRegistrosOperados", "quantidadeDeRegistronsImportados", "quantidadeDeRegistrosInstants", "quantidadeDeRegistronsOperados", "quantidadeDeRegistrosInstados", "quantidadeDeRegistronsOperants"], "numeroDoRegistro": ["numeroDoRegistsrob", "numeroDoTagistsros", "numeroDoRegostros", "numeroDoRegastron", "numeroDoRegisterro", "numeroDoRegastros", "numeroDoregistros", "numeroDoRegisterrob", "numeroDoRegestrar", "numeroDoRegistsro", "numeroDoTagistsrar", "numeroDoTagistsro", "numeroDoregistro", "numeroDoTagistros", "numeroDoRegisterros", "numeroDoRegistsros", "numeroDoRegistrob", "numeroDoRegestro", "numeroDoregistron", "numeroDoRegastr", "numeroDoRegestron", "numeroDoRegistron", "numeroDoregastr", "numeroDoregastron", "numeroDoRegostron", "numeroDoRegistsrar", "numeroDoregastros", "numeroDoregistr", "numeroDoRegastro", "numeroDoRegestros", "numeroDoTagistsrob", "numeroDoTagistrob", "numeroDoRegistr", "numeroDoRegostr", "numeroDoTagistro", "numeroDoRegistrar", "numeroDoRegostro", "numeroDoRegestr", "numeroDoRegestrob", "numeroDoTagistrar", "numeroDoRegisterrar", "numeroDoRegistros", "numeroDoregastro"], "cotacaoPendenteDoDolar": ["cotacaoPendenteDoSublic", "cotacaoPendenteDoPolar", "cotacaoPendenteDoTolic", "cotacaoPendenteDoPollar", "cotacaoPendenteMoDIR", "cotacaoPendenteDoCSolar", "cotacaoPendenteDoSSolar", "cotacaoPendentePiDolic", "cotacaoPendenteMoSollar", "cotacaoPendenteDoTolar", "cotacaoPendenteDoLiscal", "cotacaoPendenteDoMolic", "cotacaoPendenteMoDolo", "cotacaoPendenteDoDIR", "cotacaoPendenteDoLollar", "cotacaoPendenteDoCollar", "cotacaoPendenteDODolar", "cotacaoPendenteDoDiscal", "cotacaoPendenteMoSSolar", "cotacaoPendenteDoSolo", "cotacaoPendenteMoSIR", "cotacaoPendenteDOSSolar", "cotacaoPendenteDOSolo", "cotacaoPendenteDoColar", "cotacaoPendenteDODublic", "cotacaoPendenteDoTIR", "cotacaoPendenteDoPolic", "cotacaoPendenteDoDublic", "cotacaoPendenteDodolo", "cotacaoPendenteMoDolar", "cotacaoPendenteDoMolar", "cotacaoPendenteDoCIR", "cotacaoPendenteDoLolo", "cotacaoPendenteDoLolar", "cotacaoPendenteDoIolar", "cotacaoPendentePidolic", "cotacaoPendenteDodolar", "cotacaoPendentePiDolar", "cotacaoPendenteDoISolar", "cotacaoPendenteDodiscal", "cotacaoPendentePidollar", "cotacaoPendenteMoDolic", "cotacaoPendentePiDollar", "cotacaoPendentePiDolan", "cotacaoPendenteMoSolic", "cotacaoPendenteDoSolar", "cotacaoPendenteDoTolan", "cotacaoPendenteMoSiscal", "cotacaoPendenteDoSiscal", "cotacaoPendenteDoPSolar", "cotacaoPendenteMoDollar", "cotacaoPendenteDODSolar", "cotacaoPendenteDOSublic", "cotacaoPendenteDOSolar", "cotacaoPendenteDoDolan", "cotacaoPendenteDoDollar", "cotacaoPendenteDoDSolar", "cotacaoPendenteMoDiscal", "cotacaoPendenteDoDolic", "cotacaoPendenteDoSolic", "cotacaoPendenteDoTSolar", "cotacaoPendenteDoIolo", "cotacaoPendenteDODolo", "cotacaoPendenteDodolan", "cotacaoPendenteDoIublic", "cotacaoPendentePidolan", "cotacaoPendenteDoDolo", "cotacaoPendenteMoDSolar", "cotacaoPendenteDoPublic", "cotacaoPendenteDoTollar", "cotacaoPendenteDoPolo", "cotacaoPendenteDoMollar", "cotacaoPendenteMoSolar", "cotacaoPendenteDoMolan", "cotacaoPendenteDodolic", "cotacaoPendenteDoSIR", "cotacaoPendenteDodollar", "cotacaoPendenteDoSollar", "cotacaoPendenteMoSolo", "cotacaoPendentePidolar"], "ano": ["osa", "office", "ado", "anos", "oa", "illo", "ilo", "amia", "asio", "lo", "auto", "ana", "umo", "ara", "uto", "ago", "ko", "ono", "antis", "ania", "iana", "amo", "ato", "aro", "rano", "ao", "anto", "aldo", "mi", "oda", "obo", "oni", "rio", "aho", "lio", "iso", "uno", "ardo", "zo", "ane", "alia", "erno", "oshi"], "mes": ["mx", "mr", "ens", "las", "mails", "MS", "ims", "ma", "mor", "ae", "sem", "me", "ls", "mers", "les", "mins", "ums", "phis", "lia", "mie", "la", "mer", "pins", "nas", "mis", "ails", "ems", "mos", "nis", "mi", "mot", "des", "mus", "es", "mc", "lis", "ms", "los", "Ms", "nes", "nos", "ME", "ses", "mol"], "dia": ["Dias", "ndias", "Dica", "dIA", "DIA", "d\u00eda", " dria", "dica", " dIA", "Dria", "dsica", "Dia", " d\u00eda", " dias", "dria", "ndia", "dias", "D\u00eda", "dsIA", " dica", "dsia", "nd\u00eda", "dsria", "ndica"], "calendario": ["calendingri", "calpendiry", "Calendedaro", "calentasio", "calendarius", "Calendedillo", "calentazon", "calendazon", "calenasio", "calentiry", "calpendario", "calENDarius", "calendado", " recalentado", "Calendaro", "calmentri", "Calendedario", "calendingazon", "calenar", "calenierra", "Calendillo", "Calendedarius", "calENDierra", "calendingado", "calpendarius", "calendedarius", "caladario", "calmentado", "calmentario", "calendingaro", "calmentazon", "calENDaro", "calendingillo", "calendedario", "palenierra", "calendar", "calpendasio", "palendierra", "calandasio", "calentario", "calENDario", "calandario", "caladiry", "palenar", " recalendri", "calenario", "Caladasio", "calandar", "palenario", " recalentazon", "calENDar", "palendar", "calENDillo", "calendasio", "calendedaro", "caladasio", "calendaro", "palenasio", "calENDasio", "Calendasio", "Caladario", "calendiry", "calendillo", "Caladarius", "calendedillo", " recalentri", "calendierra", "calendri", "calandierra", " recalentario", " recalendario", "palendario", "palendasio", "Calendario", "calendingario", "calentado", "calentri", "calentarius", "Caladiry", "Calendiry", "calendingarius", "Calendarius", "caladarius", " recalendado", " recalendazon"], "vDATA": [" vdata", "VDEF", "hData", "Vdata", "VData", "jData", "hDATA", "VDATA", "VATA", " vATA", "vData", " vDEF", " vData", "jDEF", "hATA", "vATA", "hdata", "vDEF", "jATA", "jDATA", "vdata"], "vPRECO": ["vPreDO", "vPreCo", "vPDO", "fPreDO", "vPACo", "vPCO", "vPreCON", "vPRECo", "fPreCO", "fPRECO", "vPRECON", "vPADO", "vPACON", "fPreCON", "vPCo", "fPRECON", "vPREDO", "fPRECo", "fPREDO", "vPCON", "vPACO", "fPreCo", "vPreCO"]}}
{"id1": "7044153", "id2": "18974466", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendExceptionWithserver", "sendExceptiontoHost", "sendExceptiontoServer", "sendExceptionWithServer", "sendErrorToserver", "sendExceptionToService", "sendExceptionAsHost", "sendExceptionAsserver", "sendErrorToService", "sendErrortoHost", "sendExceptionAsService", "sendExceptionToserver", "sendExceptionWithHost", "sendErrortoService", "sendErrortoserver", "sendErrorToServer", "sendErrorToHost", "sendExceptionAsServer", "sendExceptionToHost", "sendErrortoServer", "sendExceptiontoService", "sendExceptiontoserver", "sendExceptionWithService"], "server": ["email", "base", "erver", "ssl", "Server", "conf", "domain", "root", "client", "address", "test", "proxy", "service", "db", "port", "ser", "null", "http", " host", "prefix", "header", "host", "addr", "serv", "ip", "json"], "ex": ["x", "full", "su", "ext", "Ex", "ception", "error", "rupt", "aux", "nex", "rex", "event", "str", "Exc", "hex", "log", "class", "status", "base", " exc", "throw", "sex", "export", "err", "ax", "exc", "e", "temp", "acer", "pex", "lex", "example", "exec", "exit", "cl", "except", "fail", "con", "res", "Exception", "def", "exp", "none", "re", "ace", "tx", "obj", "EX"], "config": ["connection", "app", "cb", "ext", "Conf", "options", "settings", "proc", "rc", "log", "base", "text", "conf", "cmd", "bug", "etc", "client", "address", "console", "service", "cfg", "Configuration", "file", "Config", "json"], "prob": ["pebe", "peb", "Probe", "pebs", "Proj", "Probs", " probs", "probe", "proj", "Prob", "probs", " probe", " proj", "pej"], "dataSB": ["dataBL", "uiEl", "execBB", "offLB", "pSB", "innerLB", "DataFB", "errorBB", "contentsb", "nosb", "codeEB", "uiSB", "noSB", "workBB", "eventSB", "strLB", " dataEB", "controlBL", "dataRB", "datasb", "ifsb", "postLB", "ifSL", "postSB", "fileSB", "fullLB", " dataLB", "DataBL", "innersb", "cachesb", "filesb", " dataFB", "errorEB", "datLB", "DataBB", "contentLB", "cacheSB", "datSB", "codeSB", " dataBB", "execBL", "errorPB", "responseLB", "errorSL", "responseSB", "ifLB", "codeLB", "DataLB", "cacheLB", "controlsb", " dataBL", "eventSL", "execLB", "dataBs", "offsb", "fullBB", "DataSL", "DataHL", "DataOB", "loadBB", "datBB", "noSL", "codeRB", "fullBL", "loadSB", "Datasb", "dataOB", "loadsb", "defaultBB", "dataFB", "offSB", "dataEB", "datOB", "responseBL", "offBB", "uiLB", "eventLB", "defaultSB", "codeMB", "dataBB", "eventBB", "workSB", "loadLB", "codeHL", "contentOB", "codeBB", "postsb", "workPB", "innerSB", " dataPB", "fileLB", "DataRB", "errorOB", "strsb", "controlLB", "postSL", "dataSL", "DataSB", "defaultLB", "errorLB", "errorsb", "execsb", "pLB", " dataBs", " dataEl", " dataRB", " dataOB", "dataHL", "innerSL", "offSL", "DataMB", "noLB", "defaultsb", "dataLB", "controlBB", "ifSB", "fileSL", "errorSB", "pBs", " dataMB", "dataEl", "contentSB", "codesb", "codeBs", "codeFB", "codeEl", "strSB", " datasb", "controlSB", "responseBB", " dataHL", "execSB", "psb", " dataSL", "cacheBL", "dataPB", "workSL", "strSL", "dataMB", "fullSB"], "trace": ["trip", "profile", "data", "tri", "scale", "error", "type", "ctr", "span", "string", "array", "stack", "info", "xml", "log", "ptr", "cache", "r", "bug", "trans", "err", "e", "flow", "bean", "address", "temp", "race", "track", "buffer", "test", "atter", "t", " debug", " tracing", "details", "shadow", " traced", "message", "debug", "tr", "result", "out", "cover", "fake", "report", "ace", "tx", " traces", "strip", "runner", "ray"]}}
{"id1": "10728243", "id2": "1986417", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    @Override\n    public void export(final Library lib) throws PluginException {\n        try {\n            new Thread(new Runnable() {\n\n                public void run() {\n                    formatter.format(lib, writer);\n                    writer.flush();\n                    writer.close();\n                }\n            }).start();\n            ftp.connect(host);\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                ftp.disconnect();\n                throw new PluginException(\"Unable to connect to FTP\");\n            }\n            ftp.login(user, pass);\n            ftp.pasv();\n            ftp.changeWorkingDirectory(dir);\n            ftp.storeFile(file, inStream);\n            ftp.logout();\n        } catch (SocketException e) {\n            throw new PluginException(e);\n        } catch (IOException e) {\n            throw new PluginException(e);\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"scramble411": ["scramprint411", "screamprint411", "screamble123", "screamprint41", "screamble5", "screamprint123", "screamprint5", "scramble5", "scramble41", "scramcy41", "scramprint5", "scramprint123", "screamble411", "scrambe5", "scramcy123", "scramble123", "scrambe41", "scramcy5", "scrambe123", "screamble41", "scrambe411", "scramprint41", "scramcy411"], "password": ["wallet", "name", "channel", "email", "wd", "sudo", "words", "user", "Password", "mac", "account", "key", "address", "secret", "crypt", "padding", "sword", "project", "phrase", "PASS", "hash", "path", "filename", "attribute", "sum", "config", "number", "pass", "dh", "word", "prefix", "token", "input", "pad", "security", "auth", "string", "username"], "seed": ["offset", "volume", "Salt", "finger", "name", "machine", "slice", "pair", "state", "mode", "sudo", "text", "size", "zip", "alias", "key", "random", "address", "secret", "crypt", "padding", "source", "template", "driver", "phrase", "hash", "pattern", "prime", "sum", "pass", "shadow", "id", "prefix", "eed", "token", "pad", "length", "string", "device", "username"], "md": [" Md", "bm", "meta", "df", "bd", "vd", "doc", "mag", "mg", "cd", "addr", "rm", "wd", "ds", "grad", "mad", "dd", "m", "ma", " MD", "mt", "mode", "ind", "ld", "kg", "dig", "di", "mid", "om", "mb", "ht", "am", "part", "mac", "hm", "cmd", "dm", "mn", "sm", "d", "dc", "MD", "km", "gd", "mo", "diff", "amd", "mi", "mp", "metadata", "mm", "pm", "dh", "sha", "po", "cm", "mem", "mc", "nd", "ms", "pd", "mand", "ad", "od", "hd", "nm", "Cmd", "pkg"], "passwordHashStage1": ["passwordSumStage1", "passwordSumPhase1", "passwordHashPhaseOne", "passwordSumStage0", "passwordHashstage3", "passwordHashstage4", "passwordHashstage0", "passwordSumStage4", "passwordSumPhase2", "passwordSumPhase4", "passwordHashPhase0", "passwordHashPhase4", "passwordHashStageOne", "passwordSumStage3", "passwordHashStep3", "passwordHashStep1", "passwordHashStep2", "passwordSumPhase3", "passwordHashstage2", "passwordSumStage2", "passwordHashstage1", "passwordSumPhaseOne", "passwordSumPhase0", "passwordHashPhase1", "passwordHashPhase2", "passwordHashPhase3", "passwordHashStage4", "passwordHashstageOne", "passwordSumStageOne", "passwordHashStage3", "passwordHashStage0"], "passwordHashStage2": ["passwordHashStage02", "passwordSumStage1", "passwordSumPhase1", "passwordSumStageTwo", "passwordHashStage8", "passwordBlockStage1", "passwordBlockStage4", "passwordBlockstage4", "passwordHashstage8", "passwordBlockstage2", "passwordHashstage4", "passwordBlockStage8", "passwordHashStep4", "passwordSumPhase2", "passwordSumStage02", "passwordHashPhase8", "passwordHashStageTwo", "passwordHashPhase02", "passwordHashPhase4", "passwordBlockStage2", "passwordHashstage02", "passwordHashstageTwo", "passwordHashStep1", "passwordHashStep2", "passwordHashstage2", "passwordSumStage2", "passwordHashstage1", "passwordHashPhaseTwo", "passwordBlockstage1", "passwordHashPhase1", "passwordHashStep8", "passwordSumPhaseTwo", "passwordHashPhase2", "passwordBlockstage8", "passwordHashStage4", "passwordSumPhase02"], "toBeXord": ["tobeXorder", "toBeCrossor", "toBeZorder", "toBeWorkors", "tobeYors", "toBeXords", "toBEYord", "toBeXor", "toBeXors", "toBeZors", "toBEYORD", "toBeCrossords", "toBeZor", "toBEXords", "toBeYorder", "tobeXords", "tobeYorder", "toBeWorkord", "toBEXORD", "toBEYor", "toBeXorder", "toBeCrossord", "toBeYord", "tobeYord", "tobeXors", "tobeXord", "tobeCrossords", "toBEXord", "tobeCrossor", "toBeWorkords", "toBeXORD", "toBeYors", "toBeWorkORD", "toBeCrossors", "tobeCrossord", "tobeYor", "toBeZORD", "toBeWorkorder", "toBeYor", "toBeYords", "toBeCrossORD", "toBEYords", "toBeWorkor", "toBeZords", "toBEXor", "tobeXor", "tobeCrossors", "toBeZord", "toBeYORD"], "numToXor": ["numToXors", "numToXOr", "numToCrossOr", "num2XOr", "numToxOR", "numToWorkOR", "numToAbsorer", "numtoXors", "numtoxorer", "numToXOR", "num2Xorer", "numToAbsor", "numtoxor", "numToxors", "numToAnyOR", "numtoxOR", "numToAbsOR", "num2AbsOr", "num2XOR", "numtoxors", "numToAnyorer", "numToWorkors", "numToXorer", "numToWorkor", "num2AbsOR", "numToWorkorer", "numToCrossor", "numToCrossors", "numtoXorer", "numtoXOR", "numToxor", "numToAnyOr", "numToCrossorer", "num2Xor", "numToxorer", "numToAbsOr", "num2Absorer", "numToAnyor", "num2Absor", "numtoXor", "numToCrossOR"], "i": ["x", "f", "y", "si", "it", "ti", "ri", "slice", "m", "p", "j", "info", "pi", "k", "ix", "hi", "I", "di", "u", "b", "part", "multi", "bi", "qi", "l", "r", "e", "o", "key", "off", "abi", "d", "ci", "z", "t", "h", "xi", "v", "oi", "ui", "li", "uri", "n", "ii", "io", "c", "in", "id", "index", "chi", "a", "ai", "gi", "ip"]}}
{"id1": "21368981", "id2": "8815137", "code1": "    public APIResponse create(Application application) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/application/create\").openConnection();\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n        connection.setUseCaches(false);\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\")));\n        connection.getOutputStream().flush();\n        connection.getOutputStream().close();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine()));\n            response.setDone(true);\n            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));\n            connection.getInputStream().close();\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Create Application Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "label": 0, "substitutes": {"create": ["save", "open", "get", "complete", "type", "send", "setup", "add", "construct", "call", "run", "api", "request", "Create", "process", "POST", "creat", "delete", "update", "post", "make", "message", "execute", "write", "start"], "application": ["x", "app", "current", "name", "version", "database", "android", "audio", "apache", "language", "array", "layer", "xml", "expression", "base", "class", "component", "page", "Application", "video", "instance", "output", "bean", "address", "external", "service", "api", "project", "request", "object", "system", "attribute", "config", "document", "unit", "http", "a", "message", "resource", "apply"], "response": ["answer", "data", "tree", "ception", "manager", "version", "error", "handler", "respond", "session", "reference", "ae", "Response", "status", "position", "model", "description", "more", "part", "user", "page", "output", "success", "writer", "collection", "client", "reply", "service", "entry", "image", "feed", "api", "example", "request", "value", "object", "next", "offer", "document", "view", "server", "esi", "http", "function", "index", "message", "result", "resource", "host", "report", "onse", "json", "dict", "resp", "site"], "connection": ["office", "statement", "current", "version", "machine", "channel", "creator", "operation", "wrapper", "section", "creation", "cli", "source", "url", "number", "uri", "io", "function", "message", "directory", "socket", "error", "session", "handler", "log", "position", "conn", "cache", "inner", "entity", "bug", "query", "engine", "client", "connected", "builder", "environment", "character", "context", "document", "Connection", "communication", "bc", "node", "union", "loc", "database", "remote", "command", "reference", "expression", "component", "part", "writer", "collection", "image", "connect", "config", "relation", "location", "network", "graph", "manager", "event", "timeout", "text", "translation", "password", "proxy", "condition", "entry", "object", "ion", "system", "server", "link"], "obj": ["active", "cdn", "data", "oa", "bj", "arr", "body", "j", "info", "ns", "art", "conn", "b", "part", "output", "txt", "r", "line", "aj", "o", "list", "map", "Obj", "ctx", "js", "objects", "object", "ass", "obo", "code", "n", "tmp", "ose", "rt", "co", "po", "result", "res", "out", "adj", "coll", "so", "json", "nb", "ob", "resp", "act"]}}
{"id1": "20623709", "id2": "20991673", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public NodeId generateTopicId(String topicName) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"No SHA support!\");\n        }\n        if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName);\n        md.update(topicName.getBytes());\n        byte[] digest = md.digest();\n        NodeId newId = new NodeId(digest);\n        return newId;\n    }\n", "label": 0, "substitutes": {"split": ["open", "archive", "sync", "sort", "set", "match", "add", "copy", "format", "part", "share", "cmp", "parse", "build", "init", "run", "process", "exec", "Split", "delete", "update", "transfer", "diff", "join", "append", "execute", "start"], "targetDirectory": ["targetRoot", "targetFile", " targetRoot", " targetFolder", "destDir", "masterDir", "baseFile", "outputFile", "currentRoot", " targetFile", "targetDatabase", "masterDatabase", "TargetDir", "targetDir", "outputDir", "currentFolder", " targetPath", "basePath", "baseDatabase", "currentPath", "masterDirectory", "TargetDirectory", "TargetDatabase", "baseFolder", "TargetRoot", "baseDir", "TargetFolder", "targetPath", "destFile", " targetDir", "TargetPath", "destFolder", "masterPath", "TargetFile", "baseDirectory", "currentDir", "outputFolder", "currentDirectory", "outputDirectory", "destDirectory", "targetFolder"], "prefix": ["offset", "FIX", "sequence", "fixed", "name", "type", "first", " suffix", "timeout", "base", "ix", "prot", "format", "resolution", "cache", "Pref", "domain", "txt", "pre", "root", "patch", "temp", "padding", "template", "path", "filename", "pattern", "config", "number", "uri", "unit", "folder", "fix", "index", "resource", "queue", "append", "fp", "directory", "string", "username"], "maxUnitBases": ["maxUnitAliases", "maxUnitEaches", "maxunitBails", "maxunitBaches", "maxUnitChasing", "maxUnitChase", "maxUnitQueasing", "maxUnitAliails", "maxunitAliasing", "maxunitAliues", "maxUnitAliase", "maxunitAliaches", "maxunitAliase", "maxUnitQueues", "maxUnitEails", "maxUnitPlases", "maxUnitEase", "maxunitBues", "maxUnitQueases", "maxUnitPlaches", "maxUnitPlails", "maxUnitQuease", "maxUnitChases", "maxUnitBaches", "maxUnitAliaches", "maxUnitPlase", "maxUnitEases", "maxunitAliails", "maxUnitChues", "maxUnitBues", "maxUnitAliues", "maxUnitBasing", "maxunitBases", "maxunitBase", "maxunitBasing", "maxUnitBails", "maxunitAliases", "maxUnitBase", "maxUnitAliasing"], "maxUnitEntries": ["maxUnitIntrys", "maxUnitOrdries", "maxUnitEntryies", "maxUnitOrdry", "maxUnitAddry", "maxUnitCountrations", "maxUnitOrdies", "maxUnitEntryresses", "maxUnitEntines", "maxUnitCountry", "maxUnitEntrys", "maxunitEntryrys", "maxLineEntries", "maxLineOrdrations", "maxUnitEntures", "maxunitEntries", "maxunitEnties", "maxUnitEntry", "maxUnitAddresses", "maxLineOrdry", "maxUnitIntries", "maxUnitIntresses", "maxUnitAddries", "maxUnitEnties", "maxunitEntryies", "maxUnitEntrations", "maxUnitEntresses", "maxUnitEntryures", "maxUnitErry", "maxLineEntrations", "maxUnitOrdresses", "maxunitEntryresses", "maxLineOrdines", "maxUnitCountines", "maxUnitEntryrys", "maxunitEntrys", "maxUnitCountries", "maxUnitOrdrys", "maxUnitAddures", "maxLineOrdries", "maxUnitOrdrations", "maxUnitErries", "maxLineEntry", "maxUnitInties", "maxLineEntines", "maxUnitOrdines", "maxUnitEntryries", "maxUnitErines", "maxUnitEntryry", "maxUnitErrations", "maxunitEntryries", "maxunitEntresses"], "fis": [" fai", "fiss", "forisc", " fris", "fisa", " fisa", "foriss", "fai", "forris", "forai", "forIs", "fIs", "vis", " fIs", "Fis", "vIs", "forisa", " fisc", "vai", "Fiss", "visa", " fiss", "foris", "fris", "Fris", "Fisc", "fisc"], "fci": ["Fco", "Fci", "efci", "bai", " fai", "fii", "vci", "hco", "Foci", "fai", "bci", "foci", "hai", " fii", "Fis", "efai", "hci", "Fai", "vai", "fcos", "dci", "bis", "dii", "hcos", "efco", "efcos", "bco", "Fii", "vcos", "vco", "dco", "doci", " foci"], "fos": ["fscos", "ifios", " fcos", "ifo", "fsos", "fsios", "fso", "ifos", "Foes", "foes", "infoss", "toes", "Fis", "infoes", "infos", "fcos", "Foss", "foss", "tis", "tos", "toss", "fios", "Fos", " fo", " fios", "fo", "infis", "ifcos"], "fco": ["Fco", "Fci", "dcos", "hco", "fbo", " fcos", "hgo", "fgo", "fileico", " fico", "lci", "lro", "fileci", "lcos", "fro", "hci", " fbo", "Fico", "fcos", "dci", "fico", "hcos", "lgo", "dro", "Fbo", "filebo", "dco", "fileco", "lco", " fgo", " fro"], "buffer": ["offset", "bin", "border", "reader", "uffer", "iter", "data", "texture", "scale", "channel", "batch", "reference", "layer", "buff", "info", "Buffer", "timeout", "zero", "counter", "binary", "base", "expression", "position", "copy", "cache", "loader", "size", "callback", "writer", "capacity", "translation", "flush", "bar", "entry", "block", "comment", "image", "feed", "source", "request", "response", "context", "transfer", "document", "server", "pause", "view", "null", "rate", "read", "memory", "message", "queue", "resource", "header", "result", "pad", "length", "window", "input", "bc", "device", "buf"], "currentBasesCount": ["currentBatchesNum", "currentChasesCounter", "currentChaseNum", "currentBasesNum", "currentChaseCounter", "currentBaseCounter", "currentChaseCount", "currentChasecount", "currentBasescount", "currentChasesCount", "currentBatchescount", "currentBasingCount", "currentBasingcount", "currentBaseNum", "currentBaseCount", "currentBasingCounter", "currentBatchesCount", "currentBatchesCounter", "currentBasingNum", "currentChasesNum", "currentBasecount", "currentBasesCounter", "currentChasescount"], "currentEntriesCount": ["currentEntursSize", "currentAddriesCount", "currentEntursCount", "currentEntriesSize", "currentAdduresSize", "currentAdduresLimit", "currentEntrasCount", "currentAdduresOffset", "currentAdduresCount", "currentEnturesCount", "currentAddriesSize", "currentEntriesOffset", "currentEntrasSize", "currentEnturesLimit", "currentEntrasLimit", "currentEntursLimit", "currentEntrasOffset", "currentAddriesOffset", "currentEnturesSize", "currentEntriesLimit", "currentAddriesLimit", "currentEntursOffset", "currentEnturesOffset"], "targetCount": ["TargetSum", "argetSize", "patterncount", "patternSize", "argetcount", "TargetSize", "targetcount", "targetSize", "argetSum", "patternCount", "argetCount", "TargetCount", "targetSum", "patternSum", "Targetcount"], "fastaChannel": ["fastasColumn", "fastanContainer", "fastaqColumn", "fastaqConnection", "fastaContext", " fastABuffer", " fastaContainer", " fastaConnection", "fastAConnection", " fastaContext", "fastaqChannel", "fastAContext", "fastasContext", "fastasConnection", "fastaContainer", "fastABuffer", "fastanBuffer", " fastAColumn", "fastasBuffer", " fastAContainer", "fastanContext", "fastAContainer", "fastaqBuffer", " fastAChannel", " fastAContext", "fastAColumn", "fastaConnection", "fastaColumn", "fastAChannel", "fastanChannel", "fastasContainer", " fastAConnection", " fastaColumn", "fastasChannel"], "totalSeqCount": ["totalSeqCounter", "totalQueqcount", "totalSeQCount", "totalQueQcount", "totalSeqcount", "totalSeqsCounter", "totalSeQcount", "totalSeqsCount", "totalSeuxcount", "totalQueQCount", "totalSeqscount", "totalSeuxCount", "totalSeqNum", "totalQueQNum", "totalSeQCounter", "totalSeuxNum", "totalSeuxCounter", "totalQueqCount", "totalQueqNum", "totalQueqCounter", "totalSeQNum", "totalQueQCounter", "totalSeqsNum"], "totalResiduesCount": ["totalResiduingSize", "totalResiduationcount", "totalResiduesNum", "totalResiduingNum", "totalResiduresSize", "totalResiduresCount", "totalResiduationSize", "totalResiduingcount", "totalResiduingCount", "totalResqueurescount", "totalResqueuresCount", "totalResqueuesCount", "totalResqueuescount", "totalResiduescount", "totalResiduationCount", "totalResqueuesSize", "totalResiduesSize", "totalResiduationNum", "totalResidurescount", "totalResiduresNum", "totalResqueuresNum", "totalResqueuesNum", "totalResqueuresSize"], "prevTime": ["PrevFile", " prevFile", "prevFile", " prevValue", " prevSize", "PrevValue", "commitTime", "PrevSize", "PrevTime", "prevSize", "commitFile", "commitSize", "commitValue", "prevValue"], "fastaFileSize": ["fastasFileName", "fastAFileCount", "fastaPageName", "fastaLineLength", "fastaPageAddress", "fastaFilesSize", "fastaBufferCount", "fastaFilesAddress", "fastABufferSize", "fastAFileAddress", "fastaHeaderAddress", "fastABufferCount", "fastaLineCount", "fastaBlockLength", "fastasFileSize", "fastaPageSize", "fastasHeaderSize", "fastasFileAddress", "fastaHeaderSize", "fastABufferAddress", "fastaFileAddress", "fastaFileName", "fastaFileCount", "fastasHeaderLength", "fastaBlockSize", "fastaFilesLength", "fastaFileLength", "fastaHeaderName", "fastaBlockAddress", "fastaBufferAddress", "fastaPageLength", "fastABufferLength", "fastaBufferSize", "fastaLineAddress", "fastasFileLength", "fastaHeaderLength", "fastasHeaderAddress", "fastaLineSize", "fastAFileSize", "fastaBlockCount", "fastAFileLength", "fastaFilesName", "fastasHeaderName", "fastaBufferLength"], "fastaFileReadOffset": ["fastaFileWriteOff", "fastaFileWriteoffset", "fastaBufferReadAmount", "fastaDirectoryWriteOff", "fastaFileLoadLength", "fastaFileRunoffset", "fastaFilesReadoffset", "fastaFilereadOff", "fastaFilesWriteOffset", "fastaFilereadoffset", "fastaBufferWriteOffset", "fastaFilereadOffset", "fastaBufferWriteoffset", "fastaFileStartOff", "fastaBufferReadoffset", "fastaFileLengthoffset", "fastaFileReadAmount", "fastaFileLoadOffset", "fastaDirectoryWriteOffset", "fastaFileRunEntry", "fastaDirectoryReadOff", "fastaFilesReadOff", "fastaDirectoryReadOffset", "fastaFilereadLength", "fastaFileReadoffset", "fastaFileRunOff", "fastaFileReadEntry", "fastaFilesReadOffset", "fastaFileStartoffset", "fastaFilesWriteoffset", "fastaFileReadOff", "fastaDirectoryReadEntry", "fastaFileWriteOffset", "fastaFilesWriteOff", "fastaDirectoryWriteoffset", "fastaDirectoryReadoffset", "fastaFileWriteEntry", "fastaFileRunOffset", "fastaFileLoadoffset", "fastaFileLengthOffset", "fastaDirectoryWriteEntry", "fastaBufferReadLength", "fastaFileLengthAmount", "fastaFileWriteAmount", "fastaFileStartOffset", "fastaFileStartEntry", "fastaFileReadLength", "fastaFilesWriteLength", "fastaBufferReadOffset", "fastaFileWriteLength", "fastaFileLengthOff", "fastaBufferWriteAmount", "fastaFileLoadAmount", "fastaBufferWriteLength", "fastaFilesReadLength", "fastaFileLengthLength"], "partitionStartOffset": ["partitionStopOrder", "partitionBufferOffset", "partitionStartOff", "partitionStopOffset", "partitionEndOff", "partitionsEndOffset", "partitionBufferOrder", "partitionBufferRange", "partitionEndOrder", "partitionsStartOff", "partitionsStartOrder", "partitionStartOrder", "partitionsStartRange", "partitionEndRange", "partitionsEndRange", "partitionsEndOrder", "partitionsEndOff", "partitionStopOff", "partitionBufferOff", "partitionStartRange", "partitionStopRange", "partitionsStartOffset"], "bufferSize": ["processSize", "processSIZE", "bufferCount", " bufferCount", " bufferSIZE", "BufferC", " bufferType", "processType", " bufferC", "BufferSize", "BufferCount", "queueCount", "bufferType", "bufferC", "BufferType", "queueSize", "bufferSIZE", "processC", "BufferSIZE"], "fastaBuffer": ["fastaceBuffer", "fastanContainer", " fastasContainer", "fastAFile", " fastasFile", "fastaQueue", "fastanFile", "fastacePtr", "fastaPtr", "fastasBuff", "FastasBuff", "FastasPtr", "fastaaStream", " fastABuffer", " fastaContainer", " fastAFile", "fastasFile", "FastaStream", "fastaStream", "FastasBuffer", "fastaaBuffer", "FastaChannel", " fastaFile", "fastaContainer", " fastasBuffer", "fastaFile", "fastanBuffer", " fastasChannel", "FastaBuffer", "fastanBuff", "fastaaPtr", "fastasBuffer", "FastasStream", "fastaceBuff", "fastaaBuff", "fastasQueue", "fastaBuff", "fastAContainer", " fastAChannel", "fastaceChannel", "fastanQueue", " fastaQueue", "fastAQueue", "fastasStream", " fastAQueue", "fastABuff", " fastaBuff", "FastaPtr", "FastaBuff", "fastanPtr", "fastAChannel", "fastanChannel", "fastasContainer", "fastasPtr", "fastanStream", "fastAPtr", "FastasChannel", " fastABuff", "fastABuffer", "fastasChannel"], "fastaReadState": ["fastaReadingMode", "fastaReadstate", "fastaReadType", "fastaReaderstate", "fastaFileState", "fastaReadingState", "fastaFileMode", "fastaReaderMode", "fastaFilestate", "fastaFileType", "fastasReadState", "fastaReadingstate", "fastaReaderType", "fastaReaderState", "fastaReadingType", "fastasReaderState", "fastasReaderMode", "fastasReaderstate", "fastasReadType", "fastaReadMode", "fastasReadstate", "fastasReadMode", "fastasReaderType"], "nBytes": ["oParts", "lenFrames", "NBytes", "pByte", " nByte", "oBytes", "lenBytes", "pBytes", "NByte", "pbytes", " nbytes", "obytes", "numBytes", "numbytes", "oFiles", "pParts", "nFiles", " nFrames", "numFiles", "lenFiles", "numFrames", "nbytes", "Nbytes", "nFrames", " nParts", "nParts", "NParts", "NFiles", "nByte", " nFiles", "lenbytes"]}}
{"id1": "14053882", "id2": "9449064", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": [" enrypt", " encryptryption", " encryptrypt", " encryptcode", " enipher", "decrypt", "encryption", "deccode", " encode", " encryptipher", " enryption", "decryption", "enccode", "encipher", "decipher"], "plaintext": [" plaincontent", "encryptedcontent", "protectedText", " plainsource", "givensource", " plainfont", "plaincontent", "encryptedtext", "batstring", "batfont", "giventext", " plainstruct", "protectedcontent", "protectedtext", "plainfont", "protectedstruct", "encryptedstruct", "encryptedText", " plainText", "plainsource", "givenstring", "battext", "plainText", " plainstring", "batsource", "givenfont", "plainstring", "plainstruct"], "md": ["meta", "df", "bd", "cb", "data", "mag", "mg", "cd", "wd", "mad", "dd", "m", "ma", " MD", "mt", "da", "mage", "dig", "kg", "alg", "mb", "ph", "am", "mac", "hm", "cmd", "dm", "dr", "material", "dc", "d", "sm", "MD", "mo", "mod", "amd", "mp", "code", "metadata", "mm", "pm", "dh", "mu", "sha", "po", "cm", "mc", "ms", "od", "mand", "hd", "ad", "pd", "pg", "Cmd", "nm", "pkg"], "raw": ["full", "data", "ack", "array", "stream", "partial", "dec", "clean", "RAW", "enc", "load", "shared", "hex", "binary", "rc", "Raw", "instance", "text", "wrapper", "rew", "pure", "row", "buffer", "block", "image", "pack", "feed", "response", "serial", " RAW", "empty", "null", "original", "wave", "unsigned", "sha", "input", "initial", "auth", "unknown", "json", "string", "buf"], "hash": ["rh", "data", "ha", "version", "array", "hex", "log", "base", "cache", "mac", "her", "kh", "href", "password", "key", "secret", "buffer", "block", "image", "response", "h", "url", "sum", "ashes", "id", "index", "message", "sha", "header", "ash", "length", "auth", "Hash", "html", "sh"]}}
{"id1": "19549489", "id2": "6341264", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "label": 0, "substitutes": {"copy": ["create", "sync", "p", "download", "move", "Cop", "all", "zip", "cop", "paste", "source", "Copy", "delete", "transfer", "Transfer", " copied", "io", " copying", "split", "file", "clone", "upload", " copies", " move", "write", " transfer", " Copy"], "sourceFile": ["searchFile", "resourceDirectory", "serviceFiles", "searchfile", "serviceFilename", " sourceFiles", "siteFILE", "sourceDirectory", "SourceFile", "sourceFiles", "resourcefile", " sourceFILE", "sourceFilename", "resourceFiles", "Sourcefile", "serviceFile", "sourceFILE", "siteDirectory", "servicefile", "sourcefile", "searchFilename", "searchFiles", " sourceFilename", "SourceFiles", " sourceDirectory", "resourceFile", "SourceFILE", "siteFiles", " sourcefile", "SourceDirectory", "siteFile"], "destinationFile": ["destinatedFile", "distinationFiles", "destationFiles", "destinationDirectory", "Destinationfile", "distinationFile", "destinatedDirectory", "destinatedDir", "destinatorDir", "distinationImage", "destinationImage", "Destinatorfile", "destationFile", "destinatedImage", "destinatorfile", "destinationDir", "DestinatorDir", "DestinationFile", "DestinationFiles", "destationDirectory", "DestinationDir", "destinatedFiles", "DestinatorFiles", "destationDir", "destinatorImage", "destationfile", "destinatedfile", "destationImage", "distinatedFile", "destinationfile", "DestinatorFile", "distinatedFiles", "distinatedDirectory", "distinatedImage", "distinationDirectory", "destinatorFile", "destinatorDirectory", "destinationFiles", "destinatorFiles"], "sourceFileChannel": ["targetFileClient", "sourceFilesContext", "sourceFileContext", "targetFileChannel", "sourceLinechannel", "sourceLibraryChan", " sourceFilesConnection", "sourceFilesChannel", "ourceFileStream", "sourceFunctionConnection", "sourceFileStream", " sourceFilesContext", "ourceFileChan", "sourceLineChan", "sourceFunctionContext", "targetFileChan", "sourceDirectoryClient", "sourceLineStream", "targetLibraryChan", "sourceFileClient", "sourceDirectorySocket", "targetLibrarySocket", "sourceStreamChannel", "sourceStreamConnection", "sourceStreamChan", " sourceFileContext", "targetLibraryChannel", "sourceStreamStream", "sourceFilesConnection", "sourceFileConnection", "ourceStreamChannel", "ourceFilechannel", "sourceFileChan", "sourceFunctionService", "sourceFilechannel", "sourceFunctionChannel", "sourceLineClient", "sourceFilesService", "sourceLibraryChannel", "sourceStreamContext", "sourceStreamService", "ourceFileChannel", "sourceDirectoryChannel", "sourceLibrarySocket", "sourceStreamchannel", "targetFileSocket", " sourceFileService", "sourceDirChan", "ourceStreamchannel", " sourceFileConnection", " sourceFilesChannel", " sourceFilesService", "sourceFileService", "sourceLibraryClient", "sourceDirectoryChan", "sourceLineChannel", "sourceLineSocket", "sourceDirStream", "sourceFileSocket", "targetLibraryClient", "sourceDirChannel", "ourceStreamStream", "ourceStreamChan", "sourceDirchannel"], "destinationFileChannel": ["destinationLineClient", "destinationLineService", "destinationFileConnection", "destinationFilesHandler", "destinatorFileCache", "destinationDirectoryHandler", "destinatorFileClient", "destinatorFilesChannel", "destinationDirectoryCache", "destinatorFilesHandler", "destinationDirectoryChannel", "destinatorFilesCache", "destinatorFileChan", "destinationDirectoryConnection", "destinationFileService", "destinationLineHandler", "destinationFilesClient", "destinatorFileChannel", "destinatorFileHandler", "destinatorFilesChan", "destinationDirectoryService", "destinationFileHandler", "destinationIOCache", "destinationFileClient", "destinationFilesChannel", "destinationDirectoryChan", "destinationDirectoryClient", "destinationLineConnection", "destinationFilesChan", "destinationIOChannel", "destinationFileCache", "destinationFilesCache", "destinatorFilesClient", "destinationIOService", "destinationFilesService", "destinationFilesConnection", "destinatorFileConnection", "destinationFileChan", "destinatorFilesConnection", "destinationIOClient", "destinatorFilesService", "destinationLineChannel", "destinationLineChan", "destinatorFileService"]}}
{"id1": "17791385", "id2": "23666867", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyStream", "Copyfile", "copyFiles", " copyfile", " copyStream", "transferFile", "transferfile", " copyFiles", "transferStream", "CopyFiles", "CopyFile", "transferFiles", "copyfile", "copyStream"], "src": ["inf", "sl", "sin", "loc", "sup", "s", "sc", "ins", "stream", "st", "ipl", "inst", "rc", "ls", "b", "files", "txt", "img", "dist", "dest", "back", "rb", "source", "image", "filename", "url", "config", "uri", "sit", "http", "file", "upload", "sel", "sb", "input", "resource", "obj"], "dst": ["fdst", "Dlt", "fdft", "pdfd", "dsts", " dsts", " ddest", "dft", " dlt", "fdfd", "pdsp", "dsp", "ddst", "ddest", "ddfd", "pdft", "pdst", "dlt", "fdsp", "Dst", "stdest", "Ddest", "stlt", "stst", "ddft", "Dsts", "dfd", "ststs", "ddsp"], "in": ["reader", "bin", "sin", "f", "login", "data", "socket", "ins", "pin", "m", "cin", "In", "is", "inside", "kin", "conn", "inner", "again", "rin", "win", "r", "din", "IN", "err", "pull", "ini", "i", "init", "inc", "nin", "h", "url", "n", "inn", "oin", "as", "file", "id", "impl", "lin", "input", "con", "ln", "gin"], "out": ["x", "bin", "ext", "f", "self", "at", "s", "sync", "ex", "outs", "plain", "copy", "conn", "w", "again", "output", "cache", "part", "writer", "line", "err", "o", "off", "client", "OUT", "temp", "i", "inc", "exec", "outer", "parent", "other", "n", "raw", "server", "post", "null", "io", "net", "file", "up", "exp", "Out", "obj"], "buf": ["bin", "cur", "cb", "bd", "seq", "data", "loc", "ff", "fl", "lim", "batch", "cap", "buff", "bh", "rc", "base", "bl", "bb", "b", "vec", "br", "bytes", "cmd", "val", "bag", "off", "rb", "buffer", "count", "cat", "ctx", "uc", "v", "raw", "c", "wb", "fd", "uf", "queue", "bf", "pad", "length", "fb", "bc"], "len": ["nt", "bin", "lt", "le", "sl", "f", "data", "name", "fl", "lim", "el", "rev", "cap", "en", "ind", "ll", "base", "lc", "ix", "part", "all", "size", "l", "line", "val", "err", "lf", "count", "i", "no", "cl", "n", "li", "c", "split", "pos", "fd", "lin", "fin", "Len", "length", "ln", "end"]}}
{"id1": "5061606", "id2": "10795866", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNecccessary", "createSettingsIfNecesary", "createSettingsIfNequccessnecessary", "createSettingsIfNecesarily", "createSettingsIfNececarily", "createSettingsIfNequccessarily", "createSettingsIfNequccessary", "createSettingsIfNecesseless", "createSettingsIfNecessnecessary", "createSettingsIfNecessarily", "createSettingsIfNececary", "createSettingsIfNecesnecessary", "createSettingsIfNecccesseless", "createSettingsIfNequccesseless", "createSettingsIfNececeless", "createSettingsIfNececnecessary", "createSettingsIfNecccessnecessary", "createSettingsIfNequessary", "createSettingsIfNeceseless", "createSettingsIfNecccessarily", "createSettingsIfNequesseless", "createSettingsIfNequessnecessary", "createSettingsIfNequessarily"], "out": ["connection", "bin", "lock", "app", "data", "name", "socket", "at", "pool", "error", "channel", "array", "sync", "ex", "outs", "timeout", "plain", "log", "plugin", "copy", "model", "page", "conn", "cache", "again", "output", "user", "by", "writer", "err", "password", "o", "flush", "client", "OUT", "off", "this", "i", "source", "image", "init", "cookie", "path", "exec", "object", "parent", "exit", "url", "config", "group", "server", "null", "io", "net", "file", "up", "index", "a", "prefix", "result", "window", "Out", "write", "obj", "editor"], "fSettings": ["FConfig", "fConfig", "fileSettings", "fJs", "Fsettings", "sfsettings", "fileSetting", " fSetting", "fsConfig", "fettings", " fFs", "filesettings", "FSettings", "fSetting", "fmSettings", " fJs", "sfJs", "FJs", "sfettings", "fsSettings", "fsSetting", "sfSetting", "fmSetting", "FSetting", "rfSettings", "sfSettings", "fmSetup", " fConfig", " fettings", "rfSetting", "rfFs", "fFs", "fmConfig", "fsSetup", "fileettings", "rfConfig", "FSetup", " fsettings", "fsettings", "fsFs", "fSetup"], "src": ["cur", "sl", "cb", "loc", "gb", "sc", "ins", "ctr", "stream", "st", "settings", "str", "rc", "base", "prot", "ource", "ssl", "req", "b", "text", "img", "lower", "dist", "dest", "rb", "source", "storage", "sub", "uc", "path", "filename", "attr", "url", "config", "uri", "route", "file", "sr", "sel", "sb", "fp", "ref", "string", "tmp"], "in": ["reader", "bin", "connection", "sin", "f", "data", "login", "s", "ins", "stream", "In", "kin", "copy", "b", "inner", "again", "rin", "win", "din", "l", "r", "IN", "err", "ini", "i", "source", "image", "init", "inc", "path", "url", "n", "thin", "inn", "c", "file", "id", "index", "input", "con", "gin"]}}
{"id1": "620855", "id2": "345515", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doversioncheck", "doChangeCheck", "doVersionUpdate", " doVersionUpdate", " doversionScan", " doVersionScan", "doChangecheck", " doVersioncheck", "doFeaturecheck", "doFeatureUpdate", "doversionUpdate", "doChangeUpdate", " doversioncheck", "doFeatureScan", "doFeatureCheck", "doVersionScan", "doChangeScan", " doversionCheck", "doversionScan", "doVersioncheck", "doversionCheck", " doversionUpdate"], "view": ["lock", "self", "container", "edit", "pool", "div", "screen", "see", "review", "update", "out", "html", "gu", "session", "el", "page", "cache", "query", "display", "client", "row", "port", "value", "ui", "group", "up", "fail", "use", "widget", "View", "im", "vis", "model", "vol", "check", "by", "e", "cell", "this", "show", "style", "image", "form", "config", "http", "VIEW", "full", "layout", "manager", "head", "body", "change", "event", "base", "box", "video", "user", "can", "comment", "list", "block", "object", "v", "server", "index", "views", "sel", "input", "window", "ou", "ve", "link"], "url": ["ul", "open", "sl", "f", "loc", "name", "socket", "email", "gl", "stream", "web", "download", "log", "base", "ssl", "bb", "ls", "ll", "blog", "b", "loader", "zip", "l", "bug", "fr", "address", "Url", "buffer", "URL", "source", "image", "builder", "hub", "path", "server", "uri", "null", "browser", "http", "file", "impl", "id", "resource", "www", "host", "link", "location", "length", "rel", "string", "ob"], "in": ["reader", "isin", "sin", "login", "data", "doc", "socket", "s", "ins", "pin", "m", "stream", "cin", "In", "binary", "is", "b", "inner", "again", "rin", "win", "din", "IN", "err", "ini", "buffer", "source", "init", "inc", "nin", "bis", "inn", "file", "as", "lin", "resource", "input", "out", "con", "ac"], "bin": ["reader", "border", "lock", "sin", "login", "socket", "pin", "body", "cin", "bn", "vin", "binary", "bot", "is", "bb", "bi", "b", "loader", "inner", "win", "din", "IN", "ruby", "ini", "abi", "buffer", "lib", "run", "init", "spin", "arin", "ban", "browser", "inn", "oin", "file", "lin", "fin", "input", "out", "record", "con", "gin", "nb"], "line": ["job", "le", "sl", "data", "name", "type", "pin", "range", "el", "ge", "one", "str", "definition", "letter", "log", "base", "lc", "inline", "page", "b", "text", "part", "user", "zip", "l", "val", "e", "cell", "lines", "lf", "key", "ine", "comment", "row", "entry", "block", "parse", "Line", "object", "cl", "code", "nl", "unit", "pe", "jo", "file", "up", "id", "LINE", "word", "lin", "out", "link", "string", "write", "ip", "end", "look"], "version": ["feature", "ver", "name", "support", "type", "dev", "python", "versions", "install", "VERSION", "latest", "download", "release", "plugin", "position", "model", "format", "video", "user", "vert", "section", "bug", "patch", "vision", "pull", "secret", "image", "value", "project", "driver", "v", "update", "server", "unit", "date", "author", "null", "code", "Version", "id", "beta", "cover", "host", "string", "option", "device", "license"], "build": ["lock", "job", "ver", "tag", "get", "mount", "Build", "hold", "how", "building", "boot", "install", "info", "clean", "load", "lease", "release", "log", "add", "built", "bug", "work", "uild", "patch", "pull", "row", "show", "style", "image", "block", "run", "feed", "builder", "update", "unit", "make", "post", "http", "valid", "follow", "help", "home", "print", "link", "rel", "use"]}}
{"id1": "8815137", "id2": "14758866", "code1": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"copyToDir": [" copyFromDir", " copyToFolder", " copyToFile", "copyFromDir", "copyToFolder", "copy2File", "copy2Folder", "copy2Dir", " copyToDist", "copyNewDist", "copyFromFolder", " copyFromFile", "copyFromFile", " copyFromDist", " copyFromFolder", "copyNewFile", "copyNewFolder", "copyFromDist", "copyToDist", "copyNewDir", "copyToFile", "copy2Dist"], "dir": ["lock", "director", "f", "data", "tree", "name", "loc", "keep", "manager", "doc", "container", "wd", "type", "div", "local", "base", "class", "direction", "log", " directory", "model", "cache", "plugin", "output", "files", "domain", "Dir", "zip", "root", "dist", "dest", "temp", "this", "dc", "d", "lib", "entry", "source", "db", "build", "project", "path", "parent", "object", "url", "store", "ir", "uri", "http", "folder", "id", "module", "DIR", "coll", "target", "out", "diff", "home", "directory", "report", "editor"], "file": ["current", "data", "name", "self", "type", "letter", "binary", "class", "format", " directory", "single", "lane", "source", "ile", "path", "url", "default", "io", "function", "module", "message", "queue", "resource", "out", "directory", " filename", "File", " module", "handler", "table", "stream", "fe", "local", "log", "page", "cache", "content", "zip", "key", "parent", "code", "up", "folder", "id", "home", "use", "f", "create", "p", "info", "model", "part", "line", "e", "this", "lib", "image", "live", "http", "FILE", "fp", "full", "connection", "force", "body", " source", " base", "base", "files", "l", "comment", "found", "block", "db", "write", "filename", "object", " name", "view", "unit", "string", "media"], "fileOutputStream": ["filesOutputSteam", "filesInputLength", "filesOutputChannel", "fileWritestream", "fileInputChannel", "fileInputFile", "fileOutputChannel", "fileWriteChannel", "fileResponseFile", "fileResponseStream", "FileOutputSteam", "FileInputStream", "fileResponseSteam", "FileOutputSem", "fileInputSem", "FileInputSteam", "fileOperstream", "fileConfigStream", "filesInputSteam", "fileIOStream", "filesOutputStream", "fileConfigChannel", "fileConfigSteam", "filesInputChannel", "filesInputStream", "fileOperLength", "fileOutputFile", "fileIOSem", "fileResponseSem", "fileConfigstream", "fileIOFile", "FileInputFile", "fileWriteSteam", "fileOutputLength", "fileIOSteam", "fileBytestream", "filesInputstream", "FileInputSem", "filesOutputLength", "filesOutputstream", "fileWriteStream", "fileOutputSteam", "fileByteLength", "fileInputstream", "fileInputSteam", "fileOperSteam", "fileOperStream", "fileOutputSem", "fileByteSteam", "fileByteStream", "FileOutputStream", "fileInputLength", "fileOutputstream", "FileOutputFile"], "fileInputStream": ["filesOutputSteam", " fileInputThread", "fileAsyncstream", "fileInternalstream", "fileInSteam", "fileStorageThread", "fileInstallStream", "fileAsyncSteam", "filesInputSteam", "filesOutputStream", " fileOutputstream", "filesInputStream", "fileStoragePass", "fileSourceStream", "fileSourceSteam", "fileSourceThread", " fileInputstream", "fileStorageStream", "filesInputThread", "filesInputstream", "fileInternalSteam", " fileOutputThread", "fileInternalStream", "filesOutputstream", "filesOutputThread", "fileOutputSteam", "fileAsyncStream", "fileInputstream", "fileInPass", "fileInputSteam", "fileInternalThread", "fileStorageSteam", "fileInstallSteam", "fileSourcestream", "filesOutputPass", " fileOutputSteam", "fileInputPass", "fileInstallstream", "fileOutputPass", "fileInputThread", "fileInThread", "fileInStream", "filesInputPass", "fileOutputThread", "fileOutputstream", " fileInputSteam"], "read": ["reader", "READ", "open", "iter", "readable", "current", "get", "start", "ride", "Read", "allow", "play", "create", "sync", "send", "se", "ip", "load", "find", "reads", "add", "loop", " write", "check", "b", "size", "ok", "old", "r", "work", "e", "seek", "count", "i", "lex", "run", "ask", "feed", "build", "parse", " Read", "exec", "fill", "select", "next", "close", "default", "level", "reading", "pass", "view", "raw", "io", "id", "index", "last", "resource", "input", "total", "sleep", "length", "write", "use", "end", "wait"], "buffer": ["offset", "reader", "border", "uffer", "iter", "data", "channel", "batch", "slice", "seed", "layer", "buff", "Buffer", "load", "zero", "binary", "base", "cache", "b", "size", "bytes", "shape", "flush", "row", "comment", "feed", "limit", "request", "transfer", "null", "split", "wave", "message", "queue", "result", "length", "write", "buf"]}}
{"id1": "19912848", "id2": "7149578", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeFileAsStream", "decodeFileToFiles", "decodeFile2File", "decodeFileToString", "decodeStringToStream", "decodeStringToString", "decodeFileAsString", "decodeFileAsFile", "decodeString2File", "decodeFileFromFiles", "decodeFileFromFile", "decodeString2Stream", "decodeString2String", "decodeFileFromStream", "decodeStringToFiles", "decodeString2Files", "decodeFileToStream", "decodeFile2Stream", "decodeFileAsFiles", "decodeStringToFile", "decodeFile2Files", "decodeFileFromString"], "infile": ["inputfilename", "outfilename", "infilename", " instream", "inputfile", "inputfiles", "minfile", "outfiles", "infp", "Instream", "inputfp", "Inbase", "outfp", "minstream", " infilename", " infp", " infiles", " inbase", " inFile", "instream", "infiles", "minFile", "inbase", "minbase", "InFile", "Infile", "inFile"], "outfile": ["inputFile", "outputfilename", "outfilename", "infilename", "inputfile", "outpath", "outputFile", "outFile", " outfilename", "inputdatabase", " outdatabase", "inputpath", " outpath", " outFile", "outputdatabase", "outdatabase", " outfolder", "outputfile", "infolder", "outputpath", "outputfolder", "outfolder", "inFile"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "lin", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "channel", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "log", "copy", "conn", "cache", "again", "output", "inner", "line", "writer", "work", "err", "off", "client", "o", "OUT", "lib", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "pass", "post", "io", "net", "file", "up", "co", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "bin", "reader", "border", "uffer", "iter", "data", "channel", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "queue", "input", "result", "length", "write", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "r", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "positive", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "8452134", "id2": "4016687", "code1": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        String sFTP = \"ftp.miservidor.com\";\n        String sUser = \"usuario\";\n        String sPassword = \"password\";\n        try {\n            System.out.println(\"Conectandose a \" + sFTP);\n            client.connect(sFTP);\n            boolean login = client.login(sUser, sPassword);\n            if (login) {\n                System.out.println(\"Login correcto\");\n                boolean logout = client.logout();\n                if (logout) {\n                    System.out.println(\"Logout del servidor FTP\");\n                }\n            } else {\n                System.out.println(\"Error en el login.\");\n            }\n            System.out.println(\"Desconectando.\");\n            client.disconnect();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"exists": ["exits", "esisting", "esistent", "esists", "xits", "resists", "resisting", "Exits", "xisting", "resits", "existing", "Existing", "xists", "existent", "Exist", "actists", "actistent", "actisting", "actist", "Exists", "Existent", "xist", "exist", "resist", "esist"], "fileToCheck": ["entryTOCheck", "filetoCheck", "entryTOChe", "fileTOcheck", "fileTocheck", "fileToChe", "fileTOCheck", "filetoChe", "stringTocheck", "entryToTest", "entryToCheck", "entryToChe", "filetoTest", "fileToTest", "fileTOChe", "entryTOcheck", "fileTOTest", "entryTOTest", "stringToCheck", "stringToTest", "entryTocheck", "filetocheck"], "ftp": ["lfp", "ntps", "mailpc", "ftpo", "ftps", "alttp", "kta", " ftpo", "fttp", "altp", "lfpo", "fcp", "oftpa", "fta", "ftt", "uttp", "ctcp", "FTap", "ttps", " ftt", "ft", "htp", "htbr", "ffcp", " fttp", " ftb", " ftbr", "ftw", "oftip", "oftp", "ffp", " ftcp", "altpc", "cttp", "aftpc", "ftb", "ttcp", "htpa", " ftap", "utw", "utpc", "ctp", "ktpc", "ntcp", "cfp", "ftcp", "uffp", "ftsap", "ntp", "lfps", "fftp", "ftbr", " ftfp", "tta", "afttp", "ctpo", "lftp", "ufp", " ftpa", "oftbr", "cfpo", "ttp", "ftip", "rtpb", " fta", "rtp", "ktp", "ftpc", " ftpb", "ktpb", "rtpc", "aftcp", "FTb", " ftw", "mailcp", "ftfp", "mailtp", "fpc", "ftsp", "fp", "uft", "FTps", "FTp", "utp", "ftpb", "ftsb", "rta", "altw", "ftpa", "aftp", "ftsps", "cftp", "mailp", "cfps", " ftpc", " ftps", "ffpo", "ufcp", "htip", " ftip", "ftap", "nta"], "found": ["full", "active", "nt", "iter", "f", "loaded", "fixed", "fl", "error", "first", "good", "received", "used", "find", "local", "given", "all", "successful", "locked", "success", "old", "left", "built", "bug", "val", "err", "l", "updated", "expected", "defined", "Found", "count", "finding", "connected", "ret", "response", "default", "read", "checked", "finder", "flat", "index", "pos", "valid", "len", "search", "fd", "sent", "result", "length", "failed", "confirmed", "broken"], "reply": ["connection", "answer", "data", "force", "error", "reason", "respond", " replied", " replies", " response", "sync", "send", "info", "ply", "zero", "received", "bot", "echo", "status", "match", "base", "part", "text", "repl", "query", "err", "address", "dy", "rr", "call", "comment", "buffer", "service", "Reply", "continue", "request", "response", "next", "code", "read", "server", "post", "lying", "index", "prefix", "message", "len", "result", "sent", "cause", "link", "length", "report", "write", "resp"]}}
{"id1": "19584877", "id2": "771802", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToStream", "encodeFiletoStream", "encodeString2Stream", "encodeFiletoFile", "encodeStringToString", "encodeString2String", "encodeFileToStream", "encodeFileToString", "encodeFileFromFiles", "encodeFile2Files", "encodeStringToFiles", "encodeFile2String", "encodeStringToFile", "encodeFileFromString", "encodeString2Files", "encodeFileFromFile", "encodeFiletoString", "encodeFile2Stream", "encodeFileToFiles", "encodeFiletoFiles", "encodeString2File", "encodeFile2File", "encodeFileFromStream"], "infile": ["inputFile", "inputfilename", "Infiles", "outfilename", "infilename", "inputfile", "outFile", "inputfiles", "outfiles", "infp", "inputfp", "outfp", " infilename", " infp", " infiles", "infiles", "Infilename", "InFile", "Infile", "inFile"], "outfile": ["newFile", "outputfilename", "Outfile", "outfilename", "infilename", "outFile", "Outfolder", " outfp", " outfilename", "infp", "newfolder", "outname", "outfp", " outname", " outFile", "Outname", " outfolder", "outputfp", "newname", "newfile", "outputfile", "infolder", "OutFile", "outputfolder", "outfolder"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "vin", "base", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "image", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "copy", "conn", "cache", "again", "output", "inner", "writer", "work", "line", "err", "off", "client", "o", "OUT", "lib", "source", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "post", "io", "net", "file", "up", "co", "on", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "reader", "border", "uffer", "iter", "data", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "len", "queue", "input", "result", "length", "write", "fb", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "close", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "input", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "modified", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "respons", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "15241397", "id2": "6009527", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["doGET", "handleget", " doPut", " doget", "doget", "handlePut", "didPut", "doPut", "didget", "handleGET", "handleGet", "didGet", "didGET", " doGET"], "request": ["connection", "reader", "er", "data", "complete", "QUEST", "method", "type", "info", "application", "web", "event", "received", "xml", "req", "user", "instance", "query", "client", "subject", "buffer", "image", "object", "Request", "url", "context", "document", "uri", "server", "http", "message", "input", "result", "resource", "queue", "initial", "report"], "response": ["full", "connection", "data", "version", "error", "pool", "session", "respond", "body", "results", "application", "Response", "status", "model", "page", "output", "writer", "collection", "client", "reply", "image", "parent", "object", "next", "other", "esi", "document", "view", "server", "wave", "function", "message", "resource", "result", "out", "queue", "host", "report", "onse", "generation", "json", "resp", "site"], "rewrittenQueryString": ["rewwrittenQueryList", "rewrittenUrlService", "rewrittenqueryString", "rewrittenQueryText", "rewwrittenRequestString", "rewrittenQueryList", "rewrittenRequestService", "rewwrittenQueryLine", "rewrittenPageList", "rewrittenqueryStr", "rewrittenQueryArray", "rewwrittenQueryArray", "rewrittenQuestionList", "rewrittenPageLine", "rewrittenUrlString", "rewwrittenRequestArray", "rewwrittenRequestLine", "rewrittenqueryService", "rewwrittenQueryStr", "rewrittenRequestText", "rewrittenQueryService", "rewrittenUrlText", "rewrittenQuestionArray", "rewwrittenRequestStr", "rewrittenqueryLine", "rewrittenPageArray", "rewrittenQuestionText", "rewwrittenQueryString", "rewwrittenRequestService", "rewrittenRequestStr", "rewrittenQueryLine", "rewwrittenQueryText", "rewrittenQuestionStr", "rewrittenRequestString", "rewwrittenRequestText", "rewwrittenQueryService", "rewrittenRequestLine", "rewrittenQuestionString", "rewrittenUrlLine", "rewrittenQuestionLine", "rewrittenRequestList", "rewrittenqueryText", "rewwrittenRequestList", "rewrittenRequestArray", "rewrittenQueryStr", "rewrittenPageString"], "rewrittenUrl": ["RewwrittenUrl", "rewilledUrl", "rewriteUrl", "rewardedLanguage", "rewardedInt", "rewwrittenInt", "rewmatchedUrl", "rerittenLanguage", "rewrapedUrl", "rewmatchedURL", "rewrittenInt", "rewardedUrl", "rewrittenLanguage", "rewardedJar", "rewardedUr", "RewrittenFile", "RewrittenUr", "rewilledURL", "rewatchedServer", "RewwrittenLocation", "rewardedURL", "rewatchedURL", "RewrittenServer", "rewrittenText", "rewwrittenServer", "rewcraftedUrl", "rewrapedUr", "rewwrittenJar", "rewrittenurl", "rewwrittenLanguage", "rewedurl", "rewcraftedUr", "rewwrittenLocation", "rewwrittenText", "Rewwrittenurl", "rewrapedFile", "rewriteText", "rewrittenURL", "rewodedUrl", "RewwrittenInt", "rewwrittenUr", "rewrittenServer", "rewrapedURL", "rewrittenJar", "RewrittenURL", "RewrittenLocation", "RewwrittenText", "rewodedFile", "rewriteServer", "rewmatchedFile", "rerittenUrl", "RewrittenInt", "rerittenURL", "rewatchedUrl", "rewwrittenUrl", "rewedURL", "rewmatchedurl", "RewrittenUrl", "rewrittenUr", "rewrittenLocation", "rewwrittenFile", "rewedUrl", "rewriteURL", "rewcraftedURL", "RewwrittenURL", "RewwrittenUr", "rewcraftedLocation", "rewilledJar", "RewrittenText", "rerittenFile", "RewwrittenFile", "rewatchedText", "rewodedLanguage", "rewardedLocation", "RewrittenJar", "rewedFile", "RewwrittenServer", "rewardedFile", "rewrittenFile", "rerittenUr", "rewilledInt", "rewodedURL", "rewwrittenURL", "rewedUr", "RewwrittenJar", "rewwrittenurl", "Rewrittenurl"], "httpURLConnection": ["httpCLConnection", "httpURIConnect", "apacheURLFlow", "httpURLCode", "httpURLService", "webSSLClient", "httpurlCurrent", "httpurlConnection", "httpURLConn", "httpURConn", "apacheURLConnect", "httpStreamconnection", "httpSSLConnection", "httpURIClient", "HttpChannelconnection", "httpUrlconnection", " httpURConn", " httpUrlConnection", "httpUrlConnection", "httpStreamSession", " httpURLconnection", "httpStreamConnection", " httpURConnect", "httpurlFlow", "httpUrlContext", "httpChannelService", "HttpURLConnection", "httpURLContext", " httpUrlConn", "httpCLConn", " httpStreamCurrent", "webSSLConnection", "httpURIconnection", "HttpURLconnection", "httpPathCurrent", "webURLContext", "webSSLContext", "httpurlconnection", "httpUrlConn", "httpURLCurrent", "apacheGEConnect", "httpURConnect", " httpStreamSession", "httpWebConnect", "httpSSLContext", "httpPathConnection", "httpPathconnection", "httpurlSession", "HttpChannelConnect", "httpGEconnection", " httpURLSession", "httpURIFlow", "httpURIContext", "httpURLClient", "httpurlConn", " httpURLConn", "httpUrlService", "httpStreamCurrent", "httpURConnection", "httpUrlConnect", "apacheGEConnection", "HttpURLConnect", " httpStreamConnection", " httpURConnection", "httpGEConnection", "httpURIConnection", "httpURLconnection", "httpurlConnect", " httpURLCurrent", "httpChannelconnection", "httpELConn", " httpURLConnect", "httpChannelConnection", "httpWebConn", "webURLClient", "apacheGEFlow", "httpSSLConn", " httpStreamconnection", "apacheURLconnection", "HttpURLService", "httpSSLClient", "httpELConnection", "HttpChannelConnection", "httpGEFlow", "webURLConnection", "webURLConn", "httpChannelConnect", "httpGEConnect", "httpUrlCode", "HttpChannelService", "httpWebConnection", "httpURconnection", " httpURLCode", "httpURService", " httpUrlCode", "httpUrlClient", "httpPathSession", "apacheGEconnection", "httpURLFlow", "httpCLCode", "webSSLConn", "apacheURLConnection", "httpurlCode", "httpURIConn", "httpURLConnect", "httpELConnect", "httpURLSession"], "header": ["feature", "iter", "er", "director", "data", "version", "channel", "master", "error", "handler", "head", "reference", "filter", "layer", "pair", "info", "after", "field", "event", "definition", "rule", "match", "component", "part", "bridge", "section", "her", "writer", "line", "member", "key", "ter", "dr", "column", "back", "buffer", "list", "entry", "player", "comment", "block", "driver", "outer", "hash", "second", "character", "Header", "next", "default", "attribute", "document", "group", "server", "date", "consumer", "author", "metadata", "function", "index", "message", "item", "token", "headers", "queue", "result", "cover", "string"], "value": ["office", "values", "data", "current", "name", "version", "now", "get", "type", "language", "V", "info", "field", "variable", "option", "label", "letter", "expression", "set", "format", "description", "model", "text", "content", "sv", "val", "VALUE", "key", "password", "comment", "entry", "child", "parent", "object", "v", "property", "attribute", "default", "document", "hello", "server", "function", "valid", "message", "item", "gi", "Value", "json", "string", "media", "end", "element"], "inputStream": ["pullStreamer", "inputSteam", "resourceSteam", "InputChannel", "InputStream", "InputStreamer", "outputStreamer", "pullstream", "inputStreamer", "resourceChannel", "pullStream", "pullSteam", "resourcestream", "resourceStream", "inputChannel", "Inputstream", "outputChannel", "outputSteam", "InputSteam", "inputstream", "outputstream"], "outputStream": ["inputSteam", " outputChannel", "OutputSteam", "outputFile", "OutputChannel", " outputFile", "OutputStream", "outputStreamer", "externalstream", "Outputstream", "inputStreamer", "externalSteam", "externalStreamer", "responseStream", "responseSteam", " outputSteam", "responseFile", "outputChannel", "outputSteam", "responseChannel", "externalStream", "inputstream", "OutputFile", "outputstream", "OutputStreamer"]}}
{"id1": "20675046", "id2": "18433984", "code1": "    public Object getContent(ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {\n        try {\n            URL url = (getURL() != null) ? new URL(getURL().toExternalForm()) : new URL(((URL) ctxAttrValue).toExternalForm());\n            InputStream reader = url.openStream();\n            int available = reader.available();\n            byte contents[] = new byte[available];\n            reader.read(contents, 0, available);\n            reader.close();\n            return new String(contents);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return ex.toString();\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"getContent": ["newContents", "createResource", "loadResource", "getResource", "newContent", "newResource", "getcontent", "createcontent", "loadContents", "createContent", "loadContent", "getContents", "newcontent", "loadcontent", "createContents"], "context": ["connection", "data", "Context", "name", "manager", "channel", "stream", "comp", "event", "proc", "class", "component", "text", "instance", "content", "writer", "temp", "this", "ctx", "path", "object", "config", "document", "consumer", "resource", "processor", "tx", "bc"], "ctxAttrName": ["ctxAttributeValue", "ctxAttrKey", "ctxAttrsKey", "ctxAddributeValue", "ctxAddrValue", "ctxAddrKey", "ctxAttrsValue", "ctxAttributeName", "ctxAttribKey", "ctxAddributeName", "ctxAttrPath", "ctxAttribName", "ctxAddributeKey", "ctxAddrName", "ctxAddrPath", "ctxAttrsName", "ctxAttrsPath", "ctxAddributePath", "ctxAttribPath", "ctxAttribValue", "ctxAttributePath", "ctxAttributeKey"], "ctxAttrValue": ["ctxAttributevalue", "ctxAttrVal", "ctxAttratorValue", "ctxAddributeVal", "ctxAttbvalue", "ctxAttributerVALUE", "ctxAttrivalue", "ctxAttributeValue", "ctxAttrKey", "ctxAddrvalue", "ctxAddributeValue", "ctxAttriValue", "ctxAddrValue", "ctxAttriVALUE", "ctxAttributeriName", "ctxAttmValue", "ctxAttmVal", "ctxAttributeriVALUE", "ctxAttmvalue", "ctxAttributerName", "ctxAddrKey", "ctxAttributeriValue", "ctxAttributerivalue", "ctxAttributeVal", "ctxAttratorVALUE", "ctxAttrvalue", "ctxAttbVal", "ctxAttbKey", "ctxAttorName", "ctxAttrVALUE", "ctxAttorvalue", "ctxAttratorName", "ctxAttmKey", "ctxAttratorvalue", "ctxAttributerValue", "ctxAttributervalue", "ctxAddributeKey", "ctxAttorVALUE", "ctxAttbValue", "ctxAttriName", "ctxAttorValue", "ctxAddrVal", "ctxAttributeKey", "ctxAddributevalue"], "url": ["connection", "sl", "org", "channel", "ur", "stream", "per", "base", "ssl", "bb", "blog", "user", "loader", "l", "writer", "address", "Url", "service", "URL", "source", "entry", "buffer", "feed", "api", "image", "build", "path", "object", "lr", "server", "uri", "browser", "io", "http", "file", "resource", "www", "host", "location", "string", "ler"], "reader": ["connection", "iter", "er", "f", "data", "ri", "iterator", "handler", " Reader", "worker", "stream", "ender", "layer", "per", "rc", "keeper", "loader", "l", "writer", "r", "rer", "parser", "rr", "buffer", "source", "oder", "entry", "feed", "builder", "driver", "reading", "read", "uri", "tx", "bird", "server", "io", "http", "browser", "in", "rar", "resource", "input", "result", "ler", "Reader", "editor", "rx"], "available": ["active", "missing", "full", "open", "readable", "current", "loaded", "version", "channel", "error", "allowed", "availability", "enough", "created", "closed", "array", "ready", "good", "free", "used", "supported", "able", "release", "position", "all", "instance", "existing", "content", "opened", "capacity", "enabled", "external", "found", "connected", "published", "buffer", "selected", "bound", "next", "default", "Available", "empty", "null", "memory", "unsigned", "valid", "accessible", "resource", "input", "running", "total", "length", "visible", "quality"], "contents": ["contens", "containingapes", " content", "contContents", "extences", "loadContents", "CONTures", "sequent", "intent", "explens", "containingent", "contures", "explent", "containingensions", "explents", "contings", "loadents", " contContents", "intensions", "content", "intapes", "contapes", "contences", "contensions", "containingents", "sequents", "extContents", " contures", "intents", "extents", "loadings", "sequensions", "CONTents", "extings", "explures", " contings", " contences", "loadences", "sequapes", " contens", "CONTens", "CONTent"]}}
{"id1": "20886320", "id2": "8754809", "code1": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 0, "substitutes": {"search": ["get", "scan", "create", "filter", "results", "send", "find", "sort", "all", "show", "list", "Search", "run", "select", "parse", "build", "submit", "request", "form", "index", "suggest", "result", "replace", "report", "start"], "query": ["feature", "answer", "data", "name", "question", "depth", "q", "error", "database", "command", "range", "filter", "results", "clean", "timeout", "str", "xml", "sort", "expression", "qu", "words", "cache", "text", "description", "term", "password", "quer", "comment", "source", "image", "value", "qs", "request", "general", "view", "uri", "params", "series", "queue", "result", "resource", "sql", "json", "string", "media", "Query"], "order": ["ORD", "er", "name", "effect", "type", "method", "state", "ard", "sort", "direction", "ordering", "rule", "position", "class", "page", "part", "user", "by", "r", "e", "err", "random", "orter", "address", "key", "orders", "row", "hop", "ort", "Order", "request", "asc", "der", "group", "server", "result", "record", "dir", "ordered", "string", "desc", "editor"], "maxResults": ["MaxPages", "minResult", "maxPages", "minResults", "MaxResult", "minresults", "Maxresults", "maxResult", "MaxResults", " maxResult", " maxPages", "maxresults", "minPages", " maxresults"], "encodedQuery": ["encodedUrl", "encachedUrl", "encapedquery", "encoredRequest", "EncryptedQ", "deccodedBody", "enccodedQuery", "encachedquery", "encryptedRequest", "encapedPage", "deccodedRequest", "encryptedquery", "encodedquery", "EncodedQuery", "incodedRequest", "encodedExp", "incoredUrl", "encryptedBody", "encodedQ", "enccodedBody", "incodedQuery", "incodedUrl", "encodingRequest", "EncodedQ", "enccodedQ", "Encryptedquery", "decodedRequest", "encryptedQ", "encodingBody", "enccodedRequest", "encodingQuery", "encachedQuery", "incoredExp", "enccodedExp", "enccodedUrl", "encachedPage", "encachedQ", "deccodedQuery", "decodedQuery", "incoredRequest", "encoredQuery", "decodedQ", "encodedPage", "encodedBody", "encachedRequest", "encapedQ", "encachedExp", "encoredExp", "decodedBody", "EncodedPage", "Encodedquery", "EncryptedPage", "encodedRequest", "EncryptedQuery", "encodingQ", "encryptedPage", "encryptedQuery", "incoredQuery", "encapedQuery", "encoredUrl", "incodedExp", "deccodedQ"], "startAt": ["StartAt", "endat", "StartFrom", "endAt", "endOr", " startNum", " startAfter", "startFrom", "endFrom", "Startat", "startat", "stopat", "StartNum", "endAfter", "startOr", "endNum", "stopFrom", "StartAfter", "StartOr", "startAfter", "stopOr", "startNum", "stopAt", " startFrom"], "pageNr": ["pageLenn", "pageSrc", " pageNrs", "pageLenrc", "pageSrs", "pageSn", "pageNumrs", "pageLenrs", "pageNrc", "pageNumn", "pageSr", " pageNnr", " pageNn", " pageNrc", "pageNumr", "pageNnr", "pageNn", "pageLenr", "pageNumnr", "pageNrs"], "url": ["connection", "sl", "data", "name", "version", "channel", "q", "string", "download", "str", "xml", "base", "ssl", "format", "page", "output", "href", "r", "address", "Url", "URL", "entry", "source", "image", "feed", "request", "path", "uri", "server", "route", "http", "id", "resource", "www", "host", "link", "location", " URL", "json"], "httpparams": ["httppARams", "httupparatums", "httPParAMS", "httPParas", "httpparsam", "httupparums", "httPParams", "httppparams", "httppareums", "httupparays", "httpparamAMS", "httPPARams", "httppParases", "httppARms", "httupparatays", "httpparatums", "httppparays", "httPPARas", "httppareas", "httpsarams", "httmpareams", "httmpareums", "httpsarases", "httmparams", "httpsaram", "httpsarsases", "httpparays", "httpparamam", "httpparamas", "httppARays", "httPPARms", "httPParms", "httpparatAMS", "httppParams", "httupparatams", "httppARums", "httpparsases", "httpparatams", "httmpareases", "httpparamams", "httmparas", "httmpareas", "httpparamparams", "httupparams", "httppparums", "httupparatAMS", "httpparAMS", "httppareams", "httmparums", "httppParparams", "httPPARAMS", "httpparatays", "httpparparams", "httpparaases", "httpparsparams", "httpparaums", "httpparamms", "httpparsas", "httppARAMS", "httpsarsams", "httupparAMS", "httpsarparams", "httpparamases", "httppParam", "httpsarsam", "httpsarsparams", "httpparms", "httppARas", "httpparsums", "httppareases", "httpparases", "httpparaas", "httpparas", "httpparums", "httmparases", "httpparsms", "httpparaams", "httpparsams", "httpparam", "httppparAMS", "httpparsAMS"], "httpclient": ["webconn", " httpmethod", "httpmethod", "httprequest", "htmlserver", " httpClient", "httpserver", " httpconnection", "httpsrequest", "phpconnection", "htmlconn", "phprequest", "httpsserver", "phpClient", "httpcall", "phpcall", "htmlClient", "phpserver", "httpClient", " httpserver", "httpconnection", "phpmethod", "webmethod", "httpconn", " httpcall", "htmlclient", "httpsclient", "webClient", "webclient", "httpscall", "webserver", "phpclient", "httpsconn", " httprequest", "webconnection", "httpsClient"], "httpget": ["phppost", "httpsput", "phpget", " httpsend", "httpsend", " httppost", "httppost", "perget", "Httpget", "persend", "perset", "Httpsend", "phpGet", "httpspost", " httpput", "httpsGet", " httpset", "Httpset", "httpGet", "httpput", "phpput", " httpGet", "httpsget", "httpset"], "response": ["full", "connection", "data", "get", "version", "session", "respond", "method", "stream", "body", "application", "received", "Response", "status", "page", "user", "successful", "output", "success", "collection", "client", "reply", "entry", "feed", "api", "request", "object", "seeking", "document", "server", "http", "message", "result", "res", "resource", "onse", "json", "resp"], "instream": ["inputform", " inchannel", "inview", "outstream", "inversion", "infile", "rinview", "inresource", "outStream", "inputview", "innerstream", "outresource", "intchannel", "inchannel", "innerversion", "rinStream", "rinstream", " inversion", "inform", " inresource", "outchannel", "intversion", " inStream", " infile", " inform", "inputresource", "outform", "intfile", "inputStream", "innerchannel", "outview", "inputchannel", "inStream", "innerfile", "inputstream", "intstream", "rinchannel"], "html": ["data", "doc", "version", "body", "string", "tml", "info", "web", "str", "xml", "plain", "base", "format", "page", "HTML", "text", "output", "css", "content", "article", "img", "source", "live", "template", "db", "js", "h", "object", "hash", "view", "raw", "ml", "browser", "http", "title", "message", "result", "header", "hot", "json"]}}
{"id1": "16623181", "id2": "237493", "code1": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"srcDir": ["rcDir", "rcFile", "srcFile", "rcDirectory", "srcDirectory", "sourceDir", " srcFolder", "destDir", "sourceDirectory", " srcDirectory", " srcFile", "destFile", "destFolder", "srcFolder", "sourceFolder", "sourceFile", "rcFolder", "destDirectory"], "dstDir": ["drcPath", "DstDir", "dotFile", "DrcDIR", "drcFile", "drcDir", "ddestFile", "dstDirectory", "DstPath", "dndFile", "dndDirectory", "DrcDir", "dptDIR", "dotDirectory", "dotPath", "dptFile", "dstDIR", "DrcFile", "drcDirectory", "dstFile", "dotDir", "dndDir", "DstFile", "ddestPath", "DrcPath", "DrcDirectory", "ddestDirectory", "ddestDir", "dndDIR", "dptDirectory", "drcDIR", "dstPath", "dptDir", "DstDirectory", "DstDIR"], "srcFiles": ["rcDir", "rcFile", "srcFile", "scFiles", "srcPoints", "scFile", " srcPoints", "sourceDir", "rcFiles", "sourceFiles", "scPoints", "scFs", "srcfiles", "sourceFs", " srcfiles", " srcFile", "rcfiles", "srcFs", "sourcePoints", "sourceFile", " srcFs", "sourcefiles"], "f": ["x", " df", "name", "self", " F", "s", "m", "p", "info", "j", "fe", "fed", "u", "b", "w", "files", "rf", "F", "r", "l", "fn", "fi", "e", "fr", "tf", "lf", "o", "d", "i", "fx", "feed", "t", "path", "h", "filename", "of", "v", "url", "form", "n", "io", "flat", "c", "file", "folder", "fa", "fd", "bf", "sf", "fp", "dir", "ref", "directory", "fc", "fb", "fs"], "srcChannel": [" srcContext", "rcClient", "sourceChan", "rcConnection", "rcBuffer", "sourceClient", "srcGate", "destConnection", " srcchannel", "destChan", "sourceChannel", "distChannel", "distChan", "rcContext", " srcBuffer", "sourceConnection", " srcConnection", "rcChan", "rcGate", "srcBuffer", "srcClient", "srcChan", "sourceBuffer", " srcGate", "destContext", "rcchannel", "sourcechannel", "distGate", "destChannel", "srcContext", "sourceContext", "srcchannel", "rcChannel", "distchannel", " srcClient", "srcConnection", " srcChan"], "dstChannel": [" dstchannel", "Dstchannel", "drcchannel", "dblChannel", "dstsConnection", "dscchannel", "ddrcButton", "dstConnection", "drcChannel", "dstchannel", " destHandler", "dscButton", "DrcChannel", "ddrcChan", "DrcBuffer", " dstHandler", "drcChan", "dstHandler", "ddstButton", "ddrcChannel", "destConnection", "Drcchannel", "ddrcchannel", "drcBuffer", "destChan", "DstChannel", "dstBuffer", "ddstChannel", "dblBuffer", "drcButton", " destchannel", "ddstChan", " dstConnection", "destButton", "dscBuffer", "dstChan", "dscChan", "destChannel", "drcConnection", "dscChannel", "destHandler", " destChannel", "dstschannel", "dstsHandler", "destchannel", "DstBuffer", "drcHandler", "dblchannel", "dstsChannel", " destConnection", "dstButton", "ddstchannel"], "buffer": ["reader", "bin", "border", "cur", "uffer", "iter", "data", "cb", "job", "batch", "reference", "seed", "layer", "buff", "Buffer", "stack", "zero", "binary", "base", "position", "copy", "bb", "cache", "b", "loader", "size", "r", "writer", "FFER", "flush", "row", "bar", "block", "image", "comment", "limit", "feed", "abi", "request", "url", "transfer", "document", "server", "read", "null", "wave", "message", "queue", "header", "out", "pad", "resource", "length", "result", "fb", "bc", "buf", "offset"], "nr": ["mr", "cur", "iter", "nn", "rn", "cb", "ri", "nc", " ni", "radius", "sn", "adr", "vr", "ru", "eno", "counter", "orr", " sr", "br", "rf", "num", "nu", "r", "err", "fr", "rr", "rb", " NR", "ner", "pointer", "row", "i", "rw", "lr", "number", "nor", "n", "nl", "NR", "ng", "wr", "ni", "nw", "sr", "pos", "gr", "result", "usr", "rl", "nm", "uni", "obj", "nb", "rx"]}}
{"id1": "14820302", "id2": "8011262", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    private void uploadFile() {\n        String end = \"\\r\\n\";\n        String twoHyphens = \"--\";\n        String boundary = \"*****\";\n        try {\n            URL url = new URL(actionUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            con.setRequestProperty(\"Charset\", \"UTF-8\");\n            con.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary);\n            DataOutputStream ds = new DataOutputStream(con.getOutputStream());\n            ds.writeBytes(twoHyphens + boundary + end);\n            ds.writeBytes(\"Content-Disposition: form-data; \" + \"name=\\\"file1\\\";filename=\\\"\" + newName + \"\\\"\" + end);\n            ds.writeBytes(end);\n            FileInputStream fStream = new FileInputStream(uploadFile);\n            int bufferSize = 1024;\n            byte[] buffer = new byte[bufferSize];\n            int length = -1;\n            while ((length = fStream.read(buffer)) != -1) {\n                ds.write(buffer, 0, length);\n            }\n            ds.writeBytes(end);\n            ds.writeBytes(twoHyphens + boundary + twoHyphens + end);\n            fStream.close();\n            ds.flush();\n            InputStream is = con.getInputStream();\n            int ch;\n            StringBuffer b = new StringBuffer();\n            while ((ch = is.read()) != -1) {\n                b.append((char) ch);\n            }\n            showDialog(b.toString().trim());\n            ds.close();\n        } catch (Exception e) {\n            showDialog(\"\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"innerProcess": [" innerWrite", "innerprocess", "subWrite", "binaryWrite", "subConnect", "innerWrite", "innerConnect", "binaryConnect", " innerprocess", "binaryprocess", "subProcess", "subprocess", " innerConnect", "binaryProcess"], "curi": ["lciri", "Cunit", "lcunit", " curl", "Ciri", "lcri", "papi", "Curl", " cui", "puri", "Cui", "lurl", "Capi", " capi", " cri", "lcui", "cui", "lcuri", "lcgui", "fURI", "capi", "lURI", "Cri", "luri", "curl", "fri", "pURI", "cunit", " cgui", "lcURI", " cURI", "fui", "furi", "pri", "Curi", "CURI", "cgui", "cri", "Cgui", " cunit", "firi", "ciri", "lri", "cURI"], "regexpr": ["recrepl", "Renexp", "reggexpl", "Regexpr", "regexr", "prenexp", "rerupl", "pregexpl", "Regexpre", "regnexper", "regexpl", "recrep", "prenexpr", "RegexPR", "rerepr", "Renexpre", "regnexpl", "renexpr", "pregexp", "rerupr", "recreer", "relexpr", "regexpre", "rerer", "rereper", "reruer", "reggexper", "RenexPR", "recrepre", "regexp", "pregexer", "regexer", "renexer", "renexpl", "regexPR", "reggexpr", "pregexpr", "recrePR", "regnexr", "recepr", "relexpre", "recer", "Renexpr", "renexr", "rerup", "reggexr", "prenexpl", "regexper", "regnexpr", "receper", "Regexp", "renexper", "relexPR", "recrepr", "prenexer", "renexpre", "relexp", "renexp", "renexPR", "rerepl", "recepl"], "cs": ["cb", "cn", "cos", "sc", "bs", "ds", "ca", "icks", "sync", "acks", "ins", "ns", "cms", "ics", "ec", "os", "pc", "codes", "rc", "lc", "cer", "ls", "cells", "cache", "css", "cing", "conn", "cr", "rs", "wcs", "ks", "cc", "ci", "ctx", "qs", "cf", "js", "ces", "spec", "ars", "vs", "gs", "cases", "fs", "acts", "ps", "details", "c", "ce", "ced", "acs", "cks", "cas", "coll", "ss", "tc", "cm", "CS", "ches", "ms", "es", "cp", "ac", "cers", "cus", "ios", "bc", "Cs", "cons"], "digest": ["signEST", "igested", "hashcher", " diger", "digit", " digests", "hashger", " digcher", "diggest", "Digester", "biggest", "hashester", "digested", "Digcher", "signests", "bigests", "digester", "Digity", "digEST", "digcher", "logit", "bigest", " digger", "digity", "digger", "logester", "bigEST", "signester", " digEST", "Digested", "signested", "Digger", "diger", "logest", "signer", "igity", "signgest", "Diger", "logger", "signest", "signger", "igester", " digity", "Digit", " digit", "hashest", "digests", " digested", "igest", " digester", "Digest", " diggest"], "s": ["sl", "su", "f", "data", "si", "ds", "g", "bs", "groups", "services", "sets", "sync", "p", "ns", "settings", "str", "os", "binary", "is", "ls", "ans", "u", "b", "abs", "obs", "bytes", "l", "r", "rs", "e", "o", "address", "strings", "S", "ws", "t", "js", "h", "v", "sum", "gs", "n", "ps", "c", "states", "sb", "ss", "ms", "sym", "string", "ses"], "m": ["bm", "mr", "gm", "machine", "rm", "p", "me", "match", "om", "imm", "am", "M", "hm", "wm", "r", "dm", "e", "vm", "ym", "sm", "map", "mo", "tm", "v", "mi", "man", "mm", "c", "pm", "cm", "mc", "fm", "ms", "nm", "string"], "newDigestValue": ["newDigestVal", "newSignestValue", "newDigESTString", "newDigesterKey", "newDigeterKey", "newSignestKey", "newDigesterValues", "newSignestedValue", "newDigESTValue", "newSignestValues", "newDigESTValues", "newSignestedString", "newSignestedValues", "newDigeterString", "newDigeterVal", "newDigestedKey", "newDigeterValue", "newDigestedValues", "newDigestedValue", "newSignestString", "newDigestString", "newDigestedString", "newDigesterVal", "newDigestKey", "newDigestedVal", "newDigesterValue", "newDigESTKey", "newDigesterString", "newDigestValues", "newSignestedKey"]}}
{"id1": "11477906", "id2": "16825994", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadApplicationSettings", "loaddefaultParameters", "loadGlobalSettings", "loadApplicationParameters", "loadGlobalConfiguration", "getdefaultsettings", "getDefaultSettings", "getdefaultSettings", "loadDefaultParameters", "getDefaultParameters", "loaddefaultsettings", "getDefaultsettings", "loaddefaultConfiguration", "getdefaultParameters", "loadApplicationsettings", "loadDefaultsettings", "getdefaultConfiguration", "loadApplicationConfiguration", "loaddefaultSettings", "loadGlobalParameters", "loadGlobalsettings", "getDefaultConfiguration", "loadDefaultConfiguration"], "configFileName": ["configFullLocation", "ConfigModuleName", "configFullUrl", "configModuleName", "configPlaceName", "configFilesTime", "ConfigFileString", "fileFILELocation", "configFileType", "ConfigModuleString", "ConfigFileUrl", "ConfigFileLocation", "configFileUrl", "fileFileType", "configFILETime", "configFILEType", "configFilenameName", "configModuleUrl", "configModuleString", "fileFILETime", "configFilenameType", "configFILELocation", "configFileString", "fileFileName", "configFilesType", "ConfigModuleUrl", "fileFileLocation", "fileFileTime", "configFilenameLocation", "configFilesName", "configPlaceLocation", "fileFILEName", "configFilesLocation", "ConfigModuleLocation", "configFileTime", "configFILEName", "ConfigFileName", "configModuleLocation", "configFilenameTime", "configFullString", "configFullName", "configPlaceUrl", "fileFILEType", "configPlaceString", "configFileLocation"], "in": ["reader", "bin", "login", "f", "data", "it", "socket", "ins", "pin", "m", "stream", "cin", "In", "pc", "base", "is", "log", "inside", "ssl", "conn", "inner", "again", "din", "r", "work", "IN", "err", "plus", "pull", "this", "ini", "i", "source", "init", "inc", "nin", "url", "config", "n", "read", "pass", "inn", "as", "up", "id", "a", "resource", "input", "con", "diff"], "out": ["connection", "bin", "ext", "f", "data", "name", "point", "it", "version", "socket", "error", "s", "sync", "to", "ex", "outs", "one", "timeout", "able", "set", " file", "log", "copy", "conn", "user", "again", "output", "instance", "all", "writer", "and", "err", "password", "o", "off", "client", "OUT", "back", " back", "this", "d", "lib", "image", "inc", "t", "exec", "object", "parent", "default", " output", "view", "server", "config", "null", "io", "net", "c", "up", "file", "prefix", "ou", "exp", "Out", "string", "write", "obj"]}}
{"id1": "14598566", "id2": "14758866", "code1": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"copyFileByNIO": ["copyFilebyNIF", "copyFileByMIP", "copyFilebynio", "copyFileBynIF", "copyFileByFileio", "copyFileByFileIF", "copyFileByNio", "copyFilebyNio", "copyFileByMIO", "copyFileBynIO", "copyFileByNIP", "copyFilebynIP", "copyFilebynIF", "copyFilebyNIO", "copyFileBynIP", "copyFileByNIF", "copyFileByFileIP", "copyFileByMio", "copyFileBynio", "copyFileByFileIO", "copyFilebyNIP", "copyFileByMIF", "copyFilebynIO"], "in": ["x", "reader", "bin", "connection", "login", "data", "name", "at", "ins", "m", "ex", "min", "In", "base", "copy", "part", "b", "inner", "again", "din", "IN", "ini", "buffer", "i", "source", "image", "inc", "or", "h", "url", "io", "inn", "c", "file", "id", "index", "resource", "input", "diff", "ac"], "out": ["connection", "ext", "data", "name", "at", "to", "p", "ex", "outs", "copy", "conn", "w", "b", "output", "part", "cache", "again", "writer", "o", "client", "dest", "OUT", "external", "buffer", "source", "image", "inc", "project", "path", "exec", "object", "v", "n", "io", "c", "file", "prefix", "resource", "target", "Out", "string"], "sourceChannel": ["innerChan", "sourceChan", " sourceConnection", "ourceChan", "innerStream", "sinStream", "SourceChan", " sourceStream", "sinChan", "sinServer", "targetchannel", "sourceServer", "sinChannel", "innerServer", "sourceConnection", "targetChannel", "srcQueue", "srcChannel", "sourceStream", "srcChan", " sourceServer", "sourcechannel", " sourceQueue", " sourcechannel", "ourceConnection", "sourceQueue", "innerChannel", "ourceStream", "SourceConnection", "ourcechannel", "SourceStream", "targetConnection", "ourceChannel", "SourceChannel", "Sourcechannel", "srcConnection", " sourceChan", "targetChan", "ourceQueue"], "destinationChannel": ["DestinationContext", "DestinationChannel", "destinatorConnection", "destinateStream", "destinatorClient", "destinateConnection", "DestinationStream", "DestinatorStream", "destributionContext", "destroyingConnection", "destinationStream", "destionConnection", "destroyingChannel", "destinationContext", "destinationConnection", "DestinatorChannel", "destributionChan", "DestinationConnection", "destinatorChannel", "destinatedStream", "destinatorChan", "DestinatorConnection", "destinatorStream", "destionChannel", "DestinatorChan", "DestinationClient", "destionClient", "destinatedContext", "destroyingStream", "destinatorContext", "destinationChan", "destinatedChan", "DestinatorClient", "destinationClient", "destionChan", "DestinatorContext", "destributionClient", "DestinationChan", "destributionChannel", "destributionConnection", "destinateChannel", "destinatedChannel", "destributionStream"]}}
{"id1": "596993", "id2": "7143591", "code1": "    private String makeLoginRequest(URL url) throws IOException {\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setDoInput(true);\n        urlConnection.setDoOutput(true);\n        urlConnection.setUseCaches(false);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"Email=\").append(URLEncoder.encode(EMAIL, \"UTF-8\"));\n        content.append(\"&Passwd=\").append(URLEncoder.encode(PASSWORD, \"UTF-8\"));\n        content.append(\"&service=\").append(URLEncoder.encode(SERVICE, \"UTF-8\"));\n        content.append(\"&source=\").append(URLEncoder.encode(\"Google Base data API\", \"UTF-8\"));\n        OutputStream outputStream = urlConnection.getOutputStream();\n        outputStream.write(content.toString().getBytes(\"UTF-8\"));\n        outputStream.close();\n        int responseCode = urlConnection.getResponseCode();\n        InputStream inputStream;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = urlConnection.getInputStream();\n        } else {\n            inputStream = urlConnection.getErrorStream();\n        }\n        return toString(inputStream);\n    }\n", "code2": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "label": 0, "substitutes": {"makeLoginRequest": [" makeloginCall", " makeJSONRequest", " makeAuthCall", "makeLoginCall", " makeJSONCall", " makeJSONPost", " makeAuthRequest", "makeAuthResponse", " makeJSONResponse", " makeLoginCall", " makeLoginResponse", " makeLoginPost", "makeLoginPost", " makeloginResponse", "makeAuthCall", "makeAuthRequest", " makeAuthPost", " makeloginPost", " makeloginRequest", "makeLoginResponse", "makeAuthPost", " makeAuthResponse"], "url": ["connection", "sl", "f", "org", "twitter", "email", "ur", "gl", "web", "download", "str", "base", "ssl", "log", "lc", "page", "u", "conn", "loader", "l", "o", "client", "address", "Url", "service", "URL", "build", "image", "source", "t", "object", "config", "server", "uri", "http", "c", "file", "resource", "www", "orb", "link", " URL", "string", "obj", "ob"], "urlConnection": ["webConnector", "urlUnit", " urlServer", "lUnit", "UrlFunction", "publicConnect", "URLUnit", "slConnection", "slStream", "webNode", "slBody", "userConnector", "UrlCode", "urlConnect", "publicConnection", "sslConnect", "URLCon", "urlStream", " urlSource", " urlConn", "lDescription", "webFunction", "publicUnit", "httpConn", "URLconnection", "fileBody", " urlconnection", "fileConn", "sslConnection", "userConnect", "UrlConnect", "sslSource", "lConnection", "urlCon", "slDescription", "UrlSocket", "publicCode", "URLConn", "URLSocket", "urlServer", "sslConnector", "urlNode", "URLStream", "slUnit", "fileCode", "urlconnection", " urlStream", "eventConnection", "fileConnection", "UrlUnit", "urlDescription", " urlConnect", "URLNode", " urlConnector", "fileConnect", "webSocket", "userConnection", "fileConnector", "httpConnector", "httpCon", "UrlConnector", " urlCode", "UrlStream", "fileStream", "URLConnect", "URLCode", "webConnection", "URLConnection", "webConn", "URLServer", " urlSocket", " urlBody", " urlUnit", " urlFunction", " urlDescription", "eventServer", "URLConnector", "urlBody", "userSource", " urlCon", " urlNode", "eventFunction", "slConnect", "urlCode", "urlSource", "urlConn", "lConnect", "urlConnector", "URLFunction", "eventconnection", "UrlConnection", "webCode", "urlFunction", "urlSocket", "httpConnection"], "content": ["feature", "connection", "job", "full", "data", "current", "version", "complete", "create", "language", "body", "string", "cont", "layer", "info", "application", "load", "xml", "activity", "expression", "lc", "format", "model", "page", "more", "text", "output", "size", "time", "section", "work", "query", "key", "address", "Content", "currency", "comment", "service", "source", "buffer", "image", "child", "value", "cf", "request", "response", "exec", "write", "context", "config", "document", "code", "server", "core", "function", "script", "word", "message", "header", "resource", "result", "host", "software", "json", "html", "media"], "outputStream": ["inputSteam", " outputChannel", "OutputSteam", "controlSteam", "outStream", "OutputChannel", "leftWriter", "controlPath", "leftStream", "outSteam", "responsestream", "OutputStream", "outputStreamer", "OutputWriter", "leftStreamer", "outputPath", "outputWriter", "responsePath", " outputstream", "outStreamer", " outputWriter", "responseStream", "inputChannel", "responseSteam", " outputPath", " outputSteam", "outputChannel", "outputSteam", "controlstream", "outWriter", "controlStream", "leftSteam", "inputWriter", "outputstream", "OutputStreamer"], "responseCode": [" responseCount", "statusStatus", "ResponseMessage", "ResponseCode", "statusType", "ResponseStatus", "ResponseType", "statusCode", "respMessage", "responseStatus", " responseText", "ResponseCount", "responseText", "respCount", "statusText", " responseMessage", "ResponseText", "respCode", " responseStatus", "responseCount", "responseType", "responseMessage", "respType", " responseType"], "inputStream": ["tempFlow", " inputstream", " inputFlow", "inputFlow", "feedStream", "inputSteam", "upStream", "InputForm", "tempStream", "upSteam", "outputFlow", "outputForm", "feedSteam", "InputStream", "upView", "InputStreamer", "inputView", "tempstream", " inputView", "inputStreamer", "feedView", " inputForm", " inputStreamer", "InputView", "upStreamer", "inputForm", "outputSteam", "InputSteam", "feedStreamer", "inputstream", " inputSteam", "tempSteam", "outputstream"]}}
{"id1": "21182766", "id2": "16353490", "code1": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "code2": "    private String executePost(String targetURL, String urlParameters) {\n        URL url;\n        HttpURLConnection connection = null;\n        try {\n            url = new URL(targetURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(urlParameters.getBytes().length));\n            connection.setRequestProperty(\"Content-Language\", \"en-US\");\n            connection.setUseCaches(false);\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            wr.writeBytes(urlParameters);\n            wr.flush();\n            wr.close();\n            InputStream is = connection.getInputStream();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n            String line;\n            StringBuffer response = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                response.append(line);\n                response.append('\\r');\n            }\n            rd.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"load": ["save", "get", "loaded", "create", "install", "info", "download", "setup", "proc", "find", "set", "dump", "class", "add", "copy", "check", "LOAD", "loader", "loading", "include", "construct", "call", "parse", "build", "init", "pack", "use", "loads", "process", "path", "delete", "update", "config", "store", "read", "Load", "resource", "resources", "write", "start"], "propsName": ["propertiesPath", "pepertiesNames", "comppertiesname", "proPSDesc", "profsPath", "pepertiesname", "comppertiesDesc", "profsDesc", "comppertiesPath", "comppsDesc", "proPSNames", "pepsPath", "comppertiesName", "comppsname", "propsPath", "propertiesNames", "pepertiesName", "pepsname", "comppsPath", "proPSPath", "propsNames", "propsDesc", "proPSname", "comppsName", "propertiesDesc", "profsname", "propertiesname", "profsName", "proPSName", "pepsName", "profsNames", "pepsNames", "propsname", "propertiesName", "pepertiesPath"], "props": ["crops", "cropps", "propr", "comppos", "protps", "protpr", "prids", "compbs", "prods", "prots", "pets", "procs", "Procs", "prets", "prperties", "prebs", "compds", "Probs", "croperties", "perpos", "Prots", "perps", "prps", "pripos", "perbs", "prips", "pebs", "pecs", "compps", "propps", "prpr", "peps", "protpps", "propos", "perds", "Props", "preps", "pribs", "properties", "cropr", "probs", "precs", "prpps", "protperties"], "url": ["sl", "f", "data", "name", "fl", "channel", "gl", "stream", "not", "jar", "xml", "event", "base", "ssl", "page", "b", "loader", "user", "l", "r", "e", "Url", "service", "URL", "source", "i", "buffer", "feed", "api", "path", "cl", "config", "server", "uri", "browser", "http", "file", "id", "src", "resource", "bel", "ref", "location", "ob"]}}
{"id1": "5744493", "id2": "8747840", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": ["newFileCopy", " doFilecopy", " dofileCopy", "newFilecopy", " doFileWrite", "newBlockProxy", " dofilecopy", " dofileWrite", " doFolderCopy", " doFolderWrite", "newBlockCopy", " doBlockWrite", " doFolderProxy", " doFoldercopy", "newFileProxy", " doFileCopy", "newFileWrite", " doBlockProxy", " doBlockCopy", "newBlockWrite", " dofileProxy", " doFileProxy", " doBlockcopy", "newBlockcopy"], "in": ["reader", "bin", "lock", "isin", "login", "data", "name", "ins", "pin", "m", "ex", "min", "In", "base", "part", "b", "inner", "again", "win", "query", "IN", "err", "buffer", "i", "source", "image", "inc", "url", "config", "inn", "c", "file", "id", "index", "lin", "input", "diff"], "out": ["connection", "ext", "name", "point", "socket", "ex", "outs", "plain", "base", "copy", "page", "cache", "conn", "again", "output", "b", "user", "part", "writer", "pre", "dot", "off", "o", "OUT", "temp", "external", "buffer", "source", "image", "exec", "v", "default", "server", "io", "file", "prefix", "resource", "target", "Out", "string", "write"], "inChannel": [" inchannel", "INSocket", "INChannel", "binStream", "INChan", "InSocket", "outStream", "Inchannel", "InChan", "InStream", "inchannel", "inputSocket", " inChan", "outchannel", "INClient", " inStream", "binChannel", "outChan", "outSocket", "inClient", "INchannel", "inputChan", "inputChannel", "inChan", "inputStream", "inSocket", "inStream", "binChan", " inClient", "InChannel", "outClient", "INStream", "binSocket", " inSocket"], "outChannel": ["intChan", "inButton", " outButton", " outStream", "againStream", "outStream", "intchannel", "inchannel", "againChannel", "outchannel", "OutBuffer", "againSocket", "OutChan", "OutContainer", " outChan", "outChan", "outContainer", "againChan", "OutStream", "inContainer", "outSocket", " outBuffer", "intButton", "OutChannel", "inChan", " outSocket", "outButton", " outContainer", "inSocket", "inStream", " outchannel", "inBuffer", "intChannel", "outBuffer"], "maxCount": ["blockSize", " maxcount", "axSize", "axLength", "MaxSum", "MaxSize", "maxSum", "axCount", " maxSize", " maxLength", "blockcount", "maxSize", "blockSum", "maxcount", " maxSum", "MaxCount", "Maxcount", "blockCount", "MaxLength", "axcount", "maxLength"], "size": ["offset", "volume", "loc", "data", "name", "sized", "scale", "type", "range", "cap", "p", "send", "mode", "min", "Size", "en", "position", "shift", "time", "bytes", "max", "capacity", "shape", "flush", "address", "seek", "count", "limit", "speed", "sum", "width", "transfer", "n", "small", "unit", "empty", "SIZE", "len", "ize", "available", "length", "fee", "start", "end"], "pos": ["offset", "pose", "open", "iter", "loc", "data", "point", "cos", "slice", "pt", "p", "min", "os", "base", "position", "part", "Pos", "val", "o", "off", "address", "pointer", "count", "i", "block", "port", "limit", "spec", "slot", "pid", " position", "no", "POS", "pass", "unit", "rel", "neg", "id", "index", "len", "po", "obj", "diff", "ref", "length", "push", "start"]}}
{"id1": "5061606", "id2": "4599372", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNecccessary", "createSettingsIfNecesary", "createSettingsIfNequccessnecessary", "createSettingsIfNecesarily", "createSettingsIfNececarily", "createSettingsIfNequccessarily", "createSettingsIfNequccessary", "createSettingsIfNecesseless", "createSettingsIfNecessnecessary", "createSettingsIfNecessarily", "createSettingsIfNececary", "createSettingsIfNecesnecessary", "createSettingsIfNecccesseless", "createSettingsIfNequccesseless", "createSettingsIfNececeless", "createSettingsIfNececnecessary", "createSettingsIfNecccessnecessary", "createSettingsIfNequessary", "createSettingsIfNeceseless", "createSettingsIfNecccessarily", "createSettingsIfNequesseless", "createSettingsIfNequessnecessary", "createSettingsIfNequessarily"], "out": ["connection", "bin", "lock", "app", "data", "name", "socket", "at", "pool", "error", "channel", "array", "sync", "ex", "outs", "timeout", "plain", "log", "plugin", "copy", "model", "page", "conn", "cache", "again", "output", "user", "by", "writer", "err", "password", "o", "flush", "client", "OUT", "off", "this", "i", "source", "image", "init", "cookie", "path", "exec", "object", "parent", "exit", "url", "config", "group", "server", "null", "io", "net", "file", "up", "index", "a", "prefix", "result", "window", "Out", "write", "obj", "editor"], "fSettings": ["FConfig", "fConfig", "fileSettings", "fJs", "Fsettings", "sfsettings", "fileSetting", " fSetting", "fsConfig", "fettings", " fFs", "filesettings", "FSettings", "fSetting", "fmSettings", " fJs", "sfJs", "FJs", "sfettings", "fsSettings", "fsSetting", "sfSetting", "fmSetting", "FSetting", "rfSettings", "sfSettings", "fmSetup", " fConfig", " fettings", "rfSetting", "rfFs", "fFs", "fmConfig", "fsSetup", "fileettings", "rfConfig", "FSetup", " fsettings", "fsettings", "fsFs", "fSetup"], "src": ["cur", "sl", "cb", "loc", "gb", "sc", "ins", "ctr", "stream", "st", "settings", "str", "rc", "base", "prot", "ource", "ssl", "req", "b", "text", "img", "lower", "dist", "dest", "rb", "source", "storage", "sub", "uc", "path", "filename", "attr", "url", "config", "uri", "route", "file", "sr", "sel", "sb", "fp", "ref", "string", "tmp"], "in": ["reader", "bin", "connection", "sin", "f", "data", "login", "s", "ins", "stream", "In", "kin", "copy", "b", "inner", "again", "rin", "win", "din", "l", "r", "IN", "err", "ini", "i", "source", "image", "init", "inc", "path", "url", "n", "thin", "inn", "c", "file", "id", "index", "input", "con", "gin"]}}
{"id1": "23611770", "id2": "15645004", "code1": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"handle": [" post", " transport", " abort", "Handle", " process", " reload", " append", " redirect", " handles", " rewrite", " execute", " handler", " fn", " shutdown", " rename", " transform", " serve", " manage", "process", "transfer", " upload", " perform", " loop", " work", " restart", " next", " transfer", " operate"], "srcChannel": ["rcClient", "sourceChan", "rcConnection", "destClient", "sourceClient", " srcchannel", "destChan", "sourceChannel", "rcChan", "sourceConnection", " srcConnection", "srcClient", "srcChan", "sourcechannel", "srcchannel", "rcChannel", "destchannel", " srcClient", "srcConnection", " srcChan"], "destChannel": ["DestStream", "srcSocket", "sourceChan", " destHandler", " destSocket", " destStream", "Destchannel", "destStream", "DestCan", "descCan", "distStream", "distChannel", "destChan", "sourceChannel", "distChan", "DestChannel", "destCan", "descHandler", " destchannel", "srcChan", "destSocket", "DestHandler", " destChan", " destCan", "descChan", "destHandler", "sourceSocket", "distchannel", "destchannel", "descChannel", "DestChan"], "destOutFile": ["destPathfile", "destPointFile", "DestInFile", "destOutputFile", "tempOutSite", "destTemplatefile", "destOutSite", "destOutputSite", "destInDir", "DestInDirectory", "destInDirectory", "destoutDir", "destoutCode", " destOutfile", "destLogFilename", "tempOutDir", "DestInFiles", "destoutFiles", " destOutPath", "destPathFile", "DestOutfile", "destPathFiles", "destOutfile", "featOutFile", "featTemplatefile", "destActionfile", "destPointDir", " destOutputPath", "destOutDir", "destOUTCode", "destInFile", "featTemplateFiles", " destOutputFile", "DestInFilename", "featTemplateFile", "destInPath", " destPathFiles", " destOutputFilename", "destOUTSite", " destOutDir", "featOutFiles", "destOUTFile", " destOutputFiles", "destOutFiles", "destPathDir", "destOUTFiles", " destPathDir", "featOutDir", "destOUTDir", "tempOutFiles", "destOutputfile", "DestOutDirectory", "destLogFiles", "destOutputPath", "destInfile", "DestOutFile", "DestOutCode", "tempOutputFiles", "DestInCode", "tempOutputDir", "DestOutFiles", "DestOutFilename", "destInCode", "destOutputDirectory", "DestInfile", "destActionFile", "destInSite", " destOutFilename", "destInFiles", "destOutCode", " destPathFile", "destoutFile", "tempOutFile", " destPathfile", "destLogFile", "tempOutputSite", "destPointFilename", "DestInDir", "destTemplateFile", "destOutputDir", "destOutFilename", "destLogPath", "featTemplateDir", "destActionDir", "featOutfile", "destPointDirectory", "destTemplateDir", "destOutputFiles", "destInFilename", "destOutPath", "tempOutputFile", "destTemplateFiles", " destOutFiles", "destActionFiles", "destOutputFilename", "DestOutDir", "destOutDirectory"], "destOutFileCompressed": ["destOutFileSupression", "destOutFilesExported", "destOutFilesCompacted", "destOutFilesCompressor", "destOutFileExressor", "destOutLineCompressor", "destOutLineExpressed", "destOutFileEncressed", "destOutFilesComposed", "destOutLineExpression", "destOutFileExressed", "destOutFileExposed", "destOutFileSuppressed", "destOutFileExplied", "destOutLineCompacted", "destOutFilesExplied", "destOutFileExpression", "destOutFilesExpress", "destOutFileRepressed", "destOutLineRepressor", "destOutFileExpressed", "destOutLineCompress", "destOutFilecompressed", "destOutFileSuposed", "destOutFileExress", "destOutLineRepressed", "destOutLineRepression", "destOutFileSupressed", "destOutFilesCompression", "destOutFilesComplied", "destOutFileRepression", "destOutFilesExposed", "destOutFileExacted", "destOutFileSuppressor", "destOutLineRepacted", "destOutFileExpacted", "destOutFileComposed", "destOutFilecompression", "destOutFileEncorted", "destOutFileSuppacted", "destOutFileCompress", "destOutFileExosed", "destOutFileExpress", "destOutFileComplied", "destOutFileReposed", "destOutFilesCompressed", "destOutFileExported", "destOutFilecompress", "destOutFileEncress", "destOutFileSupress", "destOutLineExpressor", "destOutFilesCompress", "destOutLineExposed", "destOutLineRepress", "destOutLineCompression", "destOutFileCompression", "destOutFilesExpression", "destOutFileRepressor", "destOutFilesExpressed", "destOutFileCompacted", "destOutFilesExpressor", "destOutFileExorted", "destOutLineCompressed", "destOutFilesComported", "destOutLineComposed", "destOutFileReplied", "destOutFilesExpacted", "destOutFileComported", "destOutFileSuppress", "destOutFilecompacted", "destOutFilecompressor", "destOutFileRepacted", "destOutFileExpressor", "destOutFileRepress", "destOutFileCompressor", "destOutFileEncosed"], "out": ["full", "lock", "bin", "connection", "extra", "ext", "data", "doc", "name", "self", "socket", "error", "sync", "to", "ex", "outs", "one", "plain", "log", "copy", "conn", "w", "b", "output", "user", "again", "inner", "img", "part", "cache", "line", "writer", "cmd", "err", "o", "flush", "client", "OUT", "temp", "this", "key", "source", "image", "inc", "outer", "exec", "parent", "n", "conv", "post", "null", "io", "net", "server", "up", "file", "co", "resource", "exp", "Out", "obj"], "in": ["reader", "bin", "connection", "isin", "sin", "f", "login", "into", "data", "socket", "ins", "pin", "to", "cin", "min", "In", "log", "is", "part", "b", "inner", "again", "rin", "conn", "img", "win", "din", "l", "r", "IN", "err", "o", "pull", "ini", "source", "init", "image", "inc", "nin", "h", "config", "pass", "inn", "c", "up", "wave", "id", "file", "a", "lin", "token", "input", "con", "diff", "resource", "ac", "gin", "serv"], "buf": ["job", "cur", "cb", "bd", "seq", "data", "loc", "ff", "batch", "pool", "buff", "info", "Buffer", "cap", "bh", "rc", "log", "bl", "feat", "bb", "lc", "base", "b", "vec", "br", "num", "bytes", "box", "text", "val", "bag", "off", "la", "rb", "buffer", "block", "map", "ctx", "port", "uc", "lb", "path", "v", "context", "config", "cv", "func", "wb", "wave", "file", "pos", "src", "uf", "cas", "queue", "header", "bf", " buffer", "input", "ref", "pad", "result", "fb", "bc"], "len": ["nt", "lock", "le", "sl", "iter", "f", "data", "loc", "fl", "lim", "el", "rev", "body", "cap", "min", "en", "ind", " length", "ie", "ll", "lc", "part", "size", "num", "l", "line", "val", "pre", " lang", "lf", "la", "count", "limit", "url", "no", "li", "n", "led", "id", "pos", "lin", "fin", "Len", "length", "ln", "ler", "end"]}}
{"id1": "16556717", "id2": "13783549", "code1": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"getSHADigest": ["getSHADIGEST", "getSHAPigher", "getSHAPigest", "getSHADigester", "getSHADegher", "getSHAPigester", "getSHADipEST", "getSHADIGest", "getSHAPegest", "getSHAPegher", "getSHADegest", "getSHAPegester", "getSHADIGher", "getSHADipest", "getSHAPigEST", "getSHAPegEST", "getSHADegEST", "getSHADigEST", "getSHADigher", "getSHADipester", "getSHADIGester", "getSHADipher", "getSHADegester"], "password": ["data", "name", "email", "wd", "p", "encrypted", "Pass", "words", "user", "text", "Password", "key", "address", "secret", "crypt", "buffer", "padding", " passwords", "sword", "PASS", "path", "hash", "phrase", "pattern", "attribute", "config", "code", "pass", "id", "word", "prefix", "token", "input", "security", "auth", "string", "username"], "digest": ["digress", "greatester", "generhest", "generest", "hashress", "DigEST", "Digester", "Digusher", "digesting", "greatEST", "hexkey", "Digkey", "hashester", "generester", "hashkey", "Digesting", "hashusher", " digesting", " digusher", "greatesting", " digress", "dighest", "digester", "digEST", "hashString", "greatest", "digString", " dighest", "hashests", "Dighest", "hexString", " digEST", "hexest", "digusher", "generEST", "digests", "hashest", "hexests", "Digress", "Digests", " digester", "Digest", "digkey", "DigString"], "sha": ["ema", "meta", "volume", "qa", "ka", "ha", "oa", "ah", "si", "ua", "cca", "ca", "aa", "ma", "na", "da", "pi", "lambda", "shi", "acl", "ami", "acha", "ph", "mac", "alias", "ppa", "va", "la", "wa", "api", "ba", "h", "hash", "asha", "sum", "sa", "ssh", " SHA", "ga", "a", "pa", "eta", "po", "ta", "mc", "hh", "pg", "slave", "alpha", "SHA", "sh", "HA"], "pwhash": [" pwashed", "jpwhash", "pwheest", "jpwha", "jpWHest", "pWHash", "jpwhashed", "jpWHashed", "pphade", " pwade", "pwa", "pwest", " pwhashed", "pwheashed", "jpwhest", "pwheash", " pwhest", "pwha", "pWhash", "pWHa", "pwhade", "pWHashed", "pphashed", "pWhest", "pWhashed", "pWHest", "pwade", "pphest", " pwest", "pWhade", "pwhea", " pwash", "pwhest", "jpWHash", "jpWHa", "pwash", " pwhade", "pwashed", "pphash", "pwhashed"]}}
{"id1": "21368981", "id2": "8942491", "code1": "    public APIResponse create(Application application) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/application/create\").openConnection();\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n        connection.setUseCaches(false);\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\")));\n        connection.getOutputStream().flush();\n        connection.getOutputStream().close();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine()));\n            response.setDone(true);\n            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));\n            connection.getInputStream().close();\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Create Application Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    public static URLConnection openProxiedConnection(URL url) throws IOException {\n        if (proxyHost != null) {\n            System.getProperties().put(\"proxySet\", \"true\");\n            System.getProperties().put(\"proxyHost\", proxyHost);\n            System.getProperties().put(\"proxyPort\", proxyPort);\n        }\n        URLConnection cnx = url.openConnection();\n        if (proxyUsername != null) {\n            cnx.setRequestProperty(\"Proxy-Authorization\", proxyEncodedPassword);\n        }\n        return cnx;\n    }\n", "label": 0, "substitutes": {"create": ["save", "open", "get", "complete", "type", "send", "setup", "add", "construct", "call", "run", "api", "request", "Create", "process", "POST", "creat", "delete", "update", "post", "make", "message", "execute", "write", "start"], "application": ["x", "app", "current", "name", "version", "database", "android", "audio", "apache", "language", "array", "layer", "xml", "expression", "base", "class", "component", "page", "Application", "video", "instance", "output", "bean", "address", "external", "service", "api", "project", "request", "object", "system", "attribute", "config", "document", "unit", "http", "a", "message", "resource", "apply"], "response": ["answer", "data", "tree", "ception", "manager", "version", "error", "handler", "respond", "session", "reference", "ae", "Response", "status", "position", "model", "description", "more", "part", "user", "page", "output", "success", "writer", "collection", "client", "reply", "service", "entry", "image", "feed", "api", "example", "request", "value", "object", "next", "offer", "document", "view", "server", "esi", "http", "function", "index", "message", "result", "resource", "host", "report", "onse", "json", "dict", "resp", "site"], "connection": ["office", "statement", "current", "version", "machine", "channel", "creator", "operation", "wrapper", "section", "creation", "cli", "source", "url", "number", "uri", "io", "function", "message", "directory", "socket", "error", "session", "handler", "log", "position", "conn", "cache", "inner", "entity", "bug", "query", "engine", "client", "connected", "builder", "environment", "character", "context", "document", "Connection", "communication", "bc", "node", "union", "loc", "database", "remote", "command", "reference", "expression", "component", "part", "writer", "collection", "image", "connect", "config", "relation", "location", "network", "graph", "manager", "event", "timeout", "text", "translation", "password", "proxy", "condition", "entry", "object", "ion", "system", "server", "link"], "obj": ["active", "cdn", "data", "oa", "bj", "arr", "body", "j", "info", "ns", "art", "conn", "b", "part", "output", "txt", "r", "line", "aj", "o", "list", "map", "Obj", "ctx", "js", "objects", "object", "ass", "obo", "code", "n", "tmp", "ose", "rt", "co", "po", "result", "res", "out", "adj", "coll", "so", "json", "nb", "ob", "resp", "act"]}}
{"id1": "11962480", "id2": "4562786", "code1": "    public void read(String skeletonFilename) throws Exception {\n        ClassLoader loader = UnicodePropertiesSkeleton.class.getClassLoader();\n        URL url = loader.getResource(skeletonFilename);\n        if (null == url) {\n            throw new Exception(\"Cannot locate '\" + skeletonFilename + \"' - aborting.\");\n        }\n        String line;\n        StringBuilder section = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n        while (null != (line = reader.readLine())) {\n            if (line.startsWith(\"---\")) {\n                sections.add(section.toString());\n                section.setLength(0);\n            } else {\n                section.append(line);\n                section.append(NL);\n            }\n        }\n        if (section.length() > 0) {\n            sections.add(section.toString());\n        }\n        if (sections.size() != size) {\n            throw new Exception(\"Skeleton file '\" + skeletonFilename + \"' has \" + sections.size() + \" static sections, but \" + size + \" were expected.\");\n        }\n    }\n", "code2": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "label": 1, "substitutes": {"read": ["open", "readable", "get", "Read", "create", "download", "load", "find", "add", "copy", "register", "check", "construct", "parse", "build", "init", "process", "store", "split", "transform", "resource", "replace", "print", "report", "write", "start"], "skeletonFilename": ["southeastFile", "sletonFilename", " skelFilename", " skelFile", "sletonfilename", "skeletonSourceFile", "southeastFilename", "skelDownload", "SkeletonSourceFile", "sletonSourceFile", "skelFile", "SkelFilename", "SkelDownload", "skelSourceFile", "skeletonDownload", "SkeletonDownload", "sleeFilename", " skeletonFile", "southeastSourceFile", "sletonFile", "Skelfilename", "skelFilename", " skelSourceFile", "sleeFile", "skeletonFile", "SkelFile", "SkelSourceFile", " skeletonfilename", " skelfilename", "SkeletonFile", "Skeletonfilename", "sleeSourceFile", "sletonDownload", "sleefilename", "southeastDownload", "skelfilename", "skeletonfilename", "SkeletonFilename", " skeletonSourceFile"], "loader": ["lock", "er", "loc", "loaded", "name", "handler", "Loader", "layer", "load", "class", "log", "lc", "base", "cache", "b", "loading", "l", "r", "err", "parser", "lang", "buffer", "source", "init", "builder", "driver", "path", "system", "cl", "config", "server", "null", "http", "CL", "in", "file", "impl", "resource", "rl"], "url": ["connection", "sl", "cdn", "f", "data", "loc", "name", "ur", "load", "base", "ssl", "page", "b", "user", "l", "r", "client", "address", "Url", "buffer", "URL", "source", "service", "i", "image", "api", "lib", "feed", "path", "object", "uri", "server", "browser", "http", "file", "resource", "bel", "coll", "host", "location", "rl", "rel", "string"], "line": ["job", "le", "sl", "data", "name", "lo", "body", "sync", "se", "str", "definition", "letter", "log", "base", "inline", "lc", "page", "part", "text", "user", "content", "l", "cell", "L", "lines", "lf", "key", "row", "comment", "i", "entry", "source", "style", "parse", "Line", "write", "no", "cl", "number", "nl", "code", "unit", "pe", "file", "split", "LINE", "word", "lin", "item", "result", "header", "link", "string", "liner", "strip"], "section": ["job", "connection", "union", "region", "data", "division", "sect", "sections", "layout", "version", "handler", " intersection", "array", "layer", "body", "se", "sector", "definition", "letter", "rule", "lc", "format", "position", "page", "description", "text", "output", "contract", "content", "article", "zip", "writer", "journal", "patch", "parser", "key", "row", "service", "style", "entry", "ner", "block", "storage", "feed", "sub", "builder", "source", "parent", "sec", "character", "config", "server", "null", "element", "file", "Section", "function", "script", "search", "draft", "chapter", "join", "length", "location", "area", "string", "ler", "option", "editor"], "reader": ["iter", "er", "f", "ri", "handler", "worker", "stream", "layer", "per", "inner", "r", "writer", "rer", "parser", "rr", "row", "buffer", "i", "ner", "oder", "feed", "builder", "driver", "reading", "bird", "io", "file", "rar", "resource", "input", "ler", "Reader", "editor", "rx"]}}
{"id1": "2642914", "id2": "18748516", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToZipGzip", "addFileToTarGarx", "addFileToTarGszi", "addFileToZipGszi", "addFileToZipGarz", "addFileToZipGgz", "addFileToTarGgz", "addFileToTarggz", "addFileToTargz", "addFileToZipGarzip", "addFileToTarGszip", "addFileToZipGarzi", "addFileToZipGz", "addFileToTarGuzi", "addFileToTarGsgz", "addFileToZipGarx", "addFileToTarGsz", "addFileToTarGarzi", "addFileToZipGsz", "addFileToTarGzip", "addFileToTarGarzip", "addFileToTarGzi", "addFileToTargx", "addFileToTargzip", "addFileToTarGux", "addFileToZipGx", "addFileToTarGx", "addFileToZipGsgz", "addFileToZipGszip", "addFileToTarGargz", "addFileToZipGzi", "addFileToTarGuzip", "addFileToTargzi", "addFileToTarGuz", "addFileToTarGarz"], "taro": ["Tero", "thoro", "fargo", "toro", "Tamar", " too", "ataro", "staro", "toran", "taron", "ptaro", "atro", " tro", "atoran", "fara", "Tro", "Taron", " tara", "tabo", "thaco", "stoo", "laro", "lro", "tamar", "staco", "Targo", "ptargo", "too", " tabo", " tero", "ptaco", "targo", "stamar", "largo", " targo", "ptabo", "stro", "tharo", "faco", "stero", "taco", "ptaron", "Toro", "Toran", "Tara", "Taco", "Too", "tara", "thamar", "tero", "storo", "atargo", " taco", "Tabo", "Taro", "loran", " taron", "faro", "tro"], "path": ["data", "loc", "name", "type", "from", "p", "str", "log", "cache", "text", "root", "fn", "key", "pointer", "source", "image", "parent", "filename", "pattern", "object", "url", "uri", "route", "c", "file", "folder", "id", "PATH", "ath", "Path", "resource", "dir", "ref", "location", "directory", "string"], "base": ["extra", "ase", "absolute", "name", "type", "from", "p", "cache", "b", "part", "root", "pre", "key", "address", "back", "buffer", "api", "relative", "parent", "bas", "url", "default", "store", "uri", "server", "core", "http", "file", "id", "index", "prefix", "Base", "resource", "bf", "dir", "home", "area", "string", "start", "site"], "f": ["df", "inf", "fac", "self", "fen", "aff", "s", "g", "m", "raf", "p", "j", "fe", "b", "w", "rf", "F", "l", "r", "fn", "fold", "e", "tf", "fr", "lf", "this", "d", "i", "fx", "found", "feed", "t", "cf", "h", "of", "v", "form", "url", "n", "flat", "c", "file", "fa", "af", "fd", "bf", "sf", "fp", "fo", "ref", "framework", "fc", "fb", "fs"], "entryName": ["fileType", "fileName", "EntryName", "resourcePath", "entryname", "EntryType", " entryPath", "archivePath", " entryTime", "archiveSize", "entryTime", "resourceSize", " entryname", "elementType", " entryType", "archiveName", "EntryTime", "filePath", "entrySize", "resourceName", " entrySize", "entryPath", "elementName", "archivename", "entryType", "fileTime", "elementTime", "elementPath", "EntryPath", "resourcename"], "goIn": ["GoIN", "gain", "poin", "goIN", "GOOut", "loin", "coIn", "GOIn", "GoIn", "goIns", "GOIN", "poIN", "poIns", "GOIns", "loIn", "GOin", "GoIns", "gaIn", "poIn", "goin", "gaIN", "loIN", "gaIns", "goOut", "poOut", "coin", "coOut", "Goin", "coIns", "loIns"], "tarEntry": ["rarEnt", " tarEnt", " tarentry", "tarFile", "zipFile", " tarInfo", "Tarentry", " tarFile", "tarElement", "TarEntry", "TarElement", "zipEnt", " TarEntry", "tarentry", "zipInfo", " TarElement", "tarEnt", "zipEntry", "rarEntry", "rarFile", "rarInfo", " Tarentry", " tarElement", "tarInfo"], "children": ["ul", "pages", "open", "scenes", "values", "current", "blocks", "data", "name", "rows", "loc", "pool", "packages", "ins", "balls", "bars", "web", "parents", "father", "words", "roots", "all", "files", "output", "ools", "content", "members", "when", "Children", "each", "ales", "pes", "which", "kids", "sub", "feed", "parent", "h", "far", "ren", "other", "iblings", "many", "well", "jobs", "ports", "opens", "plugins"], "child": ["connection", "job", "lib", "data", "Child", "name", "channel", "pool", "hel", "layer", "per", "page", "cloud", "l", "root", "shell", "and", "key", "client", "pull", "row", "i", "entry", "count", "kid", "comment", "ch", "or", "feed", "parent", "build", "code", "server", "c", "in", "file", "id", "draft", "cel", "leaf", "slave"]}}
{"id1": "7276377", "id2": "7908169", "code1": "    public static String checksum(URL url, String algorithm) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(algorithm);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex);\n        }\n        byte[] bytes = new byte[4 * 1024];\n        try {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                int nBytesRead = 0;\n                while ((nBytesRead = in.read(bytes)) > 0) {\n                    messageDigest.update(bytes, 0, nBytesRead);\n                }\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm);\n        }\n        byte[] checksumValue = messageDigest.digest();\n        return digestAsString(checksumValue);\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 0, "substitutes": {"checksum": ["cksums", "checksums", "decum", "decums", " checksums", "checkssum", "cksum", "checksumb", "decsum", "ckssum", " checkssum", "cksumb", "decumb", " checksumb"], "url": ["connection", "sl", "f", "loc", "name", "manager", "email", "ur", "gl", "stream", "download", "str", "base", "rule", "ssl", "ll", "user", "loader", "text", "href", "l", "fr", "address", "Url", "proxy", "URL", "service", "image", "source", "feed", "or", "path", "filename", "config", "uri", "server", "http", "file", "cert", "id", "src", "resource", "host", "location", "string", "username"], "algorithm": [" algorith", "algebra", "Alignment", "malgorithm", "exgorith", "Algo", "Algorithm", "ALgo", "malgo", " algebra", "malignment", "allgo", "Algorith", "ALgorith", " alignment", "exgo", "algo", "allgorith", " algo", "malgebra", "ALgebra", "allgebra", "alignment", "exgebra", "ALgorithm", "exgorithm", "Algebra", "malgorith", "algorith", "allgorithm"], "messageDigest": ["messageMixest", "messageDer", "messagedigess", "messagedigester", "messageMixester", "messagediger", "MessageDesignator", "messageDade", "messagedigator", "messageDigess", "messageDge", "messageRegester", "messageDpe", "MessageDesignest", "messageDse", "MessageDesignester", "messageDigge", "messageDigpe", "MessageMixer", "MessageDse", "messageDigse", "messageDigester", "MessageSignest", "messagedigse", "messageDigator", "messagedigpe", "messageDesignester", "messageSignester", "MessageDade", "MessageDester", "messageRegator", "MessageDigse", "MessageSignester", "messageSignest", "MessageDigest", "MessageDiger", "messageDesignest", "messagedigest", "messageSignge", "messageMixpe", "MessageMixester", "MessageDigess", "messageSignse", "MessageDesigness", "messagedigade", "MessageSignge", "MessageSignse", "messageRegest", "MessageMixest", "MessageDest", "messageRegess", "MessageDigge", "messagedigge", "MessageDigpe", "MessageDigester", "MessageMixpe", "MessageDigade", "messageDesignator", "messageDiger", "messageMixer", "MessageDigator", "messageDesigness", "messageDester", "messageDigade", "messageDest"], "bytes": ["pages", "vals", "values", "blocks", "eps", "rows", "bs", "boot", "ips", "outs", "units", "os", "gets", "reads", "cells", "ls", "words", "items", "parts", "files", "size", "bits", "bles", "zip", "lines", "steps", "resses", "buffer", "pieces", "ipes", "loads", "tes", "objects", "classes", "frames", "vs", "errors", "bps", "seconds", "ones", "es", "resources", "Bytes", "limits"], "in": ["reader", "bin", "isin", "login", "f", "data", "version", "socket", "s", "ins", "m", "stream", "ex", "min", "In", "fe", "gen", "is", "kin", "ssl", "conn", "b", "again", "inner", "rin", "win", "r", "l", "din", "IN", "err", "fr", "client", "ini", "i", "source", "init", "inc", "nin", "n", "inn", "c", "file", "as", "id", "impl", "a", "token", "input", "out", "con", "ac", "gin", "serv"], "nBytesRead": ["nFramesFound", "nByteWritten", " nByteCount", " nByteRead", " nBytesWritten", " nBytesFound", "nBytesWritten", "nCharactersRead", "nByteLength", "nPagesWritten", " nBytesLoad", "nBytesFound", "nPartsWritten", "nFramesRead", "nBytesLength", "nByteRead", "nPagesLength", "nByteFound", "nWordsRead", "nBytesCount", "nPagesRead", "nCharactersCount", "nCharactersLength", " nBytesLength", "nByteCount", "nWordsWritten", "nPartsRead", "nByteLoad", " nByteFound", "nWordsLength", "nCharactersWritten", "nWordsCount", "nBytesLoad", "nPagesFound", "nFramesLength", " nByteLoad", " nBytesCount", " nByteWritten", "nFramesWritten", "nPartsLoad", " nByteLength"], "checksumValue": ["checksupData", "checkssumData", "checksumVal", " checkssumText", " checkssumArray", "checksumberString", "checksupString", " checkssumData", "checkssumString", "checksumText", "checksumberValue", "checksumberText", "checksummValue", " checkssumPath", " checksumText", "checksramValue", "checksummVal", " checksumData", "checksupValue", " checksumString", "checkssumText", " checkssumVal", "checksramArray", "checksupText", " checksumVal", "checksumberData", "checkssumArray", "checksummPath", "checkssumValue", "checksumPath", " checkssumValue", " checkssumString", " checksumArray", "checkssumPath", "checksummArray", "checksramVal", "checksumArray", "checkssumVal", "checksumData", "checksramPath", "checksumString", " checksumPath"]}}
{"id1": "20100809", "id2": "14502142", "code1": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["save", "get", "rm", "archive", "create", "remote", "type", "py", "change", "sync", "ge", "opy", "download", "move", "load", "dump", "part", "share", "zip", "clip", "cop", "patch", "paste", "map", "Copy", "process", "delete", "update", "transfer", "split", "clone", "replace", "cp", " cp", "write"], "srcPath": ["rcDir", "rcFile", "srcFile", "srcHalf", "sourcepath", "rcPath", "sourceDir", "destDir", "rcRoot", "srcpath", "destpath", " srcDir", " srcpath", "srcName", " srcRoot", "srcRoot", "sourceName", "rubypath", "destPath", "rubyPath", "rcHalf", "sourcePath", " srcFile", "rcpath", "rcName", " srcName", "destFile", "rubyRoot", " srcHalf", "sourceRoot", "rubyHalf", "sourceFile", "srcDir"], "dstPath": ["DstLocation", "drcPath", " drcPATH", "drestpath", "drestFile", "dndName", "fftPath", "DrcDir", "dstsName", "drcPATH", "dostPATH", "fstName", "dstsDirectory", "dstName", "dostDirectory", "dostHome", "drcHome", "dstHome", "sdstpath", "dftPath", "dsppath", "dstsDir", " dstHome", "dtdPATH", "Drcpath", "fstPath", "dndFile", "sdostRoot", "dtdpath", "dstsFile", "dspPath", "ddestpath", "dostPath", "dspFile", " dsppath", "dndPath", "sdostpath", "sdstRoot", "DstFile", "fftName", "dftpath", "dstPATH", "dstRoot", "drdFile", "dstsRoot", "drestHome", " drcHome", "dtdPath", " dstPATH", "dstspath", "dftFile", "dostRoot", "DrcUrl", "dstDirectory", "drcRoot", " dstFile", " dspHome", "drcLocation", "fftFile", "DrcLocation", "dstpath", "drestPath", "dstUrl", "dspHome", "ddestLocation", "DrcPath", "dstsLocation", " dstpath", "Dstpath", "dostpath", "dftName", "sdstDirectory", "fftpath", "sdstPath", "drdUrl", "DstDir", "dstDir", " drcPath", "dtdHome", " dspFile", "drcFile", "drcDir", "sdostDirectory", "sdostPath", "drcUrl", "dndUrl", "fstFile", "DstPath", "dstLocation", "dstsPath", "fstpath", "drdpath", "dndpath", " drcpath", "DrcFile", "drdPath", "drcDirectory", "dstFile", "drcpath", "ddestPath", " dspPath", "DstUrl", "ddestDir"], "result": ["feature", "rh", "df", "ure", "true", "force", "card", "master", "reason", "ack", "arr", "results", "event", "rc", "status", "match", "rule", "here", "successful", "ok", "success", "Result", "acc", "val", "err", "member", "dest", "rr", "found", "comment", "inc", "attr", "form", "particip", "sign", "pass", "make", "func", "rar", "valid", "res", "mate", "replace", "report", "start"], "files": ["pages", "f", "images", "data", "blocks", "sections", "ins", "balls", "events", "ips", "Files", "ls", "items", "cells", "models", "bytes", "features", "apps", "sheets", "tools", "lines", "strings", "assets", "objects", "filename", "books", "classes", "names", "boxes", "fields", "keys", "users", "plugins", "resources", "fs"], "file": ["le", "f", "data", "current", "name", "it", "File", "el", "info", "load", "fe", "letter", "per", "rule", "page", "part", "b", "content", "l", "line", "work", "e", "key", "source", "entry", "feed", "ile", "child", "path", "filename", "object", "url", "view", "uri", "unit", "route", "pe", "folder", "id", "queue", "input", "resource", "fp", "string", "use"], "in": ["reader", "bin", "connection", "login", "f", "get", "name", "into", "socket", "s", "ins", "pin", "m", "sync", "p", "cin", "info", "min", "In", "inside", "conn", "b", "inner", "again", "rin", "part", "win", "by", "din", "r", "l", "IN", "err", "work", "client", "pull", "ini", "call", "i", "source", "lib", "image", "init", "inc", "nin", "path", "url", "n", "pass", "server", "view", "thin", "inn", "c", "up", "as", "id", "a", "index", "on", "token", "input", "con", "diff", "ac", "re", "gin", "serv"], "out": ["connection", "bin", "extra", "ext", "name", "point", "manager", "channel", "socket", "pool", "sync", "to", "ex", "outs", "plain", "base", "conn", "b", "again", "output", "cache", "w", "inner", "part", "writer", "by", "serv", "err", "flow", "o", "off", "client", "OUT", "key", "plus", "i", "lib", "image", "inc", "ch", "cookie", "outer", "other", "url", "no", "n", "group", "server", "io", "net", "up", "word", "ou", "with", "home", "exp", "Out", "gin", "write"], "size": ["offset", "open", "loc", "data", "si", "sized", "scale", "name", "type", "send", "mode", "enc", "Size", "en", "shift", "time", "weight", "bytes", "content", "capacity", "shape", "export", "iz", "address", "flush", "ice", "seek", "count", "i", "pack", "clear", "path", "speed", "sec", "age", "order", "close", "sum", "eng", "number", "width", "transfer", "unit", "empty", "small", "code", "SIZE", "id", "len", "ize", "length", "write", "end", "now"], "buf": ["job", "bin", "cb", "bd", "seq", "data", "ha", "ff", "av", "batch", "BU", "buff", "cap", "Buffer", "rc", "feat", "b", "vec", "br", "bytes", "box", "r", "line", "bag", "la", "rb", "abi", "buffer", "cmp", "map", "uc", "cf", "ba", "cv", "uf", "cas", "coll", "bf", "fb", "bc", "pkg"]}}
{"id1": "21125261", "id2": "8024375", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"test": [" run", " check", "Test", " process", " deploy", " solve", " eval", "evaluate", " analyse", " sample", " simulate", "run", " testing", " validate", " evaluate", "Main", " verify", "tests", "train", " train", "execute", " example", " tests", "Train"], "is": ["ais", "Is", "iss", "si", "does", "s", "ins", "stream", "info", "has", "ics", "os", "gets", "isa", "IS", "ls", "its", "i", "mis", "ws", "bis", "ists", "ir", "ps", "ris", "as", "in", "iso", "id", "iris", "src", "es", "res", "ai", "out", "ios", "lis", "opens", "serv", "fs", "ses", "isi"], "byteArrayOutputStream": ["byteArrayInputStream", "byteArrayFileFile", "byteArrayOutputPath", "byteArrayOutputString", "byteArrayOutputFile", "byteStringOutputContext", "byteArrayFilePath", "byteArrayByteFile", "byteArrayInputFile", "byteArrayFileSteam", "byteStringOutputPath", "byteArrayInputPath", "byteStringInputString", "byteArrayIOSteam", "byteStringOutputStream", "byteArrayoutputContext", "byteStringInputContext", "byteArrayByteStream", "byteArrayByteSteam", "byteArrayoutputPath", "byteArrayByteString", "byteArrayFileStream", "byteArrayFileString", "byteArrayIOFile", "byteArrayoutputStream", "byteArrayFileContext", "byteStringInputStream", "byteArrayInputSteam", "byteStringOutputString", "byteArrayInputContext", "byteStringInputSteam", "byteStringOutputFile", "byteArrayIOString", "byteArrayOutputSteam", "byteArrayInputString", "byteStringInputPath", "byteArrayoutputSteam", "byteStringOutputSteam", "byteArrayIOStream", "byteStringInputFile", "byteArrayOutputContext"], "def": ["Def", "df", "f", "data", "DEF", "dev", "info", "da", "definition", "class", "base", "di", "conf", "decl", "e", "dist", "md", "this", "bus", "d", "defined", "entry", "parse", "init", "spec", "der", "define", "DE", "default", "config", "file", "id", "des", "frame", "obj", "dir", "pro", "report", "ref", "re", "dem", "desc", "de"], "se": ["be", "le", "sl", "su", "sche", "si", "ade", "ase", "inse", "ze", "s", "sc", "sk", "ge", "fe", "sem", "me", "ie", "ste", "per", "cle", "sea", "zip", "e", "see", "ke", "service", "ne", "parse", "sp", "lex", "entry", "sh", "ine", "sec", "SE", "spe", "te", "pse", "ser", "pe", "ce", "sel", "es", "ss", "ve", "sle", "ane", "so", "sed", "est", "de", "ses", "site"], "linkId": ["LinkLength", "linkInfo", "Linkid", "feedLength", " linkid", "LinkId", "lineInfo", "lockId", "linkLength", "feedid", "lineById", "lineId", "linkById", "feedId", " linkInfo", "lockInfo", "feedInfo", "lockById", " linkById", "LinkInfo", "linkid", " linkLength"], "segmentId": ["sementInfo", "negmentCount", "segmentInfo", "selementID", "segmentsInfo", "negmentId", " segmentsId", "segmentType", " segmentID", "segmentsID", " segmentsID", " segmentsType", "negementCount", "sementId", "segmentsCount", "negementNumber", "segementInfo", "segmentsType", "segmentNumber", "sementNumber", "sementCount", " segmentCount", "segmentID", "segementCount", "negmentInfo", "negementInfo", "segmentsId", " segmentType", "segmentsNumber", "segmentCount", "segementId", "sementType", "sementID", "selementCount", "negementId", "negmentNumber", "selementId", "selementType", " segmentsCount", "segementNumber"], "linkSegments": ["linkEnggments", "lineSeggments", "linkSegles", "linkIncreles", "lineSegment", " linkEngments", "linkConnectures", " linkSegures", " linkSeggments", "lineSegines", "linkFragments", "lineSegments", " linkEngment", " linkSegment", "linkSeggments", "linkFragment", "lineFragines", "linkIncrement", "linkIncreines", "lineFragments", " linkEnggments", "linkEngment", "linkSegines", "linkSegures", "linkEngines", "linkConnectgments", "linkEngures", "linkFragles", "lineFragles", " linkEngures", "linkIncrements", "lineSegles", "linkFragines", "linkEngments", "lineFragment", "lineFraggments", "linkFragures", "linkEngles", "linkIncregments", "linkConnectment", "linkSegment", "linkFraggments", "linkConnectments"], "segments": ["pegs", "Seggements", "sements", "schements", "gegs", "segements", "gements", "begment", "geplings", "pegements", "gegments", "Segments", "Seggment", "scheplings", "pegments", "gegment", "schegments", "segment", "schegment", "seplings", "begments", "begs", "peplings", "pegment", "gegements", "Seggments", "bements", "segs", "pements"], "frameProperties": ["framePromproperties", "frameproproperties", " frameproperties", " frameProblems", "frameProproperties", " frameproproperties", "frameproeters", "framePrometers", "frameproblems", "framePropeters", "frameProblems", "framePropperties", "frameproperties", " frameproblems", "framePromperties", " frameProproperties", " frameprops", " frameproeters", "frameProps", " frameProps", "framePropblems", "framePromps", "frameProeters", " frameProeters", "framePropproperties", "framePropps", "frameprops"], "time": ["x", "etime", "once", "f", "data", "name", "times", "depth", "vel", "type", "play", "cost", "change", "tim", "timeout", "event", "Time", "activity", "loop", "video", "size", "weight", "clock", "TIME", "work", "e", "ice", "step", "count", "live", "money", "ime", "t", "port", "image", "value", "h", "speed", "age", "v", "date", "rate", "c", "duration", "file", "delay", "id", "timer", "sleep", "length", "start", "end", "now"], "vehicle": ["vertology", "bridicle", "vehometry", " mobish", "bridometry", " vehish", " vehicles", "venocity", "venical", "vehline", "vehocity", "verticles", "bridical", " vehline", " mobicle", " vehology", "bridocity", "venicle", "Vehline", " mobline", "vehish", "driometry", "vehical", "vehology", "Vehicle", " mobicles", "driocity", "verticular", "Vehology", "venometry", "Vehish", "vehicular", "Vehicular", "vehicles", "driicle", " vehicular", "Vehicles", "verticle", "driical"]}}
{"id1": "6403868", "id2": "10795866", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"extractUninstallFiles": ["extractUppackFiles", "extractUninstallSources", "extractUnzipfiles", "extractUpinstallSources", "extractUninstallfiles", "extractUpinstallFile", "extractUnpackfiles", "extractUnpackFiles", "extractUnInstallFile", "extractUnInstallfiles", "extractUppackfiles", "extractUnInstallFiles", "extractUpinstallfiles", "extractUppackFile", "extractUpinstallFiles", "extractUppackSources", "extractUninstallFile", "extractUnpackFile", "extractUnzipSources", "extractUnzipFile", "extractUnInstallSources", "extractUnzipFiles", "extractUnpackSources"], "_destPath": [" _sourceHome", "_sourcePath", "_destFile", "_distDir", "_Destpath", "_sourceFile", " _destFile", "_sourceHome", "_sourceDir", "_sourceDirectory", "_tmpDirectory", "_srcDirectory", "_srcDir", " _destDirectory", "_distPath", "_srcPath", "_distFile", "_tmppath", " _sourceDirectory", "_destHome", "_sourcepath", "_downloadHome", "_srcFile", "_destpath", "_downloadDirectory", "_destDir", "_downloadPath", "_DestFile", "_DestHome", "_tmpPath", "_destDirectory", "_downloadFile", "_tmpDir", " _sourcePath", " _destHome", "_DestDirectory", "_distDirectory", "_DestDir", "_DestPath", " _sourceFile"], "upgrade": ["Upgrade", "dugrading", "upgrading", "Upgrading", " upinstall", "duGrade", " upge", "ipinstall", "upgrades", "ipgrading", "UpGrade", "offinstall", "offgrading", "offgrade", " upGrade", "offgrades", "upGrade", " upgrading", "Upge", " upgrades", "upge", "ipgrades", "dugrade", "ipgrade", "duge", "upinstall"], "lastVer": ["nextver", "Lastver", "firstVersion", "firstver", " lastVers", "lastver", "LastVersion", "firstVER", "firstVer", "LastVer", "prevVersion", "LastVER", "prevver", "nextVers", "lastVers", " lastVER", "prevVers", "lastVersion", "prevVer", " lastver", " lastVersion", "nextVersion", "nextVer", "lastVER"], "oldlog": ["OldLog", "newlog", "oldbug", "oldpath", " oldbug", "oldLOG", "newLog", "newbug", "OLDLog", " oldpath", "newtext", "olderLog", "OLDbug", "newpath", " oldtext", "oldtext", "olderLOG", "oldertext", "olderlog", "OldLOG", " oldLog", "Oldpath", "OLDlog", "oldLog", " oldLOG", "newLOG", "Oldlog"], "destPath": ["usrFile", "homePath", "homeKit", " destRoot", "targetRoot", "destDir", "descDir", "secureLog", "Destpath", " destDir", "constPath", " destath", "DestDir", " destpath", "usrPath", "DestRoot", "doneLog", "destFolder", "DestHome", "destPATH", "descName", " destWin", "doneDir", "contDir", "exportDirectory", " destCh", "DestFile", "targetFile", "sourceDir", "constpath", "sourceDirectory", "targetDir", " destLog", "destpath", "postRoot", "donepath", "flatFolder", "doneWin", "destath", "descFile", " destFolder", "DestPATH", "secureWin", "contPath", "DestCh", "exportPath", "postPATH", "destKit", "postPath", "contath", "descKit", "destDirectory", " destFile", "sourcepath", "destHome", "srcDirectory", " destHome", "destName", "srcpath", "constFile", "targetpath", "secureDir", " destPATH", " destName", "destWin", "flatPath", "exportPATH", "constHome", "targetPath", "sourcePath", "flatDir", "homeName", "destFile", "contpath", "destRoot", "DestPath", "homepath", "DestFolder", "homeDir", "flatpath", "homeLog", "descPath", "postpath", "destLog", "Destath", "exportpath", "targetPATH", "usrpath", " destDirectory", "destCh", "securePath", "srcPath", "DestDirectory", " destKit", "descpath", "srcPATH", "donePath", "descCh"], "lastVerPath": ["prevverName", " lastVersionCh", "lastverName", " lastVersionFile", "lastVerpath", " lastModpath", " lastVerCh", "lastVersionEx", "lastModName", "lastModFile", "lastTestFile", "lastTestPath", "lastverFile", "lastVerDir", "lastModDir", "nextVerCh", " lastVerId", "lastverDir", "lastVersCh", "lastModpath", "lastverCh", "lastVerEx", "lastVERCh", "lastVEREx", "nextverPath", " lastVersionEx", "lastVersionpath", "lastverId", "prevVerName", "lastVERPath", "prevVerFile", "lastVerspath", "prevverpath", " lastVersionId", "nextVerpath", " lastVerDir", "lastVerId", "lastVersionId", " lastModDir", "lastVersFile", "prevVerpath", "nextVerFile", "lastVerName", " lastVerpath", "nextVerPath", "nextverCh", "lastverPath", "prevverPath", "lastModCh", "lastVERpath", "lastverEx", "lastverpath", "lastVerCh", " lastVersionpath", " lastVersionPath", "nextverpath", " lastModPath", "lastVersionCh", "lastVerFile", " lastModCh", " lastVerEx", " lastVerFile", "prevVerPath", "lastTestpath", "lastVersPath", "lastVersionFile", "lastModPath", "lastVERDir", "lastTestId", "lastVersionName", "lastVersionPath", "nextverFile", "prevverFile"], "bkdir": [" bkDir", "bckDir", "bkgir", "bkir", "bkkir", "bkbloc", "bckdir", "bkloc", "bkgdir", "bktdesc", "bktfile", "bKpath", "bkkpath", "bktdir", " bktfile", " bakdir", "bKDir", "bakpath", "bakloc", "bkkdesc", "bvpath", " bkir", " bkpath", " bkloc", "bKdir", "bkdirectory", " bakir", " bkdesc", "bvdir", "bakir", " bakpath", "bvloc", "Bkdir", " bakDir", "bakDir", "bakdirectory", "bkkDir", "bkfile", "bkbfile", "BkDir", "bkgDir", "bkDir", "Bkpath", " bktdir", " bktdesc", "BckDir", "Bckdir", "bvDir", " bktloc", "bkpath", "bckpath", "bkdesc", "bkkdir", " bakloc", "bakdir", "Bkdirectory", "bkbdesc", "bktloc", "Bckdirectory", " bkfile", "bkkfile", "bckdirectory", "bkkloc", "bkbdir", "bKdirectory", "Bckpath"], "oldClassCopied": ["oldClassCrossified", "oldFileCopied", "oldClassCopyies", "oldClassCopyified", "oldFileCopie", "oldClasscopored", "oldClassCopie", "oldFileCopyying", "oldFilecopies", "oldClassCopies", "oldFilecopied", "oldClassCopored", "oldClassSkie", "oldFileCopyiated", "oldFilecopying", "oldClassSkored", "oldClassCopyied", "oldClassSkied", "oldClasscopied", "oldClassCopified", "oldFileCopyied", "oldClassCopyie", "oldClasscopie", "oldClassCopying", "oldclassCopies", "oldFileCopyified", "oldClassCopyying", "oldClassCrossying", "oldClasscopies", "oldClassCopiated", "oldFileCopying", "oldFileCopiated", "oldclassCopie", "oldClassCopyiated", "oldclassCopied", "oldFilecopie", "oldClassSkies", "oldClasscopying", "oldFileCopified", "oldFileCopies", "oldClassCrossied", "oldclassCopored", "oldClassCrossiated"], "ls": ["lt", "tl", "LS", "lp", "sels", "fl", "mails", "dl", "bs", "als", "ns", "ll", "cs", "lc", "acl", "les", "less", "files", "wl", "l", "lf", "la", "lines", "igs", "iffs", "list", "ails", "lb", "qs", "fts", "vs", "lists", "lr", "bps", "ils", "lv", "locks", "los", "lis", "ches", "ln", "rl", "lbs", "ols", "fs", "irs"], "i": ["x", "ji", "ij", "f", "y", "si", "it", "start", "ti", "ri", "q", "s", "type", "slice", "m", "p", "j", "info", "pi", "min", "ind", "ix", "hi", "lc", "I", "di", "u", "b", "multi", "inner", "part", "qi", "l", "fi", "e", "o", "uli", "ini", "abi", "d", "ci", "z", "t", "xi", "v", "oi", "mi", "ui", "yi", "li", "uri", "ii", "io", "c", "id", "index", "iu", "mu", "eni", "ai", "gi", "phi", "ip", "end"]}}
{"id1": "13086936", "id2": "23452437", "code1": "            public void run() {\n                waiting(200);\n                txtinfo.post(new Runnable() {\n\n                    public void run() {\n                        txtinfo.setText(\"Searching\");\n                    }\n                });\n                try {\n                    URL url = new URL(urlAddress);\n                    SAXParserFactory spf = SAXParserFactory.newInstance();\n                    SAXParser sp = spf.newSAXParser();\n                    XMLReader xr = sp.getXMLReader();\n                    XMLHandlerReviews myXMLHandler = new XMLHandlerReviews();\n                    xr.setContentHandler(myXMLHandler);\n                    xr.parse(new InputSource(url.openStream()));\n                    if (statuscode != 200 && statuscode != 206) {\n                        throw new Exception();\n                    }\n                    nReviewsOnPage = myXMLHandler.nItems;\n                    statuscode = myXMLHandler.statuscode;\n                    if (nReviewsOnPage > 0) {\n                        authors = new String[nReviewsOnPage];\n                        reviews = new String[nReviewsOnPage];\n                        ratings = new String[nReviewsOnPage];\n                        titles = new String[nReviewsOnPage];\n                        listtext = new String[nReviewsOnPage];\n                        for (int i = 0; i < nReviewsOnPage; i++) {\n                            reviews[i] = myXMLHandler.reviews[i];\n                            authors[i] = myXMLHandler.authors[i];\n                            titles[i] = myXMLHandler.titles[i];\n                            ratings[i] = myXMLHandler.ratings[i];\n                            if (authors[i] == null || authors[i] == \"\") {\n                                authors[i] = \"Anonymous\";\n                            }\n                            if (ratings[i] == null || ratings[i] == \"\") {\n                                listtext[i] = titles[i] + \" - \" + reviews[i] + \" - \" + authors[i];\n                            } else {\n                                listtext[i] = \"Score: \" + ratings[i] + \" - \" + titles[i] + \" - \" + reviews[i] + \" - \" + authors[i];\n                            }\n                        }\n                        nTotalReviews = myXMLHandler.nTotalItems;\n                        final int fnmin = iFirstReviewOnPage;\n                        final int fnmax = iFirstReviewOnPage + nReviewsOnPage - 1;\n                        final int fntotalitems = nTotalReviews;\n                        if (nTotalReviews > fnmax) {\n                            nextButton.post(new Runnable() {\n\n                                public void run() {\n                                    nextButton.setVisibility(0);\n                                }\n                            });\n                        } else {\n                            nextButton.post(new Runnable() {\n\n                                public void run() {\n                                    nextButton.setVisibility(8);\n                                }\n                            });\n                        }\n                        if (iFirstReviewOnPage > 1) {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(0);\n                                }\n                            });\n                        } else if (nTotalReviews > fnmax) {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(8);\n                                }\n                            });\n                        } else {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(4);\n                                }\n                            });\n                        }\n                        txtinfo.post(new Runnable() {\n\n                            public void run() {\n                                if (title != null && title != \"\") {\n                                    txtinfo.setText(title + \"\\n\" + getString(R.string.showing) + \" \" + fnmin + \" \" + getString(R.string.through) + \" \" + fnmax + \" \" + getString(R.string.of) + \" \" + fntotalitems);\n                                } else {\n                                    txtinfo.setText(getString(R.string.showing) + \" \" + fnmin + \" \" + getString(R.string.through) + \" \" + fnmax + \" \" + getString(R.string.of) + \" \" + fntotalitems);\n                                }\n                            }\n                        });\n                        handlerSetList.sendEmptyMessage(0);\n                    } else {\n                        txtinfo.post(new Runnable() {\n\n                            public void run() {\n                                txtinfo.setText(title + getString(R.string.no_reviews_for_this_album));\n                            }\n                        });\n                    }\n                } catch (Exception e) {\n                    final Exception ef = e;\n                    txtinfo.post(new Runnable() {\n\n                        public void run() {\n                            txtinfo.setText(R.string.search_failed);\n                        }\n                    });\n                }\n                dialog.dismiss();\n                handlerDoneLoading.sendEmptyMessage(0);\n            }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 0, "substitutes": {"run": ["job", "su", "login", "background", "name", "apply", "un", "container", "thread", "worker", "base", "fun", "loop", "output", "work", "runs", "call", "build", "use", "submit", "process", "exec", "pass", "unit", "man", "in", "func", "running", "execute", "Run", "start", "graph", "runner"], "url": ["connection", "open", "sl", "f", "org", "channel", "stream", "base", "ssl", "ll", "html", "page", "b", "user", "r", "l", "left", "address", "this", "Url", "service", "URL", "source", "buffer", "image", "api", "path", "server", "uri", "io", "http", "file", "sr", "src", "resource", "www", "location", "string"], "spf": ["skfs", " spfx", " spfen", "ppfx", "Spf", "skfen", "Spfs", "Spfd", "pf", "scF", "spfd", "pfd", "scf", "scfs", "SpF", "skfx", "ppfs", "scfd", "pfs", " spfs", "pF", "spF", "spfs", "ppfen", "spfen", "skf", "ppf", "spfx"], "sp": ["esp", "sl", "er", "f", "Sp", "si", "lp", "sc", "g", "py", "st", "space", "p", "se", "wp", "par", "xml", "SP", "ssl", "pr", "sv", "parser", "asp", "pp", "sm", "service", "parse", "source", "sw", "server", "sa", "http", "scope", "sr", "sb", "sf", "so", "pg", "html", "serv", "sh", "steam"], "xr": ["txrs", "rxR", "xrr", "xR", "xer", "Xr", "txrb", " xrr", " xrs", "txr", "Xrs", "swrb", "swhr", "byrr", "xhr", "byrb", " xrb", " xR", "rxrr", "txR", "byR", "Xer", "rxr", "swrs", " xer", "txhr", "XR", "byr", "xrb", "rxrb", "swr", "txer", " xhr", "xrs"], "myXMLHandler": ["myXSLEvent", "myTXMLEvent", "myXSLContext", "myTXELReader", "myXMLInfo", "myYSLService", "myXMLParser", "myXELManager", "myXRLPath", "myXRLInfo", "myXLSHandler", "myXRLHandler", "myXMLConfig", "myXLSParser", "myFXmlHandler", "myYMLReader", "myXMLReader", "myXPCService", "myXLSEvent", "myXCLHandler", "myYMLService", "myXSLParser", "myTXmlEvent", "myYSLParser", "myXELPath", "myXELParser", "myXLMLHandler", "myXRLEvent", "myFXmlParser", "myXCLParser", "myXRLContext", "myXMLPath", "myWorkMLHandler", "myXSLReader", "myXRLReader", "myXCLManager", "myXPCHandler", "myXmlPath", "myXSLService", "myXLMLReader", "myXCLReader", "myWorkMLPath", "myWorkMLParser", "myXMLManager", "myWorkmlReader", "myFXMLManager", "myXELReader", "myXmlReader", "myXLMLPath", "myXLSLReader", "myXmlConfig", "myTXmlInfo", "myXCLConfig", "myTXMLReader", "myTXELEvent", "myXCLPath", "myYSLHandler", "myFXmlPath", "myXSLManager", "myWorkMLReader", "myXCLService", "myTXMLParser", "myWorkmlPath", "myYMLConfig", "myXmlEvent", "myXSLInfo", "myYMLParser", "myFXMLReader", "myXMLEvent", "myYSLReader", "myXmlParser", "myXPCContext", "myTXMLHandler", "myFXMLPath", "myXMLService", "myXLSReader", "myXCLContext", "myXLSLPath", "myYSLConfig", "myFXmlReader", "myXSLPath", "myXSLHandler", "myTXmlReader", "myTXELParser", "myTXELHandler", "myXmlInfo", "myXLSLHandler", "myXSLConfig", "myXMLContext", "myTXMLInfo", "myYSLContext", "myXPCReader", "myXELHandler", "myXmlManager", "myWorkmlHandler", "myFXmlManager", "myXmlContext", "myFXMLParser", "myXELEvent", "myYMLHandler", "myWorkmlParser", "myXLMLParser", "myTXmlHandler", "myXLSLParser", "myYMLContext", "myXmlHandler", "myXRLParser", "myFXMLHandler"], "nReviewsOnPage": ["nReviewsOnlineLine", "nReviewesPerPage", "nReviewsOnlineRequest", "nReviewesPerPages", "nReviewsThisPage", "nReviewsInSection", "nReviewmentsPerDisk", "nReviewsOnpage", "nReviewsonPage", "nReviewsPerLine", "nReviewingsOnFile", "nReviewesOnpage", "nReviewmentsPerLine", "nReviewesCurrentPage", "nReviewsPerRequest", "nReviewesOnPage", "nReviewsOffLine", "nReviewsForFile", "nReviewmentsOnpage", "nReviewsPerSection", "nReviewesPerLine", "nReviewsOnLine", "nReviewsONRequest", "nReviewsDuringPage", "nReviewsCurrentLine", "nReviewsPerFile", "nReviewingsPerSection", "nReviewsOnlinepage", "nReviewingsONpage", "nReviewesOnLine", "nReviewmentsOnLine", "nReviewingsPerPage", "nReviewsInPage", "nReviewesCurrentFile", "nReviewsOnFile", "nReviewsThisSection", "nReviewmentsPerPage", "nReviewingsPerLine", "nReviewsInpage", "nReviewsThisFile", "nReviewsForpage", "nReviewsOnDisk", "nReviewsOnSection", "nReviewmentsOnDisk", "nReviewsInLine", "nReviewsONLine", "nReviewsonFile", "nReviewingsONRequest", "nReviewsOffPages", "nReviewsDuringLine", "nReviewesPerpage", "nReviewingsPerpage", "nReviewsCurrentFile", "nReviewingsONPage", "nReviewsPerPage", "nReviewesOnFile", "nReviewsForLine", "nReviewingsONLine", "nReviewsInFile", "nReviewsONpage", "nReviewsForPage", "nReviewsOnPages", "nReviewsonpage", "nReviewsPerPages", "nReviewsONPages", "nReviewesCurrentLine", "nReviewingsOnPage", "nReviewingsOnLine", "nReviewmentsOnPage", "nReviewmentsPerpage", "nReviewsCurrentpage", "nReviewsPerpage", "nReviewesOnPages", "nReviewsonLine", "nReviewsCurrentPage", "nReviewsDuringDisk", "nReviewsonPages", "nReviewsOnRequest", "nReviewingsOnSection", "nReviewingsPerFile", "nReviewsOffPage", "nReviewsThisLine", "nReviewsOffpage", "nReviewsPerDisk", "nReviewingsOnpage", "nReviewsONPage", "nReviewsDuringpage", "nReviewesCurrentpage", "nReviewsOnlinePage", "nReviewingsOnRequest", "nReviewsInDisk"], "statuscode": ["resultcodes", "statstate", "statuscount", "msgcount", "msgstate", "resultcode", "statcode", " statusstatus", "statcodes", "Statuscodes", "resultstate", "levelcase", "statusstatus", "zipcode", "msgcodes", "statusCode", " statusmessage", "postcode", "zipstatus", "statuscodes", "zipcodes", "postCode", "resultmessage", " statusCode", "msgcode", "levelcode", "statusmessage", "zipCode", "resultcount", "postcodes", "levelstate", "Statuscount", "levelcodes", " statusstate", " statuscodes", "statcase", "Statusstate", " statuscase", "msgmessage", "Statuscode", "statuscase", "poststatus", "statusstate"], "authors": ["verbs", "pages", "artifacts", "apters", "thumbnails", "images", "blocks", "sections", "yrs", "articles", "runners", "versions", "ors", "archs", "services", "ins", "testers", "settings", "relations", "abet", "quarters", "abilities", "parents", "reads", "people", "words", "members", "features", "builders", "apps", "workers", "blogs", "posts", "weights", "journal", "writers", "attacks", "letters", "strings", "archives", "marks", "owners", "apers", "books", "itles", "atts", "comments", "names", "errors", "styles", "tags", "ppers", "author", "includes", "humans", "ants", "papers", "casters", "users", "projects", "rators", "headers", "criptions", "rules", "reports", "plugins", "docs", "anners", "resources", "masters", "agents", "rights"], "reviews": [" reviewings", "followes", "reviewins", "followings", "reviewations", "following", "follows", "reviewments", "reviewions", "reviewing", "signations", "sells", "signins", "authorp", "Reviewing", "reviewes", "authoring", "feeds", "authorins", "Reviews", "reviewings", "Reviewers", "authorers", "authorings", "feedations", "signs", "Reviewp", "downloading", "feedings", " reviewments", "Reviewes", "Reviewments", "reviewp", "downloadments", "downloadings", "sellions", "authorments", "authorions", "sellers", "reviewers", "Reviewings", "signings", "Reviewions", "feedins", "authores", "sellings", "authorations", " reviewp", "downloads"], "ratings": ["statations", "tensions", " ratitles", "ritins", "ratages", "authories", "rities", "trages", " ratickets", " ratios", "tacters", "trings", "ties", "ritions", "trios", "statios", "ratations", "authorifications", "ratitles", "statages", " ratifications", "rations", "authorins", "trickets", "pritles", "practers", "roundensions", "variings", "variitles", "pitings", "variations", "pitations", "authorings", "latensions", "tations", "rounditles", "latations", "tings", "statickets", " ratning", "ratins", "variions", "statitles", "authorages", "authorning", "roundations", "ratios", "roundings", "statensions", " ratacters", "statifications", "statning", "ritings", "tins", "pitions", " ratages", "prensions", "ratacters", "latings", "authorions", "raties", "ratickets", "ratensions", "statings", "ratning", "latitles", "ratifications", "prings", " ratensions", "pititles", "tions"], "titles": ["tapes", " tributes", "Tames", "untls", "untitles", "sitles", "sapes", "ttributes", "tacters", " tacters", "ratapers", "ratames", "tticks", "tasks", "tls", " tapers", "lractions", " tales", "ratitles", " tls", "tractions", "ttings", "ttales", "untings", "lasks", " tasks", "thips", " tings", "Ticks", "tings", "ttickets", "ticks", "Tales", "ttitles", "tributes", "tickets", "untickets", "tapers", "ttractions", "sasks", " thips", "ttls", "Titles", " tames", "ships", "lhips", " tapes", "ratacters", "Tapers", "litles", "tales", "lapes", "Tacters", " ticks", " tractions", "Tings", "lickets", " tickets", "tames", "lributes"], "listtext": ["summaryname", "flattxt", "summaryTEXT", " listtxt", "detailobject", "flattext", " listformat", "LISTformat", " listobject", "summarytxt", "testobject", " listname", "flatTEXT", "summaryformat", "listTEXT", "listText", "summarytext", "LISTTEXT", " listbody", "testtext", "listformat", "liststr", "detailbody", "listtxt", " listText", "listobject", " listTEXT", "LISTtext", "listname", "listbody", " liststr", "testbody", "detailstr", "summaryText", "flatText", "LISTname", "detailtext", "teststr"], "i": ["x", "ji", "f", "y", "sup", "si", "current", "it", "ti", "ri", "s", "g", "iv", "m", "j", "ori", "p", "pi", "info", "ie", "ix", "hi", "lc", "ei", "I", "bi", "u", "di", "b", "multi", "is", "qi", "l", "fi", "e", "o", "uli", "ini", "abi", "cli", "ci", "init", "z", "api", "ki", "xi", "yi", "v", "ui", "mi", "oi", "li", "uri", "ii", "io", "ni", "id", "iu", "index", "chi", "vi", "ic", "eni", "gi", "ai", "phi", "uni", "ip", "isi"], "nTotalReviews": ["nTotalDownloaded", "nTotalDownloads", "nTotalGraphEvents", "nTotalGraphed", "nAllReviewEvents", "nTotalreviewes", "nTotalDownloadEvents", "nTotalreviews", "nAllreviewes", "nTotalreviewed", "nAllReviewes", "nAllReviewed", "nTotalReviewes", "nAllreviewEvents", "nAllReviews", "nTotalGraphes", "nTotalDownloades", "nTotalReviewed", "nTotalReviewEvents", "nAllreviewed", "nAllreviews", "nTotalGraphs", "nTotalreviewEvents"], "fnmin": [" fmin", " nmin", " fstart", " ndiff", "fnstart", "fnall", " nall", "fndiff", " fnall", " nstart", " fdiff", " fndiff", " fnstart", " fall"]}}
{"id1": "810342", "id2": "3945236", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doversioncheck", "doChangeCheck", "doVersionUpdate", " doVersionUpdate", " doversionScan", " doVersionScan", "doChangecheck", " doVersioncheck", "doFeaturecheck", "doFeatureUpdate", "doversionUpdate", "doChangeUpdate", " doversioncheck", "doFeatureScan", "doFeatureCheck", "doVersionScan", "doChangeScan", " doversionCheck", "doversionScan", "doVersioncheck", "doversionCheck", " doversionUpdate"], "view": ["lock", "self", "container", "edit", "pool", "div", "screen", "see", "review", "update", "out", "html", "gu", "session", "el", "page", "cache", "query", "display", "client", "row", "port", "value", "ui", "group", "up", "fail", "use", "widget", "View", "im", "vis", "model", "vol", "check", "by", "e", "cell", "this", "show", "style", "image", "form", "config", "http", "VIEW", "full", "layout", "manager", "head", "body", "change", "event", "base", "box", "video", "user", "can", "comment", "list", "block", "object", "v", "server", "index", "views", "sel", "input", "window", "ou", "ve", "link"], "url": ["ul", "open", "sl", "f", "loc", "name", "socket", "email", "gl", "stream", "web", "download", "log", "base", "ssl", "bb", "ls", "ll", "blog", "b", "loader", "zip", "l", "bug", "fr", "address", "Url", "buffer", "URL", "source", "image", "builder", "hub", "path", "server", "uri", "null", "browser", "http", "file", "impl", "id", "resource", "www", "host", "link", "location", "length", "rel", "string", "ob"], "in": ["reader", "isin", "sin", "login", "data", "doc", "socket", "s", "ins", "pin", "m", "stream", "cin", "In", "binary", "is", "b", "inner", "again", "rin", "win", "din", "IN", "err", "ini", "buffer", "source", "init", "inc", "nin", "bis", "inn", "file", "as", "lin", "resource", "input", "out", "con", "ac"], "bin": ["reader", "border", "lock", "sin", "login", "socket", "pin", "body", "cin", "bn", "vin", "binary", "bot", "is", "bb", "bi", "b", "loader", "inner", "win", "din", "IN", "ruby", "ini", "abi", "buffer", "lib", "run", "init", "spin", "arin", "ban", "browser", "inn", "oin", "file", "lin", "fin", "input", "out", "record", "con", "gin", "nb"], "line": ["job", "le", "sl", "data", "name", "type", "pin", "range", "el", "ge", "one", "str", "definition", "letter", "log", "base", "lc", "inline", "page", "b", "text", "part", "user", "zip", "l", "val", "e", "cell", "lines", "lf", "key", "ine", "comment", "row", "entry", "block", "parse", "Line", "object", "cl", "code", "nl", "unit", "pe", "jo", "file", "up", "id", "LINE", "word", "lin", "out", "link", "string", "write", "ip", "end", "look"], "version": ["feature", "ver", "name", "support", "type", "dev", "python", "versions", "install", "VERSION", "latest", "download", "release", "plugin", "position", "model", "format", "video", "user", "vert", "section", "bug", "patch", "vision", "pull", "secret", "image", "value", "project", "driver", "v", "update", "server", "unit", "date", "author", "null", "code", "Version", "id", "beta", "cover", "host", "string", "option", "device", "license"], "build": ["lock", "job", "ver", "tag", "get", "mount", "Build", "hold", "how", "building", "boot", "install", "info", "clean", "load", "lease", "release", "log", "add", "built", "bug", "work", "uild", "patch", "pull", "row", "show", "style", "image", "block", "run", "feed", "builder", "update", "unit", "make", "post", "http", "valid", "follow", "help", "home", "print", "link", "rel", "use"]}}
{"id1": "12349563", "id2": "22611968", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"resourceExists": [" fileexistence", " resourceexits", " resourceexists", " resourceAbses", " resourceExistence", " resourceAbsists", " fileexits", " resourceCompits", " fileExistence", " resourceCompes", " fileExists", " resourceCompistence", " resourceExits", " fileExits", " resourceCompists", " fileExes", " fileexists", " fileexes", " resourceExes", " resourceAbsits", " resourceAbsistence", " resourceexistence", " resourceexes"], "location": ["connection", "localhost", "region", "loc", "data", "name", "point", "layout", "type", "remote", "language", "reference", "operation", "layer", "info", "local", "base", "position", "description", "content", "href", "LOC", "shape", "collection", "address", "pointer", "source", "image", "provided", "path", "response", "filename", "object", "uri", "server", "route", "file", "folder", "message", "Location", "resource", "target", "host", "home", "length", "directory", "area", "string", "node"], "url": ["connection", "open", "sl", "f", "loc", "fl", "web", "base", "ll", "ssl", "blog", "page", "b", "user", "zip", "l", "r", "address", "Url", "i", "URL", "lib", "build", "source", "image", "api", "path", "config", "server", "uri", "io", "http", "c", "file", "impl", "resource", "www", "host", "string", "obj"], "cxn": ["cxxp", "Cuxn", "cxxn", "cuxns", "cdsn", "Cuxns", "crexp", "Cxp", "Cxns", "cexns", " crexn", " crexg", " crexp", "cxns", "Cxn", "crexg", "cuxp", "cexg", "cexcon", "cexp", "cdscon", "cdsp", "crexn", " cxcon", "Cuxp", "cxxne", "cxg", "cuxn", " cxg", "cxxns", " crexcon", "Cxne", " cxp", "cuxne", "cxcon", "cxne", "cexne", "cxp", "crexcon", "cexn", "cdsg", "Cuxne"], "is": ["x", "app", "ens", "ais", "Is", "iss", "get", "isl", "it", "cos", "does", "s", "oss", "bs", "stream", "ori", "info", "has", "web", "cms", "os", "im", "isa", "IS", "isc", "abs", "was", "internet", "ar", "its", "i", "init", "api", "or", "js", "nis", "next", "close", "ui", "bis", "ois", "ir", "uri", "ris", "http", "in", "as", "iso", "id", "iris", "src", "es", "ai", "out", "us", "ios", "ms", "lis", "ip", "fs", "ob", "isi"], "byteBuffer": ["byteBuff", "ByteArray", "ByteBuffer", "ByteBB", " byteBuff", "bitBB", "bitBuffer", "ByteBuff", "bitBuff", "byteArray", " byteLength", "ByteLength", "byteLength", "bitArray", " byteArray", "bitLength", " byteBB", "byteBB"]}}
{"id1": "15516136", "id2": "19910627", "code1": "    public static synchronized BufferedImage loadBufferedJPEGImage(URL url) {\n        BufferedImage image = null;\n        if (url != null) {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(in);\n                image = decoder.decodeAsBufferedImage();\n            } catch (Exception e) {\n                log.severe(\"URL: \" + url + \" - \" + e.getMessage());\n                image = null;\n            } finally {\n                try {\n                    if (in != null) in.close();\n                } catch (IOException ioe) {\n                    log.severe(\"URL: \" + url + \" - \" + ioe.getMessage());\n                }\n            }\n            if (image != null) {\n                log.config(\"Image type : \" + image.getType());\n                if (image.getWidth() <= 0 || image.getHeight() <= 0) {\n                    log.severe(\"URL: \" + url + \" =0\");\n                    image = null;\n                }\n            }\n        }\n        return image;\n    }\n", "code2": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "label": 0, "substitutes": {"loadBufferedJPEGImage": ["loadBufferedJPELImage", "loadBufferedJPEGimage", "loadBufferedMPEGFile", "loadBufferedJPPGimage", "loadBufferedJPEGMedia", "loadBufferedJPELFile", "loadBufferedJPNGFile", "loadBufferedJPEGFile", "loadBufferedMPPGFile", "loadBufferedJPELimage", "loadBufferedMPPGImage", "loadBufferedMPEGImage", "loadBufferedMPEGMedia", "loadBufferedJPELMedia", "loadBufferedJPPGImage", "loadBufferedJPNGMedia", "loadBufferedJPNGimage", "loadBufferedJPPGFile", "loadBufferedJPPGMedia", "loadBufferedMPEGimage", "loadBufferedJPNGImage", "loadBufferedMPPGMedia", "loadBufferedMPPGimage"], "url": ["connection", "job", "sl", "alt", "f", "data", "loc", "name", "mount", "email", "dl", "ur", "gl", "el", "remote", "stream", "play", "layer", "download", "xml", "base", "ll", "ssl", "log", "rule", "page", "blog", "bb", "loader", "href", "l", "address", "pull", "Url", "service", "URL", "source", "buffer", "feed", "style", "found", "large", "path", "filename", "object", "config", "server", "uri", "http", "file", "id", "src", "resource", "www", "coll", "host", "link", "ref", "location", "string", "media"], "image": ["feature", "data", "issue", "container", "archive", "gallery", "picture", "ami", "work", "source", "age", "default", "message", "resource", "out", "element", "error", "photo", "pin", "m", "auto", "Image", "position", "page", "cache", "icon", "inner", "output", "pixel", "zip", "bug", "build", "value", "game", "parent", "ui", "document", "thin", "up", "pm", "result", "jpg", "job", "f", "database", "p", "info", "xml", "im", "model", "copy", "ini", "show", "api", "large", "config", "figure", "eye", "upload", "available", "site", "connection", "manager", "gif", "slice", "audio", "layer", "hole", "video", "instance", "size", "img", "i", "object", "view", "file", "shadow", "cm", "cover", "media"], "in": ["reader", "bin", "isin", "login", "f", "data", "doc", "socket", "container", "inas", "ins", "el", "m", "stream", "pin", "cin", "ex", "min", "In", "xml", "is", "kin", "inside", "ssl", "part", "b", "conn", "inner", "rin", "again", "win", "l", "r", "din", "IN", "err", "ax", "ini", "i", "source", "init", "inc", "nin", "or", "cf", "n", "pass", "inn", "c", "file", "id", "impl", "a", "fd", "input", "out", "con", "ac", "gin", "serv", "fb"], "decoder": ["decoding", "encoded", "encode", " decoding", "decode", "recoding", " decode", "encoder", "Decoding", "Decoded", "encoding", "deoder", "Decenter", "deenter", "Decode", "recenter", "decenter", " decoded", "recoder", "decoded", "deoding", "recode", "deode", "Decoder"]}}
{"id1": "13720140", "id2": "3683344", "code1": "    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {\n        Property property = new Property(new Long(valueID), userID);\n        String newValue = value;\n        System.out.println(property.getName());\n        if (property.getName().equals(\"Password\")) {\n            try {\n                MessageDigest crypt = MessageDigest.getInstance(\"MD5\");\n                crypt.update(value.getBytes());\n                byte digest[] = crypt.digest();\n                StringBuffer hexString = new StringBuffer();\n                for (int i = 0; i < digest.length; i++) {\n                    hexString.append(hexDigit(digest[i]));\n                }\n                newValue = hexString.toString();\n                crypt.reset();\n            } catch (NoSuchAlgorithmException e) {\n                System.err.println(\"jspShop: Could not get instance of MD5 algorithm. Please fix this!\" + e.getMessage());\n                e.printStackTrace();\n                throw new JspTagException(\"Error crypting password!: \" + e.getMessage());\n            }\n        }\n        property.setValue(newValue);\n    }\n", "code2": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "label": 1, "substitutes": {"modifyProperty": ["modifiedproperty", "modureString", "ModifyProperty", "modifyString", "Modifiedproperty", "modateAttribute", "modifiedString", "modateString", "modateProperty", "ModifiedProperty", "Modifyproperty", "modateproperty", "ModifyString", "modureAttribute", "modifyproperty", "modifyAttribute", "modifiedAttribute", "modifiedProperty", "modureProperty", "modureproperty", "ModifyAttribute", "ModifiedString", "ModifiedAttribute"], "valueID": ["jobIP", "jobid", "propertyID", "VALUEid", "propertyid", "VALUEIndex", "propertyId", "propertyIP", "jobId", "valueid", "Valueid", "ValueIndex", "ValueId", "ValueID", "contentIndex", "valueId", "contentID", "VALUEID", "jobID", "valueIndex", "valueIP", "contentid", "ValueIP"], "value": ["values", "data", "name", "reference", "command", "language", "string", "array", "expression", "format", "description", "text", "output", "content", "val", "password", "key", "address", "secret", "padding", "source", "entry", "image", "example", "response", "phrase", "object", "pattern", "v", "attribute", "update", "default", "number", "document", "server", "code", "function", "message", "result", "resource", "Value", "target", "token", "VALUE", "element", "username"], "userID": [" userid", "userName", " userName", "authorMAC", "UserMAC", "authorID", "UserId", " userMAC", "userid", "Userid", "UserName", "userMAC", " userId", "authorId", "userId", "authorName", "UserID", "authorid"], "property": ["prop", "connection", "feature", "profile", "Property", "data", "name", "type", "method", "operation", "layer", "p", "pair", "info", "variable", "field", "definition", "expression", "base", "position", "part", "entity", "term", "section", "password", "key", "address", "temp", "this", "style", "entry", "project", "parent", "object", "attribute", "character", "update", "config", "prototype", "metadata", "jo", "function", "primary", "prefix", "module", "message", "operator", "resource", "result", "properties", "foo", "string", "option", "element", "tmp"], "newValue": ["defaultvalue", "newVALUE", "nextVALUE", "newString", "oldVALUE", " newVALUE", "nextValue", "NewString", "rawVal", "replaceVALUE", " newString", " newvalue", "replaceValue", "oldValue", "NewVal", "nextvalue", "nextVal", "replaceVal", "rawString", "defaultVALUE", "newvalue", "defaultVal", "currentvalue", "rawVALUE", " newVal", "newVal", "oldVal", "currentVALUE", "currentValue", "rawValue", "defaultValue", "NewValue", "oldvalue", "NewVALUE", "currentVal", "replacevalue"], "crypt": ["pool", "ctr", "pt", "python", "ca", "cash", "dec", "bec", "enc", "comb", "ec", "utils", "hex", "binary", "prot", "ssl", "copy", "cache", "conn", "cook", "contract", "mac", "cmd", "cr", "Crypt", "ryption", "password", "key", "client", "temp", "mix", "cmp", "lib", "cc", "poly", "rypt", "ch", "chain", "hash", "code", "conv", "core", "c", "com", "coin", " cryptography", "coll", "cm", "con", "security", "auth", "cp", "chip"], "digest": ["digress", "encoded", "signEST", "designit", "Digist", "genested", "cododed", "gener", "digit", "DigEST", "crester", "digoded", "Digester", "Digusher", "Digend", "codester", "crist", "digested", "genest", "ddusher", "designest", "designester", "digester", "digEST", "digist", "ddest", "ddester", "Digoded", " digist", "crest", " digend", "Digested", "digend", "signested", "diger", "digusher", "signer", "encest", "Diger", "crend", "codress", "genEST", "signest", "Digit", "codest", "encress", "designusher", "Digress", " digester", "Digest", "encester", "ddit"], "hexString": ["rexArray", "hashStr", "hexstring", "hexArray", " hexArray", "exArray", "byteBuffer", " hexBuffer", "exstring", "rexBuffer", "tempArray", "exBuffer", "cryptBuffer", "hexBuffer", "tempSection", "hashArray", "hashString", "rexString", "byteArray", "tempBuffer", "cryptArray", "hexSection", "tempString", " hexStr", "cryptSection", "hashBuffer", "exString", "byteString", "byteStr", "hexStr", " hexstring", " hexSection", "rexstring", "cryptString"], "i": ["x", "f", "data", "si", "it", "ti", "ri", "s", "slice", "m", "p", "j", "info", "pi", "k", "field", "ix", "hi", "I", "di", "u", "b", "multi", "bi", "l", "r", "e", "key", "o", "abi", "d", "ci", "init", "h", "xi", "v", "oi", "ui", "li", "uri", "ii", "io", "c", "in", "id", "index", "mu", "pos", "gi", "phi", "ip"]}}
{"id1": "18891988", "id2": "2511579", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"getFile": ["loadFilename", "downloadfile", "getfile", "downloadFile", "GetFile", "getFilename", "loadString", "Getfile", "downloadString", "loadfile", "GetFilename", "loadFile", "GetString", "getString", "downloadFilename"], "serviceName": ["ServiceType", "ServicePath", "ServiceName", "Servicename", "projectPath", "packagePath", "packagename", " servicePath", "servicePath", "packageName", "projectName", "ServiceUrl", "projectType", "serviceUrl", "servicename", "serviceType", "packageUrl", " serviceType", " servicename", " serviceUrl", "projectUrl"], "wsdlLocation": ["wsdlUrl", "wsslLocation", "wllFile", "wsllUrl", "wddlLocation", "awslFile", "wddlDirectory", "wsdlFile", "wdlDirectory", "wslLocation", "awsdlLocation", "wllFolder", "wsdlFolder", "wsllAddress", "wslpDirectory", "wslpLocation", "wddlFile", "wslFolder", "awslDirectory", "wsslFile", "wssdFolder", "awsdlDirectory", "wdlLocation", "wllLocation", "wdlFile", "wdlFolder", "wssdFile", "wsllFile", "wslUrl", "wslDirectory", "wsdlDirectory", "wslpFile", "wsslAddress", "awsdlUrl", "awslUrl", "wssdAddress", "wsllFolder", "wllAddress", "wsDLUrl", "wddlFolder", "wsslFolder", "wslFile", "awsdlFile", "wslpFolder", "awslLocation", "wdlAddress", "wsDLDirectory", "wsllLocation", "wsdlAddress", "wsDLLocation", "wsllDirectory", "wsDLFile", "wssdLocation"], "endpoint": ["enpointer", "endPoint", "ENDPoint", "endpo", "enaddress", " endpointer", "endsword", "endspoint", "endsocol", " endPoint", "Endpoint", " endpo", "endpoints", "enination", "startpoint", " endocol", "Endword", "endocol", "enPoint", "ENDination", "startPoint", "Endocol", "enpoint", " endaddress", "EndPoint", "endspo", "endination", " endword", "startaddress", "ENDpoints", "Endpo", "Endination", "ENDpoint", "startpointer", "endaddress", "Endpoints", "endpointer", "endword", "enpoints"], "fileLocation": ["FILEUrl", "FileLocation", "FILEURI", "FileUrl", " fileUrl", " fileDirectory", "fileUrl", "FILELocation", " fileURI", "fileURI", "FILEDirectory", "FileURI", "fileDirectory", "FileDirectory"], "tempDir": [" tempDirectory", "tempDirectory", "tempPath", "tempVer", " tempdir", " temporaryDir", " temporaryPath", " temporaryVer", "TempDir", "tmpVer", " tempPath", "TempPath", "TempDirectory", "tempdir", "tmpDirectory", "tmpPath", "Tempdir", "tmpDir", " tempVer", " temporaryDirectory", "tmpdir"], "url": ["ul", "connection", "open", "sl", "f", "fl", "channel", "socket", "ur", "el", "stream", "web", "download", "log", "ssl", "base", "ll", "ls", "conn", "l", "client", "address", "pull", "Url", "service", "URL", "source", "image", "path", "config", "server", "uri", "io", "http", "file", "www", "coll", "host", "contact", "string"], "WSDLFile": ["WSDLLFiles", "WSDlSourceFile", "WDDLPath", "WSDLFiles", "WINDLFolder", "WSDLLfile", "WSDDLBase", "WINDELFile", "WSDELFile", "WDDlfile", "WSDLFolder", "WINDLPath", "WINDLFiles", "WINDELFiles", "WDDlPath", "WINDLFile", "WSDDLFile", "WSDlFile", "WSDELPath", "WSDDLPath", "WSDlBase", "WDDLFile", "WDDLfile", "WSDlFolder", "WDDLSourceFile", "WSDlPath", "WSDlfile", "WSDLLFolder", "WINDELFolder", "WSDLLBase", "WSDLLSourceFile", "WDDLFolder", "WDDlBase", "WSDLLPath", "WDDlSourceFile", "WSDDLFolder", "WDDlFile", "WSDLPath", "WDDLBase", "WSDLBase", "WSDDLSourceFile", "WSDDLFiles", "WSDDLfile", "WSDLLFile", "WDDlFolder", "WSDLSourceFile", "WSDELFolder", "WINDELPath", "WSDELFiles", "WSDLfile"], "tmpWSDLFile": ["tmpWSDlFolder", "tmpWDDELFile", "tmpWSDLLFile", "tmpWDDLFiles", "tmpWSDELLocation", "tmpWSDELFolder", "tmpWSDLLFiles", "tmpWSDDLUrl", "tmpWSDLUrl", "tmpWSDELFiles", "tmpWSDDLFile", "tmpWSDlUrl", "tmpWSDLLFolder", "tmpWDDELUrl", "tmpWDDlUrl", "tmpWDDELLocation", "tmpWDDlFolder", "tmpWSDLFiles", "tmpWDDELFiles", "tmpWSDlLocation", "tmpWSDELUrl", "tmpWDDlFiles", "tmpWSDDLLocation", "tmpWDDlFile", "tmpWDDLFile", "tmpWSDLLUrl", "tmpWSDlFile", "tmpWDDLLocation", "tmpWSDLLocation", "tmpWSDLFolder", "tmpWSDlFiles", "tmpWDDLUrl", "tmpWSDDLFiles", "tmpWDDLFolder", "tmpWSDELFile"], "inputFile": ["tempPage", "InputUrl", "requestFiles", "InputBase", "tempBase", " inputStream", "tempFactory", "infile", "inputfile", "outputFile", "inDir", "InputPage", "inputFactory", "outputDir", "inputPage", "requestFile", "InputFactory", "InputStream", " inputFactory", " inputfile", "tempfile", "tempPlace", " inputFiles", "requestStream", "InputBuffer", "InputDir", "inputDir", "tempBuffer", "inPage", "requestfile", " inputPage", "inputBase", "inputUrl", " inputUrl", " inputBuffer", " inputPlace", "outputFiles", " inputBase", "inputFiles", "inputBuffer", "outputfile", "inputStream", "InputFile", "InputPlace", "tempUrl", " inputDir", "Inputfile", "tempFile", "InputFiles", "inputPlace", "inFile"], "tmpFile": ["tempPage", "tempDirectory", "TempFiles", "tempDocument", "tmpPage", "inputDocument", "uploadFile", "tempStream", "TempFile", " tmpPage", "tmpStream", " tmpDirectory", "uploadDocument", "uploadFiles", "uploadStream", "TempPage", "inputFiles", "TempDirectory", "tmpDirectory", "tempFiles", "inputStream", "tmpFiles", " tmpFiles", "tempFile"], "in": ["connection", "bin", "reader", "lock", "login", "f", "data", "socket", "ins", "pin", "m", "p", "In", "is", "ssl", "conn", "inner", "again", "win", "din", "l", "r", "IN", "client", "source", "image", "init", "inc", "inn", "c", "file", "up", "id", "impl", "on", "lin", "input", "gin"], "out": ["connection", "bin", "name", "socket", "channel", "error", "sync", "to", "outs", "timeout", "In", "log", "copy", "conn", "part", "inner", "output", "again", "conf", "cache", "can", "line", "writer", "IN", "err", "o", "client", "OUT", "source", "image", "inc", "ch", "outer", "parent", "conv", "group", "server", "io", "net", "c", "file", "up", "co", "on", "input", "Out"], "con": ["connection", "open", "cn", "socket", "nc", "channel", "un", "gin", "ins", "sync", "en", "plain", "rec", "ssl", "kin", "rc", "conn", "inner", "conf", "win", "can", "IN", "Con", "ran", "client", "connect", "ch", "CON", "uc", "inc", "close", "conv", "thin", "Conn", "c", "com", "co", "cm", "ctrl", "fc", "bc"], "fileLength": ["contentlength", "channelSize", "contentLen", "contentSize", "contentLength", "filelength", "fileLen", " filelength", "fileWidth", " fileLen", " fileWidth", " fileSize", "channelLen", "fileSize", "Filelength", "FileLen", "FileSize", "channelLength", "FileLength", "channelWidth", "FileWidth"], "channelIn": ["resourceOut", "resourceIn", "connectionin", "Channelin", "channelIN", "characterIn", "connectionIn", "channelConn", "channelin", "ChannelIn", "connectionOut", " channelin", "characterin", " channelConn", "ChannelConn", " channelIN", "characterOut", "ChannelOut", "characterIN", "connectionConn", "resourceIN", "resourcein", "ChannelIN"], "channelOut": ["chanOUT", "canOUT", " channelOutput", "chanOut", " channelout", "canOut", "Channelout", "connectionOutside", "ChannelOutput", "channelout", "connectionIn", "channelOUT", "ChannelIn", "connectionOut", "ChannelOUT", "connectionOutput", "ChannelOutside", "connectionout", "chanOutside", "chanout", "canIn", "channelOutput", "chanIn", "ChannelOut", "channelOutside", "canOutside"], "tmpDocument": ["newFile", "mpDocument", "tmDocument", "tempDocument", "newContent", " tmpNode", "tempdocument", " tmpdocument", "tempContent", "mpDoc", "mpFile", "tempDoc", "tmpContent", "newDocument", "tmpNode", "tmNode", " tmpDoc", "tmFile", " tmpContent", "tempNode", "tmdocument", "mpNode", "tempFile", "tmpDoc", "tmpdocument", "newdocument"], "nl1": ["ln11", "arl5", "dl2", "NL0", "NL1", "jl1", "nl6", "nlone", "NL2", "nl0", "arlFirst", "nn1", "kl5", "NL11", "klFirst", "jlone", "nn6", "NL6", "nl5", "klone", "nl2", "kl1", "arlone", "dl0", "nlFirst", "jl5", "nn0", "nn2", "arl1", "nl11", "jlFirst", "nn11", "ln6", "ln1", "ln2", "dl1"], "i": ["ji", "f", "y", "si", "it", "ti", "ri", "slice", "m", "p", "j", "info", "pi", "ie", "ix", "hi", "I", "bi", "di", "b", "u", "multi", "part", "qi", "l", "fi", "e", "o", "uli", "ini", "abi", "d", "ci", "z", "xi", "v", "mi", "ui", "oi", "yi", "li", "uri", "n", "ii", "io", "ni", "id", "iu", "index", "chi", "mu", "eni", "ai", "gi", "phi", "ip"], "node1": ["node0", " node0", "package91", "packageOne", " node91", "layer2", " nodeone", "layer1", "n1", " node2", "nodeone", "shapeOne", "nOne", "Node1", "NodeOne", "shape1", "n0", "nodeOne", "shapeone", "node91", "node2", "package1", "Node91", "packageone", "n2", "layerOne", "Node0", " nodeOne", "Node2", "shape91", "layer91"], "tmpOut": ["vmOUT", "tempout", "cacheOUT", " tmpout", "tempIn", "cacheIn", "ptyout", "txtOutput", "cacheFile", "tempOutput", "txtout", "tmpIn", "ptyOut", "tempOut", "tmpOUT", " tmpWriter", "tmpout", "vmOut", "tmpWriter", " tmpOUT", "ptyOutput", " tmpOutput", "ptyIn", "vmIn", "vmout", "tmpOutput", "tempOUT", " tmpIn", "cacheOut", "txtWriter", "tempWriter", "tempFile", "txtOut"], "retVal": ["RETval", "retRet", "valval", "valVal", "valRet", "retval", " retRet", "RETRet", "RETVal", "valObj", "retObj", " retObj", "RETObj", " retval"]}}
{"id1": "1097146", "id2": "4056444", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "label": 1, "substitutes": {"getMessageDigest": ["getContentdigifier", "getMessageSignest", "getMessagedigests", "getMessageDigester", "getMessagedigest", "getMessageEncester", "getMessageEncests", "getMessageEncifier", "getContentdigests", "getContentDigests", "getMessageEncest", "getContentDigest", "getMessagedigester", "getMessageSignests", "getContentDigester", "getContentdigest", "getMessagedigifier", "getMessageSignifier", "getMessageDigests", "getMessageDigifier", "getMessageSignester", "getContentdigester", "getContentDigifier"], "input": ["reader", "inf", "data", "self", "container", "type", "audio", "string", "stream", "array", "state", "str", "xml", "definition", "binary", "model", "text", "output", "instance", "inner", "content", "plus", "password", "address", "temp", "this", "buffer", "i", "source", "list", "image", "parse", "submit", "request", "parent", "object", "form", "context", "config", "argument", "raw", "empty", "null", "document", "element", "in", "message", "amp", "out", "target", "accept", "Input", "now"], "md": ["bm", "meta", "df", "bd", "vd", "mag", "mg", "rm", "wd", "mad", "dd", "m", "ma", " MD", "mt", "me", "di", "mb", "am", "mac", "M", "cmd", "dm", "um", "mn", "dr", "sm", "d", "dc", "MD", "gd", "mo", "mod", "amd", "mp", "rpm", "metadata", "mm", "pm", "sha", "cm", "bf", "mc", "ms", "od", "mand", "nm"], "bytes": ["pages", "vals", "values", "data", "blocks", "rows", "gb", "s", "bs", "groups", "body", "outs", "units", "codes", "binary", "base", "words", "les", "parts", "b", "files", "bits", "ies", "bles", "lines", "address", "its", "strings", "pieces", "ipes", "tes", "classes", "odes", "bps", "null", "keys", "seconds", "es", "Bytes", "string"]}}
{"id1": "3430784", "id2": "5148212", "code1": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 1, "substitutes": {"decodeBody": ["decodingStream", "decodesBody", "decodesFile", "decodedStream", "decodesStream", "decodedFile", " decodedBody", "decodingBody", " decodedFile", " decodedStream", " decodedPart", "decodeStream", "decodedPart", "decodePart", " decodeStream", "decodesPart", "decodingPart", "decodedBody", "decodingFile", "decodeFile", " decodeFile", " decodePart"], "in": ["reader", "bin", "connection", "isin", "login", "f", "data", "get", "into", "it", "version", "socket", "session", "inas", "ins", "m", "body", "cin", "ex", "min", "load", "In", "is", "inside", "conn", "b", "inner", "loader", "again", "content", "win", "din", "work", "r", "IN", "err", "ini", "buffer", "i", "source", "init", "image", "inc", "nin", "request", "exec", "url", "config", "read", "pass", "inn", "c", "as", "file", "id", "src", "resource", "input", "con", "ac", "gin", "serv"], "contentTransferEncoding": ["contentPartEasing", "contentTransferAcasing", "contentPartEncryption", "contentTransferEnoder", "contentTransferEndoder", "contentTransferEoder", "contentRestEnoder", "contentTransferEngoded", "contentTransferencoder", "contentTransferAcosing", "contentTransferEasing", "contentTransferEncitting", "contentTransferEndoded", "contentPartEoding", "contentTransferEcitting", "contentTransferEcording", "contentTransferEngasing", "contentPartEncoding", "contentTransferEnasing", "contentTransferEnryption", "contentRestEncaming", "contentRestEncording", "contentTransferEndoding", "contentPartEncasing", "contentTransferCryption", "contentTransferCoding", "contentTransferEosing", "contentTransferEcoding", "contentTransferEncoded", "contentRestEncoding", "contentPartEncoder", "contentTransferEoding", "contentTransferEnording", "contentTransferEnoded", "contentTransferencoding", "contentTransferEryption", "contentTransferEcaming", "contentTransferEncearing", "contentPartEryption", "contentTransferEngoding", "contentTransferEncoder", "contentTransferEnaming", "contentTransferEnitting", "contentRestEnaming", "contentTransferEnosing", "contentTransferEngearing", "contentTransferencitting", "contentTransferEcoder", "contentTransferCearing", "contentTransferEnoding", "contentTransferEncording", "contentTransferEndasing", "contentRestEnoding", "contentTransferencording", "contentTransferCasing", "contentTransferCording", "contentPartEoder", "contentTransferEncryption", "contentRestEncoder", "contentTransferEncasing", "contentTransferEnearing", "contentTransferEncaming", "contentTransferCaming", "contentTransferAcoding", "contentTransferCoder", "contentTransferEncosing", "contentRestEnording", "contentTransferCoded", "contentTransferAcoder"], "tempBody": ["tempbody", "tmpBody", "TempCore", " tempLife", "outputFile", "TempFile", " tempCore", "TempBody", "tmpLife", "outputLife", "outputBody", "tmpFile", " tempbody", "outputbody", " tempFile", "tmpbody", "Tempbody", "tempCore", "tmpCore", "tempFile", "tempLife"], "out": ["connection", "bin", "app", "ext", "extra", "data", "channel", "socket", "pool", "body", "sync", "ex", "outs", "base", "copy", "page", "cache", "conn", "inner", "output", "again", "user", "writer", "line", "err", "o", "off", "client", "OUT", "temp", "this", "i", "source", "init", "path", "exec", "object", "parent", "raw", "null", "io", "c", "file", "a", "resource", "Out", "obj"]}}
{"id1": "1421557", "id2": "19868933", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToStream", "encodeFiletoStream", "encodeString2Stream", "encodeFiletoFile", "encodeStringToString", "encodeString2String", "encodeFileToStream", "encodeFileToString", "encodeFileFromFiles", "encodeFile2Files", "encodeStringToFiles", "encodeFile2String", "encodeStringToFile", "encodeFileFromString", "encodeString2Files", "encodeFileFromFile", "encodeFiletoString", "encodeFile2Stream", "encodeFileToFiles", "encodeFiletoFiles", "encodeString2File", "encodeFile2File", "encodeFileFromStream"], "infile": ["inputFile", "inputfilename", "Infiles", "outfilename", "infilename", "inputfile", "outFile", "inputfiles", "outfiles", "infp", "inputfp", "outfp", " infilename", " infp", " infiles", "infiles", "Infilename", "InFile", "Infile", "inFile"], "outfile": ["newFile", "outputfilename", "Outfile", "outfilename", "infilename", "outFile", "Outfolder", " outfp", " outfilename", "infp", "newfolder", "outname", "outfp", " outname", " outFile", "Outname", " outfolder", "outputfp", "newname", "newfile", "outputfile", "infolder", "OutFile", "outputfolder", "outfolder"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "vin", "base", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "image", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "copy", "conn", "cache", "again", "output", "inner", "writer", "work", "line", "err", "off", "client", "o", "OUT", "lib", "source", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "post", "io", "net", "file", "up", "co", "on", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "reader", "border", "uffer", "iter", "data", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "len", "queue", "input", "result", "length", "write", "fb", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "close", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "input", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "modified", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "respons", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "9805906", "id2": "873012", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"dump": ["save", "df", "f", "data", "info", "download", "load", "copy", "all", "files", "zip", "Dir", "export", "flush", " dumped", "ump", "db", " dumps", "update", " dumping", "transfer", "store", "println", "diff", "dir", "out", "ln"], "source": ["connection", "iter", "sin", "ources", "current", "start", "s", "slice", "remote", "from", "stream", "se", "base", "ource", "SOURCE", "address", "this", "service", "parent", "view", "uri", "server", "core", "unit", "http", "file", "series", "src", "scene", "resource", "input", "Source", "slave", "string", "use", "site"], "target": ["office", "connection", "it", "force", "master", "arget", "effect", "database", "table", "to", "settings", "base", "top", "output", "goal", "alias", "root", "dest", "address", "pointer", "template", "port", "project", "path", "parent", "object", "large", "next", "platform", "null", "file", "Target", "enemy", "src", "follow", "resource", "out", "result", "host", "replace"], "is": ["ens", "ais", "Is", "iss", "isl", "s", "oss", "bs", "ins", "bos", "ori", "info", "has", "ics", "im", "gets", "isa", "IS", "ls", "cs", "abs", "was", "obs", "ops", "oses", "its", "i", "mis", "ws", "or", "nis", "bis", "ois", "ui", "ists", "ps", "ris", "io", "as", "in", "iso", "iris", "es", "ai", "opens", "us", "ios", "lis", "ip", "ses", "isi"], "os": ["ens", "ais", "ues", "oa", "cos", "ds", "oos", "s", "bs", "oss", "boot", "bos", "ori", "ips", "outs", "ows", "cs", "ies", "obs", "ops", "oses", "o", "its", "i", "OS", "or", "Os", "oes", "vs", "ose", "ps", "io", "osi", "as", "pos", "aos", "acs", "ros", "ss", "es", "los", "ios", "us", "ols", "nos", "fs", "ks", "dos"], "done": ["did", "once", "current", "loaded", "data", "Done", "later", "made", "complete", "started", "got", "due", "after", "ready", "one", "disabled", "finished", "odo", "future", "die", "part", "enabled", "expected", "defined", "doing", "confirmed", "next", "nice", " finished", "checked", "dad", "empty", "yes", "last", "running", "gone", "none", " Done", "foo", "progress", "always", "de", "dirty"]}}
{"id1": "3756429", "id2": "9099457", "code1": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public static String hash(String value) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] md5hash = new byte[32];\n            md.update(value.getBytes(\"iso-8859-1\"), 0, value.length());\n            md5hash = md.digest();\n            return Hex.encodeHexString(md5hash);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"scramble": ["scroubles", "scambling", "screambler", "scroubling", "scrouble", "scroubler", "scrambler", "scamble", " screambles", "scrambles", " screambler", " scrambling", " screambling", "scambles", " scrambler", "scrambling", "scambler", "screamble", "screambling", " scrambles", "screambles", " screamble"], "text": ["ext", "data", "name", "body", "str", "letter", "binary", "class", "output", "bytes", "txt", "content", "password", "secret", "test", "buffer", "source", "image", "Text", "editor", "path", "struct", "object", "pattern", "config", "code", "in", "word", "message", "token", "TEXT", "input", "out", "string", "obj", "texture", "username"], "md": [" Md", "bm", "df", "bd", "vd", "f", "mag", "cd", "rm", "wd", "grad", "mad", "dd", "m", "ma", " MD", "mt", "ind", "bb", "di", "mb", "am", "mac", "hm", "cmd", "dm", "um", "mn", "sm", "d", "MD", "gd", "db", "mod", "amd", "mp", "rpm", "metadata", "mm", "pm", "dh", "cm", "mc", "ms", "od", "mand", "pd", "hd", "ad"], "sb": ["SB", "bm", "BB", " SB", "cb", "su", "bd", "sg", "ob", "gb", "s", "bs", "sync", "bt", "eb", "bh", "xb", "binary", "ssl", "kb", "bb", "ls", " eb", "mb", "erb", "bp", "rb", "buffer", "db", "lb", "sa", "pb", "ab", "wb", "nb", "sr", "src", "bsp", "bf", "sf", "usb", "obb", "fb", "bc", "ib", "buf"], "b": ["be", "bin", "cb", "bd", "f", "machine", "bs", "boot", "body", "p", "eb", "bot", "binary", "base", "bb", "B", "mb", "br", "bytes", "l", "rb", "d", "i", "buffer", "block", "db", "object", "bis", "ab", "pb", "c", "beta", "a", "bf", "obj", "orb", "fb", "nb", "ob"]}}
{"id1": "3046085", "id2": "11673907", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"s": ["f", "data", "name", "g", "m", "services", "sets", "p", "ns", "str", "is", "sample", "w", "text", "b", "parts", "content", "r", "e", "strings", "i", "S", "source", "sound", "t", "path", "v", "speech", "gs", "n", "south", "in", "params", "a", "es", "ss", "sb", "joined", "string", "ses"], "tokenizer": [" tokener", " tokenner", "okener", " tokenization", "optimizer", " tokeniter", "okenzer", "generized", "logize", "okeniser", "generizer", "optiminer", "Tokenizers", "widgetizable", "tokenizers", "tunzer", "toolizer", "Tokenener", "Tokeniser", "initializable", "normalizer", " tokenzer", "normalizable", " tokenener", "tokenister", "tokener", "statizer", "Tokenized", "optimiser", "Tokeniner", "okenator", " tokenized", "initializer", "tunner", " tokenister", "widgetiser", "statator", "finer", "generize", "tokenner", "tooliner", "tokenener", "initialiser", "okenization", "tokeniser", " tokenizers", " tokenize", "tokenizable", "okenize", "normalize", "initialization", "okeniter", "widgetiner", "finizer", "Tokenizable", "finize", "tokenized", "initialize", "initialiner", " tokeniser", "statizers", "logizer", "okenister", " tokenator", "Tokener", "tunizer", "generiser", "tokeniner", "normaliner", "optimizable", "loginer", "tokenization", "okenner", "tokeniter", "logizable", "okenizers", "Tokenizer", "tokenzer", " tokenizable", "finizable", "okenizable", "statiter", "tuner", "okenener", "toolize", "Tokenister", "okenizer", "toolizable", "widgetizer", "tokenator", "okeniner", "Tokenize", "tokenize"], "title": ["meta", "genre", "profile", "tag", "song", "data", "name", "type", "audio", "layer", "theme", "Title", "label", "art", "bot", "album", "summary", "format", "description", "music", "team", "text", "source", "filename", "url", "author", "metadata", "owner", "prefix", "resource", "company", "string", "media", "editor", "license", "username"], "artist": ["genre", "tag", "song", "Artist", "master", "archive", "piece", "audio", "creator", "photo", "layer", "theme", "chart", "episode", "art", "winner", "album", "music", "video", "season", "alias", "patch", " artists", "track", "player", "source", "image", "filename", "author", "metadata", "prefix", "target", "cover", "voice", "media", "username"], "location": ["region", "tag", "loc", "layout", "photo", "audio", "language", "layer", "theme", "gallery", "album", "position", "description", "time", "content", "address", "lang", "image", "mobile", "path", "url", "level", "message", "Location", "motion", "length", "area", "media"], "rating": ["genre", "boarding", "audio", "training", "rank", "sharing", "album", "resolution", "description", "weight", "playing", "ranking", "scoring", "fps", "season", "random", "padding", "style", "live", "breaking", "game", "score", "rate", "repeat", "tracking", "alpha", "media", "rising"], "overplay": ["offledge", "offplay", "replay", "oplay", "overlay", "opplay", "overledge", "opload", "reledge", "reload", "offlay", "overload", "relay", "opledge", "offload"], "temp": ["tag", "data", "sequence", "name", "layout", "loc", "Temp", "current", "type", "pt", "stable", "body", "emp", "partial", "str", "base", "format", "music", "part", "cache", "txt", "content", "test", "track", "list", " temporary", "style", "source", "template", "testing", "path", "stage", " tmp", "tmp", "empty", "unit", "flat", "original", "prefix", "message", "tc", "fake", "string", "media", "font"], "tags": ["ids", "thumbnails", "images", "sections", "packages", "phones", "events", "relations", "words", "files", "features", "bots", "authors", "strings", "tracks", "assets", "archives", "stats", "stars", "dates", "notes", "products", "comments", "names", "styles", "Tags", "terms", "fields", "modules", "videos", "users", "bugs", "tests", "properties", "reports", "types", "resources", "plugins"], "bytes": ["pages", "values", "data", "blocks", "articles", "balls", "body", "ips", "outs", "units", "codes", "gets", "words", "les", "parts", "size", "bits", "files", "lines", "letters", "strings", "pieces", "tes", "objects", "notes", "comments", "errors", "bps", "keys", "params", "videos", "seconds", "es", "fee", "Bytes"], "hasher": ["haher", "hahers", "hanhr", "haveest", " hashed", "hadher", "hashher", "haveer", "haser", "Haser", "haer", "hanher", "havehandler", "haest", "Hashers", "hashandler", "hashhandler", "Hashed", " hashers", "hashers", "Hasest", "hashed", "hadumper", "haveumper", "haner", "hadest", " hashr", "Hasher", "hanest", "hashumper", " haser", "hasumper", "hashr", "haveher", "hashest", "hahed", "hasest", "havehr", " hasest", "hadhandler"]}}
{"id1": "646016", "id2": "5836744", "code1": "    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorCliente.elimina()\");\n        int id = cli.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            sql = \"DELETE FROM persona WHERE id =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt.executeUpdate(sql);\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        }\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"elimina": [" elimada", "elimalina", "elimerini", "elrimina", "elrimada", " elrimita", "elrimini", " elrimina", " elimita", " elrimini", "elimalita", "elimita", " elrimada", "elimerina", "elimerada", "elimada", "elimalada", "elimalini", " elimini", "elimerita", "elrimita", "elimini"], "cli": ["connection", "util", "dl", "ctl", "lo", "Client", "hi", "lc", "API", "cci", "di", "conn", "cmd", "l", "client", "lu", "oci", "i", "ci", "gui", "ctx", "api", "colo", "gd", "cfg", "xi", "ui", "GUI", "li", "server", "uri", "cu", "osi", "uci", "CL", "cgi", "c", "sci", "gi", "ctrl"], "id": ["x", "ids", "connection", "aid", "active", "login", "f", "name", "version", "start", "it", "q", "error", "email", "database", "type", "ident", "p", "info", "en", "patient", "status", "oid", "model", "mid", "num", "zip", "val", "vid", "key", "client", "address", "md", "kid", "d", "i", "entry", "style", "db", "value", "path", "h", "like", "pid", "url", "admin", "code", "server", "ID", "in", "index", "Id", "ql", "uid", "resource", "sid", "ip"], "sql": ["msg", "job", "base", "sl", "su", "statement", "data", "layout", "name", "sg", "util", "eps", "liquid", "dl", "type", "seed", "install", "sync", "str", "os", "sys", " SQL", "log", "status", "SQL", "ls", "ssl", "lc", "html", "ll", "sv", "cmd", "l", "query", "zip", "shell", "err", "lua", "sal", "sex", "lang", "cop", "sq", "comment", "i", "live", "db", "js", "url", "no", "general", "repl", "nl", "sol", "null", "details", "lv", "function", "script", "params", "ql", "result", "sb", "sf", "ln", "auth", "rl", "string", "generic", "il"], "stmt": ["estmt", "sttr", "putmt", "sthmt", " stmb", " stdr", " stmn", " stmm", "fMT", "stMT", "fmp", "estpt", "estnt", "estmb", "Stmt", " stnt", "estmd", " stdb", "estmm", "estdb", "Stmm", "stmp", "stmm", "instmt", "stmd", "fmt", "sthdr", "putmb", " stm", " stMT", " stpt", "shmn", " stmd", "stdr", "Stdb", " sttr", "stdb", "stsql", "shtr", "StMT", " stmp", " stsql", "shnt", "stmn", "estsql", "stm", "sthm", "estmn", "sthdd", "putsql", "putpt", "Stm", " stdd", "instm", "stpt", "fm", "stmb", "Stmp", "Stmd", "shmt", "stnt", "esttr", "instdr", "instdd", "stdd"]}}
{"id1": "4398382", "id2": "13946197", "code1": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "code2": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "label": 1, "substitutes": {"digest": ["mdest", "digress", "encse", "generest", " digests", "generests", "Digester", "generester", "digested", " digress", "digester", "Digse", "mdested", "mdests", "mdester", "digse", "encest", " digse", "digests", "generested", "encress", "Digress", " digested", " digester", "Digest", "encester"], "algorithm": ["algebra", "Alignment", "malgorithm", "alenge", "Algorithm", "Algo", "maloding", " algebra", "malignment", " alenge", "challgorithm", "challenge", "algo", "malgebra", " algo", "argorithm", "challgo", "aloding", "Alenge", "alignment", "challgebra", "arignment", "Algebra", "aroding", "Aloding", "argebra"], "text": ["connection", "ext", "sequence", "data", "name", "str", "letter", "format", "output", "txt", "content", "bytes", "password", "address", "secret", "test", "buffer", "source", "image", "value", "feed", "Text", "path", "struct", "object", "pattern", "url", "attribute", "config", "code", "word", "message", "token", "TEXT", "input", "length", "string", "username"], "mDigest": ["amDigested", "MDigester", "mCodested", "mSignge", "MDest", "amDigest", "mGest", "mCodest", "MDigenge", "amPostest", "mDigester", "mCodener", "mDgest", "mDigested", "mdigest", "mDigEST", "mDigener", "mDesigner", "mPostener", "mDesigngest", "mSignester", "MDiggest", "mGast", "mSignest", "mDer", " mDigast", " mGest", "MDigest", "mEncester", "mDigenge", "mSignast", "mGge", "mdigested", " mDigge", "mdigester", "mdiger", "mSignenge", "amDigener", "mdiggest", "mPostested", "mDEST", "MDiger", "mDest", "mSignEST", "mDigge", "mDesignester", " mGge", "MDgest", "MDer", "mGester", " mGast", "mDigast", "mDenge", "mdigener", "mDiger", " mDigester", "mDiggest", "amPostener", "mEncest", "mEncge", "mEncast", "mDester", "amPostested", "mDesignest", " mGester", "mPostest", "MDigEST", "MDester"], "raw": ["full", "data", "container", "array", "partial", "clean", "RAW", "enc", "hex", "binary", "orig", "wrap", "Raw", "instance", "output", "content", "row", "buffer", "source", "image", "feed", "response", "serial", "default", "null", "original", "unsigned", "message", "input", "result", "initial", "none", "internal", "json", "buf"], "encoder": ["ecoding", "decoding", "encoded", " encoding", "Encoding", "encode", "deccode", "decode", "ecoder", "encoding", " encoded", "decoder", "eccode", "enoding", "Encode", "enode", "ecoded", "enoder", " encode", "Encoded", "Encoder", "enccode", "ecode"]}}
{"id1": "18451704", "id2": "11645260", "code1": "    public boolean isValidPage(BookPage page) {\n        boolean isValid = false;\n        try {\n            if (page.getType() == BookPage.TYPE_RESOURCE) {\n                BookPagePreviewPanel panel = new BookPagePreviewPanel(dControl, true);\n                panel.setCurrentBookPage(page);\n                isValid = !page.getUri().equals(\"\") && panel.isValid();\n            } else if (page.getType() == BookPage.TYPE_URL) {\n                URL url = new URL(page.getUri());\n                url.openStream().close();\n                isValid = true;\n            } else if (page.getType() == BookPage.TYPE_IMAGE) {\n                if (page.getUri().length() > 0) isValid = true;\n            }\n        } catch (Exception e) {\n            isValid = false;\n        }\n        return isValid;\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"isValidPage": ["isInvalidpage", "isLegalPage", "isAvailableContent", "IsInvalidPage", "IsValidpage", "isInvalidContent", "IsInvalidBook", "IsValidContent", "isLegalContent", "isValidContent", "IsValidPage", "isLegalpage", "IsInvalidContent", "isValidpage", "IsValidBook", "isAvailablepage", "isAvailablePage", "IsInvalidpage", "isAvailableBook", "isInvalidPage", "isLegalBook", "isInvalidBook", "isValidBook"], "page": ["office", "data", "current", "name", "version", "channel", "book", "type", "language", "class", "section", "next", "facebook", "route", "module", "message", "resource", "pg", "html", "profile", "cache", "content", "display", "client", "project", "parent", "document", "Page", "result", "about", "home", "pb", "app", "f", "filter", "p", "chart", "xml", "pl", "model", "e", "account", "this", "image", "config", "platform", "http", "title", "www", "site", "pages", "manager", "change", "settings", "button", "wiki", "base", "plugin", "user", "instance", "article", "comment", "player", "block", "child", "request", "object", "admin", "view", "server", "pe", "menu", "file", "frame"], "panel": ["flower", "layout", "data", "channel", "widget", "book", "table", "el", "filter", "info", "wall", "settings", "chart", "button", "screen", "label", "plugin", "Panel", "part", "circle", "tab", "board", "journal", "bean", "row", "list", "bar", "player", "map", "paper", "block", "square", "pal", "group", "view", "server", "conference", "browser", "menu", "pan", "frame", "tool", "coll", "window", "plan", "area", "plane", " Panel"], "isValid": ["isActive", "isOpen", " isInvalid", "hasLegal", "asLegal", " isActive", "ISvalid", " isVal", "osvalid", "ISLegal", "asInvalid", "isaActive", "osInvalid", " isvalid", " isOk", "sInvalid", " isOpen", "svalid", "asActive", "IsInvalid", "asOpen", "isOk", " isLegal", "isVal", "idValid", "sLegal", "osVal", "hasvalid", "isaInvalid", "asvalid", "isvalid", "IsValid", "isLegal", "idLegal", "idvalid", "ISInvalid", "asValid", "itValid", "isaOpen", "isaValid", "idOk", "hasInvalid", "sValid", "ISVal", "itInvalid", "Isvalid", "hasValid", "ISValid", "osValid", "itvalid", "isInvalid", "IsLegal", "asOk"], "url": ["connection", "open", "sl", "f", "fl", "channel", "stream", "layer", "web", "control", "base", "ssl", "album", "blog", "b", "user", "plug", "l", "r", "address", "Url", "URL", "source", "image", "feed", "large", "path", "object", "uri", "server", "browser", "http", "file", "ball", "follow", "resource", "www", "bel", "location", "string"]}}
{"id1": "539195", "id2": "15757836", "code1": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "code2": "    private int[] sort(int n) {\n        int[] mas = new int[n];\n        Random rand = new Random();\n        for (int i = 0; i < n; i++) {\n            mas[i] = rand.nextInt(10) + 1;\n        }\n        boolean t = true;\n        int tmp = 0;\n        while (t) {\n            t = false;\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    tmp = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = tmp;\n                    t = true;\n                }\n            }\n        }\n        return mas;\n    }\n", "label": 0, "substitutes": {"copy": ["get", "it", "rm", "create", "put", "py", "change", "download", "opy", "load", "csv", "zip", "cop", "paste", "cmp", "cat", "Copy", "delete", "transfer", "io", "split", "file", "clone", "php", "replace", "cp", " cp", "write"], "src": ["cur", "sl", "sin", "loc", "sup", "name", "RC", "archive", "gb", "s", "sc", "remote", "slice", "stream", "sync", "secure", "inst", "sys", "rc", "ssl", "txt", "img", "href", "rs", "dist", "ruby", "rb", "source", "sub", "image", "path", "filename", "url", "config", "code", "uri", "sit", "file", "id", "upload", "sel", "resource", "sb", "target", "string", "desc"], "dest": ["prop", "const", "loc", "data", "opt", "later", "wd", "tern", " destination", "slice", "them", "buff", "comb", "destroy", "feat", "orig", "die", "text", "output", "txt", "done", "coord", "dist", "temp", "test", "d", "source", "filename", " Dest", "delete", "default", "du", "flat", "folder", "wb", "Dest", "target", "dir", "dat", "home", "replace", "desc", "end", "tmp", "rest"], "ifp": ["dfp", "ipltp", "ifb", "ibtp", "ppp", "pppa", "ifo", "ifpa", "ifi", " ifpa", "IFp", "upcp", "iplpa", " ifb", "Ifi", " ifo", "uppp", "Ifpa", "iplp", " ifcp", " ifpp", "ibp", " ifap", "ibpa", "IFcp", "upp", "ppap", "IFpp", "ifap", "ifpp", "dfb", "ibi", "ppb", "IFo", "ipli", "Ifp", "ifcp", "dfpa", "iftp", "Iftp", "upo", "dfap"], "ofp": ["ofps", "ovf", "ippy", "Ofp", " ofps", " ofy", " off", "Off", "OFps", " ofi", "ippc", " ofc", "Ofi", "off", "OFp", "OFc", "ofi", "ofy", "Ofc", "ovp", "ovc", "ippps", "ofc", "OFy", "ovi", "ippp"], "fis": ["fiss", "fus", "infiss", "cfos", "ofais", "ofis", "flus", "infi", "his", "cfiss", "ofos", "flis", "cfbis", " fais", "cfi", "fls", "fps", " fus", "fi", " fps", "hs", "cfais", "hps", " fi", "infos", "fbis", "ofbis", " fiss", " fs", "fais", "flps", "hus", "cfis", "fs", "infis", " fbis"], "fos": ["ifoser", " foes", "Foses", "ifis", "foses", "bos", "ifos", "Fpos", "boser", "Foes", "poses", "foes", " foses", "pis", "Fios", "Fis", "fops", "bios", "poes", "bis", " foser", "bops", " fpos", "ifops", "fios", "Fos", "pos", "foser", "bpos", " fios", " fops", "fpos"], "b": ["f", "gb", "bs", "boot", "p", "buff", "eb", "xb", "binary", "base", "bb", "bi", "mb", "B", "br", "l", "r", "e", "rb", "d", "emb", "i", "abb", "buffer", "db", "lb", "ba", "h", "bound", "v", "bis", "buf", "ab", "c", "wb", "a", "sb", "bf", "nb", "ib", "ob"]}}
{"id1": "9275622", "id2": "5061606", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["moveFolder", "copyFiles", " copyfile", "copyFolder", "transferFile", "transferFolder", "moveFiles", "transferfile", " copyFiles", " copyFolder", "transferFiles", "movefile", "copyfile", "moveFile"], "_file1": ["_files1", "_files01", "_File2", "_fileone", "_resourceOne", "_mail2", "_file0", "_resource1", "_fFirst", "_resourceone", "_zip1", "_zipFirst", "_fileOne", "_zipOne", "_file01", "_fone", "_fOne", "_File0", "_f1", "_mail1", "_File01", "_mail0", "_File1", "_mail01", "_zipone", "_files2", "_files0", "_resourceFirst", "_fileFirst"], "_file2": ["_files4", "_filesecond", "_Filesecond", "_File5", "_File2", "jfile1", "_file4", " _filesTwo", " _files3", "jmodelsecond", "_model1", "_model5", "_file5", "_modelsecond", "_files3", "_file3", "jfile5", "_play2", "jfilesecond", " _file3", "_playTwo", "jmodel1", "jmodel5", "_play1", "_model2", "_playsecond", "_filesTwo", "_fileTwo", "_File1", "_play5", " _files4", "_files2", "_play4", " _file4", " _fileTwo", "jfile2", "_play3", "jmodel2", " _files2"], "fis": ["fiss", "infiss", "lfais", "lfi", "afis", "cfos", " fris", "afais", "cfiss", "lfis", "cfas", "Fils", " fais", "infils", "afiss", "fi", "Fas", "Fis", " fi", "fils", "infos", "Fiss", "fas", " fiss", "afi", " fils", "lfiss", "Fos", "fris", "Fris", "fais", "cfis", "cfris", "infis", " fas"], "fos": ["infaos", "Fo", "fus", "infus", "Foos", "Foses", "foses", "infios", "feos", "floes", "goses", "Fus", "info", " foos", "fOS", "flis", "infros", "gis", "Faos", "Fros", " fus", "gos", "feoses", "foes", "pis", "Fios", "Fis", "infoos", "infos", "fros", "poes", " faos", "pOS", "feus", "fios", "Fos", "pos", "feis", "foos", " fo", "flOS", " fios", "los", "lis", "faos", "lOS", "flos", "fo", " fros", "loes", "gus"], "canalFuente": ["canalBuence", "canalCraencia", "canaledBuje", "canaledBuze", "canalKuze", "canallBuente", "canallFuente", "canalBuento", "canalFuze", "canalsBuence", "canaledBuente", "canalSuente", "canalFuento", "canallBuence", "canalsFuente", "canalBuente", "canalBuje", "canalSuje", "canalFUje", "canaledFuente", "canalSuestro", "canaledFuestro", "canallFuze", "canalsFuence", "canalsBuento", "canalFUestro", "canalFuencia", "canalKuence", "canalsFuencia", "canalFUente", "canalBuencia", "canaledBuestro", "canaledFuje", "canalKuento", "canalsFuento", "canalFuje", "canallBuze", "canallFuence", "canalsBuencia", "canaledFuze", "canalBuestro", "canallFuencia", "canalKuente", "canalKuencia", "canalFuence", "canalFUencia", "canalSuze", "canalCraence", "canalsBuente", "canalFUze", "canalCraente", "canalCraento", "canalFUence", "canalBuze", "canallBuencia", "canalFuestro"]}}
{"id1": "8690362", "id2": "22993368", "code1": "    public static void fileUpload() throws IOException {\n        HttpClient httpclient = new DefaultHttpClient();\n        httpclient.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION, HttpVersion.HTTP_1_1);\n        HttpPost httppost = new HttpPost(postURL);\n        File file = new File(\"d:/hai.html\");\n        System.out.println(ukeycookie);\n        httppost.setHeader(\"Cookie\", ukeycookie + \";\" + skeycookie + \";\" + usercookie);\n        MultipartEntity mpEntity = new MultipartEntity();\n        ContentBody cbFile = new FileBody(file);\n        mpEntity.addPart(\"\", cbFile);\n        httppost.setEntity(mpEntity);\n        System.out.println(\"Now uploading your file into mediafire...........................\");\n        HttpResponse response = httpclient.execute(httppost);\n        HttpEntity resEntity = response.getEntity();\n        System.out.println(response.getStatusLine());\n        if (resEntity != null) {\n            System.out.println(\"Getting upload response key value..........\");\n            uploadresponsekey = EntityUtils.toString(resEntity);\n            getUploadResponseKey();\n            System.out.println(\"upload resoponse key \" + uploadresponsekey);\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"fileUpload": ["urlupload", "urlPost", "FileDownload", "FileUpload", "Fileupload", "FilePost", " fileupload", "urlUpload", "urlDownload", "fileDownload", "filePost", "fileupload", " filePost", " fileDownload"], "httpclient": [" httpClient", "phpcon", "httpcon", "httpserver", " httpconnection", " http24", "httpsserver", "phpClient", "Httpcon", "php24", "HttpClient", "httpClient", " httpserver", "httpconnection", "Httpclient", "httpsclient", "webClient", "Http24", "webclient", "phpclient", "webserver", "httpsconnection", " httpcon", "webconnection", "httpsClient", "http24"], "httppost": ["motpsort", "httplod", "httmpod", "httpsost", "httipprest", " httpprest", "httppast", " httpport", "httpast", "httmpast", "httppod", "httpsrest", "httppposter", " httplost", "httpsort", " httplrest", "httmpoint", "httmppost", " httppod", "httppppost", "httprest", "htteppost", "httphort", "motpprest", "httmprest", " httploint", "httphost", "httippost", "motpspost", "httppoint", "httplpost", "motpport", "httploint", "httippod", "httmport", " httphort", "httplrest", "httpppost", "httpposter", "motppost", "httpspost", "httpport", " httplod", "httmpost", "httport", "httpost", " httpppost", " httphpost", " httphost", "httpppast", "motpsost", "httepast", " httphoint", "motpsrest", "httphpost", "httplost", "httmposter", "httposter", "httippoint", "httpprest", " httppoint", "httepost", "htteposter", "motpppost", "httplort", "httphoint"], "file": ["connection", "f", "data", "name", "File", "handler", "audio", "body", "stream", "p", "xml", "base", "log", "model", "story", "page", "cache", "b", "part", "files", "picture", "video", "content", "zip", "l", "e", "buffer", "source", "image", "feed", "path", "object", "filename", "form", "url", "document", "movie", "http", "folder", "php", "message", "upload", "FILE", "resource", "queue", "fp", "media"], "mpEntity": ["mpentity", " mpentity", "upentity", "cpContent", "phpEngine", "cpentity", " mpEngine", "MPEnt", "mmContent", "upOrg", "mmEnt", "mpUrl", "mmEntity", " mpContent", "mpEngine", "mpEnt", "cpOrg", "ppContent", "MPUrl", "MPBody", "mpOrg", "cpEntity", " mpUrl", "MPEngine", "upEntity", "MPContent", "phpBody", "MPEntity", " mpBody", "mpBody", "ppEnt", "upContent", "ppEntity", "mpContent", " mpOrg", "phpEntity", "phpUrl"], "cbFile": ["fbfile", "cbBody", "CBfile", "cbfile", "cbPart", "fbFiles", "bbFile", "fbFile", "cbFiles", "bbfile", "CBFiles", "CBEntity", "bbEntity", "fbEntity", "CBFile", "CBBody", "CBPart", "fbBody", "cbEntity", "fbPart", "bbFiles", "bbPart", "bbBody"], "response": ["full", "connection", "answer", "data", "tree", "sequence", "ception", "error", "respond", "body", "stream", "application", "received", "Response", "status", "model", "description", "page", "successful", "output", "success", "line", "collection", "client", "reply", "respons", "service", "image", "feed", "request", "object", "v", "default", "document", "relation", "server", "http", "message", "flash", "resource", "res", "result", "onse", "json", "de", "resp", "site"], "resEntity": ["ResInstance", "respInstance", "respEnt", "respEntity", " resUnit", "ResEntity", "resentity", "respentity", " resEnt", "Resentity", "respEntry", " resEntry", " resentity", "resEntry", "ResEnt", "resInstance", "resUnit", "resEnt", "respUnit", " resInstance", "ResUnit", "ResEntry"], "uploadresponsekey": ["uploadresponsevalue", "uploadResponsekey", " uploadrespkey", "uploadrequestpart", "uploadrespvalue", " uploadresponsevalue", "uploadResponsepart", " uploadresppart", " uploadrespKey", "UploadResponseKey", "uploadrequestKey", "uploadrespkey", " uploadresponseKey", "UploadResponsekey", "UploadresponseKey", "uploadResponseKey", "uploadresppart", " uploadresponsepart", "uploadresponseKey", " uploadrespvalue", "uploadrequestkey", "uploadResponsevalue", "uploadrespKey", "Uploadresponsevalue", "uploadrequestvalue", "UploadResponsevalue", "Uploadresponsekey", "uploadresponsepart"]}}
{"id1": "20735941", "id2": "7425022", "code1": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"getFile": ["newFile", "openFiles", "getfile", "createResource", "getFiles", "openfile", "getResource", "newResource", "openFile", "newFiles", "createFile", "createfile", "createFiles", "openResource", "newfile"], "home": ["f", "family", "Home", "name", "first", "HOME", "base", "library", "log", "class", "user", "house", "include", "domain", "root", "plus", "back", "this", "bar", "build", "project", "path", "parent", "h", "hub", "default", "store", "server", "owner", "up", "folder", "search", "resource", "www", "dir", "host", "join", "directory", "location", " HOME"], "fileName": ["FilePath", "fullPath", "fileType", " fileType", "FileType", "resourcePath", "FileNum", "singleType", "remoteUrl", "urlName", "fullname", "remoteName", "urlNum", " filePart", "filePart", " fileUrl", "Filename", "FilePart", " filePath", "singlePath", "fullPart", "urlname", "fileUrl", "filePath", "remotePath", "filename", " fileNum", "fileNum", "singleName", "resourceName", "fullName", "resourceUrl", "FileName", "urlPath", " filename", "singlename"], "file": ["be", "job", "full", "connection", "le", "lock", "f", "data", "get", "name", "it", "File", "current", "place", "handler", "play", "type", "table", "el", "fe", "local", "letter", "class", "base", "log", "model", "plain", "rule", "part", "user", "output", "zip", "l", "work", "line", "e", "buffer", "lib", "source", "run", "image", "db", "child", "ile", "money", "feed", "path", "parent", "object", "live", "filename", "or", "store", "uri", "http", "up", "function", "folder", "resource", "FILE", "fp", "dir", "use"], "url": ["job", "connection", "sl", "f", "data", "loc", "name", "org", "socket", "ur", "el", "web", "download", "base", "rule", "ource", "ls", "bb", "log", "page", "b", "ssl", "conn", "zip", "l", "r", "fr", "address", "pull", "Url", "service", "URL", "source", "i", "lib", "feed", "api", "image", "path", "object", "lr", "uri", "server", "io", "http", "impl", "resource", "www", "coll", "host", "location", "rl", "string", "ob", "il"], "in": ["reader", "bin", "isin", "login", "f", "data", "into", "socket", "s", "ins", "stream", "In", "is", "inside", "b", "inner", "again", "r", "l", "line", "IN", "e", "plus", "din", "pull", "ini", "i", "source", "init", "image", "inc", "n", "io", "inn", "c", "up", "as", "a", "lin", "resource", "input", "ac", "gin"], "out": ["bin", "ext", "data", "socket", "sync", "to", "ex", "outs", "In", "plain", "base", "is", "copy", "conn", "b", "again", "output", "inner", "line", "writer", "serv", "err", "flow", "o", "client", "IN", "OUT", "this", "i", "source", "init", "inc", "exec", "object", "null", "io", "net", "up", "co", "resource", "exp", "Out", "write"]}}
{"id1": "17161805", "id2": "8164056", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "label": 1, "substitutes": {"encode": ["reoding", "encoder", "encoding", "reode", "enoding", "ensoder", "Encode", "enscod", "Encod", "enscode", "Enoding", "recod", "enode", "enccod", "recode", "enoder", "ensode", "enccode", "Enode", "encod", "Enoder"], "plaintext": [" plaincontent", "longText", "foreTEXT", "bodyform", "forestring", " plainform", "plainTEXT", "plaincontent", "plainform", "bodyText", "bodytext", " plainTEXT", "bodycontent", "batstring", "foreText", "foretext", "longtext", "batText", "batTEXT", "longform", " plainText", "battext", "plainText", " plainstring", "plainstring", "longcontent"], "md": ["meta", "df", "bd", "f", "mag", "cd", "rm", "wd", "grad", "mad", "dd", "m", "ma", " MD", "ind", "me", "di", "mb", "mac", "cmd", "dm", "um", "sm", "d", "MD", "gd", "mod", "amd", "mp", "code", "rpm", "metadata", "mm", "pm", "dh", "sha", "po", "mc", "ms", "od", "mand", "pd", "hd", "ad"], "raw": ["missing", " Raw", "blocks", "ack", " hex", "remote", "array", "stream", "dec", "clean", "RAW", "enc", "load", "shared", "local", "hex", "binary", "ghost", "orig", "Raw", "instance", "all", "rew", "pure", "row", "buffer", "block", "pack", "feed", "ode", "serial", "original", "unsigned", "input", "out", "custom", "initial", "unknown", "internal", "alpha", "micro"]}}
{"id1": "21656668", "id2": "23335922", "code1": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 0, "substitutes": {"copyResourceToFile": ["copyResourcesToFiles", "copyResource2Resource", "copyResourcesToFolder", "copyResourceAsResource", "copyResourceFromFile", "copyResourceToFiles", "copyResourcesFromFile", "copyResourceAsFile", "copyResourcesFromFiles", "copyResourceFromResource", "copyResourcesToFile", "copyResourceToResource", "copyResourceToFolder", "copyResourceAsFolder", "copyResource2Files", "copyResource2Folder", "copyResource2File", "copyResourceFromFolder", "copyResourcesFromResource", "copyResourcesFromFolder", "copyResourcesToResource", "copyResourceFromFiles", "copyResourceAsFiles"], "resourceFilename": ["ResourceFilename", "requestPath", " resourceFile", "resourcePath", "ResourceString", " resourceString", " resourcefilename", "sourceSourceFile", " resourceSourceFile", "ResourceSourceFile", "sourceFilename", " resourcePath", "requestString", "sourceString", "resourceString", "resourcefilename", "Resourcefilename", "ResourceFile", "resourceSourceFile", "ResourcePath", "resourceFile", "sourceFile", "requestfilename", "requestFilename"], "destinationFilename": ["DestinationFilename", "destinationThumbnail", "destinatorSourceFile", "DestinationModule", "destinationModule", "destignmentFile", "destationFile", "destificationThumbnail", "destationSourceFile", "DestificationThumbnail", "destificationModule", "DestinationFile", "destificationFilename", "destificationSourceFile", "DestificationFile", "DestinationSourceFile", "destinationSourceFile", "destationModule", "destarationFile", "DestificationModule", "DestinationThumbnail", "destignmentFilename", "DestificationSourceFile", "destationFilename", "DestificationFilename", "destarationThumbnail", "destignmentThumbnail", "destinatorFile", "destinatorFilename", "destarationFilename", "destinationFile", "destificationFile", "destinatorModule"], "inStream": ["binstream", " inSt", "INstream", " inCh", "ninSteam", "inputSteam", "ninStream", "outstream", "binStream", " instream", "inCh", "inStreamer", "INSteam", " inSteam", "outFile", "binSteam", "inputSt", "outSteam", "binStreamer", "INFile", "inputStreamer", " inStreamer", " inFile", "outSt", "instream", "outStreamer", "inputCh", "inSteam", "ninstream", "inputStream", "outCh", "ninStreamer", "inputstream", "inSt", "INStreamer", "INStream", "inFile"], "outStream": ["inPath", "workSteam", "inputSteam", "outstream", "OUTSteam", " outSteam", "againstream", "outputStream", "againStream", "workStreamer", "inStreamer", "outFile", "oneSteam", " outstream", "outPath", "outSteam", "OutSteam", "outputStreamer", "OUTStreamer", "workstream", "OutPath", "inputStreamer", " outFile", "againSteam", "OUTFile", "oneDirectory", "OutStream", "instream", "outStreamer", "OUTStream", "oneStreamer", "inSteam", "oneStream", "inputStream", " outStreamer", "workStream", "againDirectory", "Outstream", "outputSteam", "inputDirectory", " outPath", "outDirectory", "againStreamer", "outputstream", "inFile"]}}
{"id1": "7981642", "id2": "10715601", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"update": ["save", "login", "data", "edit", "create", "put", "change", "send", "setup", "set", "add", "copy", "register", "user", "check", "text", "u", "and", "password", "key", "updated", "address", "Update", "build", "init", "exec", "h", "delete", "url", "config", "sum", "sign", "post", "up", "append", "replace", "UPDATE", "auth", "push", "insert", "write", "end", "apply"], "mail": ["ul", "msg", "office", "gmail", "alt", "login", "lock", "name", "phone", "mails", "m", "ge", "gal", "xml", "label", "Email", "local", "model", "html", "user", "text", "front", "zip", "old", "password", "address", "md", "proxy", "fax", "source", "value", "url", "hello", "uri", "server", "date", "group", "view", "file", "folder", "dial", "id", "message", "Mail", "contact", "dir", "host", "company", "who", "string", "ip", "username"], "email": ["office", "gmail", "ail", "cdn", "alt", "login", "cn", "name", "phone", "archive", "wd", "note", "mails", "el", "info", "dn", "en", "xml", "Email", "inet", "class", "log", "model", "description", "text", "online", "zip", "old", "line", "password", "address", "md", "nick", "fax", "url", "enter", "li", "n", "uri", "server", "hello", "eu", "folder", "file", "id", "message", "Mail", "dir", "host", "home", "addr", "ip", "element", "username"], "pwd": ["pwt", "cpwd", "cpws", " pWD", "Pws", "ppwd", "Ppassword", "hwd", "hwa", " ppass", "pwa", "hWD", "Pwd", "Pwh", " pwa", " pwt", "ppassword", "cpwt", "Ppass", " pwh", "cpWD", "pWD", "pwh", "Pwa", "ppwh", "hpass", "PWD", "Pwt", "pws", " pws", "pppassword", " ppassword", "ppass", "pppass"], "firstname": ["firstemail", "caseName", "lastkey", "lastuser", " firstName", "hostname", "lastnames", "casename", " firstuser", "lastName", " firstpass", "firstkey", "lastpass", "firstuser", " firstnames", "hostemail", "firstnames", "newuser", "firstpass", "casepass", "hostkey", "newname", " firstemail", "hostName", " firstkey", "caseemail", "lastemail", "newnames", "firstName"], "lastname": [" lastday", "lastkey", "firstday", "lastn", "secondName", "lastnames", "fullname", "lastName", "firstkey", " lastaddress", "firstaddress", "fulln", "lastday", " lastName", "secondname", "lastaddress", "secondkey", "firstnames", " lastnames", " lastn", "fullnames", "fullday", " lastkey", "fullName", "firstn", "firstName", "secondaddress"], "connection": ["manager", "nc", "pool", "handler", "database", "sc", "session", "creator", "ca", "m", "application", "lc", "di", "conn", "b", " Connection", "client", "this", "connected", "condition", "cc", "connect", "db", "cf", "h", "object", "response", "ion", "system", "context", "config", "document", "relation", "server", "Conn", "c", "function", "management", "index", "con", "directory", "Connection", "communication", "bc", "graph"], "attrs": ["attacts", "attks", "attributes", "attras", "Attps", " attks", "atras", "attars", "matps", "atributes", "attps", " attr", "atRS", "Attributes", "Attrs", " attRS", "AttRs", "addars", "atr", "addras", "atrs", "addributes", "attRs", " attRs", " attributes", "addRS", " attps", " attacts", "atps", "Attr", "addRs", "atars", " attars", "attr", "atks", "matars", "addps", "addrs", "matrs", "Attars", "attRS", "Attras", "atacts", "matributes", "Attacts", "addr", "addks"], "sha": ["ema", "meta", "volume", "ka", "ha", "sche", "si", "ua", "ca", "ma", "na", "da", "pi", "lambda", "shi", "base", "hi", "acl", "ami", "mac", "alias", "password", "va", "la", "md", "sm", "wa", "h", "asha", "sum", "sa", "mm", " SHA", "ga", "a", "pa", "eta", "pg", "alpha", "ya", "SHA", "sh", "HA"], "digest": ["mdest", "modEST", " digester", " digests", "DigEST", "diggest", "Digester", "digested", "moded", "modests", "Digcode", " diggest", "digester", "tagest", "digEST", "diged", " digcode", "mdested", "mdester", "mdgest", "digcode", "Diged", " digEST", "Digested", "Diggest", "modest", " diged", "tagester", "digests", "tagcode", " digested", "tagested", "Digest", "Digests"], "hash": ["rh", "bin", "ag", "ha", "hed", "version", "body", "array", "enc", "hex", "bh", "base", "match", "dig", "user", "mac", "her", "kh", "password", "key", "secret", "block", "image", "build", "value", "h", "url", "sum", "code", "raw", "message", "ash", "cover", "auth", "Hash", "json", "html", "sh"], "ctx": [" cx", " rc", "cb", "qa", "loc", "Context", "cn", " cs", "cca", "fw", "sc", "ca", " conn", "ct", "hw", "ck", "pc", "rc", "cs", "lc", " context", "cci", "conn", "jp", "cr", "client", "sq", "cmp", "ci", "cc", "vc", "anc", "cf", "xc", "context", "cl", "config", "conv", "cu", "cv", "c", "cas", "tc", " c", "ctrl", "cm", "mc", "cp", "tx", "bc", "pkg"], "newName": ["oldAddress", " newAddress", "newEmail", "Newname", "oldname", "oldEmail", "newAddress", "NewName", " newEmail", "newname", "NewAddress", " newname", "NewEmail"], "oldName": ["oldHome", "origname", " oldAddress", "OldName", "newHome", "OldHome", "newAddress", "OldAddress", " oldPath", "OldPath", "origName", " oldEmail", "Oldname", "oldname", " oldname", "oldPath", " oldHome", "oldAddress", "OldEmail", "newEmail", "oldEmail", "origPath", "origEmail"]}}
{"id1": "13012591", "id2": "6188784", "code1": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"getPasswordHash": ["getPasswordSum", "getpasswordSecret", "getStringSum", "getHashSum", "getStringhash", " getPasswordSecret", " getpasswordSecret", "getpasswordHash", "getPasswordSecret", " getPasswordhash", " getpasswordHash", " getPasswordSum", "getStringSecret", " getpasswordhash", "getpasswordhash", "getHashhash", "getpasswordSum", "getHashSecret", "getStringHash", "getPasswordhash", "getHashHash", " getpasswordSum"], "password": ["data", "name", "email", "wd", "database", "array", "p", "words", "cache", "user", "text", "Password", "content", "account", "key", "address", "secret", "crypt", "buffer", "padding", "source", " passwords", "sword", "phrase", "path", "PASS", "pattern", "attribute", "config", "number", "code", "pass", "word", "prefix", "message", "token", "input", "security", "auth", "string", "confirmed", "username"], "md": ["bm", "meta", "gm", "bd", "vd", "mag", "mg", "gb", "dd", "m", "ma", " MD", "mt", "arm", "dig", "ld", "alg", "mb", "mac", "hm", "cmd", "dm", "dr", "material", "sm", "d", "dc", "MD", "map", "gd", "db", "mo", "mod", "amd", "mp", "metadata", "mm", "pm", "dh", "mu", "amp", "sha", "cm", "mem", "mc", "ms", "pd", "mand", "ad", "hd", "nm", "od", "mage", "pkg"], "hash": ["data", "ha", "hed", "error", "batch", "handle", "array", "filter", "body", "hex", "bh", "match", "dig", "carry", "cache", "check", "kh", "mac", "mask", "query", "dot", "key", "address", "secret", "row", "count", "map", "image", "build", "block", "square", "h", "url", "sum", "number", "code", "ashes", "index", "search", "message", "sha", "header", "ash", "diff", "cover", "host", "length", "total", "Hash", "html", "sh"], "buf": ["bin", "cb", "f", "data", "ff", "book", "array", "buff", "cap", "Buffer", "aux", "bh", "bb", "b", "box", "br", "abs", "img", "bp", "bag", "va", "rb", "abi", "buffer", "db", "ctx", "cf", "h", "v", "Buff", "conv", "cv", "pb", "ab", "nb", "src", "af", "uf", "cas", "sb", "bf", " buffer", "pad", "ref", "home", "fp", "fb", "bc", "tmp", "pkg"], "i": ["x", "ji", "f", "data", "si", "it", "ti", "ri", "s", "m", "p", "j", "pi", "k", "field", "hi", "I", "bi", "u", "b", "di", "multi", "qi", "l", "r", "fi", "e", "o", "uli", "abi", "d", "ci", "t", "h", "xi", "v", "oi", "ui", "li", "uri", "ii", "io", "c", "id", "index", "chi", "mu", "vi", "eni", "ai", "gi", "phi", "length", "ip", "end"]}}
{"id1": "6966398", "id2": "19739421", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"reader": ["connection", "df", "iter", "er", "manager", "ri", "handler", "book", "raf", "stream", "p", "se", "cms", "k", "load", "rc", "per", "reads", "cer", "keeper", "loader", "instance", "her", "r", "writer", "parser", "o", "pp", "dr", "rr", "row", "buffer", "client", "ner", "oder", "source", "feed", "or", "builder", "driver", "rw", "context", "config", "reading", "read", "server", "io", "pe", "file", "rake", "rar", "ry", "resource", "input", "ler", "Reader"], "ks": ["rows", "inks", "ds", "icks", "bs", "sk", "acks", "se", "ips", "ck", "k", "ics", "ns", "gets", "works", "cs", "reads", "kb", "ans", "kies", "ls", "ko", "ops", "rs", "ke", "hs", "ctx", "qs", "KS", "ki", "DS", "books", "ku", "orks", "vs", "kes", "powers", "akes", "ps", "checks", "keys", "co", "acs", "cks", "opens", "ss", "es", "ges", "CS", "ches", "ms", "fs", "acts"], "key": ["lock", "court", "point", "char", "type", "seed", "ca", "p", "pair", "state", "k", "base", "ssl", "cache", "user", "client", "secret", "ke", "service", "value", "ki", "sign", "code", "transfer", "server", "read", "pe", "io", "keys", "c", "file", "ring", "ce", "trust", "co", "pg", "Key", "ee"], "chain": ["lock", "sequence", "family", "scale", "container", "table", "range", "slice", "stack", "pair", "wheel", "enc", "set", "base", "rule", "wrap", "cache", "box", "circle", "cr", "root", "collection", "Chain", "crypt", "secret", "list", "chains", "block", "image", "path", "object", "config", "store", "code", "c", "file", "coll", "mc", "network", "none"], "os": ["cos", "ds", "oss", "ot", "options", "s", "bos", "p", "outs", "ol", "oid", "is", " o", "op", "ops", "rs", "oses", "o", " bos", "OS", "Os", "object", "io", "ps", "osi", "iso", "pos", "aos", "rss", "ros", "res", "ou", "los", "ios", "es", "opens", "ms", "fs", "ob"], "stamper": ["spamler", "data", "stAMmer", "_", "streamler", "stammpper", " nostamler", " nostameler", "streammer", "stAMper", "s", "g", "spAMmer", "stammer", "stampper", " nostamper", "spampe", "starmper", " nostampper", " nostamepper", "stammler", "starmler", "streamper", "stammpe", "stammmer", "streampe", "stAMpe", "spAMpe", "spamper", "this", "starmple", "stameler", "stammper", "stampe", "path", "stamler", "stameper", " nostameper", "function", "spAMper", "starmpper", "stample", "stamepper", "stammple", "spAMler", "stAMler", " nostample", "stameple", " nostameple", "spammer"], "appearance": ["Appearing", "installearance", "suppfacing", "applier", "askfacing", " applier", "appeared", "askeared", "ppasion", " appear", "installearing", "signlier", "formearance", " appence", " appeared", "suppasion", "formismo", "signointment", "ppaser", "ppearance", "formearing", "atteared", " appismo", "formaser", "appears", "appointment", "appismo", "appfacing", "askence", "appearing", "feedointment", "ppearing", " appaser", "byearing", "suppearing", "signearing", "installear", "appasion", "ppear", "Appears", "appaser", "appear", "signearance", "byismo", "feedear", " appfacing", "feedearance", "signfacing", "suppear", "feedfacing", "byearance", "Appearance", "appence", "attearance", "installasion", "formear", "Applier", "signears", "suppearance", "attence", "suppointment", "attfacing", " appears", "signear", "byear", "askearance", " appearing"]}}
{"id1": "8747840", "id2": "3767903", "code1": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["mop", "get", "rm", "put", "sync", "p", "download", "load", "dump", "Cop", "all", "clip", "zip", "cop", "paste", "cmp", "Copy", "transfer", "split", "file", "clone", "diff", "cp", " cp", "write", " transfer", " Copy"], "src": ["reader", "inf", "cb", "sin", "sl", "loc", "archive", "gb", "s", "ins", "stream", "inst", "rc", "ource", "b", "files", "rin", "img", "dist", "back", "rb", "source", "path", "filename", "url", "config", "uri", "sit", "file", "sel", "resource", "input", "sb", "ref", "obj"], "dest": ["save", "sup", "opt", "name", "later", "tif", "down", "comb", "destroy", "class", "orig", "die", "b", "output", "txt", "done", "dist", "temp", "test", "source", " Dest", "delete", "exit", "thin", "flat", "file", "wb", "folder", "Dest", "result", "target", "obj", "usr", "home", "desc", "de", "tmp"], "in": ["reader", "bin", "isin", "login", "f", "socket", "ins", "m", "stream", "In", "rec", "is", "inside", "conn", "inner", "again", "rin", "win", "l", "r", "din", "IN", "pull", "ini", "i", "source", "sub", "image", "inc", "nin", "h", "url", "n", "thin", "inn", "as", "file", "impl", "id", "a", "lin", "input", "con", "ln", "gin"], "out": ["app", "ext", "self", "socket", "pool", "ex", "outs", "one", "log", "conn", "w", "again", "part", "cache", "output", "img", "b", "writer", "line", "err", "off", "o", "OUT", "temp", "this", "client", "i", "source", "inc", "exec", "outer", "v", "exit", "n", "post", "io", "file", "up", "ou", "home", "exp", "Out", "obj", "over"], "buf": ["cur", "cb", "bd", "f", "data", "seq", "ff", "batch", "p", "cap", "buff", "bh", "rc", "base", "bl", "orig", "bb", "b", "br", "bytes", "cr", "cmd", "bp", "bag", "rb", "buffer", "count", "ctx", "uc", "cf", "v", "raw", "cv", "ab", "wb", "len", "fd", "uf", "queue", "bf", "fp", "length", "cp", "fb", "bc", "tmp"], "c": [" rc", "cur", "cb", "f", "loc", "cd", "nc", "unc", "m", "ct", "C", "p", "k", "enc", "ec", "pc", "rc", "lc", "u", "b", "cr", "l", "r", "e", "o", " i", "dc", "d", "count", "i", "ci", "cc", "pointer", "z", "uc", "cf", "ch", " n", "xc", "v", "cl", "code", " b", "n", "cu", "ce", "a", "cm", "cp", "ac", "col", "fc", "cy"]}}
{"id1": "11484416", "id2": "838844", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"moveFile": [" movedDirectory", " moveDirectory", "MoveFiles", " movedFiles", "moveFiles", "MoveDirectory", " movedPath", " movedFile", " moveFiles", "movePath", "moveDirectory", " movePath", "MovePath", "MoveFile"], "orig": ["bin", "iter", "ext", "Orig", "f", "loc", "org", "origin", "archive", "ctr", "remote", "raf", "array", "ori", "info", "comb", "base", "prev", "copy", "img", "old", "coord", "raid", "dest", "imag", "temp", "rb", "exe", "proxy", "source", "real", "init", "image", "build", "bas", "original", "file", "folder", "id", "impl", "src", "transform", "frame", "coll", "home", "internal", "obj", "buf", "tmp"], "target": ["nt", "f", "current", "it", "force", "origin", "manager", "master", "archive", "arget", "remote", "reference", "auto", "to", "base", "prot", "format", "copy", "match", "eth", "dest", "temp", "this", "ret", "external", "source", "build", "template", "t", "project", "path", "parent", "object", "next", "platform", "original", "Target", "resource", "join", "result", "replace", "compatible", " Target", "tmp"], "buffer": ["bin", "iter", "uffer", "sequence", "data", "batch", "reference", "slice", "layer", "buff", "stack", "Buffer", "binary", "base", "position", "copy", "bb", "cache", "b", "bytes", "content", "address", "padding", "source", "block", "feed", "request", "url", "transfer", "read", "code", "raw", "null", "repeat", "file", "wave", "message", "frame", "header", "result", "resource", "input", "queue", "length", "write", "buf"], "bread": ["ffe", "rows", "bat", "fen", "batch", "robe", "piece", "fle", "ble", "fall", "good", "web", "rub", "div", "fe", "eb", "zero", "str", "fine", "fed", "bn", "loop", "bb", "die", "beat", "cook", "num", "zip", "wake", "bare", "key", "circ", "design", "bc", "abi", "meal", "feed", "cake", "raft", "brew", "choice", "fred", "food", "wen", "bee", "width", "hello", "inn", "knife", "buck", "grain", "sleep", "fee", "length", "fif", "rib", "four", "broken"], "fis": ["fiss", "lfos", "afis", "ufiss", "hIs", "fisa", " fisa", "his", "qils", "lfis", "fIs", " fIs", "fxIs", "fxis", "fxisa", "afiss", "afos", "afIs", "fxos", "qos", "fils", "hisa", "qiss", " fiss", "lfIs", "ufils", " fils", "lfiss", "qis", "ufis", "hos", "ufos"], "fos": ["infaos", " foss", "flens", "Foses", "foses", "flois", "fose", "flose", "Fose", "gros", "Fois", "Faos", "gis", "flaos", "Fros", " fose", "flors", "floses", "gos", "Fens", " foses", "Fis", "infos", "infois", "fors", "fros", "Foss", "goss", "foss", " fens", "Fos", " fros", "fois", "faos", "flos", "Fors", "fens", "infors"]}}
{"id1": "5760649", "id2": "16092702", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"createFile": ["saveResource", "createResource", " createResource", " createFolder", "CreateContent", "saveFolder", " createContent", "CreateFolder", "createFolder", "createContent", "CreateFile", "saveContent", "saveFile", "CreateResource"], "src": ["sl", "cb", "data", "loc", "name", "gb", "s", "slice", "sc", "stream", "secure", "load", "proc", "rc", "SourceFile", "ssl", "rob", "files", "txt", "content", "img", "href", "r", "fn", "ruby", "dest", "rb", "source", "path", "url", "uri", "sit", "file", "upload", "sel", "rss", "resource", "input", "sb", "Source", "fp", "resources", "string", "obj", "buf", "username"], "filename": ["ame", "f", "name", "s", "fil", "SourceFile", "nil", "feat", "Filename", "acl", "loader", "files", "output", "txt", "l", "fn", "ename", "which", "source", "path", "url", "uri", "route", "ames", "metadata", "file", "wb", "title", "prefix", "utf", "FILE", "resource", "sf", "fp", "location", "directory", "length", "rl", "string", "dll", "username"], "fis": ["fiss", " fris", "cfos", "sfos", "sfris", "fbs", "FIS", "sfiss", "cfIS", " fais", "Fbs", "Fis", " fIS", "cfais", "Fiss", "Fais", " fiss", "cfbs", " fbs", "Fos", "fris", "Fris", "fais", "fIS", "sfis", "cfis", "cfris"], "fos": ["sfios", "affos", "sfos", "Fbos", "affis", "bos", "FOS", "Fops", "fOS", " fOS", "fbos", "foras", "foros", "Fios", "Fas", "Fis", "fops", "affios", "bbos", "bios", "fas", "bis", "affbos", "sfops", "foris", "fios", "Fos", "forOS", " fios", "sfis", " fops", " fas"]}}
{"id1": "16063533", "id2": "12306305", "code1": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["Enccrypt", "Encrypt", "Encrypted", "encipher", "enrypt", "decrypted", "enipher", "deccrypt", "enrypted", "decipher", "enccrypt", "encrypted", "decrypt", "Encipher"], "x": ["f", "y", "data", "s", "m", "p", "rex", "ex", "xml", "hex", "b", "text", "xy", "content", "X", "e", "xp", "crypt", "xxx", "xxxx", "fx", "z", "t", "xs", "xes", "xi", "v", "xa", "code", "xxxxxxxx", "xx", "message", "es", "string", "tx", "rx"], "d": ["bd", "vd", "f", "data", "ade", "cd", "sd", "ds", " dd", "mad", "D", "dd", "m", " D", "p", "da", "dx", "dig", "ld", "di", "u", "b", "dom", "and", "e", "o", "md", "dc", "i", "gd", "db", "t", "ded", "rd", "dad", "dh", "id", "ed", "fd", "nd", "pd", "od", "ad", "de", "dict", "dt"]}}
{"id1": "6371580", "id2": "23088292", "code1": "    public void insertDomain(final List<String> domains) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"domain.add\"));\n                    Iterator<String> iter = domains.iterator();\n                    String domain;\n                    while (iter.hasNext()) {\n                        domain = iter.next();\n                        psImpl.setString(1, domain);\n                        psImpl.setString(2, domain.toLowerCase(locale));\n                        psImpl.executeUpdate();\n                    }\n                }\n            });\n            connection.commit();\n            cmDB.updateDomains(null, null);\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                    log.error(ex);\n                }\n            }\n        }\n    }\n", "code2": "    private void Submit2URL(URL url) throws Exception {\n        HttpURLConnection urlc = null;\n        try {\n            urlc = (HttpURLConnection) url.openConnection();\n            urlc.setRequestMethod(\"GET\");\n            urlc.setDoOutput(true);\n            urlc.setDoInput(true);\n            urlc.setUseCaches(false);\n            urlc.setAllowUserInteraction(false);\n            if (urlc.getResponseCode() != 200) {\n                InputStream in = null;\n                Reader reader = null;\n                try {\n                    in = urlc.getInputStream();\n                    reader = new InputStreamReader(in, \"UTF-8\");\n                    int read = 0;\n                    char[] buf = new char[1024];\n                    String error = null;\n                    while ((read = reader.read(buf)) >= 0) {\n                        if (error == null) error = new String(buf, 0, read); else error += new String(buf, 0, read);\n                    }\n                    throw new NpsException(error, ErrorHelper.SYS_UNKOWN);\n                } finally {\n                    if (reader != null) try {\n                        reader.close();\n                    } catch (Exception e1) {\n                    }\n                    if (in != null) try {\n                        in.close();\n                    } catch (Exception e1) {\n                    }\n                }\n            }\n        } finally {\n            if (urlc != null) try {\n                urlc.disconnect();\n            } catch (Exception e1) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"insertDomain": ["insertdomain", "updateDomain", " insertHost", " insertDom", "addDom", " insertdomain", "updateHost", "updatedomain", "addDomain", "addHost", "adddomain", "insertDom", "insertHost", "updateDom"], "domains": ["dimains", "commains", "dimands", "demains", "messains", "demances", "messain", "dimales", "messands", "demales", "demands", "Domands", "domages", "Domages", "commain", "commands", "demages", "demain", "domands", "dimages", "domances", "Domales", "commances", "Domains", "messances", "domales"], "psImpl": ["upsimpl", "ipsimpl", "paramsInstance", "ipsManager", "upsUl", "ipsInterface", "ipsOrg", "osimpl", "ipsEl", "osEl", "qsUl", "PSimpl", "psInstance", "psimpl", "PSOrg", "PSEl", " psimpl", "ipsInstance", "psManager", " psInstance", "osFactory", " psFactory", "psUl", "qsimpl", "ipsImpl", "paramsImpl", "upsImpl", "psInterface", "paramsManager", "PSFactory", " psManager", "osImpl", "paramsInterface", "PSUl", " psInterface", "psFactory", "qsImpl", "PSImpl", " psOrg", "psEl", " psEl", "psOrg"], "iter": ["reader", "er", "it", "ator", "gener", "inse", "el", "upper", "sort", "set", "is", "loop", "cer", "page", "inner", "walker", "former", "ite", "e", "err", "ter", "izer", "i", "ner", "entry", "parse", "inc", "feed", "apper", "oper", "chain", "order", "next", "enter", "iterator", "ir", "finder", "itter", "in", "Iterator", "index", "cher", "Iter", "coll", "inter", "ider", "ip", "end", "over"], "domain": ["feature", "region", "agent", "data", "division", "name", "version", "origin", "remote", "range", "command", "type", "country", "str", "base", "rule", "model", "format", "page", "description", "query", "dom", "root", "key", "address", "zone", "product", "value", "example", "brand", "role", "pattern", "url", "unit", "route", "file", "folder", "id", "index", "prefix", "module", "message", "result", "host", "company", "Domain", "string", "node", "site"]}}
{"id1": "6379126", "id2": "8216539", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"gerarTutorialPage": ["riarTourpage", "riarTutorialElement", "riarTravisElement", "riarTravisDir", "riartutorialDir", "riarTourElement", "riarTravisPage", "riarTutorialpage", "riartourpage", "riarTutorialPage", "riartutorialPage", "riartourElement", "riarTinyPage", "riarTinyDir", "riartutorialElement", "riartourDir", "riartourPage", "riarTourDir", "riarTravispage", "riarTourPage", "riartutorialpage", "riarTinypage", "riarTutorialDir", "riarTinyElement"], "indexDir": ["indexTier", "includeDir", "zipDIR", "zipDir", "indexJar", "includeJar", "IndexJar", "IndexDIR", "indexDIR", "includeTier", "zipTier", "includeDIR", "IndexDir", "IndexTier", "zipJar"], "cssDir": ["gzDir", "javascriptDar", "CSSDar", "cssDIR", "catsDir", "piecesDie", "codesDoc", "piecesDIR", "piecesD", "codesDir", "fontDie", "cssDie", "cssUrl", "gzDirectory", "ssDirectory", "fontDir", "javascriptDir", "CSSUrl", "CSSDb", "cssLen", "fontD", "cssD", "catsDoc", "ssUrl", "javascriptDb", "cssDoc", "ssDIR", "cssDar", "gzUrl", "cssDb", "javascriptDIR", "piecesDir", "gzDIR", "fontDIR", "catsLen", "CSSDir", "CSSDirectory", "ssDb", "ssDie", "ssDir", "cssDirectory", "CSSLen", "CSSDoc", "codesLen", "ssD", "ssDar", "CSSDIR"], "capDir": ["apsVol", "apsDir", "casDirectory", "casDir", "apsDirectory", "capDirectory", "CapVol", "casdir", "capVol", "capdir", "CapDirectory", "apsdir", "casVol", "Capdir", "CapDir"], "licDir": ["lifDoc", "licDoc", "volDoc", "volDir", "voldir", "lifdir", "lifManager", "libdir", "libDoc", "volManager", "licdir", "licManager", "lifDir", "libDir", "libManager"], "midDir": ["casTier", "middir", "midTier", "limTier", "mindDIR", "casDir", "limDIR", "mindTier", "casdir", "mindDir", "limDir", "casDIR", "minddir", "limdir", "midDIR"], "filesDir": ["filesDIR", " filesPos", "stylesDir", "opensDirectory", "locksDir", "videosFolder", "pagesPos", "stylesDur", "locksDirectory", "FilesDir", "filesDur", "imagesDirectory", "imagesFolder", "locksDur", "pagesDir", "filesDirectory", "filesFolder", "opensDir", "videosFile", "FilesDirectory", "imagesDir", "pagesVol", "stylesDirectory", "locksDIR", "filesPos", "opensDur", "stylesDIR", "ballsVol", "imagesFile", "FilesFile", "ballsPos", "filesFile", " filesVol", "ballsDir", "videosDirectory", "FilesFolder", "opensDIR", "filesVol"], "videosDir": ["imagesDb", "viewsDirectory", "videosUrl", "videoDir", "videoUrl", " videosDb", "videosFile", "imagesDir", " videosUrl", "videoDirectory", "viewsUrl", " videosFile", "videosDb", "videoFile", " videosDirectory", "videosDirectory", "viewsDir", "viewsFile", "videoDb"], "imagensDir": ["imgensFile", "imagersDIR", "imagersDir", "imagenJar", "imgentsDir", "imagersFile", "imgentsFile", "imagenciesDIR", "imgensDIR", "imagenDir", "imagersJar", "imagentsJar", "imagenciesDir", " imagensDirectory", "imagersDirectory", "imagentsDir", "imagentsFile", "imagentsDirectory", "imagenciesDirectory", "imgensDir", "imgentsDIR", "imgentsDirectory", "imagensJar", " imagersJar", "imagensDIR", "imgensDirectory", " imagensFile", "imagensFile", "imagensDirectory", " imagersFile", " imagensJar", " imagersDirectory", "imagentsDIR", "imagenDirectory", " imagersDir", "imagenFile", "imagenciesFile"], "local": ["active", "lock", "localhost", " Local", "standard", "specified", "loc", "name", "data", "current", "present", "util", "where", "basic", "self", "remote", "input", "p", "partial", "personal", "state", "shared", "base", "log", "part", "user", "inner", "conf", "managed", "LOC", "l", "back", "temp", "defined", "d", "relative", "request", "path", "serial", "pal", "small", "tmp", "pass", "http", "Local", "file", "global", "prefix", "valid", "same", "Location", "upload", "safe", "dir", "initial", "total", "home", "directory", "location", "available", "internal", "json", "username"], "srcCss1": ["srcCcss4", "srcCfgPre", "srcCse1", "srcCcss0", "srcCass1", "srcCcss11", "srcCse2", "srcCpe2", "srcPcssPre", "srcCrss2", "srcPss81", "srcPcss81", "srcCrss3", "srcRss81", "srcRss2", "srcCse11", "srcPss4", "srcCcss1", "srcRss1", "srcCfg2", "srcCass0", "srcPss2", "srcCcss81", "srcCcssPre", "srcCss81", "srcCrss1", "srcCrss81", "srcPcss1", "srcCass11", "srcRss0", "srcCss11", "srcPssPre", "srcPcss3", "srcPss3", "srcCpe4", "srcCass3", "srcCfg4", "srcCfg1", "srcCass81", "srcCss0", "srcRcss11", "srcPss1", "srcCpe1", "srcRcss1", "srcRcss0", "srcCcss2", "srcPcss2", "srcRss11", "srcRcss2", "srcCrss11", "srcCcss3", "srcCass2", "srcCpePre", "srcRcss81", "srcCse0", "srcCssPre", "srcPcss4"], "destCss1": ["destCxx2", "destPssCard", "destPcss1", "destCfg0", "destCrss2", "destCcss1", "destCcss2", "destPcss0", "destCcss0", "destCrss81", "destCcss81", "destCass3", "destCfg2", "destPcssCard", "destCass1", "destCassCard", "destCcss3", "destPcss2", "destCxxCard", "destCss0", "destCss81", "destCxx1", "destCxx3", "destCrss1", "destCfg3", "destPss81", "destCass2", "destPcss81", "destPcss3", "destPss3", "destCcssCard", "destPss0", "destPss1", "destCrss0", "destPss2", "destCssCard", "destCass81", "destCrss3", "destCfg1"], "srcCss2": ["srcUss1", "srcCcss4", "srcCfgL", "srcChessTwo", "srcChess1", "srcCass1", "srcCrss2", "srcCrss3", "srcPssL", "srcPcssL", "srcCssL", "srcUcss1", "srcCcss1", "srcCssB", "srcUcssB", "srcCass4", "srcUssTwo", "srcCfg2", "srcCcss52", "srcCss27", "srcPss2", "srcAccss52", "srcCross52", "srcCross4", "srcAcss1", "srcCrss27", "srcCfg3", "srcCrss1", "srcPcss27", "srcCssTwo", "srcPcss1", "srcPcss3", "srcCcssB", "srcPss3", "srcCng27", "srcCng1", "srcAcss4", "srcCfg1", "srcCross2", "srcChessB", "srcPss1", "srcAcss2", "srcCass52", "srcCcssTwo", "srcCng2", "srcCss52", "srcCcss2", "srcPcss2", "srcAccss2", "srcCfgB", "srcCcss27", "srcCrssL", "srcCcss3", "srcCcssL", "srcUss2", "srcCass2", "srcPss27", "srcUcss2", "srcAccss4", "srcUcssTwo", "srcAccss1", "srcUssB", "srcCross1", "srcCfgTwo", "srcAcss52", "srcChess2"], "destCss2": ["destCest1", "destNcss4", "destCcss32", "destCest3", "destCcss4", "destCcss72", "destCss32", "destNcss2", "destCcss1", "destCcss2", "destNcss3", "destCfg2", "destNss32", "destCess2", "destNssB", "destNcss32", "destCcss3", "destCfg4", "destNss4", "destCess32", "destNss2", "destCfgB", "destCfg3", "destCess1", "destNcss1", "destNss3", "destCest2", "destNss1", "destCess4", "destCssB", "destNcssB", "destCss72", "destCestB", "destNss72", "destNcss72", "destCfg72", "destCess72", "destCcssB", "destCfg1", "destCfg32"], "srcCss3": ["srcScss15", "srcCcss4", "srcCcssThird", "srcCshThird", "srcCstyle2", "srcScss3", "srcRcss4", "srcRss1", "srcCcss183", "srcCstyle15", "srcCfg3", "srcCcss6", "srcRss183", "srcCsh2", "srcCfg4", "srcCfg1", "srcScstyle93", "srcCrssAND", "srcPss6", "srcCass1", "srcPcss6", "srcRss2", "srcScss93", "srcRcss183", "srcPcssAND", "srcRcssThird", "srcClass15", "srcScstyle2", "srcCcss1", "srcPss2", "srcCstyle93", "srcPcss3", "srcClass93", "srcRcss1", "srcClass3", "srcCcssAND", "srcRcss2", "srcCsh183", "srcCsh3", "srcClass2", "srcCsl3", "srcCssAND", "srcCrss3", "srcPssAND", "srcRcss3", "srcCssThird", "srcRssThird", "srcRss3", "srcCcss2", "srcPcss2", "srcCass2", "srcCstyle6", "srcScss2", "srcCsl2", "srcCstyle3", "srcCrss2", "srcCss93", "srcCslThird", "srcCcss15", "srcRss4", "srcCass4", "srcCfg2", "srcCrss6", "srcCsl183", "srcScstyle3", "srcPss3", "srcCass3", "srcCss15", "srcCcss3", "srcCstyleAND", "srcCss183", "srcCcss93", "srcScstyle15"], "destCss3": ["destScrss6", "destCja6", "destCross03", "destNcss2", "destCrss2", "destCcss2", "destCstyle43", "destCss183", "destCrss6", "destScss2", "destPcss03", "destCcss53", "destCstyle03", "destNcss3", "destCass3", "destCja3", "destCja2", "destCcss3", "destScss6", "destCss03", "destCstyle2", "destCcss6", "destScss183", "destCcss183", "destScrss2", "destPcss2", "destNss2", "destNcss43", "destPss53", "destPcss53", "destNss3", "destCss43", "destCcss43", "destPss03", "destNss43", "destCass2", "destCstyle53", "destScrss183", "destCcss03", "destPcss3", "destPss3", "destCross2", "destScrss3", "destCross3", "destCross53", "destCass43", "destCstyle3", "destScss3", "destCss53", "destCrss183", "destPss2", "destCrss3", "destCja183"], "srcCss4": ["srcCcss4", "srcCass1", "srcPssFour", "srcCrss4", "srcCrss2", "srcPss4", "srcCcss1", "srcCass4", "srcPss2", "srcCrss1", "srcPcss1", "srcPss1", "srcCssFour", "srcCcss2", "srcPcss2", "srcPcssFour", "srcCass2", "srcCcssFour", "srcCassFour", "srcCrssFour", "srcPcss4"]}}
{"id1": "21979462", "id2": "350482", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"downloadURLtoString": [" downloadURLintoLong", " downloadURL2string", " downloadURLintostring", " downloadUrltoStr", " downloadURL2Long", " downloadURLtoLong", " downloadUrlasStr", " downloadURLintoString", " downloadURL2String", " downloadURLasStr", " downloadUrlasString", " downloadURLasLong", " downloadUrlasLong", " downloadURLasString", " downloadURLintoStr", " downloadUrltoString", " downloadURLasstring", " downloadURLtostring", " downloadUrlasstring", " downloadUrltostring", " downloadURL2Str", " downloadUrltoLong", " downloadURLtoStr"], "url": ["connection", "job", "sl", "f", "loc", "data", "name", "remote", "gl", "el", "base", "ssl", "rule", "page", "b", "loader", "user", "l", "address", "Url", "buffer", "URL", "source", "image", "service", "path", "lr", "config", "server", "uri", "http", "file", "resource", "bel", "link", "ref"], "in": ["reader", "bin", "isin", "login", "f", "data", "into", "it", "ilo", "at", "s", "ins", "cms", "min", "In", "is", "ssl", "b", "inner", "again", "r", "din", "IN", "err", "fr", "ini", "buffer", "i", "source", "init", "db", "inc", "nin", "h", "n", "read", "inn", "as", "impl", "ic", "af", "lin", "input", "out", "ln", "re", "ac", "gin", "fb", "rx"], "sb": ["SB", " SB", "bm", "BB", "cb", "bd", "sg", "si", "ub", "gb", "s", "bs", "buff", "sth", "bt", "eb", "lab", "xb", "bh", "kb", "bb", "ls", " eb", "b", "B", "mb", "erb", "sv", "bp", "rb", "buffer", "abb", "db", "lb", "zb", "lr", "sa", "pb", "amb", "wb", "nb", "Bs", "src", "bsp", "bf", "sf", "usb", "obb", "fb", "bc", "ib", "buf"], "str": ["cur", "sl", "iter", "f", "data", "doc", "name", "char", "s", "arr", "st", "ct", "enc", "div", "bl", "lc", "pr", "b", "text", "br", "txt", "cr", "l", "line", "r", "err", "fr", "key", "dr", "list", "i", "sp", "spec", "cl", "read", "pass", "n", "STR", "wr", "sr", "result", "tr", "obj", "coll", "exp", "string", "Str", "stri"]}}
{"id1": "10445819", "id2": "4830847", "code1": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "code2": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "label": 0, "substitutes": {"getReader": ["getreader", "getParser", "getStream", "readStream", "newStream", "newreader", "newParser", "readParser", "loadReader", "newReader", "loadStream", "loadParser", "readReader", "loadreader", "readreader"], "stream": ["reader", "open", "ream", "sl", "f", "data", "channel", "pool", "slice", "body", "cont", "sync", "clean", "control", "roll", "wrapper", "output", "instance", "content", "zip", "trans", "temp", "source", "feed", "child", "port", "object", "serial", "v", "url", "sw", "form", "document", "raw", "read", "null", "http", "file", "draft", "impl", "valid", "upload", "resource", "input", "coll", "host", "window", "draw", "Stream"]}}
{"id1": "19584877", "id2": "12766394", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToStream", "encodeFiletoStream", "encodeString2Stream", "encodeFiletoFile", "encodeStringToString", "encodeString2String", "encodeFileToStream", "encodeFileToString", "encodeFileFromFiles", "encodeFile2Files", "encodeStringToFiles", "encodeFile2String", "encodeStringToFile", "encodeFileFromString", "encodeString2Files", "encodeFileFromFile", "encodeFiletoString", "encodeFile2Stream", "encodeFileToFiles", "encodeFiletoFiles", "encodeString2File", "encodeFile2File", "encodeFileFromStream"], "infile": ["inputFile", "inputfilename", "Infiles", "outfilename", "infilename", "inputfile", "outFile", "inputfiles", "outfiles", "infp", "inputfp", "outfp", " infilename", " infp", " infiles", "infiles", "Infilename", "InFile", "Infile", "inFile"], "outfile": ["newFile", "outputfilename", "Outfile", "outfilename", "infilename", "outFile", "Outfolder", " outfp", " outfilename", "infp", "newfolder", "outname", "outfp", " outname", " outFile", "Outname", " outfolder", "outputfp", "newname", "newfile", "outputfile", "infolder", "OutFile", "outputfolder", "outfolder"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "vin", "base", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "image", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "copy", "conn", "cache", "again", "output", "inner", "writer", "work", "line", "err", "off", "client", "o", "OUT", "lib", "source", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "post", "io", "net", "file", "up", "co", "on", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "reader", "border", "uffer", "iter", "data", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "len", "queue", "input", "result", "length", "write", "fb", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "close", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "input", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "modified", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "respons", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "10728243", "id2": "20100809", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"scramble411": ["scramprint411", "screamprint411", "screamble123", "screamprint41", "screamble5", "screamprint123", "screamprint5", "scramble5", "scramble41", "scramcy41", "scramprint5", "scramprint123", "screamble411", "scrambe5", "scramcy123", "scramble123", "scrambe41", "scramcy5", "scrambe123", "screamble41", "scrambe411", "scramprint41", "scramcy411"], "password": ["wallet", "name", "channel", "email", "wd", "sudo", "words", "user", "Password", "mac", "account", "key", "address", "secret", "crypt", "padding", "sword", "project", "phrase", "PASS", "hash", "path", "filename", "attribute", "sum", "config", "number", "pass", "dh", "word", "prefix", "token", "input", "pad", "security", "auth", "string", "username"], "seed": ["offset", "volume", "Salt", "finger", "name", "machine", "slice", "pair", "state", "mode", "sudo", "text", "size", "zip", "alias", "key", "random", "address", "secret", "crypt", "padding", "source", "template", "driver", "phrase", "hash", "pattern", "prime", "sum", "pass", "shadow", "id", "prefix", "eed", "token", "pad", "length", "string", "device", "username"], "md": [" Md", "bm", "meta", "df", "bd", "vd", "doc", "mag", "mg", "cd", "addr", "rm", "wd", "ds", "grad", "mad", "dd", "m", "ma", " MD", "mt", "mode", "ind", "ld", "kg", "dig", "di", "mid", "om", "mb", "ht", "am", "part", "mac", "hm", "cmd", "dm", "mn", "sm", "d", "dc", "MD", "km", "gd", "mo", "diff", "amd", "mi", "mp", "metadata", "mm", "pm", "dh", "sha", "po", "cm", "mem", "mc", "nd", "ms", "pd", "mand", "ad", "od", "hd", "nm", "Cmd", "pkg"], "passwordHashStage1": ["passwordSumStage1", "passwordSumPhase1", "passwordHashPhaseOne", "passwordSumStage0", "passwordHashstage3", "passwordHashstage4", "passwordHashstage0", "passwordSumStage4", "passwordSumPhase2", "passwordSumPhase4", "passwordHashPhase0", "passwordHashPhase4", "passwordHashStageOne", "passwordSumStage3", "passwordHashStep3", "passwordHashStep1", "passwordHashStep2", "passwordSumPhase3", "passwordHashstage2", "passwordSumStage2", "passwordHashstage1", "passwordSumPhaseOne", "passwordSumPhase0", "passwordHashPhase1", "passwordHashPhase2", "passwordHashPhase3", "passwordHashStage4", "passwordHashstageOne", "passwordSumStageOne", "passwordHashStage3", "passwordHashStage0"], "passwordHashStage2": ["passwordHashStage02", "passwordSumStage1", "passwordSumPhase1", "passwordSumStageTwo", "passwordHashStage8", "passwordBlockStage1", "passwordBlockStage4", "passwordBlockstage4", "passwordHashstage8", "passwordBlockstage2", "passwordHashstage4", "passwordBlockStage8", "passwordHashStep4", "passwordSumPhase2", "passwordSumStage02", "passwordHashPhase8", "passwordHashStageTwo", "passwordHashPhase02", "passwordHashPhase4", "passwordBlockStage2", "passwordHashstage02", "passwordHashstageTwo", "passwordHashStep1", "passwordHashStep2", "passwordHashstage2", "passwordSumStage2", "passwordHashstage1", "passwordHashPhaseTwo", "passwordBlockstage1", "passwordHashPhase1", "passwordHashStep8", "passwordSumPhaseTwo", "passwordHashPhase2", "passwordBlockstage8", "passwordHashStage4", "passwordSumPhase02"], "toBeXord": ["tobeXorder", "toBeCrossor", "toBeZorder", "toBeWorkors", "tobeYors", "toBeXords", "toBEYord", "toBeXor", "toBeXors", "toBeZors", "toBEYORD", "toBeCrossords", "toBeZor", "toBEXords", "toBeYorder", "tobeXords", "tobeYorder", "toBeWorkord", "toBEXORD", "toBEYor", "toBeXorder", "toBeCrossord", "toBeYord", "tobeYord", "tobeXors", "tobeXord", "tobeCrossords", "toBEXord", "tobeCrossor", "toBeWorkords", "toBeXORD", "toBeYors", "toBeWorkORD", "toBeCrossors", "tobeCrossord", "tobeYor", "toBeZORD", "toBeWorkorder", "toBeYor", "toBeYords", "toBeCrossORD", "toBEYords", "toBeWorkor", "toBeZords", "toBEXor", "tobeXor", "tobeCrossors", "toBeZord", "toBeYORD"], "numToXor": ["numToXors", "numToXOr", "numToCrossOr", "num2XOr", "numToxOR", "numToWorkOR", "numToAbsorer", "numtoXors", "numtoxorer", "numToXOR", "num2Xorer", "numToAbsor", "numtoxor", "numToxors", "numToAnyOR", "numtoxOR", "numToAbsOR", "num2AbsOr", "num2XOR", "numtoxors", "numToAnyorer", "numToWorkors", "numToXorer", "numToWorkor", "num2AbsOR", "numToWorkorer", "numToCrossor", "numToCrossors", "numtoXorer", "numtoXOR", "numToxor", "numToAnyOr", "numToCrossorer", "num2Xor", "numToxorer", "numToAbsOr", "num2Absorer", "numToAnyor", "num2Absor", "numtoXor", "numToCrossOR"], "i": ["x", "f", "y", "si", "it", "ti", "ri", "slice", "m", "p", "j", "info", "pi", "k", "ix", "hi", "I", "di", "u", "b", "part", "multi", "bi", "qi", "l", "r", "e", "o", "key", "off", "abi", "d", "ci", "z", "t", "h", "xi", "v", "oi", "ui", "li", "uri", "n", "ii", "io", "c", "in", "id", "index", "chi", "a", "ai", "gi", "ip"]}}
{"id1": "22993368", "id2": "7908169", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeFileAsStream", "decodeFileToFiles", "decodeFile2File", "decodeFileToString", "decodeStringToStream", "decodeStringToString", "decodeFileAsString", "decodeFileAsFile", "decodeString2File", "decodeFileFromFiles", "decodeFileFromFile", "decodeString2Stream", "decodeString2String", "decodeFileFromStream", "decodeStringToFiles", "decodeString2Files", "decodeFileToStream", "decodeFile2Stream", "decodeFileAsFiles", "decodeStringToFile", "decodeFile2Files", "decodeFileFromString"], "infile": ["inputfilename", "outfilename", "infilename", " instream", "inputfile", "inputfiles", "minfile", "outfiles", "infp", "Instream", "inputfp", "Inbase", "outfp", "minstream", " infilename", " infp", " infiles", " inbase", " inFile", "instream", "infiles", "minFile", "inbase", "minbase", "InFile", "Infile", "inFile"], "outfile": ["inputFile", "outputfilename", "outfilename", "infilename", "inputfile", "outpath", "outputFile", "outFile", " outfilename", "inputdatabase", " outdatabase", "inputpath", " outpath", " outFile", "outputdatabase", "outdatabase", " outfolder", "outputfile", "infolder", "outputpath", "outputfolder", "outfolder", "inFile"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "lin", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "channel", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "log", "copy", "conn", "cache", "again", "output", "inner", "line", "writer", "work", "err", "off", "client", "o", "OUT", "lib", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "pass", "post", "io", "net", "file", "up", "co", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "bin", "reader", "border", "uffer", "iter", "data", "channel", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "queue", "input", "result", "length", "write", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "r", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "positive", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "9099457", "id2": "11005804", "code1": "    public static String hash(String value) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] md5hash = new byte[32];\n            md.update(value.getBytes(\"iso-8859-1\"), 0, value.length());\n            md5hash = md.digest();\n            return Hex.encodeHexString(md5hash);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"hash": ["data", "get", "string", "str", "dump", "hex", "set", "match", "format", "check", "text", "mac", "key", "cmp", "build", "pack", "h", "sum", "update", "number", "code", "sha", "ash", "replace", "print", "Hash", "html"], "value": ["values", "data", "name", "version", "database", "type", "language", "variable", "xml", "expression", "format", "description", "text", "output", "content", "val", "VALUE", "key", "password", "address", "this", "buffer", "entry", "source", "image", "response", "object", "v", "property", "number", "hello", "server", "document", "null", "message", "token", "input", "Value", "initial", "json", "string", "media", "element"], "md": ["bm", "meta", "bd", "vd", "f", "mag", "mg", "git", "rm", "wd", "dd", "m", "ma", " MD", "mt", "mb", "mac", "hm", "cmd", "dm", "key", "sm", "d", "MD", "mo", "mod", "amd", "mp", "code", "rpm", "metadata", "mm", "pm", "mu", "message", "sha", "po", "bf", "mem", "mc", "cm", "ms", "pd", "mand", "ad", "od", "nm", "editor"], "md5hash": ["mdlessHash", "md55shadow", "MD6hash", "md55copy", "md5Hash", "MD5header", "md55header", "MD5hex", "md5copy", "md6hash", "md6Hash", "MD5shadow", "md2hash", "md4Hash", "md5header", "md6hex", "MD6hex", "md2copy", "MD5sha", "MD5hash", "md5sha", "mdlessshadow", "mddownsha", "mdlessheader", "md55hash", "MD6Hash", "md5hex", "md4sha", "MD6sha", "md6header", "md6sha", "MD5Hash", "md55Hash", "mand5Hash", "mdlesshash", "MD6shadow", "MD6header", "mand55hash", "md4hash", "mand55copy", "mddownhex", "md4hex", "mand55Hash", "md6shadow", "mddownHash", "md2Hash", "mddownhash", "mand5hash", "md6copy", "md5shadow", "mand5copy"]}}
{"id1": "6188784", "id2": "3767903", "code1": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["lock", "create", "put", "change", "sync", "to", "p", "download", "move", "Cop", "zip", "clip", "cop", "cmp", "map", "Copy", "transfer", " copying", "split", "file", "clone", "replace", "cp", " cp", " transfer", " Copy"], "source": ["reader", "connection", "iter", "sin", "ources", "name", "origin", "down", "slice", "ins", "remote", "from", "stream", "sync", "ie", "base", "ource", "cache", "inner", "SOURCE", "i", "use", "path", "parent", "unit", "route", "file", "up", "id", "src", "resource", "input", "Source", "target", "start", "site"], "dest": ["bin", "sup", "later", "down", " destination", "cont", "destroy", "comb", "orig", "die", "img", "done", "coord", "dist", "temp", "dc", "d", "style", "test", "which", "delete", "exit", "thin", "flat", "wb", "folder", "src", "Dest", "result", "target", "dir", "home", "desc", "de", "tmp"], "in": ["reader", "bin", "connection", "isin", "login", "f", "sin", "issue", "name", "it", "into", "socket", "s", "ins", "pin", "m", "cin", "min", "In", "pc", "ie", "base", "plugin", "inside", "conn", "inner", "again", "include", "win", "r", "din", "work", "IN", "err", "plus", "client", "pull", "ini", "i", "image", "init", "inc", "nin", "parent", "url", "n", "thin", "inn", "c", "as", "file", "id", "up", "src", "resource", "input", "con", "ac", "gin"], "out": ["connection", "bin", "extra", "ext", "outside", "name", "socket", "at", "pool", "channel", "down", "sync", "ex", "outs", "not", "timeout", "one", "plain", "conn", "w", "again", "output", "inner", "part", "vert", "writer", "err", "password", "o", "client", "off", "OUT", "this", "call", "i", "buffer", "cat", "lib", "exec", "parent", "outer", "other", "our", "no", "n", "io", "net", "file", "up", "id", "prefix", "ou", "exp", "Out", "write", "obj", "option"], "size": ["x", "offset", "open", "loc", "si", "sized", "scale", "name", "depth", "sync", "send", "any", "mode", "Size", "en", "add", "time", "bytes", "content", "max", "capacity", "shape", "e", "export", "iz", "address", "flush", "ice", "seek", "count", "clear", "speed", "sec", "order", "close", "sum", "width", "number", "n", "transfer", "unit", "empty", "small", "SIZE", "len", "ize", "izes", "length", "start", "end"], "buf": ["bin", "cb", "bd", "seq", "data", "ha", "ff", "BU", "buff", "Buffer", "feat", "b", "vec", "br", "bytes", "box", "ra", "bag", "la", "rb", "buffer", "cmp", "map", "ctx", "uc", "cf", "ba", "fam", "cv", "len", "src", "uf", "cas", "coll", "bf", "fb", "bc", "pkg"]}}
{"id1": "4852691", "id2": "7372311", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["get", " fingerprint", " hashing", "str", "dump", "log", "dig", "copy", "add", "check", "component", "text", "password", " Hash", "build", "pack", "h", "sum", "update", "code", "read", " hashes", "print", "Hash", "string", "SHA"], "data": ["reader", "connection", "s", "database", "audio", "body", "p", "info", "str", "dump", "hex", "binary", "base", "format", "video", "text", "output", "bytes", "content", "key", "address", "buffer", "padding", "source", "storage", "image", "response", "memory", "DATA", "a", "message", "result", "input", "dat", "length", "json", "string", "media"], "digest": ["signEST", " diger", "digit", "DigEST", "digener", " digests", "Digester", "biger", "signests", "digester", "Digse", "logener", "bigester", "digEST", "Digener", "bigest", " digger", "digger", "logester", "digse", "bigEST", "signester", " digEST", "diger", "Digger", "logest", "signer", "Diger", "signest", "signger", " digse", "loger", "digests", "Digit", " digit", "signit", " digener", "signse", " digester", "Digest", "Digests", "bigger"]}}
{"id1": "16388708", "id2": "3731077", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeFileAsStream", "decodeFileToFiles", "decodeFile2File", "decodeFileToString", "decodeStringToStream", "decodeStringToString", "decodeFileAsString", "decodeFileAsFile", "decodeString2File", "decodeFileFromFiles", "decodeFileFromFile", "decodeString2Stream", "decodeString2String", "decodeFileFromStream", "decodeStringToFiles", "decodeString2Files", "decodeFileToStream", "decodeFile2Stream", "decodeFileAsFiles", "decodeStringToFile", "decodeFile2Files", "decodeFileFromString"], "infile": ["inputfilename", "outfilename", "infilename", " instream", "inputfile", "inputfiles", "minfile", "outfiles", "infp", "Instream", "inputfp", "Inbase", "outfp", "minstream", " infilename", " infp", " infiles", " inbase", " inFile", "instream", "infiles", "minFile", "inbase", "minbase", "InFile", "Infile", "inFile"], "outfile": ["inputFile", "outputfilename", "outfilename", "infilename", "inputfile", "outpath", "outputFile", "outFile", " outfilename", "inputdatabase", " outdatabase", "inputpath", " outpath", " outFile", "outputdatabase", "outdatabase", " outfolder", "outputfile", "infolder", "outputpath", "outputfolder", "outfolder", "inFile"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "lin", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "channel", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "log", "copy", "conn", "cache", "again", "output", "inner", "line", "writer", "work", "err", "off", "client", "o", "OUT", "lib", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "pass", "post", "io", "net", "file", "up", "co", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "bin", "reader", "border", "uffer", "iter", "data", "channel", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "queue", "input", "result", "length", "write", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "r", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "positive", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "9802073", "id2": "1586662", "code1": "    public void testAutoCommit() throws Exception {\n        Connection con = getConnectionOverrideProperties(new Properties());\n        try {\n            Statement stmt = con.createStatement();\n            assertEquals(0, stmt.executeUpdate(\"create table #testAutoCommit (i int)\"));\n            con.setAutoCommit(false);\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (0)\"));\n            con.setAutoCommit(false);\n            con.rollback();\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (1)\"));\n            con.setAutoCommit(true);\n            con.setAutoCommit(false);\n            con.rollback();\n            con.setAutoCommit(true);\n            ResultSet rs = stmt.executeQuery(\"select i from #testAutoCommit\");\n            assertTrue(rs.next());\n            assertEquals(1, rs.getInt(1));\n            assertFalse(rs.next());\n            rs.close();\n            stmt.close();\n        } finally {\n            con.close();\n        }\n    }\n", "code2": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"testAutoCommit": ["testAutoDebite", "testSyncCommIT", "testAutoDebit", "testAutoComit", "testSyncDebits", "testSyncDebIT", "testAutoComite", "testAutoDebits", "testAutoCommite", "testAutoDebIT", "testAutoommits", "testAutoommit", "testSyncCommits", "testAutoComIT", "testAutoCommits", "testSyncDebit", "testAutoommite", "testAutoommIT", "testAutoCommIT", "testSyncDebite", "testSyncCommit", "testSyncCommite", "testAutoComits"], "con": ["lock", "pool", "class", "win", "common", "ctx", "ocon", "close", "pen", "conv", "c", "com", "co", "coll", "ctrl", "sql", "fc", "cur", "session", "m", "syn", "pub", "en", "pc", "log", "conn", "cache", "conf", "client", "context", "Connection", "bc", "act", "union", "ver", "cn", "util", "un", " conn", "ct", "cr", "pre", "fn", "ran", "cc", "cond", "connect", "config", "n", "platform", "an", "crit", "tc", "cas", "mc", "col", "connection", "fac", "ca", "sync", "non", "min", "gen", "rc", "pr", "can", "Con", "db", "uc", "CON", "cf", "cl", "core", "Conn", "cm", " CON", "ac"], "stmt": ["Stnt", "estmt", "rmd", " stbl", "slur", " stmb", "Stmn", " stmn", "STmb", "estMT", "STbl", "stMT", "STnt", " stor", "estmb", "Stmt", " stnt", "rorp", "Stor", "Stpt", " storp", "stmp", "stmd", "STMT", "ctmp", "Stb", " stm", " stpt", " stMT", "Stmb", "STmt", " stb", "ctmb", "STsp", " stmd", " stur", "rb", "Stbl", "STm", "slmp", "slmn", "estsp", "storp", " stmp", " stsp", "stbl", "ctor", "Storp", "stmn", "STmp", "stor", "stm", "slmt", "Stm", "STpt", "stpt", "stmb", "Stmp", "Stmd", "stb", "stsp", "stnt", "rmt", "stur", "Stur", "ctmt"], "rs": [" rc", "mr", "reader", "RC", " RS", "rows", "RS", "eers", "sc", "ins", "ubs", "results", "Rs", "acks", "vers", "relations", "rc", "cs", " sr", "ls", "pr", "cr", "r", "ra", "repl", "runs", "rr", "rys", " r", "ras", "row", "hs", "hr", " res", "ars", "xs", "rd", "errors", "rt", "ps", "ris", "sr", "src", "rss", "ry", "ros", "res", " results", " Rs", "ges", "ms", "rl", " rows", "ows", "rx"]}}
{"id1": "14764852", "id2": "19322941", "code1": "    public HttpResponse<E> doRequest(HttpMethods method, HttpHeader[] headers, boolean auth, URI target, BlipMessagePart body) throws HttpRequestException {\n        HttpRequest<E> con = createConnection(method, target);\n        if (defaultHeaders != null) {\n            putHeaders(con, defaultHeaders);\n        }\n        if (headers != null) {\n            putHeaders(con, headers);\n        }\n        try {\n            if (auth && authStrategy != null) {\n                authStrategy.perform(con);\n            }\n            if (body != null) {\n                bodyGenerator.writeBody(con, body);\n            }\n            HttpResponse<E> res = execute(con);\n            return res;\n        } catch (IOException e) {\n            throw new HttpRequestException(\"Error executing request\", e);\n        }\n    }\n", "code2": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"doRequest": ["doOperation", "runOperation", " doOperation", "DoOperation", "doQuery", "doResponse", "runResponse", "DoRequest", "DoQuery", " doResponse", "runQuery", "runRequest", " doQuery", "DoResponse"], "method": ["connection", "name", "version", "session", "type", "head", "METHOD", "stream", "mode", "class", "ssl", "format", "text", "content", "client", "subject", "source", "port", "request", "path", "process", "object", "project", "attr", "url", "cl", "sign", "view", "uri", "route", "http", "transform", "module", "message", "crit", "header", "resource", "host", "record", "tr", "Method"], "headers": ["breakers", "heads", "vals", "values", "blocks", "head", "options", "groups", "settings", "relations", "codes", "parents", "words", "parts", "members", "files", "features", "drivers", "workers", "authors", "caps", "lines", "writers", "strings", "qs", "frames", "names", "ppers", "checks", "boxes", "fields", "keys", "tails", "params", "ters", "users", "header", "properties", "types", "resources", "docs", "ers", "agents", "limits"], "auth": ["authent", "lock", "cb", "aut", "ant", "head", "type", "secure", "auto", "info", "enc", "art", "ssl", "acl", "conn", "anon", "user", "att", "password", "Auth", "block", "port", "api", "parent", "config", "arch", "pass", "guard", "oct", "author", "http", "uth", "stat", "upload", "header", "token", "host", "home", "ac", "act"], "target": ["connection", "current", "manager", "arget", "remote", "base", "href", "root", "client", "address", "subject", "reply", "ARGET", "external", "proxy", "source", "template", "port", "request", "path", "response", "object", "parent", "next", "url", "context", "uri", "server", "route", "owner", "Target", "resource", "result", "host", "location"], "body": ["full", "connection", "lock", " Body", "data", " data", " content", "odies", "reason", " response", "stream", "one", "load", "binary", "log", "plain", "part", "b", "text", "output", "content", " object", "query", " bodies", " payload", "reply", " message", "buffer", "comment", "secret", "block", "source", "storage", "port", "db", "proxy", "response", "h", "object", "other", "url", "config", "code", "view", "pass", "Body", "file", "params", "message", "header", "resource", "media", "ob", "ODY"], "con": ["connection", "cur", "cn", "fac", "cos", "un", "ca", "ct", "clean", "enc", "en", "pc", "ann", "rc", "conn", "conf", "can", "cr", "fn", "dom", "ran", "Con", "client", "dc", "cat", "cond", "connect", "ch", "CON", "cf", "request", "exec", "ocon", "xc", "uc", "cl", "conv", "an", "c", "fa", "co", "crit", "cas", "cm", "mc", "ain", "cp", "ac", "col", "fc", "cons"], "res": ["pers", "vals", "data", "s", "arr", "bs", "results", "os", "cs", "req", "resolution", "Res", "pres", "parts", "content", "r", "rs", "val", "err", "RES", "ret", "qs", "js", "response", "vs", "ps", "details", "rep", "params", "des", "result", "es", "out", "re", "rel", "obj", "resp", "cons"]}}
{"id1": "11484416", "id2": "7087108", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"moveFile": [" movedDirectory", " moveDirectory", "MoveFiles", " movedFiles", "moveFiles", "MoveDirectory", " movedPath", " movedFile", " moveFiles", "movePath", "moveDirectory", " movePath", "MovePath", "MoveFile"], "orig": ["bin", "iter", "ext", "Orig", "f", "loc", "org", "origin", "archive", "ctr", "remote", "raf", "array", "ori", "info", "comb", "base", "prev", "copy", "img", "old", "coord", "raid", "dest", "imag", "temp", "rb", "exe", "proxy", "source", "real", "init", "image", "build", "bas", "original", "file", "folder", "id", "impl", "src", "transform", "frame", "coll", "home", "internal", "obj", "buf", "tmp"], "target": ["nt", "f", "current", "it", "force", "origin", "manager", "master", "archive", "arget", "remote", "reference", "auto", "to", "base", "prot", "format", "copy", "match", "eth", "dest", "temp", "this", "ret", "external", "source", "build", "template", "t", "project", "path", "parent", "object", "next", "platform", "original", "Target", "resource", "join", "result", "replace", "compatible", " Target", "tmp"], "buffer": ["bin", "iter", "uffer", "sequence", "data", "batch", "reference", "slice", "layer", "buff", "stack", "Buffer", "binary", "base", "position", "copy", "bb", "cache", "b", "bytes", "content", "address", "padding", "source", "block", "feed", "request", "url", "transfer", "read", "code", "raw", "null", "repeat", "file", "wave", "message", "frame", "header", "result", "resource", "input", "queue", "length", "write", "buf"], "bread": ["ffe", "rows", "bat", "fen", "batch", "robe", "piece", "fle", "ble", "fall", "good", "web", "rub", "div", "fe", "eb", "zero", "str", "fine", "fed", "bn", "loop", "bb", "die", "beat", "cook", "num", "zip", "wake", "bare", "key", "circ", "design", "bc", "abi", "meal", "feed", "cake", "raft", "brew", "choice", "fred", "food", "wen", "bee", "width", "hello", "inn", "knife", "buck", "grain", "sleep", "fee", "length", "fif", "rib", "four", "broken"], "fis": ["fiss", "lfos", "afis", "ufiss", "hIs", "fisa", " fisa", "his", "qils", "lfis", "fIs", " fIs", "fxIs", "fxis", "fxisa", "afiss", "afos", "afIs", "fxos", "qos", "fils", "hisa", "qiss", " fiss", "lfIs", "ufils", " fils", "lfiss", "qis", "ufis", "hos", "ufos"], "fos": ["infaos", " foss", "flens", "Foses", "foses", "flois", "fose", "flose", "Fose", "gros", "Fois", "Faos", "gis", "flaos", "Fros", " fose", "flors", "floses", "gos", "Fens", " foses", "Fis", "infos", "infois", "fors", "fros", "Foss", "goss", "foss", " fens", "Fos", " fros", "fois", "faos", "flos", "Fors", "fens", "infors"]}}
{"id1": "5951610", "id2": "22114133", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    @Override\n    public void actionPerformed(ActionEvent e) {\n        String cmd = e.getActionCommand();\n        boolean askRestart = false;\n        if (cmd == null) return;\n        if (cmd.equals(\"GRAPHVIZ\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"GRAPHVIZ\", filename);\n            graphVizPath.setText(filename);\n            owner.mToolsAuxGraphviz.setEnabled(true);\n        }\n        if (cmd.equals(\"IMAGEMAGICK\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", filename);\n            imageMagickPath.setText(filename);\n        }\n        if (cmd.equals(\"FINFAMILY.XLS\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"xls\"));\n            chooser.setDialogTitle(\"Open xls file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", filename);\n            excelPath.setText(filename);\n            missingKeys = checkForMissingNames(filename);\n        }\n        if (cmd.equals(Resurses.OK)) {\n            String newPath = Suku.kontroller.getPref(owner, \"FINFAMILY.XLS\", \"\");\n            if (!newPath.equals(exPath)) {\n                askRestart = true;\n                Suku.setFinFamilyXls(newPath);\n            }\n            String input = (String) serverUrl.getSelectedItem();\n            if (input == null) {\n                input = \"\";\n            }\n            if (input.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"SERVERURL\", \"\");\n                if (!originUrl.isEmpty()) {\n                    askRestart = true;\n                }\n            } else {\n                URL url;\n                String resp = null;\n                try {\n                    url = new URL(input + \"SukuServlet\");\n                    HttpURLConnection uc = (HttpURLConnection) url.openConnection();\n                    int resu = uc.getResponseCode();\n                    if (resu == 200) {\n                        byte buff[] = new byte[1024];\n                        InputStream in = uc.getInputStream();\n                        int len = in.read(buff);\n                        resp = new String(buff, 0, len);\n                        uc.disconnect();\n                    }\n                } catch (Exception e1) {\n                    e1.printStackTrace();\n                }\n                if (resp != null && resp.toLowerCase().startsWith(\"finfamily\")) {\n                    Suku.kontroller.putPref(owner, \"SERVERURL\", input);\n                    if (!input.equals(originUrl)) {\n                        askRestart = true;\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(this, Resurses.getString(\"SERVER_ERROR\"), Resurses.getString(Resurses.SUKU), JOptionPane.ERROR_MESSAGE);\n                }\n            }\n            int newLoca = loca.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.LOCALE, locas[newLoca]);\n            if (!originLanguage.equals(locas[newLoca])) {\n                askRestart = true;\n            }\n            int newLang = repolang.getSelectedIndex();\n            if (newLang >= 0) {\n                Suku.kontroller.putPref(owner, Resurses.REPOLANG, Suku.getRepoLanguage(newLang, true));\n                Resurses.setLanguage(Suku.getRepoLanguage(newLang, true));\n            }\n            int imageScaler = imageScaling.getSelectedIndex();\n            Suku.kontroller.putPref(owner, \"SCALE_IMAGE\", \"\" + imageScaler);\n            owner.setImageScalerIndex(imageScaler);\n            int seleId = defaultCountryCode.getSelectedIndex();\n            if (seleId >= 0) {\n                selectedCc = ccodes[seleId];\n            }\n            try {\n                Resurses.setDefaultCountry(selectedCc);\n            } catch (SukuException e1) {\n                owner.setStatus(e1.getMessage());\n            }\n            int newDateIndex = dateFormat.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.DATEFORMAT, dateCodes[newDateIndex]);\n            Resurses.setDateFormat(dateCodes[newDateIndex]);\n            Utils.resetSukuModel();\n            boolean openStreetMap = useOpenStreetMap.isSelected();\n            Suku.kontroller.putPref(owner, \"USE_OPEN_STREETMAP\", \"\" + openStreetMap);\n            String fntSize = dbFontSize.getText();\n            Suku.kontroller.putPref(owner, \"DB_VIEW_FONTSIZE\", fntSize);\n            String lf = lfNames[lookAndFeel.getSelectedIndex()];\n            Suku.kontroller.putPref(owner, \"LOOK_AND_FEEL\", lf);\n            int lfIdx = -1;\n            for (int i = 0; i < lafInfo.length; i++) {\n                if (lafInfo[i].getName().equalsIgnoreCase(lf)) {\n                    lfIdx = i;\n                    break;\n                }\n            }\n            try {\n                if (lfIdx < 0) {\n                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n                } else {\n                    UIManager.setLookAndFeel(lafInfo[lfIdx].getClassName());\n                }\n                SwingUtilities.updateComponentTreeUI(owner);\n            } catch (Exception e1) {\n                logger.log(Level.WARNING, \"look_and_feel\", e1);\n            }\n            setVisible(false);\n            if (askRestart) {\n                if (missingKeys != null && !missingKeys.isEmpty()) {\n                    SukuPad pad = new SukuPad(this, missingKeys);\n                    pad.setVisible(true);\n                }\n                JOptionPane.showMessageDialog(this, Resurses.getString(\"RESTART_FINFAMILY\"), Resurses.getString(Resurses.SUKU), JOptionPane.INFORMATION_MESSAGE);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"testNetworkHTTP": ["testNETHTTP", "testNetworkHttp", " testNetworkSSL", "testnetworkHttp", "testnetworkHTML", "testnetworkSSL", " testInternetSSL", "testnetworkHTTP", "testNetworkSSL", " testNetworkHttp", "testInternetSSL", "testInternetHttp", " testNetworkHTML", " testInternetHTML", "testNETSSL", "testInternetHTML", "testNETHttp", "testNETHTML", "testInternetHTTP", "testNetworkHTML", " testInternetHTTP", " testInternetHttp"], "url": ["sl", "channel", "dl", "ur", "web", "bl", "control", "ssl", "ls", "blog", "left", "shell", "buffer", "service", "URL", "path", "lr", "update", "uri", "impl", "resource", "coll", "host", "github", "ob", "ul", "org", "email", "gl", "el", "load", "ol", "log", "ll", "lc", "page", "cloud", "mail", "output", "key", "pull", "call", "build", "group", "ml", "tool", "bf", "use", "il", "job", "loc", "util", "fl", "pl", "loader", "r", "Url", "lib", "image", "feed", "large", "config", "nl", "http", "www", "location", "rl", "rel", "connection", "layer", "event", "base", "user", "text", "l", "entry", "cl", "view", "server", "file", "hl"], "urlConnection": ["urlUnit", "flConnect", "UrlEnvironment", "glConnect", "resourceConnection", "UrlFunction", "flConstruction", "termContainer", "urlConstruction", "numberconnection", "urlGate", "urlReference", "implReference", "uriComputer", "serviceconnection", "emailGate", "urlConnect", "termComputer", "implEnvironment", " urlComputer", "numberConnection", "httpUnit", "urConnection", "blogConnect", " urlConn", "httpConn", "URLconnection", "emailConnect", "lengthConnect", "emailClient", " urlconnection", "htmlConstruction", "uriFunction", "emailConnection", "urlEnvironment", "urFunction", "urConn", "sslConnection", "lengthconnection", "resourceconnection", "glConnection", "UrlConnect", "urlFactory", "implConnection", "numberConnector", "lConnection", "UrlReference", "glFunction", "URLConn", "ulConnector", "flConnection", " urlReference", "blogconnection", "sslConnector", "emailconnection", "URLPool", "lengthConnection", "webPool", "htmlconnection", "urlconnection", " urlClient", "resourceClient", " urlConnect", " urlFactory", " urlConnector", "urFactory", " urlContainer", "urlClient", "sslConn", "UrlContainer", "UrlComputer", " urlGate", "ulConnection", " urlPool", "viewConnection", "lconnection", "urlComputer", "URLConnect", "sslUnit", "lengthConstruction", "termConnection", "emailConstruction", "httpFunction", "webConnection", "flConnector", "uriConnection", "viewconnection", "httpFactory", "ulConn", "URLConnection", "blogConnector", "viewConstruction", "resourceGate", "urlContainer", " urlFunction", " urlUnit", "urlPool", "htmlConnection", " urlEnvironment", "serviceConn", "httpComputer", "serviceConnect", "termConn", "numberConnect", "viewConnect", "ulUnit", "blogConnection", "serviceConnection", "flconnection", "glConn", "urlConn", "lConnect", "uriUnit", "urlConnector", "webconnection", "UrlConnection", "UrlConn", "urlFunction", "lConn", "httpConnection"], "rd": ["rh", "reader", "lt", "bd", "director", "vd", "rn", "RD", "red", "wd", "respond", "ds", "arr", "dd", "R", "adr", "ru", "rod", "sth", "bl", "ld", "dig", "rob", "RL", "rf", "r", "rs", "td", "own", "fr", "lf", "bf", "dr", "std", "rb", "rr", "d", "rowd", "gd", "db", "hr", "DR", "rw", "rg", "lr", "nl", "nor", "dra", "erd", "rt", "ng", "rand", "wr", "dh", "RW", "sr", "ird", "fd", "rss", "RR", "tr", "xd", "dj", " reader", "nd", "usr", "pd", "rl", "rown", "rid", "addr", "Reader", "RF", "rx"], "line": ["msg", "le", "sl", "login", "data", "loc", "name", "error", "lo", "el", "ge", "letter", "log", "status", "ld", "lc", "inline", "page", "part", "user", "l", "val", "cell", "lines", "lf", "key", "la", "row", "d", "ne", "entry", "block", "comment", "source", "limit", "Line", "response", "cl", "number", "code", "nl", "unit", "li", "pass", "file", "id", "LINE", "word", "len", "frame", "sel", "lin", "skip", "link", "rl", "day", "col", "string", "write", "end"]}}
{"id1": "14093044", "id2": "14598566", "code1": "    @Override\n    public boolean insert(String consulta, boolean autocommit, int transactionIsolation, Connection cx) throws SQLException {\n        filasInsert = 0;\n        if (!consulta.contains(\";\")) {\n            this.tipoConsulta = new Scanner(consulta);\n            if (this.tipoConsulta.hasNext()) {\n                execConsulta = this.tipoConsulta.next();\n                if (execConsulta.equalsIgnoreCase(\"insert\")) {\n                    Connection conexion = cx;\n                    Statement st = null;\n                    try {\n                        conexion.setAutoCommit(autocommit);\n                        if (transactionIsolation == 1 || transactionIsolation == 2 || transactionIsolation == 4 || transactionIsolation == 8) {\n                            conexion.setTransactionIsolation(transactionIsolation);\n                        } else {\n                            throw new IllegalArgumentException(\"Valor invalido sobre TransactionIsolation,\\n TRANSACTION_NONE no es soportado por MySQL\");\n                        }\n                        st = (Statement) conexion.createStatement(ResultSetImpl.TYPE_SCROLL_SENSITIVE, ResultSetImpl.CONCUR_UPDATABLE);\n                        conexion.setReadOnly(false);\n                        filasInsert = st.executeUpdate(consulta.trim(), Statement.RETURN_GENERATED_KEYS);\n                        if (filasInsert > -1) {\n                            if (autocommit == false) {\n                                conexion.commit();\n                            }\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    } catch (MySQLIntegrityConstraintViolationException e) {\n                        System.out.println(\"Posible duplicacion de DATOS\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLNonTransientConnectionException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLDataException e) {\n                        System.out.println(\"Datos incorrectos\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (MySQLSyntaxErrorException e) {\n                        System.out.println(\"Error en la sintaxis de la Consulta en MySQL\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (SQLException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } finally {\n                        try {\n                            if (st != null) {\n                                if (!st.isClosed()) {\n                                    st.close();\n                                }\n                            }\n                            if (!conexion.isClosed()) {\n                                conexion.close();\n                            }\n                        } catch (NullPointerException ne) {\n                            ne.printStackTrace();\n                        } catch (SQLException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"No es una instruccion Insert\");\n                }\n            } else {\n                try {\n                    throw new JMySQLException(\"Error Grave , notifique al departamento de Soporte Tecnico \\n\" + email);\n                } catch (JMySQLException ex) {\n                    Logger.getLogger(JMySQL.class.getName()).log(Level.SEVERE, null, ex);\n                    return false;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException(\"No estan permitidas las MultiConsultas en este metodo\");\n        }\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"insert": ["save", "it", " insertion", "create", "put", " append", " inserted", "add", "commit", "select", "submit", "process", "exec", "delete", "update", " Insert", "post", " inserting", "action", "ERT", "append", "replace", "Insert", "execute", "write", "apply"], "consulta": ["conscula", "consula", "consunctable", "consulte", "consulas", "consultas", "Consultse", "consule", "ConsULTa", "Consulte", "consultsarea", "consorte", "consular", "Consultable", "consULTas", "Consulta", "consortao", "consultsar", "consULTa", "Consultao", "consunctas", "consorta", "consunctao", "consunctarea", "consculable", "consultse", "consultable", "consributa", "Consultsable", "consULTe", "Consultsarea", "consributarea", "Consultsao", "ConsULTe", "Consultsas", "consultsable", "consULTar", "Consultsa", "Consultarea", "consultsas", "Consultas", "consuncte", "consultsa", "Consultar", "consuncta", "consultsao", "ConsULTar", "consULTarea", "conscularea", "consortas", "consultao", "consributas", "ConsULTas", "consributao", "consultar", "consULTao", "consultarea", "consculas"], "autocommit": ["autocommIT", "autocCommitting", "autocleanit", "autacommact", "autocomits", "autocleanmit", "autecommit", "autocCommmit", "autocomit", "autocompitting", "autocqumit", "autOComit", "autocleanIT", "autocCommact", "autacommits", "autecomits", "autacCommits", "autrocommit", "autecomitting", "autocquit", "autrocompmit", "autecomited", "autocommact", "autacommit", "autrocompIT", "autocompact", "autocCommit", "autocomited", "autocquitting", "autrocommits", "autocCommited", "autrocommmit", "autecommits", "autocompmit", "autocommmit", "autrocompits", "autocomact", "autocomitting", "autocommits", "autOComitting", "autocleanits", "autocommited", "autocCommits", "autacCommit", "autocompits", "autacCommitting", "autOCommitting", "autocompIT", "autOCommit", "autOComits", "autocomIT", "autrocommIT", "autOCommits", "autOCommmit", "autecommited", "autrocompit", "autocquits", "autecommitting", "autacommitting", "autocommitting", "autacCommact", "autocompited", "autocompit", "autecomit"], "transactionIsolation": ["transactIolation", "transactionIoration", "transactionInteroration", "transactionISoration", "transactionInterolation", "transactionIsolution", "transactionISolate", "transactionIdolation", "transactionIsola", "transactionIola", "transactionIdolate", "transactIolate", "transactionIsolated", "transactionRestolation", "transactionIoli", "transactionIsoli", "transactionRestoration", "transactionIsoration", "transactionInterolated", "transactionInfoolation", "transactIsolution", "transactionIdola", "transactionISolated", "transactionISolation", "transactionIsolate", "transactIsolate", "transactIolated", "transactionISoli", "transactIola", "transactionRestolated", "transactionIdolated", "transactionEolate", "transactionInfoolated", "transactIolution", "transactIsoli", "transactionEolation", "transactionInterola", "transactIsola", "transactionInterolate", "transactionIdolution", "transactIoli", "transactionIolation", "transactIsoration", "transactionEoration", "transactionInfooration", "transactionIolated", "transactionIolution", "transactIsolated", "transactIsolation", "transactionISolution", "transactionIdoli", "transactionISola", "transactionIolate", "transactionInfoolate", "transactionRestolate", "transactionEola", "transactIoration"], "cx": [" cxb", "mcxb", "lcxf", "cxc", "mcxc", "Cxc", "dcxf", "mcx", "Cx", "ccax", "ccxf", "dcxx", "dcx", "ctx", "cax", "lcxx", " ctx", "cxx", "lcx", "cxf", "Cxb", "Ctx", "dcax", "lcax", "ccx", " cxc", "mctx", "ccxx", "cxb"], "filasInsert": ["filASERT", "FilasERT", "FilaisSelect", "filasaSelect", "filabsUpdate", "filasImport", "filasPut", "ilarsUpload", "FilaisInsert", "filaisInsert", "filasaInsert", "filarsAdd", "ilasUpload", "filaUpdate", "FilabsInsert", "filansImport", "filaisSelect", "filisinsert", "filisAdd", "FilaisPut", "filASDelete", "FilasImport", "ilasInsert", "filAsinsert", "FilaisImport", "filASUpdate", "filasERT", "filaInsert", "filansPut", "FilasSelect", "filasUpload", "FilabsERT", "FilasPut", "ilasinsert", "filasSelect", "filansSelect", "ilarsInsert", "filasAdd", "filAsUpload", "ilasAdd", "filaDelete", "FilasUpdate", "FilasInsert", "filasUpdate", "FilasDelete", "filabsDelete", "filaisImport", "filaisPut", "ilarsinsert", "FilabsDelete", "filabsInsert", "filasDelete", "filarsinsert", "filasinsert", "filAsInsert", "filansInsert", "filAsAdd", "filaERT", "filasaImport", "filabsERT", "filASInsert", "filarsUpload", "filasaPut", "filisInsert", "FilabsUpdate", "filarsInsert", "filisUpload", "ilarsAdd"], "tipoConsulta": ["tipoConsulsada", "tipoconsultsa", "tipoConsultada", "tipoconsulta", "tipoConsULTa", "tipoConsulsao", "tipoConsultureia", "tipoconsultia", "tipoconsultsada", "tipoConsultsao", "tipoConsULTation", "tipoconsultada", "tipoConsulsation", "tipoConsULTas", "tipoConsultsas", "tipoConsultsada", "tipoConsultsation", "tipoconsultsation", "tipoConsulsa", "tipoConsolidao", "tipoConsultsia", "tipoConsolidada", "tipoconsultation", "tipoconsultas", "tipoConsultao", "tipoConsulturea", "tipoConsultia", "tipoconsultsao", "tipoConsultsa", "tipoConsultureao", "tipoConsulsas", "tipoConsolidas", "tipoconsultsas", "tipoConsultureas", "tipoconsultsia", "tipoconsultao", "tipoConsULTia", "tipoConsultation", "tipoConsultas", "tipoConsULTada", "tipoConsULTao", "tipoConsolida"], "execConsulta": ["execconsultso", "execConsulation", "execConsultsation", "execConULTa", "execConsultsas", "execconsultas", "execConsULTas", "execConsultsan", "execConsulsas", "execConultada", "execConulta", "execConULTada", "execConsulo", "execConsulsa", "execConsultas", "execConsULTan", "execconsulta", "execconsulto", "execConsulsada", "execConULTas", "execConULTan", "execConsULTation", "execConsultsa", "execConsultan", "execConsulsan", "execconsultsation", "execConsultsada", "execconsultation", "execConsultada", "execConultan", "execConsula", "execConultas", "execconsultsas", "execConsULTo", "execconsultsa", "execConsultso", "execConsultation", "execConsULTa", "execConsulas", "execConsULTada", "execConsulto"], "conexion": ["conexiona", " coneXor", "coexiton", "posexion", "conezION", "conexesional", "Colextion", "coneXone", "conexpone", "coexion", "conexione", " coneexion", "conextION", "poseexession", "conexpional", "conexif", "conequion", "coneXions", "conexent", " conexION", "conebif", "Colexions", "conexions", "coeexif", "coneXor", "conebion", "dosextions", "conexpor", " conexiona", "coneexent", "coneziton", "conexpession", "coneXent", " coneexional", "dosexiton", "conequiona", "dosextiton", "conexesions", "zonexions", "coneexione", "dosextION", "dosexION", "coneXION", "coeexion", "conexpION", "coneXional", "conexiton", "zonexpiao", "Colextions", "conexpione", "conenexions", "posexession", "conenexion", "zonexpions", "coeexiton", "conextiton", "conenexiton", " coneexent", "conexpions", "zonexiao", "coneXiao", " coneexiona", "zonexone", "coneexiao", " conexions", "dosexion", "coneexional", "zonexpion", "posexione", "zonexpone", "conexpiton", "coneexif", "conexone", "coexional", " coneXion", "conebional", "coneXion", "conequent", "conextions", "poseexions", "conenexession", " coneXions", "coexif", "poseexion", "ColexION", " conexent", " conexional", "poseexione", "conebiton", "Colextional", " conexor", "zonexion", "conenexional", "conequional", "conexor", "conexpion", "conextion", "coneexion", "conexpiao", "conezion", "coneexone", "conenexif", "conenexione", "conezions", "coneexions", "conexiao", "ColextION", "dosexions", "conexesion", "Colexional", "posexions", " coneXION", "conexesION", "conexional", "conextor", "coneXiona", "conexION", "Colexion", "dosextion", "conexession", "coneexession", "coneexiona", "coeexional", "conextional", "coneexiton"], "st": ["nt", "sl", "statement", "f", "s", "sc", "put", "pt", "m", "ct", "p", "se", "mt", "inst", "sth", "str", "ist", "ut", "bl", "ste", "ld", "pr", "sts", "b", "ust", "ST", "cr", "r", "l", "e", "fr", "sm", "d", "sp", "sh", "t", "tt", "h", "St", "cl", "pe", "sa", "c", "sr", "src", "sb", "ost", "nd", "est", "start", "rest"], "MySQL": [" mySQL", "OpenLL", " myLL", " mySSL", " MyLL", "MyLL", "MyConnection", "OpenConnection", "OpenSSL", "MySSL", " MyConnection", " myConnection", " MySSL", "OpenSQL"]}}
{"id1": "16308040", "id2": "16092702", "code1": "    public boolean update(String dbName, Query[] queries) throws ServiceException {\n        Connection con = null;\n        PreparedStatement pstmt = null;\n        int rows = 0;\n        try {\n            con = getDbConnection().getConnection(dbName);\n            con.setAutoCommit(false);\n            for (int i = 0; i < queries.length; i++) {\n                Query query = queries[i];\n                System.out.println(query.getSql());\n                pstmt = con.prepareStatement(query.getSql());\n                addParametersToQuery(query, pstmt);\n                rows += pstmt.executeUpdate();\n            }\n            con.commit();\n            return rows > 0;\n        } catch (DbException e) {\n            log.error(\"[DAOService::update]  \" + e.getMessage(), e);\n            log.error(\"[DAOService::update] Execute rollback \" + e.getMessage(), e);\n            try {\n                con.rollback();\n            } catch (SQLException e1) {\n                log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e);\n                throw new ServiceException(e.getMessage());\n            }\n            throw new ServiceException(e.getMessage());\n        } catch (SQLException e) {\n            log.error(\"[DAOService::update]  \" + e.getMessage(), e);\n            try {\n                con.rollback();\n            } catch (SQLException e1) {\n                log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e);\n                throw new ServiceException(e.getMessage());\n            }\n            throw new ServiceException(e.getMessage());\n        } finally {\n            closeConnection(con, pstmt, null);\n        }\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"update": ["save", "where", "database", "create", "method", "sync", "set", "add", "all", "updated", "Update", "run", "build", "db", "delete", "id", "ql", "result", "replace", "UPDATE", "sql", "execute", "insert", "write", "end", "apply"], "dbName": ["DbName", "DBname", "tablename", "DBFamily", "dbname", "dbFamily", " dbNames", "connectionRef", "databaseRef", "DbFamily", "dbNames", "tableName", "tableFamily", "databaseNames", " dbname", "connectionName", "DBName", "databasename", "databaseName", " dbRef", "connectionNames", "connectionname", "Dbname", "dbRef"], "queries": ["quotes", "quources", "shqs", " quicks", "questqs", " quqs", "sheries", "qicks", "qqs", "quos", "quicks", "shos", "questeries", "shands", "qotes", "quqs", "Queries", "qos", "votes", "vqs", "qands", "quands", "Quands", "qeries", "Quicks", "questands", "qources", "vands", "Quources", "questos", "Quotes", "veries", " quources", "Quqs"], "con": ["connection", "lock", "cur", "ver", "cn", "reg", "fac", "cos", "socket", "un", "session", "ca", "non", "syn", "pub", "en", "pc", "ann", "rc", "log", "pl", "fun", "conn", "cache", "user", "conf", "can", "cr", "win", "Con", "ran", "client", "row", "ci", "cc", "db", "connect", "uc", "CON", "cf", "cond", "h", "exec", "xc", "mon", "close", "cl", "pen", "conv", "core", "Conn", "c", "an", "fa", "com", "co", "cas", "crit", "coll", "cm", "mc", "cons", "cp", "ac", "col", "fc", "bc", "act"], "pstmt": ["pctdt", "pctm", " pppm", "Pstql", " pstmp", "pactlt", "pstnt", " pactmt", " pppmd", "pptmp", " pstmd", "Pstdt", "ppput", "pptmit", "Pstmit", "pastm", "pctmd", "pstrmt", "pctut", " pactlt", " pstut", "pstql", "Pstmp", "pssnt", "pctamp", "pptmt", "pstlt", "pstmit", "pastmt", "pctmt", "pqlt", " ppput", "Pstm", "pctql", "pastmd", "pstamp", "pqmt", "pqmp", "pstdt", "psthmit", " pactamp", "Pstmd", " pppmt", "pactmp", " pactmp", "Pctmt", "pprm", "pppmt", "Pstmt", "pprql", "pprnt", "pssm", "pstmd", "pstrm", "pssdt", "pssmt", "psthmd", "Pctql", "pctlt", "Pctmp", "psthmp", "pctmit", "pstrnt", "Pctmit", "pstmp", "pstut", "pactamp", " pstlt", "pctmp", "pastut", "pactmt", "pqamp", "Pctdt", "pppm", "pprmt", " pstamp", " pstm", "Pstnt", "psthmt", "pptmd", "Pctnt", "pppmd", "pstm", "pstrdt", "Pctm", "Pctmd", "pctnt"], "rows": ["heads", "pages", "values", "ues", "blocks", "times", "issues", "s", "ins", "results", "ries", "acks", "ips", "ures", "gets", "reads", "roots", "files", "flows", "rs", "ends", "posts", "runs", "lines", "orders", "row", "ks", "tracks", "count", "ails", "ings", "loads", "objects", "odes", "errors", "checks", "fields", "keys", "locks", "users", "projects", "tests", "bugs", "ches", "length", "rors", "rown", "ows"], "i": ["x", "f", "y", "si", "ti", "ri", "q", "type", "slice", "m", "p", "j", "info", "pi", "k", "ori", "hi", "bi", "I", "u", "b", "di", "multi", "part", "qi", "l", "e", "o", "ini", "ci", "z", "h", "xi", "v", "oi", "ui", "mi", "yi", "li", "n", "uri", "ii", "io", "c", "in", "ni", "id", "index", "ai", "gi", "ip"], "query": ["feature", "connection", "statement", "f", "name", "question", "scan", "q", "error", "database", "sc", "command", "qq", "m", "table", "sync", "comment", "rule", "commit", "qu", "model", "check", "user", "iq", "qi", "bug", "engine", "e", "key", "sq", "row", "service", "quer", "eight", "entry", "call", "child", "parse", "condition", "request", "block", "exec", "ctx", "parent", "general", "dq", " Query", "server", "unit", "code", "script", "search", "module", "ic", "action", "ql", "result", "eries", "sql", "select", "Query"]}}
{"id1": "3958807", "id2": "822452", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadFbinaryContent", "loadBbinaryStream", "loadBInputStream", "loadBatchContent", "loadFbinaryFile", "loadBinaryContent", "loadBinaryInput", "loadBatchStream", "loadBatchInput", "loadBatchFile", "loadFinaryInput", "loadBbinaryFile", "loadBbinaryInput", "loadBInputContent", "loadFinaryStream", "loadFbinaryStream", "loadBinaryFile", "loadFinaryFile", "loadFbinaryInput", "loadBInputFile", "loadBInputInput", "loadBbinaryContent", "loadFinaryContent"], "streamName": ["fileType", " streamKey", "streamPath", "streamKey", "fileName", " streamPath", "resourcePath", "fileKey", "channelName", "streamType", "Streamname", "channelPath", "filePath", "filename", "streamname", "channelKey", "resourceName", "StreamName", "StreamPath", " streamType", "resourcename", "resourceType", " streamname"], "streamToLoad": ["streamtoUpload", "objectTOLoad", " streamtoAdd", "streamWillRead", "streamTOLoad", "channelToAdd", "objectTOUpload", "objectToUse", " streamToRead", "streamToRead", "streamtoUse", "streamTOload", "objectTOUse", "streamTOAdd", "channelToLoad", " streamToAdd", "streamWithRead", " streamToUse", "streamWithLoad", "streamToUse", "channelToload", "objectToLoad", "streamTOUse", "streamtoAdd", "streamWillUpload", "channeltoLoad", "streamToAdd", "objectTORead", "streamWithAdd", "streamToload", "channeltoAdd", " streamtoUse", "streamtoRead", "streamtoload", " streamtoRead", "objectToRead", "streamtoLoad", "streamWillLoad", "streamWillAdd", "streamWithUse", "streamTORead", "channeltoload", " streamtoLoad", "streamTOUpload", "streamToUpload", "streamWillUse", "objectToUpload"], "sz": ["imsze", "szip", "psz", " siz", "ssze", " szip", "szes", "ssiz", "szi", "psze", "imszes", "imsz", "wszi", " szi", "pszi", "pszip", "siz", "wsz", "wszip", "ssz", "sze", "wsze", " szes", "sszes", " sze", "imsiz"], "req": ["rh", "cb", "Resp", "f", "q", "respond", "download", "proc", "sem", "rec", "require", "conn", "ok", "r", "err", "fr", "client", "rr", "requ", "ctx", "request", "response", "exec", "rw", "Request", "http", "src", "rss", "res", "input", "def", "wx", "report", "qt", "ref", "inv", "progress", "serv", "obj", "rx", "pkg"], "resp": ["rh", "esp", "df", "Resp", "respond", "remote", "rev", "body", "download", "wp", "par", "Response", "proc", "rec", "bb", "prev", "conn", "page", "jp", "output", "cook", "zip", "rem", "err", "e", "client", "circ", "reply", "ret", "comm", "cmp", "sp", "ctx", "rup", "api", "request", "response", "exec", "server", "http", "wb", "rep", "rss", "res", "fp", "ref", "report", "wx", "re", "rel", "html", "serv", "obj"], "out": ["bin", "data", "pool", "s", "boot", "auto", "p", "outs", "gz", "os", "binary", "base", "log", "copy", "conn", "b", "cache", "output", "again", "op", "img", "ops", "zip", "fn", "o", "OUT", "buffer", "i", "ws", "response", "exec", "object", "default", "null", "io", "in", "co", "aos", "res", "Out", "serv", "buf", "tmp"], "bos": ["bott", "lol", "bin", "osa", "fits", "las", "bes", "oos", "lo", "bs", "boot", "os", "bot", "bh", "obos", "bb", "bi", "rob", "ko", "obs", "biz", "cro", "ubis", "abi", "pins", "mis", "bas", "zb", "bis", "obo", "oops", "bps", "osi", "aos", "bo", "ros", "bro", "flo", "los", "ios", "zo", "zos", "obb", "bc", "ob", "bare"]}}
{"id1": "810342", "id2": "6403868", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doversioncheck", "doChangeCheck", "doVersionUpdate", " doVersionUpdate", " doversionScan", " doVersionScan", "doChangecheck", " doVersioncheck", "doFeaturecheck", "doFeatureUpdate", "doversionUpdate", "doChangeUpdate", " doversioncheck", "doFeatureScan", "doFeatureCheck", "doVersionScan", "doChangeScan", " doversionCheck", "doversionScan", "doVersioncheck", "doversionCheck", " doversionUpdate"], "view": ["lock", "self", "container", "edit", "pool", "div", "screen", "see", "review", "update", "out", "html", "gu", "session", "el", "page", "cache", "query", "display", "client", "row", "port", "value", "ui", "group", "up", "fail", "use", "widget", "View", "im", "vis", "model", "vol", "check", "by", "e", "cell", "this", "show", "style", "image", "form", "config", "http", "VIEW", "full", "layout", "manager", "head", "body", "change", "event", "base", "box", "video", "user", "can", "comment", "list", "block", "object", "v", "server", "index", "views", "sel", "input", "window", "ou", "ve", "link"], "url": ["ul", "open", "sl", "f", "loc", "name", "socket", "email", "gl", "stream", "web", "download", "log", "base", "ssl", "bb", "ls", "ll", "blog", "b", "loader", "zip", "l", "bug", "fr", "address", "Url", "buffer", "URL", "source", "image", "builder", "hub", "path", "server", "uri", "null", "browser", "http", "file", "impl", "id", "resource", "www", "host", "link", "location", "length", "rel", "string", "ob"], "in": ["reader", "isin", "sin", "login", "data", "doc", "socket", "s", "ins", "pin", "m", "stream", "cin", "In", "binary", "is", "b", "inner", "again", "rin", "win", "din", "IN", "err", "ini", "buffer", "source", "init", "inc", "nin", "bis", "inn", "file", "as", "lin", "resource", "input", "out", "con", "ac"], "bin": ["reader", "border", "lock", "sin", "login", "socket", "pin", "body", "cin", "bn", "vin", "binary", "bot", "is", "bb", "bi", "b", "loader", "inner", "win", "din", "IN", "ruby", "ini", "abi", "buffer", "lib", "run", "init", "spin", "arin", "ban", "browser", "inn", "oin", "file", "lin", "fin", "input", "out", "record", "con", "gin", "nb"], "line": ["job", "le", "sl", "data", "name", "type", "pin", "range", "el", "ge", "one", "str", "definition", "letter", "log", "base", "lc", "inline", "page", "b", "text", "part", "user", "zip", "l", "val", "e", "cell", "lines", "lf", "key", "ine", "comment", "row", "entry", "block", "parse", "Line", "object", "cl", "code", "nl", "unit", "pe", "jo", "file", "up", "id", "LINE", "word", "lin", "out", "link", "string", "write", "ip", "end", "look"], "version": ["feature", "ver", "name", "support", "type", "dev", "python", "versions", "install", "VERSION", "latest", "download", "release", "plugin", "position", "model", "format", "video", "user", "vert", "section", "bug", "patch", "vision", "pull", "secret", "image", "value", "project", "driver", "v", "update", "server", "unit", "date", "author", "null", "code", "Version", "id", "beta", "cover", "host", "string", "option", "device", "license"], "build": ["lock", "job", "ver", "tag", "get", "mount", "Build", "hold", "how", "building", "boot", "install", "info", "clean", "load", "lease", "release", "log", "add", "built", "bug", "work", "uild", "patch", "pull", "row", "show", "style", "image", "block", "run", "feed", "builder", "update", "unit", "make", "post", "http", "valid", "follow", "help", "home", "print", "link", "rel", "use"]}}
{"id1": "23296117", "id2": "21656668", "code1": "    public static void extractNativeLib(String sysName, String name, boolean load, boolean warning) throws IOException {\n        String fullname = System.mapLibraryName(name);\n        String path = \"native/\" + sysName + \"/\" + fullname;\n        URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n        if (url == null) {\n            if (!warning) {\n                logger.log(Level.WARNING, \"Cannot locate native library: {0}/{1}\", new String[] { sysName, fullname });\n            }\n            return;\n        }\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        File targetFile = new File(getExtractionDir(), fullname);\n        OutputStream out = null;\n        try {\n            if (targetFile.exists()) {\n                long targetLastModified = targetFile.lastModified();\n                long sourceLastModified = conn.getLastModified();\n                if (targetLastModified + 1000 > sourceLastModified) {\n                    logger.log(Level.FINE, \"Not copying library {0}. Latest already extracted.\", fullname);\n                    return;\n                }\n            }\n            out = new FileOutputStream(targetFile);\n            int len;\n            while ((len = in.read(buf)) > 0) {\n                out.write(buf, 0, len);\n            }\n            in.close();\n            in = null;\n            out.close();\n            out = null;\n            targetFile.setLastModified(conn.getLastModified());\n        } catch (FileNotFoundException ex) {\n            if (ex.getMessage().contains(\"used by another process\")) {\n                return;\n            }\n            throw ex;\n        } finally {\n            if (load) {\n                System.load(targetFile.getAbsolutePath());\n            }\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n        logger.log(Level.FINE, \"Copied {0} to {1}\", new Object[] { fullname, targetFile });\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"extractNativeLib": ["extractnativeLib", "extractNativelib", "extractednativeLib", "extractLibraryLib", "extractRemoteLib", "extractedNativeLib", "extractLibraryLibrary", "extractnativelib", "extractednativelib", "extractnativeLibrary", "extractednativeLibrary", "extractRemoteLibrary", "extractedNativeLibrary", "extractedNativelib", "extractNativeLibrary", "extractLibrarylib", "extractRemotelib"], "sysName": [" sysPath", "libPath", "sysPath", "systemTitle", "systemPath", " sysDir", "libname", "sysTitle", "ysPath", "ysname", "sysFull", "SysFull", " sysname", "Sysname", "SysPath", "libName", "systemname", "systemFull", "libTitle", "SysName", "ysName", "sysname", "systemName", "sysDir", "systemDir", "SysDir", " sysFull", " sysTitle"], "name": ["connection", "data", "type", "na", "nam", "label", "base", "plugin", "part", "cache", "loader", "size", "root", "key", "source", "filename", "system", "no", "nice", "Name", "n", "number", "default", "file", "title", "word", "prefix", "id", "resource", "named", "nm", "string", "NAME", "username"], "load": ["lock", "save", "open", "loaded", "start", "get", "force", "play", "create", " reload", "sync", "ck", "download", "dump", "launch", "set", "rc", "add", "copy", "require", "check", "LOAD", "loader", "loading", "cache", "include", "callback", "l", "zip", "pull", "test", "call", "comment", "oad", "parse", "cli", "pack", "init", "loads", "close", "cl", "delete", "read", "null", "Load", "hack", "fail", "skip", "link", "leaf", "progress", "push", "write", "use", "wait", "remove"], "warning": ["Warning", "ew", "error", "alert", "ww", "fw", "auto", "WARN", "web", "only", "warn", "wild", "misc", "acl", "loader", "loading", "notice", "blocking", "success", "watch", "random", "lang", "external", "comment", " warnings", "war", "wa", "breaking", "ws", "aw", "weak", "message", "WARNING", "resource", "initial", "fp", "leaf", "generation", " warn"], "fullname": ["realpath", "fulbase", " fullnode", "fullbase", "realName", "fullNAME", "flatpath", "fullpath", " fullnamed", " fullbase", "fulName", "Fullname", "FullNAME", " fullName", "fullybase", "flatName", "fullyName", " fullkey", "fulkey", " fullNAME", "fullykey", "fullypath", "flatnamed", "fullnode", "Fullnode", "realnamed", "Fullpath", " fullnumber", "fulname", "realname", "fullName", "realNAME", " fullpath", "fulpath", "Fullnumber", "FullName", "fullynumber", "Fullnamed", "fullyname", "fullnumber", "fullnamed", "flatname", "fulnode", "fullkey"], "path": ["full", "data", "type", "method", "filter", "enc", "str", "base", "log", "part", "loader", "text", "cache", "work", "root", "key", "pointer", "image", "api", "parent", "object", "filename", "pattern", "context", "config", "uri", "code", "route", "file", "id", "PATH", "ath", "Path", "resource", "link", "ref", "location", "string"], "url": ["connection", "sl", "f", "loc", "org", "fl", "channel", "ur", "download", "log", "base", "ll", "ssl", "bb", "blog", "loader", "l", "fr", "address", "Url", "lib", "URL", "source", "image", "service", "api", "lr", "config", "uri", "server", "http", "file", "impl", "src", "resource", "www", "coll", "bel", "link", "location", "rl", "string", "serv", "ob", "il"], "conn": ["connection", "nt", "open", "lock", "cb", "loc", "cn", "reg", "org", "socket", "nc", "channel", "session", "ct", "sync", "dn", "enc", "ann", "rc", "log", "ssl", "conf", "l", "err", "client", "cmp", "cli", "init", "ctx", "connect", "ch", "api", "config", "n", "conv", "rt", "io", "net", "c", "Conn", "http", "coll", "con", "fp", "cp", "Connection", "serv", "ob", "resp", "act"], "in": ["reader", "bin", "connection", "lock", "login", "f", "data", "socket", "s", "ins", "pin", "sync", "cin", "min", "In", "ie", "ssl", "inside", "kin", "b", "inner", "again", "part", "cache", "win", "din", "r", "pre", "IN", "err", "client", "pull", "ini", "this", "i", "source", "init", "image", "inc", "child", "nin", "request", "exec", "like", "config", "n", "inn", "c", "file", "up", "id", "index", "a", "src", "ic", "on", "lin", "input", "con", "resource", "ac", "gin", "serv"], "targetFile": [" targetDirectory", "argetClass", "hostDir", "sourceDir", "resourceDir", "hostStream", " targetFolder", "TargetDir", "argetFiles", "targetDir", "sourceDirectory", " targetPath", " targetfile", "targetStream", "sourceFiles", "TargetDirectory", "targetfile", "resourcefile", "TargetStream", " targetLine", "argetfile", "TargetClass", "argetFile", "hostFile", "targetPath", " targetStream", "Targetfile", "sourcePath", "targetClass", "hostfile", "targetFiles", " targetDir", "sourcefile", " targetClass", "TargetPath", "argetPath", "TargetFile", "targetDirectory", "sourceLine", "targetLine", "resourceLine", "sourceFolder", "resourceFile", "TargetFiles", "sourceFile", "argetFolder", "resourceDirectory", " targetFiles", "targetFolder"], "out": ["connection", "bin", "lock", "app", "ext", "login", "doc", "socket", "at", "error", "sync", "ex", "one", "plain", "log", "page", "cache", "again", "output", "inner", "w", "part", "user", "cmd", "writer", "line", "err", "o", "client", "key", "OUT", "temp", "off", "call", "comment", "source", "block", "init", "image", "inc", "exec", "outer", "parent", "sum", "default", "n", "group", "null", "server", "io", "net", "post", "file", "up", "prefix", "co", "result", "resource", "on", "target", "token", "exp", "Out", "obj", "option", "buf"], "targetLastModified": ["targetFirstMODed", "targetFirstModed", "targetLastModed", "targetLastPedIFIED", "targetFirstMinified", "targetLastModocked", "targetFirstMODified", "targetFirstMinIFIED", "targetLastPedamed", "targetLastMODamed", "targetLastMODified", "targetLastMODIFIED", "targetFirstModamed", "targetLastMinIFIED", "targetLastModamed", "targetLastMified", "targetLastModIFIED", "targetFirstModIFIED", "targetLastSemocked", "targetLastMocked", "targetFirstMODification", "targetFirstMined", "targetLastMODocked", "targetLastSemified", "targetFirstModification", "targetLastMed", "targetFirstModocked", "targetLastMification", "targetLastSemification", "targetLastPeded", "targetLastMinified", "targetFirstModified", "targetLastMinamed", "targetLastPedified", "targetLastMODed", "targetFirstMinamed", "targetFirstMODocked", "targetLastModification", "targetLastSemed", "targetLastMined", "targetLastMODification"], "sourceLastModified": ["sourceFirstMODified", "sourceLastImated", "sourceLastmoded", "sourceLastmodIFIED", "sourceFirstMODated", "sourceFirstMODIFIED", "sourceLastMODed", "sourceLastModed", "sourceLastImed", "sourceLastMated", "sourceLastImified", "sourceFirstMODed", "sourceLastMODated", "sourceFirstModated", "sourceFirstMODification", "sourceFirstModIFIED", "sourceFirstModification", "sourceLastMODified", "sourceLastModated", "sourceLastMODIFIED", "sourceLastMed", "sourceLastModIFIED", "sourceLastMined", "sourceLastModification", "sourceLastImification", "sourceLastmodified", "sourceLastMinIFIED", "sourceLastMification", "sourceLastMified", "sourceFirstModed", "sourceLastMinified", "sourceFirstModified", "sourceLastMODification"], "len": ["nt", "bin", "le", "sl", "iter", "f", "data", "fl", "lim", "el", "body", "min", "en", "str", "lc", "part", "size", "num", "lon", "l", "line", "val", "err", "lf", "count", "z", "limit", "no", "cl", "n", "li", "net", "id", "pos", "lin", "fin", "Len", "length", "ln", "ler", "end"]}}
{"id1": "692738", "id2": "20275821", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["connection", "sl", "f", "loc", "name", "ur", "el", "xml", "base", "ll", "ssl", "html", "loader", "href", "l", "fr", "address", "Url", "buffer", "URL", "source", "service", "image", "feed", "path", "filename", "lr", "config", "server", "uri", "null", "io", "http", "file", "id", "resource", "www", "bel", "host", "link", "ref", "location", "rl", "string", "ob"], "in": ["reader", "bin", "isin", "login", "f", "data", "socket", "ins", "pin", "m", "ex", "cms", "min", "In", "xml", "is", "ssl", "inside", "part", "conn", "again", "inner", "rin", "r", "din", "val", "IN", "err", "ini", "this", "i", "source", "init", "image", "inc", "nin", "or", "config", "n", "io", "inn", "c", "file", "as", "id", "impl", "a", "token", "input", "out", "con", "resource", "gin", "serv"]}}
{"id1": "9109613", "id2": "7468827", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"fileCopy": [" filecopy", "FileTransfer", " fileTransfer", "fileTransfer", "foldercopy", "FileCopy", "folderCopy", "FileUpload", "folderTransfer", "filecopy", " fileUpload", "folderUpload", "fileUpload", "Filecopy"], "from_name": ["fromqName", " from_key", "from_key", " from_alias", "from_size", " from_word", "fromTheName", "from_image", " from__Name", "from__name", "fromTheword", "fromFullalias", " from_no", "from_filename", " from_size", "fromameName", "from_time", "from_address", "fromqfilename", "fromqpath", " from_space", " from_address", "from_path", "from__Name", " from_image", " from_Name", "from__alias", "fromameno", "from__address", "fromFulladdress", "from_no", " from__name", "fromThename", " from_path", "fromqname", "from_word", "fromamename", "from_alias", "from_resource", " from_time", "from_space", " from__address", "fromThespace", "from_Name", "fromFullname", " from__alias", " from_resource", "fromFullName", " from_filename", "fromametime"], "to_name": ["to_key", "to_path", "To_Name", " to_file", "to_file", "tokName", "to_Name", "to_common", "tokcommon", "from_Name", "from_path", "To_name", "to_names", " to_key", "tokname", "from_names", "To_common"], "fromFile": ["toFiles", "fromLine", "oneDir", "asFiles", "autoFile", "asFile", "FromFolder", "ofFolder", "sourcePage", " fromPackage", "FromFile", " fromPage", "oneFunction", "autoFolder", "connectionFolder", "sourceDirectory", "connectionPackage", " fromfile", " fromModel", "Fromfile", " fromFolder", " fromLibrary", " fromDir", "tofile", "offile", "FromLine", "connectionfile", "fromfile", " fromFunction", "fromFolder", "FromFiles", " fromLine", "onePage", "FromDirectory", " fromFactory", "ofFile", " fromFiles", "fromPackage", "fromDirectory", "FromPage", "autoPage", "FromDir", "oneModel", "asFactory", "asfile", "toFunction", "fromDir", " fromDirectory", "fromLibrary", "ofPackage", "fromPage", "FromFunction", "FromModel", "fromFiles", "FromLibrary", "onefile", "toFactory", "connectionFile", "fromModel", "sourceFile", "oneFolder", "autofile", "sourceLibrary", "oneFile", "fromFunction", "toLine", "fromFactory"], "toFile": ["toFiles", "toPage", " toTable", " tofile", " toPage", "afile", "aDir", " toSourceFile", "ofFile", "fromDirectory", "baseDir", "tempFolder", "aFiles", "coFunction", "TODir", "coFile", "Tofile", "ToSourceFile", "fromLine", "targetFolder", "ToFactory", "targetFile", "toLibrary", "baseFile", "ToFiles", "targetDir", "ToPlace", "toTable", "fromfile", "ToPage", "targetPlace", "targetFactory", "ofDir", "fromDir", "toDir", "TOPage", "sofile", "fromPage", "nofile", "soFile", "coDirectory", "ToDirectory", "soLibrary", "tempFile", "ToFile", "toDirectory", "basefile", "toFolder", "tempFactory", "baseTable", "ToLine", "targetfile", "soPage", "ToFunction", "TOPlace", "toFunction", "noFile", "aFile", "noPage", " toFunction", "fromFiles", "cofile", "ToDir", "toLine", "noLibrary", " toFolder", "targetSourceFile", "toSourceFile", "toPlace", "tofile", "offile", "tempfile", "TOFile", "targetPage", "ofTable", " toFiles", "ToLibrary", " toDir", "toFactory", " toLine", " toDirectory", " toFactory"], "parent": ["current", "data", "name", "pool", "type", "par", "div", "class", "section", "and", "shape", "source", "path", "url", "null", "owner", "search", "resource", "out", "directory", "exp", "option", "Parent", "point", "session", "g", "rule", "lc", "page", "term", "content", "key", "client", "address", "port", "or", "id", "home", "region", "loc", "complete", "remote", "p", "paren", "parents", "part", "root", "line", "patch", "test", "inc", "api", "large", "guard", "pa", "valid", "location", "col", "ip", "full", "connection", "manager", "master", "pt", "any", "pr", "user", "child", "server", "pe", "file", "ac", "string"], "dir": ["lock", "cur", "iter", "director", "f", "loc", "doc", "name", "manager", "ver", "keep", "container", "wd", "dev", "dec", "dep", "div", "per", "rec", "class", "di", "die", "Dir", "r", "root", "dist", "dr", "dc", "d", "lib", "cat", "block", "build", "db", "inc", "or", "dis", "path", "mod", "attr", "url", "group", "ir", "rel", "folder", "file", "DIR", "fd", "coll", "out", "def", "home", "directory", "exp", "col", "dict"], "from": ["connection", "get", "name", "self", "channel", "range", "From", "stream", "auto", "low", "se", "clean", "one", "without", "per", "base", "add", "vol", "component", "conn", "with", "user", "part", "can", "old", "left", "by", "cr", "ra", "e", "fr", "o", "normal", "client", "query", "bean", "this", "source", "parse", "ch", "or", "api", "wh", "hand", "form", "url", "view", "empty", "io", "c", "in", "file", "ce", "module", "po", "flo", "out", "ou", "link", "cm", "con", "so", "de", "who", "start", "when"], "to": ["be", "connection", "office", "su", "ver", "name", "two", "eto", "TO", "type", "auto", "sync", "tom", "pi", "one", "tto", "not", "To", "top", "base", "copy", "fat", "with", "b", "cache", "output", "op", "size", "page", "by", "until", "too", "again", "plus", "o", "see", "go", "proxy", "source", "db", "port", "api", "or", "object", "will", "no", "store", "io", "http", "file", "co", "po", "token", "target", "out", "on", "via", "flo", "about", "so", "fb"], "buffer": ["reader", "border", "uffer", "iter", "data", "texture", "channel", "vector", "batch", "reference", "table", "seed", "layer", "buff", "Buffer", "variable", "binary", "position", "page", "cache", "bytes", "shape", "address", "flush", "row", "padding", "comment", "block", "value", "feed", "character", "default", "document", "read", "server", "number", "transfer", "null", "memory", "duration", "message", "queue", "header", "resource", "result", "total", "length", "available", "string", "device", "buf"], "bytes_read": ["bytesESSread", "bytesavavailable", "bytes___READ", "bytesavview", "bytes_written", "bytes___available", "bytesESSput", "classes_available", "lines_received", "bytes___view", "classes_read", "classesavread", "bytesavREAD", "bytes_view", "lines_written", "bytes_received", "bytes_available", "classesavview", "bytesaywritten", "classesavavailable", "bytesayput", " bytes_written", "bytes_load", "bytesESSwritten", "classesavREAD", "classes_view", "lines_read", "bytes___read", "bytesayreceived", "bytes_put", "bytes_READ", "classes_READ", "bytesayread", "bytesESSreceived", "bytesavread", " bytes_load", "bytes_write", " bytes_write", "lines_put"]}}
{"id1": "659316", "id2": "18238468", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "label": 1, "substitutes": {"argv": ["Argver", " argl", "argumentve", "argsv", "argb", "argumentver", "paramb", "interv", "interl", "argve", "argl", "argsl", "argsc", "Argl", "interc", " argve", " argf", "argumentc", "argf", " argc", "argc", "Argf", "argver", "Argve", "argV", " argV", " argver", "paramV", "paraml", "Argb", "Argv", " argb", "paramv", "interV", "Argc", "argumentv", "ArgV", "argsf"], "sources": ["statigs", "sides", "statores", "issides", "sresources", "sences", "issources", "sesores", "sesences", "sesigs", "fources", "issource", "fource", "fresources", " sors", "tresources", "issors", "psides", "fors", "tource", "statences", "tources", "psresources", "vesources", "psource", "vesigs", "tides", "sigs", "statources", "fides", "psources", "sesources", "vesores", "sores", "sors", " sides", "vesences"], "targets": [" tokencies", "tanges", "tanget", " tokets", "Targens", "tagnets", "targends", "tokens", "taxlets", "tigens", "targens", "Tangets", " taxets", "tagnencies", " toket", "targlets", "tampets", "Targlets", "tangencies", " targends", "tokets", " targens", "taxets", "tiges", "tangets", "targels", "Tangels", "tangels", "targencies", "tigets", "tagnens", " targencies", "toket", "Tanglets", "tampens", "taxes", "tanglets", "tagnet", " taxes", "tokencies", " taxends", "Targels", "tamplets", "tigends", "tangens", "taxends", " tokens", "tangends", "Targets", "taxens", "Tangens", "targes", " taxens", " targes", "taxels", "tampels"], "srclen": ["rsclEN", "srCLoen", "srcelen", "srClen", "srselens", "rscln", "rsceln", " srclength", "rscelens", "srClEN", " srpleno", " srcleno", "srcloen", "rsclen", " srploen", "srCLength", "srcln", "srploen", "rscelen", "srctength", " srcloen", "srCln", "srplength", "srcten", "srclens", "srplen", "rscelEN", "srClens", "srseln", "srselEN", "srCLen", "srctoen", "srclength", "srcleno", "srselen", " srplen", "srpleno", "srceln", "srcteno", "srclEN", " srplength", "srCLeno", "srcelens", "rsclens", "srcelEN"], "source": ["reader", "sl", "ources", "current", "start", "get", "force", "self", "channel", "s", "remote", "slice", "create", "type", "stream", "secure", "seed", "event", "rc", "ssl", "ource", "copy", "component", "model", "cache", "size", "single", "SOURCE", "client", "dest", "service", "proxy", "image", "driver", "path", "parent", "url", "config", "view", "uri", "unit", "in", "scope", "id", "src", "resource", "out", "Source", "input", "link", "use"], "tgt": [" tkt", "lgz", "tnt", "tgs", "tch", "Tgs", "Tch", "lgt", " tgz", "tbuster", "tkt", "hgt", "hret", "bitarg", "Targ", "bitgt", "Ticket", "rgt", "lnt", "tgh", "tgz", "bitgh", " tgs", " targ", "Tkt", "larg", "hnt", " tch", "tret", " tnt", "hgz", "rkt", "targ", "biticket", " ticket", "ptgt", "ticket", "ptarg", "Tgh", "ptbuster", "rch", "ptnt", "rgs", " tgh", "lbuster", " tret", " tbuster", "lret", "Tgt"], "target": ["nt", "connection", "open", "director", "current", "point", "force", "it", "channel", "mount", "master", "arget", "session", "manager", "remote", "archive", "handler", "to", "download", "event", "base", "match", "component", "plugin", "conn", "output", "goal", "member", "client", "dest", "external", "service", "image", "port", "child", "driver", "path", "parent", "project", "cross", "next", "url", "object", "tail", "view", "unit", "route", "null", "io", "core", "Target", "result", "out", "resource", "slave", "rel"], "deletes": ["disires", " deises", "delises", "delleted", "desists", "kesises", " degrades", "deles", "delouts", "deouts", "Deletes", " dedates", "exdates", "deires", "delletes", "downlete", "disists", "deists", " delete", "kesleted", "desletes", "disletes", "downgrades", " deouts", "downletes", "degrades", "Deires", "delete", "desires", " deleted", "deises", "kesouts", "disles", "exletes", "dedates", "downdates", "kesletes", "exlete", "deleted", "desles", "Deists", "Deles", "exgrades"], "del": ["ul", "lock", "data", "get", "name", "fl", "dl", "down", "el", "change", "install", "syn", "dec", "se", "clean", "download", "local", "bl", "base", "ll", "Del", "add", "copy", "model", " delete", "err", "pull", "d", "delete", "update", "nl", " Del", "null", "neg", "file", "delay", "id", "up", "sel", "coll", "Delete", "fail", "diff", "dir", "def", "skip", "rel", "de", "remove"]}}
{"id1": "21488868", "id2": "23452437", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToStream", "encodeFiletoStream", "encodeString2Stream", "encodeFiletoFile", "encodeStringToString", "encodeString2String", "encodeFileToStream", "encodeFileToString", "encodeFileFromFiles", "encodeFile2Files", "encodeStringToFiles", "encodeFile2String", "encodeStringToFile", "encodeFileFromString", "encodeString2Files", "encodeFileFromFile", "encodeFiletoString", "encodeFile2Stream", "encodeFileToFiles", "encodeFiletoFiles", "encodeString2File", "encodeFile2File", "encodeFileFromStream"], "infile": ["inputFile", "inputfilename", "Infiles", "outfilename", "infilename", "inputfile", "outFile", "inputfiles", "outfiles", "infp", "inputfp", "outfp", " infilename", " infp", " infiles", "infiles", "Infilename", "InFile", "Infile", "inFile"], "outfile": ["newFile", "outputfilename", "Outfile", "outfilename", "infilename", "outFile", "Outfolder", " outfp", " outfilename", "infp", "newfolder", "outname", "outfp", " outname", " outFile", "Outname", " outfolder", "outputfp", "newname", "newfile", "outputfile", "infolder", "OutFile", "outputfolder", "outfolder"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "vin", "base", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "image", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "copy", "conn", "cache", "again", "output", "inner", "writer", "work", "line", "err", "off", "client", "o", "OUT", "lib", "source", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "post", "io", "net", "file", "up", "co", "on", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "reader", "border", "uffer", "iter", "data", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "len", "queue", "input", "result", "length", "write", "fb", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "close", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "input", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "modified", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "respons", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "4223002", "id2": "19206412", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getPasswordMD5": ["getPasswordMAC256", "getPasswordSHA5", "getPasswordMAC5", "getPasswordMD512", "getPasswordMD256", "getpasswordMD512", "getPasswordMac1", "getPasswordMAC1", "getPasswordSHA512", "getPasswordMac512", "getpasswordMD1", "getPasswordMac256", "getpasswordSHA1", "getpasswordMD256", "getPasswordSHA256", "getPasswordMAC512", "getPasswordMac5", "getPasswordSHA1", "getpasswordSHA256", "getpasswordMD5", "getpasswordSHA5", "getpasswordSHA512", "getPasswordMD1"], "algorithm": ["Alest", " algorith", "calgorithm", "algebra", " alrator", "aggo", "Alignment", "Algo", "fgorithm", "Algorithm", "Alrator", "omalgo", "calgebra", "alm", " alm", "fgo", "Algorith", "alest", "fgebra", "gegorithm", "agrator", "omalgorithm", "geest", " alignment", "fgorith", "alrator", "calgorith", "alger", "algo", "omalphabet", " algo", "aggorithm", "Alger", "gem", "Alphabet", " alphabet", "Alm", "alignment", "agignment", "omalgorith", "Algebra", "alphabet", "algorith", "geger", "calgo", " alger", " alest"], "messageDigest": ["messagedigester", " messagedigEST", "messageModString", "phrasedigested", "phraseDigest", " messagedigest", "phrasedigest", "messageDigested", "phraseDigester", "MessageModested", "messagedigested", "messageDigester", "MessageModester", "messageModEST", "MessageModEST", "messageMDEST", "phrasedigester", "messageMDester", "messageDigString", "MessageDigest", "phraseDigested", "MessageDigested", "messagedigest", "MessageDigEST", "messageDEST", "messagedigString", " messageDigEST", "messageModester", "phraseDigEST", "messageDested", " messageDigString", "messageModested", "phrasedigEST", "messageMDString", " messagedigString", "MessageModest", "messageDigEST", "messageMDest", " messagedigester", "messageModest", " messageDigester", "MessageDigester", "messageDester", "messagedigEST", "messageDest"], "hexString": ["checkString", "hashStr", "hexstring", "hexArray", "hexLine", " hexArray", " hexStream", " hexBuffer", "shortstring", "textStream", "textArray", "checkStr", "hexBuffer", "shortArray", "hashFunction", "byteStream", "hexStream", "hashString", "byteArray", "checkFunction", "hexFunction", "textLine", " hexStr", "hashBuffer", "textBuffer", "byteString", "textString", " hexFunction", "hexStr", "byteLine", " hexstring", "shortString", "textstring", " hexLine", "checkBuffer", "shortBuffer"], "i": ["x", "volume", "f", "si", "ti", "ri", "s", "type", "slice", "m", "p", "j", "info", "pi", "ix", "hi", "I", "bi", "u", "b", "di", "multi", "l", "r", "fi", "e", "o", "key", "abi", "d", "ci", "t", "h", "xi", "v", "oi", "ui", "mi", "n", "li", "uri", "zi", "ii", "io", "c", "in", "id", "index", "a", "chi", "mu", "ai", "gi", "phi", "end"]}}
{"id1": "7044153", "id2": "12883117", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    public PhoneSetImpl(URL url) throws IOException {\n        BufferedReader reader;\n        String line;\n        phonesetMap = new HashMap();\n        reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        line = reader.readLine();\n        lineCount++;\n        while (line != null) {\n            if (!line.startsWith(\"***\")) {\n                parseAndAdd(line);\n            }\n            line = reader.readLine();\n        }\n        reader.close();\n    }\n", "label": 1, "substitutes": {"sendExceptionToServer": ["sendExceptionWithserver", "sendExceptiontoHost", "sendExceptiontoServer", "sendExceptionWithServer", "sendErrorToserver", "sendExceptionToService", "sendExceptionAsHost", "sendExceptionAsserver", "sendErrorToService", "sendErrortoHost", "sendExceptionAsService", "sendExceptionToserver", "sendExceptionWithHost", "sendErrortoService", "sendErrortoserver", "sendErrorToServer", "sendErrorToHost", "sendExceptionAsServer", "sendExceptionToHost", "sendErrortoServer", "sendExceptiontoService", "sendExceptiontoserver", "sendExceptionWithService"], "server": ["email", "base", "erver", "ssl", "Server", "conf", "domain", "root", "client", "address", "test", "proxy", "service", "db", "port", "ser", "null", "http", " host", "prefix", "header", "host", "addr", "serv", "ip", "json"], "ex": ["x", "full", "su", "ext", "Ex", "ception", "error", "rupt", "aux", "nex", "rex", "event", "str", "Exc", "hex", "log", "class", "status", "base", " exc", "throw", "sex", "export", "err", "ax", "exc", "e", "temp", "acer", "pex", "lex", "example", "exec", "exit", "cl", "except", "fail", "con", "res", "Exception", "def", "exp", "none", "re", "ace", "tx", "obj", "EX"], "config": ["connection", "app", "cb", "ext", "Conf", "options", "settings", "proc", "rc", "log", "base", "text", "conf", "cmd", "bug", "etc", "client", "address", "console", "service", "cfg", "Configuration", "file", "Config", "json"], "prob": ["pebe", "peb", "Probe", "pebs", "Proj", "Probs", " probs", "probe", "proj", "Prob", "probs", " probe", " proj", "pej"], "dataSB": ["dataBL", "uiEl", "execBB", "offLB", "pSB", "innerLB", "DataFB", "errorBB", "contentsb", "nosb", "codeEB", "uiSB", "noSB", "workBB", "eventSB", "strLB", " dataEB", "controlBL", "dataRB", "datasb", "ifsb", "postLB", "ifSL", "postSB", "fileSB", "fullLB", " dataLB", "DataBL", "innersb", "cachesb", "filesb", " dataFB", "errorEB", "datLB", "DataBB", "contentLB", "cacheSB", "datSB", "codeSB", " dataBB", "execBL", "errorPB", "responseLB", "errorSL", "responseSB", "ifLB", "codeLB", "DataLB", "cacheLB", "controlsb", " dataBL", "eventSL", "execLB", "dataBs", "offsb", "fullBB", "DataSL", "DataHL", "DataOB", "loadBB", "datBB", "noSL", "codeRB", "fullBL", "loadSB", "Datasb", "dataOB", "loadsb", "defaultBB", "dataFB", "offSB", "dataEB", "datOB", "responseBL", "offBB", "uiLB", "eventLB", "defaultSB", "codeMB", "dataBB", "eventBB", "workSB", "loadLB", "codeHL", "contentOB", "codeBB", "postsb", "workPB", "innerSB", " dataPB", "fileLB", "DataRB", "errorOB", "strsb", "controlLB", "postSL", "dataSL", "DataSB", "defaultLB", "errorLB", "errorsb", "execsb", "pLB", " dataBs", " dataEl", " dataRB", " dataOB", "dataHL", "innerSL", "offSL", "DataMB", "noLB", "defaultsb", "dataLB", "controlBB", "ifSB", "fileSL", "errorSB", "pBs", " dataMB", "dataEl", "contentSB", "codesb", "codeBs", "codeFB", "codeEl", "strSB", " datasb", "controlSB", "responseBB", " dataHL", "execSB", "psb", " dataSL", "cacheBL", "dataPB", "workSL", "strSL", "dataMB", "fullSB"], "trace": ["trip", "profile", "data", "tri", "scale", "error", "type", "ctr", "span", "string", "array", "stack", "info", "xml", "log", "ptr", "cache", "r", "bug", "trans", "err", "e", "flow", "bean", "address", "temp", "race", "track", "buffer", "test", "atter", "t", " debug", " tracing", "details", "shadow", " traced", "message", "debug", "tr", "result", "out", "cover", "fake", "report", "ace", "tx", " traces", "strip", "runner", "ray"]}}
{"id1": "16590954", "id2": "12306305", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"createJAR": ["createAMAR", " createJJar", " createPHJar", " createPHAP", "createPHARS", "createJJar", "createJPARS", " createPHARS", " createPHAR", "createJPAP", "createJPAR", "createAMARS", "createJPJar", "createAMJar", "createPHAR", "createAMAP", "createPHAP", "createJARS", "createPHJar", " createJAP", " createJARS", "createJAP"], "fileString": ["FileText", "FileString", "modelStream", "filestring", "lineArray", "baseString", "fileName", "baseFile", "FileArray", "modelString", "linestring", "fileArray", "lineName", "FileStream", " fileText", " fileFile", " fileArray", "modelText", "Filestring", "loadstring", "resourceText", "fileStr", "loadString", "resourceString", "fileText", "basestring", " fileStr", "FileFile", "loadText", "loadName", "resourceStream", "fileFile", "fileStream", "FileStr", "baseStr", "FileName", "modelStr", " filestring", "lineString", "resourceStr", " fileName"], "ext": ["x", "extra", "app", "data", "name", "version", "type", "info", "ex", "enc", "dep", "str", "class", "prot", "format", "req", "Ext", "text", "txt", "content", "EXT", "zip", "dist", "ax", " Ext", "xt", "exe", "external", "path", "filename", "v", "url", "config", "code", "append", "exp", "desc", "end"], "file": ["full", "le", "binary", "f", "doc", "get", "name", "it", "File", "force", "socket", "place", "change", "jar", "fe", "local", "ger", "base", "log", "per", "class", "model", "page", "cache", "b", "part", "files", "output", "zip", "l", "work", "line", "single", "test", "buffer", "bar", "source", "build", "db", "ile", "path", "h", "filename", "parent", "url", "unit", "pe", "http", "let", "up", "wave", "folder", "module", "flat", "FILE", "resource", "fp", "queue", "use"], "i": ["x", "f", "si", "it", "mini", "slice", "ori", "j", "p", "pi", "ind", "hi", "I", "di", "multi", "qi", "l", "key", "ini", "abi", "ci", "limit", "xi", "v", "mi", "ui", "yi", "li", "uri", "ii", "c", "ni", "index", "iu", "eni", "ai", "phi", "uni", "ip"], "dir": ["cur", "data", "doc", "name", "manager", "loc", "type", "info", "jar", "str", "div", "class", "base", "direction", "format", " directory", "output", "domain", "Dir", "zip", "dist", "lib", "db", "path", "filename", "url", "config", "uri", "ir", "folder", "id", "module", "src", "prefix", "DIR", "coll", "directory", "area", "rel", "string", "tmp", "pkg"], "jarFile": ["tarfile", "javaFiles", "tarFile", "javaDir", "tarLine", "jarFiles", " jarFolder", "archiveFolder", " jarSourceFile", "sessionFile", "reportF", "javaF", "archiveFile", "jarFolder", " jarLine", "javafile", "sessionLine", "javaFolder", "tarF", "javaFile", "javaSourceFile", "sessionSourceFile", " jarFiles", "reportfile", "reportSourceFile", " jarfile", "jarLine", "archiveFiles", "jarDir", "tarSourceFile", "archiveDir", "reportFile", "jarSourceFile", " jarDir", "jarF", "sessionfile", "jarfile"], "fstrm": ["fbrum", " fstrM", "fstm", " fsrM", "Fstrmd", "Fsrm", "fbrm", "fstrcm", "fstrum", "fgrmd", "Fsrcm", "fsrcm", "fgrM", "Fstrm", "Fsrmd", "fsrM", "Fstrcm", "fsrm", "fstcm", " fstrcm", "fgrcm", "fgrm", " fstrum", " fsrcm", " fsrm", " fsrum", "fstmd", "fstrmd", "fsrmd", "fbrM", "fbrcm", "FsrM", "fsrum", "fstum", "fstrM", "FstrM", "fstM"], "in": ["reader", "bin", "login", "f", "into", "socket", "s", "ins", "pin", "m", "stream", "sync", "to", "p", "min", "In", "binary", "is", "inside", "conn", "part", "inner", "again", "rin", "din", "l", "r", "IN", "pull", "image", "init", "inc", "or", "nin", "n", "read", "io", "inn", "c", "up", "id", "input", "ac", "gin"], "out": ["connection", "bin", "outside", "doc", "self", "channel", "pool", "m", "sync", "to", "outs", "plain", "conn", "b", "all", "output", "inner", "again", "user", "part", "line", "writer", "err", "flow", "off", "client", "plus", "OUT", "this", "call", "source", "init", "image", "inc", "outer", "v", "group", "server", "null", "io", "net", "c", "up", "resource", "exp", "Out"], "temp": ["full", "pipe", "iter", "f", "doc", "get", "it", "Temp", "archive", "emp", "p", "clean", "local", "dump", "base", "wrap", "cache", "w", "output", "tem", "Output", "zip", "writer", "single", "export", "key", "dest", "porary", "test", "buffer", " temporary", "storage", "build", "db", "template", "api", "controller", "source", "path", "or", " tmp", "v", "form", "config", "store", "server", "unit", "c", "folder", "input", "fake", "home", "directory", " Temp", "tmp"], "fstrm2": ["fstrM002", "fstm1", "fstrm1", "fhrms2", "fstrM02", "fstrp2", "fstM0", "fstM1", "fstrm0", "fhrm02", "fhrm002", "fstrM0", "fstrmr1", "fhrms1", "fstrp1", "fstrmr002", "fstrp0", "fstm0", "fstrms02", "fstrM2", "fhrms02", "fhrm2", "fstrM1", "fhrm1", "fstrms0", "fstrms1", "fstrms2", "fhrms002", "fstrms002", "fstm2", "fstrmr02", "fstrm02", "fstrmr2", "fstrm002", "fstM2"], "ostrm": ["odm", "istmr", "ophrm", "obsrt", "oodrm", "obrm", "istrom", "obsrob", "obsrem", "obsrm", "istrm", "oodrob", "ostrem", "odmr", "oscrm", "ooprm", "obrt", "ostmr", "ostrob", "ophmr", "obrom", "oscm", "odrm", "oodrt", "odrt", "otherrm", "istrt", "ooprom", "ostrom", "ooprt", "ophrt", "othermr", "oopmr", "ostrt", "oscmr", "otherrom", "ostm", "oodrem", "otherrt", "oscrt", "obmr", "ophm"], "docFile": ["docDir", "documentFile", "DocF", "DocDir", " docFiles", "DocFiles", "DocFile", "documentFiles", "docF", "documentF", "docFiles", " docF", " docDir", "documentDir"]}}
{"id1": "6470716", "id2": "4618237", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"st": ["est", "const", "f", "s", "sc", "put", "pt", "ct", "ist", "inst", "ast", "sth", "str", "fe", "class", "ste", "ld", "sts", "ust", "ST", "Str", "r", "fr", "std", "d", "t", "tt", "struct", "St", "sta", "stage", "cl", "code", "id", "src", "sb", "www", "sf", "ost", "stress", "ft", "string", "start", "rest"], "url": ["ul", "connection", "open", "sl", "f", "loc", "org", "fl", "ur", "gl", "stream", "web", "download", "pl", "log", "base", "ssl", "ll", "ls", "bb", "html", "b", "user", "blog", "page", "zip", "l", "bug", "err", "fr", "address", "Url", "URL", "build", "source", "feed", "image", "or", "hub", "path", "cl", "uri", "server", "http", "file", "id", "impl", "tool", "www", "coll", "bel", "host", "link", "string", "ob"], "fis": ["fiss", " fris", "afis", "lils", "flils", "bos", "FIS", "FIs", "flis", "fIs", "bi", "afiss", "afos", "afIs", "fi", "fips", "Fis", "lris", " fIS", " fi", "fli", "fliss", "fils", " fips", "Fiss", "bis", "flris", "zIS", " fiss", "Fips", " fils", "fris", "Fos", "Fris", "liss", "flIs", "zips", "zris", "fIS", "lis", "flos", "biss"], "zis": ["Ziss", "zipits", "zeisa", " zbis", "zisa", "Zis", "zipois", "zipisi", " zi", "zenisi", "zenais", "zipais", "ezIS", "zisi", "ziss", "zeis", "Zais", "zipis", "qi", " ziss", " zisi", "zeIS", " zIS", "ezips", "zois", " zits", " zisa", "qiss", "zIS", "zi", "zenis", " zais", "qbis", "ezisa", "zits", "zenois", "qis", "zips", "zeips", "ezis", "zbis", "zipi", "zipiss", " zois", "zipbis", "Zits", "zais", " zips"], "entry": ["nt", "reader", "extra", "si", "archive", "session", "auto", "ries", "ident", "info", "se", "ge", "country", "ie", "rc", "match", "lc", "Entry", "part", "inner", "je", "sea", "zip", "r", "ace", "line", "e", "cell", "key", "la", "address", "fr", "row", "comment", "dc", "parse", "image", "cat", "feed", "inc", "or", "spec", "object", "sec", "next", "enter", "li", "pe", "in", "file", "index", "ry", "result", "obj", "record", "cel", "exp", "ent", "de", "element"], "count": ["offset", "name", "_", "current", "depth", "allow", "type", "load", "en", "counter", "ind", "log", "base", "add", "more", "check", "cache", "size", "part", "line", "val", "max", "buffer", "list", "Count", "i", "limit", "feed", "use", "child", "parent", "sum", "default", "number", "read", "code", "c", "file", "id", "index", "len", "skip", "length", "write", "start", "end"], "data": ["reader", "error", "batch", "body", "results", "p", "info", "load", "str", "zero", "shift", "cache", "text", "size", "bytes", "content", "d", "buffer", "i", "image", "block", "feed", "value", "read", "number", "raw", "empty", "code", "DATA", "a", "len", "message", "result", "dat", "input", "length", "area", "alpha", "string", "start", "buf"], "fos": ["efosh", "fol", "fosh", "zol", "dfosi", "foses", "zOS", "efoses", "frosh", "Fol", "FOS", "fOS", "efos", "dfosh", "froses", "fosi", "znos", "fnos", "dfoses", "fros", "flol", "flnos", "dfos", "frosi", "efosi", "Fos", "flOS", "flos", "zos", "Fnos"], "dest": ["prop", "const", "cdn", "loc", "sup", "later", "slice", "dev", "stream", "cont", "sync", "comb", "di", "die", "inner", "output", "txt", "img", "done", "zip", "trans", "writer", "coord", "dist", "temp", "std", "dc", "test", "style", "source", "wh", "outer", "exit", "sum", "default", "south", "wb", "transform", "src", "des", "Dest", "flash", "result", "target", "out", "dat", "home", "desc", "de", "end", "tmp", "rest"]}}
{"id1": "732800", "id2": "18696387", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createOutputSteam", "createInputStream", " createInputSteam", "createOutputSteam", " createByteSteam", " createOutputFile", " createOutputReader", " createIOSteam", "createInputReader", " createByteFile", " createByteReader", " createIOStream", " createByteStream", "createInputSteam", " createInputFile", " createInputReader", " createIOReader", "createOutputReader", "createOutputFile", "createInputFile", " createIOFile", " createInputStream"], "inFile": ["inputFile", "outFiles", "insfile", "infile", "inputfile", "outfile", "outStream", "incFiles", "sourceFiles", "incfile", "inFiles", "insStream", "sourceStream", "incFile", "insFile", "sourcefile", "inputFiles", "inputStream", "sourceFile", "insFiles", "inStream", "incStream"], "outFile": ["inputFile", "workingDirectory", "workDir", " outStream", "targetFile", "outDir", "inputTime", "infile", "inputfile", "outfile", "outStream", "inDir", "workingFile", "targetStream", " outDirectory", "targetfile", "inputDir", " outfile", "workingfile", "outTime", "workfile", "targetDirectory", "inTime", "workFile", "workingStream", "outDirectory", "workTime"], "k_blockSize": ["k_lineInfo", "k_BlockCount", "k_blockLength", "k_BlockLength", "k_lockCount", "k_blockInfo", "k_BlockSize", "k_blockCode", "k_blocksLen", "k_blocksSize", "k_blocksCount", "k_lineCount", "k_byteCount", "k_BlockCode", "k_bitInfo", "k_lockLength", "k_byteLen", "k_lockLen", "k_blockCount", "k_blocksLength", "k_bitCount", "k_byteSize", "k_blockLen", "k_lockSize", "k_byteInfo", "k_lineSize", "k_byteCode", "k_byteLength", "k_lockCode", "k_bitSize"], "byteCount": [" byteSize", "ByteCount", "blockSize", "flushLength", "flushcount", " byteLen", "bytecount", "ByteLen", "byteSum", "blockLength", "characterCount", "flushSize", "ByteSize", "ByteSum", "byteLen", " byteSum", "blockSum", " byteLength", "characterLen", "characterLength", "ByteLength", " bytecount", "byteLength", "blockCount", "flushCount", "characterSize", "byteSize", "Bytecount"], "buf": ["border", "cb", "seq", "data", "loc", "background", "batch", "alloc", "buff", "cap", "Buffer", "bh", "rc", "feat", "base", "b", "vec", "bytes", "img", "cmd", "bag", "exc", "flush", "font", "la", "rb", "buffer", "ctx", "feed", "ucc", "Buff", "config", "cv", "brace", "len", "src", "fd", "uf", "cas", "queue", "bf", "append", "result", "fb", "tmp"], "ofp": ["Oftp", "OFt", "afc", "Ofl", "Ofp", "oftp", "fortp", "forp", "OFtp", "ofl", "fort", "ofnp", "oft", "afl", "Ofnp", "afnp", "OFp", "OFl", "OFc", "forc", "Ofc", "afp", "ofc", "OFnp", "Oft"], "zos": ["lol", "cos", "zy", "bes", "outs", "ls", "css", "rez", "tz", "nz", "uz", "ws", "zyk", "zn", "js", "cfg", "zx", "nox", "ozo", "modules", "bitcoin", "ros", "ZA", "ses", "webkit", "fits", "ogl", "enos", "liquid", "bs", "os", "lins", "kos", "zl", "zag", "zin", "obs", "zip", "oses", "ZI", "iffs", "abi", "packs", "z", "rons", "osi", "inos", "zar", "los", "zo", "obb", "zona", "budget", "bos", "ossus", "ops", "jas", "zers", "zh", "zb", "zik", "zen", "zi", "soon", "zig", "zes", "forge", "owicz", "oS", "hz", "robe", "gz", "utils", "zon", "iframe", "zer", "oda", "dylib", "core", "za"], "osw": ["ossd", "issw", "osd", "osfw", "oswd", "isnow", "ishell", "esww", "bx", "osshell", "esy", "esnow", " osww", "oshell", "iswd", "eshell", "ossow", "ossy", "ossfw", "bws", "bsx", "lsx", "osy", "ossww", "osssw", "bsws", "bsw", "esfw", "isy", "osx", "ossw", "isd", " osfw", "lsw", "ossnow", "esow", "osws", " osow", "lswo", "osswd", "isw", "bwo", "essw", "osow", "esw", "esd", "oswo", "osnow", "eswd", "lsws", "osww", "bswo"], "bw": ["bbwa", " bz", "lbsw", "bbaw", "bbwu", "abW", "abwd", " bwa", "bx", " bew", "fw", "bz", "fbwe", "ebwd", "bbws", "fsw", "lbw", "lw", "bws", "fwa", "ebwe", " baw", "ow", "lbx", "abwe", "bbz", " bws", "owu", "oaw", "Bw", "bew", "lbwa", "bwu", "bsw", "lx", "fr", "bbwh", "lbws", "baw", "ebw", "fx", "bwe", "bbew", "fwh", "abw", "lsw", "bwh", "lbr", "ebW", "Bwa", " bwu", "Bws", "fbW", "lbwh", "Bew", "owa", "bwd", "fbw", "fbwd", "bwa", "bbw", " bwh", "lbz", "bW", "lwa"], "zot": ["azor", "jit", "Zit", "ziot", " zor", "zerot", "jori", "azit", "Zita", "azot", "jot", "Zott", "zerott", "zerita", "zeros", "zita", "Zot", "zerori", "aziot", " zori", "Zor", "azita", "zott", "azott", "zerit", "zor", " ziot", "zori", "jos", "Ziot"], "ifp": ["ifb", " ifc", "Iff", "ifl", "ifi", "ipl", "IFp", " ifi", " ifb", "Ifi", "ipc", "ipp", "Ifc", " iff", "IFl", "ipb", " ifl", "IFc", "iff", "IFi", "Ifp", "ifc", "IFb", "IFf"], "zis": ["zenIS", "Ziss", "zipits", "jit", "Zis", "jisi", "xits", "zeits", "xisi", "zenais", "xis", "zeiss", "zisi", "ziss", "zeis", "zipis", "zip", "xIS", "xib", " zisi", "zipip", " zIS", "jits", "zenib", "zeip", "jis", " zits", "zIS", "zenis", " zais", "zib", "xais", " zib", "zits", "zipiss", "xit", "Zip", "Zits", "zais"], "isr": ["risr", "iscr", "rispr", "irpr", "ISr", "irr", "irrb", " iscr", "ISrs", "isrs", "IScr", "isrc", "issr", "ISpr", "ISrc", "ISrb", "isrb", "ISsr", "issrs", "isscr", "isssr", " issr", "risrc", "irrc", "ispr", "risrb", " isrs"], "br": ["mr", "Br", "ob", "HR", "ibr", "arr", "ctr", "body", "kr", "div", "str", "bh", " fr", "bl", "obl", " BR", "yr", "b", "img", " Br", "r", "bp", "rs", "err", "fr", "cro", "rb", "bar", "BR", "sp", "shr", "hr", "ch", "lr", "ibl", "browser", "ocr", "gr", "sr", "bsp", "rib", "bro", "tr", " dr", "ber", "obi", "bc"], "zit": ["zipith", "ji", "zipits", "jit", "zipit", "zIT", "zite", " zite", "zipitter", "zipita", " zi", "jip", " zic", "xic", "zeits", "zeIT", "jIT", " zith", "zith", "zita", "zip", "jic", "zipip", "zenitter", "jits", "jith", "zipite", "zeita", "zenith", "zitter", "xi", "jite", " zits", "zipIT", "zi", "xith", " zip", "jita", "zits", "zic", "zeit", "zeitter", "zenit", "xit", "zeith", "zenits"]}}
{"id1": "6271502", "id2": "9347451", "code1": "    @Override\n    public InputStream getResourceByClassName(String className) {\n        URL url = resourceFetcher.getResource(\"/fisce_scripts/\" + className + \".class\");\n        if (url == null) {\n            return null;\n        } else {\n            try {\n                return url.openStream();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 0, "substitutes": {"getResourceByClassName": ["getResourceByclassString", "getResourceByclassName", "getResourceForClassName", "getResourceForclassName", "getResourceByClassString", "getResourceByFileString", "getResourceByFilename", "getResourceForclassString", "getResourceByclassname", "getResourceByClassname", "getResourceForClassString", "getResourceForClassname", "getResourceForclassname", "getResourceByFileName"], "className": ["ClassType", "Classname", "scriptPath", "ClassPath", " classPath", "classTitle", "classType", "scriptname", "shortPath", "classPath", " classType", "shortName", "ClassName", "scriptType", " classTitle", "scriptName", " classname", "ClassTitle", "shortTitle", "classname", "shortname"], "url": ["job", "sl", "f", "data", "name", "org", "el", "web", "event", "str", "xml", "class", "base", "ssl", "ls", "log", "page", "b", "loader", "instance", "plug", "zip", "l", "e", "address", "Url", "service", "URL", "source", "buffer", "image", "feed", "api", "path", "object", "lr", "server", "uri", "http", "file", "impl", "resource", "bel", "www", "coll", "orb", "ref", "location", "rl", "window", "resources", "rel", "string", "element", "ob"]}}
{"id1": "6457199", "id2": "8486429", "code1": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "code2": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doRequest": ["runProxy", "DoCall", " doCall", "runCall", "doCall", "doResponse", "runResponse", "DoRequest", " doResponse", " doProxy", "runRequest", "DoProxy", "doProxy", "DoResponse"], "request": ["reader", "name", "error", "session", "complete", "reference", "method", "application", "event", "xml", "req", "user", "instance", "query", "client", "call", "buffer", "object", "Request", "url", "context", "view", "uri", "server", "route", "hello", "http", "right", "message", "result", "queue", "report", "re", "json", "string"], "response": ["connection", "error", "respond", "reference", "body", "results", "application", "Response", "status", "model", "more", "page", "output", "success", "writer", "client", "reply", "respons", "service", "template", "feed", "api", "parent", "object", "v", "document", "view", "server", "route", " Response", "http", "index", "message", "result", "out", "host", "report", "onse", "re", "json", "resp", "site"], "path": ["full", "arc", "data", "name", "self", "type", "method", "slice", "p", "info", "partial", "base", "part", "text", "inner", "content", "alias", "left", "work", "patch", "key", "ith", "pointer", "source", "image", "template", "child", "anc", "port", "object", "pattern", "relative", "api", "url", "context", "walk", "uri", "code", "route", "http", "id", "PATH", "prefix", "right", "message", "index", "ath", "Path", "token", "dir", "host", "location", "string", "end"], "internal": ["x", "standard", "outside", "actual", "background", "name", "absolute", "central", "origin", "remote", "ident", "personal", "exclusive", "shared", "local", "base", "binary", "inside", "inline", "rc", "inner", "Internal", "alias", "single", "normal", "external", "storage", "special", "source", "api", "relative", "parent", "attr", "system", "context", "url", "regular", "uri", "route", "intern", "http", "original", "impl", "primary", "prefix", "custom", "initial", "international", "join", "foreign", "re", "string", "rx"], "resource": ["connection", "manager", "reference", "range", "stream", "rera", "rc", "base", "rule", "ource", "resolution", "r", "ruby", "client", "address", "Resource", "this", "external", "buffer", "pointer", "source", "real", "image", "use", "api", "url", "context", "relation", "uri", "server", "route", "http", "file", "sr", "src", "result", "record", "res", "resources", "string", "media", "re", "rest"], "mimeType": ["pipTypes", "mancePath", "modName", "mimesTypes", "smimeName", "monsePath", "maxType", "piptype", "mimesPath", " mileInfo", "mileInfo", "smIMEName", "pimePath", "mimePath", "modType", "mileTypes", "mipType", "mpeInfo", "maxInfo", "smimetype", "modInfo", "mpeType", "smIMEType", " mimeInfo", "pipPath", "mIMEtype", "monseTypes", "mimesInfo", " milePath", "mimesType", "pimeType", "mimeName", "miptype", "monsetype", "modtype", "pimetype", "smIMEInfo", "mIMEInfo", " mileType", " mimePath", "mimeInfo", "pipType", "manceType", "smIMEtype", "pimeTypes", "mIMEName", "mileType", "mipTypes", "manceTypes", " mileTypes", "mipPath", "mpeTypes", "milePath", "mimeTypes", "monseType", "smimeInfo", " mimeTypes", "maxName", "smimeType", "mIMEType", "mimetype", "maxtype", "mancetype", "mpePath"], "is": ["ais", "Is", "iss", "ri", "ori", "info", "im", "isa", "IS", "isc", "was", "ops", "its", "ras", "i", "api", "or", "nis", "bis", "ois", "vs", "ui", "ir", "uri", "ps", "http", "ris", "as", "in", "iso", "iris", "are", "sis", "res", "us", "ios", "lis", "serv", "ip", "fs", "isi"], "os": ["oS", "ais", "cos", "oss", "s", "bs", "bos", "ori", "outs", "cs", "ies", "ops", "oses", "o", "OS", "Os", "oes", "vs", "ose", "io", "ps", "osi", "as", "iso", "aos", "acs", "ros", "res", "opens", "us", "ios", "los", "so", "ols", "nos", "ows", "dos"]}}
{"id1": "8135072", "id2": "16572931", "code1": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"setImg": ["setIMgs", "setIMg", "setImagegm", "setAmg", "setImgs", "getImg", "setImageg", "setIMgm", "getImageg", "setIMvg", "setAmgm", "setImgm", "setImagegs", "getImgs", "getImagevg", "getImgm", "setAmgs", "setImvg", "getImagegm", "getImagegs", "setImagevg", "setAmvg", "getImvg"], "jFileChooser1": ["jFileChooseone", "jFileChoitcher3", "jFileChoitcher2", "jFileChoouter2", "jFileChooserone", "jFileCloseL", "jFileChooser01", "jFileChooseL", "jFileChooserL", "jFileChoosingL", "jFileChoosen2", "jFileCloser2", "jFileChoiser3", "jFileChoosing1", "jFileCloserL", "jFileChoosen1", "jFileChoitcherone", "jFileChoose3", "jFileCloserOne", "jFileChoose2", "jFileChoicker3", "jFileChoouter3", "jFileCloseOne", "jFileChoosen3", "jFileClose2", "jFileClose3", "jFileCloser01", "jFileChooser3", "jFileChoosing2", "jFileChoose01", "jFileChoouter1", "jFileChoicker1", "jFileChoickerOne", "jFileChoose1", "jFileChoouter01", "jFileChoosing3", "jFileChoickerL", "jFileCloser3", "jFileChoiserOne", "jFileChoiser1", "jFileChooser2", "jFileChoiser2", "jFileChooserOne", "jFileChoosen01", "jFileCloser1", "jFileChooseOne", "jFileChoosingOne", "jFileClose1", "jFileChoosenone", "jFileClose01", "jFileChoitcher1"], "separator": ["separate", "terminar", "locator", "separar", "variation", "perated", " separoder", "terminate", "seinator", " separate", "seator", "locate", "escapator", "separigator", "locating", "variated", " separigator", "terminner", "perar", "perate", " separated", "separation", "decator", "decators", "escapigator", " separner", " separating", "generate", "separinator", "separating", " separation", "variate", "locoder", "perner", "generating", "perator", "escapators", " separators", "decigator", "seate", "variator", "terminator", "escapate", "separated", "separner", "locinator", "peration", "separators", " separar", " separinator", "location", "separoder", "generator", "generation", "seoder", "decate"], "dirImg": ["dirAnimvg", "dirAmvg", "dirSegs", "dirUrgd", " dirImgd", "dirImagesg", "dirSevg", "dirImsg", "dirAmog", "dirIMvg", "directoryImagegs", "dirIMg", "directoryImagesg", "folderImvg", "dirImgb", "dirimgs", "dirIMm", "homeImg", "dirImog", "dirUrgs", "dirimgb", "homeImgd", "dirAmg", " dirImimg", "dirAnimm", "dirImagegb", "dirimsg", "dirImagegs", "dirimg", "homeImvg", "homeIMg", " dirImgs", "dirSeog", "directoryImageg", "dirImgs", "homeIMm", "dirAmgs", "dirAnimgd", "folderImgs", "dirImageg", "directoryImsg", "folderImog", "dirAnimg", "dirUrimg", "dirIMgb", "homeIMgd", "dirSeg", "dirImvg", "folderImg", "directoryImgs", "homeIMvg", "directoryImagegb", "dirIMimg", "dirUrg", "dirImgd", "homeImm", "dirImimg", "dirImm", "dirIMgs", "dirIMgd", "directoryImgb", "dirIMsg", "directoryImg"], "index": ["x", "offset", "active", "loc", "name", "point", "slice", "type", "field", "ind", "match", "position", "page", "part", "size", "num", "weight", "section", "line", "key", "address", "i", "Index", "condition", "inc", "value", "path", "axis", "default", "level", "number", "id", "pos", "len", "action", "diff", "length", "string", "end"], "imgName": ["imageName", "imagename", "ngname", "imagePath", "imgname", "ngName", "imgPath", "iconName", " imgPath", "imageType", "iconname", "imgType", "iconPath", "imagePart", "ngPath", " imgPart", "ngPart", " imgname", "imgPart", "iconType", " imgType"], "newPath": ["newFile", "oldFile", " newLocation", "NewPath", "oldpath", "nextFile", "NewLocation", "NewName", "workingFile", "Newpath", "NewUrl", "nextPath", "oldLocation", "newName", "newpath", "workingpath", " newUrl", "nextLocation", " newFile", "workingPath", "oldPath", " newName", "newLocation", "newUrl", "nextpath", "workingName", "NewFile", " newpath", "nextUrl"], "inputFile": ["inPath", "viewDirectory", " inputStream", "InputPath", "inDir", "InputPage", "viewFile", "inputPage", "InputStream", " inputDirectory", " inputFiles", " inputPath", "outputPage", "inputFolder", "InputDir", "inputDir", "outputPath", "viewFolder", " inputPage", "InputDirectory", "viewPath", "outputFiles", "inputFiles", " inputFolder", "inputStream", "InputFile", " inputDir", "inputPath", "inStream", "inputDirectory", "InputFolder", "InputFiles", "inFile"], "outputFile": [" outputFolder", "targetFile", "OutputFiles", "outputStream", "inputfile", " outputFiles", "outputDir", " outputStream", " outputDirectory", "writeStream", "outputPath", "inputFolder", "inputDir", " outputDir", "writeFile", "targetPath", " outputfile", "targetFiles", "OutputDirectory", "outputFiles", "inputFiles", "writeDir", "outputfile", "inputStream", " outputPath", "OutputPath", "outputFolder", "inputPath", "inputDirectory", "outputDirectory", "writefile", "OutputFile", "targetFolder"], "in": ["reader", "bin", "connection", "lock", "isin", "sin", "f", "login", "into", "socket", "ins", "pin", "cin", "ex", "In", "is", "inside", "conn", "part", "inner", "again", "win", "l", "r", "din", "IN", "err", "plus", "o", "ini", "i", "source", "init", "inc", "nin", "h", "n", "io", "inn", "as", "up", "fa", "id", "a", "lin", "input", "diff"], "out": ["bin", "name", "point", "socket", "error", "down", "ins", "sync", "to", "ex", "outs", "plain", "copy", "conn", "cache", "inner", "output", "again", "part", "line", "writer", "IN", "err", "plus", "o", "off", "client", "OUT", "i", "lib", "inc", "exec", "outer", "other", "io", "net", "file", "up", "co", "Out"], "c": ["x", "cent", "abc", "arc", "f", "nc", "sc", "m", "ct", "C", "p", "dec", "k", "enc", "ec", "pc", "rc", "lc", "b", "cr", "l", "r", "e", "o", "esc", "dc", "d", "i", "pointer", "ci", "cc", "t", "ch", "uc", "xc", "v", "character", "cl", "n", "code", "cu", "ce", "ic", "cm", "cp", "ac", "col", "bc", "cy"], "bckImg": ["bckimgl", "bckInf", "bccImg", "bckImf", "bckIngl", "bccPf", "bckimf", "bckPgs", "bckIngs", "bccPgl", "bccImgl", "bckPf", "bckImgs", "bccPgs", "bckImgl", "bckPgl", "bckimgs", "bccImf", "bccImgs", "bckPg", "bccPg", "bckIng", "bckimg"]}}
{"id1": "6301863", "id2": "23517481", "code1": "    protected String doRawRequest(String postData) throws IOException {\n        URL url = new URL(SERVICE_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(postData);\n        wr.flush();\n        BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuffer sb = new StringBuffer();\n        String line;\n        while ((line = rd.readLine()) != null) {\n            sb.append(line);\n        }\n        wr.close();\n        rd.close();\n        return sb.toString();\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"doRawRequest": ["doPostPost", "DoRawRequest", "doPostResponse", "DoDirectRequest", "doPostMessage", "DoDirectResponse", "doRawMessage", "doFullResponse", "doDirectResponse", "DoDirectPost", "DoRawPost", "doFullRequest", "DoRawMessage", "doDirectRequest", "doFullMessage", "doPostRequest", "doDirectMessage", "doFullPost", "DoDirectMessage", "DoRawResponse", "doDirectPost", "doRawPost", "doRawResponse"], "postData": ["Postdata", "postString", " postdata", "POSTString", "postdata", "POSTData", "PostBody", "PostData", "postBody", "PostPart", "POSTPart", " postPart", " postString", " postBody", "postPart", "PostString", "POSTBody", "POSTdata"], "url": ["connection", "nt", "open", "sl", "f", "org", "fl", "ur", "web", "download", "str", "ll", "ssl", "base", "ls", "log", "bb", "b", "page", "blog", "user", "r", "l", "client", "Url", "service", "URL", "db", "api", "lr", "cl", "config", "server", "uri", "http", "c", "resource", "www", "host", "rl"], "conn": ["connection", "nt", "open", "lock", "cb", "rn", "loc", "cn", "reg", "org", "nc", "session", "g", "ct", "Connect", "sync", "dn", "enc", "not", "pub", "pc", "ann", "ssl", "w", "contract", "cr", "r", "client", "dc", "ci", "db", "connect", "ch", "cf", "exec", "close", "conv", "n", "rt", "Conn", "c", "wb", "co", "po", "coll", "ai", "con", "cm", "fp", "fail", "auth", "cp", "Connection", "apt", "act"], "wr": ["rh", "mr", "wt", "ww", "wd", "fw", "kr", "raft", "vr", "wp", "ru", "pr", "w", "wrap", "wm", "cr", "r", "writer", "ra", "Wr", "dr", "rr", "wn", "rb", "shr", "war", "WR", "hr", "wa", "rw", "sw", "nr", "rt", "wire", "wb", "RW", "wer", "rx", "nw", "fd", "wy", "rss", "Writer", "write", "wx"], "rd": ["rh", "reader", "bd", "rn", "RS", "RD", "rm", "wd", "ds", "dd", "adr", "rod", "ru", "rc", "ld", "dig", "pr", "rob", "cr", "r", "writer", "ra", "fr", "dr", "rb", "rr", "rowd", "gd", "hr", "db", "rw", "rg", "erd", "dra", "rt", "sr", "src", "ird", "fd", "rss", "tr", "xd", "wx", "pd", "rl", "rx"], "sb": ["SB", " SB", "BB", "cb", "bd", "su", "sg", "nn", "si", "lp", "bj", "gb", "s", "bs", "buff", "bt", "eb", "lab", "bh", "binary", "xb", "ssl", "bb", "ls", " eb", "b", "mb", "sv", "bp", "lines", "bc", "rb", "buffer", "abb", "db", "ws", "lb", "zb", "bg", "bps", "sa", "wb", "nb", "src", "bsp", "bf", "sf", "fp", "obb", "fb", "pb", "buf"], "line": ["job", "reader", "le", "sl", "f", "data", "name", " Line", "error", "type", "body", "sync", "non", "one", "str", "letter", "lc", "inline", "page", "user", "text", "part", "l", "r", "cell", "err", "lines", "key", "e", "lf", "row", "comment", "i", "source", "Line", "object", "character", "no", "cl", "code", "pass", "unit", "in", "split", "file", "id", "LINE", "word", "len", "message", "lin", "link", "string", "ip", "end"]}}
{"id1": "20939940", "id2": "12766394", "code1": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 0, "substitutes": {"createJavaProject": ["getjavaProject", "createJavaFolder", "createRubyFolder", "createjavaProject", "createJavaConnector", "getJavaApplication", "getjavaApplication", "getJavaConnector", "createjavaApplication", "getJavaProject", "createjavaConnector", "createJSConnector", "createJSProject", "getJavaFolder", "createRubyApplication", "createJSFolder", "createJavaApplication", "getjavaConnector", "createRubyConnector", "createJSApplication", "createRubyProject", "getjavaFolder", "createjavaFolder"], "proj": ["prod", "pez", "projs", "promj", "parb", "perJ", "cojo", "sujo", "projo", "upj", "rouj", "suuj", "promjo", "parj", "propjet", "perject", "profject", "perj", "pejp", "produz", "profjs", " projs", "conj", "produj", "pejo", "suk", "conjc", " project", "parjet", "cobj", "Prok", "promjp", "upJ", "Proz", "pej", " projet", "PROz", "peJ", "produjet", "propje", "probj", "Projp", "produjo", "PROjp", "prouj", " prob", " projo", "Projc", "project", "proJ", "produjp", "coj", "suz", "preuj", " prod", " projp", "Proj", "Proaj", " proJ", "ProJ", "Prouj", "produjs", "profJ", " prouj", " probj", "prejo", " prok", "sujet", "produb", "promz", "coJ", "Projs", " projc", "Prod", "proz", "proje", "parjc", "roujc", "profj", "rouJ", "propj", "prez", "perjp", "propjo", "suj", " proz", "Projo", "conJ", "projet", "perjs", "PROj", "suje", "perz", "projc", " proaj", " proje", "prob", "upjo", "prok", "produjc", "PROJ", "projp", "produJ", "proaj", "produuj", "conjp", "upbj", "rouaj", "prej", "roujs", "roud"], "desc": ["doc", "loc", "name", "sup", "sc", "dev", "ca", "info", "dec", "dep", "div", "str", "rc", "rec", "summary", "description", "text", "contract", "txt", "dist", "esc", "dc", "comment", "sub", "anc", "asc", "struct", "sec", "attr", "Description", "config", " description", "details", "neg", "id", "des", "obj", "out", "def", "pro", "Desc", "de"], "javaProject": [" javaPlugin", "jaModule", "jarProject", " javaFolder", " javaUnit", "jarServer", "pythonModule", "pythonServer", "nativeFolder", "nativeApp", "JavaUnit", "JavaApp", "jaFolder", "JavaFolder", "jarFolder", " javaModule", " javaApp", "jaUnit", "pythonProject", "pythonFolder", "javaFolder", "javaServer", "nativeProject", " javaServer", "javaUnit", "rubyFolder", "jaProject", "javaPlugin", "JavaPlugin", "rubyProject", "JavaProject", "jarModule", "javaApp", "JavaModule", "rubyApp", "rubyUnit", "javaModule", "nativePlugin"], "srcFolder1": ["rcFolder2", "rcFolder0", "rcFolderOne", "rcDirectory1", "rcFolder81", "srcPath2", "rcFolder1", "srcFolderOne", "srcfolder2", "srcLocation1", "srcPath1", "rcDirectoryOne", "rcDirectory2", "srcfolder0", "srcFile2", "srcLocation0", "srcPathOne", "srcDirectory0", "srcPath0", "srcFolder0", "srcfolderOne", "srcFile81", "srcDirectory1", "srcLocation2", "srcDirectory2", "srcFolder81", "rcDirectory0", "srcfolder81", "srcDirectoryOne", "srcFileOne", "srcfolder1", "srcFile1", "srcDirectory81", "rcDirectory81"], "srcFolder2": ["rcFolder2", " srcfolder1", "rcDirectory1", "rcFolder1", "srcArea4", "srcfolder2", "srcFolder4", "srcDirectory4", "rcDirectoryTwo", "srcFile5", "rcDirectory2", "srcFolder5", "srcArea1", "srcAreaTwo", "srcfolderTwo", "srcfolder5", "srcFile2", "srcDirectoryTwo", "srcArea2", " srcfolderTwo", "rcDirectory5", " srcFolder4", "rcDirectory4", "srcDirectory1", " srcfolder2", " srcfolder4", "rcFolder4", "srcDirectory2", " srcFolderTwo", "srcFileTwo", "srcFolderTwo", "rcFolder5", "rcFolderTwo", "srcfolder4", "srcfolder1", "srcFile1", "srcDirectory5"], "classpathEntries": ["classpathAddries", "classPathAddry", "classpathEntEntry", "classPathAddEntry", "classpathEnrs", "classpathEnories", "classpathentry", "classpathEntryrys", "classPathAddrys", "classpathEntories", "classnameEntrys", "classpathentEntry", "classPathEntries", "classpathAddrys", "classpathEntryry", "classnameEnrys", "classpathEnries", "classpathentrs", "classnameEnrs", "classpathAddEntry", "classpathEntryries", "classPathAddries", "classnameEntries", "classpathEntryrs", "classPathEntEntry", "classnameEntrs", "classpathentries", "classPathEntry", "classpathEnrys", "classpathEntry", "classnameEnries", "classpathAddry", "classPathEntrys", "classnameEntories", "classpathEntryEntry", "classnameEnories", "classpathEntrs", "classpathentrys", "classpathEntryories", "classpathentories", "classpathEntrys"], "binFolder": ["winUrl", "workDir", "resultLoop", "binfolder", "winDirectory", "baseProject", " binLoop", "winfolder", "binDir", "workProject", "baseLoader", "workfolder", "binDirectory", "binaryUrl", "binaryProject", "baseFolder", "binaryFolder", " binLoader", "binaryDir", "binLoop", "resultUrl", "baseDir", " binfolder", "resultfolder", "binaryDirectory", "binLoader", " binDirectory", "workFolder", "binaryLoop", "binProject", "winFolder", "basefolder", " binUrl", "binaryLoader", "binUrl", "binaryfolder"], "testFolder": [" testfolder", "testfolder", "matchFolder", "mainfolder", "matchPath", "resultLoop", "mainFolder", " testLoop", "mainLoop", "matchOrg", "resultDirectory", " testOrg", "resultPath", "resultOrg", "mainDirectory", " testDirectory", "resultfolder", " testPath", "testPath", "testOrg", "testLoop", "testDirectory"], "resultFolder": ["returnLayer", "testfolder", "resultSection", "ResultDirectory", "resultDirectory", "returnFolder", "messageLayer", "returnPath", "testingSection", "resultPath", "messageFolder", "messagePath", "ResultLayer", " resultSection", "testingfolder", "testingFolder", "resultfolder", "ResultFolder", "testSection", "returnDirectory", " resultLayer", "resultLayer", "ResultPath", "testingLayer", "testLayer", " resultfolder", "messageDirectory"]}}
{"id1": "14324112", "id2": "14473711", "code1": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "code2": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "label": 1, "substitutes": {"innerProcess": ["innerprocess", "middleAccept", " innerMethod", " outerMethod", " innerAccept", "middleMethod", "middleprocess", "innerMethod", " outerAccept", "innerAccept", " innerprocess", "middleProcess", " outerProcess", " outerprocess"], "curi": ["luni", "numi", "lciri", "cuid", "Ciri", "biri", "lcri", "bURI", "cuni", "nuri", "lumi", "cui", "ctiri", "cacheuri", "funi", "cdu", "fri", " cuni", "furi", "CURI", "ctURI", "requuni", "ciri", "cURI", "requiri", "cturi", "luid", "ucURI", "buri", " cdu", "cacheui", " cui", "Cui", "cachedu", "cdirectory", " cuid", "requumi", " cURI", "ctuid", "lri", " cdirectory", "ucuri", "uciri", "lcui", "fURI", "lURI", "liri", "Cri", "fcri", " couri", "ldirectory", "lcURI", "Curi", " ciri", "fcumi", "firi", "Couri", "cacheURI", "Cdu", "cumi", "bdirectory", "ucuni", " cri", "lcuri", "couri", "luri", "requuri", "fui", "fcURI", " cumi", "lcouri", "cri", "fcuri", "nri", "nURI"], "maxsize": ["axize", "axsize", "totalsize", "Maxsize", "MaxSIZE", " maxSIZE", " maxname", "lastsize", "minSize", "defaultsize", "axSize", "MAXname", "MaxSize", " maxscale", "lastSize", "totalize", "maxname", "totalscale", "MAXSIZE", "minsize", "maxSIZE", "maxaddress", " maxSize", "Maxscale", "Maxname", "maxSize", "maxscale", "lastaddress", "minaddress", "Maxize", " maxaddress", " maxize", "defaultize", "MAXsize", "maxize", "defaultSize", "totalSize", "MAXSize"], "regexpr": ["replayor", "rerePr", "perepr", "regexpl", "pegexPr", "REgexr", "regexpp", "refgexpp", "regexexpr", "regexpect", "requpr", "refgexPr", "regexPR", "refgexpl", "egexpr", "egexPr", "rentaxexpr", "rereexpr", "reqor", "pegexexpr", "rerePR", "regexr", "rerexpr", "replaypt", "reuxpr", "rentaxPR", "replexexpr", "requpect", "REgexpr", "reuxpl", "REqpr", "egexps", "replexPR", "replaypr", "equpect", "REgexor", "regexpt", "perePR", "rerexps", "requPr", "rexpr", "resexPr", "reuxPr", "REgexpt", "replexpl", "refplexpp", "pereexpr", "resexps", "regexps", "REqor", "refplexpr", "refgexpr", "resexpr", "refplexpl", "rexpl", "rerexPr", "replexpr", "regexPr", "rentaxpr", "reuxpp", "REqpt", "pegexpr", "rexPr", "replexPr", "refplexPr", "resexpect", "replexpp", "rerexpect", "reqpr", "rerepr", "pegexPR", "egexpect", "perePr", "rexpp", "requps", "regexor", "replayr", "equps", "equPr", "equpr", "reqr", "rentaxPr", "REqr", "reqpt"], "cs": ["ts", "cn", "cos", "sc", "TS", "ds", "ca", "GC", "bs", "ences", "ins", "acks", "sync", "ns", "cms", "ics", "str", "ec", "pc", "lc", "ls", "cells", "cache", "css", "cr", "rs", "wcs", "ras", "ks", "cc", "ci", "ctx", "qs", "cf", "js", "ces", "spec", "ch", "cl", "gs", "ps", "c", "ce", "acs", "cks", "tc", "coll", "cas", "cm", "mc", "CS", "ches", "cons", "ms", "cp", "cus", "fs", "Cs", "acts"], "digest": ["signEST", "signusher", "returnEST", " diger", "DigEST", "diggest", "Digester", "Digusher", " digusher", "shaher", "shaest", "returnester", "digester", "digEST", "returnest", "signester", "shaer", " digEST", "digher", "returngest", "diger", "digusher", "Diggest", "Diger", "signest", "Digher", "shaEST", " digester", "Digest", " diggest", " digher"], "s": ["sl", "su", "f", "si", "session", "g", "groups", "services", "sets", "sync", "p", "ns", "str", "summary", "ls", "cells", "u", "b", "w", "sv", "l", "r", "single", "o", "lines", "strings", "d", "i", "S", "ws", "t", "js", "h", "v", "n", "ps", "details", "c", "params", "states", "sb", "ss", "ms", "string"], "m": ["bm", "gm", "f", "machine", "rm", "g", "p", "arm", "im", "b", "text", "imm", "am", "M", "wm", "mac", "l", "r", "dm", "ym", "um", "sm", "i", "d", "mo", "t", "h", "tm", "v", "mi", "n", "mm", "pm", "cm", "mc", "fm", "ms", "nm"]}}
{"id1": "6470716", "id2": "16557837", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "label": 1, "substitutes": {"st": ["est", "const", "f", "s", "sc", "put", "pt", "ct", "ist", "inst", "ast", "sth", "str", "fe", "class", "ste", "ld", "sts", "ust", "ST", "Str", "r", "fr", "std", "d", "t", "tt", "struct", "St", "sta", "stage", "cl", "code", "id", "src", "sb", "www", "sf", "ost", "stress", "ft", "string", "start", "rest"], "url": ["ul", "connection", "open", "sl", "f", "loc", "org", "fl", "ur", "gl", "stream", "web", "download", "pl", "log", "base", "ssl", "ll", "ls", "bb", "html", "b", "user", "blog", "page", "zip", "l", "bug", "err", "fr", "address", "Url", "URL", "build", "source", "feed", "image", "or", "hub", "path", "cl", "uri", "server", "http", "file", "id", "impl", "tool", "www", "coll", "bel", "host", "link", "string", "ob"], "fis": ["fiss", " fris", "afis", "lils", "flils", "bos", "FIS", "FIs", "flis", "fIs", "bi", "afiss", "afos", "afIs", "fi", "fips", "Fis", "lris", " fIS", " fi", "fli", "fliss", "fils", " fips", "Fiss", "bis", "flris", "zIS", " fiss", "Fips", " fils", "fris", "Fos", "Fris", "liss", "flIs", "zips", "zris", "fIS", "lis", "flos", "biss"], "zis": ["Ziss", "zipits", "zeisa", " zbis", "zisa", "Zis", "zipois", "zipisi", " zi", "zenisi", "zenais", "zipais", "ezIS", "zisi", "ziss", "zeis", "Zais", "zipis", "qi", " ziss", " zisi", "zeIS", " zIS", "ezips", "zois", " zits", " zisa", "qiss", "zIS", "zi", "zenis", " zais", "qbis", "ezisa", "zits", "zenois", "qis", "zips", "zeips", "ezis", "zbis", "zipi", "zipiss", " zois", "zipbis", "Zits", "zais", " zips"], "entry": ["nt", "reader", "extra", "si", "archive", "session", "auto", "ries", "ident", "info", "se", "ge", "country", "ie", "rc", "match", "lc", "Entry", "part", "inner", "je", "sea", "zip", "r", "ace", "line", "e", "cell", "key", "la", "address", "fr", "row", "comment", "dc", "parse", "image", "cat", "feed", "inc", "or", "spec", "object", "sec", "next", "enter", "li", "pe", "in", "file", "index", "ry", "result", "obj", "record", "cel", "exp", "ent", "de", "element"], "count": ["offset", "name", "_", "current", "depth", "allow", "type", "load", "en", "counter", "ind", "log", "base", "add", "more", "check", "cache", "size", "part", "line", "val", "max", "buffer", "list", "Count", "i", "limit", "feed", "use", "child", "parent", "sum", "default", "number", "read", "code", "c", "file", "id", "index", "len", "skip", "length", "write", "start", "end"], "data": ["reader", "error", "batch", "body", "results", "p", "info", "load", "str", "zero", "shift", "cache", "text", "size", "bytes", "content", "d", "buffer", "i", "image", "block", "feed", "value", "read", "number", "raw", "empty", "code", "DATA", "a", "len", "message", "result", "dat", "input", "length", "area", "alpha", "string", "start", "buf"], "fos": ["efosh", "fol", "fosh", "zol", "dfosi", "foses", "zOS", "efoses", "frosh", "Fol", "FOS", "fOS", "efos", "dfosh", "froses", "fosi", "znos", "fnos", "dfoses", "fros", "flol", "flnos", "dfos", "frosi", "efosi", "Fos", "flOS", "flos", "zos", "Fnos"], "dest": ["prop", "const", "cdn", "loc", "sup", "later", "slice", "dev", "stream", "cont", "sync", "comb", "di", "die", "inner", "output", "txt", "img", "done", "zip", "trans", "writer", "coord", "dist", "temp", "std", "dc", "test", "style", "source", "wh", "outer", "exit", "sum", "default", "south", "wb", "transform", "src", "des", "Dest", "flash", "result", "target", "out", "dat", "home", "desc", "de", "end", "tmp", "rest"]}}
{"id1": "22503685", "id2": "19276022", "code1": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 1, "substitutes": {"readGeoParserResult": ["readGeoParserOutput", "readGeoReaderResult", "readGeoWalkerResult", "readGeoReaderResults", "readGeoParserReport", "readGeOReaderResult", "readGeoparserResults", "readGeOParserOutput", "readGeOParserReport", "readGeOReaderOutput", "readGeoWalkerOutput", "readGeoParserResults", "readGeOParserResult", "readGeOParserResults", "readGeOReaderReport", "readGeoparserReport", "readGeoReaderReport", "readGeoReaderOutput", "readGeOReaderResults", "readGeoparserOutput", "readGeoparserResult", "readGeoWalkerResults", "readGeoWalkerReport"], "recordContent": ["reportBody", " recordMessage", "recordText", "RecordBody", "RecordContents", "resourceContents", "RecordContent", "recordBody", " recordBody", "reportMessage", "recordContents", "recordMessage", "RecordText", " recordFile", "resourceContent", " recordText", "RecordMessage", "resourceText", "reportContent", "reportText", " recordContents", "recordFile", "RecordFile", "resourceFile"], "getGazeteerIds": ["getGazeteerIdes", "getGazeteersIders", "getGazeteerHosts", "getGazeteerLogls", "getGazeteerLogings", "getGazeteerIdxs", "getGazeteerNeedes", "getGazeteersIdxs", "getGazeteerIdings", "getGazeteersLoges", "getGazeteersIdes", "getGazeteerIdls", "getGazeteerNeeds", "getGazeteerConfigxs", "getGazeteerLoges", "getGazeteerConfigls", "getGazeteerHostings", "getGazeteerTexts", "getGazeteerIders", "getGazeteerHosters", "getGazeteersLogings", "getGazeteersIdings", "getGazeteerTextxs", "getGazeteersLogs", "getGazeteerNeeders", "getGazeteerLogers", "getGazeteerLogs", "getGazeteersIds", "getGazeteersLogxs", "getGazeteerConfigings", "getGazeteerTextls", "getGazeteersLogers", "getGazeteersLogls", "getGazeteerTextings", "getGazeteerNeedings", "getGazeteerHostes", "getGazeteerLogxs", "getGazeteerConfigs", "getGazeteersIdls"], "ret": ["nt", "alt", "iter", "ext", "data", "f", "reg", "get", "opt", "arr", "g", "det", "array", "results", "info", "ut", "Ret", "vet", "Return", "str", "sys", "feat", "match", "fun", "status", "ll", "part", "RET", "Result", "repl", "r", "att", "reply", "list", "t", "hash", "rg", "default", "group", "rt", "len", "gt", "result", "res", "mem", "bf", "out", "replace", "ref", "usr", "rets", "re", "arg", "ft", "obj", "dict", "resp"], "retries": ["tried", "tries", "Retries", "altries", "altrying", "Retrys", "RETrying", "RETrys", " retry", "trys", "trying", "retrying", " retrying", "Retry", "retried", " retrys", "RETried", "Retrying", "retry", "altrys", "altried", "retrys", "RETries"], "reqPre": ["refPost", "respPre", " requestpre", "refpre", "requestPost", " requestPre", "requestPre", "reqPlan", "respPost", "resppre", "reqPref", "requestpre", " requestPost", " reqpre", "refPre", "reqpre", " reqPost", "respPlan", " requestPref", " reqPref", "requestPlan", "reqPost", "requestPref", "refPlan"], "outputFormat": ["outputType", "inputVersion", "reportSettings", "reportType", "inputFormat", "OutputType", "OutputSettings", "outputSettings", "outputVersion", "reportFormat", "inputType", "reportVersion", "inputSettings", "OutputVersion", "OutputFormat"], "doc": ["feature", "msg", "df", "f", "data", "git", "m", "body", "Doc", "info", "event", "str", "xml", "div", "page", "part", "b", "text", "di", "bug", "e", "Document", "md", "dr", "dc", "style", "parse", "db", "api", "project", "response", "h", "document", "tx", "date", "DOC", "http", "up", "file", "pos", "po", "resource", "result", "record", "coll", "mc", "home", "docs", "html", "desc", "bc"], "url": ["connection", "sl", "f", "data", "name", "org", "channel", "info", "web", "str", "base", "ssl", "html", "page", "b", "l", "r", "e", "address", "Url", "buffer", "URL", "entry", "source", "api", "request", "path", "response", "document", "uri", "server", "browser", "http", "file", "id", "resource", "result", "orb", "ref", "location", "string", "element"], "reader": ["iter", " readers", "er", "data", "handler", "stream", "info", "rc", "instance", "r", "writer", "parser", "rr", "buffer", "oder", "feed", "or", "read", "uri", "io", " parser", "http", "file", "resource", "input", "tx", "Reader"]}}
{"id1": "18202328", "id2": "4118412", "code1": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 0, "substitutes": {"register": ["save", "app", " reg", "login", "reg", "master", "activate", "create", "play", " registration", "load", "setup", " Register", "check", "user", "password", "bind", "init", "connect", "chain", "Register", "update", "config", " unlock", "Login", "auth", " regenerate", "start"], "session": ["connection", "lock", "login", "manager", "version", "machine", "socket", "channel", "ess", "master", "thread", "play", "remote", "python", "caster", "database", "sync", "state", "event", "Session", "ssl", "position", "conn", "user", "cache", "video", "section", " Session", "shell", "password", "client", "temp", "proxy", "gui", "service", "image", "child", "connect", "cookie", "port", "game", "h", "driver", "request", "parent", "config", "facebook", "view", "server", "group", "ession", "sa", "room", "person", "global", "browser", "script", "message", "sb", "resource", "window", "mc", "host", "security", "input", "slave", "use", "device", "site"], "username": ["localhost", "ame", "profile", "login", "name", "phone", " nickname", "email", "database", "seed", "minecraft", "monitor", "verb", " password", "user", "text", "Password", "term", "account", "password", "address", "subject", "crypt", "secret", "nick", "source", "ername", "sword", "mobile", "driver", "path", "phrase", "filename", "property", "url", "character", "attribute", "Name", "hello", "uri", "person", "duration", "title", "prefix", "word", "message", "users", "uid", "token", "mother", "host", "voice", "length", "auth", "string", "NAME", "amer", "steam"], "verificationKey": ["vermentKEY", "vermentSecret", "verificationSecret", "significationKey", "validificationPoint", "verifyPoint", "signationKEY", "significationKEY", "verationKEY", "verifyingPoint", "validifyingKey", "vermentkey", "verationKey", "verationSecret", "verifyingkey", "validificationKey", "verificationkey", "verifyingSecret", "validifyingkey", "verifyKey", "validificationkey", "verifyingKey", "verifySecret", "signationSecret", "verifykey", "verationkey", "verifyingKEY", "validificationSecret", "significationSecret", "signationKey", "significationkey", "verationPoint", "verificationPoint", "signationkey", "verificationKEY", "vermentKey", "validifyingSecret", "validifyingPoint"], "salt": ["Salt", "sehash", "suffhash", "sort", "setsALT", "seALT", "setsort", "setsodium", "sealt", "sSalt", "suffALT", "sodium", "seSalt", " sALT", "SSalt", "suffSalt", "SALT", "shash", "suffalt", " sort", "sALT", " sodium", "Shash", "setsalt"], "hash": ["name", "version", "hed", "pool", "array", "hex", "log", "match", "html", "cache", "user", "text", "output", "mac", "her", "kh", "query", "password", "key", "address", "secret", "crypt", "buffer", "build", "square", "h", "url", "sum", "number", "memory", "message", "sha", "result", "input", "ash", "host", "total", "header", "auth", "Hash", "string"], "digest": ["dige", "hedested", "signEST", "digit", " digests", "DigEST", "diggest", "Digester", "biggest", "digested", "hedEST", " dige", "defEST", "signests", "bigested", "digester", "bigester", "digEST", "Dige", "bigest", "logit", " digger", "logester", "digger", "hedester", "defe", " digEST", "Digested", "signested", "Digger", "logest", "Diggest", "logger", "signest", "defester", "Digit", " digit", "digests", "hedest", " digested", "defest", "Digests", " digester", "Digest", " diggest"], "nameChars": [" nameCharARS", "namechARS", "namechases", "nameChararts", " nameChararts", " nameCharts", "nameChacters", "nameCharts", "nameCheats", " nameChARS", "nameChases", "nameChears", " nameCharacters", "nameGracters", "nameChARS", "nameCharARS", "nameGrars", "namechacters", " nameCharars", " nameChats", "nameChats", "namechars", "nameCheARS", "nameCharacters", " nameChacters", "nameGrARS", " nameChases", "nameGrarts", "namechats", "nameCharars", "namecharts", "nameCheases"], "nameChar": ["Namechar", "idCharacter", "resourceChar", " NameCh", " nameText", " nameCh", "NameCharacter", "NameCtrl", " nameDir", "nameText", " NameChar", "NameCh", "idCh", " NameText", "resourcechar", "NameDir", "nameCh", " nameCharacter", "addressCh", "nameCharacter", " nameCtrl", " namechar", "idChar", "resourceCharacter", "idText", " NameCharacter", "NameChar", "addressCharacter", "nameDir", "nameCtrl", "addressChar", "addressCtrl", "resourceDir", "namechar"], "p": ["er", "f", "lp", "point", "q", "at", "s", "g", "py", "m", "pair", " P", "j", "pc", "per", "jp", "u", "b", "part", "br", "op", "l", "r", "cop", "pre", "e", "o", "client", "pp", "d", "i", "sp", "t", "api", "ap", "h", "v", "n", "ps", "pe", "up", "P", "a", "pa", "np", "po", "fp", "cp"], "player": ["connection", "players", "er", "league", "data", "name", "manager", "gamer", "machine", "aster", "master", " Player", "pool", "caster", "play", "g", "worker", "m", "party", "layer", "winner", "per", "class", "match", "position", "team", "part", "user", "video", "playing", "can", "l", "board", "e", "member", "played", "client", "live", "controller", "driver", "game", "parent", "media", "n", "server", "conference", "pe", "person", "owner", "pm", "script", "pro", "slave", "ace", "ler", "Player", "leader", "steam"], "c": ["abc", "cb", "arc", "f", "nc", "sc", "ca", "m", "C", "ct", "k", "enc", "ec", "pc", "rc", "cs", "lc", "cache", "conf", "cr", "l", "r", "o", "dc", "d", "cc", "ci", "ctx", "t", "cf", "chain", "h", "v", "cl", "config", "n", "cu", "ce", "tc", "con", "cm", "mc", "cp", "ac", "fc", "bc"]}}
{"id1": "3809087", "id2": "5951961", "code1": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getWave": ["readWave", "getWire", " getSound", "readwave", "getSound", "getwave", "newwave", "newWire", "newSound", "readSound", "newWave", "readWire", " getWire", " getwave"], "url": ["inf", "f", "loc", "name", "File", "fl", "ff", "web", "field", "fe", "base", "page", "b", "Feed", "F", "l", "r", "fn", "fr", "address", "Url", "fax", "URL", "source", "image", "feed", "path", "filename", "lr", "Ur", "uri", "http", "file", "wave", "word", "resource", "sf", "fp", "ref", "host", "string"], "Word": ["Msg", "Code", " word", "File", "Words", "wd", "Message", "Key", "Function", "string", "Length", "World", "Time", "Token", "words", "Field", "Frame", "Class", "F", "Letter", "Win", "Str", "Dir", "Term", "Part", "Tag", "Content", "Feature", "Language", "Url", "Eng", "Rule", "Text", "Line", "Wire", "Gender", "Name", "Work", "Folder", "Weight", "word", "W", "Path", "Writer", "Wave", "Stream", "Hack"], "FF": ["BB", "FH", "RC", "ff", "FB", "DF", "SF", "IFF", "FS", "FP", "Fi", "Client", "Fax", "FC", "IP", "Field", "FL", " ff", "Feed", "F", "ELF", "FA", "URL", "DC", "feed", "FD", "CC", "IF", "Folder", "P", "FW", "AF", "fd", "FE", "FILE", "TF", "fp", "FM", "LL"], "url2": [" url4", "l2", "URL1", "url3", "f1", " urlDB", "URL2", "URLTwo", "l3", "path2", "l1", "urlDB", "url1", "f4", "f2", "path1", " url1", "URLDB", " url3", "pathTwo", "pathDB", " urlTwo", "url4", "l4", "f3", "urlTwo"], "stream": ["reader", "pipe", "sl", "f", "ff", "channel", "socket", "handler", "thread", "slice", "ack", "stack", "field", "ssl", "loop", "w", "output", "roll", "loader", "video", "writer", "fr", "flow", "client", "temp", "row", "source", "live", "feed", "driver", "response", "path", "v", "sw", "context", "form", "raw", "server", "view", "io", "http", "in", "file", "wave", "transform", "impl", "draft", "src", "flash", "fd", "coll", "input", "host", "forward", "string", "Stream", "steam"], "Fdel": ["fdelete", "Fifin", " Fdestroy", "fdestroy", "fDel", " FDel", "FDel", "Ffin", " Ffin", " Fdelete", "Fidelete", "Fidestroy", "fdel", "Fidel", "Fdelete", "ffin", "FiDel", "Fdestroy"], "outstream": ["Outfile", " outStream", "outmodel", " outreader", "outputStream", "Outform", "outfile", "outStream", "inwriter", "inputlog", " outform", " outmodel", "inchannel", "outputmodel", "inmodel", "inlog", "outlog", "outputform", "outchannel", " outfile", "OutStream", "outwriter", "outputlog", "outform", "instream", "outreader", "inreader", "outputchannel", "outputreader", "outputwriter", "outputfile", "inputStream", "Outstream", "inputchannel", "inStream", " outwriter", "inputstream", "outputstream"], "bwriter": ["bwriters", "fbuilder", "bbreader", "bWriter", "Bwrite", " bwrite", "fwriter", "bbwriter", "bwr", "Bwriter", "bwriting", "bbWriter", "fbWriter", "Breader", " bwr", "fbwriters", " breader", "freader", " bwriting", " bbuilder", "outwriter", "bbwriters", "outreader", "breader", "Bbuilder", "bwrite", "fbwriter", "fbwrite", "bbuilder", "bbwriting", "bbwrite", "fwrite", " bwriters", "bbwr", " bWriter", "outwriting", "outwr"], "binput": ["binpos", "winwrite", "liblog", "biwrite", "bisplit", "outsell", " binstart", "biput", "binaryput", "binstart", " binset", "sincut", "binstop", "binaryset", "byteset", "bistop", "binarylog", " binpos", "bytesplit", "byteput", "outwrite", "output", "bincut", "binsell", "sinlog", "bipos", "biset", "winstart", "binset", " binsell", "bitwrite", "libcut", "bitput", " binwrite", "binwrite", "bitset", "outstart", " binstop", "sinput", " binsplit", "bitpos", "winput", "winsell", "libset", "binlog", "bytestop", "libput", "sinset", "binsplit", "binarycut"], "len": ["bin", "le", "lt", "iter", "sl", "elt", "data", "seq", "fl", "lim", "dl", "low", "el", "rev", "cap", "enc", "en", "label", "ann", "ie", "base", "fun", "lc", "lan", "ls", "part", "size", "num", "lon", "l", "line", "val", "pre", " lang", "lf", "la", "count", "limit", "n", "li", "split", "id", "pos", "hl", "lin", "fin", "coll", "Len", "length", "ln", "end"]}}
{"id1": "22441244", "id2": "18544890", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"send": ["open", "get", "create", "from", "set", "add", "text", "mail", "export", "address", "Send", "reply", "parse", "build", "submit", "exec", "delete", "transfer", "post", "message", "sent", "append", "execute", "write", "start", "end"], "hsession": ["HSessions", "openssession", "hsess", "opensessions", "hsSession", "hmession", "hhsession", "hhessions", "hession", "hsort", "hessions", "HSsession", "hmsession", "HSSession", "hsessions", "hhSession", "hessession", "hSession", "opensort", "hmSession", "hhess", "opensession", "hhort", "HSession", "opensSession", "hhession", "hssession", "hesort", "opensess", "hesession", "hmessions", "hesess"], "session": ["connection", "sl", "manager", "application", "state", "event", "class", "Session", "cache", "mail", "essions", "client", "proxy", "port", "project", "response", "parent", "context", "document", "server", "ession", "message", "chat", "resource", "host", "security", "site"], "repositoryName": ["repoositoryAddress", "repositoryFamily", "reposicleFamily", "repoositoryNAME", "repoitoryPath", "repositoryPath", "reposicleName", "repoitoryAddress", "reposessionNAME", "reposositoryNAME", "reposositoryPath", "reposicleAddress", "reposositoryName", "repoitoryEmail", "reposositoryFamily", "reposicationFamily", "reposicationName", "repoositoryName", "reposicationAddress", "reposositoryEmail", "repoitoryName", "repositoryAddress", "repoitoryFamily", "reposicleEmail", "reposessionName", "reposessionPath", "repositiveEmail", "repositoryNAME", "repositoryEmail", "repoositoryPath", "repositiveNAME", "reposositoryAddress", "reposicationEmail", "repoositoryFamily", "repositiveName", "reposessionEmail", "repoositoryEmail", "repoitoryNAME", "repositivePath"], "ideIdint": ["ideAuthints", "ideIdInt", "ideNameint", "ideidints", "IDEIdints", "ideIdints", "ideTimeInt", "ideAuthn", "ideidInt", "ideInn", "ideInint", "IDEidInt", "IDENameout", "IDEidint", "ideTimeout", "IDEIdInt", "ideIdout", "ideNameInt", "ideidn", "IDEIdout", "IDEidints", "IDENamenumber", "ideidint", "ideInfoout", "ideIdnumber", "IDENameint", "ideTimeint", "IDEIdn", "ideInfoint", "IDENameInt", "IDEIdnumber", "ideAuthint", "ideNameout", "ideInInt", "IDEIdint", "ideNamenumber", "ideAuthInt", "ideInints", "IDEidn", "ideInfonumber", "ideIdn", "ideTimenumber", "ideInfoInt"], "to": ["office", "name", "phone", "TO", "options", "from", "settings", "To", "top", "summary", "with", "mail", "by", "account", "client", "address", "reply", "sub", "source", "template", "mobile", "response", "tel", "uri", "title", "prefix", "message", "po", "token", "target", "about", "contact", "location", "company", "site"], "cc": ["cb", "cn", "phone", "nc", "card", "sc", "cca", "ca", "from", "ct", "ck", "ec", "rc", "cs", "lc", "cr", "account", "password", "client", "address", "dc", "comment", "ci", "uc", "cf", "CC", "cl", "code", "c", "ce", "tc", "contact", "company", "ac", "cus"], "bcc": ["abc", "pck", " bc", " brc", "fck", "bbrc", "pc", " bce", "bce", " bck", "pcc", "brc", "fcc", "bbck", "abcc", "bbc", "pce", "frc", "abce", "abck", "bck", "fc", "bc", "bbcc"], "subject": ["phone", "reason", "head", "method", "state", "format", "description", "mail", "content", "reply", "comment", "sub", "Subject", "template", "ject", "request", "response", "object", "filename", "uri", "author", "title", "prefix", "message", "header", "host", "username"], "body": ["connection", "lock", "data", "tree", "name", "reason", "how", "string", "plain", "base", "summary", "description", "part", "text", "inner", "wrapper", "content", "zip", "left", "line", "shell", "password", "normal", "secret", "comment", "style", "source", "template", "money", "response", "bound", "object", "foot", "url", "code", "view", "empty", "pass", "Body", "function", "message", "header", "resource", "length", "html", "media", "pod"], "attachments": ["embedings", "attachents", "messents", "embedment", "attachings", "Attachings", "embedments", "Attachents", "Attachments", "messment", "embedents", "Attachment", "messings", "messments"], "isHtml": ["isPhttp", "isChtml", "isPhhtml", " isChhtml", "isCtml", "isHive", " isHttp", " isWhail", "isWhtml", " isWhive", "isWhail", "isChhtml", " isWhhtml", "isCive", " isHail", "isCail", "isHhtml", "isChive", "isPhtml", " isWhtml", " isChail", "isHaail", "isWhive", "isChail", "isHattp", " isChtml", " isHhtml", "isHatml", "isHahtml", "isChttp", "isHail", "isWhhtml", " isHive", " isChttp", "isPhail", "isHttp"], "charset": ["charsET", "chaseset", "chasET", "chanset", "chaseting", "CharsET", "chasets", "chanspace", "chARSetting", "chearsete", "chansetter", "chearspace", "cheanset", "chansete", "chearsetter", "chARSET", "chARSeting", "Charseting", "charsetting", "chashesetter", "chARSets", "cheansET", "chackset", "charsetter", "chansetting", "chasheset", "chacksET", "chasetter", "Charsetting", "chaset", "cheansete", "chasetting", "cheansetter", "Charsets", "chacksetting", "chaseseting", "chaspace", "cheanspace", "chARSete", "Charset", "chearset", "charsets", "chearsET", "chashesET", "chansET", "cheansetting", "charsete", "charseting", "chARSet", "charspace", "chashespace", "chacksete", "chasesetting", "chearsetting", "chasesET"], "headers": ["mails", "options", "groups", "settings", " cookies", "status", "files", "content", "authors", "lines", "writers", " messages", "strings", " emails", " recipients", "classes", "comments", "names", "errors", "metadata", "params", "users", "header", "properties", "types", "ers"], "priority": ["phone", "reason", "language", "theme", "state", "mode", "status", "class", " title", "lang", "reply", "secret", "comment", "template", " severity", " recipients", "quote", "comments", "level", "code", "date", "author", "title", "prefix", "queue", "security", "length"], "email": ["office", "gmail", "ext", "data", "name", "oe", "ilo", "note", "create", "el", "auto", "em", "info", "install", "event", "en", "xml", "Email", "letter", "base", "ssl", "model", "text", "mail", "output", "online", "article", "entity", "zip", "line", "engine", "export", "account", "password", "e", "address", "external", "service", "fax", "test", "lex", "business", "template", "generic", "example", "response", "object", "url", "update", "enter", "document", "view", "server", "default", "core", "pm", "message", "contact", "result", "international", "print", "html", "liner", "element", "username"], "user": ["connection", "er", "profile", "data", "name", "type", "creator", "info", "ip", "me", "plugin", "model", "people", "account", "e", "member", "client", "User", "mobile", "object", "role", "character", "friend", "USER", "consumer", "author", "person", "id", "users", "uid", "resource", "token", "unknown", "string", "use", "username"], "identity": ["ethnicifier", "identication", "authorentity", "authority", "idITY", "ethnicity", "electricITY", "authoronymous", "authentonymous", "idifier", "authorities", "entityity", "IDENTity", "personITY", "idity", "personentity", "IdentITY", "authorication", "ethniciciary", "identiciary", "electriconymous", "ethnicITY", "installITY", "Identity", "IDENTities", "IDENTITY", "personity", "entityifier", "installonymous", "electricity", "authentITY", "publicity", "authentization", "authoriciary", "idization", "ethnicentity", "electricentity", "identonymous", "installentity", "authentication", "authentity", "idication", "publicITY", "entityonymous", "publicentity", "identization", "Identities", "Idententity", "IDENTentity", "entityization", "ethnicication", "identITY", "publiciciary", "authorifier", "idonymous", "authentifier", "idententity", "authorITY", "identifier", "identities", "installity", "personifier"], "_returnPath": ["_correctId", "_returnMid", "_resultPath", "_responseType", " _returnTo", " _backHalf", "_resultTo", "_returnHalf", " _returnUrl", "_resultHalf", "_displayPath", "_displayPart", "_backHalf", "_responsepath", "_backpath", "_displayUrl", "_inputMid", "_returnNode", "_returnPart", "_backName", "_returnText", "_inputPath", "_backType", "_returnDirectory", "_displayNode", "_successText", " _backTo", "_addType", "_backPath", "_backPart", " _backUrl", "_relationPath", "_backUrl", "_successId", "_resultName", "_returnTo", "_addPath", "_correctText", "_successPath", "_replyUrl", " _backPath", "_relationId", " _backPart", "_returnType", " _backName", "_replyMid", "_returnId", "_replyNode", "_correctPath", "_returnUrl", "_inputUrl", "_backTo", "_returnpath", "_relationDirectory", "_successDirectory", "_replyPart", "_addpath", "_correctDirectory", " _returnHalf", "_replyPath", "_displayMid", "_relationText", " _returnName", "_responsePath", "_returnName", "_inputNode", " _returnPart"], "_from": ["_for", "placeowner", "workwho", "worksource", "blockFrom", "_From", "_with", "blockerror", " _error", " _source", "workfrom", "blockto", " _owner", "existingto", "_source", "_who", "existingfrom", "_error", "blockfrom", "_owner", " _for", " _with", "existingowner", "placefrom", "workto", " _who", "placefor", " _From", "placeto", "existingfor"], "_replyTo": ["_replyFrom", "_returnUrl", "_respondTo", "_returnTo", "_respondTO", "_returnOf", " _returnTo", "_addFrom", "_reasonUrl", " _replyTO", "_closeTO", "_replyUrl", " _returnTO", "_reasonTo", "_replyTO", "_addAddress", "_commentOf", " _replyFrom", "_reasonTO", "_respondAddress", "_commentFrom", "_respondFrom", "_commentTO", "_replyAddress", "_commentTo", "_respondPoint", " _returnFrom", "_replyPoint", "_replyOf", " _replyUrl", "_returnAddress", " _returnUrl", "_returnPoint", "_addTo", "_respondUrl", "_returnFrom", "_addPoint", "_returnTO", "_closeTo", "_reasonFrom", "_closeOf", "_closeFrom"], "_to": [" _target", "_target", " _about", "Jfrom", "Jabout", "Jtarget", "_about", "Jto"], "_cc": [" _cd", " _ce", " _cf", "_cd", "_ce", "_cf"], "_bcc": [" _abc", " _bce", "_rbcs", " _bcs", "_abce", "_rbc", "_sbcs", "_sbc", " _bc", " _abcs", "_abcs", "_sbcc", "_abc", "_rbce", "_bce", "_bcs", "_rbcc", " _abce", "_sbce", "_bc", "_abcc", " _abcc"]}}
{"id1": "21326424", "id2": "1986417", "code1": "    public APIResponse delete(String id) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/variable/delete/\" + id).openConnection();\n        connection.setRequestMethod(\"DELETE\");\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            response.setDone(true);\n            response.setMessage(\"Variable Deleted!\");\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Delete Variable Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    @Override\n    public void export(final Library lib) throws PluginException {\n        try {\n            new Thread(new Runnable() {\n\n                public void run() {\n                    formatter.format(lib, writer);\n                    writer.flush();\n                    writer.close();\n                }\n            }).start();\n            ftp.connect(host);\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                ftp.disconnect();\n                throw new PluginException(\"Unable to connect to FTP\");\n            }\n            ftp.login(user, pass);\n            ftp.pasv();\n            ftp.changeWorkingDirectory(dir);\n            ftp.storeFile(file, inStream);\n            ftp.logout();\n        } catch (SocketException e) {\n            throw new PluginException(e);\n        } catch (IOException e) {\n            throw new PluginException(e);\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"delete": ["save", "drop", "get", "edit", "stop", "complete", "create", "info", "destroy", "load", "release", "set", "reply", "del", "list", "clear", "request", "process", "update", "post", "resource", "Delete", "lete", "replace", "execute", "de", "remove"], "id": ["ids", "aid", "data", "name", "version", "error", "type", "method", "ident", "info", "variable", "str", "nil", "oid", "model", "query", "and", "key", "address", "kid", "i", "request", "path", "pid", "url", "code", "uri", "ID", "in", "Id", "uid", "resource", "sid", "string", "ip", "end"], "response": ["f", "data", "tree", "ception", "version", "error", "handler", "respond", "reference", "body", "array", "application", "Response", "status", "model", "description", "page", "user", "output", "instance", "success", "collection", "client", "reply", "proxy", "i", "service", "image", "value", "api", "example", "request", "object", "next", "v", "offer", "relation", "server", "uri", "route", "view", "http", "function", "index", "message", "result", "resource", "onse", "json", "resp", "site"], "connection": ["union", "volume", "manager", "version", "socket", "channel", "error", "session", "database", "handler", "creator", "application", "timeout", "event", "log", "position", "description", "conn", "cache", "inner", "section", "bug", "writer", "query", "collection", "translation", "client", "proxy", "connected", "entry", "condition", "image", "connect", "builder", "driver", "request", "or", "ion", "character", "url", "context", "config", "number", "relation", "server", "uri", "document", "io", "http", "c", "function", "index", "resource", "directory", "network", "Connection", "communication"]}}
{"id1": "11484416", "id2": "12172485", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"moveFile": [" movedDirectory", " moveDirectory", "MoveFiles", " movedFiles", "moveFiles", "MoveDirectory", " movedPath", " movedFile", " moveFiles", "movePath", "moveDirectory", " movePath", "MovePath", "MoveFile"], "orig": ["bin", "iter", "ext", "Orig", "f", "loc", "org", "origin", "archive", "ctr", "remote", "raf", "array", "ori", "info", "comb", "base", "prev", "copy", "img", "old", "coord", "raid", "dest", "imag", "temp", "rb", "exe", "proxy", "source", "real", "init", "image", "build", "bas", "original", "file", "folder", "id", "impl", "src", "transform", "frame", "coll", "home", "internal", "obj", "buf", "tmp"], "target": ["nt", "f", "current", "it", "force", "origin", "manager", "master", "archive", "arget", "remote", "reference", "auto", "to", "base", "prot", "format", "copy", "match", "eth", "dest", "temp", "this", "ret", "external", "source", "build", "template", "t", "project", "path", "parent", "object", "next", "platform", "original", "Target", "resource", "join", "result", "replace", "compatible", " Target", "tmp"], "buffer": ["bin", "iter", "uffer", "sequence", "data", "batch", "reference", "slice", "layer", "buff", "stack", "Buffer", "binary", "base", "position", "copy", "bb", "cache", "b", "bytes", "content", "address", "padding", "source", "block", "feed", "request", "url", "transfer", "read", "code", "raw", "null", "repeat", "file", "wave", "message", "frame", "header", "result", "resource", "input", "queue", "length", "write", "buf"], "bread": ["ffe", "rows", "bat", "fen", "batch", "robe", "piece", "fle", "ble", "fall", "good", "web", "rub", "div", "fe", "eb", "zero", "str", "fine", "fed", "bn", "loop", "bb", "die", "beat", "cook", "num", "zip", "wake", "bare", "key", "circ", "design", "bc", "abi", "meal", "feed", "cake", "raft", "brew", "choice", "fred", "food", "wen", "bee", "width", "hello", "inn", "knife", "buck", "grain", "sleep", "fee", "length", "fif", "rib", "four", "broken"], "fis": ["fiss", "lfos", "afis", "ufiss", "hIs", "fisa", " fisa", "his", "qils", "lfis", "fIs", " fIs", "fxIs", "fxis", "fxisa", "afiss", "afos", "afIs", "fxos", "qos", "fils", "hisa", "qiss", " fiss", "lfIs", "ufils", " fils", "lfiss", "qis", "ufis", "hos", "ufos"], "fos": ["infaos", " foss", "flens", "Foses", "foses", "flois", "fose", "flose", "Fose", "gros", "Fois", "Faos", "gis", "flaos", "Fros", " fose", "flors", "floses", "gos", "Fens", " foses", "Fis", "infos", "infois", "fors", "fros", "Foss", "goss", "foss", " fens", "Fos", " fros", "fois", "faos", "flos", "Fors", "fens", "infors"]}}
{"id1": "15745420", "id2": "12246545", "code1": "    private void download(String address, String localFileName) throws UrlNotFoundException, Exception {\n        String ext = G_File.getExtensao(address);\n        if (ext.equals(\"jsp\")) {\n            throw new Exception(\"Erro ao baixar pagina JSP, tipo negado.\" + address);\n        }\n        File temp = new File(localFileName + \".tmp\");\n        if (temp.exists()) temp.delete();\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            try {\n                URL url = new URL(address);\n                conn = url.openConnection();\n                in = conn.getInputStream();\n            } catch (FileNotFoundException e2) {\n                throw new UrlNotFoundException();\n            }\n            out = new BufferedOutputStream(new FileOutputStream(temp));\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n        } catch (UrlNotFoundException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        File oldArq = new File(localFileName);\n        if (oldArq.exists()) {\n            oldArq.delete();\n        }\n        oldArq = null;\n        File nomeFinal = new File(localFileName);\n        temp.renameTo(nomeFinal);\n    }\n", "code2": "    public void load(String url) throws IOException {\n        this.url = url;\n        int col = url.indexOf(':');\n        if (col > 1 && col < 5) {\n            load(new URL(url).openStream());\n        } else {\n            if (new File(url).exists()) {\n                System.out.println(\"Loading JAD from file : \" + url);\n                FileInputStream fin = new FileInputStream(url);\n                try {\n                    load(fin);\n                } finally {\n                    fin.close();\n                }\n            } else {\n                InputStream in = getClass().getResourceAsStream(url);\n                if (in != null) {\n                    System.out.println(\"Loading JAD from classpath : \" + url);\n                    load(in);\n                } else {\n                    throw new IOException(\"\\\"\" + url + \"\\\" was found in file system or classpath\");\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"download": ["save", "open", "data", "archive", " Download", "handle", "load", "gz", "dump", "release", "binary", "copy", "register", "output", "zip", "source", "process", "exec", " downloading", "update", "transfer", "Download", " upload", "upload", "append", " transfer"], "address": ["localhost", "region", "data", "name", "point", "email", "type", "remote", "reference", "array", "mode", "base", "position", "page", "output", "content", "ace", "key", "Address", "pointer", "service", "source", "image", "port", "request", "path", "object", "order", "attribute", "config", "number", "enter", "uri", "server", "route", "ress", "prefix", "index", "message", "resource", "target", "host", "location", "addr", "string", "ip"], "localFileName": ["localImageSize", "localFilenameNames", "localStreamname", "localStreamName", "localFilePath", "localSourceFileNames", " localPageSize", "localFilenameName", "localFilesInfo", "LocalSourceFileLocation", "globalFileName", " localFileType", " localPageInfo", "LocalFileType", "localFilenameType", "localfileNames", " localFilePath", "localFileLocation", " localFileInfo", " localFilename", "localFilesAddress", "localSourceFileLocation", "LocalFileNames", "localImageInfo", "globalSourceFileName", "localfileLocation", "localFilesPath", "LocalSourceFileType", "localSourceFileAddress", "localfileName", " localPlacePath", " localPageName", "localFileInfo", "localPlaceName", "localPagePath", "LocalFileName", "localDirAddress", "globalSourceFileAddress", "globalFilePath", " localFileLocation", "localPageSize", "localDirName", "localSourceFileInfo", " localPlacename", "localStreamPath", "globalFileAddress", "localPlacePath", "localPlacename", "localPageName", "localPagename", " localPlaceLocation", "localImageName", " localPlaceName", "globalFileInfo", "localFilename", "localFileType", "localDirPath", "LocalSourceFileName", "localFileAddress", "globalSourceFileInfo", "localFileSize", "globalSourceFilePath", "localSourceFileName", "localFileNames", "localfileType", "localFilenameLocation", "localSourceFilePath", "localSourceFileSize", "localPageLocation", " localPageType", "localDirInfo", "localStreamLocation", "localPageInfo", " localFileSize", "LocalFileLocation", "localFilesName", "localPageType", "localSourceFileType", "localImageType", "LocalSourceFileNames", "localPlaceLocation"], "ext": ["x", "extra", "app", "f", "data", "alt", "name", "type", "expl", "info", "ex", "enc", "str", "fort", "prot", "req", "format", "Ext", "text", "txt", "content", "EXT", "zip", "err", "xp", "dist", "xt", "test", "fx", "path", "config", "file", "word", "ect", "exp", "qt", "addr", "string"], "temp": ["full", "pipe", "lock", "er", "iter", "data", "f", "it", "loc", "Temp", "mount", "tp", "session", "stable", "emp", "p", "ex", "clean", "wp", "local", "base", "Tem", "ht", "cache", "wrap", "output", "wl", "txt", "w", "tem", "zip", "old", "porary", "this", "test", " temporary", "source", "template", "api", "t", "parent", "v", "form", "store", "server", "unit", "null", "empty", "flat", "original", "memory", "file", "folder", "c", "valid", "input", "fake", "home", "cp", "now", "tmp"], "out": ["connection", "bin", "lock", "login", "name", "socket", "s", "sync", "ex", "outs", "not", "In", "plain", "log", "ssl", "copy", "b", "again", "output", "w", "inner", "part", "Output", "writer", "line", "and", "err", "password", "o", "client", "off", "OUT", "key", "this", "call", "i", "cli", "lib", "image", "init", "inc", "or", "exec", "outer", "parent", "other", "server", "null", "io", "net", "file", "up", "prefix", "on", "con", "exp", "Out", "write", "obj"], "conn": ["connection", "nt", "open", "nn", "cn", "socket", "nc", "ct", "sync", "enc", "ll", "ssl", "b", "cache", "cmd", "l", "fr", "client", "Url", "URL", "ci", "init", "cli", "connect", "ch", "inc", "uc", "exec", "close", "config", "n", "conv", "server", "Conn", "c", "func", "impl", "coll", "ai", "con", "fp", "cm", "cp", "Connection", "ac", "obj", "act"], "in": ["connection", "reader", "bin", "lock", "isin", "login", "f", "data", "get", "it", "socket", "s", "ins", "pin", "sync", "cin", "min", "In", "is", "kin", "part", "inner", "again", "win", "by", "r", "din", "l", "IN", "client", "pull", "ini", "i", "cli", "source", "init", "image", "inc", "nin", "or", "lib", "exec", "n", "inn", "up", "id", "index", "lin", "input", "con", "diff", "ac"], "url": ["connection", "open", "sl", "cdn", "f", "loc", "channel", "socket", "layer", "web", "ll", "ssl", "base", "ls", "blog", "b", "l", "r", "client", "Url", "i", "URL", "source", "image", "db", "path", "n", "uri", "server", "http", "file", "impl", "www", "bel", "host", "rl", "string", "ob"], "buffer": ["offset", "bin", "reader", "border", "uffer", "iter", "sequence", "data", "batch", "slice", "reference", "layer", "buff", "Buffer", "binary", "position", "bb", "cache", "b", "bytes", "flush", "FFER", "row", "padding", "comment", "block", "value", "limit", "feed", "transfer", "read", "number", "null", "memory", "wave", "message", "uf", "queue", "input", "result", "pad", "length", "slave", "buf"], "numRead": ["numWrite", "nBuild", "numberBuild", "numberRead", "Numread", "nWritten", "NumWrite", " numBuild", "commonWrite", "commonRead", "NumReader", "nRead", "nWrite", "umWrite", "numread", "numberread", "umWritten", " numReader", "numberWritten", "nread", " numWrite", "NumRead", "commonWritten", "commonReader", "numBuild", "umRead", " numread", "NumWritten", "numReader"], "numWritten": ["numWrite", "multiwritten", "Numwritten", "numberRead", "multiWritten", "multiWrite", "multiWrit", "NumWrite", "numOutput", " numWrit", "numberWrite", "numberWritten", "numberOutput", " numWrite", "NumRead", " numwritten", " numOutput", "NumWritten", "numwritten", "NumWrit", "NumOutput", "numWrit"], "oldArq": ["OldAcquest", "oldDarq", "OldArch", "oldDarque", "oldParq", "oldArp", "OldAcqs", "OldArqu", "oldDarch", "oldARg", " oldParque", "oldParque", "OldARQ", "oldArQ", "oldAcqs", "oldParg", "OldArque", "oldArtque", "OldAcQ", "OldArquest", "oldAcquest", "OldArqs", "oldAcq", "oldARquest", "oldarg", "OldARch", "oldARch", "oldArque", "oldArg", " oldArg", "OldARp", "oldarq", "oldArtquest", "oldARqs", "oldAcque", "oldARque", "oldArqu", "OldArQ", "oldArquest", "oldArtqs", "oldarque", "oldARq", "OldArq", " oldParq", "oldArtQ", "OldAcq", "oldARp", "OldARq", "OldARqu", "oldarQ", "oldAcp", "oldARQ", "oldarqu", " oldParg", "oldArtq", "oldarch", "oldArtp", " oldArque", "OldArp", "OldARque", " oldArQ", "oldArch", "oldDarqu", "oldParQ", " oldParQ", "oldARqu", "oldArqs", "oldAcQ"], "nomeFinal": ["nomesfinal", "nomenFin", "nomefinal", "nomenFinal", "navefinal", " nomefinal", "nomesFin", "naveFinal", " nomeFin", " nomesFinal", "noefinal", "nukeFin", "Nomesfinal", "nomesFinal", " nomesFin", "nukeFinal", "nomenfinal", "NomeFinal", "Nomefinal", "NomesFinal", " nomesfinal", "nukefinal", "noeFinal", "nomeFin"]}}
{"id1": "14877116", "id2": "3184073", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"cpFile": ["cpCode", "cpFiles", "Copyfile", " copyfile", " cpCode", " copyCode", "cpfile", " copyFiles", " cpfile", " cpFiles", "CopyFiles", "CopyFile", "CopyCode", " copyFile"], "source": ["connection", "iter", "current", "ources", "name", "force", "self", "channel", "archive", "database", "slice", "remote", "seed", "from", "stream", "secure", "type", "reference", "se", "grade", "base", "ource", "component", "zip", "SOURCE", "client", "dest", "subject", "this", "service", "image", "template", "use", "project", "path", "parent", "object", "context", "url", "config", "document", "view", "server", "unit", "null", "route", "file", "scope", "ce", "Target", "scene", "table", "resource", "token", "Source", "host", "directory", "string", "start", "element", "node", "site"], "target": ["connection", "nt", "iter", "director", "current", "name", "it", "self", "origin", "force", "master", "archive", "arget", "database", "table", "reference", "remote", "tor", "type", "range", "to", "boot", "sync", "download", "base", "top", "component", "copy", "format", "ource", "output", "content", "alias", "root", "client", "dest", "external", "service", "proxy", "template", "port", "project", "path", "parent", "object", "next", "other", "url", "config", "tail", "server", "route", "null", "owner", "global", "file", "transform", "folder", "Target", "resource", "result", "host", "token", "home", "site"], "replace": ["multiple", "force", "place", "rm", "complete", "allow", "range", "change", "sync", "array", "placed", "only", "move", "hide", "match", "add", "copy", "inline", "share", "include", "repl", "align", "root", "reply", "reset", "fill", "stall", "delete", "other", "update", "store", "route", "protect", "repeat", "split", "same", "flash", "follow", "append", "cover", "compatible", "re", "rel", "insert", "write", "use", "apply", "remove"], "bufferSize": ["serverLen", "bufferCount", " bufferCount", " bufferSIZE", "byteCount", "flushSize", "serversize", "buffersize", "byteLen", "bufferLen", " bufferLen", " buffersize", "queueLen", "queueCount", "bytesize", "flushLen", "serverSize", "flushSIZE", "flushsize", "queueSize", "bufferSIZE", "queuesize", "serverSIZE", "byteSize"], "src": ["cur", "sl", "cb", "loc", "ources", "RC", "start", "socket", "archive", "gb", "sc", "stream", "sync", "secure", "inst", "gz", "proc", "sys", "rc", "rec", "ssl", "ource", "copy", "req", "zip", "fn", "ruby", "dest", "rb", "sq", "proxy", "sub", "ctx", "sh", "reflect", "url", "server", "rt", "ser", "in", "sr", "flash", "sel", "resource", "result", "Source", "input", "sb", "obj", "bc", "tmp"], "tarn": ["Tarn", "taran", "Tarm", "tron", "yarn", "wtaran", "trn", "ntaron", "tern", "taron", " tron", "ttann", " tann", " tarp", "Tann", "ttron", "tarm", " tern", "ntarp", "wtarn", "etreen", "yern", "ttarp", "Taran", "ttarm", " taro", " taran", "Trn", " trn", "thaur", "ttaron", "etann", "ttaur", "Tron", "ttarn", "wtern", " taur", "tann", "ttrn", "taro", "ntann", "tharo", "yaran", "etaran", " tarm", "wtarm", "treen", "Treen", " treen", "tharn", "ntarn", "ttern", "yarm", "tarp", "ttaro", "etarn", " taron", "thern", "taur"], "tardir": ["tardeddir", "tartir", "tardedir", "tarar", "Tardir", "tardsar", "tartpath", "sardsirt", "tardpath", "tardsdir", "sardsar", "tildart", "Tardpath", "sardar", "tardart", "Tartiri", "sardire", "tardire", "tardirt", "tarpire", "sardsir", "Tarddir", "tarpar", "Tardar", "tariri", "tardedpath", "tardiri", "tardsir", "tildiri", "tartire", "tardsire", "tardedirs", "Tardart", "tarpir", "tildar", "tardspath", "tarddir", "Tardirs", "tartar", "tardsirt", "tartart", "tildir", "Tardiri", "Tartpath", "tarart", "tardsirs", "Tartir", "sardsire", "Tartdir", "Tartar", "sardir", "tarir", "tartirs", "sardirt", "tartiri", "Tartirs", "tardirs", "tardar", "tarpirt", "Tartart", "tartdir", "tartirt"], "n": ["x", "nt", "nn", "rn", "cn", "nc", "sn", "un", "g", "m", "na", "j", "p", "dn", "ns", "k", "min", "en", "u", "conn", "num", "nu", "l", "fn", "e", "o", "mn", " i", "d", "i", "ne", "z", "pn", "v", "number", "nl", "nor", "norm", "ng", "N", "c", "in", "ni", "nw", "coll", "ln", "none", "nb"], "tar": ["Tar", "cos", "archive", "tif", "raf", "ca", "jar", "par", "gz", "copy", "di", "box", "cloud", "csv", "sv", "zip", "cr", "trans", "ar", "ra", "shape", "tf", "cro", "dest", "dr", "temp", "test", "buffer", "cat", "pack", "tan", "war", "shr", "tg", "large", "sum", "transfer", "file", "sr", "rar", "flash", "tc", "tr", "safe", "skip", "car", "sh", "tmp", "ray"], "bytes": ["pages", "vals", "values", "data", "blocks", "nets", "rows", "eps", "bs", "boot", "outs", "os", "reads", "cells", "items", "words", "les", "b", "ls", "files", "bits", "bles", "ops", "runs", "lines", "steps", "pieces", "ipes", "tes", "objects", "classes", "frames", "vs", "bps", "io", "ps", "keys", "seconds", "ones", "es", "out", "resources", "Bytes"], "readn": ["Readlen", "writeno", "writen", "readns", "runno", "runN", "findlen", "writeN", "passN", "passn", "Readl", "writene", "readN", "findN", "ReadN", "readl", "findn", "runns", "readlen", "passno", "runlen", " readlen", "readno", "writelen", "runn", " readN", " readne", "findne", " readl", "writens", "passns", "runl", "Readn", "readne"]}}
{"id1": "8132219", "id2": "823074", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyStream", "Copyfile", "copyFiles", " copyfile", " copyStream", "transferFile", "transferfile", " copyFiles", "transferStream", "CopyFiles", "CopyFile", "transferFiles", "copyfile", "copyStream"], "inFile": ["inputFile", "binFiles", "binPlace", "outFiles", "inPlace", "INfile", "infile", "inputfile", "outfile", " inSourceFile", "INFilename", "binFile", "inSourceFile", "INFile", "inFiles", " infile", "InSourceFile", "outPlace", "binfile", "INSourceFile", "inputFiles", " inFilename", "inFilename", "InFile", "InFilename", "Infile", "inputPlace"], "outFile": ["outFiles", "againFile", "infile", "outputFile", "outfile", "againfile", " outFiles", "inFiles", "outputPlace", " outFilename", " outfile", "outputFilename", "againFilename", "outPlace", " outPlace", "outputFiles", "outFilename", "outputfile", "inFilename", "againPlace"], "in": ["x", "reader", "bin", "connection", "f", "data", "name", "ins", "pin", "m", "In", "base", "is", "part", "inner", "again", "rin", "din", "work", "IN", "ini", "i", "source", "image", "inc", "like", "url", "config", "n", "io", "inn", "c", "as", "file", "id", "index", "a", "ic", "input"], "out": ["x", "bin", "ext", "data", "name", "version", "to", "p", "ex", "outs", "plain", "log", "copy", "conn", "w", "b", "output", "part", "cache", "user", "line", "writer", "dot", "o", "client", "OUT", "external", "call", "buffer", "image", "exec", "v", "default", "n", "null", "io", "c", "file", "prefix", "resource", "obj", "Out", "string", "write", "Output"], "inChannel": ["iniChannel", "INSocket", " inchannel", "INChannel", "sinFlow", "INChan", "inConnection", "outStream", " inConnection", "sinSocket", "outLanguage", "winStream", "inchannel", "INFlow", "sinChan", "winChannel", "inichannel", " inChan", "iniStream", "outchannel", "inFlow", "sinChannel", " inFlow", "outChan", "winchannel", "INchannel", "outConnection", "INConnection", "winLanguage", "inputChan", "inLanguage", "inputChannel", "inChan", "inputStream", "iniLanguage", "inputchannel", "inSocket", "inStream", "INStream", " inSocket"], "outChannel": ["inPath", "newStream", "againchannel", " outStream", "inConnection", "newChan", " outContext", " outConnection", "outContext", "outStream", "outputChan", "inchannel", "outPath", "againChannel", "againPath", "outchannel", "OutChan", " outChan", "outChan", "OutContext", "againChan", "OutStream", "outConnection", "Outchannel", "OutConnection", "outputchannel", "OutChannel", "inChan", "outputChannel", " outchannel", "newContext", "newChannel", " outPath"]}}
{"id1": "17791385", "id2": "11704429", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public void run() {\n        RandomAccessFile file = null;\n        InputStream stream = null;\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=\" + downloaded + \"-\");\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                error();\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                error();\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            }\n            file = new RandomAccessFile(destination, \"rw\");\n            file.seek(downloaded);\n            stream = connection.getInputStream();\n            while (status == DOWNLOADING) {\n                byte buffer[];\n                if (size - downloaded > MAX_BUFFER_SIZE) {\n                    buffer = new byte[MAX_BUFFER_SIZE];\n                } else {\n                    buffer = new byte[size - downloaded];\n                }\n                int read = stream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                status = COMPLETE;\n                stateChanged();\n            }\n        } catch (Exception e) {\n            error();\n        } finally {\n            if (file != null) {\n                try {\n                    file.close();\n                } catch (Exception e) {\n                }\n            }\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyStream", "Copyfile", "copyFiles", " copyfile", " copyStream", "transferFile", "transferfile", " copyFiles", "transferStream", "CopyFiles", "CopyFile", "transferFiles", "copyfile", "copyStream"], "src": ["inf", "sl", "sin", "loc", "sup", "s", "sc", "ins", "stream", "st", "ipl", "inst", "rc", "ls", "b", "files", "txt", "img", "dist", "dest", "back", "rb", "source", "image", "filename", "url", "config", "uri", "sit", "http", "file", "upload", "sel", "sb", "input", "resource", "obj"], "dst": ["fdst", "Dlt", "fdft", "pdfd", "dsts", " dsts", " ddest", "dft", " dlt", "fdfd", "pdsp", "dsp", "ddst", "ddest", "ddfd", "pdft", "pdst", "dlt", "fdsp", "Dst", "stdest", "Ddest", "stlt", "stst", "ddft", "Dsts", "dfd", "ststs", "ddsp"], "in": ["reader", "bin", "sin", "f", "login", "data", "socket", "ins", "pin", "m", "cin", "In", "is", "inside", "kin", "conn", "inner", "again", "rin", "win", "r", "din", "IN", "err", "pull", "ini", "i", "init", "inc", "nin", "h", "url", "n", "inn", "oin", "as", "file", "id", "impl", "lin", "input", "con", "ln", "gin"], "out": ["x", "bin", "ext", "f", "self", "at", "s", "sync", "ex", "outs", "plain", "copy", "conn", "w", "again", "output", "cache", "part", "writer", "line", "err", "o", "off", "client", "OUT", "temp", "i", "inc", "exec", "outer", "parent", "other", "n", "raw", "server", "post", "null", "io", "net", "file", "up", "exp", "Out", "obj"], "buf": ["bin", "cur", "cb", "bd", "seq", "data", "loc", "ff", "fl", "lim", "batch", "cap", "buff", "bh", "rc", "base", "bl", "bb", "b", "vec", "br", "bytes", "cmd", "val", "bag", "off", "rb", "buffer", "count", "cat", "ctx", "uc", "v", "raw", "c", "wb", "fd", "uf", "queue", "bf", "pad", "length", "fb", "bc"], "len": ["nt", "bin", "lt", "le", "sl", "f", "data", "name", "fl", "lim", "el", "rev", "cap", "en", "ind", "ll", "base", "lc", "ix", "part", "all", "size", "l", "line", "val", "err", "lf", "count", "i", "no", "cl", "n", "li", "c", "split", "pos", "fd", "lin", "fin", "Len", "length", "ln", "end"]}}
{"id1": "19113613", "id2": "20128728", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["save", "get", "archive", "rm", "create", "put", "type", "change", "sync", "p", "download", "opy", "move", "load", "Cop", "share", "zip", "clip", "cop", "paste", "cat", "Copy", "process", "delete", "update", "transfer", "ssh", "split", "clone", "upload", "replace", "cp", " cp", "write"], "in": ["reader", "bin", "connection", "login", "f", "data", "sin", "name", "get", "ins", "pin", "cin", "min", "In", "base", "plugin", "inside", "kin", "part", "inner", "again", "win", "old", "din", "work", "IN", "client", "this", "ini", "i", "image", "init", "inc", "project", "url", "update", "config", "n", "thin", "inn", "c", "as", "id", "index", "a", "ic", "lin", "on", "input", "token", "diff"], "out": ["x", "connection", "bin", "app", "ext", "outside", "name", "point", "self", "version", "at", "remote", "p", "ex", "outs", "one", "base", "page", "conn", "b", "again", "output", "cache", "vert", "goal", "part", "user", "line", "work", "root", "err", "dot", "o", "off", "client", "OUT", "this", "external", "call", "block", "image", "init", "inc", "project", "path", "exec", "object", "parent", "outer", "v", "other", "no", "n", "group", "null", "io", "net", "c", "up", "resource", "input", "with", "Out", "obj", "option"], "source": ["feature", "missing", "iter", "sin", "alt", "family", "name", "force", "origin", "type", "reference", "from", "secure", "base", "direction", "ource", "position", "component", "class", "status", "format", "size", "SOURCE", "dest", "subject", "secret", "service", "proxy", "project", "parent", "url", "attribute", "view", "uri", "unit", "route", "pe", "scope", "ce", "id", "prefix", "src", "resource", "Source", "internal", "use", "username", "site"], "target": ["wrong", "alt", "current", "name", "point", "force", "origin", "master", "arget", "reference", "detail", "top", "direction", "base", "format", "component", "output", "goal", "alias", "root", "dest", "address", "service", "cat", "template", "value", "project", "path", "parent", "pattern", "next", "url", "tail", "config", "route", "null", "Target", "prefix", "src", "resource", "about", "host", "token", "home", "site"], "files": ["pages", "f", "images", "data", "sections", "blocks", "s", "ins", "groups", "results", "Files", "cells", "items", "ls", "models", "obs", "features", "flows", "apps", "tools", "lines", "assets", "objects", "filename", "iles", "classes", "names", "ions", "keys", "jobs", "ports", "links", "users", "plugins", "resources", "docs", "fs", "children"], "file": ["le", "f", "data", "current", "name", "it", "File", "el", "layer", " File", "load", "fe", "local", "letter", "base", "binary", "per", "future", "page", "part", "b", "entity", "l", "line", "single", "e", "lib", "entry", "live", "child", "ile", "feed", "path", "filename", "object", "parent", "url", "uri", "unit", "folder", "id", "function", "item", "FILE", "resource", "dir", "fp", "directory", "string"], "inCh": ["INChannel", "INChan", " inChannel", "outCH", "InChan", "inch", "InCh", " inChan", "INCh", "outch", " inch", "Inch", "outChan", "inChannel", "INCH", "InCH", "inChan", " inCH", "outChannel", "InChannel", "inCH"], "outCh": ["outputCh", "outputChan", "outCH", "OutCh", "inch", "OutChan", "outch", "outChan", " outChannel", "inChannel", "Outch", "OutChannel", "inChan", "outputch", " outch", "outputCH", "outChannel", "inCH", " outCH", "OutCH"]}}
{"id1": "3558512", "id2": "6457199", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "label": 1, "substitutes": {"serialize": ["normalized", "erialize", "Serialized", "normalify", "serialify", "normalze", "erializable", "serialze", "finalze", "Serialze", "finalify", "normalize", "serialized", "erialze", "Serialize", "Serializable", " serialze", " serializable", "erialization", "Serialify", "finalize", "Serialization", "finalized", "serializable", "serialization", " serialization"], "out": ["bin", "data", "name", "pool", "archive", "ex", "outs", "gen", "dump", "copy", "page", "conn", "w", "loader", "output", "cache", "content", "writer", "err", "o", "client", "OUT", "temp", "buffer", "i", "source", "image", "png", "parent", "filename", "exec", "raw", "server", "io", "file", "up", "a", "report", "Out", "string", "obj"], "parser": ["reader", "Parser", "er", "lp", "manager", "master", "handler", "pillar", "worker", "seed", "p", "xml", "arser", "per", "base", "class", "plugin", "copy", "cache", "loader", "instance", "wrapper", "txt", "writer", "pp", "test", "parse", "tt", "builder", "parent", "system", "server", "pe", "file", "as", "up", "php", "rar", "upload", "ss", "cp", "processor", "pkg"], "on_disk": ["onnetdrive", "onbootdisk", "onnetspace", "on_demand", "onbookdisk", "onJdrive", "onbootlock", "on_storage", "off_file", "off_demand", "on_space", "on_file", "off_space", "onbootstorage", "onbookdelete", "onJlock", "onbookdrive", "off_lock", "onJdemand", "onnetfile", "onjdrive", "onJdisk", "onjfile", "onjspace", "on_lock", "onbootdrive", "off_disk", "on_delete", "off_drive", "onnetdisk", "off_delete", "on_drive", "off_storage", "onjdisk", "onnetdemand"], "in": ["reader", "bin", "connection", "login", "f", "data", "socket", "inas", "ins", "pin", "stream", "info", "min", "In", "kin", "copy", "conn", "inner", "again", "rin", "win", "din", "r", "IN", "ax", "o", "ini", "i", "source", "inc", "pass", "thin", "inn", "c", "file", "as", "lin", "input", "con", "ac"]}}
{"id1": "2221297", "id2": "1371265", "code1": "    public static String getURLContent(String urlToSearchString) throws IOException {\n        URL url = new URL(urlToSearchString);\n        URLConnection conn = url.openConnection();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) encoding = \"ISO-8859-1\";\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        StringBuilder sb = new StringBuilder(16384);\n        try {\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n                sb.append('\\n');\n            }\n        } finally {\n            br.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"getURLContent": ["getPageContents", "geturlcontent", "getStringcontent", "parseurlcontent", "parseurlBody", "parseURLBody", "getURLcontent", "parseurlContents", "getStringContent", "getPagecontent", "getStringContents", "getURLBody", "parseURLContents", "getPageContent", "geturlBody", "parseurlContent", "parseURLContent", "parseURLcontent", "getPageBody", "getStringBody", "geturlContents", "geturlContent", "getURLContents"], "urlToSearchString": ["urlToFindString", "urlTOFindArray", "urltosearchStr", "urlTOSearchStr", "urlTosearchString", "urlToFindSection", "urlTosearchStr", "urlToSearchSection", "urlTOSearchSection", "urltoSearchString", "urlTosearchArray", "urlToCreateArray", "urlToSearchArray", "urltosearchString", "urltoSearchArray", "urlToCreateSection", "urlTosearchSection", "urltosearchArray", "urltosearchSection", "urlToFindStr", "urlToCreateString", "urltoSearchStr", "urlTOSearchArray", "urlToFindArray", "urltoSearchSection", "urlToCreateStr", "urlTOFindSection", "urlTOFindStr", "urlTOSearchString", "urlToSearchStr", "urlTOFindString"], "url": ["connection", "job", "open", "sl", "cb", "f", "cur", "org", "ur", "web", "download", "jar", "str", "ll", "ssl", "base", "bb", "ls", "lc", "b", "log", "blog", "page", "zip", "l", "client", "Url", "URL", "db", "ch", "server", "uri", "http", "c", "file", "resource", "www", "host", "rl"], "conn": ["connection", "nt", "open", "cur", "cb", "loc", "cn", "socket", "nc", "g", "ct", "sync", "enc", "rc", "ssl", "conf", "err", "client", "dc", "connected", "cli", "db", "connect", "ch", "ctx", "api", "exec", "config", "conv", "n", "rt", "io", "Conn", "c", "http", "Config", "con", "host", "auth", "cp", "Connection", "act"], "encoding": ["decoding", " encoring", "encoded", "noder", " encoder", "enale", "Encoding", "encode", "loccode", "acoder", "engoding", "encoder", " encoded", "enoded", "Encatin", "acoding", "noding", "Encale", "decoder", "locoding", "acatin", " encatin", "enoding", "decoring", "encatin", "locoder", "encale", "locoded", "encoring", "engoder", "decoded", "engcode", "enoder", "acoded", "noded", "engoded", "Encoded", "engoring", "nale", "enccode", "Encoder"], "br": ["reader", "mr", "Br", "cb", "ob", "arr", "stream", "jar", "str", "bh", "bl", "bb", "b", "bridge", "img", "cr", "r", "err", "fr", "cro", "dr", "rb", "bar", "BR", "sp", "db", "hr", "ch", "lr", "browser", "ab", "http", "grab", "sr", "src", "bro", "tr", "result", "orb", "ref", "ber", "fb", "bc", "buf"], "sb": ["SB", "BB", " SB", "bm", "cb", "bd", "sg", "si", "lp", "bj", "sn", "gb", "bs", "buff", "bt", "eb", "lab", "bh", "xb", "binary", "ssl", "kb", "bb", "ls", "bot", "b", "mb", "erb", "bp", "ruby", "bc", "rb", "abb", "db", "lb", "builder", "bps", "sa", "ab", "wb", "nb", "obb", "src", "bsp", "bf", "sf", "amb", "fb", "pb", "ib", "ob"], "line": ["reader", "sl", "f", "data", "name", "char", "body", "str", "letter", "base", "lc", "inline", "part", "b", "text", "page", "content", "r", "l", "cell", "err", "lines", "key", "e", "lf", "row", "buffer", "i", "comment", "source", "feed", "Line", "response", "character", "cl", "next", "number", "code", "n", "c", "LINE", "word", "len", "pos", "lin", "out", "link", "string", "end"]}}
{"id1": "7458833", "id2": "4716110", "code1": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copyParseFileToCodeFile": [" copyParseFileToMapfile", " copyParseFileToMapFile", " copyParseFiletoCodeClass", " copyParseFileToOutputClass", " copyParseFiletoCodeFile", " copyParseFileTocodeFiles", " copyParseFileToMapFiles", " copyParseFiletoCodefile", " copyParseFileToOutputFile", " copyParseFileToCodeClass", " copyParseFileTocodeClass", " copyParseFiletoCodeFiles", " copyParseFiletoOutputfile", " copyParseFiletoOutputClass", " copyParseFileTocodefile", " copyParseFileToCodeFiles", " copyParseFileToMapClass", " copyParseFileToOutputfile", " copyParseFileToOutputFiles", " copyParseFiletoOutputFiles", " copyParseFiletoOutputFile", " copyParseFileToCodefile", " copyParseFileTocodeFile"], "in": ["reader", "bin", "login", "f", "get", "socket", "ins", "pin", "m", "stream", "cin", "min", "In", "is", "inside", "ls", "kin", "inner", "again", "rin", "win", "din", "r", "IN", "err", "pull", "ini", "i", "init", "image", "inc", "nin", "n", "read", "io", "inn", "oin", "up", "as", "id", "impl", "ic", "lin", "input", "con", "gin"], "out": ["bin", "ext", "socket", "sync", "ex", "outs", "one", "plain", "log", "conn", "user", "w", "output", "again", "inner", "cache", "writer", "work", "err", "o", "client", "OUT", "this", "i", "source", "image", "inc", "exec", "outer", "parent", "other", "n", "server", "post", "io", "net", "file", "up", "as", "exp", "Out"], "buffer": ["uffer", "iter", "sequence", "data", "channel", "batch", "slice", "reference", "array", "layer", "buff", "Buffer", "event", "binary", "base", "position", "cache", "capacity", "shape", "address", "padding", "count", "source", "limit", "feed", "request", "number", "document", "read", "server", "pause", "null", "raw", "duration", "wave", "uf", "queue", "input", "result", "pad", "available", "total", "string", "fb", "buf"], "length": ["full", "offset", "lock", "volume", "sequence", "point", "type", "range", "slice", "Length", "partial", "load", "match", "position", "ength", "bb", "part", "time", "size", "weight", "l", "line", "distance", "shape", "before", "address", "pull", "row", "count", "style", "block", "limit", "feed", "value", "path", "character", "url", "width", "level", "code", "number", "view", "repeat", "duration", "id", "index", "len", "total", "string", "start", "end", "ob"]}}
{"id1": "13644374", "id2": "5142039", "code1": "    public byte[] getBytesFromUrl(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toByteArray(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public static String uncompress(String readPath, boolean mkdir) throws Exception {\n        ZipArchiveInputStream arcInputStream = new ZipArchiveInputStream(new FileInputStream(readPath));\n        BufferedInputStream bis = new BufferedInputStream(arcInputStream);\n        File baseDir = new File(readPath).getParentFile();\n        String basePath = baseDir.getPath() + \"/\";\n        if (mkdir) {\n            String[] schema = readPath.split(\"/\");\n            String baseName = schema[schema.length - 1].replaceAll(\".zip\", \"\");\n            FileUtils.forceMkdir(new File(basePath + baseName));\n            basePath = basePath + baseName + \"/\";\n        }\n        ArchiveEntry entry;\n        while ((entry = arcInputStream.getNextEntry()) != null) {\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(basePath + entry.getName()));\n            } else {\n                String writePath = basePath + entry.getName();\n                String dirName = FilenameUtils.getPath(writePath);\n                FileUtils.forceMkdir(new File(dirName));\n                BufferedOutputStream bos = new BufferedOutputStream(FileUtils.openOutputStream(new File(writePath)));\n                int i = 0;\n                while ((i = bis.read()) != -1) {\n                    bos.write(i);\n                }\n                IOUtils.closeQuietly(bos);\n            }\n        }\n        IOUtils.closeQuietly(bis);\n        return basePath;\n    }\n", "label": 0, "substitutes": {"getBytesFromUrl": ["getbytesFormUrl", "getBytesFormString", "getBytesFromString", "getBytesFromRoute", "getbytesFormRoute", "getbytesFormString", "getbytesFormURL", "getBytesfromUrl", "getBytesfromRoute", "getBytesFormURL", "getBytesFromURL", "getBytesViaString", "getbytesFromUrl", "getBytesfromString", "getBytesViaRoute", "getBytesViaUrl", "getBytesFormUrl", "getBytesFormRoute", "getBytesfromURL", "getbytesFromRoute", "getbytesFromString", "getBytesViaURL", "getbytesFromURL"], "url": ["connection", "sl", "data", "loc", "name", "email", "ur", "method", "download", "str", "xml", "base", "page", "href", "l", "key", "address", "Url", "i", "URL", "buffer", "service", "source", "api", "request", "path", "server", "uri", "route", "http", "resource", "result", "host", "ref", "location", "json", "string"], "get": ["open", "start", "create", "method", "put", "handle", "body", "send", "load", "find", "set", "gets", "query", "e", "client", "pull", "call", "service", "i", "cli", "build", "parse", "api", "request", "Get", "exec", "like", "GET", "update", "read", "http", "resource", "execute", "use", "json"], "response": ["full", "connection", "f", "data", "tree", "error", "respond", "method", "body", "application", "received", "Response", "status", "page", "output", "content", "success", "e", "reply", "feed", "api", "request", "object", "document", "server", "http", "wave", "message", "result", "resource", "out", "report", "onse", "json", "resp"], "entity": ["connection", "data", "el", "body", "info", "event", "xml", "model", "page", "node", "output", "instance", "content", "ale", "collection", "e", "translation", "this", "entry", "image", "Entity", "api", "object", "environment", "document", "server", "null", "pe", "person", "http", "metadata", "file", "message", "action", "resource", "result", "security", "json", "ent", "element", "resp"]}}
{"id1": "255765", "id2": "160739", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"f": ["x", "inf", "df", "name", "ff", "self", "fen", "s", "g", "m", "p", "j", "fe", "fun", "b", "w", "rf", "F", "l", "r", "fn", "fi", "e", "tf", "fr", "lf", "fold", "this", "d", "fx", "feed", "t", "cf", "path", "h", "filename", "of", "v", "form", "n", "io", "flat", "c", "file", "function", "fa", "folder", "a", "fd", "bf", "sf", "fp", "fo", "fm", "ref", "fc", "fs"], "in": ["lock", "login", "data", "str", "vin", "is", "ssl", "b", "w", "win", "IN", "err", "d", "source", "t", "exec", "c", "it", "socket", "session", "g", "ins", "pin", "m", "fe", "inner", "rin", "init", "nin", "or", "thin", "up", "fa", "gin", "reader", "p", "cin", "In", "part", "with", "r", "ini", "image", "inc", "config", "n", "con", "serv", "connection", "bin", "isin", "get", "ex", "min", "gen", "rec", "again", "l", "din", "v", "pass", "inn", "a", "ic", "lin", "token", "input", "diff", "ac"], "cbuf": ["bault", "bcault", "bbull", "cbull", "bcurs", "CBuff", "rbux", "cbuu", "zbutf", "bcull", "dbuc", "bcuf", "CBuc", "bcux", "zbuu", "cbault", "cfuff", "buff", "dbuff", "rbul", "bbuff", "CBuf", "cfur", "cfuc", "rbbuf", "rbutf", "cburs", "rbull", "rburs", "zbuff", "ebutf", "cbur", "CBul", "ebuff", "ebuf", "rbuu", "dbuf", "bcul", "fbuc", "cbul", "rbuf", "cbuff", "bcuff", "bux", "rbault", "bburs", "cbutf", "fbbuf", "ebuu", "buf", "fbuf", "bcuc", "rbuff", "cbuc", "cbux", "dbur", "cfuf", "cfbuf", "bcur", "fbuff", "bbuf", "rbuc", "cbbuf", "zbuf"], "read": ["iter", "data", "name", "type", "put", "know", "only", "find", "reads", "orig", "loop", "w", "work", "val", "d", "buffer", "select", "want", "fill", "close", "update", "io", "cel", "length", "report", "print", "re", "end", "wait", "READ", "open", "it", "socket", "Read", "error", "allow", "g", "play", "stream", "se", "load", "en", "ind", "log", " write", "ok", "key", "bind", "call", "count", "parse", "build", "level", "oct", "id", "last", "record", "insert", "use", "start", "bit", "x", "reader", "ride", "un", "create", "send", "add", "check", " READ", "old", "r", "each", "ak", "seek", "run", "lex", "ing", "feed", "connect", "inc", "config", "raw", "valid", "full", "er", "readable", "y", "get", "q", "ack", "change", "sync", "k", "used", "hex", "rc", "text", "size", "num", "child", " Read", "reading", "view", "pass", "pe", "ink", "repeat", "index", "ed", "input", "ize", "skip", " reading", "sleep", "draw", "write"], "totRead": ["ntottReader", "tottDraw", "TotaRead", "ntottLoad", "tobyFind", "tollRead", "toyDraw", "totoRead", "TotLoad", "tottFind", "totaLink", "ntotLoad", "tollLoad", "octotoRead", "tottReader", "tcotLoad", "tntRead", "dotReader", "tottLength", "dotWrite", "totoUse", "tottClose", "dottFind", "ntottRead", "octotoWrite", "totalWrite", "totingGet", " totalLink", "totingSearch", "tottSearch", "tottedRead", "nottLoad", "dottLoad", "totLength", "tobyRead", " totalBuild", "ntotReader", "tollReading", "tottedWrite", "totalLoad", "totaReader", "TotSearch", "notLoad", "tochReader", "TottLoad", " totalRead", "tottAccept", "tottConnect", "totiRead", "towAccept", "tatWrite", "tatReader", "TottGet", "totGet", "tottRead", "TottReading", "totoWrite", "TottReader", "tazonClose", "totiBuild", "tetReading", "octotRead", "TottFollow", "tottFollow", "TotConnect", "TotReader", "notWrite", "tntReader", "octotLength", "totoSearch", "totoLength", "tntWrite", "totaBuild", "tatRead", "tottLoad", "intottRead", "totalAccept", "tottReading", "totingRead", "totFollow", "TotWrite", "totDraw", "tntLoad", "TottWrite", "totalRead", "towWrite", "toyRead", "dottUse", "totSearch", "tetLoad", "tottUse", "tottedFollow", "nottRead", "TottRead", "dottReading", "dotReading", "tcotClose", "TottSearch", "totoReading", "tobyUse", "totLink", "TotReading", "totalLink", "towReading", "ntottWrite", "TotGet", "tottedGet", "tetWrite", "totBuild", "tochWrite", "totoFind", "totReader", "totingConnect", "towRead", "totingFollow", "dotRead", "dottReader", "TotaWrite", "intottClose", "tobyLoad", "toyWrite", "totoConnect", "intotBuild", "totAccept", "intotRead", "tazonBuild", "notAccept", "dotLoad", "toyLoad", "totWrite", " totBuild", "TottConnect", "towLoad", "tochLoad", "tazonRead", "TotRead", "TotaLoad", " totWrite", "totoLoad", "totaLoad", "totiLink", "tottWrite", "totClose", "octotoLength", "dotFind", "tetRead", "intotLoad", "octotReading", "ntotRead", "tottBuild", "totalBuild", "towLength", "tollWrite", "tochRead", "octotoReading", "intotClose", "totaDraw", "TotaDraw", "totLoad", "totaWrite", " totalWrite", "nottWrite", "tazonLoad", "tcotRead", "totaRead", "TotDraw", "totingWrite", "tottGet", "totUse", "ntotWrite", "totConnect", "intottLoad", "intottBuild", "totFind", "totiWrite", "dottWrite", "octotWrite", "tatLoad", "notRead", "tcotBuild", "nottAccept", "dotUse", "totReading", "totaReading", "dottRead", "TotFollow", " totLink"], "out": ["x", "connection", "bin", "ext", "socket", "s", "g", "sync", "p", "ex", "outs", "In", "conn", "b", "w", "output", "again", "part", "conf", "l", "r", "fn", "writer", "err", "plus", "o", "off", "client", "OUT", "d", "init", "inc", "t", "h", "exec", "parent", "v", "outer", "n", "io", "net", "c", "file", "up", "a", "exp", "ac", "Out", "obj"], "i": ["data", "current", "name", "ie", "me", "is", "bi", "b", "o", "d", "buffer", "source", "h", "xi", "uri", "io", "c", "gi", "length", "si", "it", "g", "m", "ori", "ind", "ix", "I", "u", "key", "abi", "init", "z", "yi", "mi", "ui", "li", "id", "ai", "start", "x", "ti", "my", "j", "info", "p", "one", "hi", "ei", "multi", "qi", "r", "fi", "e", "ini", "ci", "api", "ik", "oi", "zi", "ii", "ni", "iu", "eni", "phi", "ip", "ji", "y", "ri", "q", "slice", "pi", "k", "di", "l", "v", "index", "chi", "ic", "input"]}}
{"id1": "17974661", "id2": "21979717", "code1": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "code2": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"requestServerModifications": ["requestServerModifies", "requestClientModurations", "requestServerModification", "requestServerMutifications", "requestServerModurations", "requestClientmodifications", "requestServerMutification", "requestServerMuturations", "requestClientmodification", "requestClientmodurations", "requestServermodifications", "requestServermodification", "requestServermodurations", "requestServermodifies", "requestClientModifies", "requestClientModifications", "requestClientmodifies", "requestServerMutifies", "requestClientModification"], "sessionId": [" sessionInfo", "sessionID", "connectionId", "sessionName", "connectionInfo", "essionKey", "Sessionid", "SessionId", "essionName", "essionId", "connectionID", "sessionid", "sessionKey", " sessionName", "sessionInfo", "connectionName", "connectionid", " sessionid", "SessionID", "SessionInfo", "essionID", " sessionID", " sessionKey", "connectionKey"], "out": ["lock", "data", "name", "socket", "session", "remote", "ex", "outs", "timeout", "log", "cache", "conn", "again", "output", "user", "content", "writer", "err", "o", "flush", "OUT", "external", "buffer", "image", "path", "exec", "object", "parent", "url", "config", "server", "io", "in", "file", "resource", "result", "report", "Out", "write"], "client": ["connection", "https", "app", "self", "channel", "socket", "session", "handler", "Client", "web", "per", "base", "ssl", "conn", "proxy", "call", "cli", "service", "connect", "api", "request", "driver", "url", "config", "server", "uri", "bird", "io", "http", "c", "ce", "php", "resource", "con", "host"], "builder": ["reader", "building", "filter", "array", "info", "str", "xml", "letter", "base", "log", "b", "keeper", "builders", "built", "r", "writer", "parser", "bean", "address", "row", "buffer", "build", "image", "db", "api", "request", "path", "object", "Builder", "url", "v", "door", "uri", "http", "prefix", "message", "result", "sb", "orb", "length", "string", "runner"], "method": ["connection", "job", "trip", "data", "name", "session", "type", "METHOD", "operation", "stream", "send", "event", "plugin", "user", "wrapper", "instance", "r", "ter", "pull", "service", "call", "build", "api", "request", "process", "path", "url", "view", "server", "http", "function", "module", "message", "resource", "invoke", "string", "use", "end", "Method"], "response": ["full", "connection", "data", "version", "ception", "error", "session", "respond", "stream", "results", "body", "application", "received", "Response", "status", "page", "output", "success", "reply", "service", "found", "entry", "image", "feed", "value", "request", "object", "next", "default", "document", "relation", "server", "view", "http", "wave", "function", "index", "message", "result", "resource", "res", "report", "onse", "json", "serv", "resp", "site"], "header": ["connection", "er", "director", "data", "name", "manager", "version", "error", "handler", "head", "body", "layer", "info", "field", "event", "param", "status", "prev", "inner", "content", "her", "line", "writer", "err", "key", "dr", "buffer", "entry", "block", "hr", "value", "port", "cookie", "h", "request", "second", " Header", "Header", "url", "attribute", "document", "server", "number", "metadata", "holder", "message", "headers", "result", "token", "cover", "host", "forward", "string"], "code": ["be", "x", "Code", "f", "coded", "name", "ception", "error", "reason", "complete", "type", "change", "ge", "state", "mode", "one", "ec", "codes", "ie", "status", "rule", "ide", "zip", "done", "line", " status", "success", "e", "key", "CE", "see", "expected", "reply", "back", "zone", "call", "count", "go", "ode", "age", "cod", "close", "level", "score", "ose", "number", "rate", "c", "xx", "ce", "id", "message", "co", "last", "scene", "result", "cause", "charge", "length", "none", "re", "de"], "expectedLength": ["pectedlength", "actualLength", "pectedLength", "expectedLen", "pectedLen", "actualLen", "actualSize", " expectedlength", " expectedLen", "pectedSize", "expectedlength", " expectedSize", "actuallength", "expectedSize"], "is": ["x", "ire", "mark", "ais", "Is", "data", "iss", "si", "isl", "_", "name", "ri", "error", "s", "bs", "ins", "stream", "non", "info", "not", "os", "im", "set", "isa", "IS", "status", "ish", "isc", "was", "ops", "its", "key", "i", "ci", "select", "ws", "js", "bis", "uri", "io", "ii", "ris", "as", "in", "iso", "id", "params", "iris", "are", "es", "res", "us", "lis", "ms", "ios", "serv", "ip", "fs", "isi"]}}
{"id1": "21555906", "id2": "2525897", "code1": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "label": 0, "substitutes": {"actionPerformed": ["eventPerressed", "eventPeruted", "actionOccressed", "actionConceived", "actionOccuted", "actionExecressed", "actionConuted", "actionConformed", "actionConressed", "actionPerressed", "actionPeruted", "eventExecformed", "actionOccceived", "eventExecressed", "actionExecformed", "eventPerformed", "actionPerceived", "eventExecceived", "actionOccformed", "actionExecceived", "actionExecuted", "eventExecuted", "eventPerceived"], "ae": ["x", " ev", "ade", "oe", " pe", "ca", "change", " event", "event", "ec", " te", "sem", "fe", " ec", "Events", "je", "gae", "e", "E", "exc", " je", "dc", "AE", " fa", " error", " ace", "ava", "t", "Event", "pe", "c", "au", " inst", " a", "ce", "a", "ga", "fa", " ge", "es", " ce", "cm", "ea", "ai", "de", "ace", " events", "ee", "bc"], "toservlet": ["toserverlets", "tosServlete", "topservlets", "topserverler", "tosServurl", "toseserveet", "tosourcelet", "toseservelet", "toservlete", "toseserveurl", "tosourcelets", "tosServet", "toserverlet", "tosvlet", "toserverle", "tosvet", "tosvurl", "tosourcele", "tosservle", "topserverle", "toservelet", "topservler", "tosourceler", "toservler", "toserveet", "toseservlet", "toservle", "toservurl", "toseservet", "toseservlete", "toservet", "tosservlets", "tosservlet", "toservelete", "toseservurl", "topserverlets", "tosvlete", "topservlet", "toserverler", "topservle", "toserveurl", "tosServlet", "toseservelete", "toservlets", "tosservler", "topserverlet"], "servleturl": ["servleserver", "servjectserver", "servlettserver", " servletserver", "ervleturl", "ervleturi", " servlefile", "servletsuri", " servleserver", " servletfile", "servlconnection", "servletsserver", "servletsconnection", "ervletserver", "servlserver", "servletsfile", " servleconnection", "servluri", "servletsurl", "ervletsconnection", "servletturl", "servlurl", "servletfile", "servletserver", "servleturi", "servjecturl", "ervletsuri", "servlefile", "ervletsserver", "ervletconnection", "servlettconnection", "servletturi", "servleconnection", "servjectfile", " servleurl", "servjectconnection", "servleurl", "ervletsurl"], "servletconnection": ["serverletconnection", "servletpassword", "servletcon", "serverletconn", " servleconnect", " servletConnection", "servservercon", "servleConnection", " servleConnection", "ervletsconn", "servserverconnection", "ervleturl", "servleconn", "servlessconnection", "servlexconnection", " servleconn", "servlettconnect", "servbleurl", "serverletcommunication", "servletsconn", "servserverconn", "serverletconnect", "servbleconn", "servletsconnection", "ervletscon", "serverletpassword", "ervletcon", "servlettConnection", "servletcommunication", "servlesspassword", "servblecon", "servleconnect", "servletConnection", "servetConnection", "servlesscommunication", " servleconnection", "servletconnect", "serverletscommunication", "servlexcommunication", "servletsurl", "servlexconn", "ervletsconnection", "serverletsconnection", " servetconn", " servetconnect", "serverletsconn", "serverletsConnection", "servetconnect", "servletsconnect", "serverletsconnect", "servlexpassword", " servetConnection", "servletspassword", "servletconn", "servlettconnection", "servserverurl", "ervletconnection", "servletscon", "servetconnection", "serverletspassword", "servlessconn", " servetconnection", "servleconnection", "serverletConnection", "servlettconn", "servbleconnection", "servletsConnection", " servletconn", "servetconn", "servletscommunication", "ervletconn", " servletconnect", "ervletsurl"], "inputFromClient": ["inputOrClient", "requestFromRemote", "inputOrServer", "inputToClient", "requestFromServer", "outputFromURL", "inputViaCL", "inputToConnection", "InputFormConnection", "inputFromServer", "requestFromClient", "inputToclient", "inputfromConnection", "outputFromCL", "outputfromURL", "outputfromCL", "InputFormClient", "InputFromConnection", "inputfromCL", "inputOrURL", "requestFromConnection", "inputViaServer", "outputfromClient", "requestFromclient", "inputfromURL", "inputFormStream", "outputFromClient", "inputFromStream", "inputViaClient", "inputToRemote", "inputFromclient", "inputfromclient", "inputToServer", "inputfromClient", "InputFormclient", "InputFromStream", "InputFormStream", "InputFromClient", "inputFromRemote", "inputFromURL", "inputFormClient", "inputOrCL", "outputFromServer", "inputFormclient", "inputViaURL", "inputFormConnection", "inputFromConnection", "inputfromStream", "inputFromCL", "inputfromServer", "InputFromclient", "outputfromServer"], "fos": ["affos", "Foos", "ifaos", "fis", "Foses", "foses", "Fbos", "affis", " fis", "ifos", " foos", "fbos", "Faos", " fols", " foses", "ifoses", "Fis", "affoos", "affbos", " faos", "ifols", "Fos", "Fols", "foos", " fbos", "faos", "fols"], "buf": ["bin", "cb", "bd", "seq", "data", "loc", "ha", "ff", "bu", "batch", "pool", "cap", "buff", "comb", "bh", "bl", "feat", "bb", "b", "vec", "box", "br", "bytes", "bp", "bag", "shape", "off", "la", "font", "rb", "buffer", "block", "lb", "uc", "ba", "bound", "uint", "Buff", "cv", "wb", "uf", "cas", "queue", "bf", "pad", "fb", "bc", "tmp"], "bytesread": ["rowswrite", "lineswrite", "Bytesread", " bytesrun", "filesread", " byteswrite", "bytesRead", "rowsrun", "bytesrun", "bytesload", "teswrite", "linesrun", "tesload", "filesRead", "linesread", "linesRead", "BytesRead", "fileswrite", "tesrun", "rowsRead", "Byteswrite", " bytesRead", "byteswrite", "tesread", "linesload", " bytesload", "filesrun", "Bytesload", "rowsread"]}}
{"id1": "17538992", "id2": "15362793", "code1": "    public static boolean check(String urlStr) {\n        try {\n            URL url = new URL(urlStr);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            urlConnection.setConnectTimeout(2000);\n            urlConnection.getContent();\n        } catch (Exception e) {\n            logger.error(\"There is no internet connection\", e);\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public static String ReadURL(URL url, boolean textonly) {\n        try {\n            URLConnection uconn = url.openConnection();\n            Object ucont = uconn.getContent();\n            if (ucont instanceof InputStream) return ReadInputStream((java.io.InputStream) ucont, textonly); else return \"\" + ucont;\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"check": ["login", "get", "complete", "info", "load", "Check", "find", "match", "ok", " checks", "work", "checking", "test", "call", "run", "process", "exec", "close", "update", "checked", "checks", " checking", "resource", "CHECK", "link", "start", " Check"], "urlStr": [" urlText", "URLSTR", "httpText", "httpSTR", "urlSTR", "urlString", "httpStr", "URLName", "urlName", " urlstr", " urlString", "urlstr", "httpstr", "httpString", "URLString", "resourcestr", "resourceText", " urlSTR", "resourceString", "httpName", "URLStr", " urlName", "resourceStr", "urlText"], "url": ["connection", "open", "sl", "f", "data", "channel", "layer", "web", "str", "ll", "base", "ssl", "log", "ls", "page", "blog", "b", "user", "conn", "l", "r", "client", "address", "Url", "URL", "build", "image", "feed", "object", "config", "server", "uri", "browser", "http", "c", "impl", "resource", "www", "host", " URL", "string", "obj"], "urlConnection": ["URLconnection", "URLConnection", "urlConfig", "urlconnection", " urlSocket", "httpUrl", "urlC", "newconnection", "urlUrl", "urlContainer", " urlconnection", "UrlConfig", " urlC", "Urlconnection", "httpC", " urlconn", "sslConnection", "httpContainer", "URLContainer", "sslC", "newContainer", "newConnection", "URLUrl", "urlconn", "sslconn", "UrlSocket", "httpconnection", "httpconn", "newUrl", "sslconnection", "httpConfig", " urlConfig", "UrlConnection", "urlSocket", "httpSocket", "httpConnection"]}}
{"id1": "12380475", "id2": "4461350", "code1": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 0, "substitutes": {"transport": ["transmission", "transpoint", "ransporter", " transprocess", " transports", " transpoint", "protport", "transports", "protmission", "ransports", "ransprocess", " transporter", "protports", "protprocess", "transporter", "transprocess", "ransmission", "protporter", "protpoint", " transmission", "ransport", "ranspoint"], "file": ["full", "reader", "connection", "f", "data", "name", "File", "channel", "socket", "handler", "type", "handle", "stream", "change", "auto", "info", "local", "log", "class", "base", "model", "page", "cache", "user", "content", "line", "single", "e", "service", "comment", "source", "entry", "image", "db", "ile", "project", "path", "parent", "filename", "object", "url", "document", "server", "route", "io", "http", "folder", "FILE", "resource", "dir", "fp", "out", "queue", "directory", "string", "use"], "files": ["pages", "f", "images", "blocks", "thumbnails", "issues", "s", "ups", "ins", "phones", "bs", "balls", "results", "events", "Files", "ls", "items", "cells", "models", "ums", "features", "flows", "lines", "facts", "pes", "iles", "objects", "books", "classes", "names", "boxes", "ions", "keys", "sites", "views", "users", "headers", "dir", "fs"], "i": ["x", "f", "si", "it", "ti", "ri", "slice", "m", "p", "info", "j", "pi", "k", "hi", "I", "di", "u", "b", "multi", "e", "o", "key", "ini", "abi", "d", "ci", "h", "xi", "v", "mi", "oi", "ui", "n", "li", "uri", "ii", "io", "c", "ni", "id", "index", "chi", "vi", "ai", "col", "ip", "end"], "inChannel": [" inchannel", " inCh", "inCh", "outFile", "outStream", "Inchannel", "inMessage", "InChan", "InMessage", "InStream", "inchannel", "InCh", " inMessage", " inChan", "outchannel", " inStream", " inFile", "inputCh", "inputChan", "outMessage", "inputChannel", "inChan", "inputStream", "inStream", "InFile", "InChannel", "inFile"], "outChannel": ["ioHandler", " outStream", "inConnection", " outConnection", "outStream", "inchannel", "ioChan", "outchannel", "OutChan", " outChan", "outChan", "OutStream", " outHandler", "outHandler", "outConnection", "Outchannel", "ioConnection", "ioChannel", "OutChannel", "inChan", "inHandler", "inStream", " outchannel"]}}
{"id1": "7843322", "id2": "20663364", "code1": "    public void run(IAction action) {\n        int style = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell().getStyle();\n        Shell shell = new Shell((style & SWT.MIRRORED) != 0 ? SWT.RIGHT_TO_LEFT : SWT.NONE);\n        GraphicalViewer viewer = new ScrollingGraphicalViewer();\n        viewer.createControl(shell);\n        viewer.setEditDomain(new DefaultEditDomain(null));\n        viewer.setRootEditPart(new ScalableFreeformRootEditPart());\n        viewer.setEditPartFactory(new TableEditPartFactory());\n        viewer.setContents(getContents());\n        viewer.flush();\n        int printMode = new PrintModeDialog(shell).open();\n        if (printMode == -1) return;\n        PrintDialog dialog = new PrintDialog(shell, SWT.NULL);\n        PrinterData data = dialog.open();\n        if (data != null) {\n            PrintGraphicalViewerOperation op = new PrintGraphicalViewerOperation(new Printer(data), viewer);\n            op.setPrintMode(printMode);\n            op.run(selectedFile.getName());\n        }\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 0, "substitutes": {"run": ["save", "app", "play", "task", "load", "launch", "loop", "register", "output", "work", "plot", "test", "show", "call", "image", "build", "use", "submit", "select", "process", "exec", "form", "update", "config", "view", "read", "runner", "index", "running", "input", "render", "report", "execute", "Run", "start", "apply"], "action": ["app", "it", " act", " module", " controller", " flow", "state", "ction", " app", " ACTION", " fn", " activity", " input", "controller", "ctx", "ctions", " f", "next", " actions", "actions", " step", "Action", "ACTION", " c", " result", "tx", " Action", "act"], "style": ["offset", "profile", "layout", "background", "type", "py", "phase", "theme", "info", "state", "mode", "letter", "rule", "position", "format", "inline", "css", "size", "shape", "dot", "normal", "estyle", "image", "template", "value", "like", "pattern", "role", "level", "config", "styles", "color", "file", "shadow", "script", "sty", "length", "print", "Style", "sh", "element"], "shell": ["lock", "sl", "layout", "si", "widget", "session", "body", "tty", "mode", "xml", "ol", " Shell", "ll", "hell", "control", "log", "loop", "roll", "wrapper", "math", "l", "sole", "o", "console", "buffer", "cli", "gui", "live", "lex", "child", "system", "pty", "cl", "ui", "nl", "server", "null", "scroll", "clone", "search", "tool", "sel", "cel", "sb", "skin", "window", "help", "sql", "sym", "kel", "Shell", "sh"], "viewer": [" viewitter", "viewitter", "displayer", "viewter", "presentoser", "lookier", "displayner", "Vieworer", "showaer", " vieworer", " viewe", " viewter", "presentaer", "Viewier", "ViewER", "viewner", "footerver", "showester", "reviewed", "vieworer", "scanener", " viewed", "scanner", "lookener", " viewers", "presentester", "viewerver", "viewr", "Viewar", "viewER", "Viewed", "showoser", "scaner", " viewER", "displayitter", "scanar", "viewester", " viewner", "lookers", "footer", "viewe", "looke", "Viewter", " viewener", "viewier", "reviewter", " viewr", "viewsr", "Viewe", "reviewe", "looker", " viewier", " viewester", "viewed", "viewar", " viewerver", "viewaer", " viewoser", "footorer", "viewoser", "Viewitter", "presenter", " viewaer", "Viewer", "viewsed", "Viewerver", "Viewers", "viewener", "shower", "reviewer", "viewsers", "lookER", "displayier", "viewers", "Viewner", "Viewener", "Viewr", "viewser", "footers", " viewar"], "printMode": ["PrintMode", "logmode", " printSize", "PrintMODE", "PrintSize", "printStyle", "patchStyle", "writeMODE", "writemode", "printMODE", " printRole", "viewSize", "writeRole", "printRole", "patchMODE", "printmode", "printSize", " printMODE", " printmode", "writeMode", "patchmode", "logMODE", "Printmode", "viewMode", "logStyle", "logMode", "patchMode", "PrintRole", " printStyle"], "dialog": ["demOG", "demDialog", "protog", "dialdr", "demog", "logog", "protink", "dialOG", "slogo", "logdr", "sldr", "dialink", "collOG", "DialOG", "dialoder", "DialDialog", "dialDialog", "dialogo", "collDialog", "Dialoder", "demoder", "colloder", "logogo", "Dialog", "slog", "collog", "slink", "protogo", "logink", "protdr"], "data": ["reader", "layout", "where", "error", "handler", "operation", "body", "to", "p", "info", "state", "da", "plugin", "format", "model", "page", "di", "part", "loader", "output", "text", "inner", "done", "ops", "writer", "parser", "o", "buffer", "entry", "map", "image", "value", "api", "or", "oper", "response", "object", "next", "form", "ui", "raw", "view", "up", "a", "valid", "frame", "po", "result", "input", "resource", "dat", "pad", "area", "json", "processor", "media", "obj"], "op": ["job", "open", "app", "opus", "opp", "opt", "it", "oop", "operation", "comp", "auto", "p", "opy", "proc", "set", "top", "Op", "opl", "jp", "ops", "pop", "cop", "and", "o", "pp", "dr", "hop", "sp", "init", "or", "ap", "oper", "object", "mp", "oc", "post", "up", "operator", "co", "po", " operation", "obj", "orb", "OP", "exp", "ip", "ob", "opa"]}}
{"id1": "23452437", "id2": "16719805", "code1": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"internalCopy": ["doCopy", "internalTransfer", "doTransfer", "internalDownload", " internalDownload", "doDownload", " internalcopy", "innercopy", "innerTransfer", " internalTransfer", "internalcopy", "docopy", "innerCopy", "innerDownload"], "fSource": ["fpSourceFile", "iPath", "fPath", "fileType", "tfType", "sfOrigin", "cSourceFile", "fSite", "fOrigin", "sSource", "fSourceFile", "sSourceFile", "fpOrigin", "sOrigin", "sfSourceFile", "tfFile", "iSOURCE", "ifSourceFile", " fFile", "fpSource", "fpSources", " fPath", "ifSOURCE", "sfSource", "tfSource", "sfSources", "fFile", "cSource", " fSOURCE", "fileSource", "fType", "fsource", "iSource", "fSOURCE", "csource", "ifSource", "filePath", "fSources", "tfSite", " fSourceFile", "fileSOURCE", "iSourceFile", "fileFile", " fsource", "cSOURCE", "ifsource", " fType", "fileSourceFile", "fileSite", "sSources", " fSite"], "file": ["x", "lock", "connection", "f", "data", "name", "File", "handler", "type", "table", "el", "p", "info", "letter", "base", "log", "class", "model", "plain", "cache", "files", "zip", "l", "line", "e", "address", "source", "image", "db", "feed", "ile", "path", "parent", "filename", "object", "url", "document", "uri", "http", "folder", "FILE", "resource", "dir", "fp", "directory"], "o": ["f", "oa", "oe", "oo", "lo", "oop", "auto", "p", "one", "wo", "os", "ol", "u", "ko", "w", "op", "l", "yo", "e", "off", "go", "mo", "or", "oi", "no", "li", "io", "in", "co", "po", "bo", "out", "O", "fo", "zo", "so", "ob"], "i": ["f", "si", "ri", "ori", "p", "pi", "ie", "I", "di", "u", "bi", "ami", "qi", "l", "e", "ini", "cli", "ci", "api", "xi", "oi", "mi", "ui", "li", "uri", "io", "ii", "c", "in", "iu", "a", "ic", "gi", "ai", "phi", "ip", "ib", "isi"], "b": ["x", "bin", "bd", "cb", "f", "gb", "g", "bs", "boot", "p", "buff", "xb", "binary", "base", "bl", "bb", "bi", "mb", "B", "br", "bytes", "r", "l", "e", "rb", "d", "buffer", "emb", "db", "lb", "ba", "bound", "v", "buf", "ab", "c", "wb", "nb", "a", "sb", "bf", "fb", "pb", "ib", "ob"], "n": ["x", "nt", "nn", "f", "y", "cn", "rn", "nc", "sn", "un", "g", "m", "na", "p", "j", "dn", "ns", "k", "not", "en", "u", "conn", "size", "num", "l", "r", "e", "err", "end", "d", "ne", "z", "t", "no", "number", "N", "net", "c", "an", "nb", "a", "len", "out", "none", "nu"]}}
{"id1": "6190356", "id2": "1235538", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 1, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForOldMC512", " hashPasswordForOldMD3", " hashPasswordForNewMD3", " hashPasswordForNewMD512", " hashPasswordForOldMD512", " hashPasswordForNewMD4", " hashPasswordForOldMC5", " hashPasswordForOldMC3", " hashPasswordForOldmd3", " hashPasswordForOldMC4", " hashPasswordForOldmd5", " hashPasswordForOldM512", " hashPasswordForOldmd512", " hashPasswordForNewM5", " hashPasswordForOldmd4", " hashPasswordForNewMD5", " hashPasswordForOldM4", " hashPasswordForOldM5", " hashPasswordForOldMD4", " hashPasswordForOldM3", " hashPasswordForNewM3", " hashPasswordForNewM4", " hashPasswordForNewM512"], "password": ["wallet", "data", "name", "wd", "seed", "array", "p", "encrypted", "words", "text", "Password", "content", "account", "key", "address", "crypt", "secret", "buffer", "padding", " passwords", "sword", "value", "phrase", "path", "hash", "PASS", "pattern", "code", "pass", "word", "message", " Password", "token", "input", "result", "pad", "auth", "string", "username"], "md": ["meta", "df", "bd", "vd", "f", "mag", "cd", "rm", "wd", "grad", "dd", "m", "ma", " MD", "mt", "clean", "ind", "dig", "di", "mb", "am", "mac", "hm", "cmd", "managed", "dm", "vm", "um", "dc", "d", "MD", "gd", "mo", "mod", "amd", "mp", "rpm", "metadata", "mm", "pm", "mc", "pd", "mand", "hd", "pg", "od", "km", "Cmd", "nm"], "messageDigest": ["MessageAddEST", "messageAddester", " messageModests", "messagedigester", " messageModEST", "MessageAddse", "messageDigests", "messageDse", "messageAddse", "messageDigse", "messageDigester", "MessageModester", "messagedigse", " messageModester", "messageModEST", "MessageModEST", "MessageDigse", "messageModse", "messageAddest", "MessageDigest", "messagedigest", "MessageDigEST", "messageDEST", "messageModests", " messageDigests", " messageDigEST", "messageModester", " messageModest", "MessageModse", "MessageModest", "messageDigEST", "MessageAddest", " messageDigester", "messageModest", "messageAddests", "MessageDigester", "messagedigests", "messageAddEST", "MessageAddester", "messageDester", "messagedigEST", "messageDest"], "hexString": ["hexstring", "hexArray", " hexArray", "tempStr", " hexBuffer", "crossFunction", "crossStr", " hexService", "crossstring", "sumstring", "tempstring", "hashService", "hexFile", "sumString", "hexBuffer", "transformString", "hashArray", "hashSection", "octArray", "hashString", "transformStr", "tempFunction", "octBuffer", "hexSection", "tempString", "hexFunction", " hexStr", "sumFile", "hexService", "stringArray", "sumStr", "transformArray", " hexFunction", "octString", "crossString", "hexStr", "stringSection", " hexstring", " hexSection", "transformBuffer", "stringString", "stringService", " hexFile", "octStr", "tempFile"], "i": ["x", "ji", "f", "si", "ti", "ri", "s", "slice", "m", "p", "j", "pi", "k", "info", "ix", "I", "di", "u", "b", "multi", "bi", "qi", "r", "l", "fi", "e", "o", "d", "ci", "t", "h", "xi", "v", "oi", "ui", "n", "li", "uri", "ii", "io", "c", "id", "index", "a", "ai", "phi", "length", "ip"], "hex": ["rh", "full", "data", "char", "digit", "batch", "comp", "buff", "rex", "ex", "json", "str", "zero", "letter", "binary", "orig", "format", "shift", "cache", "text", "he", "pixel", " Hex", "sex", "temp", "cmp", "pack", "pex", "nexus", "cookie", "path", "h", "hash", "serial", "pattern", "character", "form", "default", "hello", "oct", "raw", "null", "http", "transform", "hack", "utf", "lit", "result", "host", "length", "none", "exp", "alpha", "string", "ip", "bit"]}}
{"id1": "494226", "id2": "149935", "code1": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"linesep": ["lineeps", "ineseps", "nseper", "linerseter", "linersew", "linpace", "linseter", "lineearch", "linersearch", " linesupp", "ringspec", "linerseng", "lineseper", "gesyp", "gesep", "linepace", "inesep", "lineps", "linespace", "geseps", "linedep", "linepec", "linspec", "linep", "lineseng", "lineseps", " lineseps", "linsep", "linersep", "linesew", "timesep", " linesaper", " lineseter", "lineseter", "ringspace", "lineep", "linyp", " linesew", "linspace", "nseps", " linesearch", "nsep", "linesyp", "linesaper", "timesyp", "linedew", "inesaper", "lineupp", "linespec", "linseps", "ineseper", "nsaper", "linsew", "codeseps", "gespe", "linseng", "linerseps", "timespe", "linesupp", "ringsep", "timeseps", "linesip", "linpec", "linesearch", "linedip", " linespec", "linersip", " lineseper", " lineseng", "linpe", "codesew", "ringsupp", " linespace", "linedeps", "codesip", "linespe", "linerspec", "codesep"], "fos": ["coes", "FOs", "cos", "infops", "foses", "FOS", "focks", " fOS", "fes", "infotes", "loadOs", "foros", " foses", "loadoS", "Fios", "go", "fotes", "cols", "eol", "poes", "fats", "Fats", " fats", "loados", "infoses", "fo", "Foser", " fops", "Foses", "fingocks", "infes", "coos", "Foes", "foes", "Focks", "foS", "Fis", "fops", "fOs", "poos", "fullis", "pols", "infols", "Fes", "Fos", "forOS", "foser", " fo", "zotes", "zo", "loadops", "zol", " fOs", "fingos", "infios", "eos", "info", "gocks", "Fops", "gos", "fingoss", "infoos", "eotes", "infoes", "infos", " foser", "eo", "fulloser", "fios", "pos", "foos", " fios", "fulloes", " fes", "Fo", "fol", "forats", "fis", " foes", " fis", "fOS", "fullos", "FoS", "foroses", "goss", "Foss", "foss", " foS", "infol", "fols", "zos", "fingo", "infis"], "files": ["ids", "pages", "scenes", "f", "images", "blocks", "thumbnails", "data", "rows", "bs", "groups", "services", "balls", "results", "ins", "events", "lets", "Files", "ls", "items", "models", "members", "obs", "features", "apps", "l", "workers", "tools", "lines", "strings", "facts", "archives", "iles", "objects", "books", "classes", "names", "boxes", "http", "keys", "file", "jobs", "ports", "locks", "states", "users", "projects", "tests", "headers", "bugs", "rules", "plugins", "resources", "docs", "fs"], "i": ["ji", "f", "current", "y", "si", "it", "start", "ti", "ri", "type", "slice", "m", "p", "j", "info", "pi", "ie", "ix", "hi", "I", "di", "u", "b", "multi", "inner", "qi", "fi", "e", "ini", "d", "count", "ci", "z", "t", "xi", "v", "oi", "ui", "yi", "li", "uri", "ii", "io", "c", "id", "index", "iu", "eni", "ai", "gi", "phi", "col", "ip"], "metaprops": ["metoprops", "metoppropes", "metapropps", "metaprpps", "metaparps", "metaprope", "metopprop", "metoprope", "metapPropps", "metepropps", "metaprobpe", "metapprope", "metopropp", "metaprobps", "meteprope", "metaporeps", "metaporepps", "metapproperties", "metaporepe", "meteppropes", "metaprop", "metopprops", "metaproperties", "metopropps", "metaporepes", "metaprobpps", "metaprobp", "metaprobpes", "metappropes", "metapprop", "metaprospes", "metaparpps", "metoppropps", "metopprope", "metopproperties", "metaprosps", "metappropp", "metapropp", "metappropps", "meteppropps", "metopropes", "metepprope", "metoproperties", "metaprpes", "metaparpp", "metapropes", "metaprospps", "metaprobpp", "metaprps", "metapProps", "metapprops", "metoprop", "meteprops", "metepprops", "metaprpe", "metaprosperties", "metaprobperties", "metapPrope", "metoppropp", "metapPropes", "metaparp", "metepropes"], "itsect": ["Itect", "itssection", "itersect", "litrupt", "Itsector", "itrupt", " itsector", "iterrupt", "itsector", " itsection", "litna", " itect", "Itna", " itconnect", "itsection", "itssect", "litect", "itconnect", "Itrupt", "Itsection", "itect", " itrupt", "Itconnect", "Itsect", "itna", "litsect", "iterect", "itssector", "iterconnect", " itna"], "section": ["job", " Section", "division", "loc", "name", "version", "sect", "sections", "array", "j", "sector", "set", "ie", "rc", "description", "page", "part", "text", "protection", "year", "line", "account", "key", "vision", "esc", "mission", "service", "step", "entry", "sub", "closure", "child", " sections", "sec", "ion", "environment", "second", "config", "route", "Section", "function", " subsection", "script", "search", "edition", "header", "ect", "ection", "area", "string", "element"]}}
{"id1": "15799935", "id2": "5237257", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedPart", "saveAttachedBody", "saveAppensionFile", "saveAttPartPart", "saveAttachmentPart", "saveAttachedFile", "saveAttensionBody", "saveAttPartFile", "saveAppachmentbody", "saveAppensionbody", "saveAttensionbody", "saveAppensionPart", "saveAttachedbody", "saveAttachmentFile", "saveAppachmentFile", "saveAttachmentbody", "saveAttPartBody", "saveAppachmentPart", "saveAttensionFile", "saveAppensionBody", "saveAppachmentBody", "saveAttensionPart", "saveAttPartbody"], "context": ["connection", "reader", "current", "Context", "version", "manager", "present", "channel", "container", "support", "cca", "ca", "state", "cms", "event", "definition", "center", "component", "cache", "text", "front", "concept", "content", "collection", "translation", "client", "subject", "service", "kernel", "ctx", "template", "cf", "request", "parent", "driver", "project", "environment", "system", "config", "document", "view", "c", "ce", "message", "community", "resource", "input", "queue", "mc", "coll", "contact", "host", "network", "processor", "media"], "part": ["connection", "app", "name", "point", "channel", "place", "type", "from", "body", "to", "p", "partial", "state", "phase", "event", "art", "per", "base", "component", "position", "parts", "Part", "section", " parts", "pre", "translation", "patch", "mission", "PART", " Part", "comment", "service", "source", "block", "pod", "image", "or", "media", "parent", "object", "file", "message", "upload", "po", "chapter", "plan", "area", "html", "Parts", "start"], "localAttachment": ["LocalAssachment", " localAttachachment", "localPartribution", "localAttachension", "localAttension", "localAvacher", " localAttrollment", "LocalAttment", "localAvacement", "localInstribution", "localAttacement", "localArtment", " localAttribution", " localAttention", "localAddment", "localAttment", " localAttacement", " localExtachment", " localPartension", "LocalAttention", "localattention", "localattrollment", "localAssention", " localPartribution", "LocalAssail", "localAvachment", "localPartension", "localAvention", "localArtail", "localAssment", " localPartention", "localAttachrollment", "LocalAttachment", "localAssail", " localExtacement", "localAddrollment", "localAttachention", "LocalAttail", "localPartention", "localExtacher", " localAttension", "localAttachacement", "localAttacher", "localPartachment", "localAttribution", "localAddail", " localExtacher", "LocalAssment", "localattachment", "localArtention", " localExtention", "localAttention", " localAttachrollment", "localAttrollment", " localAttacher", "localArtachment", "localAttail", "localAssachment", " localPartachment", " localAttment", "localExtacement", "localExtachment", "localAttachachment", "localAttachribution", "LocalAssention", "localInstachment", "localInstention", " localAttachention", "localExtention", "localInstension", "localAddachment", "localattment", "localAddention", "localAttachacher"], "accountId": ["contractId", "contractName", "jobid", "accountInfo", "contactid", "jobId", "appInfo", " accountID", "AccountName", "appId", "accountid", "feedID", "Accountid", "appID", "accInfo", " accountid", "feedid", "accId", "accountID", "appid", "feedName", "feedId", "AccountId", "jobName", "jobID", "accID", "AccountID", "accid", " accountInfo", "accountName", "contractid", "contactName", "contactId", " accountName"], "attachmentId": ["addachmentID", "attociationID", "attlementName", "attmentId", "atachmentReference", "attociationType", "addachmentType", "extachmentid", "adachmentID", "attentionId", "addentionID", "attmissionID", "attmissionId", "extachmentId", "atachmentName", "atociationReference", "attensionSource", "attentionSource", "adachmentInfo", "atociationName", "attlementId", "attmentName", "attmentReference", "attociationId", "attachmentID", "attachedType", "attentionIndex", "attentionUrl", "attociationReference", "atociationID", "extachmentSource", "attociationUrl", "attlementReference", "attociationName", "attachmentReference", "attlementID", "attensionid", "attachmentSource", "attentionType", "attachedID", "attentionid", "extensionSource", "atociationId", "attachedUrl", "attptionID", "adachmentIndex", "attensionID", "addentionId", "extensionid", "attptionId", "adentionIndex", "attmissionSource", "attmissionid", "attachmentType", "attachmentIndex", "attachmentInfo", "addachmentId", "adentionInfo", "attagramIndex", "attachmentUrl", "attagramInfo", "atachmentID", "adachmentId", "atachmentId", "addachmentUrl", "attachmentName", "attptionIndex", "attmentID", "extachmentID", "attentionID", "attachmentid", "attptionInfo", "attachedId", "extensionId", "attentionInfo", "adentionId", "extensionID", "addentionUrl", "attensionId", "attagramID", "attagramId", "adentionID", "addentionType"], "in": ["reader", "bin", "login", "f", "data", "it", "socket", "slice", "ins", "pin", "p", "cin", "info", "load", "In", "is", "inside", "copy", "conn", "inner", "again", "din", "IN", "err", "plus", "pull", "ini", "i", "source", "init", "image", "inc", "nin", "or", "url", "pass", "inn", "file", "as", "id", "up", "a", "input", "con", "ac", "gin"], "saveIn": [" savein", "savIn", "aveIn", "avein", "saveOut", "saveIN", "aveAs", " saveIns", "stageIn", "savAs", "writeIN", " saveOut", "SaveIns", "writeIn", "aveOut", "savOut", "stageOut", "savein", "stageIns", "SaveIn", "saveIns", "stageAs", " saveIN", "savin", "writeOut", "SaveAs", "aveIN", "SaveOut", "writein"], "saveAs": ["openAs", "copyAs", "saveAt", "openAS", "saveOut", "createAt", "copyas", " saveOut", "copyIn", "writeIn", " saveas", " saveAS", "writeAs", "SaveAS", "createAS", "saveAS", "SaveIn", "createAs", "saveFile", " saveFile", "copyAS", " saveAt", "writeOut", "openAt", "openFile", "SaveAs", "saveas", "writeAS", "SaveOut", "createFile", "Saveas"], "out": ["bin", "ext", "data", "name", "at", "s", "sync", "to", "ex", "outs", "copy", "page", "conn", "again", "output", "cache", "inner", "line", "writer", "err", "flow", "o", "client", "off", "OUT", "temp", "this", "plus", "source", "init", "image", "inc", "path", "exec", "outer", "v", "other", "default", "null", "io", "c", "file", "as", "up", "a", "Out", "string"], "copySize": ["CopyTime", " copyTime", "saveLength", "leSize", "byteTime", " copySIZE", "saveSize", "savesize", "lesize", "copyAddress", "CopySize", "openSIZE", "copyTime", "leLength", "copySIZE", "leSIZE", "Copysize", " copysize", "bytesize", "copysize", "byteAddress", " copyLength", "openLength", "copyLength", "saveAddress", "CopyLength", "byteLength", "opensize", " copyAddress", "openSize", "byteSize"], "contentUriString": ["contentUioStr", "contentIiByte", "contentUiniByte", "contentUridStr", "contentUrisString", "contentUioInt", "contentUpiInt", "contentUriUnit", "contentUpiStr", "contentUriByte", "contentUiNumber", "contentUriStr", "contentIrisInt", "contentUrisstring", "contentUiByte", "contentIrisStr", "contentUiostring", "contentUpiString", "contentIriStr", "contentIrisUnit", "contentUuriByte", "contentIriInt", "contentIiStr", "contentUridString", "contentUuriString", "contentUrisUnit", "contentUiString", "contentIrisString", "contentIriByte", "contentUuriNumber", "contentIiNumber", "contentIiString", "contentIristring", "contentUioString", "contentUiStr", "contentIrisstring", "contentUiniNumber", "contentUridUnit", "contentUiniStr", "contentUriInt", "contentUriNumber", "contentUuriStr", "contentUrisStr", "contentUiUnit", "contentUpistring", "contentUrisInt", "contentIriNumber", "contentUiniString", "contentIriString", "contentUristring", "contentIriUnit"], "mSize": ["pLength", "iLength", "cCount", "cSize", "mCount", "mLength", "pSize", "cLength", "mName", "pName", "iCount", "iSize", "iName", "cName", "pCount"], "mContentUri": ["mContentIci", "mResourceUric", "mContentUrci", "mResourceIris", "mContentUci", "mResourceUri", "mContentUric", "mContentOUri", "mContentUrris", "mContentIric", "mResourceUci", "mContentUris", "mContentIris", "mContentOUris", "mResourceUris", "mResourceIri", "mResourceIci", "mResourceIric", "mContentOUci", "mContentUrri", "mContentIri", "mContentOUric", "mContentUrric"], "cv": ["nv", "GV", "cb", "keep", "loc", "cd", "nc", "CV", "av", "vp", "sc", "iv", "ca", "cap", "vr", "enc", "vv", "rc", "cs", "lc", "iq", "auc", "csv", "content", "sv", "cr", "vm", "um", "bc", "cc", "ctx", "vc", "uc", "cf", "xc", "v", "vs", "conv", "core", "cu", "uv", "c", "lv", "VC", "co", "ov", "coll", "cm", "cover", "mc", "fp", "que", "ctrl", "cp", "fc", "pb", "buf"], "uri": ["URI", " url", "data", "point", "ri", "gb", "iri", "iv", "range", "pi", "universal", "base", "oid", "format", " ur", "href", "qi", "query", "address", "proxy", "i", "cli", "ci", "storage", "api", "path", "environment", "url", " scheme", "ui", "mi", "attribute", " Uri", "route", "metadata", "http", "id", "prefix", "resource", "uid", "location", "uni", "string", " URI", "username"]}}
{"id1": "12055086", "id2": "14590676", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void download(String address, String localFileName) {\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            URL url = new URL(address);\n            out = new BufferedOutputStream(new FileOutputStream(localFileName));\n            conn = url.openConnection();\n            in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n            System.out.println(localFileName + \"\\t\" + numWritten);\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyDeleting": [" copyDeleging", " copyDeletting", " copyDeleteting", " copyDequeging", " copydeleing", " copydeletter", " copydeleging", " copyDeletter", " copyDeletging", " copyDeleing", " copyDequeting", " copydeletting", " copyDeleteing", " copyDeleter", " copyDequeing", " copydeleting", " copyDequeter", " copydeletging", " copyDeleteging", " copydeleter", " copyDeleteter"], "source": ["reader", "connection", "iter", "sin", "f", "ources", "master", "archive", "down", "s", "remote", "from", "stream", "ie", "base", "ource", "copy", "cache", "inner", "SOURCE", "e", "service", "i", "storage", "image", "path", "config", "view", "route", "file", "src", "resource", "input", "target", "Source", "use", "site"], "dest": ["pipe", "bin", "opt", "master", "later", " destination", "slice", "comb", "destroy", "class", "orig", "destruct", "die", "img", "done", "content", "trans", "dist", "temp", "path", "exit", "default", "null", "thin", "flat", "wb", "file", "folder", "src", "Dest", "result", "target", "dir", "home", "slave", "desc", "de", "tmp"], "buf": ["cb", "bd", "seq", "data", "loc", "ff", "batch", "buff", "Buffer", "bh", "rc", "base", "feat", "b", "vec", "br", "txt", "img", "bytes", "cmd", "bp", "bag", "off", "rb", "buffer", "ctx", "port", "uc", "feed", "config", "raw", "code", "cv", "pos", "src", "len", "uf", "queue", "bf", "append", "result", "pad", "length", "cp", "fb", "bc", "tmp"], "in": ["reader", "bin", "isin", "sin", "f", "login", "data", "tin", "socket", "ins", "pin", "stream", "p", "min", "In", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "din", "IN", "plus", "ini", "i", "init", "image", "inc", "nin", "exec", "url", "n", "read", "thin", "io", "inn", "c", "up", "file", "id", "src", "input", "con", "gin"], "out": ["bin", "app", "ext", "f", "socket", "at", "pool", "down", "sync", "ex", "outs", "conn", "w", "b", "output", "inner", "again", "img", "part", "win", "writer", "err", "o", "client", "OUT", "buffer", "i", "lib", "image", "inc", "exec", "outer", "parent", "n", "io", "file", "up", "exp", "Out", "obj"], "count": ["lock", "offset", "f", "current", "name", "depth", "pool", "allow", "type", "handle", "ind", "base", "cache", "b", "size", "all", "num", "weight", "part", "zip", "max", "val", "key", "buffer", "Count", "cond", "limit", "use", "ch", "child", "path", "parent", "feed", "close", "sum", "n", "number", "code", "read", "c", "id", "index", "len", "coll", "length", "start"]}}
{"id1": "6379126", "id2": "9347451", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"gerarTutorialPage": ["riarTourpage", "riarTutorialElement", "riarTravisElement", "riarTravisDir", "riartutorialDir", "riarTourElement", "riarTravisPage", "riarTutorialpage", "riartourpage", "riarTutorialPage", "riartutorialPage", "riartourElement", "riarTinyPage", "riarTinyDir", "riartutorialElement", "riartourDir", "riartourPage", "riarTourDir", "riarTravispage", "riarTourPage", "riartutorialpage", "riarTinypage", "riarTutorialDir", "riarTinyElement"], "indexDir": ["indexTier", "includeDir", "zipDIR", "zipDir", "indexJar", "includeJar", "IndexJar", "IndexDIR", "indexDIR", "includeTier", "zipTier", "includeDIR", "IndexDir", "IndexTier", "zipJar"], "cssDir": ["gzDir", "javascriptDar", "CSSDar", "cssDIR", "catsDir", "piecesDie", "codesDoc", "piecesDIR", "piecesD", "codesDir", "fontDie", "cssDie", "cssUrl", "gzDirectory", "ssDirectory", "fontDir", "javascriptDir", "CSSUrl", "CSSDb", "cssLen", "fontD", "cssD", "catsDoc", "ssUrl", "javascriptDb", "cssDoc", "ssDIR", "cssDar", "gzUrl", "cssDb", "javascriptDIR", "piecesDir", "gzDIR", "fontDIR", "catsLen", "CSSDir", "CSSDirectory", "ssDb", "ssDie", "ssDir", "cssDirectory", "CSSLen", "CSSDoc", "codesLen", "ssD", "ssDar", "CSSDIR"], "capDir": ["apsVol", "apsDir", "casDirectory", "casDir", "apsDirectory", "capDirectory", "CapVol", "casdir", "capVol", "capdir", "CapDirectory", "apsdir", "casVol", "Capdir", "CapDir"], "licDir": ["lifDoc", "licDoc", "volDoc", "volDir", "voldir", "lifdir", "lifManager", "libdir", "libDoc", "volManager", "licdir", "licManager", "lifDir", "libDir", "libManager"], "midDir": ["casTier", "middir", "midTier", "limTier", "mindDIR", "casDir", "limDIR", "mindTier", "casdir", "mindDir", "limDir", "casDIR", "minddir", "limdir", "midDIR"], "filesDir": ["filesDIR", " filesPos", "stylesDir", "opensDirectory", "locksDir", "videosFolder", "pagesPos", "stylesDur", "locksDirectory", "FilesDir", "filesDur", "imagesDirectory", "imagesFolder", "locksDur", "pagesDir", "filesDirectory", "filesFolder", "opensDir", "videosFile", "FilesDirectory", "imagesDir", "pagesVol", "stylesDirectory", "locksDIR", "filesPos", "opensDur", "stylesDIR", "ballsVol", "imagesFile", "FilesFile", "ballsPos", "filesFile", " filesVol", "ballsDir", "videosDirectory", "FilesFolder", "opensDIR", "filesVol"], "videosDir": ["imagesDb", "viewsDirectory", "videosUrl", "videoDir", "videoUrl", " videosDb", "videosFile", "imagesDir", " videosUrl", "videoDirectory", "viewsUrl", " videosFile", "videosDb", "videoFile", " videosDirectory", "videosDirectory", "viewsDir", "viewsFile", "videoDb"], "imagensDir": ["imgensFile", "imagersDIR", "imagersDir", "imagenJar", "imgentsDir", "imagersFile", "imgentsFile", "imagenciesDIR", "imgensDIR", "imagenDir", "imagersJar", "imagentsJar", "imagenciesDir", " imagensDirectory", "imagersDirectory", "imagentsDir", "imagentsFile", "imagentsDirectory", "imagenciesDirectory", "imgensDir", "imgentsDIR", "imgentsDirectory", "imagensJar", " imagersJar", "imagensDIR", "imgensDirectory", " imagensFile", "imagensFile", "imagensDirectory", " imagersFile", " imagensJar", " imagersDirectory", "imagentsDIR", "imagenDirectory", " imagersDir", "imagenFile", "imagenciesFile"], "local": ["active", "lock", "localhost", " Local", "standard", "specified", "loc", "name", "data", "current", "present", "util", "where", "basic", "self", "remote", "input", "p", "partial", "personal", "state", "shared", "base", "log", "part", "user", "inner", "conf", "managed", "LOC", "l", "back", "temp", "defined", "d", "relative", "request", "path", "serial", "pal", "small", "tmp", "pass", "http", "Local", "file", "global", "prefix", "valid", "same", "Location", "upload", "safe", "dir", "initial", "total", "home", "directory", "location", "available", "internal", "json", "username"], "srcCss1": ["srcCcss4", "srcCfgPre", "srcCse1", "srcCcss0", "srcCass1", "srcCcss11", "srcCse2", "srcCpe2", "srcPcssPre", "srcCrss2", "srcPss81", "srcPcss81", "srcCrss3", "srcRss81", "srcRss2", "srcCse11", "srcPss4", "srcCcss1", "srcRss1", "srcCfg2", "srcCass0", "srcPss2", "srcCcss81", "srcCcssPre", "srcCss81", "srcCrss1", "srcCrss81", "srcPcss1", "srcCass11", "srcRss0", "srcCss11", "srcPssPre", "srcPcss3", "srcPss3", "srcCpe4", "srcCass3", "srcCfg4", "srcCfg1", "srcCass81", "srcCss0", "srcRcss11", "srcPss1", "srcCpe1", "srcRcss1", "srcRcss0", "srcCcss2", "srcPcss2", "srcRss11", "srcRcss2", "srcCrss11", "srcCcss3", "srcCass2", "srcCpePre", "srcRcss81", "srcCse0", "srcCssPre", "srcPcss4"], "destCss1": ["destCxx2", "destPssCard", "destPcss1", "destCfg0", "destCrss2", "destCcss1", "destCcss2", "destPcss0", "destCcss0", "destCrss81", "destCcss81", "destCass3", "destCfg2", "destPcssCard", "destCass1", "destCassCard", "destCcss3", "destPcss2", "destCxxCard", "destCss0", "destCss81", "destCxx1", "destCxx3", "destCrss1", "destCfg3", "destPss81", "destCass2", "destPcss81", "destPcss3", "destPss3", "destCcssCard", "destPss0", "destPss1", "destCrss0", "destPss2", "destCssCard", "destCass81", "destCrss3", "destCfg1"], "srcCss2": ["srcUss1", "srcCcss4", "srcCfgL", "srcChessTwo", "srcChess1", "srcCass1", "srcCrss2", "srcCrss3", "srcPssL", "srcPcssL", "srcCssL", "srcUcss1", "srcCcss1", "srcCssB", "srcUcssB", "srcCass4", "srcUssTwo", "srcCfg2", "srcCcss52", "srcCss27", "srcPss2", "srcAccss52", "srcCross52", "srcCross4", "srcAcss1", "srcCrss27", "srcCfg3", "srcCrss1", "srcPcss27", "srcCssTwo", "srcPcss1", "srcPcss3", "srcCcssB", "srcPss3", "srcCng27", "srcCng1", "srcAcss4", "srcCfg1", "srcCross2", "srcChessB", "srcPss1", "srcAcss2", "srcCass52", "srcCcssTwo", "srcCng2", "srcCss52", "srcCcss2", "srcPcss2", "srcAccss2", "srcCfgB", "srcCcss27", "srcCrssL", "srcCcss3", "srcCcssL", "srcUss2", "srcCass2", "srcPss27", "srcUcss2", "srcAccss4", "srcUcssTwo", "srcAccss1", "srcUssB", "srcCross1", "srcCfgTwo", "srcAcss52", "srcChess2"], "destCss2": ["destCest1", "destNcss4", "destCcss32", "destCest3", "destCcss4", "destCcss72", "destCss32", "destNcss2", "destCcss1", "destCcss2", "destNcss3", "destCfg2", "destNss32", "destCess2", "destNssB", "destNcss32", "destCcss3", "destCfg4", "destNss4", "destCess32", "destNss2", "destCfgB", "destCfg3", "destCess1", "destNcss1", "destNss3", "destCest2", "destNss1", "destCess4", "destCssB", "destNcssB", "destCss72", "destCestB", "destNss72", "destNcss72", "destCfg72", "destCess72", "destCcssB", "destCfg1", "destCfg32"], "srcCss3": ["srcScss15", "srcCcss4", "srcCcssThird", "srcCshThird", "srcCstyle2", "srcScss3", "srcRcss4", "srcRss1", "srcCcss183", "srcCstyle15", "srcCfg3", "srcCcss6", "srcRss183", "srcCsh2", "srcCfg4", "srcCfg1", "srcScstyle93", "srcCrssAND", "srcPss6", "srcCass1", "srcPcss6", "srcRss2", "srcScss93", "srcRcss183", "srcPcssAND", "srcRcssThird", "srcClass15", "srcScstyle2", "srcCcss1", "srcPss2", "srcCstyle93", "srcPcss3", "srcClass93", "srcRcss1", "srcClass3", "srcCcssAND", "srcRcss2", "srcCsh183", "srcCsh3", "srcClass2", "srcCsl3", "srcCssAND", "srcCrss3", "srcPssAND", "srcRcss3", "srcCssThird", "srcRssThird", "srcRss3", "srcCcss2", "srcPcss2", "srcCass2", "srcCstyle6", "srcScss2", "srcCsl2", "srcCstyle3", "srcCrss2", "srcCss93", "srcCslThird", "srcCcss15", "srcRss4", "srcCass4", "srcCfg2", "srcCrss6", "srcCsl183", "srcScstyle3", "srcPss3", "srcCass3", "srcCss15", "srcCcss3", "srcCstyleAND", "srcCss183", "srcCcss93", "srcScstyle15"], "destCss3": ["destScrss6", "destCja6", "destCross03", "destNcss2", "destCrss2", "destCcss2", "destCstyle43", "destCss183", "destCrss6", "destScss2", "destPcss03", "destCcss53", "destCstyle03", "destNcss3", "destCass3", "destCja3", "destCja2", "destCcss3", "destScss6", "destCss03", "destCstyle2", "destCcss6", "destScss183", "destCcss183", "destScrss2", "destPcss2", "destNss2", "destNcss43", "destPss53", "destPcss53", "destNss3", "destCss43", "destCcss43", "destPss03", "destNss43", "destCass2", "destCstyle53", "destScrss183", "destCcss03", "destPcss3", "destPss3", "destCross2", "destScrss3", "destCross3", "destCross53", "destCass43", "destCstyle3", "destScss3", "destCss53", "destCrss183", "destPss2", "destCrss3", "destCja183"], "srcCss4": ["srcCcss4", "srcCass1", "srcPssFour", "srcCrss4", "srcCrss2", "srcPss4", "srcCcss1", "srcCass4", "srcPss2", "srcCrss1", "srcPcss1", "srcPss1", "srcCssFour", "srcCcss2", "srcPcss2", "srcPcssFour", "srcCass2", "srcCcssFour", "srcCassFour", "srcCrssFour", "srcPcss4"]}}
{"id1": "23611770", "id2": "20924119", "code1": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"handle": [" post", " transport", " abort", "Handle", " process", " reload", " append", " redirect", " handles", " rewrite", " execute", " handler", " fn", " shutdown", " rename", " transform", " serve", " manage", "process", "transfer", " upload", " perform", " loop", " work", " restart", " next", " transfer", " operate"], "srcChannel": ["rcClient", "sourceChan", "rcConnection", "destClient", "sourceClient", " srcchannel", "destChan", "sourceChannel", "rcChan", "sourceConnection", " srcConnection", "srcClient", "srcChan", "sourcechannel", "srcchannel", "rcChannel", "destchannel", " srcClient", "srcConnection", " srcChan"], "destChannel": ["DestStream", "srcSocket", "sourceChan", " destHandler", " destSocket", " destStream", "Destchannel", "destStream", "DestCan", "descCan", "distStream", "distChannel", "destChan", "sourceChannel", "distChan", "DestChannel", "destCan", "descHandler", " destchannel", "srcChan", "destSocket", "DestHandler", " destChan", " destCan", "descChan", "destHandler", "sourceSocket", "distchannel", "destchannel", "descChannel", "DestChan"], "destOutFile": ["destPathfile", "destPointFile", "DestInFile", "destOutputFile", "tempOutSite", "destTemplatefile", "destOutSite", "destOutputSite", "destInDir", "DestInDirectory", "destInDirectory", "destoutDir", "destoutCode", " destOutfile", "destLogFilename", "tempOutDir", "DestInFiles", "destoutFiles", " destOutPath", "destPathFile", "DestOutfile", "destPathFiles", "destOutfile", "featOutFile", "featTemplatefile", "destActionfile", "destPointDir", " destOutputPath", "destOutDir", "destOUTCode", "destInFile", "featTemplateFiles", " destOutputFile", "DestInFilename", "featTemplateFile", "destInPath", " destPathFiles", " destOutputFilename", "destOUTSite", " destOutDir", "featOutFiles", "destOUTFile", " destOutputFiles", "destOutFiles", "destPathDir", "destOUTFiles", " destPathDir", "featOutDir", "destOUTDir", "tempOutFiles", "destOutputfile", "DestOutDirectory", "destLogFiles", "destOutputPath", "destInfile", "DestOutFile", "DestOutCode", "tempOutputFiles", "DestInCode", "tempOutputDir", "DestOutFiles", "DestOutFilename", "destInCode", "destOutputDirectory", "DestInfile", "destActionFile", "destInSite", " destOutFilename", "destInFiles", "destOutCode", " destPathFile", "destoutFile", "tempOutFile", " destPathfile", "destLogFile", "tempOutputSite", "destPointFilename", "DestInDir", "destTemplateFile", "destOutputDir", "destOutFilename", "destLogPath", "featTemplateDir", "destActionDir", "featOutfile", "destPointDirectory", "destTemplateDir", "destOutputFiles", "destInFilename", "destOutPath", "tempOutputFile", "destTemplateFiles", " destOutFiles", "destActionFiles", "destOutputFilename", "DestOutDir", "destOutDirectory"], "destOutFileCompressed": ["destOutFileSupression", "destOutFilesExported", "destOutFilesCompacted", "destOutFilesCompressor", "destOutFileExressor", "destOutLineCompressor", "destOutLineExpressed", "destOutFileEncressed", "destOutFilesComposed", "destOutLineExpression", "destOutFileExressed", "destOutFileExposed", "destOutFileSuppressed", "destOutFileExplied", "destOutLineCompacted", "destOutFilesExplied", "destOutFileExpression", "destOutFilesExpress", "destOutFileRepressed", "destOutLineRepressor", "destOutFileExpressed", "destOutLineCompress", "destOutFilecompressed", "destOutFileSuposed", "destOutFileExress", "destOutLineRepressed", "destOutLineRepression", "destOutFileSupressed", "destOutFilesCompression", "destOutFilesComplied", "destOutFileRepression", "destOutFilesExposed", "destOutFileExacted", "destOutFileSuppressor", "destOutLineRepacted", "destOutFileExpacted", "destOutFileComposed", "destOutFilecompression", "destOutFileEncorted", "destOutFileSuppacted", "destOutFileCompress", "destOutFileExosed", "destOutFileExpress", "destOutFileComplied", "destOutFileReposed", "destOutFilesCompressed", "destOutFileExported", "destOutFilecompress", "destOutFileEncress", "destOutFileSupress", "destOutLineExpressor", "destOutFilesCompress", "destOutLineExposed", "destOutLineRepress", "destOutLineCompression", "destOutFileCompression", "destOutFilesExpression", "destOutFileRepressor", "destOutFilesExpressed", "destOutFileCompacted", "destOutFilesExpressor", "destOutFileExorted", "destOutLineCompressed", "destOutFilesComported", "destOutLineComposed", "destOutFileReplied", "destOutFilesExpacted", "destOutFileComported", "destOutFileSuppress", "destOutFilecompacted", "destOutFilecompressor", "destOutFileRepacted", "destOutFileExpressor", "destOutFileRepress", "destOutFileCompressor", "destOutFileEncosed"], "out": ["full", "lock", "bin", "connection", "extra", "ext", "data", "doc", "name", "self", "socket", "error", "sync", "to", "ex", "outs", "one", "plain", "log", "copy", "conn", "w", "b", "output", "user", "again", "inner", "img", "part", "cache", "line", "writer", "cmd", "err", "o", "flush", "client", "OUT", "temp", "this", "key", "source", "image", "inc", "outer", "exec", "parent", "n", "conv", "post", "null", "io", "net", "server", "up", "file", "co", "resource", "exp", "Out", "obj"], "in": ["reader", "bin", "connection", "isin", "sin", "f", "login", "into", "data", "socket", "ins", "pin", "to", "cin", "min", "In", "log", "is", "part", "b", "inner", "again", "rin", "conn", "img", "win", "din", "l", "r", "IN", "err", "o", "pull", "ini", "source", "init", "image", "inc", "nin", "h", "config", "pass", "inn", "c", "up", "wave", "id", "file", "a", "lin", "token", "input", "con", "diff", "resource", "ac", "gin", "serv"], "buf": ["job", "cur", "cb", "bd", "seq", "data", "loc", "ff", "batch", "pool", "buff", "info", "Buffer", "cap", "bh", "rc", "log", "bl", "feat", "bb", "lc", "base", "b", "vec", "br", "num", "bytes", "box", "text", "val", "bag", "off", "la", "rb", "buffer", "block", "map", "ctx", "port", "uc", "lb", "path", "v", "context", "config", "cv", "func", "wb", "wave", "file", "pos", "src", "uf", "cas", "queue", "header", "bf", " buffer", "input", "ref", "pad", "result", "fb", "bc"], "len": ["nt", "lock", "le", "sl", "iter", "f", "data", "loc", "fl", "lim", "el", "rev", "body", "cap", "min", "en", "ind", " length", "ie", "ll", "lc", "part", "size", "num", "l", "line", "val", "pre", " lang", "lf", "la", "count", "limit", "url", "no", "li", "n", "led", "id", "pos", "lin", "fin", "Len", "length", "ln", "ler", "end"]}}
{"id1": "13981689", "id2": "22752444", "code1": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 1, "substitutes": {"md5Hash": [" MD6Sum", "md512hash", "md6hash", "md6Hash", " MD6hash", "md4Hash", "md5String", "md512String", "md6Sum", " MD6Hash", " MD5Sum", " MD6String", "md4String", "md4hash", " MD5String", "md4Sum", "md5Sum", "md512Sum", " MD5hash", "md6String", " MD5Hash", "md512Hash", "md5hash"], "src": ["SB", "msg", "inf", "sl", "data", "RC", "sup", "gb", "s", "sc", " source", "info", "inst", "buster", "str", "rc", "SourceFile", "ssl", "ptr", "text", "b", "bytes", "img", "Str", "href", "SOURCE", "ruby", "dest", "rb", "RGB", "Url", "lib", "source", "URL", "uri", "file", "sb", "input", "Source", "length", "Bytes", "string", "obj", "buf", "tmp"], "md": ["bd", "vd", "f", "mag", "cd", "rm", "wd", "mad", "dd", "m", "ma", " MD", "rod", "ind", "dig", "kg", "di", "mb", "mac", "cmd", "dm", "material", "d", "MD", "gd", "db", "mo", "mod", "hash", "amd", "mp", "code", "metadata", "mm", "pm", "ss", "mc", "ms", "od", "pd", "hd", "ad", "mand", "km", "editor"]}}
{"id1": "17296916", "id2": "19810820", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"logging": [" logger", "logger", "Logting", "loging", "blogging", "blogger", "logting", "bloging", "blogting", " logting", "Logger", "Logging", "Loging", " loging"], "wrap": [" wrapped", "lock", "pipe", "f", "util", "get", "self", "force", "widget", "handler", "create", "handle", "rap", "stream", "p", "web", "wp", "div", "wra", "binary", "ow", "format", "cache", "b", "wrapper", "w", "box", "work", "bag", " Wrap", "parse", "we", "image", "ws", "war", "wa", "api", "process", "build", "h", "or", "init", "run", "sw", "default", "wb", "wire", "transform", "nw", "word", "message", "flash", "frame", "cover", "ad", "use", "now"], "buffer": ["bm", "msg", "reader", "bin", "cb", "uffer", "iter", "ob", "manager", " buf", "batch", "table", "reference", "BU", "layer", "buff", "Buffer", " buffers", "log", "binary", "base", "copy", "bb", "cache", "b", "wrapper", "bridge", "loader", " receive", "board", "shell", "writer", "reply", "surface", "bar", "player", "source", "comment", "template", "feed", "image", "builder", "response", "url", "transfer", "view", "server", "pause", "code", "null", "document", "pb", "nb", "flash", "message", "frame", "uf", "header", "queue", "result", "cover", "ref", "print", "report", "fb", "bc", "buf"], "encoding": ["decoding", "ecoding", "encoded", "coded", "Encet", "Encoding", "encode", "decode", "packet", "ecoder", "encoder", "enoded", "ecryption", "unicoder", "encryption", "decoder", "coding", "cet", "packoder", "coder", "enoding", "packoding", "packoded", "unicode", "decoded", "enode", "unicoded", "ecoded", "enoder", "encet", "unicoding", "Encoded", "Encryption", "Encoder", "decryption"], "getEncoding": ["getCoding", "getEnoding", "getencoder", "getencasing", "getEncasing", "getEnoded", "getEncoded", "getCoder", "getencocol", "getEncocol", "getEncoder", "getencoding", "getCasing", " getEncocol", " getEnoder", " getEnocol", " getEnasing", " getEncoder", " getEnoding", "getEnasing", " getEncasing", " getEncoded", "getEnocol", " getEnoded", "getCoded", "getencoded", "getCocol", "getEnoder"], "headers": ["ids", "heads", "breaks", "vals", "values", "blocks", "s", "head", "options", "groups", "body", "settings", "relations", "str", "parts", "wrapper", "files", "bits", "features", "content", "rs", "workers", "caps", "lines", "writers", "strings", "padding", "ings", "h", "ints", "objects", "frames", "names", "ppers", "http", "keys", "fields", "details", "params", "ports", "ters", "links", "header", "properties", "host", "types", "plugins", "ers", "dict"], "is": ["ais", "Is", "iss", "isl", "las", "isol", "oss", "s", "bs", "ins", "ori", "has", "cms", "os", "isa", "IS", "abs", "obs", "was", "ops", "its", "i", "mis", "ws", "api", "or", "js", "nis", "\u00eds", "bas", "bis", "ists", "ui", "ois", "tis", "io", "http", "ris", "as", "in", "iso", "iris", "aos", "are", "es", "sis", "out", "us", "ios", "ms", "lis", "so", "fs", "ses", "isi"], "bos": ["bott", "osa", "bin", "opus", "fits", "ses", "cos", "las", "org", "bes", "oos", "bs", "ubs", "cms", "outs", "os", "bh", "bot", "obos", "base", "lins", "bi", "ko", "obs", "bits", "bots", "ops", "oses", "oks", "ubis", "bc", "abi", "pins", "mis", "ws", "mobi", "mos", "bas", "beans", "bis", "oes", "uds", "ois", "obo", "oops", "tis", "osi", "shadow", "aos", "bo", "ros", "flo", "los", "ios", "home", "zo", "zos", "so", "obi", "fs", "ob", "bones"], "e": ["x", "be", "er", "f", "ception", "oe", "error", "ze", "type", "p", "se", "one", "ae", "fe", "ec", "ie", "me", "je", "ale", "ite", "l", "E", "o", "exc", "err", "ke", "d", "i", "ev", "esi", "pe", "ise", "c", "ce", "a", "ea", "de", "re", "ee"]}}
{"id1": "14168494", "id2": "7425022", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferClass", " copiedClass", "copyFiles", " copyfile", " copiedfile", "transferFile", "transferfile", " copyFiles", " copiedFile", "transferFiles", "copyClass", " copyClass", "copyfile", " copiedFiles"], "dest": ["data", "loc", "name", "sup", "true", "later", " destination", "st", "destroy", "comb", "class", "orig", "output", "txt", "done", "dist", "temp", "this", "d", "source", "path", " Dest", "transfer", "null", "file", "wb", "Dest", "resource", "target", "out", "dir", "desc", "obj", "tmp"], "src": ["bin", "sl", "sin", "cb", "loc", "sup", "master", "gb", "ds", "s", "sc", "slice", "stream", "st", "sync", "inst", "download", "rc", "ssl", "copy", "rob", "img", "dist", "rb", "sq", "source", "sub", "storage", "filename", "url", "config", "sit", "file", "split", "Dest", "upload", "sel", "sb", "target", "tmp"], "srcChannel": ["sourceChan", "rcConnection", " srcStream", " srcButton", "rcCh", "destConnection", "srcSection", " srcchannel", "rcButton", "distStream", "distChannel", "destChan", "sourceButton", "sourceChannel", "distChan", "rcChan", " srcConnection", "rcSection", "srcCh", "srcChan", "rcStream", "inputConnection", " srcCh", "srcStream", "rcchannel", "srcButton", "sourcechannel", "destChannel", "srcchannel", "inputChannel", "rcChannel", "inputchannel", "destchannel", " srcSection", "distCh", "inputSection", "srcConnection", " srcChan"], "dstChannel": [" dstchannel", "Dstchannel", "drcchannel", "drcContext", "dstsConnection", " dstChan", " drdContext", "dstConnection", "drcChannel", "dstchannel", "dDestChannel", " drdchannel", "ddestConnection", "dsrcVideo", "drdchannel", "dstVideo", "dDestchannel", "drcChan", " dstsStream", " drdChan", "drdChannel", "DstChannel", "ddestChannel", "dstsStream", "Ddestchannel", " dstschannel", "dstContext", "dDestConnection", "ddestContext", "ddestChan", " dstStream", "ddestchannel", " dstConnection", "DstVideo", "DdestChannel", "dstChan", " dstsChannel", "DdestVideo", " drdChannel", "dDestStream", "ddestStream", "dsrcChannel", "drdContext", "dstschannel", "dstsChannel", "dsrcchannel", " dstContext", "ddestVideo", " dstsConnection", "drdChan", "dstStream", "drcVideo"]}}
{"id1": "14882263", "id2": "12724876", "code1": "    private void UploadActionPerformed(ActionEvent evt) {\n        JFileChooser chooser = new JFileChooser();\n        FileNameExtensionFilter filter = new FileNameExtensionFilter(\"*.jpg\", \"jpg\");\n        chooser.setFileFilter(filter);\n        File dir = new File(System.getProperty(\"user.home\"));\n        chooser.setCurrentDirectory(dir);\n        Component parent = null;\n        int returnVal = chooser.showOpenDialog(parent);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            UserStatus.setText(\"Bitte warten\");\n        }\n        try {\n            Pic.setVisible(false);\n            FTPClient client = new FTPClient();\n            client.connect(\"showus.de\");\n            client.login(\"web2\", \"kcinnay88\");\n            client.enterLocalActiveMode();\n            client.setFileTransferMode(FTPClient.BINARY_FILE_TYPE);\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            int reply = client.getReplyCode();\n            System.out.println(\"Connect returned: \" + reply);\n            FileInputStream in = new FileInputStream(chooser.getSelectedFile().getAbsolutePath());\n            System.out.println(\"Uploading File\");\n            client.storeFile(\"/html/Applet/user/\" + Config.id + \".jpg\", in);\n            client.logout();\n            in.close();\n            System.out.println(\"done\");\n            UserStatus.setText(\"Upload fertig, Bild wird aktuallisiert\");\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            UserStatus.setText(\"Fehler beim Upload\");\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void loadURL(URL url, String username, String password, JLabel statusDialogMBLabel) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (username != null && !username.equals(\"\")) {\n            if (password == null) {\n                password = \"\";\n            }\n            String encoding = new sun.misc.BASE64Encoder().encode(new String(username + \":\" + password).getBytes());\n            connection.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        this.tmpVRMLFile = File.createTempFile(\"xnavi-\", null, null);\n        System.out.println(\"Created tmp file: \" + this.tmpVRMLFile.getAbsolutePath());\n        FileWriter fw = new FileWriter(this.tmpVRMLFile);\n        long bytesInFile = this.tmpVRMLFile.length();\n        double sizeInMB = ((double) bytesInFile) / (1024.0 * 1024.0);\n        String response = \"\";\n        while ((inputLine = in.readLine()) != null) {\n            response = inputLine + \"\\n\";\n            fw.write(response);\n            fw.flush();\n            if (statusDialogMBLabel != null) {\n                bytesInFile = this.tmpVRMLFile.length();\n                sizeInMB = ((double) bytesInFile) / (1024.0 * 1024.0);\n                sizeInMB *= 100.0;\n                sizeInMB = (double) ((int) sizeInMB);\n                sizeInMB /= 100.0;\n                statusDialogMBLabel.setText(sizeInMB + \" MB\");\n                statusDialogMBLabel.repaint();\n            }\n        }\n        fw.close();\n        System.out.println(\"Wrote file \" + this.tmpVRMLFile.getAbsolutePath());\n    }\n", "label": 0, "substitutes": {"UploadActionPerformed": ["UploadActionOccuted", "UploadActionReformed", "UploadActionOccformed", "UploadActionPerumed", "UploadActionEnformed", "UploadActionOccced", "UploadButtonOccformed", "UploadActionEnced", "UploadActionOccumed", "UploadActionReuted", "UploadButtonPerumed", "UploadActionEnuted", "UploadActionEnumed", "UploadActionReced", "UploadButtonPerced", "UploadActionReumed", "UploadButtonPerformed", "UploadButtonOccuted", "UploadButtonOccumed", "UploadButtonOccced", "UploadActionPerced", "UploadButtonPeruted", "UploadActionPeruted"], "evt": ["Evte", " evtf", "Evt", " averte", " averts", "Evts", " Evte", " Evt", " evts", " Evts", " avertf", "Evtf", " avert", " evte", " Evtf"], "chooser": ["composer", "Choosed", "Choosite", "joo", "Chooe", "chocho", "closed", "closer", "dialose", "Choose", "combose", "coose", "promoser", "choo", "jooser", "Choosing", "dialosen", "coosite", "promosite", "closen", "joiner", "closing", "choose", "Choosen", "compcho", "joosen", "coosed", "choosen", "choiner", "cooe", "dialcho", "promosen", "comboser", "composen", "compose", "choosed", "coiner", "Chocho", "promose", "Chooser", "combosed", "compo", "dialoser", "combiner", "promo", "chooe", "choosing", "cooser", "promoe", "joosing", "joosed", "choosite", "joose"], "filter": ["lock", "ext", "f", "name", "ff", "fl", "self", "force", "handler", "aff", "type", "method", "fil", "sort", "class", "match", "plugin", "format", "model", "acl", "cache", "b", "user", "query", "atter", "list", "map", "Filter", "limit", "path", "object", "pattern", "form", "url", "config", "finder", "flat", "file", "search", "sf"], "dir": ["lock", "f", "data", "doc", "name", "loc", "handler", "type", "info", "base", "log", "direction", " directory", "cache", "user", "loader", "part", "conf", "Dir", "zip", "root", "dist", "source", "db", "project", "path", "url", "config", "store", "ir", "uri", "folder", "file", "id", "DIR", "fd", "dat", "out", "home", "directory", "area", "pkg"], "parent": ["Parent", "current", "name", "point", "self", "channel", "container", "handler", "p", "div", "parents", "component", "page", "part", "user", "instance", "section", "root", "image", "child", "port", "path", "object", "pid", "url", "document", "menu", "file", "folder", "id", "resource", "home", "location", "directory", "ip", "editor"], "returnVal": ["returnval", "returnVol", "continueVal", "errorVal", "returnObj", "continueObj", "continueValue", "continueval", "ReturnVol", " returnval", "errorVol", "returnValue", "ReturnValue", "ReturnObj", " returnValue", "Returnval", " returnObj", " returnVol", "errorval", "ReturnVal", "errorValue"], "client": ["connection", "https", "standard", "app", "open", "get", "util", "force", "phone", "socket", "channel", "session", "complete", "remote", "simple", "secure", "Client", "p", "web", "clean", "pi", "local", "pc", "per", "base", "ssl", "plugin", "conn", "cache", "user", "cloud", "contract", "cell", "console", "external", "call", "proxy", "cli", "service", "i", "connect", "api", "use", "request", "cl", "default", "config", "friend", "close", "server", "quit", "core", "http", "c", "file", "net", "ce", "co", "google", "contact", "cm", "con", "out", "custom", "help", "queue", "ip", "end", "grid"], "reply": ["msg", "connection", "answer", "error", "reason", "respond", " replied", " replies", " response", "sync", "send", "info", "ply", "state", "mode", "rc", "status", "req", "repl", "query", "err", "back", "rr", "count", "parse", "Reply", "response", "like", "next", "close", "exit", "code", "uri", "xxxxxxxx", "post", "ise", "id", "message", "action", "ry", "result", "link", "write", "resp"], "in": ["reader", "bin", "login", "f", "data", "tin", "socket", "ins", "pin", "stream", "p", "ex", "min", "In", "pc", "rec", "is", "conn", "inner", "again", "l", "din", "r", "IN", "ax", "ini", "i", "source", "image", "inc", "nin", "n", "io", "inn", "file", "up", "id", "cgi", "ic", "on", "resource", "input", "out", "con", "ac", "gin", "serv", "fc"]}}
{"id1": "17974661", "id2": "16215393", "code1": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "code2": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"requestServerModifications": ["requestServerModifies", "requestClientModurations", "requestServerModification", "requestServerMutifications", "requestServerModurations", "requestClientmodifications", "requestServerMutification", "requestServerMuturations", "requestClientmodification", "requestClientmodurations", "requestServermodifications", "requestServermodification", "requestServermodurations", "requestServermodifies", "requestClientModifies", "requestClientModifications", "requestClientmodifies", "requestServerMutifies", "requestClientModification"], "sessionId": [" sessionInfo", "sessionID", "connectionId", "sessionName", "connectionInfo", "essionKey", "Sessionid", "SessionId", "essionName", "essionId", "connectionID", "sessionid", "sessionKey", " sessionName", "sessionInfo", "connectionName", "connectionid", " sessionid", "SessionID", "SessionInfo", "essionID", " sessionID", " sessionKey", "connectionKey"], "out": ["lock", "data", "name", "socket", "session", "remote", "ex", "outs", "timeout", "log", "cache", "conn", "again", "output", "user", "content", "writer", "err", "o", "flush", "OUT", "external", "buffer", "image", "path", "exec", "object", "parent", "url", "config", "server", "io", "in", "file", "resource", "result", "report", "Out", "write"], "client": ["connection", "https", "app", "self", "channel", "socket", "session", "handler", "Client", "web", "per", "base", "ssl", "conn", "proxy", "call", "cli", "service", "connect", "api", "request", "driver", "url", "config", "server", "uri", "bird", "io", "http", "c", "ce", "php", "resource", "con", "host"], "builder": ["reader", "building", "filter", "array", "info", "str", "xml", "letter", "base", "log", "b", "keeper", "builders", "built", "r", "writer", "parser", "bean", "address", "row", "buffer", "build", "image", "db", "api", "request", "path", "object", "Builder", "url", "v", "door", "uri", "http", "prefix", "message", "result", "sb", "orb", "length", "string", "runner"], "method": ["connection", "job", "trip", "data", "name", "session", "type", "METHOD", "operation", "stream", "send", "event", "plugin", "user", "wrapper", "instance", "r", "ter", "pull", "service", "call", "build", "api", "request", "process", "path", "url", "view", "server", "http", "function", "module", "message", "resource", "invoke", "string", "use", "end", "Method"], "response": ["full", "connection", "data", "version", "ception", "error", "session", "respond", "stream", "results", "body", "application", "received", "Response", "status", "page", "output", "success", "reply", "service", "found", "entry", "image", "feed", "value", "request", "object", "next", "default", "document", "relation", "server", "view", "http", "wave", "function", "index", "message", "result", "resource", "res", "report", "onse", "json", "serv", "resp", "site"], "header": ["connection", "er", "director", "data", "name", "manager", "version", "error", "handler", "head", "body", "layer", "info", "field", "event", "param", "status", "prev", "inner", "content", "her", "line", "writer", "err", "key", "dr", "buffer", "entry", "block", "hr", "value", "port", "cookie", "h", "request", "second", " Header", "Header", "url", "attribute", "document", "server", "number", "metadata", "holder", "message", "headers", "result", "token", "cover", "host", "forward", "string"], "code": ["be", "x", "Code", "f", "coded", "name", "ception", "error", "reason", "complete", "type", "change", "ge", "state", "mode", "one", "ec", "codes", "ie", "status", "rule", "ide", "zip", "done", "line", " status", "success", "e", "key", "CE", "see", "expected", "reply", "back", "zone", "call", "count", "go", "ode", "age", "cod", "close", "level", "score", "ose", "number", "rate", "c", "xx", "ce", "id", "message", "co", "last", "scene", "result", "cause", "charge", "length", "none", "re", "de"], "expectedLength": ["pectedlength", "actualLength", "pectedLength", "expectedLen", "pectedLen", "actualLen", "actualSize", " expectedlength", " expectedLen", "pectedSize", "expectedlength", " expectedSize", "actuallength", "expectedSize"], "is": ["x", "ire", "mark", "ais", "Is", "data", "iss", "si", "isl", "_", "name", "ri", "error", "s", "bs", "ins", "stream", "non", "info", "not", "os", "im", "set", "isa", "IS", "status", "ish", "isc", "was", "ops", "its", "key", "i", "ci", "select", "ws", "js", "bis", "uri", "io", "ii", "ris", "as", "in", "iso", "id", "params", "iris", "are", "es", "res", "us", "lis", "ms", "ios", "serv", "ip", "fs", "isi"]}}
{"id1": "16851955", "id2": "17996547", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"testTrainingBackprop": ["testTrainBackpointer", "testTrainingBackdrop", "testTrainBackpressure", "testTrainingFrontdrop", "testTrainBACKpointer", "testTrainBackdrop", "testTrainingFrontprop", "testTrainBACKprop", "testTrainingBackpointer", "testTrainingFrontpressure", "testTrainingBACKprop", "testTrainingBackpressure", "testTrainBACKdrop", "testTrainBackprop", "testTrainingBACKpressure", "testTrainBACKpressure", "testTrainingBACKdrop", "testTrainingBACKpointer", "testTrainingFrontpointer"], "temp": ["full", "lock", "save", "pipe", "f", "data", "current", "Temp", "mount", "archive", "container", "session", "stable", "pdf", "emp", "clean", "ex", "local", "base", "copy", "model", "wrap", "cache", "output", "txt", "tem", "zip", "writer", "font", "dest", "porary", "this", "test", "buffer", "storage", "template", "path", "parent", "v", "form", "config", "empty", "io", "flat", "http", "file", "folder", "cel", "input", "out", "dat", "fake", "directory", "tmp"], "layers": ["lients", "licikes", "players", "flayers", "dlanguages", " languages", "liacks", "blasses", "liayers", "licibraries", " lasses", "blanguages", " lays", "Layers", "liibraries", " lowers", "Lients", "nlagers", "flanguages", "lagers", "nlibraries", "bayers", " lobs", " lients", "dlacks", "gobs", "licagers", "placks", "languages", "dlibraries", "planguages", "lacks", "dlayers", " lacks", "bays", "plasks", " likes", "lasks", " lasks", "lobs", "bowers", "slayers", " lagers", "fllements", "slays", "nlikes", "slowers", "Lobs", " lores", "gayers", "licayers", "lowers", "flasses", " llements", "lays", "likes", "lasses", "blayers", "backs", "lores", "dlasks", "slacks", "bllements", "liores", "libraries", "dlores", "llements", "nlayers", " libraries", "gients"], "fann": ["garn", "fannon", "gnn", "Fanny", "gann", "xfain", "farn", "xfann", "sfann", "Fann", "elfann", "Fannon", "fain", "sfain", "fanny", "fana", "Fain", "xfannon", "elfana", "fnn", "lnn", "xfanny", "elfnn", "sfannon", "lann", "sfanny", "elfarn", "larn", "lana", "gana"], "trainer": ["triner", "strainer", "stracker", "striner", "retainer", "traainer", "Trainer", "Triner", "trrain", "tracer", " tracker", "traacker", "rainer", "strain", "tacker", "Trrain", " tracer", "Tracker", "tacer", "Trayer", "Tracer", "tainer", "tracker", "traacer", "retacer", "retiner", "stracer", "trarain", "racer", "trayer", "racker", "train", " train", "retayer", "strayer", "rain"], "desiredError": ["desireSize", "desciredProblem", "designedError", "descidedError", "descidedFailure", "resiredEvent", "reservedEvent", "desiredProblem", "DesiredError", "desireException", "DesireException", "desidedFailure", "reservedSize", "DesiredSize", "reservedOrder", "desidederror", "descidederror", "designedSize", "desizedError", "resiredOrder", "desciredFailure", "despectedError", "desidedError", "resiredSize", "desciredError", "deservedEvent", "reservedError", "desizedException", "desiredFailure", "deservedError", "designedOrder", "desirableEvent", "desiredException", "resiredError", "desiredOrder", "desiringError", "desidedProblem", "desirableSize", "desirederror", "descirederror", "descidedProblem", "deservedOrder", "desivedException", "despectedProblem", "despectedFailure", "desizedSize", "desivedSize", "despectederror", "DesiredException", "desirableOrder", "desiringProblem", "desirableError", "deservedSize", "desiringerror", "desiringFailure", "desireError", "DesireError", "DesireSize", "desiredSize", "designedEvent", "desiredEvent", "desivedError"], "mse": [" mce", "fSE", "mze", "mSE", "mte", "fmce", " mte", " mSE", "mge", "Mte", "Mse", "MSE", "Mce", "fmze", "gmSE", "fmte", "fmse", " mge", "gmse", " mze", "gmce", "fge", "Mge", "gmge", "mce", "Mze", "fse", "fce"]}}
{"id1": "18544890", "id2": "4716110", "code1": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"get": ["data", "create", "remote", "send", "info", "download", "load", "find", "gets", "match", "cache", "query", "end", "pull", "call", "show", "list", "select", "Get", "next", "GET", "update", "debug", "resource", "start", "json"], "url": ["connection", "sl", "f", "loc", "name", "email", "ur", "layer", "download", "str", "ll", "base", "ssl", "ls", "rule", "page", "href", "l", "key", "address", "Url", "service", "URL", "source", "image", "feed", "path", "server", "uri", "date", "route", "http", "file", "id", "resource", "www", "queue", "host", "location", "string"], "lat": ["tile", "offset", "alt", "league", "loc", "data", "point", "las", "at", "play", "range", "Lat", "gal", "local", "bot", "base", "street", "l", "distance", "la", "address", "live", "port", "game", "late", "width", "route", "west", "pos", "id", "out", "height", "location", "length", "home", "grid"], "lon": ["offset", "loc", "depth", "vel", "range", "layer", "log", "base", "position", "lan", "fat", "online", "left", "l", "val", "off", "la", "lang", "live", "lb", "ino", "width", "level", "nl", "number", "ng", "lag", "pos", "len", "on", "lin", "land", "location", "ln", "length"], "count": ["offset", "f", "name", "force", "depth", "error", "batch", "pool", "type", "amount", "load", "timeout", "log", "base", "more", "cache", "time", "size", "num", "all", "part", "val", "list", "found", "Count", "limit", "age", "sum", "level", "number", "code", "n", "scroll", "c", "file", "id", "index", "len", "follow", "total", "length"], "req": ["https", "ext", "ur", "worker", "proc", "rob", "rf", "cmd", "work", "err", "rr", "requ", "ctx", "exec", "next", "rt", "io", "c", "fin", "exp", "fb", "fit", "cur", "org", "socket", "respond", "ru", "pub", "fe", "sem", "conn", "cache", "conf", "cook", "ok", "plug", "query", "client", "pull", "rb", "call", "build", "wa", "Request", "dq", "gr", "fail", "qt", "pkg", "ver", "f", "loc", "reg", "grad", "p", "check", "r", "fr", "temp", "test", "hr", "form", "http", "res", "ref", "cp", "serv", "resp", "wx", "cb", "q", "ctr", "download", "pr", "jp", "require", "sq", "cf", "request", "server", "post", "bur", "tr", "orb", "def", "rx"], "gl": ["ul", "lol", "GL", "gm", "sl", "loc", "fl", "ogl", "las", "berg", "gb", "lim", "g", "cal", "gold", "groups", "el", "gn", "ang", "bs", "gal", "fe", "ger", "pl", "bl", "ll", "lc", "img", "gel", "l", "Gl", "fr", "console", "go", "list", "fx", "gre", "rg", "bg", "cl", "nl", "view", "ml", "browser", "global", "ga", "gg", "hl", "sel", "gall", "bel", "gi", "coll", "cm", "rl", "il"], "br": ["reader", "mr", "Br", "arr", "ctr", "stream", "body", "div", "str", "bh", "bl", "yr", "pr", "b", "bridge", "img", "cr", "r", "ar", "err", "fr", "dr", "rb", "bar", "BR", "sp", "hr", "brush", "ch", "lr", "browser", "io", "gr", "sr", "bro", "tr", "res", "result", "ber", "ler", "bc", "buf"], "line": ["le", "sl", "data", "name", "char", "lo", "el", "sync", "ge", "str", "letter", "bl", "log", "rule", "inline", "base", "lc", "page", "text", "cle", "l", "cell", "e", "lines", "fr", "key", "lf", "ine", "row", "style", "comment", "ne", "block", "source", "live", "entry", "Line", "ino", "cl", "nl", "code", "unit", "pe", "jo", "file", "LINE", "word", "pos", "co", "sel", "lin", "link", "string", "end", "look"]}}
{"id1": "15799935", "id2": "8328527", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public void insertJobLog(String userId, String[] checkId, String checkType, String objType) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preStm = null;\n        String sql = \"insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)\";\n        String cleanSql = \"delete from COFFICE_JOBLOG_CHECKAUTH where \" + \"user_id = '\" + userId + \"' and check_type = '\" + checkType + \"' and obj_type = '\" + objType + \"'\";\n        try {\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            preStm = connection.prepareStatement(cleanSql);\n            int dCount = preStm.executeUpdate();\n            String sHaveIns = \",\";\n            preStm = connection.prepareStatement(sql);\n            for (int j = 0; j < checkId.length; j++) {\n                if (sHaveIns.indexOf(\",\" + checkId[j] + \",\") < 0) {\n                    preStm.setInt(1, Integer.parseInt(userId));\n                    preStm.setInt(2, Integer.parseInt(checkId[j]));\n                    preStm.setInt(3, Integer.parseInt(checkType));\n                    preStm.setInt(4, Integer.parseInt(objType));\n                    preStm.executeUpdate();\n                    sHaveIns += checkId[j] + \",\";\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            log.debug((new Date().toString()) + \" \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0228\ufffd\ufffd\u02a7\ufffd\ufffd! \");\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n                throw e;\n            }\n            throw ex;\n        } finally {\n            close(null, null, preStm, connection, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"saveAttachmentBody": ["saveAttachedPart", "saveAttachedBody", "saveAppensionFile", "saveAttPartPart", "saveAttachmentPart", "saveAttachedFile", "saveAttensionBody", "saveAttPartFile", "saveAppachmentbody", "saveAppensionbody", "saveAttensionbody", "saveAppensionPart", "saveAttachedbody", "saveAttachmentFile", "saveAppachmentFile", "saveAttachmentbody", "saveAttPartBody", "saveAppachmentPart", "saveAttensionFile", "saveAppensionBody", "saveAppachmentBody", "saveAttensionPart", "saveAttPartbody"], "context": ["connection", "reader", "current", "Context", "version", "manager", "present", "channel", "container", "support", "cca", "ca", "state", "cms", "event", "definition", "center", "component", "cache", "text", "front", "concept", "content", "collection", "translation", "client", "subject", "service", "kernel", "ctx", "template", "cf", "request", "parent", "driver", "project", "environment", "system", "config", "document", "view", "c", "ce", "message", "community", "resource", "input", "queue", "mc", "coll", "contact", "host", "network", "processor", "media"], "part": ["connection", "app", "name", "point", "channel", "place", "type", "from", "body", "to", "p", "partial", "state", "phase", "event", "art", "per", "base", "component", "position", "parts", "Part", "section", " parts", "pre", "translation", "patch", "mission", "PART", " Part", "comment", "service", "source", "block", "pod", "image", "or", "media", "parent", "object", "file", "message", "upload", "po", "chapter", "plan", "area", "html", "Parts", "start"], "localAttachment": ["LocalAssachment", " localAttachachment", "localPartribution", "localAttachension", "localAttension", "localAvacher", " localAttrollment", "LocalAttment", "localAvacement", "localInstribution", "localAttacement", "localArtment", " localAttribution", " localAttention", "localAddment", "localAttment", " localAttacement", " localExtachment", " localPartension", "LocalAttention", "localattention", "localattrollment", "localAssention", " localPartribution", "LocalAssail", "localAvachment", "localPartension", "localAvention", "localArtail", "localAssment", " localPartention", "localAttachrollment", "LocalAttachment", "localAssail", " localExtacement", "localAddrollment", "localAttachention", "LocalAttail", "localPartention", "localExtacher", " localAttension", "localAttachacement", "localAttacher", "localPartachment", "localAttribution", "localAddail", " localExtacher", "LocalAssment", "localattachment", "localArtention", " localExtention", "localAttention", " localAttachrollment", "localAttrollment", " localAttacher", "localArtachment", "localAttail", "localAssachment", " localPartachment", " localAttment", "localExtacement", "localExtachment", "localAttachachment", "localAttachribution", "LocalAssention", "localInstachment", "localInstention", " localAttachention", "localExtention", "localInstension", "localAddachment", "localattment", "localAddention", "localAttachacher"], "accountId": ["contractId", "contractName", "jobid", "accountInfo", "contactid", "jobId", "appInfo", " accountID", "AccountName", "appId", "accountid", "feedID", "Accountid", "appID", "accInfo", " accountid", "feedid", "accId", "accountID", "appid", "feedName", "feedId", "AccountId", "jobName", "jobID", "accID", "AccountID", "accid", " accountInfo", "accountName", "contractid", "contactName", "contactId", " accountName"], "attachmentId": ["addachmentID", "attociationID", "attlementName", "attmentId", "atachmentReference", "attociationType", "addachmentType", "extachmentid", "adachmentID", "attentionId", "addentionID", "attmissionID", "attmissionId", "extachmentId", "atachmentName", "atociationReference", "attensionSource", "attentionSource", "adachmentInfo", "atociationName", "attlementId", "attmentName", "attmentReference", "attociationId", "attachmentID", "attachedType", "attentionIndex", "attentionUrl", "attociationReference", "atociationID", "extachmentSource", "attociationUrl", "attlementReference", "attociationName", "attachmentReference", "attlementID", "attensionid", "attachmentSource", "attentionType", "attachedID", "attentionid", "extensionSource", "atociationId", "attachedUrl", "attptionID", "adachmentIndex", "attensionID", "addentionId", "extensionid", "attptionId", "adentionIndex", "attmissionSource", "attmissionid", "attachmentType", "attachmentIndex", "attachmentInfo", "addachmentId", "adentionInfo", "attagramIndex", "attachmentUrl", "attagramInfo", "atachmentID", "adachmentId", "atachmentId", "addachmentUrl", "attachmentName", "attptionIndex", "attmentID", "extachmentID", "attentionID", "attachmentid", "attptionInfo", "attachedId", "extensionId", "attentionInfo", "adentionId", "extensionID", "addentionUrl", "attensionId", "attagramID", "attagramId", "adentionID", "addentionType"], "in": ["reader", "bin", "login", "f", "data", "it", "socket", "slice", "ins", "pin", "p", "cin", "info", "load", "In", "is", "inside", "copy", "conn", "inner", "again", "din", "IN", "err", "plus", "pull", "ini", "i", "source", "init", "image", "inc", "nin", "or", "url", "pass", "inn", "file", "as", "id", "up", "a", "input", "con", "ac", "gin"], "saveIn": [" savein", "savIn", "aveIn", "avein", "saveOut", "saveIN", "aveAs", " saveIns", "stageIn", "savAs", "writeIN", " saveOut", "SaveIns", "writeIn", "aveOut", "savOut", "stageOut", "savein", "stageIns", "SaveIn", "saveIns", "stageAs", " saveIN", "savin", "writeOut", "SaveAs", "aveIN", "SaveOut", "writein"], "saveAs": ["openAs", "copyAs", "saveAt", "openAS", "saveOut", "createAt", "copyas", " saveOut", "copyIn", "writeIn", " saveas", " saveAS", "writeAs", "SaveAS", "createAS", "saveAS", "SaveIn", "createAs", "saveFile", " saveFile", "copyAS", " saveAt", "writeOut", "openAt", "openFile", "SaveAs", "saveas", "writeAS", "SaveOut", "createFile", "Saveas"], "out": ["bin", "ext", "data", "name", "at", "s", "sync", "to", "ex", "outs", "copy", "page", "conn", "again", "output", "cache", "inner", "line", "writer", "err", "flow", "o", "client", "off", "OUT", "temp", "this", "plus", "source", "init", "image", "inc", "path", "exec", "outer", "v", "other", "default", "null", "io", "c", "file", "as", "up", "a", "Out", "string"], "copySize": ["CopyTime", " copyTime", "saveLength", "leSize", "byteTime", " copySIZE", "saveSize", "savesize", "lesize", "copyAddress", "CopySize", "openSIZE", "copyTime", "leLength", "copySIZE", "leSIZE", "Copysize", " copysize", "bytesize", "copysize", "byteAddress", " copyLength", "openLength", "copyLength", "saveAddress", "CopyLength", "byteLength", "opensize", " copyAddress", "openSize", "byteSize"], "contentUriString": ["contentUioStr", "contentIiByte", "contentUiniByte", "contentUridStr", "contentUrisString", "contentUioInt", "contentUpiInt", "contentUriUnit", "contentUpiStr", "contentUriByte", "contentUiNumber", "contentUriStr", "contentIrisInt", "contentUrisstring", "contentUiByte", "contentIrisStr", "contentUiostring", "contentUpiString", "contentIriStr", "contentIrisUnit", "contentUuriByte", "contentIriInt", "contentIiStr", "contentUridString", "contentUuriString", "contentUrisUnit", "contentUiString", "contentIrisString", "contentIriByte", "contentUuriNumber", "contentIiNumber", "contentIiString", "contentIristring", "contentUioString", "contentUiStr", "contentIrisstring", "contentUiniNumber", "contentUridUnit", "contentUiniStr", "contentUriInt", "contentUriNumber", "contentUuriStr", "contentUrisStr", "contentUiUnit", "contentUpistring", "contentUrisInt", "contentIriNumber", "contentUiniString", "contentIriString", "contentUristring", "contentIriUnit"], "mSize": ["pLength", "iLength", "cCount", "cSize", "mCount", "mLength", "pSize", "cLength", "mName", "pName", "iCount", "iSize", "iName", "cName", "pCount"], "mContentUri": ["mContentIci", "mResourceUric", "mContentUrci", "mResourceIris", "mContentUci", "mResourceUri", "mContentUric", "mContentOUri", "mContentUrris", "mContentIric", "mResourceUci", "mContentUris", "mContentIris", "mContentOUris", "mResourceUris", "mResourceIri", "mResourceIci", "mResourceIric", "mContentOUci", "mContentUrri", "mContentIri", "mContentOUric", "mContentUrric"], "cv": ["nv", "GV", "cb", "keep", "loc", "cd", "nc", "CV", "av", "vp", "sc", "iv", "ca", "cap", "vr", "enc", "vv", "rc", "cs", "lc", "iq", "auc", "csv", "content", "sv", "cr", "vm", "um", "bc", "cc", "ctx", "vc", "uc", "cf", "xc", "v", "vs", "conv", "core", "cu", "uv", "c", "lv", "VC", "co", "ov", "coll", "cm", "cover", "mc", "fp", "que", "ctrl", "cp", "fc", "pb", "buf"], "uri": ["URI", " url", "data", "point", "ri", "gb", "iri", "iv", "range", "pi", "universal", "base", "oid", "format", " ur", "href", "qi", "query", "address", "proxy", "i", "cli", "ci", "storage", "api", "path", "environment", "url", " scheme", "ui", "mi", "attribute", " Uri", "route", "metadata", "http", "id", "prefix", "resource", "uid", "location", "uni", "string", " URI", "username"]}}
{"id1": "822452", "id2": "1357662", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrap", "readandRewrites", "readAndRewwrite", "readandrewrites", "readandRewrap", "readAndSwwrite", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readAndRebrites", "readAndRewrites", "readAndrewrites", "readandrewrite", "readandRewwrite", "readandrewrap", "readAndRebrite", "readAndSwrites", "readAndSwrite", "readAndRebrap", "readAndrewrap", "readandrewwrite", "readAndRewrap", "readandRewrite"], "inFile": ["inputFile", "outFiles", "oldFile", "loginfile", "oldFilename", "infile", "inputfile", "outfile", "loginFile", " inSourceFile", "loginFiles", "inSourceFile", "outSourceFile", "loginFilename", "inFiles", "InFiles", " infile", "InSourceFile", "oldfile", "oldFiles", "inputFiles", "outFilename", " inFilename", "inFilename", "InFile", "Infile", " inFiles", "inputFilename"], "outFile": ["processFILE", "newFile", "newStream", "Outfile", " outStream", "thisFILE", "outDir", "thisfile", "outfile", " outDir", "outStream", "outputFile", "processFile", "processPlace", "offFile", "processFilename", "outputPlace", "offFilename", " outfile", "OutStream", "newDir", "outputFILE", "outputFilename", "thisFile", "outPlace", "exFILE", "exFilename", "newfile", "exFile", "outFilename", "outputfile", "offPlace", "OutDir", "outFILE", "thisFilename", "exfile", "OutFile", "offFILE"], "iis": ["iais", "Iais", " iIs", "iiss", "Iis", "IIS", " iiss", "iiIs", "iniis", "iniiss", " iris", "iniIs", "ciris", "iniIS", "iiis", "ciIs", "iiris", "iniris", "Iiss", "iiiss", " iIS", "ciIS", "iiIS", "iIS", "iris", "ciis", "iIs", "ciiss", "ciais", " iais"], "dcmParser": ["dcrParser", " dpmPar", "dmParser", "dcmJar", "dcrPar", "DcmInstallation", "dmissionReader", "dpmPlugin", "dmissionParser", " dpmReader", "dkmParser", "dcrLoader", "dhemInstallation", " dcrReader", " dcmReader", "dmcJar", "dmissionPlugin", "dcmPar", "dpmInstallation", "dcmHandler", "dpmHandler", " dpmparser", "dmLoader", "dpmPolicy", "dpmParser", "dcmPlugin", "dmmParser", " dcmLoader", " dpmJar", "dcmLanguage", "DcmJar", "dcrPlugin", " dpmarser", " dcmparser", "dmcPar", " dcmPar", "dmcParser", " dcrPlugin", "dkmPolicy", "dpmPar", "dCMLoader", "dpmLoader", "dbmPlugin", "dCMParser", " dpmHelper", "fcmReader", "dbmParser", "dCMHandler", "fpmReader", "dcrReader", "dkmPlugin", " dcmPolicy", "fpmHandler", "fcmparser", "dpmarser", "dmmparser", " dcmarser", "dbmPolicy", "dpmLanguage", "dcrJar", "dmoduleJar", "dmoduleparser", " dpmParser", "fcmHandler", "dmcarser", "dpmReader", "dcmPolicy", "dcmLoader", "dcmHelper", " dcmJar", " dcmPlugin", " dpmPlugin", "dpmparser", "dmoduleReader", "dmPlugin", " dcmHelper", "dhemJar", "dcmarser", "fpmparser", "dbmHelper", " dpmLoader", " dpmLanguage", "dmReader", " dcrLoader", "dcmparser", " dpmPolicy", "dmissionLanguage", "dhemParser", "dmmLoader", "dmodulePlugin", "dcrarser", "fpmParser", "dCMReader", "dCMPlugin", "fcmParser", "dCMparser", " dcmLanguage", "dcmInstallation", "dmoduleParser", " dcrParser", "DcmReader", "dhemReader", "dpmHelper", "dpmJar", "dmmPlugin", "dcmReader", "DcmParser", "dkmHelper"], "ds": ["cdn", "df", "ts", "asi", "data", "iss", "vals", "eps", "s", "icks", "bs", "dd", "ins", "services", "sync", "session", "ns", "da", "Ds", "utils", "os", "sys", "cs", "ld", "ls", "ys", "di", "conn", "parts", "is", "rs", "drivers", "dds", "Db", "dr", "dc", "d", "ras", "nas", "gd", "db", "points", "qs", "js", "ws", "tes", "DS", "Os", "xs", "uds", "vs", "gs", "ays", "ps", "details", "ils", "ants", "des", "src", "amps", "ros", "dat", "ss", "pd", "ads", "tx", "ks", "dt"], "pdReader": ["hdLoader", "pdRunner", "pbReader", "hdStream", "ddRunner", "dsreader", "dsReader", "ddLoader", "pdLoader", "pdStream", "pcLoader", "xdReader", "pcReader", "dsRead", "pbRunner", "pdreader", "pcWriter", "ddStream", "ddReader", "hdreader", "xdreader", "dsLoader", "xdWriter", "pdRead", "pbLoader", "pcRead", "hdWriter", "hdRead", "xdRead", "pbStream", "hdRunner", "hdReader", "dsWriter"], "out": ["lock", "ext", "login", "data", "doc", "name", "at", "down", "outs", "ssl", "w", "err", "flow", "o", "dot", "cli", "oder", "exec", "url", "default", "null", "io", "as", "co", "exp", "over", "point", "later", "session", "auto", "to", "sys", "page", "cache", "conn", "inner", "output", "term", "her", "key", "client", "builder", "outer", "parent", "order", "group", "code", "up", "word", "result", "director", "copy", "model", "with", "part", "line", "writer", "temp", "external", "lib", "image", "inc", "store", "Out", "obj", "device", "full", "connection", "manager", "s", "dev", "array", "sync", "layer", "ex", "gen", "base", "user", "again", "img", "password", "OUT", "list", "db", "child", " in", "object", "pass", "net", "in", "file", "diff", "write"], "dcmEncParam": ["dcmEstPar", "dcmDecPart", "dcmEncParameter", "dcmEncPart", "dcmElType", "dcmEnParameter", "dcmArchParameter", "dcmEnPar", "dcmDecArg", "dcmEnType", "dcmEstParameter", "dcmEstParam", "dcmArchArg", "dcmSecPart", "dcmDecParameter", "dcmEnPart", "dcmDecType", "dcmDecParam", "dcmEncPar", "dcmSecPar", "dcmSecParam", "dcmEncArg", "dcmEncType", "dcmElPar", "dcmEstType", "dcmElParameter", "dcmDecPar", "dcmEnArg", "dcmSecType", "dcmEnParam", "dcmArchParam", "dcmElParam"], "pdWriter": ["dsWrite", "PDWriting", "dpWriter", "pdWriting", "dsReader", "hdWrite", "dpWrite", "htWriting", "PDReader", "ddWrite", "dsOutput", "hdOutput", "PDWrite", "ddReader", "dpReader", "htReader", "pdOutput", "ddWriter", "pdWrite", "htWrite", "ddOutput", "PDWriter", "htWriter", "hdWriter", "hdReader", "dsWriter", "dpWriting"]}}
{"id1": "15580610", "id2": "19810820", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"trainClassifier": [" trainclassification", " trainClassify", " trainclassLoader", "trainClassLoader", "trainTestLoader", "trainTestification", "trainclassLoader", "trainModelifier", "trainClassify", "trainclassification", "trainModelify", "trainclassify", " trainclassifier", "trainClassification", "trainModelification", "trainTestify", "trainModelLoader", " trainclassify", " trainClassLoader", "trainTestifier", "trainclassifier", " trainClassification"], "dir": ["data", "loc", "name", "doc", "cd", "wd", "database", "div", "base", "class", "direction", "model", " directory", "di", "files", "output", "domain", "Dir", "root", "dist", "env", "md", "d", "lib", "build", "db", "project", "path", "filename", "object", "url", "config", "group", "uri", "du", "file", "folder", "module", "DIR", "fd", "target", "out", "window", "home", "directory", "report"], "command": ["connection", "volume", "sequence", "name", "force", "machine", "error", "reason", "archive", "database", "language", "string", "operation", "array", "usage", "info", "one", "move", "event", "power", "sudo", "control", "component", "model", "domain", "cmd", "query", "root", "and", "shell", "password", "this", "service", "which", "cli", "comment", "image", "clear", "child", "request", "exec", "path", "pattern", "project", "system", "attribute", "media", "delete", "history", "argument", "document", "config", "category", "menu", "file", "Command", "function", "module", "word", "message", "action", "script", "input", "help", "directory", "slave", "program", "three"], "length": ["full", "zip", "sequence", "loc", "strength", "depth", "type", "slice", "range", "how", "Length", "body", "creator", "head", "span", "power", "letter", "class", "match", "position", "ength", "part", "time", "size", "inner", "ph", "section", "th", "left", "max", "distance", "capacity", "shape", "before", "dim", "angle", "l", "count", "padding", "style", "limit", "square", "or", "value", "character", "form", "prime", "sum", "width", "number", "level", "duration", "both", "id", "word", "len", "last", "join", "end", "now"], "process": ["connection", "app", "handle", "machine", "master", "cess", "session", "thread", "method", "task", "processing", "worker", "python", "p", "sync", "application", "proc", "class", "status", "component", "user", "share", "output", "cmd", "display", "plus", "console", "this", "call", "service", "parse", "run", "child", "path", "exec", "project", "parent", "pid", "system", "document", "group", "post", "processor", "file", "function", "script", "result", "out", "host", "Process", "program", "use"]}}
{"id1": "7761195", "id2": "3536332", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"encrypt": ["ecryption", "ecrypt", " encipher", "Encrypt", " encress", "encipher", "encryption", "encress", "Encryption", "ecress", "ecipher", " encryption", "Encipher", "Encress"], "plaintext": ["protectedText", "foresource", " plainsource", " plainletter", "preText", "batletter", "foreletter", "pretext", "plainletter", "foreText", "foretext", "predata", "batText", "prestruct", " plainstruct", "protectedtext", "protectedstruct", "plainsource", " plainText", "plaindata", "battext", "plainText", "batsource", "protecteddata", "plainstruct", " plaindata"], "sb": ["SB", " SB", "BB", "bm", "cb", "sg", "sam", "kB", "si", "gb", "bs", "bh", "bb", "mb", "erb", "sv", "bp", "rb", "sq", "abb", "db", "bg", "pb", "bf", "sf", "gc", "BG", "ss", "nb"], "md": ["meta", "df", "bd", "vd", "cb", "mag", "mg", "cd", "rm", "wd", "mad", "dd", "m", "ma", " MD", "mt", "dig", "ld", "mb", "M", "mac", "cmd", "hm", "dm", "dr", "sm", "dc", "d", "MD", "gd", "mo", "mod", "amd", "mp", "metadata", "mm", "pm", "dh", "mu", "sha", "cm", "mc", "ms", "od", "mand", "hd", "ad", "pd", "nm", "Cmd", "de"], "raw": ["full", "missing", "data", "ack", "array", "stream", "dec", "clean", "RAW", "enc", "load", "shared", "hex", "rc", "words", "Raw", "instance", "text", "bytes", "output", "row", "buffer", "block", "pack", "image", "feed", "response", "serial", "empty", "null", "ng", "original", "wave", "unsigned", "valid", "message", "input", "initial", "unknown", "json", "buf"], "hash": ["rh", "alt", "data", "ha", "version", "array", "hex", "base", "log", "dig", "cache", "text", "num", "mac", "her", "kh", "key", "secret", "abi", "buffer", "block", "image", "pack", "h", "url", "sum", "code", "ashes", "id", "message", "flash", "sha", "header", "ash", "ref", "Hash", "html", "sh"]}}
{"id1": "14168494", "id2": "13595251", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferClass", " copiedClass", "copyFiles", " copyfile", " copiedfile", "transferFile", "transferfile", " copyFiles", " copiedFile", "transferFiles", "copyClass", " copyClass", "copyfile", " copiedFiles"], "dest": ["data", "loc", "name", "sup", "true", "later", " destination", "st", "destroy", "comb", "class", "orig", "output", "txt", "done", "dist", "temp", "this", "d", "source", "path", " Dest", "transfer", "null", "file", "wb", "Dest", "resource", "target", "out", "dir", "desc", "obj", "tmp"], "src": ["bin", "sl", "sin", "cb", "loc", "sup", "master", "gb", "ds", "s", "sc", "slice", "stream", "st", "sync", "inst", "download", "rc", "ssl", "copy", "rob", "img", "dist", "rb", "sq", "source", "sub", "storage", "filename", "url", "config", "sit", "file", "split", "Dest", "upload", "sel", "sb", "target", "tmp"], "srcChannel": ["sourceChan", "rcConnection", " srcStream", " srcButton", "rcCh", "destConnection", "srcSection", " srcchannel", "rcButton", "distStream", "distChannel", "destChan", "sourceButton", "sourceChannel", "distChan", "rcChan", " srcConnection", "rcSection", "srcCh", "srcChan", "rcStream", "inputConnection", " srcCh", "srcStream", "rcchannel", "srcButton", "sourcechannel", "destChannel", "srcchannel", "inputChannel", "rcChannel", "inputchannel", "destchannel", " srcSection", "distCh", "inputSection", "srcConnection", " srcChan"], "dstChannel": [" dstchannel", "Dstchannel", "drcchannel", "drcContext", "dstsConnection", " dstChan", " drdContext", "dstConnection", "drcChannel", "dstchannel", "dDestChannel", " drdchannel", "ddestConnection", "dsrcVideo", "drdchannel", "dstVideo", "dDestchannel", "drcChan", " dstsStream", " drdChan", "drdChannel", "DstChannel", "ddestChannel", "dstsStream", "Ddestchannel", " dstschannel", "dstContext", "dDestConnection", "ddestContext", "ddestChan", " dstStream", "ddestchannel", " dstConnection", "DstVideo", "DdestChannel", "dstChan", " dstsChannel", "DdestVideo", " drdChannel", "dDestStream", "ddestStream", "dsrcChannel", "drdContext", "dstschannel", "dstsChannel", "dsrcchannel", " dstContext", "ddestVideo", " dstsConnection", "drdChan", "dstStream", "drcVideo"]}}
{"id1": "6988216", "id2": "23452437", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"testSimpleQuery": [" runRawConnect", "runSimpleQuery", " runBasicSearch", "runSimpleConnect", " runBasicQuery", " runClientSearch", " runSimpleQuery", " runSimpleFilter", "runRawConnect", " runSimpleConnect", "runRawQuery", "runRawFilter", " runRawSearch", " runClientConnect", " runBasicConnect", " runClientFilter", " runSimpleSearch", " runBasicFilter", " runClientQuery", "runRawSearch", "runSimpleSearch", " runRawFilter", " runRawQuery", "runSimpleFilter"], "dummySource": ["duddyOrigin", "pummyContent", "puddyClient", "pummyClient", "puddyType", "duddyService", "dandySource", "duddyType", "pummyType", "daddyService", "dellyContent", " dumbOrigin", " dumbSource", "dumbConfig", "daddyType", "puddySource", "dummyConfig", "dandySite", "dummySourceFile", "dundleContent", "daddyContent", "duddySource", "daddySource", " dumbContent", "dellyService", "puddySourceFile", "dumbSource", "dummyClient", "dandySourceFile", "duddyClient", "dumbContent", " dummyConfig", "duddySourceFile", "duddySite", "dummyType", " dumbConfig", "pummySource", "dundleOrigin", "dummyOrigin", "daddySite", "dummySite", "dellyType", "dundleConfig", "pummyService", "puddyContent", "puddyService", "dumbOrigin", "duddyContent", " dummyOrigin", "pummySourceFile", "dandyClient", "duddyConfig", "puddySite", "dummyService", "daddyClient", "daddySourceFile", "pummySite", "dundleSource", "dellySource"], "os": ["oS", "ens", "oa", "cos", "ds", "oss", "oos", "bs", "uns", "s", "bos", "ori", "ns", "ol", "sys", "is", "ls", "om", "conn", "css", "obs", "ok", "op", "ops", "oses", "o", "ox", "i", "ks", "OS", "or", "mos", "Os", "object", "vs", "ose", "oc", "osi", "io", "ps", "as", "iso", "pos", "aos", "acs", "ros", "ss", "ou", "los", "ios", "us", "out", "es", "ms", "ols", "nos", "fs", "ows", "dos"], "dummyContent": [" dellyContents", "DummyBody", "dumperBody", "dumpingOutput", " dummyContents", "dellycontent", "DuckyReader", "DummyReader", "dummyOutput", "dumpingcontent", "dummycontent", "dellyContents", "DummySource", "duckyReader", "dummyReader", "DuckyBody", "dellyContent", "dumperSource", " dummycontent", "DuckyContent", "dumpingContent", " dellycontent", "duckyContent", " dellyContent", "DuckySource", "dumperReader", "duddySource", " dellyOutput", " dummyOutput", "dummyBody", "dumperContents", "duckyBody", "dummyContents", "dumpercontent", "duckySource", "DummyContent", "duddyContent", "dellyOutput", "duddyBody", "duddyReader", "dumpingContents", "dumperOutput", "dumperContent"], "source": ["reader", "connection", "sl", "sin", " Source", "ources", " sources", "cos", "channel", "sn", "s", "sc", "seed", "secure", "stream", "sync", "info", "class", "ource", "cache", "text", "size", "e", "SOURCE", "client", "service", "proxy", "i", "storage", "parent", "object", "url", "config", "uri", "unit", "core", "ser", "scope", "search", "src", "resource", "result", "target", "Source", "host", "resources", "slave", "string", "use", "element", "node", "site"], "content": ["data", "current", "version", "cos", "body", "cont", "cms", "clean", "load", "xml", "activity", "expression", "match", "music", "description", "model", "css", "text", "output", "size", "news", "address", "Content", "comment", "service", "image", "child", "value", "feed", "response", "url", "update", "config", "document", "code", "sol", "comments", "server", "transform", "title", "message", "resource", "target", "cover", "host", "header", "result", "report", "input", "html", "media", "children"], "qResult": ["queryRes", "iqResult", "kReturn", "qResults", "kSource", "queryResult", "kRes", "qFilter", "rSource", "queryResponse", "qSource", "rRes", "iqResults", "queryFilter", "qRes", "QResult", "queryResults", "qresult", " qresult", "kresult", "QFilter", "kResults", "iqresult", " qResponse", "rResult", "QReturn", "iqResponse", "QResults", "qResponse", "queryresult", "kFilter", "kResult", "rresult", "querySource", "queryReturn", "qReturn", " qResults"], "results": ["ids", "pages", "values", "data", "blocks", "rows", "s", "versions", "ins", "groups", "ries", "events", "vers", "RESULTS", "items", "models", "successful", "members", "files", "features", "collection", "runs", "its", "lines", "shows", "Results", "qs", "response", "objects", "errors", "details", "ions", "users", "result", "res", "tests", "reports", "resources", "docs", "children"], "it": [" It", "iter", "si", "IT", "edit", "ited", "slice", "ins", "itted", "p", "info", "ITS", "not", "mit", "pit", "It", "op", "ite", "l", "r", "and", "its", "rit", "list", "i", "entry", "ci", "which", "init", "ort", "t", "or", "v", "ait", "sit", "in", "split", "iti", "id", "the", "ic", "stat", "lit", "ati", "you", "ip"], "rSrc": [" rSsrc", " rEsource", "rDssrc", "rSource", "RIsrec", " rEsRC", "rSrec", "RSrec", "rAsource", "rDsRC", "rPsource", "rDsource", "RSrc", "RSource", "rEssrc", "rDsrc", "rPssrc", "rEsrc", "RIsrc", "rAssrc", "RIsource", "rAsrec", "rIsRC", "rIsrc", "rIsrec", "RSRC", " rSRC", "rIsource", "rSRC", "rPsRC", " rEsrc", "rEsRC", "rAsRC", "rSsrc", " rDsource", "rEsource", " rDssrc", " rDsRC", " rDsrc", "rPsrc", "RIsRC", " rEssrc", " rSource", "rAsrc"], "rSrcIn": ["rCRCOut", "rSourceOut", "rAsRCOut", "rSvcin", "rCsrcIn", "rSrcIN", "rSvcOut", "rSsrcin", "rSourceIn", "rSrcOut", "rAsRCIn", "rAsRCin", "rCsrcOut", "rCsrcIN", "rSRCIN", "rSRCin", "rSourceIns", "rSrcin", "rSvcIn", "rCrcin", "rSsrcIn", "rSvcIns", "rSrcIns", "rSsrcIN", "rCrcOut", "rCrcIns", "rSRCIn", "rSsrcOut", "rSRCIns", "rCRCIns", "rAsrcin", "rCrcIn", "rSourcein", "rAsrcOut", "rCrcIN", "rCRCIn", "rCsrcin", "rSRCOut", "rSvcIN", "rAsrcIn"], "actualOut": ["realOut", "eventIn", "publicOut", "assertOUT", "actualIn", " actualout", "nexpectedWin", "realWin", "operatorOUT", "eventout", "eventOUT", " ActualOUT", "assertOut", " ActualOut", "operatorIn", "operatorOut", "actualOutput", "publicIn", "realout", "illegalOUT", "actualWin", " ActualIn", "nexpectedout", "publicOutput", " actualOutput", "nexpectedIn", "assertIn", "illegalOut", "actualout", " ActualBridge", "assertBridge", " actualOUT", "operatorout", "nexpectedOut", "actualOUT", "realIn", " actualIn", "illegalIn", "publicOUT", "actualBridge", " actualWin", "eventOut", "illegalOutput", " actualBridge"]}}
{"id1": "20623709", "id2": "19134229", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"split": ["open", "archive", "sync", "sort", "set", "match", "add", "copy", "format", "part", "share", "cmp", "parse", "build", "init", "run", "process", "exec", "Split", "delete", "update", "transfer", "diff", "join", "append", "execute", "start"], "targetDirectory": ["targetRoot", "targetFile", " targetRoot", " targetFolder", "destDir", "masterDir", "baseFile", "outputFile", "currentRoot", " targetFile", "targetDatabase", "masterDatabase", "TargetDir", "targetDir", "outputDir", "currentFolder", " targetPath", "basePath", "baseDatabase", "currentPath", "masterDirectory", "TargetDirectory", "TargetDatabase", "baseFolder", "TargetRoot", "baseDir", "TargetFolder", "targetPath", "destFile", " targetDir", "TargetPath", "destFolder", "masterPath", "TargetFile", "baseDirectory", "currentDir", "outputFolder", "currentDirectory", "outputDirectory", "destDirectory", "targetFolder"], "prefix": ["offset", "FIX", "sequence", "fixed", "name", "type", "first", " suffix", "timeout", "base", "ix", "prot", "format", "resolution", "cache", "Pref", "domain", "txt", "pre", "root", "patch", "temp", "padding", "template", "path", "filename", "pattern", "config", "number", "uri", "unit", "folder", "fix", "index", "resource", "queue", "append", "fp", "directory", "string", "username"], "maxUnitBases": ["maxUnitAliases", "maxUnitEaches", "maxunitBails", "maxunitBaches", "maxUnitChasing", "maxUnitChase", "maxUnitQueasing", "maxUnitAliails", "maxunitAliasing", "maxunitAliues", "maxUnitAliase", "maxunitAliaches", "maxunitAliase", "maxUnitQueues", "maxUnitEails", "maxUnitPlases", "maxUnitEase", "maxunitBues", "maxUnitQueases", "maxUnitPlaches", "maxUnitPlails", "maxUnitQuease", "maxUnitChases", "maxUnitBaches", "maxUnitAliaches", "maxUnitPlase", "maxUnitEases", "maxunitAliails", "maxUnitChues", "maxUnitBues", "maxUnitAliues", "maxUnitBasing", "maxunitBases", "maxunitBase", "maxunitBasing", "maxUnitBails", "maxunitAliases", "maxUnitBase", "maxUnitAliasing"], "maxUnitEntries": ["maxUnitIntrys", "maxUnitOrdries", "maxUnitEntryies", "maxUnitOrdry", "maxUnitAddry", "maxUnitCountrations", "maxUnitOrdies", "maxUnitEntryresses", "maxUnitEntines", "maxUnitCountry", "maxUnitEntrys", "maxunitEntryrys", "maxLineEntries", "maxLineOrdrations", "maxUnitEntures", "maxunitEntries", "maxunitEnties", "maxUnitEntry", "maxUnitAddresses", "maxLineOrdry", "maxUnitIntries", "maxUnitIntresses", "maxUnitAddries", "maxUnitEnties", "maxunitEntryies", "maxUnitEntrations", "maxUnitEntresses", "maxUnitEntryures", "maxUnitErry", "maxLineEntrations", "maxUnitOrdresses", "maxunitEntryresses", "maxLineOrdines", "maxUnitCountines", "maxUnitEntryrys", "maxunitEntrys", "maxUnitCountries", "maxUnitOrdrys", "maxUnitAddures", "maxLineOrdries", "maxUnitOrdrations", "maxUnitErries", "maxLineEntry", "maxUnitInties", "maxLineEntines", "maxUnitOrdines", "maxUnitEntryries", "maxUnitErines", "maxUnitEntryry", "maxUnitErrations", "maxunitEntryries", "maxunitEntresses"], "fis": [" fai", "fiss", "forisc", " fris", "fisa", " fisa", "foriss", "fai", "forris", "forai", "forIs", "fIs", "vis", " fIs", "Fis", "vIs", "forisa", " fisc", "vai", "Fiss", "visa", " fiss", "foris", "fris", "Fris", "Fisc", "fisc"], "fci": ["Fco", "Fci", "efci", "bai", " fai", "fii", "vci", "hco", "Foci", "fai", "bci", "foci", "hai", " fii", "Fis", "efai", "hci", "Fai", "vai", "fcos", "dci", "bis", "dii", "hcos", "efco", "efcos", "bco", "Fii", "vcos", "vco", "dco", "doci", " foci"], "fos": ["fscos", "ifios", " fcos", "ifo", "fsos", "fsios", "fso", "ifos", "Foes", "foes", "infoss", "toes", "Fis", "infoes", "infos", "fcos", "Foss", "foss", "tis", "tos", "toss", "fios", "Fos", " fo", " fios", "fo", "infis", "ifcos"], "fco": ["Fco", "Fci", "dcos", "hco", "fbo", " fcos", "hgo", "fgo", "fileico", " fico", "lci", "lro", "fileci", "lcos", "fro", "hci", " fbo", "Fico", "fcos", "dci", "fico", "hcos", "lgo", "dro", "Fbo", "filebo", "dco", "fileco", "lco", " fgo", " fro"], "buffer": ["offset", "bin", "border", "reader", "uffer", "iter", "data", "texture", "scale", "channel", "batch", "reference", "layer", "buff", "info", "Buffer", "timeout", "zero", "counter", "binary", "base", "expression", "position", "copy", "cache", "loader", "size", "callback", "writer", "capacity", "translation", "flush", "bar", "entry", "block", "comment", "image", "feed", "source", "request", "response", "context", "transfer", "document", "server", "pause", "view", "null", "rate", "read", "memory", "message", "queue", "resource", "header", "result", "pad", "length", "window", "input", "bc", "device", "buf"], "currentBasesCount": ["currentBatchesNum", "currentChasesCounter", "currentChaseNum", "currentBasesNum", "currentChaseCounter", "currentBaseCounter", "currentChaseCount", "currentChasecount", "currentBasescount", "currentChasesCount", "currentBatchescount", "currentBasingCount", "currentBasingcount", "currentBaseNum", "currentBaseCount", "currentBasingCounter", "currentBatchesCount", "currentBatchesCounter", "currentBasingNum", "currentChasesNum", "currentBasecount", "currentBasesCounter", "currentChasescount"], "currentEntriesCount": ["currentEntursSize", "currentAddriesCount", "currentEntursCount", "currentEntriesSize", "currentAdduresSize", "currentAdduresLimit", "currentEntrasCount", "currentAdduresOffset", "currentAdduresCount", "currentEnturesCount", "currentAddriesSize", "currentEntriesOffset", "currentEntrasSize", "currentEnturesLimit", "currentEntrasLimit", "currentEntursLimit", "currentEntrasOffset", "currentAddriesOffset", "currentEnturesSize", "currentEntriesLimit", "currentAddriesLimit", "currentEntursOffset", "currentEnturesOffset"], "targetCount": ["TargetSum", "argetSize", "patterncount", "patternSize", "argetcount", "TargetSize", "targetcount", "targetSize", "argetSum", "patternCount", "argetCount", "TargetCount", "targetSum", "patternSum", "Targetcount"], "fastaChannel": ["fastasColumn", "fastanContainer", "fastaqColumn", "fastaqConnection", "fastaContext", " fastABuffer", " fastaContainer", " fastaConnection", "fastAConnection", " fastaContext", "fastaqChannel", "fastAContext", "fastasContext", "fastasConnection", "fastaContainer", "fastABuffer", "fastanBuffer", " fastAColumn", "fastasBuffer", " fastAContainer", "fastanContext", "fastAContainer", "fastaqBuffer", " fastAChannel", " fastAContext", "fastAColumn", "fastaConnection", "fastaColumn", "fastAChannel", "fastanChannel", "fastasContainer", " fastAConnection", " fastaColumn", "fastasChannel"], "totalSeqCount": ["totalSeqCounter", "totalQueqcount", "totalSeQCount", "totalQueQcount", "totalSeqcount", "totalSeqsCounter", "totalSeQcount", "totalSeqsCount", "totalSeuxcount", "totalQueQCount", "totalSeqscount", "totalSeuxCount", "totalSeqNum", "totalQueQNum", "totalSeQCounter", "totalSeuxNum", "totalSeuxCounter", "totalQueqCount", "totalQueqNum", "totalQueqCounter", "totalSeQNum", "totalQueQCounter", "totalSeqsNum"], "totalResiduesCount": ["totalResiduingSize", "totalResiduationcount", "totalResiduesNum", "totalResiduingNum", "totalResiduresSize", "totalResiduresCount", "totalResiduationSize", "totalResiduingcount", "totalResiduingCount", "totalResqueurescount", "totalResqueuresCount", "totalResqueuesCount", "totalResqueuescount", "totalResiduescount", "totalResiduationCount", "totalResqueuesSize", "totalResiduesSize", "totalResiduationNum", "totalResidurescount", "totalResiduresNum", "totalResqueuresNum", "totalResqueuesNum", "totalResqueuresSize"], "prevTime": ["PrevFile", " prevFile", "prevFile", " prevValue", " prevSize", "PrevValue", "commitTime", "PrevSize", "PrevTime", "prevSize", "commitFile", "commitSize", "commitValue", "prevValue"], "fastaFileSize": ["fastasFileName", "fastAFileCount", "fastaPageName", "fastaLineLength", "fastaPageAddress", "fastaFilesSize", "fastaBufferCount", "fastaFilesAddress", "fastABufferSize", "fastAFileAddress", "fastaHeaderAddress", "fastABufferCount", "fastaLineCount", "fastaBlockLength", "fastasFileSize", "fastaPageSize", "fastasHeaderSize", "fastasFileAddress", "fastaHeaderSize", "fastABufferAddress", "fastaFileAddress", "fastaFileName", "fastaFileCount", "fastasHeaderLength", "fastaBlockSize", "fastaFilesLength", "fastaFileLength", "fastaHeaderName", "fastaBlockAddress", "fastaBufferAddress", "fastaPageLength", "fastABufferLength", "fastaBufferSize", "fastaLineAddress", "fastasFileLength", "fastaHeaderLength", "fastasHeaderAddress", "fastaLineSize", "fastAFileSize", "fastaBlockCount", "fastAFileLength", "fastaFilesName", "fastasHeaderName", "fastaBufferLength"], "fastaFileReadOffset": ["fastaFileWriteOff", "fastaFileWriteoffset", "fastaBufferReadAmount", "fastaDirectoryWriteOff", "fastaFileLoadLength", "fastaFileRunoffset", "fastaFilesReadoffset", "fastaFilereadOff", "fastaFilesWriteOffset", "fastaFilereadoffset", "fastaBufferWriteOffset", "fastaFilereadOffset", "fastaBufferWriteoffset", "fastaFileStartOff", "fastaBufferReadoffset", "fastaFileLengthoffset", "fastaFileReadAmount", "fastaFileLoadOffset", "fastaDirectoryWriteOffset", "fastaFileRunEntry", "fastaDirectoryReadOff", "fastaFilesReadOff", "fastaDirectoryReadOffset", "fastaFilereadLength", "fastaFileReadoffset", "fastaFileRunOff", "fastaFileReadEntry", "fastaFilesReadOffset", "fastaFileStartoffset", "fastaFilesWriteoffset", "fastaFileReadOff", "fastaDirectoryReadEntry", "fastaFileWriteOffset", "fastaFilesWriteOff", "fastaDirectoryWriteoffset", "fastaDirectoryReadoffset", "fastaFileWriteEntry", "fastaFileRunOffset", "fastaFileLoadoffset", "fastaFileLengthOffset", "fastaDirectoryWriteEntry", "fastaBufferReadLength", "fastaFileLengthAmount", "fastaFileWriteAmount", "fastaFileStartOffset", "fastaFileStartEntry", "fastaFileReadLength", "fastaFilesWriteLength", "fastaBufferReadOffset", "fastaFileWriteLength", "fastaFileLengthOff", "fastaBufferWriteAmount", "fastaFileLoadAmount", "fastaBufferWriteLength", "fastaFilesReadLength", "fastaFileLengthLength"], "partitionStartOffset": ["partitionStopOrder", "partitionBufferOffset", "partitionStartOff", "partitionStopOffset", "partitionEndOff", "partitionsEndOffset", "partitionBufferOrder", "partitionBufferRange", "partitionEndOrder", "partitionsStartOff", "partitionsStartOrder", "partitionStartOrder", "partitionsStartRange", "partitionEndRange", "partitionsEndRange", "partitionsEndOrder", "partitionsEndOff", "partitionStopOff", "partitionBufferOff", "partitionStartRange", "partitionStopRange", "partitionsStartOffset"], "bufferSize": ["processSize", "processSIZE", "bufferCount", " bufferCount", " bufferSIZE", "BufferC", " bufferType", "processType", " bufferC", "BufferSize", "BufferCount", "queueCount", "bufferType", "bufferC", "BufferType", "queueSize", "bufferSIZE", "processC", "BufferSIZE"], "fastaBuffer": ["fastaceBuffer", "fastanContainer", " fastasContainer", "fastAFile", " fastasFile", "fastaQueue", "fastanFile", "fastacePtr", "fastaPtr", "fastasBuff", "FastasBuff", "FastasPtr", "fastaaStream", " fastABuffer", " fastaContainer", " fastAFile", "fastasFile", "FastaStream", "fastaStream", "FastasBuffer", "fastaaBuffer", "FastaChannel", " fastaFile", "fastaContainer", " fastasBuffer", "fastaFile", "fastanBuffer", " fastasChannel", "FastaBuffer", "fastanBuff", "fastaaPtr", "fastasBuffer", "FastasStream", "fastaceBuff", "fastaaBuff", "fastasQueue", "fastaBuff", "fastAContainer", " fastAChannel", "fastaceChannel", "fastanQueue", " fastaQueue", "fastAQueue", "fastasStream", " fastAQueue", "fastABuff", " fastaBuff", "FastaPtr", "FastaBuff", "fastanPtr", "fastAChannel", "fastanChannel", "fastasContainer", "fastasPtr", "fastanStream", "fastAPtr", "FastasChannel", " fastABuff", "fastABuffer", "fastasChannel"], "fastaReadState": ["fastaReadingMode", "fastaReadstate", "fastaReadType", "fastaReaderstate", "fastaFileState", "fastaReadingState", "fastaFileMode", "fastaReaderMode", "fastaFilestate", "fastaFileType", "fastasReadState", "fastaReadingstate", "fastaReaderType", "fastaReaderState", "fastaReadingType", "fastasReaderState", "fastasReaderMode", "fastasReaderstate", "fastasReadType", "fastaReadMode", "fastasReadstate", "fastasReadMode", "fastasReaderType"], "nBytes": ["oParts", "lenFrames", "NBytes", "pByte", " nByte", "oBytes", "lenBytes", "pBytes", "NByte", "pbytes", " nbytes", "obytes", "numBytes", "numbytes", "oFiles", "pParts", "nFiles", " nFrames", "numFiles", "lenFiles", "numFrames", "nbytes", "Nbytes", "nFrames", " nParts", "nParts", "NParts", "NFiles", "nByte", " nFiles", "lenbytes"]}}
{"id1": "350482", "id2": "20939940", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doversioncheck", "doBuildCheck", "doReleasecheck", " doVersionWork", "doVersionWork", " doBuildWork", "doversionTest", " doReleaseCheck", " doBuildcheck", " doBuildCheck", "doReleaseTest", " doVersioncheck", "doReleaseCheck", " doVersionTest", "doVERSIONcheck", " doReleasecheck", "doBuildWork", "doVersionTest", " doBuildTest", "doVERSIONTest", "doBuildTest", " doReleaseTest", "doBuildcheck", "doVERSIONWork", "doReleaseWork", "doVersioncheck", "doversionCheck", "doVERSIONCheck"], "view": ["full", "reader", "lock", "app", "layout", "self", "q", "edit", "widget", "session", "el", "body", "change", "div", "View", "event", "screen", "vis", "model", "page", "cache", "box", "can", "l", "e", "display", "cell", "see", "client", "this", "row", "buffer", "show", "comment", "style", "image", "block", "port", "gui", "request", "object", "v", "ui", "update", "config", "form", "server", "http", "views", "sel", "input", "window", "out", "VIEW", "accept", "html", "use", "gu"], "url": ["connection", "open", "sl", "f", "socket", "channel", "stream", "web", "base", "ssl", "log", "ll", "bb", "blog", "user", "loader", "zip", "l", "client", "address", "Url", "buffer", "URL", "source", "build", "image", "service", "lib", "hub", "path", "server", "uri", "browser", "http", "file", "resource", "input", "bel", "host", "string", "ob"], "in": ["reader", "isin", "sin", "login", "data", "socket", "s", "ins", "stream", "cin", "In", "binary", "is", "b", "inner", "rin", "win", "din", "IN", "ini", "buffer", "i", "source", "init", "inc", "nin", "bis", "n", "inn", "file", "as", "lin", "resource", "input", "out", "con", "ac", "gin"], "bin": ["reader", "border", "lock", "sin", "data", "socket", "pin", "body", "cin", "bn", "bot", "binary", "log", "kin", "bb", "bi", "inline", "part", "b", "loader", "inner", "win", "din", "IN", "ruby", "abi", "buffer", "lib", "run", "init", "spin", "browser", "inn", "oin", "file", "lin", "fin", "input", "out", "record", "con", "ln", "gin", "nb"], "line": ["job", "le", "data", "name", "lo", "el", "layer", "non", "ge", "load", "str", "definition", "letter", "log", "base", "inline", "lc", "rule", "page", "b", "text", "part", "model", "l", "e", "cell", "lines", "key", "lf", "ine", "row", "i", "source", "comment", "style", "block", "entry", "parse", "Line", "band", "object", "no", "cl", "code", "pass", "unit", "nl", "pe", "file", "split", "up", "LINE", "word", "valid", "message", "id", "lin", "link", "home", "day", "string", "ip", "end", "look", "site"], "develBuild": ["dellRelease", "deVELBuilt", "deelBuild", "deviousBuild", "deploybuild", "desvenBuilt", "DEvelBuilt", "desvenBuild", "desvenRun", "develbuild", "deelRelease", "desvelBuild", "deVELRun", "dewardbuild", "desvelRun", "desvelBuilt", "desvenBuilder", "deelRun", "develBuilder", "desvenbuild", "DEVELBuilt", "devenbuild", "devenRun", "DEVELBuilder", "DEVELBuild", "devenRelease", "deVELBuild", "deployBuilt", "desvelBuilder", "DEVELbuild", "deviousbuild", "deelBuilder", "DEvelbuild", "deVELbuild", "develRun", "deviousBuilt", "deployRun", "develRelease", "dellRun", "desvelRelease", "devenBuilder", "deployBuilder", "dewardBuild", "devenBuilt", "dellBuilder", "dellBuild", "DEvelBuild", "dewardBuilt", "deployBuild", "desvenRelease", "dewardBuilder", "develBuilt", "desvelbuild", "devenBuild", "deVELBuilder", "DEvelBuilder"], "stableBuild": ["stableVersion", "compatibleBuild", "validbuild", "latestBuild", "baseBuilder", "securebuild", "staticBuilder", " stableVersion", "prettyBuild", "baseBuild", "validBuilder", "basebuild", "prettyVersion", "baseVersion", "compatibleBuilder", "staticbuild", "latestbuild", "prettyBuilder", "prettybuild", "staticBuild", "validBuild", " stablebuild", " stableBuilder", "compatiblebuild", "stablebuild", "secureBuild", "stableBuilder", "latestBuilder", "secureBuilder"]}}
{"id1": "18693224", "id2": "19134229", "code1": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"runDynusT": ["runDennibusTF", "runDynusesTF", "runDynibusTF", "runDynicsM", "runDynibusT", "runDynicsT", "runDynicsTS", "runDennusTF", "runDynusM", "runDynusTF", "runDennibusT", "runDennusTS", "runDynusesT", "runDynusesTS", "runDennusM", "runDynusTS", "runDynibusTS", "runDynibusM", "runDennusT", "runDennibusM", "runDennibusTS", "runDynicsTF", "runDynusesM"], "cleanUp": [" cleaningDown", " cleanup", " cleaningUp", " cleanDown", "cleanDown", " cleanedDown", "cleanup", " cleaningup", " cleanedUP", "cleanUP", " cleanedUp", " cleanedup", " cleanUP", " cleaningUP"], "exeFiles": ["archiveResources", "installResources", "execFs", "execFiles", "exeFs", "exefiles", "installFile", "archiveFile", "coeFs", "xeFs", "installfiles", "execFile", "coeFiles", "xefiles", "xeFiles", "coeFile", "examplefiles", "execfiles", "exampleFiles", "exampleFile", "archiveFiles", "exeFile", "coefiles", "installFiles", "archivefiles", "exampleResources", "xeFile", "exeResources"], "modelFiles": ["modelsfiles", "modelFile", "modelSources", "sampleSources", "ModelFiles", " modelfiles", "modelParents", "sampleFiles", " modelSources", "sampleParents", "imageSources", "ModelFile", "imageParents", "Modelfiles", "imageFiles", "sampleParts", "imageParts", " modelParts", "modelfiles", "modelsFiles", " modelParents", "modelsFile", "modelParts", " modelFile"], "iterDir": ["itDir", "IterKit", "erDur", "testDir", "iterDirectory", "iterFolder", "catDir", "initdir", " iterKit", "itDur", "IterDir", "initDir", "erDirectory", "testFolder", "tmpDur", "catDirectory", "itDirectory", "tmpFolder", "testKit", " iterUrl", "Iterdir", "IterUrl", "catdir", "iterDur", "testdir", "iterUrl", "iterKit", "initFolder", "erFolder", "catFolder", "tmpDirectory", "initDirectory", "testUrl", "erDir", " iterdir", "tmpDir", "iterdir", "testDirectory", "itFolder"], "filename": ["username", "til", "sequence", "name", "undle", "john", "email", "database", "layer", "kn", "application", "download", "fil", "SourceFile", "nil", "binary", "expression", "that", "kl", "Filename", "loader", "wl", "files", "size", "dyl", "txt", "jet", "l", "fn", "ename", "subject", "which", "fax", "path", "phrase", "url", "document", "nl", "uri", "figure", "processor", "knife", "title", "prefix", "word", "module", "fd", "jl", "sheet", "utf", "queue", "FILE", "sf", "fp", "message", "named", "directory", "location", "length", "json", "string", "dll", "gender", "il", "spring"], "f": ["full", "x", "al", "self", "s", "m", "p", "inst", "format", "b", "F", "fer", "l", "fn", "e", "object", "form", "n", "c", "func", "fd", "sf", "out", "fc", "fs", "fit"]}}
{"id1": "11475527", "id2": "14650352", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    boolean checkIfUserExists(String username) throws IOException {\n        try {\n            URL url = new URL(WS_URL + \"/user/\" + URLEncoder.encode(username, \"UTF-8\") + \"/profile.xml\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.connect();\n            InputStream is = conn.getInputStream();\n            is.close();\n            return true;\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"addDataFromURL": ["addDatafromUrl", "addDataForUrl", "addTextfromURL", "addTextfromUrl", "addDatafromurl", "addDataFromUrl", "addTextFromUrl", "addDataFromurl", "addDataWithUrl", "addTextfromFile", "addTextfromurl", "addDataWithurl", "addDataFromFile", "addDataForURL", "addTextFromURL", "addTextFromurl", "addDataForFile", "addDatafromURL", "addDataForurl", "addDatafromFile", "addDataWithFile", "addDataWithURL", "addTextFromFile"], "theurl": ["thelog", " thepublic", "myUrl", "pythonurl", "youlog", "theuri", " theuri", "youURL", "myURL", " theUrl", " Theurl", "thereURL", " TheUrl", " theURL", "youurl", "thepublic", "thereurl", "youUrl", "thereuri", "theUrl", "testlog", " Thepublic", "theURL", " TheURL", "myurl", "pythonURL", " thelog", "pythonuri", "testURL", "testUrl", "mypublic", "testurl"], "line": ["reader", "connection", "le", "f", "name", "char", "el", "sync", "str", "letter", "log", "base", "model", "part", "text", "l", "cell", "lines", "key", "ine", "comment", "i", "style", "entry", "block", "source", "buffer", "row", "feed", "Line", "object", "character", "url", "no", "cl", "number", "code", "nl", "pass", "li", "unit", "pe", "file", "id", "LINE", "len", "lin", "out", "link", "string", "write"], "in": ["reader", "bin", "isin", "login", "it", "socket", "s", "ins", "pin", "m", "stream", "cin", "info", "In", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "l", "din", "IN", "r", "err", "client", "ini", "i", "source", "init", "image", "inc", "nin", "or", "arin", "url", "read", "pass", "io", "inn", "oin", "file", "fa", "a", "lin", "fin", "input", "out", "record", "serv"], "data": ["reader", "connection", "open", "iter", "er", "f", "handler", "stream", "body", "info", "da", "one", "di", "conn", "inner", "output", "r", "l", "writer", "plus", "lines", "la", "o", "this", "d", "i", "buffer", "ata", "entry", "source", "like", "next", "url", "default", "file", "up", "DATA", "result", "input", "out", "dat", "start", "end"], "e": ["be", "ep", "er", "f", "ade", "oe", "ception", "eme", "error", "edge", "ze", "se", "ge", "one", "ae", "en", "ec", "fe", "ede", "event", "ie", "me", "je", "ale", "E", "exc", "o", "err", "ke", "ne", "or", "ev", "ue", "ef", "et", "pe", "ise", "eu", "ce", "ele", "es", "ea", "de", "ace", "ee", "element"]}}
{"id1": "14758866", "id2": "18613870", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"getResourceAsStream": ["getResourcesasFile", "getResourceASStream", "getResourceasFile", "getResourceToString", "getResourceasStream", "getResourcesasSteam", "getResourcesAsFile", "getResourcesasString", "getResourceToSteam", "getResourceAsString", "getResourcesAsStream", "getResourcesAsSteam", "getResourcesasStream", "getResourceASString", "getResourceASSteam", "getResourceToFile", "getResourceASFile", "getResourceToStream", "getResourceAsSteam", "getResourceasSteam", "getResourceAsFile", "getResourcesAsString", "getResourceasString"], "name": ["full", "connection", "ame", "data", "version", "type", "remote", "info", "ip", "str", "base", "part", "cache", "time", "size", "domain", "alias", "key", "address", "source", "path", "parent", "filename", "object", "hash", "Name", "config", "uri", "names", "memory", "file", "id", "prefix", "word", "resource", "named", "location", "string", "NAME", "username"], "inputStream": [" inputstream", "inputSteam", "cachestream", "currentBody", "InputConnection", " inputBody", "currentstream", "InputChannel", "InputStream", "currentStream", " inputChannel", "cacheSteam", "pullChannel", "inputBody", "pullConnection", "inputConnection", "cacheStream", "pullStream", "pullSteam", "inputFeed", "InputFeed", " inputConnection", "Inputstream", "inputChannel", "currentSteam", "InputBody", "cacheFeed", "InputSteam", "inputstream", " inputSteam", " inputFeed"], "in": ["reader", "bin", "data", "socket", "ins", "m", "In", "rec", "log", "inner", "din", "r", "IN", "err", "buffer", "source", "image", "path", "exec", "read", "c", "src", "input", "re", "Out"], "out": ["lock", "bin", "msg", "data", "point", "error", "pool", "state", "outs", "ex", "gen", "proc", "dump", "ger", "sys", "log", "copy", "page", "part", "conn", "user", "output", "cache", "cmd", "r", "line", "writer", "pre", "err", "query", "key", "client", "flush", "OUT", "temp", "list", "buffer", "cli", "bar", "outer", "object", "group", "server", "raw", "io", "up", "file", "params", "println", "inter", "window", "debug", "ref", "Out", "obj"], "url": ["full", "connection", "https", "open", "sl", "f", "data", "loc", "org", "socket", "ur", "gl", "remote", "stream", "web", "download", "event", "base", "log", "ssl", "page", "cache", "b", "user", "l", "r", "left", "client", "address", "pull", "Url", "service", "URL", "source", "image", "feed", "api", "path", "object", "update", "config", "li", "server", "uri", "route", "browser", "http", "file", "resource", "result", "coll", "bel", "location", "rel", "string", "ob"], "remoteName": ["fullPath", "localPath", "Remotename", "remoteUrl", "fullname", "fullKey", "remotename", "RemoteUrl", "RemotePath", "localUrl", " remotePath", "RemoteKey", "remotePath", " remoteUrl", "localKey", "remoteKey", "fullName", "RemoteName", " remoteKey", " remotename"], "localName": ["remoteFile", "locString", "locName", "globalString", "locname", "localPath", "LocalKey", " localname", "localFile", "LocalPath", "locUrl", "LocalName", "remoteUrl", " localKey", "locPath", "localString", " localString", "remotename", "localUrl", "globalFile", "remotePath", " localUrl", " localFile", "localKey", "remoteKey", "globalname", "globalName", "globalKey", "globalPath", "localname", "remoteString", " localPath", "Localname"], "host": ["localhost", "loc", "hard", "database", "head", "type", "remote", "format", "conn", "domain", "address", "proxy", "hop", "service", "driver", "path", "h", "config", "arch", "server", "uri", "http", "Host", "prefix", "src", "header", "target", "dir", "home", "addr", "string", "ip", "username"], "prot": ["prop", "family", "channel", "addr", "pt", "lat", "proc", " plat", "ssl", "ht", "conn", "part", " proto", "Prot", "txt", "att", "password", "client", " protocol", "cli", "api", "col", "pattern", "config", "conv", "platform", "pass", "afi", "cert", "pos", "prefix", "ocol", "stat", "ios", "pro", "ref", "def", "rel", "serv", " protocols", "rot", "nat"], "port": ["f", "version", "point", "phone", "PORT", "type", "slice", "allow", "p", "pi", "timeout", "position", "direction", "future", "pr", "time", "size", "Port", "patch", "password", "address", "service", "hop", "proxy", "ort", "select", "value", "limit", "project", "path", "pid", "width", "number", "server", "uri", "pass", "file", "ports", "index", "priority", "target", "length", "string", "ip", "rest"], "cacheFile": ["remoteFile", "CacheDirectory", "basefile", "outputConnection", "localfile", " cacheLine", " cachefile", "cacheConnection", "proxyHandle", "localFile", "outputFile", "baseFile", "CacheDir", "achePlace", "cacheMessage", "storageFile", "cacheDirectory", " cacheDir", "cacheLine", "remoteUrl", "fakeFile", "sessionDir", " cacheFiles", "localDir", "tempDir", "acheFiles", "sessionFiles", "cacheUrl", "tempfile", "fakeUrl", "storageFiles", "localFiles", "cacheHandle", "Cachefile", "cachePlace", "storagePlace", "proxyfile", "cacheFiles", " cacheHandle", "CacheUrl", "cachefile", "proxyDir", "fakeLine", "tempHandle", "remoteLine", "outputMessage", " cachePlace", "baseMessage", "CacheFile", " cacheConnection", "remotefile", "outputfile", "acheFile", "fakefile", " cacheMessage", "sessionUrl", "cacheDir", " cacheDirectory", " cacheUrl", "CacheFiles", "proxyFile", "localDirectory", "baseConnection", "tempFile", "sessionFile"], "urlConnection": ["URLconnection", "sslFile", "URLConnection", "slCode", "urlconnection", "slChannel", "httpCode", " urlFile", "cacheConnection", "cachePool", "cacheConn", "downloadEntry", "downloadConnection", " urlconnection", "webConnect", "fileConnection", "URLResponse", " urlChannel", " urlConnect", "urlPool", "slConnection", "cacheConnect", "fileConn", "urlEntry", "sslConnection", "urlPart", "filePart", "fileConnect", "downloadconnection", "slCommand", "sslResponse", "httpChannel", " urlCommand", "httpPool", "httpCon", "urlCon", "urlResponse", "urlConnect", "sslConn", "httpConnect", "downloadFile", " urlCode", "URLConn", "sslConnect", "urlCommand", " urlPool", "urlChannel", "httpconnection", "URLCon", "sslEntry", "urlCode", "sslconnection", "urlConn", " urlConn", "URLConnect", "httpResponse", " urlPart", "webconnection", " urlEntry", "URLPart", "webConnection", "httpCommand", "httpConn", "webCon", "urlFile", "httpConnection"], "httpURLConnection": ["httpCLConnector", "httpCLConnection", "httpREConnection", "httpSLCode", "upperRTransaction", "httpURLCode", "httpRNode", "upperRNode", " httpLLConstruction", "httpSLConnection", "httpRLConnector", "httpHTTPFunction", "httpREStatement", "httpHTTPQuery", "httpURQuery", "httpCLConnect", "httpSLconnection", "httpurlConnection", "httpRLClient", "httpURLConn", "httpMconnection", "upperURLNode", "httpWSNode", "httpLLconnection", "httpURNode", "httpBLQuery", "httpLLConnection", " httpUrlFunction", "httpUrlconnection", "httpDOMconnection", " httpUrlConnection", "httpMLFunction", "cacheURLClient", "httpUrlConnection", " httpHTTPConnection", " httpURLconnection", "httpRLConnection", "urlUrlClient", "httpBLFunction", "httpDateconnection", "httpURFunction", " httpLLConn", "cacheURLConnection", "httpBLOperation", "upperURLConnection", "httpREConstruction", "httpurlconnection", "httpurlStatement", "urlUrlStatement", "httpFormConnection", "httpURLFunction", "shortURLConnection", "httpREconnection", "httpMLconnection", "httpREClient", "upperURLconnection", "urlURLconnection", "httpRLConnect", "httpURLOperation", " httpHTTPQuery", "cacheURLConnect", "cacheUrlClient", "httpHTTPOperation", "httpWSTransaction", "httpURLClient", "httpMCode", "currentURLCode", "upperURLTransaction", "httpBLConnection", " httpUrlconnection", "httpUROperation", "shortSLConnection", " httpURLConn", "shortSLconnection", "httpURConnection", "httpURLNode", " httpLLConnection", "shortSLConnect", "httpUrlConnect", "httpFormConnect", "httpDateConstruction", "currentURLConnection", " httpHTTPFunction", "httpCLClient", "httpURLConstruction", " httpLLconnection", "httpURLconnection", "httpFormconnection", "httpURLStatement", "httpUrlFunction", "httpHTTPConnection", "httpSLConnect", " httpURLQuery", "urlUrlconnection", "httpWSconnection", " httpURLConnect", "currentURLconnection", "shortURLConnect", " httpURLOperation", "httpDOMFunction", "httpRConnection", "httpURTransaction", "currentURLConnect", "urlURLStatement", "httpDOMConnect", "httpUrlConnector", "httpMLConnect", "cacheUrlConnector", "httpDOMConnection", "httpUrlStatement", " httpURLFunction", " httpURLConstruction", "urlUrlConnection", "upperRconnection", "httpREConn", "urlURLClient", "httpMLConnection", "httpURconnection", "httpURLQuery", "httpLLConn", "httpURLConnector", " httpUrlConnect", "httpUrlClient", "urlURLConnection", "httpURLTransaction", "cacheURLConnector", "httpRLconnection", "httpurlClient", "httpLLConstruction", "cacheUrlConnect", "shortURLconnection", "httpWSConnection", " httpHTTPOperation", "httpDateConnection", "cacheUrlConnection", "httpRTransaction", "httpRconnection", "httpMConnection", "httpURLConnect", "upperRConnection", "httpDateConn", "httpMConnect"], "responseCode": ["statusStatus", "ResponseMessage", "statusCount", "ResponseCode", "statusType", "ResponseStatus", "replyMessage", "ResponseType", "statusCode", "replyType", "responseStatus", "replyCode", "ResponseCount", " responseMessage", "statusMessage", " responseStatus", "replyCount", "responseCount", "responseType", "responseMessage", " responseType"], "lastModified": ["lastModed", "lastMODIFIED", " lastMODined", "lastMinified", "lastEdIFIED", "New", "nextMODified", " lastModied", "lastEdified", "lastModIFIED", "lastmoded", "nextMODed", "lastMODied", "nextModIFIED", "nextMODied", "nextModied", "lastmodIFIED", " lastModined", " lastMODied", " lastMODIFIED", "lastEded", "lastmodified", "_", "lastMODified", "lastMinIFIED", " lastMODified", "lastmodied", "lastModied", "lastMinied", "this", "lastMODification", "lastmodification", "nextModification", "nextMODIFIED", "lastEdification", "lastMODed", " lastModIFIED", "lastModined", "s", "nextModified", "lastModification", "lastMinined", "lastMODined", "nextMODification", "nextModed"]}}
{"id1": "14650352", "id2": "22503685", "code1": "    boolean checkIfUserExists(String username) throws IOException {\n        try {\n            URL url = new URL(WS_URL + \"/user/\" + URLEncoder.encode(username, \"UTF-8\") + \"/profile.xml\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.connect();\n            InputStream is = conn.getInputStream();\n            is.close();\n            return true;\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n    }\n", "code2": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "label": 0, "substitutes": {"checkIfUserExists": ["checkIfuserexists", "checkIfUserExist", "checkIfUserContes", "checkIfUserContist", "checkIfuserexes", "checkIfUserContisting", "checkIfUserListing", "checkIfUserLists", "checkIfUserExisting", "checkIfUserLes", "checkIfUserexists", "checkIfuserexist", "checkIfUserexist", "checkIfuserExisting", "checkIfuserexisting", "checkIfuserExists", "checkIfUserContists", "checkIfuserExes", "checkIfUserList", "checkIfUserExes", "checkIfuserExist", "checkIfUserexisting", "checkIfUserexes"], "username": ["ame", "profile", "login", "data", "family", "name", "email", "uu", "database", "method", "me", "sudo", "description", "u", "user", "text", "account", "password", "key", "address", "subject", "nick", "ername", "staff", "mobile", "path", "filename", "role", "uri", "USER", "title", "users", "token", "uid", "home", "directory", "auth", "string"], "url": ["connection", "sl", "f", "loc", "org", "fl", "channel", "ur", "web", "aur", "base", "ssl", "ll", "ls", "log", "bb", "user", "b", "blog", "page", "l", "client", "address", "Url", "URL", "build", "feed", "api", "uc", "path", "object", "server", "uri", "browser", "http", "file", "impl", "resource", "www", "host", "string"], "conn": ["connection", "nt", "open", "cur", "cb", "loc", "cn", "org", "cos", "nc", "ct", "p", "dn", "ns", "enc", "os", "ann", "rc", "ssl", "lc", "ls", "cs", "conf", "dc", "cli", "ci", "ctx", "connect", "ch", "cf", "h", "close", "n", "conv", "rt", "Conn", "c", "http", "co", "ai", "con", "cp", "Connection", "col", "act"], "is": ["app", "ens", "ais", "Is", "iss", "isl", "it", "cos", "ins", "bs", "ori", "info", "has", "os", "isa", "IS", "ls", "isc", "abs", "css", "err", "its", "i", "api", "bis", "ui", "vs", "ris", "as", "in", "iso", "act", "iris", "ai", "ss", "us", "ios", "ms", "serv", "ip", "fs", "isi"]}}
{"id1": "13152325", "id2": "614099", "code1": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"loadExistingAntlibs": ["loadExistingAntLIBz", "loadExistingAntLibb", "loadExistingantLibb", "loadExistingantlibs", "loadExistingAntLibz", "loadExistingAntLibs", "loadExistingAntlibes", "loadExistingantlibb", "loadExistingAntLIBb", "loadExistingAntLIBs", "loadExistingantlibes", "loadExistingantLibes", "loadExistingantlibz", "loadExistingAntilibz", "loadExistingAntlibz", "loadExistingAntlibb", "loadExistingAntilibb", "loadExistingantLibs", "loadExistingAntLIBes", "loadExistingantLibz", "loadExistingAntLibes", "loadExistingAntilibs", "loadExistingAntilibes"], "classLoader": ["ClassLine", " classLine", "sourceLoader", "constloader", "sourceloader", "constLoader", "classLine", "classContainer", "CLASSloader", "ClassLoading", "CLASSLoading", "ClassLoader", " classUrl", " classloader", " classLoading", "classLoading", " classContainer", "ClassUrl", "CLASSContainer", "sourceLoading", "sourceLine", "constLoading", "classloader", "CLASSLoader", "Classloader", "constUrl", "ClassContainer", "classUrl"], "antlibUrl": ["antlibURL", "ntLibJar", "ntlibURI", "antLibUrl", "ntlibUr", "antlibServer", "antliAddress", "antlibLocation", "artlibServer", "antLibUr", "antLibLocation", "antibUrl", "antliServer", "antlrLocation", "antslUr", "antlabServer", "antliUrl", "antLibJar", "antlrURL", "artlibUrl", "antlibraryServer", "artlibraryAddress", "ntLibURL", "antlibAddress", "antlibraryAddress", "antslJar", "antlabAddress", "ntLibLocation", "artlibraryJar", "artlibraryUrl", "antslURI", "ntLibUrl", "ntlibJar", "antlibUr", "antliJar", "antlabUrl", "ntLibURI", "artlibAddress", "antLibURI", "antlibraryLocation", "antibJar", "ntlibUrl", "antibUr", "antlibraryUrl", "antlrUrl", "antlrJar", "antlibJar", "ntlibLocation", "antslUrl", "artlibraryServer", "antlibURI", "ntlibURL", "ntLibUr", "antlibraryJar", "antlabJar", "antibURI", "antlibraryURL", "antLibURL", "artlibJar"], "antlibUri": ["antlibUric", "antlibraryAri", "antlabUrri", "antlibEro", "antlibOli", "antliOris", "antlibraryUsric", "antlibraryFilero", "antlibEric", "antlibUsri", "antlibraryUro", "antlibraryUris", "antlibAio", "antlibraryURI", "antlibCri", "antlibAri", "antliUpi", "antliOpi", "antlibraryFileRI", "antlibFpi", "antlibFris", "antliUri", "antlabUrrio", "antlibUris", "antlibUtrio", "antlibUsio", "antlibUsro", "antlibFileri", "antlibraryUrio", "antlibOris", "antlibUsris", "antlabUrris", "antlibEri", "antliOri", "antlibOpi", "antlibCRI", "antlibraryUric", "antlibFileris", "antlibUrri", "antlabUio", "antlibraryUsri", "antlibraryAro", "antlibUrio", "antlibUpi", "antlibCric", "antlibUsli", "antlibIri", "antlibraryUsro", "antlibOri", "antlibIris", "antlibARI", "antlibUio", "antlibUspi", "antlibERI", "antlibUtro", "antlibCro", "antliUris", "antlibFileRI", "antlibUsric", "antlibIro", "antliOli", "antlibUrris", "antlibUrrio", "antlibUsrio", "antlibArio", "antlibraryFileri", "antlabUrio", "antliUli", "antlibraryUri", "antlibUtri", "antlibFilero", "antlibUli", "antlibraryFileris", "antlabUri", "antlibAro", "antlibAris", "antlibIRI", "antlabUris", "antlibUro", "antlibUtRI", "antlibUsRI", "antlibraryUsRI", "antlibURI", "antlibraryArio", "antlibFli", "antlibraryARI", "antlibFri"], "resources": ["ids", "multiple", "pages", "thumbnails", "ources", "rows", "times", "maps", "packages", "groups", "results", "ries", "events", "relations", "parents", "items", "roots", "files", "Resources", "bytes", "loader", "features", "apps", "rs", "collection", "ruby", "lines", "strings", "archives", "source", "objects", "classes", "errors", "rt", "http", "details", "users", "resource", "res", "rules", "reports", "plugins", "types", "media"], "url": ["connection", "sl", "f", "data", "loc", "name", "ri", "ur", "layer", "download", "jar", "str", "xml", "base", "ssl", "ource", "ll", "plugin", "page", "user", "loader", "zip", "l", "r", "root", "key", "address", "Url", "service", "URL", "source", "image", "buffer", "feed", "path", "lr", "config", "li", "server", "route", "io", "http", "file", "id", "resource", "coll", "host", "link", "location", "addr", "string", "element"], "stream": ["sl", "er", "f", "data", "channel", "socket", "pool", "handler", "slice", "filter", "body", "clean", "per", "ssl", "model", "user", "loader", "video", "zip", "r", "writer", "e", "parser", "client", "buffer", "source", "feed", "port", "or", "driver", "response", "path", "serial", "system", "v", "form", "context", "read", "server", "view", "document", "io", "http", "in", "file", "transform", "resource", "input", "out", "coll", "host", "string", "Stream"], "reader": ["connection", "iter", "er", "f", "ri", "handler", "worker", "layer", "xml", "per", "library", "loader", "r", "writer", "err", "e", "parser", "rer", "rr", "row", "buffer", "i", "ner", "oder", "entry", "parse", "feed", "source", "or", "driver", "reading", "read", "iterator", "bird", "server", "io", "http", "in", "file", "rar", "ry", "resource", "input", "result", "ler", "Reader", "editor", "rx"], "line": ["job", "le", "sl", "data", "name", "range", "el", "sync", "non", "info", "str", "letter", "base", "log", "rule", "inline", "lc", "page", "liner", "text", "user", "part", "l", "val", "r", "e", "err", "lines", "key", "cell", "lf", "o", "row", "source", "entry", "parse", "block", "Line", "plugin", "li", "read", "pass", "nl", "code", "raw", "pe", "file", "LINE", "word", "lin", "header", "resource", "string", "write", "ip", "end", "element"], "pkg": ["qa", "loc", "git", "packages", "wd", "type", "install", "comp", "p", "info", "jar", "dep", "base", "plugin", "lc", "kg", "class", "prot", "req", "loader", "plug", "ph", "cmd", "zip", "ppa", "alias", "root", "patch", "password", "lang", "pp", "lib", "cmp", "pack", "parse", "Package", "path", "spec", "filename", "dp", "rpm", "file", "module", "prefix", "src", "po", "resource", "dir", "fp", "gp", "cp", "string", "ip"], "uri": ["URI", "util", "ri", "iri", "database", "pi", "base", "plugin", "root", "collection", "address", "service", "i", "cli", "source", "URL", "proxy", "lib", "api", "anti", "ci", "path", "entry", "ui", "li", "server", "io", "http", "file", "resource", "uid", "uni", "string", " URI"], "resource2antlib": ["resource2atlib", "resource2ntlab", "resourceSecondatlib", "resource2aptlib", "resource5antLib", "resource4ntlib", "resource2antrib", "resource4ntLib", "resource2artLib", "resource2artlibrary", "resource2rtLib", "resource4ntlibrary", "resource2antlibrary", "resource2ntl", "resource4antLib", "resource2ntibl", "resource2aptl", "resourceSecondatrib", "resource2antibl", "resource4ntlab", "resource2antl", "resourceSecondatibl", "resource5antlibrary", "resource2aptLib", "resource5antl", "resource2rtlib", "resource2atrib", "resource5antslib", "resourceSecondatLib", "resource2ctlib", "resource2atLib", "resource2antLib", "resource2artlib", "resourceSecondantLib", "resource4antlab", "resource2atibl", "resourceSecondantlib", "resource4antlibrary", "resource2ntLib", "resource2antlab", "resource2ctlab", "resourceSecondantrib", "resource2aptlibrary", "resource2artlab", "resource2ctLib", "resource2rtrib", "resource5antsLib", "resource5antslibrary", "resource2antsl", "resource2ntlibrary", "resource2antslib", "resource5antsl", "resourceSecondantibl", "resource5antlib", "resource4antlib", "resource2antsLib", "resource2ntrib", "resource2rtibl", "resource2ctlibrary", "resource2antslibrary", "resource2ntlib"]}}
{"id1": "8000624", "id2": "11032546", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copyFrom", " transferFile", " copyTo", "copyTo", " copyto", "copyFile", "copyFrom", "CopyFile", " transferTo", "Copyto", "copyto", " transferto", " transferFrom", " copyFile", "CopyFrom"], "dest": ["bin", "data", "sup", "name", "opt", "later", " destination", "table", "them", "cont", "destroy", "comb", "class", "orig", "die", "desc", "w", "output", "txt", "content", "img", "done", "dist", "temp", "test", "source", "path", "filename", "object", " Dest", "delete", "exit", "flat", "file", "wb", "folder", "transform", "src", "Dest", "target", "write", "obj", "tmp", "rest"], "in": ["x", "reader", "bin", "connection", "isin", "sin", "f", "login", "issue", "s", "ins", "pin", "m", "cin", "In", "vin", "inside", "kin", "conn", "b", "inner", "again", "rin", "win", "r", "l", "din", "IN", "ax", "plus", "pull", "ini", "i", "source", "image", "init", "inc", "lib", "nin", "h", "n", "pass", "thin", "inn", "as", "up", "fa", "id", "wave", "lin", "input", "con", "ln", "re", "ac", "gin"], "out": ["x", "bin", "app", "ext", "outside", "data", "name", "socket", "pin", "sync", "ex", "outs", "not", "timeout", "one", "copy", "conn", "w", "b", "output", "cache", "again", "inner", "part", "vert", "user", "writer", "err", "plus", "o", "off", "OUT", "temp", "this", "client", "call", "i", "lib", "external", "image", "inc", "nin", "or", "outer", "exec", "object", "other", "url", "no", "our", "n", "io", "net", "up", "file", "target", "ou", "Out"], "c": ["x", "abc", "cb", "arc", "f", "char", "sc", "m", "ca", "ct", "C", "p", "enc", "ec", "pc", "rc", "lc", "u", "content", "cr", "l", "r", "e", "o", "exc", "esc", "dc", "d", "i", "pointer", "ci", "cc", "comment", "buffer", "ch", "t", "uc", "cf", "xc", "v", "cl", "config", "code", "n", "oc", "cu", "ce", "ic", "cm", "ac", "col", "fc", "bc", "cy"]}}
{"id1": "15799935", "id2": "14598566", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedPart", "saveAttachedBody", "saveAppensionFile", "saveAttPartPart", "saveAttachmentPart", "saveAttachedFile", "saveAttensionBody", "saveAttPartFile", "saveAppachmentbody", "saveAppensionbody", "saveAttensionbody", "saveAppensionPart", "saveAttachedbody", "saveAttachmentFile", "saveAppachmentFile", "saveAttachmentbody", "saveAttPartBody", "saveAppachmentPart", "saveAttensionFile", "saveAppensionBody", "saveAppachmentBody", "saveAttensionPart", "saveAttPartbody"], "context": ["connection", "reader", "current", "Context", "version", "manager", "present", "channel", "container", "support", "cca", "ca", "state", "cms", "event", "definition", "center", "component", "cache", "text", "front", "concept", "content", "collection", "translation", "client", "subject", "service", "kernel", "ctx", "template", "cf", "request", "parent", "driver", "project", "environment", "system", "config", "document", "view", "c", "ce", "message", "community", "resource", "input", "queue", "mc", "coll", "contact", "host", "network", "processor", "media"], "part": ["connection", "app", "name", "point", "channel", "place", "type", "from", "body", "to", "p", "partial", "state", "phase", "event", "art", "per", "base", "component", "position", "parts", "Part", "section", " parts", "pre", "translation", "patch", "mission", "PART", " Part", "comment", "service", "source", "block", "pod", "image", "or", "media", "parent", "object", "file", "message", "upload", "po", "chapter", "plan", "area", "html", "Parts", "start"], "localAttachment": ["LocalAssachment", " localAttachachment", "localPartribution", "localAttachension", "localAttension", "localAvacher", " localAttrollment", "LocalAttment", "localAvacement", "localInstribution", "localAttacement", "localArtment", " localAttribution", " localAttention", "localAddment", "localAttment", " localAttacement", " localExtachment", " localPartension", "LocalAttention", "localattention", "localattrollment", "localAssention", " localPartribution", "LocalAssail", "localAvachment", "localPartension", "localAvention", "localArtail", "localAssment", " localPartention", "localAttachrollment", "LocalAttachment", "localAssail", " localExtacement", "localAddrollment", "localAttachention", "LocalAttail", "localPartention", "localExtacher", " localAttension", "localAttachacement", "localAttacher", "localPartachment", "localAttribution", "localAddail", " localExtacher", "LocalAssment", "localattachment", "localArtention", " localExtention", "localAttention", " localAttachrollment", "localAttrollment", " localAttacher", "localArtachment", "localAttail", "localAssachment", " localPartachment", " localAttment", "localExtacement", "localExtachment", "localAttachachment", "localAttachribution", "LocalAssention", "localInstachment", "localInstention", " localAttachention", "localExtention", "localInstension", "localAddachment", "localattment", "localAddention", "localAttachacher"], "accountId": ["contractId", "contractName", "jobid", "accountInfo", "contactid", "jobId", "appInfo", " accountID", "AccountName", "appId", "accountid", "feedID", "Accountid", "appID", "accInfo", " accountid", "feedid", "accId", "accountID", "appid", "feedName", "feedId", "AccountId", "jobName", "jobID", "accID", "AccountID", "accid", " accountInfo", "accountName", "contractid", "contactName", "contactId", " accountName"], "attachmentId": ["addachmentID", "attociationID", "attlementName", "attmentId", "atachmentReference", "attociationType", "addachmentType", "extachmentid", "adachmentID", "attentionId", "addentionID", "attmissionID", "attmissionId", "extachmentId", "atachmentName", "atociationReference", "attensionSource", "attentionSource", "adachmentInfo", "atociationName", "attlementId", "attmentName", "attmentReference", "attociationId", "attachmentID", "attachedType", "attentionIndex", "attentionUrl", "attociationReference", "atociationID", "extachmentSource", "attociationUrl", "attlementReference", "attociationName", "attachmentReference", "attlementID", "attensionid", "attachmentSource", "attentionType", "attachedID", "attentionid", "extensionSource", "atociationId", "attachedUrl", "attptionID", "adachmentIndex", "attensionID", "addentionId", "extensionid", "attptionId", "adentionIndex", "attmissionSource", "attmissionid", "attachmentType", "attachmentIndex", "attachmentInfo", "addachmentId", "adentionInfo", "attagramIndex", "attachmentUrl", "attagramInfo", "atachmentID", "adachmentId", "atachmentId", "addachmentUrl", "attachmentName", "attptionIndex", "attmentID", "extachmentID", "attentionID", "attachmentid", "attptionInfo", "attachedId", "extensionId", "attentionInfo", "adentionId", "extensionID", "addentionUrl", "attensionId", "attagramID", "attagramId", "adentionID", "addentionType"], "in": ["reader", "bin", "login", "f", "data", "it", "socket", "slice", "ins", "pin", "p", "cin", "info", "load", "In", "is", "inside", "copy", "conn", "inner", "again", "din", "IN", "err", "plus", "pull", "ini", "i", "source", "init", "image", "inc", "nin", "or", "url", "pass", "inn", "file", "as", "id", "up", "a", "input", "con", "ac", "gin"], "saveIn": [" savein", "savIn", "aveIn", "avein", "saveOut", "saveIN", "aveAs", " saveIns", "stageIn", "savAs", "writeIN", " saveOut", "SaveIns", "writeIn", "aveOut", "savOut", "stageOut", "savein", "stageIns", "SaveIn", "saveIns", "stageAs", " saveIN", "savin", "writeOut", "SaveAs", "aveIN", "SaveOut", "writein"], "saveAs": ["openAs", "copyAs", "saveAt", "openAS", "saveOut", "createAt", "copyas", " saveOut", "copyIn", "writeIn", " saveas", " saveAS", "writeAs", "SaveAS", "createAS", "saveAS", "SaveIn", "createAs", "saveFile", " saveFile", "copyAS", " saveAt", "writeOut", "openAt", "openFile", "SaveAs", "saveas", "writeAS", "SaveOut", "createFile", "Saveas"], "out": ["bin", "ext", "data", "name", "at", "s", "sync", "to", "ex", "outs", "copy", "page", "conn", "again", "output", "cache", "inner", "line", "writer", "err", "flow", "o", "client", "off", "OUT", "temp", "this", "plus", "source", "init", "image", "inc", "path", "exec", "outer", "v", "other", "default", "null", "io", "c", "file", "as", "up", "a", "Out", "string"], "copySize": ["CopyTime", " copyTime", "saveLength", "leSize", "byteTime", " copySIZE", "saveSize", "savesize", "lesize", "copyAddress", "CopySize", "openSIZE", "copyTime", "leLength", "copySIZE", "leSIZE", "Copysize", " copysize", "bytesize", "copysize", "byteAddress", " copyLength", "openLength", "copyLength", "saveAddress", "CopyLength", "byteLength", "opensize", " copyAddress", "openSize", "byteSize"], "contentUriString": ["contentUioStr", "contentIiByte", "contentUiniByte", "contentUridStr", "contentUrisString", "contentUioInt", "contentUpiInt", "contentUriUnit", "contentUpiStr", "contentUriByte", "contentUiNumber", "contentUriStr", "contentIrisInt", "contentUrisstring", "contentUiByte", "contentIrisStr", "contentUiostring", "contentUpiString", "contentIriStr", "contentIrisUnit", "contentUuriByte", "contentIriInt", "contentIiStr", "contentUridString", "contentUuriString", "contentUrisUnit", "contentUiString", "contentIrisString", "contentIriByte", "contentUuriNumber", "contentIiNumber", "contentIiString", "contentIristring", "contentUioString", "contentUiStr", "contentIrisstring", "contentUiniNumber", "contentUridUnit", "contentUiniStr", "contentUriInt", "contentUriNumber", "contentUuriStr", "contentUrisStr", "contentUiUnit", "contentUpistring", "contentUrisInt", "contentIriNumber", "contentUiniString", "contentIriString", "contentUristring", "contentIriUnit"], "mSize": ["pLength", "iLength", "cCount", "cSize", "mCount", "mLength", "pSize", "cLength", "mName", "pName", "iCount", "iSize", "iName", "cName", "pCount"], "mContentUri": ["mContentIci", "mResourceUric", "mContentUrci", "mResourceIris", "mContentUci", "mResourceUri", "mContentUric", "mContentOUri", "mContentUrris", "mContentIric", "mResourceUci", "mContentUris", "mContentIris", "mContentOUris", "mResourceUris", "mResourceIri", "mResourceIci", "mResourceIric", "mContentOUci", "mContentUrri", "mContentIri", "mContentOUric", "mContentUrric"], "cv": ["nv", "GV", "cb", "keep", "loc", "cd", "nc", "CV", "av", "vp", "sc", "iv", "ca", "cap", "vr", "enc", "vv", "rc", "cs", "lc", "iq", "auc", "csv", "content", "sv", "cr", "vm", "um", "bc", "cc", "ctx", "vc", "uc", "cf", "xc", "v", "vs", "conv", "core", "cu", "uv", "c", "lv", "VC", "co", "ov", "coll", "cm", "cover", "mc", "fp", "que", "ctrl", "cp", "fc", "pb", "buf"], "uri": ["URI", " url", "data", "point", "ri", "gb", "iri", "iv", "range", "pi", "universal", "base", "oid", "format", " ur", "href", "qi", "query", "address", "proxy", "i", "cli", "ci", "storage", "api", "path", "environment", "url", " scheme", "ui", "mi", "attribute", " Uri", "route", "metadata", "http", "id", "prefix", "resource", "uid", "location", "uni", "string", " URI", "username"]}}
{"id1": "16621499", "id2": "1586662", "code1": "    public static byte[] loadURLToBuffer(URL url) throws IOException {\n        byte[] buf = new byte[4096];\n        byte[] data = null;\n        byte[] temp = null;\n        int iCount = 0;\n        int iTotal = 0;\n        BufferedInputStream in = new BufferedInputStream(url.openStream(), 20480);\n        while ((iCount = in.read(buf, 0, buf.length)) != -1) {\n            if (iTotal == 0) {\n                data = new byte[iCount];\n                System.arraycopy(buf, 0, data, 0, iCount);\n                iTotal = iCount;\n            } else {\n                temp = new byte[iCount + iTotal];\n                System.arraycopy(data, 0, temp, 0, iTotal);\n                System.arraycopy(buf, 0, temp, iTotal, iCount);\n                data = temp;\n                iTotal = iTotal + iCount;\n            }\n        }\n        in.close();\n        return data;\n    }\n", "code2": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"loadURLToBuffer": ["loadURLAsbuffer", "loadURLTobuf", "loadURL2buf", "loadUrlAsBuff", "loadURL2Buffer", "loadURLAsbuf", "loadURLTobuffer", "loadUrlToBuff", "loadURLTOBuffer", "loadURLTOBuff", "loadURLTObuf", "loadURLAsBuff", "loadUrlTobuffer", "loadURLToBuff", "loadUrlAsbuffer", "loadUrlTobuf", "loadURLTObuffer", "loadUrlAsbuf", "loadUrlAsBuffer", "loadURL2buffer", "loadURLAsBuffer", "loadURL2Buff", "loadUrlToBuffer"], "url": ["job", "connection", "sl", "f", "name", "org", "gl", "el", "stream", "str", "base", "ssl", "html", "page", "b", "loader", "user", "l", "fr", "address", "Url", "buffer", "URL", "source", "service", "path", "filename", "object", "config", "server", "uri", "http", "file", "resource", "queue", "out", "rel", "string", "obj", "il"], "buf": ["cb", "bd", "iter", "seq", "loc", "ff", "bu", "batch", "array", "buff", "aux", "Buffer", "bh", "bb", "br", "txt", "bytes", "done", "front", "bag", "la", "rb", "abi", "buffer", "count", "cat", "db", "ctx", "port", "uc", "band", "context", "Buff", "cv", "ab", "func", "wb", "wave", "src", "fd", "uf", "tc", "queue", "bf", "append", "fp", "pad", "input", "coll", "desc", "fb", "bc", "tmp"], "data": ["type", "div", "str", "orig", "done", "val", "la", "buffer", "cat", "source", "ada", "limit", "next", "default", "beta", "pad", "tmp", "bu", "load", "cache", "output", "bytes", "content", "count", "init", "wa", "parent", "ui", "DATA", "result", "bc", "reader", "f", "p", "info", "da", "part", "api", "config", "raw", "empty", "pos", "valid", "dat", "area", "meta", "extra", "batch", "slice", "body", "array", "results", "buff", "zero", "base", "di", "text", "size", "i", "ata", "db", "memory", "index", "a", "input", "total", "alpha", "media"], "temp": ["full", "offset", "extra", "iter", "alt", "current", "Temp", "mini", "pt", "stable", "body", "p", "partial", "buff", "shared", "local", "base", "wrap", "cache", "output", "size", "txt", "content", "tem", "zip", "done", "pre", "key", "dest", "test", "buffer", "i", "padding", "count", "init", "template", "wa", "source", "path", "parent", "config", "unit", "null", "thin", "empty", "flat", "pos", "prefix", "valid", "index", "tc", "cel", "dat", "input", "diff", "total", "fake", "length", "json", "tmp"], "iCount": ["iLength", "multiTotal", "multiSize", "iiType", "piType", "xiLength", "ITotal", " iStart", "xiType", "IMax", "jCount", "jLength", "siLength", " iMax", "ILength", "piSize", "pStart", "ricount", "piStart", "pMax", "iMin", "jTotal", "IType", "siTotal", "xiTotal", " iSize", "piLength", "iStart", "jcount", "piCommon", "inicount", "iniCast", "iiLength", "pTotal", "IMin", "iCommon", "multiLength", "multiCount", "iiMin", "iCast", "icount", " iCommon", " icount", "oiCount", "riTotal", "oiTotal", "siStart", "piTotal", "iSize", " iCast", "sicount", "pCount", "iniCount", "xiCount", "oiType", "ICount", " iLength", "iType", "piCount", "iiCount", "riCast", " iType", "oiCommon", "riCount", "iMax", "siCount", "iniTotal", "IStart", " iMin"], "iTotal": ["iLength", "multiTotal", " iMax", " itotal", "pMax", " iBasic", "iiComplete", "piRest", "uriCount", "iComplete", "iPercent", " iGlobal", "uritotal", "IPercent", "piCount", "xiBasic", "iiZero", "iiGlobal", "xiLength", "uType", " iComplete", "ILength", "uriCommon", "siTotal", "piComplete", " iCommon", "uCount", "pLast", " iZero", "piTotal", "iGlobal", "piGlobal", " iLength", "iiPercent", "iType", "iBasic", "uLast", "oiCount", "pLength", "ITotal", "iRest", "iiRest", " iPercent", "piLength", "itotal", "iiLength", "pTotal", "uTotal", "iiTotal", "iCommon", "multiLength", "multiCount", "iLast", "uriTotal", "oitotal", "oiTotal", "pType", "pCount", " iLast", "siLast", "iiCount", "oiCommon", "iMax", "IMax", "piBasic", "siLength", "iiLast", "iiMax", "iZero", "siZero", "xiTotal", " iRest", "xiCount", " iType", "iiBasic", "multiMax"], "in": ["reader", "bin", "login", "f", "fac", "ilo", "at", "s", "ins", "stream", "ex", "min", "In", "is", "ssl", "b", "inner", "again", "win", "din", "l", "r", "IN", "err", "fr", "client", "la", "ini", "buffer", "i", "source", "init", "inc", "nin", "or", "h", "exec", "io", "inn", "c", "as", "impl", "input", "out", "con", "ac", "gin"]}}
{"id1": "19467540", "id2": "19147281", "code1": "    @Override\n    public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) {\n        Connection conexion = null;\n        PreparedStatement select = null;\n        PreparedStatement update = null;\n        ResultSet rs = null;\n        boolean exito = false;\n        try {\n            conexion = pool.getConnection();\n            conexion.setAutoCommit(false);\n            select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\");\n            update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\");\n            String codigoProd;\n            int filasAfectadas = 0;\n            Iterator<String> iterador = carro.keySet().iterator();\n            while (iterador.hasNext()) {\n                codigoProd = iterador.next();\n                select.setString(1, codigoProd);\n                rs = select.executeQuery();\n                if (rs.next() == false) {\n                    Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\");\n                    iterador.remove();\n                    conexion.rollback();\n                } else {\n                    Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\"));\n                    select.clearParameters();\n                    if (carro.get(codigoProd) > prod.getStock()) {\n                        Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\");\n                        iterador.remove();\n                        conexion.rollback();\n                    } else {\n                        update.setInt(1, prod.getStock() - carro.get(codigoProd));\n                        update.setString(2, codigoProd);\n                        filasAfectadas = update.executeUpdate();\n                        if (filasAfectadas != 1) {\n                            Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\");\n                            conexion.rollback();\n                        }\n                        update.clearParameters();\n                        listado.put(prod, carro.get(codigoProd));\n                    }\n                }\n            }\n            conexion.commit();\n            exito = true;\n        } catch (SQLException ex) {\n            logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex);\n            try {\n                conexion.rollback();\n            } catch (SQLException ex1) {\n                logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1);\n            }\n        } finally {\n            cerrarConexionYStatement(conexion, select, update);\n            cerrarResultSet(rs);\n        }\n        return exito;\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 1, "substitutes": {"updateProductIfAvailable": ["updateProductsifAvailable", "updateProductUnlessPresent", "updateProductifAvailability", "updateProductsIfavailable", "updateProductIfAvailability", "updateProductsifavailable", "updateProductWhereAvailable", "updateProductifavailable", "updateProductsifPresent", "updateProductIfPresent", "updateProductifPresent", "updateProductUnlessAvailable", "updateProductsIfPresent", "updateProductWherePresent", "updateProductWhereAvailability", "updateProductsifAvailability", "updateProductifAvailable", "updateProductUnlessAvailability", "updateProductWhereavailable", "updateProductIfavailable", "updateProductsIfAvailability", "updateProductUnlessavailable", "updateProductsIfAvailable"], "carro": ["charRO", "borros", "carros", "borlo", "Carroc", "Carrio", "corro", "charco", "borro", "CarRO", "carco", "corlo", "charros", "corco", " carlo", "corros", "carra", "Carlo", "Carros", "charrio", "carrio", "borroc", "harra", " carroc", "Carro", "corra", " carrow", "carroc", " carRO", "harro", "Carra", " carros", "carRO", " carrio", "carrow", "charro", "charrow", "harros", "corrow", " carco", "carlo", "harlo"], "request": ["job", "data", "current", "apply", "pool", "session", "create", "remote", "worker", "method", "p", "info", "application", "xml", "req", "model", "require", "register", "user", "instance", "r", "query", "work", "collection", "respect", "client", "subject", "condition", "port", "submit", "response", "project", "parent", "object", "Request", "url", "config", "hello", "server", "platform", "core", "demand", "http", "params", "message", "result", "resource", "input", "queue", "join", "resources", "json", "use", "username", "remove"], "listado": [" listando", "sortable", "catable", "sortando", "listada", "sortado", " listada", "listando", "catada", " listable", "sortada", "catado", "listable", "catando"], "conexion": ["conexpution", "coneexansion", "cextison", "conexaor", "coneexION", "caexion", "Coleexansion", "coneyiton", "conextension", "conexione", "caexiton", "conexbor", "coneXione", "Colexansion", "cexpione", "conextION", "coneyiao", "caexiao", "caxiao", "zonexension", "coneplexiton", "conexao", "conexif", "conexbao", "conexiension", "conexaao", " conexION", "caxiton", "conexions", "cexpiton", " conexaion", "conexyiang", "conexyION", "conelexion", " conexao", "zonextION", "cexpao", " conexaions", "conexeION", "conexiang", "conexaions", " conexif", "Coleexiton", "conexpao", "conexison", "cexion", "conexesions", "conexyension", "conexyion", "conextao", "coneyions", "conexbion", "conexiion", "conexpION", "conexiton", " conexeif", " conexaao", "conenexION", "conexpione", "conexpif", " conexution", "conexesor", "conexpansion", "conenexion", "conexension", "zonextension", "cextiton", "conextiton", "conenexansion", "coneXiton", "zonexiang", "cexione", "conenexiton", "coneplexao", "conexpions", "coneyion", "caxion", "coneplexion", "coneexiao", " conexions", "conexeion", "conextiang", "conexbions", "conelexison", " conexeion", "coneplexison", "conexeif", "zonextiang", "cexpion", "conexpiton", "ColeexION", "conelexION", "conelexif", "cextao", "caexions", "conextison", "coneXion", "zonexION", "Coleexion", "ColexION", "cexiton", " conexor", "caxions", "zonexion", "cexao", "conexor", "conexpion", "conextion", "cextion", "coneXao", "coneexion", "conexansion", "conexpiao", "conexution", "conelexiton", "conexiiang", " conexaor", "conelexao", "coneexions", "conexiao", "conexesion", "conexaion", " conexeION", "conextione", "zonextion", "conexION", "Colexion", "Colexiton", "conexeution", "conexiION", "cexison", "coneexiton", "conelexution", " conexeution", "conexesao"], "select": ["save", "get", "apply", "where", "create", "sync", "SELECT", "state", "set", "match", "ssl", "copy", "roll", "text", "query", "subject", "pull", "construct", "sq", "test", "parse", "build", "init", "connect", "port", "collect", "Select", "reflect", "delete", "config", "view", "core", "search", "elect", "sel", "lect", "result", "input", "join", "sql", "execute", "push", "insert", "use", "selection", "remove"], "update": ["save", "current", "get", "where", "edit", "database", "create", "options", "change", "sync", "send", "settings", "set", "status", "ssl", "add", "copy", "updated", "pull", "Update", "run", "build", "feed", "response", "delete", "url", "view", "post", "http", "up", "index", "search", "id", "result", "resource", "replace", "UPDATE", "execute", "push", "json", "insert", "write", "apply"], "rs": ["mr", "ts", "values", "rows", "RS", "maps", "rm", "ds", "ack", "ins", "results", "Rs", "acks", "vers", "relations", "utils", "ows", "sys", "parse", "rc", "ats", "cs", "ys", "ls", "pr", "rob", "roc", "ums", "obs", "features", "repl", "r", "runs", "rr", "ras", "sq", "rates", "rys", "hs", "ws", "hr", "qs", "ret", "spec", "response", "rg", "ars", "xs", "js", "vs", "rd", "errors", "server", "rt", "ps", "ris", "details", "fields", "sr", "changes", "row", "rss", "asts", "ros", "res", "result", "rors", "rl", "ks", "rx"], "codigoProd": ["codicoprodo", "codigoPromdB", "codigoProdo", "codigiProe", "codigoPromdd", "codigoProdd", "codigoPerdl", "codigi\n", "codigoprodr", " codichoSelect", "codigaprold", "codigiPropd", "codicoprold", "codigiPrope", "codigaProdh", "codigiProdr", "codigoPd", "codidoProdl", " codicho\n", "codigoproe", "codigoPeard", "codicoProd", "codigoPerd", "codigoProld", "codigoProe", "codigaprod", "codigiProdd", "codidoProdB", "codigoPromld", "codidoprods", "codigoProdB", "codigaProsd", "codogo\n", "codigoPropd", "codidoProdd", "codigoPUd", "codigoPromd", "codigoSuppd", "codigoProdh", "codigoCompanyld", "codidoprodB", "codigoPeards", "codigoProds", " codigoSelect", "codigoPUe", "codigoCompanydo", "codigoSuppds", "codigoProsd", "codigoprodB", "codigoPUdd", "codigoPld", "codicoProds", "codicoProdo", "codidoprodl", "codigoPropdr", "codidoProd", "codigoprods", "codigoPeardB", "codigaProld", "codigiPropdr", "codigoprold", "codigaProd", "codigoProdl", "codigiPropdd", "codidoprold", "codigaprodh", "codicoProld", "codigoPdo", "codigoSuppld", "codigoPds", "codigoPromdh", "codigaprosd", "codigoPerld", "codigoprodl", "codigoprosd", "codigoprodd", "codigoSelect", "codidoprod", " codigo\n", "codigoPromsd", "codigoSuppdl", "codidoProds", "codigoPromds", "codigoPUdr", "codigoCompanyds", "codogoSelect", "codigoprodo", "codigoprod", "codigoPerds", "codicoprods", "codigiProd", "codigoprodh", "codigoProdr", "codigoPropdd", "codigo\n", "codigoCompanyd", "codigiSelect", "codigoPeardd", "codicho\n", "codicoprod", "codigoPrope", "codidoprodd", "codidoProld", "codichoSelect"], "filasAfectadas": ["filasAcfectable", "filasAcessida", "filasAfectable", "filasAcfectida", "filasAfectida", "filasAfectado", "filasAcessable", "filasAcessadas", "filasAccesadas", "filasAcesable", "filasAducadas", "filasAducable", "filasAducado", "filasAccesida", "filasAducida", "filasAccesado", "filasAcesado", "filasAccesable", "filasAcfectadas", "filasAcessado", "filasAcesadas", "filasAcesida", "filasAcfectado"], "iterador": ["Iteraton", "nerable", "iterar", "Iterado", "outeraton", "iterada", "enterador", "alternable", "errabo", "nerador", "enter\u00e1", "iteroration", "operato", "errrar", "iterrar", "Iter\u00e1", "enterabo", "perador", "alternoration", "errador", "perato", " iterar", "iterabo", "perada", "operada", "nerabo", "Iterrar", "outerar", " iterada", " iteroration", "Iterabo", "neroration", " iterable", "Iterar", "iter\u00e1", "enterator", "perator", "alternador", "iterator", "iteraton", " iterabo", "Iterator", " iterator", "iterado", "iterato", "operator", "errator", " iterrar", "operador", " iteraton", " iterato", " iterado", "outerado", "alternabo", "outerador", "iterable", "Iterador", " iter\u00e1"], "prod": ["pubc", " prog", "produd", "perc", "provdd", "prods", "Prog", "proc", "prog", "perd", "pubd", "prob", "Proc", "produds", "perb", " proc", "provds", "Prob", "provb", " prob", "Prods", " prodd", "pubD", "produD", "Prod", "prodd", "Prodd", " prods", "produc", "pubds", "provd", "proD", "perg", " proD"], "exito": ["pacito", "EXited", "exiting", "EXiting", "EXito", "xitation", "paciting", "xiting", "xited", "exited", "exitation", "pacitation", "pacited", "EXitation", "xito"]}}
{"id1": "3731077", "id2": "23666867", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", " copyfile", "transferFile", "importfile", "importFiles", "transferfile", " copyFiles", "importSourceFile", "copySourceFile", "transferFiles", " copySourceFile", "importFile", "transferSourceFile", "copyfile"], "from": ["f", "data", "name", "origin", "at", "range", "From", "ca", "remote", "se", "without", "base", "add", "with", "part", "user", "front", "by", "left", "old", "o", "before", "client", "address", "back", "this", "d", "source", " form", "or", "path", "of", "form", "url", "config", "io", "c", "file", "original", "ce", "as", "src", "a", "id", "about", "resource", "start"], "to": ["office", "f", "into", "name", "point", "two", "socket", "at", "eto", "toc", "TO", "type", "p", "database", "auto", "one", "os", "To", "top", "base", "copy", "with", "b", "again", "output", "size", "by", "until", "root", "too", "o", "client", "dest", "temp", "this", "storage", "source", "t", "api", "or", "parent", "object", "of", "null", "io", "as", "file", "po", "about", "target", "token", "location", "so", "site"], "parentDir": ["outFolder", "rootDir", "currentFile", "outDir", "parentFile", "Parentdir", "outFile", "rootFolder", "currentFolder", "ParentDir", " parentFile", " parentDirectory", "rootFile", "ParentFolder", "ParentDirectory", "rootDirectory", " parentFolder", "parentDirectory", "parentdir", "currentdir", "ParentFile", "currentDir", " parentdir", "parentFolder", "outDirectory"], "in": ["trial", "reader", "bin", "isin", "login", "it", "gin", "ins", "pin", "m", "sync", "cin", "min", "In", "pc", "vin", "rc", "rec", "ie", "kin", "inside", "plugin", "conn", "part", "inner", "again", "rin", "with", "win", "l", "r", "din", "IN", "err", "work", "o", "pre", "ini", "i", "source", "init", "image", "inc", "or", "nin", "exec", "arin", "form", "url", "io", "inn", "id", "on", "lin", "input", "con", "diff", "ac", "fc"], "out": ["bin", "app", "org", "channel", "at", "ot", "auto", "sync", "p", "cin", "ex", "outs", "plugin", "conn", "w", "again", "output", "user", "op", "inner", "can", "vert", "win", "writer", "o", "off", "client", "OUT", "ico", "call", "init", "inc", "or", "outer", "exec", "other", "io", "net", "c", "co", "on", "input", "ou", "about", "ac", "Out", "gin", "option", "cy"], "ic": ["icc", "iac", "pic", "loc", "auto", "ct", "irc", "cin", "sync", "ex", "enc", "ics", "aic", "ec", "pc", "rc", "ix", "cs", "lc", "conn", "op", "o", "ico", "ig", "dc", "i", "ci", "cc", "cus", "vc", "inc", "or", "uc", "anc", "nic", "ik", "IC", "xc", "cl", "voc", "cu", "io", "c", "co", "acs", "ai", "mc", "input", "ac", "fc", "bc"], "oc": ["AC", "cur", "loc", "org", "ack", "toc", "sc", "alloc", "ca", "wic", "oca", "enc", "aic", "ec", "pc", "roc", "op", "can", "o", "circ", "oci", "og", "dc", "i", "ci", "cc", "cus", "vc", "uc", "or", "inc", "nic", "anc", "ocon", "xc", "voc", "mic", "OC", "io", "c", "oco", "co", "ocol", "acs", "soc", "aco", "mc", "ac", "fc", "bc", "ob", "cy"]}}
{"id1": "2168610", "id2": "1141361", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 1, "substitutes": {"update": ["connection", "save", "lock", "open", "current", "family", "get", "version", "name", "where", "edit", "error", "complete", "database", "create", "put", "range", "handle", "change", "sync", "send", "state", "event", "timeout", "load", "grade", "set", "status", "add", "position", "future", "check", "text", "instance", "ite", "bug", "patch", "updated", "address", "pull", "Update", "build", "run", "value", "inc", "response", "fill", "delete", "config", "width", "view", "date", "unit", "http", "up", "id", "index", "message", "resource", "diff", "result", "replace", "UPDATE", "draw", "insert", "write", "use", "end", "apply"], "o": ["office", "connection", "f", "oa", "oe", "oo", "m", "p", "k", "one", "os", "oid", "conn", "ono", "online", " O", " object", "e", "t", "or", "mo", "object", "ao", "ion", "oi", "n", "c", "co", "po", "bo", "ou", "O", "od", "none", "so", "obj", "ob"], "contact": ["connection", "office", "f", "point", "phone", "email", "campaign", "sync", "info", "event", "lead", "control", "match", "lc", "model", "check", "contract", "front", "content", "concept", "ace", "work", "collection", "cell", "account", "client", "address", "product", "call", "entry", "cmp", "fax", "cc", "connect", "feed", "project", "object", "choice", "form", "character", "config", "relation", "date", "conference", "cart", "co", " Contact", "coll", "result", "charge", "company", "report", "communication", "Contact", "act"], "pst": [" put", "psst", "put", "prsp", "pct", "spst", "prsta", "lpsts", "prST", "Pcr", "opst", "wpcr", "Post", "pcr", "preut", "prsl", "psc", " pct", "psta", "opsts", " pcr", "ptd", "wptd", " pST", "Pdd", "Psts", "pstd", "spct", " ptd", "wpst", "prsc", "lpst", " psc", "lptd", "prst", "lpST", "pssts", "psp", " psta", " psl", "PST", " psp", "Pct", "Psc", " pdd", "opste", "lpcr", "lpsta", "prct", "prste", "pssl", " pste", "Pst", "sput", "prdd", "pST", "epst", "epcr", " psts", " post", "epsts", "wpsh", "prect", "pdd", "prest", "prsts", "preste", "pste", "lpsh", "Psp", "Pste", "epST", "psts", "spste", "prcr", " psh", "post", "psl", "psh", "prtd", "opct", "prost"]}}
{"id1": "22993368", "id2": "9347451", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeFileAsStream", "decodeFileToFiles", "decodeFile2File", "decodeFileToString", "decodeStringToStream", "decodeStringToString", "decodeFileAsString", "decodeFileAsFile", "decodeString2File", "decodeFileFromFiles", "decodeFileFromFile", "decodeString2Stream", "decodeString2String", "decodeFileFromStream", "decodeStringToFiles", "decodeString2Files", "decodeFileToStream", "decodeFile2Stream", "decodeFileAsFiles", "decodeStringToFile", "decodeFile2Files", "decodeFileFromString"], "infile": ["inputfilename", "outfilename", "infilename", " instream", "inputfile", "inputfiles", "minfile", "outfiles", "infp", "Instream", "inputfp", "Inbase", "outfp", "minstream", " infilename", " infp", " infiles", " inbase", " inFile", "instream", "infiles", "minFile", "inbase", "minbase", "InFile", "Infile", "inFile"], "outfile": ["inputFile", "outputfilename", "outfilename", "infilename", "inputfile", "outpath", "outputFile", "outFile", " outfilename", "inputdatabase", " outdatabase", "inputpath", " outpath", " outFile", "outputdatabase", "outdatabase", " outfolder", "outputfile", "infolder", "outputpath", "outputfolder", "outfolder", "inFile"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "lin", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "channel", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "log", "copy", "conn", "cache", "again", "output", "inner", "line", "writer", "work", "err", "off", "client", "o", "OUT", "lib", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "pass", "post", "io", "net", "file", "up", "co", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "bin", "reader", "border", "uffer", "iter", "data", "channel", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "queue", "input", "result", "length", "write", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "r", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "positive", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "10361370", "id2": "11049257", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["version", "dump", "hex", "ashing", "match", "check", "cache", "password", "key", "crypt", "comment", "block", "build", "h", "fill", "sum", "update", "sign", "shadow", "dh", "index", "sha", "header", "ash", "render", "Hash", "html"], "saltBefore": ["sultBefore", "sintFrom", "sintHead", "isaltBefore", "sintBefore", "isaltFrom", "isaltStart", "isaultBefore", "sultHead", "isaultHead", "singALTStart", "sALTAbove", "saltStart", "seedAfter", "isaultFrom", "singaltAbove", "sultFrom", "saultStart", "saltFrom", "seedStart", "singaltBefore", "singaltAfter", "sALTBefore", "singALTBefore", "saultHead", "saltHead", "sintStart", "isaultStart", "sertBefore", "singaltStart", "sertAfter", "sertStart", "singALTAbove", "sultStart", "singALTAfter", "seedAbove", "sALTAfter", "saultFrom", "sALTStart", "sertAbove", "isaltHead", "saultBefore", "seedBefore", "saltAbove"], "content": ["sequence", "data", "version", "method", "creator", "stream", "body", "cont", "str", "xml", "expression", "format", "music", "model", "cache", "text", "output", "entity", "size", "section", "password", "address", "Content", "temp", "comment", "buffer", "source", "image", "value", "parent", "filename", "pattern", "character", "url", "object", "document", "raw", "code", "script", "word", "message", "header", "input", "resource", "length", "json", "string", "media"], "saltAfter": ["saultafter", "saltEnd", "saltAround", "sintBefore", "saltedBefore", "saltafter", "sintExtra", "singALTAround", "sintafter", "saultAfter", " sALTafter", "singaltAround", "singaltBefore", "singaltAfter", " saltafter", "sALTafter", "sALTBefore", "saltedAround", "sALTExtra", "saltExtra", "singALTBefore", "sertBefore", "sertEnd", "sertAfter", "singaltEnd", "saultExtra", "sALTEnd", "singALTAfter", " sALTExtra", "saltedEnd", " sALTAfter", "saltedAfter", "sertAround", "singALTEnd", " sALTBefore", "sintAfter", "sALTAfter", " saltExtra", "sALTAround", "saultBefore"], "repeatedHashingCount": ["repeatedHashedNumber", "repeatedChashesType", "repeatedHashingNumber", "repeatedHashesType", "repeatedHashCount", "repeatedHumpingCount", "repeatedShashCode", "repeatedHashedcount", "repeatedChashingCount", "repeatedHashesCount", "repeatedShashingCode", "repeatedHashLength", "repeatedShashingCounter", "repeatedHashesNumber", "repeatedHashCode", "repeatedHumpingType", "repeatedHashCounter", "repeatedShashLength", "repeatedHashingLength", "repeatedHashedCount", "repeatedShashCounter", "repeatedHatingLength", "repeatedHashedType", "repeatedHashesCounter", "repeatedHashingCode", "repeatedHashingCounter", "repeatedHashesLength", "repeatedHatingCounter", "repeatedHumpingNumber", "repeatedChashingType", "repeatedHashingType", "repeatedChashesNumber", "repeatedHumpingcount", "repeatedChashesCount", "repeatedChashescount", "repeatedHashingcount", "repeatedChashingNumber", "repeatedHatingCount", "repeatedShashingCount", "repeatedHatingCode", "repeatedChashingcount", "repeatedHashescount", "repeatedShashCount", "repeatedShashingLength", "repeatedHashesCode"], "digest": ["signEST", "mixested", "loggest", "generest", " diger", " digests", "DigEST", "generests", "mixester", "mixest", "Digester", "Digusher", " Digest", "diggest", "generester", "digested", "ngest", " digusher", " diggest", "hashested", " digator", "digester", "digEST", "nger", "ngested", "hashString", "Digator", "digString", " digger", "digger", " Digator", "logester", "hashests", "signester", "digator", " digEST", "hexString", "Digested", "hexest", "validester", "validest", "signested", "diger", "Digger", "digusher", "logest", "valider", " Diger", " Digester", "Diger", "Diggest", "finests", "signest", "signger", "finest", "hexested", "digests", "hashest", "loger", "generested", "hexests", "finester", "finested", " digested", "mixusher", "validested", " digester", "Digest", "ngester", "Digests", "DigString"], "digestLength": ["digestingLen", "DigestLen", "digestsLength", "digestlength", "digestType", "digesterLen", "digesterlength", "digestingLength", "digestedLen", "DigestLength", "Digestlength", " digestLen", "digestslength", "digesterLength", " digesterLen", " digesterType", "digestedLength", "digestsLen", " digesterLength", "digestinglength", "digestedlength", " digesterlength", "Digesterlength", "DigesterLength", "digestingType", " digestType", "digestLen", "digesterType", " digestlength", "DigesterLen", "digestsType"], "i": ["x", "f", "si", "ti", "ri", "s", "slice", "p", "j", "info", "pi", "k", "lc", "I", "di", "u", "b", "bi", "multi", "ami", "qi", "l", "fi", "e", "o", "ini", "d", "count", "ci", "anti", "t", "api", "h", "xi", "v", "oi", "ui", "li", "n", "uri", "zi", "ii", "io", "c", "id", "index", "iu", "mu", "chi", "ai", "gi", "phi", "length", "start", "wei"]}}
{"id1": "6470716", "id2": "11049257", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "label": 0, "substitutes": {"st": ["est", "const", "f", "s", "sc", "put", "pt", "ct", "ist", "inst", "ast", "sth", "str", "fe", "class", "ste", "ld", "sts", "ust", "ST", "Str", "r", "fr", "std", "d", "t", "tt", "struct", "St", "sta", "stage", "cl", "code", "id", "src", "sb", "www", "sf", "ost", "stress", "ft", "string", "start", "rest"], "url": ["ul", "connection", "open", "sl", "f", "loc", "org", "fl", "ur", "gl", "stream", "web", "download", "pl", "log", "base", "ssl", "ll", "ls", "bb", "html", "b", "user", "blog", "page", "zip", "l", "bug", "err", "fr", "address", "Url", "URL", "build", "source", "feed", "image", "or", "hub", "path", "cl", "uri", "server", "http", "file", "id", "impl", "tool", "www", "coll", "bel", "host", "link", "string", "ob"], "fis": ["fiss", " fris", "afis", "lils", "flils", "bos", "FIS", "FIs", "flis", "fIs", "bi", "afiss", "afos", "afIs", "fi", "fips", "Fis", "lris", " fIS", " fi", "fli", "fliss", "fils", " fips", "Fiss", "bis", "flris", "zIS", " fiss", "Fips", " fils", "fris", "Fos", "Fris", "liss", "flIs", "zips", "zris", "fIS", "lis", "flos", "biss"], "zis": ["Ziss", "zipits", "zeisa", " zbis", "zisa", "Zis", "zipois", "zipisi", " zi", "zenisi", "zenais", "zipais", "ezIS", "zisi", "ziss", "zeis", "Zais", "zipis", "qi", " ziss", " zisi", "zeIS", " zIS", "ezips", "zois", " zits", " zisa", "qiss", "zIS", "zi", "zenis", " zais", "qbis", "ezisa", "zits", "zenois", "qis", "zips", "zeips", "ezis", "zbis", "zipi", "zipiss", " zois", "zipbis", "Zits", "zais", " zips"], "entry": ["nt", "reader", "extra", "si", "archive", "session", "auto", "ries", "ident", "info", "se", "ge", "country", "ie", "rc", "match", "lc", "Entry", "part", "inner", "je", "sea", "zip", "r", "ace", "line", "e", "cell", "key", "la", "address", "fr", "row", "comment", "dc", "parse", "image", "cat", "feed", "inc", "or", "spec", "object", "sec", "next", "enter", "li", "pe", "in", "file", "index", "ry", "result", "obj", "record", "cel", "exp", "ent", "de", "element"], "count": ["offset", "name", "_", "current", "depth", "allow", "type", "load", "en", "counter", "ind", "log", "base", "add", "more", "check", "cache", "size", "part", "line", "val", "max", "buffer", "list", "Count", "i", "limit", "feed", "use", "child", "parent", "sum", "default", "number", "read", "code", "c", "file", "id", "index", "len", "skip", "length", "write", "start", "end"], "data": ["reader", "error", "batch", "body", "results", "p", "info", "load", "str", "zero", "shift", "cache", "text", "size", "bytes", "content", "d", "buffer", "i", "image", "block", "feed", "value", "read", "number", "raw", "empty", "code", "DATA", "a", "len", "message", "result", "dat", "input", "length", "area", "alpha", "string", "start", "buf"], "fos": ["efosh", "fol", "fosh", "zol", "dfosi", "foses", "zOS", "efoses", "frosh", "Fol", "FOS", "fOS", "efos", "dfosh", "froses", "fosi", "znos", "fnos", "dfoses", "fros", "flol", "flnos", "dfos", "frosi", "efosi", "Fos", "flOS", "flos", "zos", "Fnos"], "dest": ["prop", "const", "cdn", "loc", "sup", "later", "slice", "dev", "stream", "cont", "sync", "comb", "di", "die", "inner", "output", "txt", "img", "done", "zip", "trans", "writer", "coord", "dist", "temp", "std", "dc", "test", "style", "source", "wh", "outer", "exit", "sum", "default", "south", "wb", "transform", "src", "des", "Dest", "flash", "result", "target", "out", "dat", "home", "desc", "de", "end", "tmp", "rest"]}}
{"id1": "3806532", "id2": "823074", "code1": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"createNew": ["writeRemote", " createnew", "requestFile", "requestnew", "writeFile", "createRemote", "createnew", "requestNew", " createRemote", "writenew", " createFile", "createFile", "requestRemote", "writeNew"], "name": ["x", "connection", "ame", "ext", "data", "self", "type", "space", "base", "part", "time", "size", "domain", "content", "old", "alias", "e", "key", "address", "this", "source", "common", "value", "child", "request", "path", "parent", "filename", "url", "default", "names", "Name", "server", "n", "uri", "null", "code", "file", "id", "prefix", "word", "action", "resource", "host", "named", "none", "string", "NAME", "username"], "in": ["reader", "bin", "connection", "isin", "login", "f", "data", "type", "ins", "pin", "cin", "info", "min", "In", "inside", "conn", "part", "inner", "size", "win", "r", "work", "IN", "plus", "pull", " IN", "ini", "i", "source", "image", "inc", "path", "exec", "url", "config", "read", "pass", "thin", "id", "index", "len", "resource", "input", "record", "con", "diff"], "length": ["offset", "lock", "sequence", "type", "Length", "body", "info", "load", "timeout", "ength", "time", "size", "content", "capacity", "address", "buffer", "count", "padding", "limit", "path", "filename", "level", "width", "number", "duration", "id", "len", "string"], "contentType": ["ContentLength", "contentToken", " contentToken", "acceptToken", "acceptType", "ContentType", " contentLength", " contenttype", "contenttype", "Contenttype", "accepttype", "acceptLength", "ContentToken", "contentLength"], "dest": ["cdn", "trip", "data", "sup", "opt", "loc", "later", "down", " destination", "cont", "comb", "destroy", "gen", "proc", "output", "txt", "img", "done", "fn", "coord", "dist", "temp", "this", "dc", "d", "source", "ctx", "uc", "project", "path", "asc", "parent", " Dest", "cl", "default", "config", "store", "null", "route", "flat", "func", "folder", "wb", "up", "file", "src", "Dest", "resource", "target", "dir", "home", "de", "desc", "obj", "through", "tmp", "rest"], "out": ["ext", "data", "version", "channel", "pool", "outs", "loop", "b", "cmd", "err", "flow", "off", "o", "exec", "url", "null", "io", "exp", "point", "socket", "session", "log", "page", "conn", "cache", "output", "plus", "key", "client", "call", "init", "parent", "up", "home", "gin", "bit", "x", "job", "qa", "f", "one", "copy", "part", "all", "line", "writer", "temp", "lib", "image", "inc", "n", "raw", "Out", "obj", "connection", "bin", "extra", "array", "sync", "ex", "base", "again", "password", "OUT", "child", "v", "view", "pass", "file", "diff", "window"]}}
{"id1": "620855", "id2": "13207437", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public Object sendRequestObjectResponse(java.lang.String servletName, java.lang.String request) {\n        String osRoot = OSRoot.getRoot();\n        String fname = \"\";\n        Object retobj = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (myport == null || myport.trim().equals(\"\")) {\n            myport = \"80\";\n        }\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            try {\n                java.io.FileOutputStream pw = new java.io.FileOutputStream(\"log.txt\");\n                pw.write(req1xml.getBytes());\n                pw.flush();\n                pw.close();\n            } catch (Exception exp) {\n                exp.printStackTrace();\n            }\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.io.File f1 = new java.io.File(osRoot + \"/localattachments/Reports\");\n            if (!f1.exists()) f1.mkdirs();\n            java.io.File file = null;\n            if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"application/vnd.oasis.opendocument.text\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".odt\");\n            } else if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"text/html\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".html\");\n            } else {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".xls\");\n            }\n            file = new java.io.File(file.getAbsolutePath());\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(file);\n            int c;\n            while ((c = ios.read()) != -1) fos.write(c);\n            fos.close();\n            ios.close();\n            fname = file.getAbsolutePath();\n            System.out.println(fname);\n            newgen.presentation.component.Utility.getInstance().showBrowser(\"file://\" + fname);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n            javax.swing.JOptionPane.showMessageDialog(null, \"<html>Could not establish connection with the server, <br>Please verify server name/IP adress, <br>Also check if NewGenLib server is running</html>\", \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        }\n        return fname;\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doversioncheck", "doChangeCheck", "doVersionUpdate", " doVersionUpdate", " doversionScan", " doVersionScan", "doChangecheck", " doVersioncheck", "doFeaturecheck", "doFeatureUpdate", "doversionUpdate", "doChangeUpdate", " doversioncheck", "doFeatureScan", "doFeatureCheck", "doVersionScan", "doChangeScan", " doversionCheck", "doversionScan", "doVersioncheck", "doversionCheck", " doversionUpdate"], "view": ["lock", "self", "container", "edit", "pool", "div", "screen", "see", "review", "update", "out", "html", "gu", "session", "el", "page", "cache", "query", "display", "client", "row", "port", "value", "ui", "group", "up", "fail", "use", "widget", "View", "im", "vis", "model", "vol", "check", "by", "e", "cell", "this", "show", "style", "image", "form", "config", "http", "VIEW", "full", "layout", "manager", "head", "body", "change", "event", "base", "box", "video", "user", "can", "comment", "list", "block", "object", "v", "server", "index", "views", "sel", "input", "window", "ou", "ve", "link"], "url": ["ul", "open", "sl", "f", "loc", "name", "socket", "email", "gl", "stream", "web", "download", "log", "base", "ssl", "bb", "ls", "ll", "blog", "b", "loader", "zip", "l", "bug", "fr", "address", "Url", "buffer", "URL", "source", "image", "builder", "hub", "path", "server", "uri", "null", "browser", "http", "file", "impl", "id", "resource", "www", "host", "link", "location", "length", "rel", "string", "ob"], "in": ["reader", "isin", "sin", "login", "data", "doc", "socket", "s", "ins", "pin", "m", "stream", "cin", "In", "binary", "is", "b", "inner", "again", "rin", "win", "din", "IN", "err", "ini", "buffer", "source", "init", "inc", "nin", "bis", "inn", "file", "as", "lin", "resource", "input", "out", "con", "ac"], "bin": ["reader", "border", "lock", "sin", "login", "socket", "pin", "body", "cin", "bn", "vin", "binary", "bot", "is", "bb", "bi", "b", "loader", "inner", "win", "din", "IN", "ruby", "ini", "abi", "buffer", "lib", "run", "init", "spin", "arin", "ban", "browser", "inn", "oin", "file", "lin", "fin", "input", "out", "record", "con", "gin", "nb"], "line": ["job", "le", "sl", "data", "name", "type", "pin", "range", "el", "ge", "one", "str", "definition", "letter", "log", "base", "lc", "inline", "page", "b", "text", "part", "user", "zip", "l", "val", "e", "cell", "lines", "lf", "key", "ine", "comment", "row", "entry", "block", "parse", "Line", "object", "cl", "code", "nl", "unit", "pe", "jo", "file", "up", "id", "LINE", "word", "lin", "out", "link", "string", "write", "ip", "end", "look"], "version": ["feature", "ver", "name", "support", "type", "dev", "python", "versions", "install", "VERSION", "latest", "download", "release", "plugin", "position", "model", "format", "video", "user", "vert", "section", "bug", "patch", "vision", "pull", "secret", "image", "value", "project", "driver", "v", "update", "server", "unit", "date", "author", "null", "code", "Version", "id", "beta", "cover", "host", "string", "option", "device", "license"], "build": ["lock", "job", "ver", "tag", "get", "mount", "Build", "hold", "how", "building", "boot", "install", "info", "clean", "load", "lease", "release", "log", "add", "built", "bug", "work", "uild", "patch", "pull", "row", "show", "style", "image", "block", "run", "feed", "builder", "update", "unit", "make", "post", "http", "valid", "follow", "help", "home", "print", "link", "rel", "use"]}}
