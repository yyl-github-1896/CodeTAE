{"code": "\"\"\"Usage:\\n      pypy X.py < X-size.in > X-size.out\\n  or sometimes\\n      python X.py < X-size.in > X-size.out\\n  \"\"\"\\n  \\n  def setup(infile):\\n      return locals()\\n  \\n  def reader(testcase, infile, C=None, **ignore):\\n      P = map(int, infile.next().split())\\n      return locals()\\n  \\n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\\n  \\n      R, C, M = P\\n      MM = M\\n  \\n      F = np.array([['.'] * C] * R)\\n      while M > 0:\\n          if R >= C and M >= C and R > 2:\\n              M -= C\\n              R -= 1\\n              F[R] = '*'\\n          elif C > R  and M >= R and C > 2:\\n              M -= R\\n              C -= 1\\n              F[:, C] = '*'\\n          elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):\\n              if M < C - 1:\\n                  R -= 1\\n                  F[R, C - M:C] = '*'\\n              elif M < R - 1:\\n                  C -= 1\\n                  F[R - M:R, C] = '*'\\n              elif M == C - 1:\\n                  R -= 1\\n                  F[R, C - M + 1:C] = '*'\\n                  F[R - 1, C - 1] = '*'\\n              else:\\n                  C -= 1\\n                  F[R - M + 1:R, C] = '*'\\n                  F[R - 1, C - 1] = '*'\\n              M = 0\\n          elif M == R * C - 1:\\n              F[:, :] = '*'\\n              M = 0\\n          else:\\n              return 'Case #%s:\\n%s\\n' % (testcase, 'Impossible')\\n  \\n      F[0, 0] = 'c'\\n      assert (F == '*').sum() == MM\\n      return 'Case #%s:\\n%s\\n' % (testcase, '\\n'.join(''.join(f.tolist()) for f in F))\\n  \\n  if __name__ == '__main__':\\n      T = int(sys.stdin.next())\\n      common = setup(sys.stdin)\\n      for t in xrange(1, T+1):\\n          sys.stdout.write(solver(**reader(t, **common)))\\n", "substitutes": {"infile": ["INFILE", "INFile", "Incomplete", "incomplete", "outFile", "infilename", "infiles", " infiles", "Infiles", "outfilename", "outconfig", "incfiles", "inFILE", " inFile", "InFile", " incomplete", "Infilename", " infilename", "incFile", "outcomplete", "INfiles", "inputFile", "outfiles", "inconfig", "inputconfig", "INfile", "InFILE", "incFILE", "incfile", "Infile", " inconfig", "outfile", "inFile", "inputfile", "inputfiles"], "testcase": ["maincase", "testCase", "testcache", "Testcases", "Testcase", "Testfile", "testfile", "mainCase", "Testcache", " testCase", " testcache", "testingcases", "testingfile", " testcases", "testingcase", "maincases", " testfile", "maincache", "testcases", "TestCase"], "C": ["CC", "O", "SC", "CR", "A", "CS", "B", "Any", "Cs", "CI", "DC", "L", "CL", "Code", "CM", "AC", "X", "K", "Rec", "Sc", "c", "Ch", "GC", "CU", "E", "CN", "CNN", "VC", "D", "NC", "G", "EC", "MC", "r", "U", "Count", "Y", "CA", "Ca", "Cl", " c", "V", "H", "Co", "CP", "Chain", "Cu", "Size", "Mc", "Q", "Cor", "W", "CE"], "P": ["p", "O", "A", "PP", "PE", "PI", "B", "Po", "J", "L", "X", "K", "RP", "Ps", "AP", "E", "PO", "IP", "PF", "D", "G", "PT", "PA", "U", "Y", "PS", "V", "H", "CP", "PN", "Q", "W", "NP", "TP"], "N": ["p", "O", "A", "B", "Ns", "NN", "L", "X", "K", "E", "CN", "D", "G", "U", "Y", "V", "Q", "NS", "W", "n", "NT"], "I": ["HI", "p", "O", "PI", "B", "ID", "Is", "LI", "API", "CI", "AI", "J", "NI", "K", "E", "SI", "i", "IP", "IO", "MI", "Pi", "U", "Y", "IL", "V", "H", "Q", "TI"], "T": ["Z", "TT", "O", "TC", "WT", "B", "TA", "L", "X", "K", "TS", "E", "CT", "Total", "TN", "TH", "D", "G", "PT", "U", "Y", "V", "H", "Q", "W", "TF", "Time", "NT"], "S": ["SL", "SC", "A", "SO", "SE", "SP", "Sa", "SA", "SN", "SI", "G", "SK", "U", "PS", "Y", "V", "s", "Si", "Sl", "SU", "Q", "NS", "SR", "SH", "SS"], "R": ["File", "CC", "O", "A", "CR", "B", "Ra", "MR", "RA", "AR", "Line", "RE", "L", "RR", "J", "Run", "X", "RN", "K", "BR", "RP", "Gr", "ER", "RW", "Ch", "Rs", "E", "NR", "RH", "LR", "DR", "RO", "Group", "D", "G", "r", " r", "Rh", "Reader", "U", "Y", "GR", "RS", "V", "H", "RT", "Co", "RG", "CL", "Q", "Cor", "W", "SR", "RF", "Re", "RM", "RIP", "DC", "Range"], "M": ["O", "A", "LM", "MF", "MN", "AM", "B", "MR", "Ms", "m", "Rule", "J", "L", "RE", "MA", "CM", "TM", "X", "DM", "K", "Man", "Model", "IM", "Mor", "E", "SM", "D", "G", "MS", "OM", "MC", "OR", "MD", "r", "U", "Y", "V", "H", "MT", "Co", "MB", "Mc", "CL", "Q", "CH", "W", "Re", "RM"], "MM": ["CC", " mm", "_", "MF", "FC", "mm", "NN", "DC", "MP", "max", "X", "DD", "CNN", "MI", "D", "MC", "MB", "Mc", "W", "RM", "n", "FM"], "F": ["ULT", "File", "Z", "Test", "FE", "O", "CF", "DF", "FO", "A", "Do", "MF", "B", "FC", "API", "FF", "BF", "Line", "Fs", "Full", "FG", "L", "WF", "X", "K", "GF", "AP", "Base", "E", "FA", "FT", "PF", "G", "D", "AF", "IF", "Frame", "U", "Y", "Function", "V", "H", "Point", "Fixed", "FR", "Q", "Part", "W", "Form", "EF", "FM", "TF", "FD"], "Impossible": ["impant", "Operossible", "imporable", "Implable", "Implant", "impable", "Impant", "Implorable", "Operant", "Operorable", "Imporable", "impossible", "Operable", "Implossible", "Impable"], "f": ["ref", "p", "it", "fp", "all", "fast", "cf", "file", "m", "function", "d", "x", "h", "l", "fo", "found", "c", "fr", "fit", "e", "fl", "form", "i", "fc", "info", "fe", "fs", "w", "j", "fun", "v", "b", "flow", "n", "df"], "common": ["new", "all", "extra", "TC", "valid", "lc", "Common", "current", "basic", "name", "x", "L", "body", "record", "stack", "custom", "c", "data", "specific", "other", "rec", " Common", "shared", " tc", "white", "local", "tf", "check", "con", "standard", "union", " custom", "this", "ctx", "normal", "loc", "original", "test", "total", "tc"], "t": ["p", "td", "all", "TC", "col", "tp", "ts", "tif", "m", "time", "python", "d", "text", "x", "ind", "y", "c", "ti", "e", "temp", "tt", "i", "tf", "ta", "the", "nt", "g", "s", "b", "inter", "normal", "tm", "n", "int", "test", "total", "tc"]}}
{"code": "\"\"\"Usage:\\n      pypy X.py < X-size.in > X-size.out\\n  or sometimes\\n      python X.py < X-size.in > X-size.out\\n  \"\"\"\\n  \\n  def setup(infile):\\n      return locals()\\n  \\n  def reader(testcase, infile, C=None, **ignore):\\n      N = int(infile.next())\\n      I = [map(int, infile.next().split()) for i in range(4)]\\n      T = int(infile.next())\\n      S = [map(int, infile.next().split()) for i in range(4)]\\n      return locals()\\n  \\n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\\n  \\n      res = set(I[N-1]) & set(S[T-1])\\n      if len(res) == 1:\\n          res = res.pop()\\n      elif len(res) > 1:\\n          res = 'Bad magician!'\\n      else:\\n          res = 'Volunteer cheated!'\\n      return 'Case #%s: %s\\n' % (testcase, res)\\n  \\n  if __name__ == '__main__':\\n      T = int(sys.stdin.next())\\n      common = setup(sys.stdin)\\n      for t in xrange(1, T+1):\\n          sys.stdout.write(solver(**reader(t, **common)))\\n", "substitutes": {"infile": ["incmodel", "INFile", "incomplete", "outmodel", "infilename", "infiles", "insfolder", "ninfile", " inf", " infiles", "ninfilename", "Infiles", "inccomplete", "incfiles", "incfilename", " inFile", "outf", "InFile", "insfile", "insFile", " incomplete", "Infilename", " infilename", "incFile", "insfilename", "INfiles", "instream", "ninstream", "INcomplete", "ninFile", " instream", " infolder", "incstream", "INfolder", "outfiles", "INstream", "inmodel", "INfile", "Instream", "INfilename", "incfile", "Infile", "inf", "outfile", " inmodel", "inFile", "incf", "infolder", "incfolder"], "testcase": ["drivercase", "Testphase", " testline", "testtype", "valCase", "validcase", "valcases", "maincase", "testCase", "outcase", "Testcases", "Testcase", "testcases", "validtype", "driverline", "mainCase", "testconnection", " testtype", "testclass", "validclass", "valcase", "driverclass", " testCase", " testclass", "validline", "valphase", "outconnection", "Testconnection", " testcases", "testphase", " testphase", "outCase", "drivertype", "mainconnection", "testline", "TestCase"], "C": ["CC", "CG", "O", "SC", "CR", "R", "CF", "CS", "B", "Cs", "CI", "CL", "L", "CM", "F", "X", "K", "c", "GC", "E", "CT", "CN", "VC", "Cache", "D", "M", "G", "EC", "MC", "U", "Ca", "CA", "Cl", "V", "Case", "Cu", "W", "CV", "Con"], "N": ["O", "A", "NB", "R", "Len", "MN", "B", " n", "Ns", "No", "Ne", "J", "L", "NI", "F", "X", "RN", "E", "Num", "CN", "D", "M", "G", "U", "Y", "V", "H", "OS", "Q", "NS", "n", "NA", "Ni", "NT"], "I": ["HI", "RI", "O", "A", "R", "IX", "PI", "IU", "B", "IN", "LI", "API", "CI", "L", "NI", "F", "X", "IM", "E", "SI", "IP", "IO", "D", "M", "G", "MI", "Pi", "KI", "Info", "U", "Y", "Fi", "IL", "DI", "II", "V", "H", "Si", "W", "Xi", "TI"], "i": ["il", "p", "it", "o", "iq", "ui", "li", "id", "ci", "ai", "x", "ind", "l", "gi", "f", "ii", "c", "ti", "e", "xi", "di", "pi", "k", "im", "j", "b", "v", "ip", "qi", "si", "int", "iu"], "T": ["TG", "Z", "Test", "TT", "O", "R", "Length", "WT", "Type", "B", "TA", "LT", "CL", "L", "TB", "DT", "X", "F", "TS", "UT", "E", "CT", "Total", "TN", "TX", "TH", "Ti", "Ts", "D", "M", "G", "ET", "PT", "TPS", "Time", "U", "Y", "V", "OUT", "H", "Size", "W", "To", "TF", "Tu", "TO", "NT"], "S": ["SL", "SC", "O", "R", "A", "CS", "B", "SO", "SE", "SP", "Sa", "L", "F", "SA", "SN", "Ps", "TS", "SI", "IS", "G", "M", "U", "PS", "Y", "RS", "V", "LS", "s", "Si", "Sl", "AS", "SU", "NS", "SR", "SH", "SS"], "P": ["p", "O", "A", "R", "PI", "B", "Type", "J", "L", "F", "X", "K", "Ps", "Path", "E", "IP", "G", "M", "D", "PT", "U", "Y", "V", "H", "PN", "Q", "W", "NP"], "res": ["err", "response", "R", "resources", "resh", "vals", "case", "resp", "relations", "rest", "our", "details", "mr", "RE", "resolution", "msg", "rss", "cr", "req", "right", "core", "RES", "pres", "Rs", "reset", "reason", "rec", "rev", "ret", "rem", "rus", "key", "ress", "repl", "os", "reed", "pre", "rr", "obj", "rel", "ps", "rh", "r", "rez", "vers", "reg", "RS", "Result", "re", "s", "Results", "ms", "rap", "pr", "content", "rm", "Res", "remote", "resource", "ros", "rs", "result", "cs", "error", "ras", "results", "rep"], "common": ["new", "extra", "TC", "valid", "lc", "Common", "name", "m", "norm", "x", "special", "body", "central", "F", "f", "record", "custom", "c", "data", "regular", "specific", "other", "util", "final", "temp", "rec", " Common", "known", "shared", "info", "set", "con", "standard", "general", "normal", "ctx", "complete", "total", "loc", "resource", "test", "local", "tc"], "t": ["p", "o", "latest", "tim", "tr", "tp", "ts", "m", "time", "d", "x", "out", "ind", "l", "y", "f", "c", "e", "temp", "tt", "tf", "nt", "type", "r", "a", "g", "s", "b", "normal", "tm", "n", "int", "test", "total", "tc"]}}
{"code": " def solve():\\n      h, w, m = map(int, raw_input().split())\\n      if h == 1:\\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\\n      elif w == 1:\\n          for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\\n              print c\\n      elif h * w - m == 1:\\n          print 'c' + '*' * (w - 1)\\n          for _ in xrange(h-1):\\n              print '*' * w\\n      else:\\n          m = h * w - m\\n          for i in xrange(h-1):\\n              for j in xrange(w-1):\\n                  t = (i + 2) * 2 + (j + 2) * 2 - 4\\n                  r = (i + 2) * (j + 2)\\n                  if t <= m <= r:\\n                      a = [['*'] * w for _ in xrange(h)]\\n                      for k in xrange(i+2):\\n                          a[k][0] = '.'\\n                          a[k][1] = '.'\\n                      for k in xrange(j+2):\\n                          a[0][k] = '.'\\n                          a[1][k] = '.'\\n                      for y, x in product(range(2, i+2), range(2, j+2)):\\n                          if y == 1 and x == 1:\\n                              continue\\n                          if t >= m:\\n                              break\\n                          a[y][x] = '.'\\n                          t += 1\\n                      a[0][0] = 'c'\\n                      for s in a:\\n                          print ''.join(s)\\n                      return\\n          print 'Impossible'\\n  for t in xrange(int(raw_input())):\\n      print \"Case #%d:\" % (t + 1)\\n      solve()\\n", "substitutes": {"h": ["p", "o", "ph", "ch", "q", "time", "d", "l", "f", "ah", "bh", "e", "sh", "hm", "z", "rh", "wa", "hs", "g", "H", "ht", "hi", "b", "v", "th", "u", "oh", "n", "ih"], "w": ["p", "o", "ww", "wt", "ws", "ow", "hw", "sw", "q", "width", "we", "wan", "d", "wave", "max", "l", "f", "wx", "wal", "kw", "e", "sh", "wall", "win", "ew", "z", "aw", "wh", "wa", "g", "wb", "work", "b", "v", "u", "W", "wl", "n", "word", "wd"], "m": ["p", "o", "mo", "ma", "mu", "mm", "range", "q", "sm", "mr", "d", "am", "l", "f", "ym", "e", "md", "M", "z", "hm", "cm", "g", "mi", "b", "v", "u", "om", "tm", "W", "n", "mc"], "c": ["cu", "p", "all", "div", "ch", "cc", "unc", "col", "cf", "lc", "dc", "nc", "d", "l", "f", "cr", "e", "code", "fc", "z", "cm", "mac", "co", "g", "C", "b", "n", "cs", "ct", "mc", "ac"], "_": ["p", "all", "of", "l", "f", "__", "block"], "i": ["p", "it", "o", "ui", "li", "id", "ci", "q", "ini", "d", "ai", "l", "f", "I", "ii", "e", "yi", "ie", "pi", "xi", "z", "ni", "im", "hi", "b", "v", "u", "ip", "iw", "n", "si", "ih", "int", "iu", "io"], "j": ["p", "o", "li", "py", "js", "jc", "q", "jp", "ji", "d", "J", "l", "f", "ii", "e", "jl", "sh", "z", "jj", "ja", "g", "ij", "im", "b", "v", "jo", "u", "jet", "n"], "t": ["p", "o", "it", "offset", " T", "tr", "at", "q", "T", "ts", "time", "ot", "d", "dt", "lit", "l", "f", "e", "temp", "tt", "trial", "ta", "z", "tu", "nt", "type", "g", "mt", "b", "v", "pt", "u", "tick", "n", "test", "int", "total", "ct"], "r": ["p", "o", " R", "R", "br", "tr", "range", "q", "ar", "d", "l", "f", "right", "nr", "e", "z", "rt", "g", "re", "b", "sr", "v", "u", "n", "rs", "er"], "a": ["p", "o", "A", "ma", "array", "la", "aaa", "at", "za", "aa", "ar", "ae", "sa", "au", "d", "am", "l", "f", "alpha", "area", "fa", "e", "code", "va", "ha", "ata", "ba", "ta", "ga", "z", "ad", "auto", "ab", "b", "v", "u", "ana", "ca", "n", "an", "sta", "ac"], "k": ["p", "o", "kn", "id", "ch", "ki", "ko", "q", "d", "ku", "f", "K", "kw", "sk", "e", "key", "ck", "ak", "ik", "ky", "z", "ok", "ka", "ks", "g", "work", "b", "kk", "u", "n", "km", "ke"], "y": ["p", "o", "py", "ch", "sy", "yx", "q", "ye", "ay", "d", "ny", "ya", "dy", "yo", "vy", "yt", "ym", "e", "yi", "yd", "z", "Y", "yl", "ey", "yn", "xy", "v", "zy", "my", "u", "oy", "n", "yy", "yr", "cy"], "x": ["p", "o", "dx", "ww", "ix", "ax", "xxx", "yx", "index", "wy", "q", "d", "ya", "dy", "l", "X", "wx", "ex", "xt", "e", "mx", "px", "xi", "xe", "z", "xs", "xc", "rx", "xy", "v", "xp", "u", "xx", "n", "xb", "tx"], "s": ["p", "o", "new", "ch", "S", "ss", "st", "sb", "states", "params", "sa", "d", "space", "span", "strings", "l", "f", "str", "e", "sets", "ses", "series", "z", "sections", "services", "parts", "ks", "g", "b", "v", "storage", "string", "n", "si"]}}
{"code": "def solve():\\n      r1 = int(raw_input())\\n      a1 = [map(int, raw_input().split()) for i in xrange(4)]\\n      r2 = int(raw_input())\\n      a2 = [map(int, raw_input().split()) for i in xrange(4)]\\n      ans = -1\\n      for i in xrange(1, 17):\\n          if i in a1[r1-1] and i in a2[r2-1]:\\n              if ans != -1:\\n                  return \"Bad magician!\"\\n              ans = i\\n      if ans == -1:\\n          return \"Volunteer cheated!\"\\n      return ans\\n  for t in xrange(int(raw_input())):\\n      print \"Case #%d:\" % (t + 1), solve()\\n", "substitutes": {"r1": [" r3", "r3", "aOne", "rr1", "a31", "rr3", "rOne", "r31", "rrOne", " r31", "rg31", " rOne", "rg1", "rg3", "rg2", "a3"], "a1": ["alpha8", "a8", "p1", "pone", " a11", " a8", "r11", "sa3", "p2", "aone", "alpha3", "alpha11", "saone", "alphaone", "alpha2", "r8", "sa1", "sa2", "a3", "p3", "alpha1", "a11"], "i": ["p", "it", "iq", "chi", "li", "id", "ci", "at", "ei", "ar", "m", "ini", "d", "ai", "multi", "x", "bi", "ind", "l", " I", "f", "I", "ii", "c", "ti", "e", "ir", "anti", "ie", "xi", "pi", "z", "r", "ic", "ni", "a", "g", "im", "j", " pi", "s", "v", "inter", "ip", "u", "iw", "n", "si", "int", "io", "iu", "ati", "ih"], "r2": ["ar8", "r4", "rbot", "ar2", "rtbot", " r4", " r8", "rttwo", "rt2", "rc4", "ar02", "arbot", "rc02", "ar4", " r02", "r8", "rtwo", "v02", "vbot", "vtwo", "r02", "v2", "artwo", "rt02", "rc8", "rc2"], "a2": ["antwo", "A6", "a4", "A4", "A2", "a5", "an4", "atwo", "Atwo", "an5", "alphatwo", " a6", "an2", " a5", "a6", "alpha2", " a4", "alpha4", "an6", "A5"], "ans": ["ons", "A", "all", "case", "ds", "ins", "lan", " scans", "faces", "atan", "ends", "os", "ants", "ks", "annels", "anes", "ines", "ats", "ed", "cs", "aces", "les", "arts", "id", "amps", "ss", "ations", "ents", "ace", "ant", "ays", "rules", "can", "ens", "AN", "anned", "aned", "ANS", "ees", "anks", "idents", "ane", "An", "na", "man", "anas", "span", "false", "scan", "cons", " means", "ases", "a", "ars", "ana", "an", "ones", "anges", "aus", "ns", "ores", "ams", "x", "ann", "ions", "anc", "s", "olds"], "t": ["p", "o", "art", "id", "at", "q", "ar", "T", "m", "ts", "d", "x", "h", "l", "y", "f", "c", "e", "ta", "z", "r", "type", "a", "w", "g", "j", "s", "b", "v", "pt", "u", "n", "int", "an", "test"]}}
{"code": " \\n  def makeBoardR(b):\\n  \tnumR, numC, numMines, filledR, filledC = b\\n  \tq = numMines / numR\\n  \tr = numMines % numR\\n  \\n  \tif q <= numC-2 and r == 0:\\n  \t\tboard = [\"*\"*(filledC + numC) for x in range (filledR)]\\n  \t\tboard.append( \"*\"*(filledC+q)+\".\"*(numC-q) )\\n  \t\tboard.append( \"*\"*(filledC+q)+\".\"*(numC-q-1)+\"c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telif numMines == numR * numC - 1:\\n  \t\tboard = [\"*\"*(filledC + numC) for x in range (filledR+1)]\\n  \t\tboard.append( \"*\"*(filledC+numC-1)+\"c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telse:\\n  \t\toutput = \"Impossible\"\\n  \\n  \treturn output\\n  \\n  def makeBoardC(b):\\n  \tnumR, numC, numMines, filledR, filledC = b\\n  \tq = numMines / numC\\n  \tr = numMines % numC\\n  \\n  \tif q <= numR-2 and r == 0:\\n  \t\tboard = [\"*\"*(filledC+numC) for x in range(filledR+q)]\\n  \t\tfor x in range( numR-1-q ):\\n  \t\t\tboard.append( \"*\"*filledC + \"..\" )\\n  \t\tboard.append( \"*\"*filledC + \".c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telif numMines == numR * numC - 1:\\n  \t\tboard = [\"*\"*(filledC+numC) for x in range(filledR+numR-1)]\\n  \t\tboard.append( \"*\"*(filledC+numC-1) + \"c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telse:\\n  \t\toutput = \"Impossible\"\\n  \treturn output\\n  \\n  def makeBoard(b):\\n  \tnumR, numC, numMines, filledR, filledC = b\\n  \tq = numMines / (numC-2)\\n  \tr = numMines % (numC-2)\\n  \\n  \tboard = [\"*\"*(numC+filledC) for x in range(filledR)]\\n  \tfor x in range(q):\\n  \t\tboard.append( \"*\"*(numC-2+filledC)+\"..\" )\\n  \tboard.append( \"*\"*(r+filledC)+\".\"*(numC-r) )\\n  \tfor x in range(numR-q-2):\\n  \t\tboard.append( \"*\"*filledC+\".\"*numC )\\n  \tboard.append( \"*\"*filledC + \".\"*(numC-1) + \"c\" )\\n  \treturn \"\\n\".join(board)\\n  \\n  def makeBoard0(b):\\n  \tnumR,numC,numMines,filledR,filledC = b\\n  \tboard = [\"*\"*(numC+filledC) for x in range(filledR)]\\n  \tfor x in range(numR-1):\\n  \t\tboard.append( \"*\"*(filledC)+\".\"*numC )\\n  \tboard.append( \"*\"*(filledC) + \".\"*(numC-1) + \"c\" )\\n  \treturn \"\\n\".join(board)\\n  \\n  f = open( sys.argv[1] )\\n  f.readline()\\n  \\n  numCase = 1\\n  l = f.readline()\\n  while l != \"\":\\n  \tnumR, numC, numMines = [int(x) for x in l.split()]\\n  \\n  \tboards = deque()\\n  \tif numR == 1:\\n  \t\tif numC == 1 and numMines == 0:\\n  \t\t\toutput = \"c\"\\n  \t\telif numC == 1 and numMines > 0:\\n  \t\t\toutput = \"Impossible\"\\n  \t\telse:\\n  \t\t\toutput = \"*\"*numMines + \".\"*(numC-numMines-1) + \"c\"\\n  \telif numC == 1:\\n  \t\toutput = \"\\n\".join(\"*\"*numMines + \".\"*(numR-numMines-1) + \"c\")\\n  \telse:\\n  \t\tboards.append( (numR,numC,numMines,0,0) )\\n  \t\toutput = \"Impossible\"\\n  \\n  \twhile output == \"Impossible\" and len(boards) > 0:\\n  \t\tb = boards.popleft()\\n  \t\tnumR,numC,numMines,filledR,filledC = b\\n  \t\tif numMines == 0:\\n  \t\t\toutput = makeBoard0(b)\\n  \t\t\tbreak\\n  \\n  \t\tif numMines >= numC and numR > 2:\\n  \t\t\tboards.append( (numR-1,numC,numMines-numC,filledR+1,filledC) )\\n  \t\tif numMines >= numR and numC > 2:\\n  \t\t\tboards.append( (numR,numC-1,numMines-numR,filledR,filledC+1) )\\n  \\n  \t\tif numMines <= (numR-2)*(numC-2):\\n  \t\t\toutput = makeBoard(b)\\n  \\n  \t\tif numR == 2:\\n  \t\t\toutput = makeBoardR(b)\\n  \\n  \t\tif numC == 2:\\n  \t\t\toutput = makeBoardC(b)\\n  \t\t\\n  \tprint \"Case #\"+str(numCase)+\":\\n\"+output\\n  \tl = f.readline()\\n  \tnumCase += 1\\n", "substitutes": {"b": ["bis", "p", "pb", "o", "br", "rb", "B", "gb", "db", "app", "lb", "sb", "m", "nb", "d", "mb", "pa", "body", "base", "h", "http", "ob", "amb", "lab", "y", "c", "fb", "t", "lib", "bp", "book", "back", "i", "bs", "obj", "bas", "k", "hub", "abs", "bb", "bf", "a", "cb", "ab", "wb", "bc", "object", "ib", "this", "v", "bar", "root", "bub", "j", "bl", "boot", "n", "bd", "home"], "numR": ["umN", " numN", " numD", "nomR", "nbRs", "widthC", "nbr", "NumRs", "nM", "sumN", "monC", " numP", "numr", "NumD", "monX", "monL", "numL", "monP", "nL", "umC", "nomD", "numX", "umRs", "NumRec", "nomRec", "widthr", "umr", " numRec", "NUMX", "NUMR", "widthR", "numRec", "NumP", " numL", "numM", "sumM", "sumr", "numD", "NumM", "NUMP", "NUMM", "NumN", "nP", "NumR", "nomM", " numX", "numP", "monR", "nbC", " numr", "NumL", " numRs", "numRs", "nomL", "nR", "monM", "nC", "nbR", "umL", "NumC", "nr", "umM", "sumC", "sumL", " numM", "numN", "widthM", "nomC", "sumR", "umR"], "numC": ["umN", "nuCS", " numN", " numD", "domc", "NumU", "nT", "domR", "numU", "namS", "numberCs", "nomc", "NUMc", "umS", "NUMT", "numCC", "namc", " numCor", "namN", "nuN", "numCS", " numP", "multiT", "NumD", "numS", "numL", "normS", "umiR", "numberC", "NumT", "numberc", "numberCor", "nL", "umC", "umiCM", "numberCC", "multiD", "nomD", "nc", "numCor", "nN", "multiL", "sumCs", "numE", "namC", "umCC", "NUMR", "nuP", "numberD", "NumP", " numL", "domE", "nD", "umD", "numM", "normR", "umic", "sumc", "numD", "NumM", "numCs", "numberR", "nuC", "NUMM", "Numc", "NumN", "homR", "nP", "NumR", "nE", "numberCM", "normC", " numc", "multiC", "sumCM", "numCM", "NumCor", "numP", "NumL", "domCC", "NUMN", "umE", " numT", "multiP", "NUMC", "numT", "domC", "nomU", "nR", "nC", "homc", "namR", "umc", "multic", "umL", "numberN", "homC", "NumC", "sumC", "numc", "NumCS", "sumE", " numU", "domCs", " numM", "NUML", "umiC", "normc", "NumE", "numN", "NUMD", "nomC", "sumR", "nCS", "umR", " numE"], "numMines": ["numTined", "homMinations", "NumCakes", "numNains", "numMakes", "numGine", "numCains", "nbmians", "numPanes", "numMsakes", " numMiddles", "nMine", "numGinks", "numCizes", "nGains", "numPine", "numGines", "numMipes", " numPines", "numGimes", "umiDemines", " numGined", "numMsiques", "numPipes", "numTains", "numMins", "numLined", " numNakes", "nGines", "numCined", " numPipes", " numPiddles", "numCakes", "nbmines", "numGides", " numGinks", "numPiddles", "nbMined", " numNins", " numMides", "umiMines", "nbMians", "numMachipes", "numDiddles", "numNins", " numGimes", "numGined", "numLines", "numMides", "homMizes", "numDemine", "numTiques", "numMians", "numNiques", "nbMizes", "NumCines", "umiDeminers", "numCMizes", "numManes", "nummains", "numLine", "numParks", "homCodes", "NumMides", "NumMines", "umiDemine", " numGides", "numTins", "homMines", "numDeminers", "numMarks", "numDipes", "numDanes", " numMakes", "numGians", "numNinks", "numGizes", " numMipes", " numMined", " numTined", " numManes", " numMimes", "numCMinations", "numDemarks", "numMimes", "numMiddles", "nbmizes", "nMined", "nGine", "numNides", "numTakes", "NumCains", "homModes", "numMinations", "numDined", "nbmined", "umiMarks", "numCiners", " numNiques", "numNakes", "umiMiners", "numMiques", " numMiners", "umiMine", "numCMines", "nummines", "homCinations", "numminers", "NumCides", "homCizes", "numGiners", " numMains", " numGines", " numTains", "numLains", "numTines", " numMins", "numCinations", "nMains", "numRines", "numRodes", "numNined", "numMine", "numMiners", "nbMines", "numModes", "numLakes", " numMiques", "numCModes", "nummined", "nummizes", "NumMakes", "numDemines", "numGains", "nMines", "numMizes", "numCine", "numMined", "numMachines", " numPanes", "numDimes", "numGakes", " numMizes", " numTakes", "nummians", " numTines", " numGiners", "numMsins", "numCines", "numMsines", " numNines", "NumMains", "numMains", " numGizes", "numMinks", " numGains", "homCines", " numMinks", "numCides", "numDizes", "numCians", "numMachanes", "nGined", "umiDemarks", "numNines", "numRinations", "numRizes", "nummimes", "numMachiddles", "numDines", "numPiners", "numCodes", "numPines"], "filledR": ["loadedr", "signedr", "selectedDR", "filledRun", "finishedC", "drawnDR", "printedLine", "signedLine", "playedRR", "selectedRs", "publishedR", "filledK", "printedRs", "finishedD", "finishedGr", "finishedRR", "selectedC", "filledLine", "loadedQ", " filledQ", "printedK", "publishedJ", "finishedRe", "playedL", "finishedK", "filledr", "printedRe", "signedRe", "filledJ", "filledGr", "printedr", "filledP", "loadedD", "loadedRs", "selectedL", "drawnC", "publishedGr", "finishedRun", "filledAt", "loadedRR", "selectedQ", "loadedAt", "filledRe", "printedJ", "finishedJ", "finishedR", "numP", "printedP", "publishedRun", "filledRs", "playedR", "loadedR", "finishedLine", "loadedC", "filledD", "loadedL", "filledL", "printedR", "filledDR", " filledr", "printedRun", " filledRR", "finishedP", " filledAt", "finishedr", "printedC", "filledQ", "playedAt", "filledRR", " filledL", "numK", "drawnR", "loadedDR", "selectedr", " filledD", "printedGr", "signedR", "selectedR"], "filledC": ["focusedCl", "wonCL", "keptCode", " filledCh", "shownMC", "ippedCT", "keptc", "placedC", " filledCl", "focusedD", " filledc", "paintedCL", "paintedM", "filledCh", "loadedB", "drawnCustom", "loadedCS", "focusedC", "paintedCs", "loadedCustom", "filledCI", "illedC", " filledCT", "illedCh", "loadedCM", " filledMC", "wonC", "wonR", " filledCAR", "focusedR", "loadedNC", "ippedS", "hedc", "paintedS", "hedC", "filledSc", "filledN", "filledCs", " filledCI", "filledCM", "filledFrom", "printedB", " filledFrom", "packedc", "focusedB", "filledCl", "numE", "illedN", "focusedCA", "loadedD", "foundCS", "drawnNC", "foundR", "filledCA", "paintedSc", "loadedc", " filledE", "drawnC", "placedc", "keptC", "filledCustom", "loadedCT", "builtS", "loadedCh", "loadedCAR", "paintedCM", " filledNC", "filledB", "shownCI", "wonS", "hedCode", "filledCS", "paintedR", "paintedc", "paintedC", "filledM", "printedD", "packedR", "shownR", "paintedCA", "hedR", "packedC", "filledNC", "keptR", "builtR", "paintedFrom", "filledCode", "filledc", "builtCL", "ippedR", " filledN", "loadedR", "loadedC", "filledD", "filledCAR", "loadedN", "printedR", "builtC", " filledCM", "loadedSc", "packedSc", "placedR", "paintedCS", "filledS", "loadedS", "filledCT", "illedCAR", "paintedCl", " filledCustom", "numc", "illedR", " filledM", "loadedM", "shownC", "loadedFrom", "loadedCs", "packedE", "printedC", " filledS", "loadedMC", "foundC", "filledCL", "filledE", "drawnR", "placedCs", "filledMC", " filledCA", "loadedCI", "ippedC", "numCode"], "q": ["p", "depth", "iq", "needed", "qu", "qq", "query", "sq", "id", "ix", "ch", "qa", "requ", "qs", "ail", "m", "que", "qual", "ai", "d", "h", "max", "y", "am", "dq", "count", "c", "quant", "req", "eq", "t", "charge", "sh", "back", "ak", "ur", "i", "ck", "ce", "ue", "k", "z", "kg", "w", "g", "quest", "cl", "j", "row", "ill", "v", "load", "s", "u", "Q", "qi", "one", "n", "int", "quality", "qt", "ac"], "r": ["err", "p", "o", "rb", "R", "tr", "range", "rc", "ar", "m", "order", "d", "kr", "rf", "h", "y", "ru", "cr", "rd", "c", "nr", "arr", "right", "e", "ir", "t", "ur", "i", "rr", "k", "rh", "rt", "z", "rg", "w", "g", "s", "v", "re", "sr", "u", "pr", "n", "rs", "er", "asc", "pc"], "board": ["stroke", "lay", "image", "node", "case", "list", "holder", "layout", "document", "player", "uc", "code", "ward", "pod", "stone", "draw", "wheel", "control", "ban", "device", "panel", "bug", "clean", "detail", "cross", "home", "ui", "comment", "hold", "screen", "view", "menu", "lock", "ack", "back", "wall", "hole", "Board", "video", "poll", "object", "flow", "court", "progress", "layer", "bit", "pool", "craft", "boarding", "function", "que", "flo", "client", "bo", " row", "ck", "post", "cell", "cart", "input", "phone", "work", "row", "sync", "error", "word", "coll", "box", " game", " clipboard", "deck", "channel", "loop", "road", "batch", "cache", "game", "che", "round", "model", "design", "bank", "block", "feed", " dashboard", "lane"], "x": ["p", "_", "bit", "qu", "val", "id", "ix", "full", "ax", "col", "xf", "index", "na", "yx", "m", "fx", "lex", "xt", "ex", "y", "X", "h", "ux", "wx", "max", "code", "t", "xes", "xi", "xe", "k", "z", "nex", "xc", "rx", "yl", "w", "co", "work", "cl", "g", "xy", "v", "xp", "ctx", "my", "xx", "sex", "n", "ct"], "output": ["response", "image", "unit", "outer", "document", "dt", "struct", "dot", "position", "lib", "cut", "display", "debug", "pre", "benefit", "control", "job", "future", "toc", "generation", "operation", "come", "page", "detail", "export", "version", "console", "product", "external", "out", "edit", "module", "summary", "ort", "object", "flow", "number", "resource", "progress", "ut", "result", "layer", "config", "function", "environment", "fore", "update", "respond", "component", "input", "production", "section", "net", "word", "application", "run", "current", "write", "target", "don", "PUT", "cache", "round", "Output", "pot", "exit", "design", "put", "complete", "ilo", "ou"]}}
{"code": " \\n  if __name__ == \"__main__\":\\n  \tf = open( sys.argv[1] )\\n  \tint(f.readline())\\n  \t\t\\n  \tnum = 1\\n  \tl = f.readline()\\n  \twhile l != \"\":\\n  \t\trow1 = int(l)\\n  \t\trows = [ f.readline() for x in range(4) ]\\n  \t\trow1 = [int(x) for x in rows[row1-1].split()]\\n  \\n  \t\trow2 = int(f.readline())\\n  \t\trows = [f.readline() for x in range(4)]\\n  \t\trow2 = [int(x) for x in rows[row2-1].split()]\\n  \\n  \t\tresult = set(row1) & set(row2)\\n  \t\tif len(result) == 1:\\n  \t\t\toutput = str(result.pop())\\n  \t\telif len(result) > 1:\\n  \t\t\toutput = \"Bad magician!\"\\n  \t\telse:\\n  \t\t\toutput = \"Volunteer cheated!\"\\n  \\n  \t\tprint \"Case #\"+str(num)+\": \"+output\\n  \t\tnum += 1\\n  \t\tl = f.readline()\\n  \t\t\\n", "substitutes": {"f": ["iter", "p", "o", "fp", "lf", "fast", "full", "of", "fm", "file", "m", "function", "d", "fx", "rf", "h", "F", "fo", "http", "y", "found", "c", "fr", "fd", "e", "fb", "t", "form", "api", "i", "fw", "fc", "tf", "z", "handler", "r", "bf", "fs", "w", "g", "s", "v", "b", "u", "sf", "feed", "fen", "n", "inf", "df", "folder", "ff", "af"], "num": ["nu", "node", "unit", "div", "id", "dom", "col", "index", " n", "du", "nm", "m", "nb", "name", "norm", "np", "nn", "loop", " nu", "d", "un", "am", "coord", "fn", "counter", "multi", "msg", "c", "thread", "Num", "temp", "no", " NUM", "final", "form", "i", "status", "um", "note", "nom", "umi", "con", "uni", "size", "uno", "mon", "sum", "union", "row", "number", "dim", "u", " number", "NUM", "n", "test"], "l": ["il", "p", "o", "la", "li", "ls", "lines", "lin", "lc", "col", "len", "lb", "m", "ll", "L", "y", "ul", "rl", "dL", "c", "e", "lv", "t", "ln", "fl", "i", "el", "nl", "r", "kl", "url", "dl", "g", "cl", "left", "lp", "s", "b", "ol", "v", "line", "u", "loc", "wl", "lr", "n", "sl", "lo"], "row1": ["lineOne", "row3", "rowOne", "cell1", "rows3", "cell5", "ow5", "ow4", "rowsone", "line3", "row5", "rows5", "ow1", "Row1", "raw1", "cell2", "line71", " rowOne", "rows1", "rawone", "row4", "rows2", "ow2", "owOne", "row71", " rowone", "raw3", "rowone", "ow71", "rows4", "line1", "cell4", " row3", " row71", "ow3", "Row2", "Row3"], "rows": ["rown", "rooms", "features", "array", "all", "files", "forms", "runs", "lines", "reports", "relations", "ss", "anges", "users", "errors", "ips", "opens", "multi", "works", "es", "strings", "fields", "raw", "reads", "locks", "breaks", "items", "flows", "views", "xes", "values", "ends", "ions", "ows", "frames", "rules", "sections", "holes", "blocks", "ks", "groups", "row", "orders", "s", "cells", "balls", "heads", "planes", "feed", "tracks", "shows", "rs", "results", "rings", "olds", "pages"], "x": ["p", "ph", "_", "id", "ci", "ix", "ax", "col", "xf", "index", "plex", "m", "time", "d", "lex", "ct", "ya", "xt", "ex", "xa", "X", "wx", "ux", "y", "h", "c", "e", "code", "t", "xes", "out", "i", "oint", "xi", "xe", "k", "z", "r", "xs", "xc", "rx", "w", "work", "ross", "row", "xy", "v", "b", "xp", "u", "on", "loc", "xx", "sex", "n", "xb", "int", "word", "max"], "row2": [" rowTwo", "key4", "ow62", "row0", "line2", "cellTwo", "view2", "pageTwo", "rowsecond", "owTwo", "viewsecond", "key2", "rowtwo", "keytwo", "line62", "pagetwo", "cell0", "blocksecond", "cell2", " row62", "block2", "line0", "blocktwo", "row4", "ow2", "viewTwo", "pagesecond", " rowsecond", "rowTwo", "lineTwo", "page2", "viewtwo", " row4", "block4", " rowtwo", "row62", "blockTwo", " row0", "keysecond"], "result": ["err", "desc", "response", "array", "new", "comment", "res", "case", "list", "valid", "group", "score", "range", "pair", "report", "db", "entry", "current", "order", "feature", "success", "record", "search", "default", "data", "answer", "table", "final", "ret", "json", "status", "dict", "ner", "r", "match", "value", "rate", "df", "runner", "Result", "row", "sum", "term", "server", "model", "diff", "line", "root", "page", "test", "error", "section", "results", "source"], "output": ["format", "o", "response", "four", "new", "unit", "outer", "export", "expression", "run", "document", "version", "log", "current", "file", "console", "null", "example", "text", "success", "double", "write", "out", "next", "message", "cut", "ln", "display", "debug", "job", "Output", "input", "value", "summary", "exit", "length", "line", "operation", "number", "generation", "put", "production", "string", "resource", "page", "n", "byte"]}}
{"code": "t = int(raw_input())\\n  \\n  for case in range(t):\\n  \tprint 'Case #'+str(case+1)+':'\\n  \tr, c, m = raw_input().split()\\n  \tr = int(r)\\n  \tc = int(c)\\n  \tm = int(m)\\n  \\n  \tif m==0:\\n  \t\tprint 'c' + ('.'*(c-1))\\n  \t\tfor i in range(r-1):\\n  \t\t\tprint '.'*c\\n  \telif r == 1:\\n  \t\tprint 'c'+('.'*(c-m-1))+('*'*(m))\\n  \telif c == 1:\\n  \t\tprint 'c'\\n  \t\tfor i in range(r-m-1):\\n  \t\t\tprint '.'\\n  \t\tfor i in range(m):\\n  \t\t\tprint '*'\\n  \telif r == 2:\\n  \t\tif m%2==0 and c>2 and m<r*c-2:\\n  \t\t\tprint 'c'+('.'*(c-m/2-1))+('*'*(m/2))\\n  \t\t\tprint ('.'*(c-m/2))+('*'*(m/2))\\n  \t\telif m == r*c - 1:\\n  \t\t\tprint 'c'+('*'*(c-1))\\n  \t\t\tprint '*'*c\\n  \t\telse:\\n  \t\t\tprint 'Impossible'\\n  \telif c == 2:\\n  \t\tif m%2==0 and r>2 and m<r*c-2:\\n  \t\t\tprint 'c.'\\n  \t\t\tfor i in range(r-m/2-1):\\n  \t\t\t\tprint '..'\\n  \t\t\tfor i in range(m/2):\\n  \t\t\t\tprint '**'\\n  \t\telif m == r*c - 1:\\n  \t\t\tprint 'c*'\\n  \t\t\tfor i in range(r-1):\\n  \t\t\t\tprint '**'\\n  \t\telse:\\n  \t\t\tprint 'Impossible'\\n  \telif c == 3 and r == 3:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\telif m == 6:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 7:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c**'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \telif c == 3 and r == 4:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 5:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 9:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c**'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \telif c == 3 and r == 5:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 8:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 12:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c**'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \telif c == 4 and r == 3:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\telif m == 5:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\telif m == 7:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c***'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \telif c == 4 and r == 4:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '..**'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 11:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 15:\\n  \t\t\tprint 'c***'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \telif c == 4 and r == 5:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 15:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 16:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 17:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 18:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 19:\\n  \t\t\tprint 'c***'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \telif c == 5 and r == 3:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '...**'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '..***'\\n  \t\telif m == 8:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \telif c == 5 and r == 4:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '..***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 15:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 16:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 17:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 18:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 19:\\n  \t\t\tprint 'c****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \telif c == 5 and r == 5:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '*****'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 13:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 15:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 16:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 17:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 18:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 19:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 20:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 21:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 22:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 23:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 24:\\n  \t\t\tprint 'c****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \telse:\\n  \t\tprint 'Impossible'\\n  \\n", "substitutes": {"t": ["p", "o", "it", "start", "at", "dt", "T", "q", "time", "ts", "d", "x", "h", "y", "l", "f", "port", "tz", "e", "tt", "trial", "z", "type", "w", "s", "b", "v", "u", "tm", "n", "test"], "case": ["me", "id", "rice", "app", "name", "ice", "time", "text", "x", "count", "position", "ace", "end", "table", "code", "trial", "ce", "type", "match", "size", "length", "Case", "instance", "line", "number", "race", "use", "loc", "ase", "section", "test", "slice", "cases"], "r": ["err", "p", "o", "rb", "R", "br", "tr", "range", "rc", "q", "ar", "mr", "d", "x", "h", "l", "y", "f", "ru", "cr", "nr", "fr", "e", "ir", "rec", "ter", "ur", "rr", "k", "rh", "z", "w", "g", "j", "re", "b", "sr", "v", "s", "hr", "u", "pr", "n", "rs", "er", "yr"], "c": ["p", "o", "cu", "ci", "ch", "cc", "col", "cf", "lc", "dc", "rc", "sc", "q", "ar", "oc", "d", "ct", "x", "h", "y", "l", "f", "cr", "cp", "count", "uc", "e", "code", "rec", "ur", "ce", "ec", "k", "z", "cin", "cat", "ic", "con", "cm", "xc", "co", "w", "cl", "g", "C", "a", "s", "b", "v", "re", "u", "ca", "n", "cs", "mc", "pc", "ac", "cy"], "m": ["mod", "p", "o", "me", "mo", "pm", "gm", "lc", "mu", "mm", "range", "fm", "machine", "ar", "man", "sm", "mr", "d", "x", "h", "am", "y", "l", "f", "arm", "ym", "e", "bm", "dm", "ur", "md", "um", "M", "z", "k", "em", "module", "hm", "cm", "a", "w", "g", "j", "im", "mon", "mi", "b", "v", "s", "re", "ms", "u", "om", "tm", "rm", "n", "an", "er", "mc"], "i": ["p", "o", "it", "ui", "li", "chi", "id", "ci", "ei", "oi", "ji", "phi", "ai", "x", "bi", "h", "l", "ri", "f", "I", "iv", "ii", "ti", "e", "yi", "ie", "xi", "pi", "di", "ic", "j", "ib", "b", "v", "ip", "iw", "u", "qi", "io", "int", "si", "iu"]}}
{"code": "t = int(raw_input())\\n  \\n  for case in range(t):\\n  \tr1 = int(raw_input())\\n  \tc1 = []\\n  \tfor j in range(4):\\n  \t\tc1.append([int(i) for i in raw_input().split()])\\n  \\n  \tr2 = int(raw_input())\\n  \tc2 = []\\n  \tfor j in range(4):\\n  \t\tc2.append([int(i) for i in raw_input().split()])\\n  \\n  \tnum = -1\\n  \tpossibles = 0\\n  \tfor j in c1[r1-1]:\\n  \t\tif c2[r2-1].count(j) == 1:\\n  \t\t\tnum = j\\n  \t\t\tpossibles += 1\\n  \\n  \tif possibles > 1:\\n  \t\tprint 'Case #'+str(case+1)+': Bad magician!'\\n  \telif possibles == 0:\\n  \t\tprint 'Case #'+str(case+1)+': Volunteer cheated!'\\n  \telse:\\n  \t\tprint 'Case #'+str(case+1)+': '+str(num)\\n", "substitutes": {"t": ["p", "it", "start", "tp", "dt", "T", "m", "q", "time", "d", "x", "h", "y", "f", "times", "c", "ti", "e", "tt", "trial", "ta", "z", "type", "r", "w", "g", "s", "v", "tm", "n", "test", "total"], "case": ["li", "id", "rice", "division", "pe", "config", "path", "seq", "q", "ice", "du", "name", "time", "loop", "ai", "space", "bi", "h", "gi", "connection", "position", "c", "uc", "ti", "end", "code", "choice", "key", "ie", "mode", "trial", "ce", "shape", "job", "k", "z", "sec", "type", "sequence", "match", "cell", "part", "size", "a", "bc", "length", "Case", "b", "v", "instance", "jo", "line", "ip", "race", "ase", "string", "qi", "test", "section", "ct", "cases"], "r1": ["rc1", "x1", " r3", "r3", "c0", "r0", "R1", "c3", "x2", "x8", "c8", " r0", "r8", "R3", "R2", "R0", "rc8", "rc2"], "c1": ["rc1", "C2", "r3", "c0", " c3", "cn", " c0", "r0", "r31", "rup", "c3", " cn", "rc0", "C1", "rc3", "Cup", " cup", "C31", " c31", "rn", "C0", "c31", "cup", "Cn", "rc2"], "j": ["p", "_", "o", "new", "ch", "js", "jit", "q", "jp", "jing", "ji", "m", "d", "J", "x", "kj", "un", "ind", "y", "f", "h", "l", "oj", "c", "end", "jl", "aj", "ie", "job", "obj", "k", "z", "cell", "jj", "r", "ja", "note", "a", "g", "dj", "im", "ij", "b", "v", "number", "u", "jam", "n", "int", "uj"], "i": ["p", "it", "o", "ui", "li", "id", "ci", "ix", "jit", "ia", "index", "ori", "q", "m", "ji", "d", "ai", "bi", "x", "ind", "ri", "l", "f", "I", "ii", "c", "ti", "e", "yi", "zi", "ie", "xi", "pi", "k", "z", "r", "ni", "im", "b", "v", "u", "ip", "on", "qi", "n", "si", "io", "int", "iu"], "r2": ["r4", "rr1", "R1", "rr2", " r4", "rsecond", "rrTwo", "v22", "usecond", "rTwo", "u2", " r22", "u22", "r22", " rsecond", " rTwo", "vsecond", "R2", "RTwo", "v2", "R4", "rr4"], "c2": ["C2", "c6", "r4", "p8", "p1", "vTwo", "cTwo", "ctwo", "f4", "v1", "r6", " c6", " c62", "c62", "p6", " cTwo", "p2", "rTwo", "c8", "f2", "C1", "r8", "Ctwo", "ftwo", "rtwo", "r62", "f1", "v2", " c8", "c4", "v62", "C4"], "num": ["split", "p", "nu", "unit", "sn", "id", "sim", "col", "lim", "index", "len", "m", "nb", "loop", "norm", "success", "x", "span", "ind", "en", "max", "coord", "count", "c", "Num", "hom", "no", "um", "k", "note", "part", "nom", "con", "ni", "uni", "umi", "mon", "sum", "b", "pos", "number", "u", "dim", "om", "loc", "NUM", "n", "int"], "possibles": ["Possibilities", "pensibility", "POSSibly", "Passibly", "powersibilities", "passibility", "Possibl", "passibl", "pOSSibles", "Passible", "Passibility", "POSSibilities", "POSSible", "pensibilities", "passibles", "Passibles", "pOSSible", "passibilities", "passible", "positibles", "pensibly", "possibl", "POSSibl", "Passibl", "Possibility", "Possibly", "Passibilities", "pOSSibly", "Possibles", "passibly", "positibilities", "possibilities", "pensibles", "posibilities", "positible", "Possible", "positibl", "possibly", "posibility", "pOSSibility", "powersibles", "POSSibility", "possible", "POSSibles", "pOSSibl", "possibility", "posibly", "posibles", "pOSSibilities", "powersibly", "powersibility"]}}
{"code": "def make_string(R, C, M):\\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\\n      grid[-1][-1] = 'c'\\n      t = M\\n      for i in xrange(R):\\n          for j in xrange(C):\\n              if M:\\n                  if forbidden(R, C, t, i, j):\\n                      continue\\n                  grid[i][j] = '*'\\n                  M -= 1\\n              else:\\n                  break\\n      s = ''\\n      if M:\\n          return 'Impossible'\\n      for r in grid:\\n          s += ''.join(r)+'\\n'\\n      return s[:-1]\\n  \\n  def forbidden(R, C, M, i, j):\\n      a = M / C\\n      b = M % C\\n      if (R*C - M == 1):\\n          return False\\n  \\n      if i >= (R-2) and j >= (C-2):\\n          return True\\n  \\n      if i >= (R-2) and b:\\n          if b % 2:\\n              return True\\n          if j < b/2:\\n              return False\\n          else:\\n              return True\\n      return False\\n          \\n  \\n  f = open('Csmall.in', 'r')\\n  g = open('outputC.txt', 'w')\\n  \\n  data = [[int(e) for e in line.strip(\"\\n\").split(' ')] for line in f]\\n  T = int(data.pop(0)[0])\\n  for i, case in enumerate(data):\\n      R, C, M = case[0], case[1], case[2]\\n      num_cells = R*C\\n      if (R-1) == 0 or (C-1) == 0:\\n          s = make_string(R, C, M)\\n          g.write('Case #%i:\\n%s\\n' %(i+1,s))\\n          continue\\n      else:\\n          s = make_string(R, C, M)\\n          g.write('Case #%i:\\n%s\\n' %(i+1, s))\\n          \\n  \\n  f.close()\\n  g.close()\\n", "substitutes": {"R": ["P", "O", "A", "CR", "WR", "KR", "S", "JR", "B", "Ra", "MR", "RA", "Rule", "J", "L", "RR", "Run", "F", "X", "Ro", "I", "RN", "BR", "K", "c", "Ch", "Rs", "E", "NR", "RH", "Right", "RO", "Group", "D", "G", "Rh", "U", "Y", "GR", "Cl", "RS", "V", "H", "Co", "RG", "Q", "W", "N", "Res", "SR", "Re", "RM", "RC", "Br", "Range", "Role"], "C": ["CC", "Z", "P", "O", "Cr", "CR", "A", "CF", "CW", "CS", "SC", "S", "B", "Cs", "CI", "YC", "JC", "CL", "L", "DC", "Code", "CM", "AC", "X", "F", "I", "K", "Sc", "c", "Ch", "CU", "E", "CT", "CN", "CNN", "VC", "D", "G", "NC", "EC", "MC", "U", "Count", "Y", "CA", " c", "Co", "V", "Case", "H", "Cu", "CE", "Cor", "Q", "W", "N", "CV", "Con"], "M": ["Mo", "Z", "P", "O", "A", "LM", "MF", "S", "MN", "AM", "B", "MO", "MR", "m", "J", "L", "MA", "CL", "CM", "Me", "F", "X", "I", "DM", "K", "Man", "IM", "c", "Mor", "E", "SM", "ME", " m", "MM", "D", "G", "MS", "MI", "MC", "MD", "U", "cm", "Y", "V", "H", "MT", "MB", "Q", "W", "N", "RM", "FM", "Mi", "BM"], "grid": ["house", "array", "unit", "div", "id", "sim", "list", "layout", "range", "db", "ode", "q", "ice", "gr", "gui", "m", "multi", "x", "law", "Grid", "play", "c", "edge", "ace", "arr", "rule", "code", "chain", "ata", "ward", "et", "str", "complex", "frame", "draw", "age", "G", "graph", "cell", "module", "sequence", "cube", "reg", "w", "row", "model", " Grid", "block", "mat", "test"], "j": ["p", "o", "it", "li", "js", "jc", "q", "jp", "m", "ji", "d", "J", "x", "bj", "bi", "ind", "oj", "y", "l", "c", "ii", "vi", "adj", "jl", "aj", "ie", "xi", "job", "k", "z", "jj", "je", "ja", "ni", "w", "ij", "im", "ab", "ib", "v", "jam", "u", "n", "si", "uj"], "i": ["it", "iq", "chi", "ix", "index", "ai", "y", "esi", "ti", "eni", "inner", "zi", "key", "uri", "xi", "z", "part", "mi", "v", "u", "ip", "io", "slice", "ui", "id", "CI", "ori", "m", "ini", "multi", "bi", "ind", "gi", "c", "vi", "yi", "ie", "hi", "n", "int", "p", "li", "ci", "ei", "ji", "d", "I", "num", "mini", "di", "info", "ni", "my", "si", "o", "P", "ia", "LI", "x", "ri", "l", "ii", "ir", "pi", "type", "ij", "ib", "iw", "qi", "iu"], "t": ["p", "o", "it", "A", "at", "m", "d", "x", "h", "out", "y", "l", "I", "TM", "F", "c", "ti", "temp", "tt", "z", "tmp", "type", "Y", "w", " c", "v", "u", "tm", "n", "int"], "s": ["side", "steps", "session", "single", "unit", "js", "ts", "name", "ips", "y", "ends", "os", "self", "z", "ures", "w", "sg", "v", "words", "comments", "u", " statements", "sf", "ed", "aces", "ss", "sb", "ches", "states", "m", "space", "es", "out", "c", "ries", "sets", "set", "sec", "abs", "sample", "ing", "n", "sym", "rs", "p", "ains", "ls", "sim", "py", "lines", "S", "spec", "su", "codes", "d", "second", "span", "ops", "ses", "gs", "ings", "status", "blocks", "size", "xs", " lines", " S", "sync", "ments", "si", "section", "seconds", "o", "sq", "ns", "x", "l", "sh", "ions", "ows", "rows", "ps", "type", "conf", "sum", "cells", "sys", "string", "south", "ances", "uses", "ds", "site"], "r": [" ir", "it", "p", "all", "array", "res", "rb", "range", "run", "q", "gr", "m", "d", "arc", "h", "l", "cr", "c", "right", "str", "arr", "ner", "rh", "Rh", " arc", "w", " c", "v", " d", "mat", "n", "rs", "result", "section"], "a": ["p", "o", "A", "ma", "ci", "ia", "na", "ae", "sa", "m", "ai", "am", "mA", "y", "alpha", "area", "c", "ba", "aj", "ga", "ab", "ca", "si", "an", "ac", "aa"], "b": ["p", "o", "be", "rb", "A", "eb", "B", "sb", "lb", "m", "nb", "d", "mb", "bi", "x", "base", "h", "l", "y", "bh", "c", "ba", "bs", "k", "z", "bb", "bf", "w", "ab", "ib", "wb", "v", "u", "n"], "f": ["p", "o", "fp", "ef", "cf", "xf", "fm", "file", "q", "m", " F", "d", "x", "rf", "h", "l", "F", "fo", "c", "fa", "fd", "fr", "fb", "form", "frame", "fw", "fc", "info", "tf", "z", "bf", "fe", "fi", "conf", "fs", "w", "v", "flow", "u", "fold", "sf", "feed", "n", "io", "fen", "af"], "g": ["err", "p", "gen", "ig", "bg", "gm", "group", "fm", "q", "file", "m", "d", "x", "h", "l", "y", "gi", "cfg", "c", "gz", "gs", "gh", "game", "gp", "ga", "G", "og", "gg", "go", "graph", "conf", "reg", "w", "sg", "v", "u", "vg", "gu", "ge"], "data": ["Data", "p", "o", "response", "array", "new", "list", "lines", "index", "d", "x", "slice", "body", "next", "default", "c", "shift", "code", "ata", "series", "key", "values", "map", "rows", "info", "sequence", "input", "DATA", "dat", "blocks", "size", "w", "row", "load", "v", "diff", "u", "test", "error", "result", "results", "change"], "e": ["element", "p", "o", "eb", "se", " E", "ef", "za", "pe", "ei", "entry", "ae", "ice", "ele", "d", "x", "ea", "es", "en", "ite", "ace", "code", "E", "ie", "el", "ce", "te", "ze", "ec", "ee", "ev", "fe", "ade", "ed", "n", "eg", "page", "one", "ge", "ke"], "line": ["p", "band", "li", "link", "lines", "lin", "ine", "len", "file", "m", "Line", "d", "en", "l", "c", "str", "code", "et", "frame", "el", "cell", "cl", "row", "v", "de", "string", "block", "page", "n", "ge"], "T": ["Z", "P", "O", "A", "unit", "S", "B", "time", "F", "X", "I", "trace", "E", "trial", "shape", "D", "z", "type", "Y", "V", "H", "number", "N", "test"], "case": ["switch", "force", "ide", "pe", "path", "catch", "pair", "event", "entry", "name", "ice", "example", "space", "record", "default", "c", "ace", "code", "choice", "key", "do", "trial", "ce", "shape", "cell", "part", "type", "match", "Case", "instance", "ase", "call", "block", "bug", "ride", "section", "test", "result", "error", "slice", "one", "change"], "num_cells": [" num_lines", "num_rows", " num_rows", "num_lines", "num_cell", " num_cell"]}}
{"code": "f = open('A.in', 'r')\\n  g = open('outputA.txt', 'w')\\n  data = [[int(e) for e in line.strip(\"\\n\").split(' ')] for line in f]\\n  T = data[0][0]\\n  c = 0\\n  for i in xrange(1, T*10 + 1, 10):\\n      c += 1\\n      choice1 = data[i][0]\\n      choice2 = data[i+5][0]\\n      grid1, grid2 = [], []\\n      for j in xrange(1,5):\\n          grid1.append(data[i+j])\\n  \\n      for j in xrange(6, 10):\\n          grid2.append(data[i+j])\\n  \\n      s1 = set(grid1[choice1-1])\\n      s2 = set(grid2[choice2-1])\\n  \\n      s = s1 & s2\\n      if len(s) == 1:\\n          g.write(\"Case #%i: %i\\n\" %(c, s.pop()))\\n      elif not s:\\n          g.write(\"Case #%i: Volunteer cheated!\\n\" %(c))\\n      else:\\n          g.write(\"Case #%i: Bad magician!\\n\" %(c))\\n  \\n  f.close()\\n  g.close()\\n      \\n", "substitutes": {"f": ["p", "o", "fp", "lf", "file", "m", "d", "x", "rf", "h", "F", "l", "fo", "fa", "fd", "fit", "fb", "t", "fl", "form", "frame", "fw", "info", "tf", "z", "r", "bf", "fe", "fi", "fs", "a", "w", "b", "v", "flow", "u", "fold", "sf", "feed", "n", "df"], "g": ["erg", "p", "o", "ig", "gen", "bg", "gm", "group", "gb", "m", "gui", "d", "x", "h", "msg", "l", "out", "cfg", "t", "gz", "gs", "gh", "ag", "game", "ge", "ga", "G", "og", "gg", "go", "r", "rg", "w", "sg", "b", "v", "agg", "mg", "u", "gc", "eg", "n", "gu", "vg"], "data": ["split", "Data", "p", "response", "array", "start", "case", "list", "group", "config", "index", "current", "file", "m", "d", "space", "x", "slice", "grade", "next", "table", "t", "code", "change", "temp", "ata", "series", "key", "batch", "values", "cache", "frame", "output", "info", "video", "input", "DATA", "match", "dat", "pick", "ad", "sample", "window", "a", "w", "row", "model", "pos", "content", "call", "string", "block", "n", "test", "result", "style", "int", "results", "zip"], "e": ["element", "p", "o", "it", "iq", "all", "se", "ei", "ae", "m", "d", "x", "en", "y", "l", "energy", "I", "ace", "t", "code", "E", "ie", "el", "te", "ge", "ze", "ec", "k", "z", "r", "ee", "je", "ev", "fe", "a", "b", "u", "n", " E"], "line": ["o", "lf", "li", "all", "lines", "lin", "run", "len", "log", "entry", "name", "file", "Line", "m", "d", "L", "h", "en", "l", "I", "code", "frame", "obj", "k", "cell", "r", "co", " lines", "buffer", "object", "row", "v", "string", "block", "page", "n", "int", "lo", "source"], "T": ["Z", "P", "O", "A", "R", "S", "B", "J", "L", "F", "X", "I", "K", "t", "E", "Total", "D", "M", "z", "Y", "C", "V", "length", "H", "Q", "W", "N", "n", "total"], "c": ["p", "cu", "o", "case", "ci", "col", "cf", "lc", "dc", "nc", "q", "m", "d", "x", "h", "y", "l", "count", "cr", "t", "code", "ce", "ec", "k", "z", "r", "ic", "a", "w", "C", "b", "v", "u", "loc", "n", "cs", "ct", "mc", "cy"], "i": ["p", "it", "ui", "li", "id", "ci", "ei", "index", "q", "m", "ini", "d", "ai", "J", "x", "ind", "l", "h", "I", "y", "ii", "ti", "eni", "t", "yi", "ie", "mini", "di", "info", "k", "z", "r", "ni", "a", "b", "v", "u", "qi", "n", "si", "int", "io", "iu"], "choice1": [" choice3", "example2", "exampleOne", "sequence2", "sequence1", "changeOne", "caseOne", "case2", "case1", "example1", "sequenceOne", "choiceOne", "sequence3", "Choice3", "change1", "ChoiceOne", "change2", "Choice1", "choice3", " choiceOne", "Choice2"], "choice2": ["codetwo", "code02", "sequence2", "line2", "choice02", "code2", "sequencetwo", "choicetwo", "changetwo", "lineb", "grid_", "sequence02", "line_", "gridb", "change02", " choice_", "line1", "change2", " choiceb", "choiceb", "choice_"], "grid1": ["lineOne", "rowOne", "cell1", "house2", "line2", "cell5", "row2", "grid4", "range0", "range1", "lineone", "house1", "row1", " gridOne", " grid01", "group3", "grid01", "group5", "group1", "choice0", " grid5", " grid3", "gridOne", " gridone", "rowone", "cell3", "range2", "grid0", "gridone", "line1", "grid5", "group01", "range4", "choice4", "house4", "house0", "cell01", "grid3"], "grid2": ["grid02", "grouptwo", "Grid3", "house2", "group2", "group02", "Grid5", "choice02", "house1", "house3", "group3", "group5", "group1", "Grid2", " grid5", " grid3", "Gridtwo", "Grid1", " gridtwo", "grid5", "gridtwo", "choice3", "house02", "grid3"], "j": ["p", "o", "br", "li", "id", "ci", "ch", "js", "q", "jp", "ji", "d", "J", "x", "ind", "l", "y", "h", "end", "t", "ie", "el", "k", "z", "r", "im", "b", "v", "u", "n"], "s1": ["ds1", " sOne", "g2", "sfirst", "sOne", "si01", "g01", "S81", "S1", "si2", "si1", "siOne", "si81", "s01", "gfirst", " s81", "dsfirst", "SOne", "s81", "ds01", "ds2", "g1", "sifirst"], "s2": [" s8", "grid52", "ss2", "s52", "es5", " s5", "es2", "es82", "es52", "s02", "ss8", " s10", "ss02", "ss10", "s8", " s02", "sa10", "grid5", "s5", " s82", "sa2", "s10", "sa02", " s52", "s82", "sa8", "grid82"], "s": ["p", "o", "tests", "new", "sort", "ls", "ws", "S", "js", "ss", "sb", "states", "qs", "ns", "m", "ins", "d", "strings", "es", "l", "ops", "y", "ids", "gs", "sets", "ses", "events", "ssl", "sites", "os", "ows", "rows", "set", "ps", "sections", "services", "parts", "size", "blocks", "settings", "groups", "a", "b", "v", "words", "sync", "comments", "u", "south", "n", "si", "sym", "cs", "slice", "ds"]}}
{"code": " \\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      T = int(f.readline())\\n      for _T in xrange(T):\\n          R, C, M = map(int, f.readline().split())\\n  \\n          print \"Case #%d:\" % (_T+1)\\n  \\n          left = R * C - M\\n  \\n          if R == 1:\\n              s = 'c'\\n              s += '.' * (left - 1)\\n              s += '*' * M\\n              print s\\n              continue\\n          if C == 1:\\n              print 'c'\\n              for i in xrange(left - 1):\\n                  print '.'\\n              for i in xrange(M):\\n                  print '*'\\n              continue\\n  \\n          if left == 1:\\n              print 'c' + '*' * (C-1)\\n              for i in xrange(R-1):\\n                  print '*' * C\\n              continue\\n  \\n          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\\n              print \"Impossible\"\\n              continue\\n          if R == 2:\\n              assert left not in (2, 3, 5, 7)\\n              assert left >= 4\\n              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\\n              print '.' + '.' * (left/2 - 1) + '*' * (M/2)\\n              continue\\n          if C == 2:\\n              assert left >= 4\\n              assert left not in (2, 3, 5, 7)\\n              print 'c.'\\n              left -= 2\\n              R -= 1\\n              while left:\\n                  print '..'\\n                  left -= 2\\n                  R -= 1\\n              assert R >= 0\\n              while R:\\n                  print '**'\\n                  R -= 1\\n              continue\\n  \\n          assert R >= 3\\n          assert C >= 3\\n  \\n          if left == 4:\\n              print 'c.' + '*' * (C-2)\\n              print '..' + '*' * (C-2)\\n              for i in xrange(R-2):\\n                  print '*' * C\\n              continue\\n  \\n          if left in (2, 3, 5, 7):\\n              print \"Impossible\"\\n              continue\\n  \\n          assert left >= 6\\n  \\n          cols = max(3, (left + R-1) // R)\\n  \\n          if left % cols == 1:\\n              assert left >= 10\\n  \\n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\\n              left -= cols\\n              R -= 1\\n  \\n              while left > cols + 1:\\n                  print '.' * cols + '*' * (C - cols)\\n                  left -= cols\\n                  R -= 1\\n              assert left == cols + 1\\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\\n              print '.' * (2) + '*' * (C - 2)\\n              R -= 2\\n  \\n              assert R >= 0\\n  \\n              while R:\\n                  print '*' * C\\n                  R -= 1\\n              continue\\n          else:\\n              assert left >= 6\\n  \\n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\\n              left -= cols\\n              R -= 1\\n  \\n              while left > cols:\\n                  print '.' * cols + '*' * (C - cols)\\n                  left -= cols\\n                  R -= 1\\n              assert left >= 2\\n              print '.' * (left) + '*' * (C - left)\\n              R -= 1\\n  \\n              assert R >= 0\\n  \\n              while R:\\n                  print '*' * C\\n                  R -= 1\\n              continue\\n  \\n          1/0\\n", "substitutes": {"f": ["p", "o", "fp", "full", "fed", "file", "m", "x", "rf", "h", "F", "l", "fo", "c", "fr", "fd", "fa", "fb", "e", "t", "form", "fw", "fc", "tf", "r", "bf", "fi", "fs", "w", "g", "v", "b", "u", "sf", "feed", "n", "fen", "inf", "df", "af"], "fn": ["format", "fin", "fp", "kn", "sn", "wt", "unc", "full", "txt", "feat", "path", "nc", "len", "fm", "file", "func", "name", "function", "ll", "syn", "rf", "F", "fa", "fd", "fb", "lib", "ln", "wn", "fl", "utf", "fc", "output", "fat", "conn", "bf", "fi", "FN", "fs", "fun", "bn", "wl", "sf", "n", "fen", "fil", "dn", "filename"], "T": ["Z", "TT", "P", "O", "A", "S", "TW", "WT", "L", "TB", "F", "X", "DT", "K", "I", "t", "TS", "E", "Total", "TN", "TX", "TH", "Tw", "TR", "D", "G", "Y", "length", "V", "Q", "W", "N", "n", "Time", "NT"], "_T": ["_t", " _t", "_M", " _N", "_N", "_F", " _M"], "R": ["P", "O", "A", "CR", "S", "B", "Left", "RA", "AR", "Line", "ro", "RE", "L", "RR", "J", "F", "X", "RN", "I", "K", "RP", "right", "c", "RW", "Rs", "E", "All", "NR", "RH", "Right", "DR", "RO", "TR", "G", "D", "r", " r", "Rh", "U", "Y", "GR", "RS", "V", "H", "RT", "RL", "RG", "Q", "W", "SR", "N", "RF", "Re", "RM", "RC", "Range"], "C": ["CC", "P", "O", "A", "CR", "Cr", "CF", "SC", "S", "B", "Left", "Cs", "COR", "DC", "L", "CM", "F", "X", "I", "K", "Sc", "c", "CU", "E", "CO", "CNN", "Right", "RO", "D", "G", "EC", "r", "U", "Y", "CA", "V", "H", "Co", "Cu", "Q", "W", "N", "RC", "CE"], "M": ["Z", "P", "O", "LM", "A", "MF", "S", "MN", "B", "Left", "MR", "m", "J", "L", "MA", "CM", "TM", "F", "X", "I", "DM", "K", "Mor", "E", "MM", "D", "G", "MS", "MC", "MD", "r", "OR", "U", "Y", "V", "H", "MT", "Q", "NM", "W", "N", "RM"], "left": ["CC", "Z", "it", "SC", "all", "case", "list", "ax", "lc", "path", "index", "internal", "shell", "CL", " L", "LL", "reset", "inner", "ell", "no", "key", "used", "wrong", "control", "output", "self", "FL", "leave", "cle", "cm", "length", "this", "plus", "min", "NL", "ctrl", "LC", "bottom", "lt", "LE", "ignore", "old", "pl", "offset", "full", "B", "m", "required", "ro", "Control", "out", "ul", "right", "c", "data", "end", "ALL", "CO", "roll", "column", "Cl", "RL", "root", "pos", "bl", "lr", "n", "ct", "p", "LM", "CR", "li", "label", "col", "st", "len", "log", "file", "function", "d", "text", "LR", "F", "X", "I", "str", "e", "fl", "none", "nl", "two", "RO", "partial", "cell", "size", "a", "cl", "j", "low", "row", "small", "line", "lower", "loc", "le", "error", "net", "lo", "outside", "one", "err", "o", "P", "PL", "sp", "Left", "ion", "center", "null", "ST", "L", "x", "l", "found", "cont", "byn", "just", "Right", "rows", "r", "value", "co", "top", "static", "last", "N"], "s": ["p", "o", "square", "ws", "ls", "lines", "S", "ss", "sb", "center", "su", "ns", "m", "ins", "d", "span", "strings", "out", "l", "y", "es", "ans", "h", "c", "right", "str", "e", "t", "sets", "ses", "ings", "ions", "us", "secondary", "sign", "r", "a", "w", "g", "sg", "sum", "b", "small", "comments", "sf", "string", "south", "n", "si", "sym", "ed", "cs"], "i": ["il", "p", "it", "o", "li", "id", "ci", "ei", "m", "ai", "x", "ind", "l", " I", "I", "ii", "c", "ti", "e", "ie", "pi", "xi", "di", "z", "r", "IJ", "g", "j", "im", "v", "ip", "u", "iw", "n", "io", "int", "si", "iu"], "cols": ["columns", "Cold", "Coln", "Cols", "COLn", "COLrows", " cold", "columnn", " colabs", "colabs", "coln", "columnabs", " coln", "Colabs", "columnd", "COLs", "cold", "Colspan", "Colrows", "colspan", "COLspan", " colspan", "colrows", " colrows"]}}
{"code": " \\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      T = int(f.readline())\\n      for _T in xrange(T):\\n          a1 = int(f.readline())\\n          l1 = [map(int, f.readline().split()) for _ in xrange(4)]\\n          a2 = int(f.readline())\\n          l2 = [map(int, f.readline().split()) for _ in xrange(4)]\\n  \\n          poss = list(set(l1[a1-1]) & set(l2[a2-1]))\\n  \\n          print \"Case #%d:\" % (_T + 1),\\n          if len(poss) == 0:\\n              print \"Volunteer cheated!\"\\n          elif len(poss) == 1:\\n              print poss[0]\\n          else:\\n              print \"Bad magician!\"\\n", "substitutes": {"f": ["p", "o", "fp", "fast", "full", "cf", "of", "file", "m", "d", "rf", "F", "l", "fo", "c", "fr", "fd", "fa", "e", "fb", "t", "form", "i", "fw", "fc", "info", "tf", "z", "buff", "handler", "r", "bf", "fe", "fi", "conf", "fs", "w", "g", "s", "v", "b", "sf", "feed", "fen", "inf", "df", "folder", "af"], "fn": ["format", "p", "o", "fin", "fp", "lf", "kn", "thin", "sn", "unc", "full", "txt", "feat", "path", "len", "fm", "name", "file", "func", "function", "ll", "syn", "F", "c", "fd", "typ", "fb", "ln", "fl", "utf", "fw", "fc", "output", "fat", "oln", "bf", "fi", "FN", "fun", "bn", "method", "loc", "wl", "sf", "n", "fen", "fil", "dn", "source", "filename"], "T": ["Z", "P", "O", "A", "TT", "R", "S", "B", "L", "F", "X", "K", "I", "TS", "t", "E", "TN", "D", "M", "G", "Y", "C", "V", "length", "number", "Q", "W", "N", "Time"], "_T": ["_NT", " _N", " _Time", "_H", "_D", "_Time", "_C", " _D", " _C", " _H", "_N", " _NT"], "a1": ["a4", "A4", "A2", "l9", "A1", "A9", "A3", "alpha3", "a9", " a3", "alpha2", "l4", "l3", "alpha4", "a3", "alpha1", " a9"], "l1": ["elOne", "lone", "l8", "ar8", "el2", "p8", "p1", "arOne", "l_", "el8", "a_", "ar2", "pOne", "Lone", " l_", "ar1", "p2", "L2", "aone", " lone", "L_", "lOne", "L1", "el1"], "_": ["p", "all", "val", "of", "place", "len", "x", "un", "out", "al", "k", "a", "non", "ing", "line", "ip", "n", "ac"], "a2": ["a8", "a4", "A4", "a02", "A2", "laII", " a8", "A8", "atwo", "da2", "aII", "latwo", " a82", "area02", "A82", "r2", "a82", "da82", "rtwo", "area2", " a4", "r02", "rII", "da8", "la02", "areaII", "la2", "da4", "areatwo"], "l2": ["a4", "p1", " l0", "b2", "p2", " l3", " l4", "b0", "b1", "p4", "b4", "p0", "l4", "l0", "l3", "a0", "a3", "p3"], "poss": ["peOSS", " pitch", "Poses", " pours", "pose", "bore", "pore", "loss", "sposes", " pore", "spore", " pott", "pott", "peitch", "boss", "POSS", "lOSS", "spott", "poses", " poses", "lpose", "pob", "bott", "peoss", "pitch", "apOSS", "pours", "aposs", "pOSS", "lpOSS", " pOSS", "litch", "lours", "lposes", "Pose", " pose", "lposs", " pob", "apose", "boses", "sposs", "apob", "Pob", "Poss", "peours"]}}
{"code": " \\n  \\n  TEST_CASES = [\\n      (\"\"\"5\\n  5 5 23\\n  3 1 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  \"\"\",\"\"\"Case #1:\\n  Impossible\\n  Case #2:\\n  c\\n  .\\n  *\\n  Case #3:\\n  Impossible\\n  Case #4:\\n  c......\\n  .......\\n  .......\\n  ....***\\n  Case #5:\\n  c........*\\n  .........*\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  \"\"\"),\\n      (\"\"\"3\\n  5 4 3\\n  5 3 8\\n  5 5 14\\n  \"\"\",\"\"\"Case #1:\\n  c...\\n  ....\\n  ....\\n  ...*\\n  ..**\\n  Case #2:\\n  Impossible\\n  Case #3:\\n  c...*\\n  ....*\\n  ...**\\n  *****\\n  *****\\n  \"\"\")\\n  ]\\n  \\n  IMPOSSIBLE = \"Impossible\"\\n  \\n  \"\"\"\\n  S is number of safe squares = (R*C) - M\\n  If S == 1 then always possible:\\n      Assume click in top left, all else mines\\n  Special cases (R or C is small):\\n  If R == 1 or C == 1 then always possible:\\n      Assume click in top left and all safe squares in a line\\n  Else if R == 2 or C == 2 then possible iff S % 2 == 0:\\n      Assume click in top left and all safe squares are in a 2 * X line\\n  Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\\n     OR if S % 2 == 0 \\n  \"\"\"\\n  \\n  def parse_input(input_reader):\\n      case_count = int(input_reader.readline())\\n      case_idx = 0\\n      while case_count > case_idx:\\n          case_idx += 1\\n          input_line = [int(x) for x in input_reader.readline().split()]\\n          input_values = {\"case\": case_idx,\\n                          \"R\": input_line[0],\\n                          \"C\": input_line[1],\\n                          \"M\": input_line[2]}\\n          yield input_values\\n  \\n  \\n  def solve_problem(output_writer=sys.stdout, **kwargs):\\n      case = kwargs['case']\\n      rows = kwargs['R']\\n      cols = kwargs['C']\\n      mines = kwargs['M']\\n      safe_squares = ((rows * cols) - mines)\\n      print >> output_writer, \"Case #%d:\" % case\\n      row_string = \"{:*<%ds}\" % cols\\n      impossible = False\\n      if safe_squares == 1:\\n          print >> output_writer, row_string.format(\"c\")\\n          for row in range(1, rows):\\n              print >> output_writer, row_string.format(\"\")\\n      elif rows == 1:\\n          safe_string = \"c\" + (\".\" * (safe_squares - 1))\\n          print >> output_writer, row_string.format(safe_string)\\n      elif cols == 1:\\n          for row in range(rows):\\n              cell = \"\"\\n              if row == 0:\\n                  cell = \"c\"\\n              elif row < safe_squares:\\n                  cell = \".\"\\n              print >> output_writer, row_string.format(cell)\\n      elif safe_squares == 2:\\n          impossible = True\\n      elif rows == 2:\\n          safe_cols, remainder = divmod(safe_squares, 2)\\n          if remainder == 1:\\n              impossible = True\\n          else:\\n              safe_string = \".\" * (safe_cols - 1)\\n              print >> output_writer, row_string.format(\"c%s\" % safe_string)\\n              print >> output_writer, row_string.format(\".%s\" % safe_string)\\n      elif cols == 2:\\n          safe_rows, remainder = divmod(safe_squares, 2)\\n          if remainder == 1:\\n              impossible = True\\n          else:\\n              for row in range(rows):\\n                  cells = \"\"\\n                  if row == 0:\\n                      cells = \"c.\"\\n                  elif row < safe_rows:\\n                      cells = \"..\"\\n                  print >> output_writer, row_string.format(cells)\\n      else:\\n          safe_rows, remainder = divmod(safe_squares, cols)\\n          if remainder == 1 and cols == 3 and safe_rows == 2:\\n              impossible = True\\n          elif safe_rows > 1:\\n              if remainder == 1 and safe_rows == 2:\\n                  mid_safe = \".\" * (cols-2)\\n                  for row in range(rows):\\n                      cell_one = \".\"\\n                      mid_cells = mid_safe\\n                      last_cell = \".\"\\n                      if row == 0:\\n                          cell_one = \"c\"\\n                      elif safe_rows == 0:\\n                          cell_one = \".\"\\n                          mid_cells = \".\" * (remainder + 1)\\n                      elif safe_rows < 0:\\n                          cell_one = \"\"\\n                          mid_cells = \"\"\\n                      if safe_rows < 3:\\n                          last_cell = \"\"\\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\\n                      safe_rows -= 1\\n              elif remainder == 1:\\n                  mid_safe = \".\" * (cols-2)\\n                  for row in range(rows):\\n                      cell_one = \".\"\\n                      mid_cells = mid_safe\\n                      last_cell = \".\"\\n                      if row == 0:\\n                          cell_one = \"c\"\\n                      elif safe_rows == 0:\\n                          cell_one = \".\"\\n                          mid_cells = \".\" * remainder\\n                      elif safe_rows < 0:\\n                          cell_one = \"\"\\n                          mid_cells = \"\"\\n                      if safe_rows < 2:\\n                          last_cell = \"\"\\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\\n                      safe_rows -= 1\\n              else:\\n                  full_safe = \".\" * cols\\n                  for row in range(rows):\\n                      cells = full_safe\\n                      if row == 0:\\n                          cells = \"c\" + (\".\" * (cols - 1))\\n                      elif row == safe_rows:\\n                          cells = \".\" * remainder\\n                      elif row > safe_rows:\\n                          cells = \"\"\\n                      print >> output_writer, row_string.format(cells)\\n          else:\\n              safe_cols, remainder = divmod(safe_squares, 2)\\n              if remainder == 1 and safe_cols < 4:\\n                  impossible = True\\n              elif remainder == 0:\\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\\n                  for row in range(2, rows):\\n                      print >> output_writer, row_string.format(\"\")\\n              else:\\n                  safe_cols -= 1\\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\\n                  print >> output_writer, row_string.format(\"...\")\\n                  for row in range(3, rows):\\n                      print >> output_writer, row_string.format(\"\")\\n      if impossible:\\n          print >> output_writer, IMPOSSIBLE\\n  \\n  def solve_inputs(input_reader, output_writer):\\n      \"\"\"\\n      Loop through each problem input in input reader and solve it.\\n  \\n      Outputs responses to output_writer.\\n      \"\"\"\\n      for input_values in parse_input(input_reader):\\n          solve_problem(output_writer=output_writer, **input_values)\\n  \\n  def run_tests():\\n      idx = 0\\n      all_pass = True\\n      for problem_input, expected_output in TEST_CASES:\\n          idx += 1\\n          input_reader = StringIO(problem_input)\\n          output_writer = StringIO()\\n          solve_inputs(input_reader, output_writer)\\n          problem_output = output_writer.getvalue()\\n          if problem_output == expected_output:\\n              print \"Test %d: Success\" % idx\\n          else:\\n              all_pass = False\\n              print \"Test %d: Failure\" % idx\\n              print problem_output\\n          input_reader.close()\\n          output_writer.close()\\n      if all_pass:\\n          print \"All tests were successful!\"\\n      else:\\n          print \"Something didn't match - try again.\"\\n  \\n  def main():\\n      parser = OptionParser()\\n      parser.add_option(\"-f\", \"--file\",\\n                        dest=\"filename_stem\",\\n                        help=\"read input from FILE.in and write to FILE.out\",\\n                        metavar=\"FILE\")\\n  \\n      (options, args) = parser.parse_args()\\n      if options.filename_stem:\\n          print \"Running in file mode.\"\\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\\n          solve_inputs(input_reader, output_writer)\\n      else:\\n          print \"Running in test mode.\"\\n          run_tests()\\n  \\n  if __name__ == \"__main__\":\\n      main()\\n", "substitutes": {"TEST_CASES": ["TEST_CATCHes", "TEST_CASEES", "TEST_CRACIONS", "TEST_CASes", "TEST_CRASIONS", "TEST_CRACes", "TEST_CRASES", "TEST_CRASSE", "TEST_CASEes", "TEST_CASIONS", "TEST_CACSE", "TEST_CRASes", "TEST_CATCHES", "TEST_CASESE", "TEST_CACES", "TEST_CRACSE", "TEST_CATCHIONS", "TEST_CACes", "TEST_CACIONS", "TEST_CRACES", "TEST_CATCHSE", "TEST_CASSE", "TEST_CASEIONS"], "IMPOSSIBLE": ["IMPENSABLE", "IMPESSible", "IMPENSibility", "IMpOSSibility", "IMPESSABLE", "IMpOSSABLE", "IMpOSSIBLE", "IMpOSSible", "IMPACIBLE", "IMpENSible", "IMPOSSibility", "IMPOSSible", "IMPESSIBLE", "IMpENSibility", "IMPESSibility", "IMPOSSABLE", "IMpENSABLE", "IMPENSIBLE", "IMPENSible", "IMpENSIBLE", "IMPACible", "IMPACABLE", "IMPACibility"], "input_reader": ["inputFmagic", "input_editor", "output_resource", "inputmatinner", "inputmatread", "inputFreader", "input_read", "input_iterator", "output_entry", "inputFilewriter", "inputFilereader", "documentmatread", "inputFeditor", "input_resource", "inputingresource", "inputFileentry", "inputingentry", "inputmatreader", "document_iterator", "document_inner", "documentmatinner", "inputFileresource", "inputmatiterator", "input_inner", "document_editor", "inputFwriter", "documentmatreader", "document_read", "document_reader", "documentmatiterator", "output_reader", "input_magic", "document_magic", "inputingwriter", "inputingreader", "input_entry", "document_writer", "input_writer"], "case_count": ["case\u00b7level", "case\u00b7count", "caseNtotal", "caseftotal", "casefbody", "ase__count", "case__count", "word\u00b7level", "case_total", "caseflevel", "word_body", "ase_id", "ase_Count", "case_Count", "word_total", "ase__Count", "case_level", "ase_count", "case\u00b7body", "caseNlevel", "word\u00b7body", "word_count", "case__Count", "case\u00b7total", "word_level", "case__id", "case_body", "word\u00b7total", "caseNbody", "case_id", "caseNcount", "ase__id", "casefcount", "word\u00b7count"], "case_idx": ["case_idv", "case_Idxes", "case_infox", "case_idxe", "case_idy", "case_Idx", "case_idsn", "case_infoy", "case_countc", "case_countX", "case_Idy", "case_idxs", "case_countxs", "case_idsx", "case_idX", "case_Idxs", "case_idxes", "case_idsxs", "case_infoc", "case_countv", "case_Idxe", "case_countx", "case_idr", "case_idc", "case_countxe", "case_Idr", "case_Idc", "case_infor", "case_idn", "case_idsxes", "case_Idv", "case_IdX", "case_Idn"], "input_line": ["Input_values", "output_line", "importLogstroke", "input_try", "import_line", "input_lines", "inputxline", "argument_sample", "input_liner", "input_sample", "input___try", "output_try", "argumentloglines", "output_lines", "import_stroke", "Input_lines", "inputwvalues", "input___line", "inputsstroke", "argument_lines", "argumentlogline", "inputsentry", "inputlogliner", "argument_line", "inputLogentry", "argumentlogliner", "input_stroke", "input_entry", "input_side", "inputsline", "inputLoglines", "argumentlogsample", "input_lane", "importLogline", "inputlogline", "inputloglines", "inputLogline", "inputLogtry", "inputlogsample", "import_entry", "argument_liner", "input___lines", "input_block", "importLogentry", "Input_block", "inputwline", "inputwblock", "input___lane", "inputLogstroke", "inputwlines", "import_side", "Input_line", "output_lane", "inputsside", "inputLoglane", "importLogside", "inputxsample", "inputxliner", "inputxlines", "inputLogside"], "x": ["p", " xx", "val", "id", "ix", "ax", "pe", "xxx", "xf", "index", "pair", "d", "fx", "xxxxxxxx", "ex", "y", "X", "xt", "wx", "e", "xes", "px", "i", "xi", "xe", "z", "xd", "fe", "xs", "xc", " X", "rx", "xy", "v", "xp", "xxxx", "u", "xx", "xb"], "input_values": ["Input_value", "Input_values", "Input_rows", "input_value", "input_rows", "Input_vals", "input_changes", "output_changes", "input_vals", "output_vals", "output_value", "output_values"], "output_writer": [" output_reader", "output_engine", " output_driver", "out_writers", "outputpubdriver", "outputpubwriter", "output_writers", "out_reader", "out_writer", "out_engine", "output_reader", "output_driver", "outputpubreader", " output_writers", "outputpubwriters"], "case": ["_", "force", "address", "catch", "pair", "name", "ice", "example", "position", "code", "key", "trial", "ce", "Error", "shape", "type", "match", "size", "Case", "instance", "model", "line", "number", "ase", "error", "test", "patch", "section", "slice", "change"], "rows": ["rown", "tests", "features", "rooms", "runs", "lines", "classes", "users", "fields", "times", "ids", "reads", "ries", "items", "checks", "values", "ows", "frames", "keys", "posts", "OWS", "sections", "types", "holes", "groups", "blocks", "headers", "length", "Row", "months", "members", "heads", "planes", "ros", "rs", "results", "cases", "pages"], "cols": ["columns", "colths", "columnes", "Cols", "Colths", "columnions", "Coli", " coles", "columni", "coles", "Coles", "wellions", "columnths", "colions", "wells", "wellths", " coli", "Colions", "welles", "coli", " colions"], "mines": ["eminions", "Minions", "minsions", "Minus", " minors", "eminors", "minses", "colus", "coles", " minces", "colces", "minces", "minus", "minors", " minus", "colions", "minions", "minsus", "minsces", " minions", "Minors", "emines", "Mines", "eminus", "mindus", "colors", "mindors", "mindions", "mindes"], "safe_squares": ["safe_Squared", "safe_Squases", "safe_quared", "safe_Squapes", "safe_collared", "safe_collases", "safe_collares", "safe_squared", "safe_collapes", "safe_squases", "safe_squapes", "safe_quares", "safe_Squares", "safe_quapes", "safe_quases"]}}
{"code": " \\n  \\n  TEST_CASES = [\\n      (\"\"\"3\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  3\\n  1 2 5 4\\n  3 11 6 15\\n  9 10 7 12\\n  13 14 8 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  3\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  \"\"\",\"\"\"Case #1: 7\\n  Case #2: Bad magician!\\n  Case #3: Volunteer cheated!\\n  \"\"\"),\\n      (\"\"\"1\\n  1\\n  15 9 16 5\\n  6 10 1 3\\n  2 4 12 11\\n  13 14 8 7\\n  1\\n  5 10 9 6\\n  12 15 1 11\\n  14 16 4 2\\n  13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\\n  \"\"\")\\n  ]\\n  \\n  BAD_MAGIC = \"Bad magician!\"\\n  CHEATING = \"Volunteer cheated!\"\\n  \\n  def parse_input(input_reader):\\n      case_count = int(input_reader.readline())\\n      case_idx = 0\\n      while case_count > case_idx:\\n          case_idx += 1\\n          rows = []\\n          for loop_idx in (1,2):\\n              row_idx = int(input_reader.readline())\\n              for idx in (1,2,3,4):\\n                  if idx == row_idx:\\n                      rows.append(set(input_reader.readline().rstrip(\"\\n\").split(\" \")))\\n                  else:\\n                      input_reader.readline()\\n          input_values = {\"rows\":rows,\\n                          \"case\":case_idx}\\n          yield input_values\\n  \\n  \\n  def solve_problem(output_writer=sys.stdout, **kwargs):\\n      rows = kwargs['rows']\\n      case = kwargs['case']\\n      intersect = rows[0].intersection(rows[1])\\n      if not intersect:\\n          msg = CHEATING\\n      elif len(intersect) == 1:\\n          msg = intersect.pop()\\n      else:\\n          msg = BAD_MAGIC\\n      print >>output_writer, \"Case #%d: %s\" % (case, msg)\\n  \\n  def solve_inputs(input_reader, output_writer):\\n      \"\"\"\\n      Loop through each problem input in input reader and solve it.\\n  \\n      Outputs responses to output_writer.\\n      \"\"\"\\n      for input_values in parse_input(input_reader):\\n          solve_problem(output_writer=output_writer, **input_values)\\n  \\n  def run_tests():\\n      \"\"\"\\n      Check the sample input and output match.\\n      \"\"\"\\n      idx = 0\\n      all_pass = True\\n      for problem_input, expected_output in TEST_CASES:\\n          idx += 1\\n          input_reader = StringIO(problem_input)\\n          output_writer = StringIO()\\n          solve_inputs(input_reader, output_writer)\\n          problem_output = output_writer.getvalue()\\n          if problem_output == expected_output:\\n              print \"Test %d: Success\" % idx\\n          else:\\n              all_pass = False\\n              print \"Test %d: Failure\" % idx\\n          input_reader.close()\\n          output_writer.close()\\n      if all_pass:\\n          print \"All tests were successful!\"\\n      else:\\n          print \"Something didn't match - try again.\"\\n          print problem_output\\n  \\n  def main():\\n      parser = OptionParser()\\n      parser.add_option(\"-f\", \"--file\",\\n                        dest=\"filename_stem\",\\n                        help=\"read input from FILE.in and write to FILE.out\",\\n                        metavar=\"FILE\")\\n  \\n      (options, args) = parser.parse_args()\\n      if options.filename_stem:\\n          print \"Running in file mode.\"\\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\\n          solve_inputs(input_reader, output_writer)\\n      else:\\n          print \"Running in test mode.\"\\n          run_tests()\\n  \\n  if __name__ == \"__main__\":\\n      main()\\n", "substitutes": {"TEST_CASES": ["TEST_SCASES", "TEST_CASS", "TEST_CASEES", "TEST_CATCHes", "TEST_CASes", "TEST_CATCHS", "TEST_CASEes", "TEST_SCASS", "TEST_CASIONS", "TEST_CATCHES", "TEST_SCATCHes", "TEST_SCATCHS", "TEST_CACES", "TEST_CACS", "TEST_CATCHIONS", "TEST_SCASIONS", "TEST_CACes", "TEST_CACIONS", "TEST_SCATCHES", "TEST_SCASes", "TEST_CASEIONS", "TEST_SCATCHIONS"], "BAD_MAGIC": ["BAD_GERICS", "BAD_STATICS", "BAD_LOGIC", "BAD_LOGICK", "BADLETOPIC", "BAD_TOPICS", "BADJLOGENT", "BADJMAGICS", "BAD_TOPIC", "BAD_MAGIT", "BAD_TOPIT", "BAD_GERICK", "BAD_MAGENT", "BAD_GERIC", "BAD_STATIC", "BAD_GERENT", "BADLEMAGICK", "BAD_LOGIT", "BAD_STATIT", "BAD_MAGICS", "BAD_MAGICK", "BADLETOPICS", "BADJMAGIC", "BAD_LOGICS", "BADLETOPICK", "BADLEMAGIT", "BAD_GENIC", "BAD_TOPICK", "BADJLOGICS", "BADLETOPIT", "BAD_GENENT", "BAD_LOGENT", "BAD_STATICK", "BADJLOGIC", "BADJLOGICK", "BADLEMAGIC", "BADLEMAGICS", "BADJMAGENT", "BAD_GENICS", "BAD_GENICK", "BADJMAGICK"], "CHEATING": ["CHPEATING", "CHFEATING", " CHEATE", "ECHEating", " CHPEATED", "ECHEATING", " CHPEATE", "CHMEating", "CHFEating", "CHEEATED", "ECHEATER", "ECHPEATING", "CHFEATE", " CHEATED", "CHEating", "CHEEATER", "CHEATER", "CHPEATER", "CHMEATED", "CHEEating", "ECHEATED", "CHFEATED", "CHEATED", "CHMEATER", "ECHPEating", "CHPEating", "ECHPEATER", "CHEEATE", " CHPEATING", " CHPEating", "CHMEATING", " CHEating", "ECHPEATED", "CHPEATE", "CHPEATED", "CHEEATING", "CHEATE"], "input_reader": ["inputfilestream", "output_worker", "jsonFileserver", "inputFilereader", "active_writer", "active_reader", "output_server", "inputfwriter", "jsonFilereader", "textFilereader", "inputFileparser", "json_server", "inputFiledriver", "input_editor", "json_writer", "activeingeditor", "activeingwriter", "inputFreader", "activeingiter", "input_inner", "inputFwriter", "json_reader", "inputfdriver", "inputfilereader", "text_enter", "inputfobject", "inputingreader", "activeingreader", " input_parser", "inputFileserver", "textFileenter", "inputfileworker", "output_object", "inputFilewriter", "inputingeditor", "inputFileenter", "input_worker", "text_parser", "input_server", "input_stream", "input_iter", "output_reader", "jsonFiledriver", "inputFserver", "inputingwriter", "textFilewriter", "inputfreader", "input_enter", "inputfserver", "active_editor", "input_driver", "output_stream", "textFileparser", "input_object", " input_inner", "active_iter", "text_writer", "inputingiter", "jsonFilewriter", "json_driver", " input_writer", "text_reader", "inputfilewriter", "input_parser", "input_writer", "inputFobject"], "case_count": ["case64sum", "casefid", "case_sum", "case__group", "case_area", "case__count", "case64count", "result64group", "result_count", "caseflevel", "result_group", "case64area", "line_id", "line_count", "case_level", "result64count", "case64group", "result_sum", "line_level", "case_group", "case_num", "result_area", "case__area", "case_id", "result64area", "line_num", "result64sum", "case__sum", "casefcount", "casefnum"], "case_idx": ["case_Idxf", "case_endy", "case_Idxes", "case_Idz", "case_idy", "case_idsX", "case_Idx", "case_initz", "case_endx", "case_idsz", "case_pidz", "case_idxf", "case_inz", "case_idxs", "case_pidxs", "case_inx", "case_endz", "case_idsx", "case_Idxs", "case_initxes", "case_idxes", "case_idX", "case_pidx", "case_indy", "case_initx", "case_pidxf", "case_indx", "case_idsxc", "case_initxs", "case_inxs", "case_idxc", "case_indz", "case_idz", "case_indxe", "case_inxf", "case_IdX", "case_idxe", "case_Idxc", "case_endxe"], "rows": ["rown", "tests", "rooms", "array", "projects", "files", "runs", "uds", "lines", "docs", "reports", "relations", "ches", "users", "errors", "details", "opens", "fields", "raw", "ids", "times", "locks", "reads", "data", "items", "flows", "views", "models", "events", "values", "ays", "ows", "frames", "keys", "posts", "rules", "olds", "OWS", "types", "holes", "blocks", "groups", "ks", "vers", "headers", "boxes", "row", "orders", "months", "cells", "days", "planes", "feed", "ros", "shows", "rs", "results", "rings", "cases", "loads", "pages"], "loop_idx": ["case_idsxf", "case_idf", "case_midf", "case_midxf", "case_midx", "case_idsf", "case_idsc", "case_countxf", "case_midc", "case_countc", "case_idxf", "case_idsx", "case_countx", "case_idc", "case_countf"], "row_idx": ["row_inty", "row_intd", "row_idxs", "row_idsy", "row_partex", "row_idsx", "row_keyx", "row_idy", "row_idsi", "row___idex", "row_idex", "row_idsxes", "row_inti", "row___idxs", "row___idd", "row_partxs", "row_keyxs", "row_intxs", "row_idi", "row_intxes", "row___intxs", "row_partd", "row___idx", "row_keyex", "row_keyd", "row_intex", "row_partx", "row_idxes", "row_idd", "row___intx", "row___intex", "row___intd", "row_intx"], "idx": [" idz", " idxc", "idex", "Idx", "idxs", "Idxc", "countxy", "idxy", "idexc", "idexs", "idz", "countx", " idxy", " idxs", " id_", "count_", "Idxs", "end_", "idxc", "endx", " idxx", "countxx", "endxx", "idez", "idxx", "Idz", "id_", "endxy"], "input_values": [" input_ids", "inputMvalues", "Input_value", "Input_values", "inputsvs", "inputMvalue", "Input_rows", "inputMrows", "input_value", "input_vs", "inputMkeys", "input_ids", "Input_vs", "inputsvals", "inputsvalue", "input_rows", "Input_vals", "Input_keys", " input_vs", "inputsvalues", "input_vals", "input_keys", " input_vals"], "output_writer": [" output_reader", "input_editor", "current_writer", "output___writers", "output_entry", "outputfwriter", "current_server", "current_writers", "output_writers", "output___writer", "output_server", "outputfeditor", "input_writers", "output_editor", "output___server", " output_entry", "output_reader", "outputfwriters", "current_reader", "outputfreader", " output_writers", "output___reader", "input_writer", "outputfentry"], "case": ["force", "address", "ci", "hyp", "pe", "path", "catch", "sea", "name", "ice", "order", "base", "count", "cp", "uc", "ace", "client", "nce", "code", "rule", "key", "ce", "trial", "shape", "cell", "type", "match", "exc", "cm", "chance", "Case", "row", "instance", "line", "ase", "call", "block", "bug", "ca", "test", "patch", "section", "slice", "cases"], "intersect": ["corsection", " interract", "Interrupt", " interct", "crossconnect", "Interract", "interect", "consection", "oversection", "conconnect", "iterrupt", " interect", "crosssect", "corsect", "crossrupt", "interct", "overract", "itercept", "consect", "intersections", "intercept", "Interconnect", "crosssection", "corct", "Intersections", " intersection", "interract", "overect", "intersection", "interconnect", "concept", "itersection", "interrupt", "itersect", "Intersection", "Intercept", "corsections", "Intersect", " intersections", "oversect", "Interct", "Interect", "conrupt"], "msg": ["err", "gen", "mn", "comment", "sim", "bg", "fg", "doc", "Message", "log", "fm", "nm", "cy", "Msg", "m", "ext", "cfg", "message", "req", "html", "str", "mag", "reason", "dm", "ag", "md", "debug", "og", "warn", "notice", "module", "mess", "arg", "exc", "cm", "mt", "g", "mid", "warning", "sg", "title", "ms", "cmd", "bug", "sym", "error", "comm", "lang"]}}
{"code": "__author__ = 'Jeffrey'\\n  \\n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-small-attempt0.in\"\\n  \\n  outFileName = inFileName[: -2] + \"out\"\\n  \\n  \\n  def parseInput(f):\\n      T = int(f.readline())\\n      L = []\\n  \\n      for i in range(T):\\n          L.append([int(i) for i in f.readline().split()])\\n  \\n      return T, L\\n  \\n  \\n  def calculateOneClick(R, C, M):\\n      size = R * C\\n      if R == 1 or C == 1 and M < size:\\n          return generateWinBoardBaseCase(R, C, M)\\n      elif size - M == 1:\\n          return generateWinBoardBaseCase(R, C, M)\\n      elif size - M >= 4:\\n          return generateWinBoard(R, C, M)\\n      return \"Impossible\"\\n  \\n  def generateWinBoard(R,C,M):\\n      emptySpace = R * C - M - 4\\n      out = \"c\"\\n      if C > 1:\\n          out += \".\"\\n          for i in range(2,C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      if R > 1:\\n          out += '\\n'\\n          out += \".\"\\n          if C > 1:\\n              out += \".\"\\n          for i in range(2,C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      for r in range(2,R):\\n          out += '\\n'\\n          for c in range(C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      return out\\n  \\n  def generateWinBoardBaseCase(R,C,M):\\n      emptySpace = R * C - M - 1\\n      out = \"c\"\\n      if C > 1:\\n          for c in range(1,C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      for r in range(1,R):\\n          out += '\\n'\\n          for c in range(C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      return out\\n  \\n  \\n  def playGame(T, L):\\n      for i in range(T):\\n          result = calculateOneClick(L[i][0], L[i][1], L[i][2])\\n          yield \"Case #\" + str(i + 1) + \":\\n\" + str(result)\\n  \\n  \\n  if __name__ == \"__main__\":\\n      iF = open(inFileName, 'r')\\n      T, L = parseInput(iF)\\n      iF.close()\\n  \\n      print(T)\\n      print(L)\\n  \\n      oF = open(outFileName, \"wb\")\\n      for out in playGame(T, L):\\n          print(out)\\n          oF.write(bytes(out + \"\\n\", 'utf-8'))\\n      oF.close()\\n", "substitutes": {"__author__": [" __creator___", "__author___", "__version__", "__version___", " __author___", " __creator__", "__authors___", "__authors__", "__creator___", "__creator__"], "inFileName": ["outClassName", "inStreamName", "outClassPath", "inPlaceLine", " inDirLine", "inLinePath", "inLineName", "inPlacePath", "inClassPath", "inDirHandle", "inLineLine", "inDirName", "outClassNames", "inDirPath", "inStreamPath", " inDirName", "inLineHandle", "inStreamUrl", " inFilePath", " inDirHandle", "inFilesNames", " inFileLine", "inStreamNames", "inFilesPath", "inFileUrl", "outClassUrl", "inFilesName", "outFileNames", "inFileHandle", "inPlaceHandle", "inPlaceName", "inFileNames", "inFilePath", "inDirLine", " inFileHandle", "inClassUrl", " inDirPath", "inClassName", "outFileUrl", "inClassNames", "outFilePath", "inFileLine", "inFilesUrl"], "outFileName": ["outDirectoryName", "outputDirPath", "outFullFile", "outFileFile", "outDirPath", "outFullName", "outFileSize", "outDirName", "outDirectoryPath", "outDirectoryFile", "outputDirSize", "outputFileFile", "outputDirFile", "outputFileSize", "outputDirName", "outputFilePath", "outDirSize", "outDirectorySize", "outFullPath", "outDirFile", "outFilePath", "outputFileName", "outFullSize"], "f": ["p", "fp", "xf", "file", "m", "stream", "d", "x", "rf", "h", "F", "http", "fo", "l", "fr", "fd", "fa", "e", "fb", "t", "fl", "form", "fc", "k", "z", "input", "aff", "bf", "fe", "arf", "fi", "fs", "conf", "w", "g", "a", "b", "v", "feed", "inf", "df", "af"], "T": ["TG", "Z", "P", "TT", "O", "A", "Length", "Len", "S", "WT", "B", "TA", "LT", "TB", "F", "X", "DT", "I", "K", "TS", "t", "E", "CT", "TX", "IP", "Ts", "Int", "G", "D", "PT", "Time", "U", "Y", "V", "H", "GT", "RT", "Port", "Q", "W", "N", "TI", "int", "Tu", "NT"], "L": ["Z", "P", "SL", "LM", "O", "LB", "S", " l", "B", "TL", "LI", "LP", "We", "Line", "LT", "DL", "J", "CL", "LR", "F", "l", "dL", "I", "K", "LL", "BL", "E", "XL", "LU", "G", "FL", "D", "LA", "IL", "V", "LS", "H", "RL", "NL", "ML", "Lu", "Q", "W", "N", "LC", "EL", "LE", "VL"], "i": ["il", "p", "it", "o", "iq", "ui", "li", "id", "ci", "lc", "ei", "index", "q", "ar", "m", "d", "ai", "x", "ind", "l", "h", "I", "gi", "ii", "ti", "e", "ir", "t", "ie", "pi", "di", "xi", "k", "z", "input", "ic", "a", "g", "j", "cl", "b", "v", "ip", "u", "iw", "n", "io", "int", "si", "iu"], "R": ["P", "O", "A", "CR", "WR", "KR", "S", "JR", "B", "Ra", "MR", "RA", "AR", "RE", "RR", "Run", "LR", "F", "X", "Ro", "K", "I", "BR", "Gr", "ER", "RP", "RW", "J", "Rs", "E", "Rec", "NR", "RH", "Right", "DR", "RO", "TR", "D", "G", "Rh", "OR", "U", "Y", "GR", "RS", "Cl", "H", "V", "RT", "RG", "Q", "W", "N", "SR", "Re", "Res", "RM", "RC", "Range", "Role"], "C": ["Com", "CC", "P", "O", "Cr", "CR", "CF", "A", "From", "SC", "CS", "There", "S", "B", "Cs", "CI", "YC", "DC", "CL", "Code", "CM", "WC", "F", "K", "X", "I", "CV", "Sc", "Ch", "Rs", "CU", "E", "CT", "CNN", "VC", "D", "G", "NC", "EC", "MC", "Custom", "U", "Count", "Y", "CA", "Or", "Cl", "V", "H", "Co", "Case", "Channel", "Cu", "Size", "Context", "Q", "W", "N", "You", "CE", "Con"], "M": ["Mo", "Z", "P", "O", "LM", "A", "MF", "S", "MN", "AM", "B", "Ms", "m", "VM", "J", "CL", "CM", "F", "X", "I", "DM", "K", "Man", "IM", "E", "MM", "Mode", "D", "G", "MS", "Min", "MD", "MC", "Mon", "U", "Y", "H", "V", "MT", "Size", "MB", "Mc", "NM", "Q", "W", "N", "RM", "FM"], "size": ["sn", "case", "S", "sc", "m", "max", "position", "core", "member", "scale", "sh", "mini", "mode", "empty", "shape", "large", "ize", "SIZE", "G", "sec", "z", "cm", "Y", "w", "cl", "length", "sized", "sum", "six", "small", "Size", "number", "capacity", "loc", "N", "W", "content", "n", "si"], "emptySpace": [" emptyLine", "emptySample", "EmptySand", "emptyCase", "nicSp", "execSp", "noneSand", "originalspace", "filledSpace", "errorSp", "emptyShipping", "openLine", "brokenSpace", "nicPlace", "EmptySpread", "execSpace", "execSpread", "brokenCase", "fullSpace", "EmptyPlace", "emptySp", "errorSpace", "EmptyLine", "EmptyCase", "brokenSpread", "emptyPlace", "emptyLine", "openRoom", "noneSp", "EmptyService", "equalSp", "activeSpace", "filledSp", "missingShipping", "originalSp", " emptySample", "Emptyspace", "equalSpace", "emptyspace", "originalLine", "nicSpace", "nonePlace", "nicCase", "missingSp", "exclusiveLine", "errorSand", "EmptySpace", "EmptySample", "EmptyRoom", "missingSpace", " emptyService", "errorPlace", "EmptySp", "brokenSp", "fullSp", " emptyShipping", "fullShipping", "equalService", "originalSpace", "emptySand", "execPlace", " emptyRoom", "openSp", "EmptyShipping", "fullLine", "filledShipping", "exclusiveSample", "activespace", "emptyService", "noneSpace", "brokenPlace", "exclusiveSpace", " emptyspace", "exclusiveSp", "openSpace", "emptySpread", "emptyRoom", " emptySp", "activeSp"], "out": ["it", "timeout", "response", "all", "query", "list", "user", "qa", "doc", "name", "parent", "ex", "bin", "lib", "no", "key", "pre", "output", "z", "part", "match", "w", "this", "script", "page", "io", "full", "init", "version", "multi", "again", "external", "data", "end", "trial", "conn", "window", "diff", "number", "cmd", "n", "int", "exp", "token", "p", "bit", "up", "pool", "copy", "at", "file", "function", "d", "flat", "client", "t", "temp", "post", "line", "call", "error", "word", "option", "err", "ref", "off", "o", "new", "outs", "channel", "null", "ext", "point", "raw", "cache", "obj", "goal", "url", "co", "static", "Out", "OUT", "sum", "string", "block"], "r": ["err", "p", "rb", "br", "ra", "range", "rc", "q", "ar", "m", "ro", "kr", "h", "cr", "ru", "right", "nr", "ir", "ur", "rr", "k", "rg", "rn", "j", "re", "b", "v", "sr", "u", "rs", "er", "yr"], "c": ["cu", "p", "ci", "cc", "col", "cf", "lc", "nc", "oc", "q", "m", "x", "arc", "l", "y", "cr", "e", "code", "ce", "ec", "k", "z", "cat", "ic", "cm", "w", "cl", "g", "cd", "b", "v", "u", "n", "cs", "ct", "pc", "ac", "cy"], "result": ["err", "response", "new", "res", "list", "score", "entry", "text", "success", "card", "default", "data", "cost", "final", "ret", "back", "trial", "dict", "output", "match", "url", "Result", "diff", "page", "RET", "results", "source"]}}
{"code": "__author__ = 'Jeffrey'\\n  \\n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.in\"\\n  outFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.out\"\\n  \\n  \\n  def parseInput(f):\\n      T = int(f.readline())\\n      L = []\\n  \\n      for i in range(T):\\n          picks = []\\n          cards = []\\n          for j in range(2):\\n              picks.append( int(f.readline()))\\n              tempL = []\\n              for k in range(4):\\n                  tempL.append( [int(j) for j in f.readline().split()])\\n              cards.append(tempL)\\n          L.append((picks, cards))\\n  \\n      return T, L\\n  \\n  \\n  def performTrick(picks, cards):\\n      matchFound = False\\n      matchedCard = None\\n      for card in cards[0][picks[0] - 1]:\\n          possibleMatch = card in cards[1][picks[1] - 1]\\n          if possibleMatch and matchFound:\\n              return \"Bad magician!\"\\n          elif possibleMatch:\\n              matchFound = True\\n              matchedCard = card\\n      if matchFound:\\n          return matchedCard\\n      else:\\n          return \"Volunteer cheated!\"\\n  \\n  \\n  def playGame(T,L):\\n      for i in range(T):\\n          result = performTrick(L[i][0], L[i][1])\\n          yield \"Case #\" + str(i + 1) + \": \" + str(result)\\n  \\n  \\n  if __name__==\"__main__\":\\n      iF = open(inFileName, 'r')\\n      T, L = parseInput(iF)\\n      iF.close()\\n  \\n      oF = open(outFileName, \"wb\")\\n      for out in playGame(T, L):\\n          oF.write(bytes(out + \"\\n\",'utf-8'))\\n      oF.close()\\n", "substitutes": {"__author__": ["__Author____", "__creator____", "__version__", "__author____", " __version____", " __author____", "__Author__", " __version__", "__version____", "__creator__"], "inFileName": ["configFilenameName", "infilename", "diffFilenameN", "diffFileName", "inModuleNames", "inFilenamename", "infileNames", "configFilenameType", "infileType", "inFilenameDie", "inDirectoryN", "configFileType", "inFilenameType", "inModuleType", "inPathDie", "diffFilenameDie", "configFilenamename", "inDirectoryDie", "inFilename", "diffFilenameName", "inPathN", "configFileNames", "diffFileDie", "infileName", "configFilename", "inFileType", "inDirectoryName", "inModulename", "inFileDie", "inFileNames", "inFileN", "configFileName", "configFilenameNames", "diffFileN", "inFilenameN", "inModuleName", "inFilenameNames", "inFilenameName", "inPathName"], "outFileName": ["outFilename", "OutDirFile", "outFilenamename", "outfileNum", "exFilenameNum", "outFileFile", "outDirPath", "OutFilename", "OutFilePath", "outfilePath", "OutDirName", "outDirName", "outFunctionFile", "OutDirname", "outFunctionName", "exFilenameEnd", "outFunctionPath", "outDirname", "exFilenameName", "exFilePath", "exFilenamePath", "outFilenamePath", "exFileNum", "OutDirPath", "outFilenameFile", "outFilenameEnd", "outFileEnd", "outfileEnd", "OutFileName", "outDirEnd", "outFilenameNum", "outFileNum", "exFileEnd", "outFunctionname", "exFileName", "outDirFile", "outFilenameName", "OutFileFile", "outFilePath", "outDirNum", "outfileName"], "f": ["p", "fp", "lf", "files", "of", "path", "xf", "file", "m", "stream", "d", "x", "rf", "F", "fn", "fo", "l", "found", "fr", "fa", "fd", "c", "e", "fb", "t", "fl", "form", "fw", "fc", "self", "buff", "handler", "z", "conf", "fe", "fi", "fs", "w", "g", "v", "b", "sf", "feed", "fen", "io", "inf", "n", "df", "ff"], "T": ["TG", "Z", "Test", "TT", "O", "P", "A", "R", "Temp", "Length", "WT", "S", "TW", "B", "TL", "TA", "Input", "LT", "TB", "F", "X", "DT", "I", "K", "TIME", "t", "TS", "UT", "E", "CT", "Total", "TH", "Ts", "Tu", "G", "M", "D", "PT", "Two", "U", "Y", "C", "V", "H", "Q", "Part", "W", "N", "TI", "TF", "Time", "NT"], "L": ["Z", "O", "P", "A", "PL", "lf", "R", "SL", "LM", "LB", "Len", "lines", " l", "B", "lc", "TL", "Left", "LI", "LP", "Line", "LT", "ll", "DL", "CL", "Lo", "J", "LR", "F", "l", "dL", "X", "I", "K", "LL", "BL", "E", "XL", "Li", "G", "M", "D", "FL", "letters", "LA", "IL", "cl", "C", "V", "LS", "left", "line", "NL", "Lu", "Card", "ML", "W", "List", "N", "LC", "Long", "EL", "VL"], "i": ["bis", "p", "it", "o", "iq", "ui", "li", "start", "chi", "ci", "ei", "index", "oi", "init", "name", "ji", "ini", "phi", "ai", "multi", "x", "bi", "ind", "l", "I", "gi", "y", "ri", "ii", "c", "ti", "e", "ir", "eni", "t", "yi", "zi", "ie", "uri", "ik", "pi", "xi", "di", "ni", "uni", "a", "ib", "v", "ip", "iw", "u", "qi", "n", "io", "int", "si", "iu"], "picks": ["cicks", "picked", "prushes", "hicks", "prarks", "spips", "tickers", "hicked", "licks", "pices", "pickers", "lics", "vics", "sicks", "tips", "lickers", "Pick", " picking", "sickets", "parks", " pickets", " pips", "spices", "prickets", "hick", " pickers", "spics", "spickers", "vicks", " parks", "nicks", "lices", " pushes", "spicks", "pricks", "hickers", "Picks", "ticks", "picking", "pips", "cick", "pushes", "pick", "cics", "Pips", "Pickers", " pics", "nicking", "cips", "pics", "vices", "licked", "vickers", "nics", "nickers", "tick", "spicking", "lick", "cickers", "sushes", "pickets", "Picked", "sarks"], "cards": ["caps", "bands", "ards", "outs", "files", "ls", "lines", "cf", "lc", "lists", "layout", "pieces", "limits", " Cards", "books", "styles", "codes", "friends", "games", "icks", "strings", "l", "fields", "stars", "phones", "cuts", "names", "lv", "cycles", "players", "cons", "checks", "events", "packs", "videos", "rules", "quarters", "clips", "cats", "cell", "lights", "holes", "letters", "groups", "services", "liners", "cl", "left", "apes", "words", "Contents", "cells", "balls", "Lu", "Card", "photos", "comments", "members", "charges", "cas", "sticks", "ventures", "cases", "breaks"], "j": ["p", "it", "li", " dj", "ch", "js", "jc", " l", "index", " n", "jp", "m", "ji", "d", "J", "x", "kj", "point", "oj", "l", "y", "ii", "c", "code", "jl", "aj", "ie", "xi", "job", "z", "cell", "jj", "r", "ja", "a", "ij", "dj", "g", "left", " jo", "b", "v", " c", "line", "jam", "ip", "u", "n", "int", "uj"], "tempL": ["temI", " tempI", "testN", "tempCL", "temB", "testL", "tempI", "testCL", "teml", "tmpN", "templ", "tempN", " tempB", "newl", "temN", "tmpUL", "tempO", "TempN", "temL", "newL", " templ", " tempN", " tempO", "TempI", " tempCL", "tmpCL", "tmpL", "TempL", "testUL", " tempUL", "tempUL", "newB", "newO", "temO", "Templ", "tempB"], "k": ["o", "ci", "ki", " n", "q", "ji", "jack", "d", "ai", "J", "kj", "h", "y", "c", "ak", "ik", "ky", "z", "ja", "ka", "g", "b", "kk", "jo", "ijk", "km", "ke"], "matchFound": ["MatchFind", "caseFound", "casefound", "searchFind", "matchMade", "MatchFound", "cardFound", "cardFind", " matchfound", "resultFound", "matchfound", " matchFind", "Matchfound", "resultMade", "searchFound", "resultFind", "matchFind", " matchMade", "searchMade", "cardfound"], "matchedCard": ["atchedCard", "checkedGame", "checkedcard", "atchedCase", "protectedCase", "protectedCard", "affectedCode", "atchedcard", "matchedCase", " matchedCase", "protectedcard", "affectedCard", " unmatchedCase", " matchedcard", "successfulGame", "affectedCase", "matchedcard", " matchedGame", "successfulCard", "matchedCode", "successfulcard", " matchedCode", " unmatchedCard", "matchedGame", "checkedCard", " unmatchedCode"], "card": ["word", "comment", "case", "id", "contact", "list", "cf", "cand", "catch", "index", "event", "board", "null", "point", "coord", "custom", "character", "default", "c", "play", "code", "back", "game", "draw", "cell", "cart", "check", "match", "cat", "number", "Card", "ard", "pattern", "char", "Match", "string", "bug", "cas", "letter", "style", "pixel", "cross", "coll"], "possibleMatch": ["possiblyCapture", "possibleSearch", "PossibilityMatch", "possibilityCapture", "spossibilityCapture", "possiblyMatch", "spossibleCapture", "PossibilitySearch", "possiblySearch", "spossibleMatch", "possibleCase", "permanentCapture", "possibilityMat", "possibilityMatch", "permanentMatch", "possibilitySearch", "Possibilitymatch", "pableMat", "PossibleMatch", "PossibleCapture", "possibleMat", "PossibleMat", "possibleCapture", "PossibilityMat", "PossibilityCapture", "pableCapture", "possiblyMat", "PossibleSearch", "Possiblematch", "spossibleCase", "possibilitymatch", "possiblymatch", "possiblematch", "possibilityCase", "spossibilityCase", "permanentCase", "possiblyCase", "pableMatch", "spossibilityMatch"], "result": ["err", "desc", "response", "comment", "res", "case", "val", "valid", "event", "rc", "our", "text", "success", "grade", "results", "message", "successful", "default", "data", "answer", "ret", "status", "dict", "output", "ner", "r", "match", "value", "Result", "sum", "diff", "complete", "compl", "string", "error", "test", "json"], "iF": [" iGF", "fW", "iFM", "oif", "yiFs", "pf", " iFs", "xiFs", "iMF", "pW", "iW", "xiF", "oiMF", "If", "yiMF", "pFM", "IFS", " iMF", "yiGF", "xif", "iGF", "oiFS", "fF", "IF", "xiFS", "yiF", "pF", "oiF", "iFs", "oiGF", "IFs", "iFS", "fFM", " iW", " iFM", "oiFs", "ff"], "oF": ["doV", " oGF", "of", "doGF", " of", "oGF", " oV", "koO", " oEF", "Of", " oO", "lM", "OV", "oV", "doF", "oM", "lELF", "koV", "lEF", " oM", "iV", "lF", "oELF", "iGF", "OF", " oELF", "OO", "oO", "eM", "eELF", "eEF", "eF", "doB", "kof", "oB", " oB", "oEF", "iB", "koF"], "out": ["err", "it", "prefix", "new", "all", "outs", "of", "IN", "yout", "m", "example", "text", "again", "ex", "get", "c", "update", "data", "table", "temp", " output", "game", "draw", "output", "obj", "set", "Output", "template", "tmp", "match", "Out", "buffer", "OUT", "this", "In", "b", "s", "sum", "v", "you", "io", "int", "net", "word", "source"]}}
{"code": " \\n  \\n  def print_basic_board(no_mine, r, c):\\n      printed_c = False\\n      for row in range(0, r):\\n          line = []\\n          for column in range(0, c):\\n              if printed_c:\\n                  if no_mine > 0:\\n                      line.append(\".\")\\n                      no_mine -= 1\\n                  else:\\n                      line.append(\"*\")\\n              else:\\n                  line.append(\"c\")\\n                  no_mine -= 1\\n                  printed_c = True\\n          print \"\".join(line)\\n  \\n  \\n  def print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c):\\n      printed_c = False\\n      for row in range(0, r):\\n          line = []\\n          for column in range(0, c):\\n              if printed_c:\\n                  if row < no_mine_row and column < no_mine_column:\\n                      line.append(\".\")\\n                  elif rest_no_mine_for_column > 0 and column == no_mine_column:\\n                      line.append(\".\")\\n                      rest_no_mine_for_column -= 1\\n                  elif rest_no_mine_for_row > 0 and row == no_mine_row:\\n                      line.append(\".\")\\n                      rest_no_mine_for_row -= 1\\n                  else:\\n                      line.append(\"*\")\\n              else:\\n                  line.append(\"c\")\\n                  printed_c = True\\n          print \"\".join(line)\\n  \\n  \\n  def solve_case(r, c, m, case_number):\\n      print \"Case #%d:\" % case_number\\n      no_mine = r * c - m\\n      if r < 2 or c < 2 or no_mine == 1:\\n          print_basic_board(no_mine, r, c)\\n      else:\\n          no_mine_row_max = int(math.ceil(float(no_mine) / 2))\\n          if no_mine_row_max > r:\\n              no_mine_row_max = r\\n          for no_mine_column in range(2, int(math.ceil(float(no_mine) / 2)) + 1):\\n              if no_mine_column > c:\\n                  break\\n              for no_mine_row in range(2, no_mine_row_max + 1):\\n                  rest_no_mine = no_mine - (no_mine_column * no_mine_row)\\n                  if rest_no_mine < 0:\\n                      continue\\n                  if rest_no_mine == 1:\\n                      continue\\n  \\n                  if rest_no_mine == 0:\\n                      print_board(no_mine_row, no_mine_column, 0, 0, r, c)\\n                      return\\n                  if rest_no_mine <= no_mine_row and no_mine_column < c:\\n                      print_board(no_mine_row, no_mine_column, 0, rest_no_mine, r, c)\\n                      return\\n                  if rest_no_mine <= no_mine_column and no_mine_row < r:\\n                      print_board(no_mine_row, no_mine_column, rest_no_mine, 0, r, c)\\n                      return\\n  \\n                  if rest_no_mine > 3 and no_mine_column < c and no_mine_row < r:\\n                      for rest_no_mine_for_row in range(2, no_mine_column):\\n                          rest_no_mine_for_column = rest_no_mine - rest_no_mine_for_row\\n                          if rest_no_mine_for_column < no_mine_row:\\n                              print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c)\\n                              return\\n  \\n          print \"Impossible\"\\n  \\n  r_file = sys.stdin\\n  \\n  if len(sys.argv) > 1:\\n      r_file = open(sys.argv[1], 'r')\\n  \\n  total_cases = r_file.readline()\\n  for case_number in range(1, int(total_cases) + 1):\\n      values = map(int, r_file.readline().split(' '))\\n      solve_case(values[0], values[1], values[2], case_number)\\n  \\n", "substitutes": {"no_mine": [" no_mining", "non_mine", "noFmining", "noAmining", "remote_powder", "remote_mine", "nice_mine", "niceFmining", "no_download", "remote67wine", " no_write", "no_brown", "no_powder", "remote_wine", "no_vale", "no__mining", " no_message", "noAselect", "no_min", "no_mining", "no_charge", "nice_care", "no__min", " no_min", "no67brown", "no__pine", " no_select", " no_pine", "noFmine", "noAmine", "nice_download", "no_grade", "nice_mining", "non_grade", "so_grave", "remote67mine", "no_wine", " no_wine", "No_mine", "niceFdownload", "no67mine", "so_mine", "No_min", "no_select", "no_write", "no_grave", "remote67brown", " no_powder", "non_vale", "No_pine", "so_min", "no__select", " no_grade", "remote67powder", "no67powder", "non_mining", "noApine", "No_mining", "niceFmine", "remote_brown", "so_charge", "no__charge", "no_pine", "no67wine", "no__mine", "no_care", "no_message", "noFdownload", "no__grave", "noFcare", "niceFcare"], "r": ["err", "p", "o", "rb", "R", "br", "dr", "ra", "range", "rc", "q", "ar", "ro", "mr", "d", "kr", "x", "h", "l", "ru", "f", "cr", "rd", "fr", "nr", "right", "e", "ir", "t", "ur", "i", "rr", "nor", "k", "rg", "a", "w", "g", "j", "sr", "re", "b", "v", "hr", "s", "u", "pr", "lr", "n", "rs", "er"], "c": ["cu", "p", "ci", "ch", "cc", "col", "cf", "lc", "dc", "nc", "rc", "cn", "q", "d", "x", "h", "l", "y", "f", "cp", "cr", "uc", "e", "t", "rec", "i", "ce", "ec", "k", "z", "con", "cm", "co", "w", "cl", "g", "C", "s", "b", "v", "u", "ca", "n", "cs", "mc", "pc", "ac", "cy"], "printed_c": ["worked_e", "printed67m", "printedLogcp", "printedJrec", "printed_ec", "printedTher", "led_cp", "printed_case", "printedptc", "led_case", "printed_cp", " printed_cn", "printedThee", "printed67e", "printed67cu", " printed_line", "picked67cu", "printedThelc", " printed_k", "printed67pc", "printedlycu", "printed_rec", "printed_m", "printed67rec", "worked_c", " printed_lc", "printed_ct", "printedlyct", "picked67c", "printedLogc", "printed67r", "printed_cu", "printedJf", "printedTheline", "printed_line", "printedJcu", "printedlyrec", "printed67c", "printedLogf", "printed_cn", "printed67ec", "printedptlc", "printed_lc", "led_f", "printedLogcase", "worked_ec", "picked67ct", " printed_e", "printedlyc", "printedptk", "picked_ct", "printed67ct", "printed_r", "picked_c", "printedJct", "printed_e", " printed_r", "printedJcp", "printedThek", "printed_pc", " printed_m", "printedptline", "printedJc", "picked_cu", "printed_uc", "picked67rec", " printed_uc", "printedJcase", "printed_k", "printedThec", "led_c", "printedThem", "printed_f", "picked_rec", "worked_pc"], "row": ["ref", "rown", "offset", "collection", "array", "ow", "user", "group", "col", "tr", "rank", "month", "range", "index", "run", "rc", "entry", "order", "channel", "ro", "container", "slice", "max", "record", "raw", "cr", "right", "ry", "rew", "key", "batch", "num", "rows", "rect", "year", "round", "roll", "cell", "arrow", "value", "length", "Row", "re", "reader", "block", "page", "ride", "error", "layer"], "line": ["side", "unit", "list", "user", "lc", "ine", "entry", "name", "day", "code", "key", "do", "cle", "inline", "page", "item", "style", "gen", "band", "comment", "stage", "engine", "plan", "db", "live", "body", "lock", "member", "mode", "plugin", "note", "auto", "object", "layer", "li", "lines", "lin", "log", "file", "Line", "record", "message", "grid", "e", "chain", "none", "el", "status", "nl", "cell", "LINE", "cl", "sync", "use", "call", "le", "ne", "word", "lo", "ge", "one", "link", "group", "base", "l", "liner", "rule", "pin", "limit", "server", "model", "block", "sl", "lane", "source", "site"], "column": ["offset", "collection", "four", "unit", "long", "group", "col", "lc", "path", "maximum", "index", "weight", "current", "entry", "width", "channel", "header", "container", "ct", "character", "position", "right", "Column", "day", "member", "year", "attribute", "cell", "sec", "arrow", "initial", "value", "cm", "length", "left", "field", "Row", "number", "const", "block", "page", "section", "minute", "word", "coll", "method"], "no_mine_row": ["no_mining_col", "no_mine64rows", "no_mine67roll", "no_mining_column", "no_mine64rot", "no_mining_cell", "no_mining_entry", "no_mine_roll", "no_mine67row", "no_mine_col", "no_mine67col", "no_mine_rows", "no_mining_rows", "no_mine_rot", "no_mine64column", "no_mine_cell", "no_mining_roll", "no_mining_row", "no_mine_entry", "no_mine67column", "no_mine64row", "no_mining_rot"], "no_mine_column": ["_", "no_mining_position", "all", "no_mineetcurrent", "index", "no_mining_section", "no_mining_cell", "no_mine_col", "no_mine___column", "no_minesrow", "no_mining_current", "match", "no_mining_col", "no_mining_connection", "no_mining_index", "end", "no_mineetrow", "no_mineetcolumn", "no_mine_connection", "no_mine_section", "no_mine_cell", "no_mine___row", "pos", "no_mine_current", "no_mine___col", "no_mineetposition", "config", "no_mine_position", "count", "no_mine_index", "none", "no_minescolumn", "no_mining_row", "no_minescol", "no_mining_column", "no_mine___position", "no_minessection", "s"], "rest_no_mine_for_row": ["rest_no_mine_for_rows", "rest_no_mine_for__column", "rest_no_mine_foraccol", "rest_no_mine_foracentry", "rest_no_mine_for__row", "rest_no_mine_for_col", "rest_no_mine_foracrow", "rest_no_mine_for_entry", "rest_no_mine_for__col", "rest_no_mine_for__rows", "rest_no_mine_foracrows"], "rest_no_mine_for_column": ["rest_no_mine_forallcol", "rest_no_mine_in_col", "rest_no_mine_forallpage", "rest_no_mine_in_row", "rest_no_mine_forallcolumn", "rest_no_mine_for__page", "rest_no_mine_for_cell", "rest_no_mine_for__column", "rest_no_mine_for_page", "rest_no_mine_in_page", "rest_no_mine_in__col", "rest_no_mine_for__row", "rest_no_mine_for_col", "rest_no_mine_in_column", "rest_no_mine_in__row", "rest_no_mine_in__page", "rest_no_mine_for_entry", "rest_no_mine_for__col", "rest_no_mine_in__column", "rest_no_mine_forallrow"], "m": ["mod", "p", "o", "ch", "range", "man", "mr", "d", "x", "h", "y", "l", "f", "cr", "e", "t", "i", "um", "meta", "M", "z", "cm", "w", "g", "mi", "re", "v", "b", "min", "s", "u", "mat", "n", "mc"], "case_number": ["casenumnumber", "result_description", "case_Number", "caseblocktype", "casenumgroup", "resultblockNumber", "resultblocktype", "casenumnum", "resultblocknumber", "caseiddescription", "caseidNumber", " case_category", " case_num", "caseblocknumber", " case_group", "result_type", "casenumcategory", "caseblockgroup", "caseblocknum", "caseblockdescription", "caseblockNumber", "case_description", "case_group", "case_num", "caseblockcategory", "caseidtype", "result_number", "resultblockdescription", "result_Number", "caseidnumber", "case_type", "case_category"], "no_mine_row_max": ["no_mine_rows_col", "no_mine_row_min", "no_mine_rows_size", "no_mine_row_col", "no_mine_rows_min", "no_mine_rows_max", "no_mine_rowpmin", "no_mine_row_ax", "no_mine_row_size", "no_mine_column_max", "no_mine_rowvmin", "no_mine_rowpax", "no_mine_rowvsize", "no_mine_rows_ax", "no_mine_rowvmax", "no_mine_column_min", "no_mine_column_last", "no_mine_rowpmax", "no_mine_row_last"], "rest_no_mine": ["rest_not_weight", "rest_notvelmate", "rest_not_mine", "rest_not_mining", "rest_not_mate", "rest_no_mate", "rest_notvelweight", "rest_notvelmine", "rest_novelmate", "rest_notvelmining", "rest_no_weight", "rest_novelmining", "rest_no_mining", "rest_novelmine", "rest_novelweight"]}}
{"code": " \\n  def solve_case(answers, arrangements_of_cards, case_number):\\n      first_candidates = arrangements_of_cards[0][answers[0] - 1]\\n      second_candidates = arrangements_of_cards[1][answers[1] - 1]\\n      answer = set(first_candidates) & set(second_candidates)\\n      length_of_answer = len(answer)\\n      if length_of_answer > 1:\\n          print \"Case #%d: Bad magician!\" % case_number\\n      elif length_of_answer < 1:\\n          print \"Case #%d: Volunteer cheated!\" % case_number\\n      else:\\n          print \"Case #%d: %d\" % (case_number, answer.pop())\\n  \\n  r = sys.stdin\\n  \\n  if len(sys.argv) > 1:\\n      r = open(sys.argv[1], 'r')\\n  \\n  total_cases = r.readline()\\n  for case_number in range(1, int(total_cases) + 1):\\n      answers = []\\n      arrangements_of_cards = []\\n      answers.append(int(r.readline()))\\n      arrangements_of_cards.append([])\\n      for row in range(0, 4):\\n          arrangements_of_cards[0].append(map(int, r.readline().split(' ')))\\n      answers.append(int(r.readline()))\\n      arrangements_of_cards.append([])\\n      for row in range(0, 4):\\n          arrangements_of_cards[1].append(map(int, r.readline().split(' ')))\\n      solve_case(answers, arrangements_of_cards, case_number)\\n", "substitutes": {"answers": ["asswerers", "answments", "oldwements", "oldwards", "answters", "ansguerers", "ansswements", "answinaters", "answeors", "ansitters", "ansquers", "answchers", "asswinerers", "answaests", "ansiwers", "answinerers", "answaters", "ansiters", "oldwests", "ansuests", "ansguatters", "inwments", "oldswests", "answeners", "answnments", "answings", "annguings", "answordschers", "answinements", "ansiwaters", "answinments", "ansquests", "answiner", "answinchers", "annwers", "answards", "ansguERS", "asswers", "oldswards", "ansguers", "ansoutters", "answorders", "answsERS", "anwordeners", "annguers", "ansangaders", "ansangters", "ansouters", "asswiners", "answorderers", "partwerers", "ansswests", "asswer", "asswiner", "ansquards", "answordser", "answaerers", "answineners", "anwers", "ansgings", "answnements", "ansgors", "answserers", "partwserers", "asswinchers", "anwer", "inouters", "answaatters", "ansguings", "answordaters", "inoutments", "answelers", "ansgers", "ansitaders", "ansglers", "answaements", "answorder", "asswchers", "inwaders", "ansitments", "inoutaders", "answordeners", "answeers", "inwters", "annwlers", "answordserers", "oldswers", "partwatters", "oldswements", "answordsers", "answatters", "answests", "anwordaters", "answlers", "ansangers", "ansuements", "answnests", "answners", "answsatters", "ansangments", "anwaters", "answinests", "ansuments", "answsers", "ansguors", "answaers", "anworders", "answaards", "oldwers", "partwsERS", "ansiweners", "answiners", "ansquements", "answaders", "ansoutments", "answements", "ansswards", "answaERS", "partwsers", "ansuers", "anworder", "ansiwer", "answeings", "ansgulers", "annwings", "ansoutaders", "answerers", "answors", "answordchers", "annwors", "inwers", "inoutters", "annguors", "partwsatters", "partwers", "anweners", "answERS", "anngulers", "partwERS", "ansswers"], "arrangements_of_cards": ["arrangements_of__cases", "arrangements_of_files", "arrangements_of_cells", "arrangements_of_books", "arrangements_of___files", "arrangements_of___cards", "arrangements_of2cards", "arrangements_of_games", "arrangements_of_pieces", "arrangements_of_bags", "arrangements_of_fields", "arrangements_of_lines", "arrangements_of__cards", "arrangements_of___cells", "arrangements_of2card", "arrangements_of__bags", "arrangements_of_card", "arrangements_of2games", "arrangements_of_balls", "arrangements_of__games", "arrangements_of_cases", "arrangements_of___cases", "arrangements_of2pieces"], "case_number": [" case_no", "case_zero", " case_string", "case54number", "case_notation", "example64number", "case54num", "example_language", " case_position", "case___number", "chance_num", "case___zero", "chance_type", "chance_number", "case_no", "case_type", "example_number", "case_position", " case_size", "example64language", "case___no", "example_zero", "case___code", "case24body", " case_type", "Case_number", "example64code", "case_body", "case_string", "case24type", "caseqnumber", "case54numbered", "case24number", "case64code", "case_size", "case64language", " case_num", "case_code", "case_reason", "case___description", "caseqzero", "case54reason", "case_description", "case_num", "case___string", "case_language", " case_description", "case64zero", "case24num", "example_code", "case___language", "Case_reason", "chance_body", "caseqcode", "case64number", "example64zero", " case_notation", "caseqlanguage", "case_numbered", "Case_numbered", "Case_num"], "first_candidates": ["first_guidate", "first_pointidates", "first_Candites", "first_Candids", "first_candids", "first_candases", "first_charidate", "first_charites", "first_chareters", "first_pointeters", "first_Candeters", "first_candidate", "first_Candases", "first_charids", "first_candeters", "first_pointidate", "first_Candidate", "first_pointites", "first_guids", "first_guidates", "first_Candidates", "first_guases", "first_candites", "first_charases", "first_charidates"], "second_candidates": ["second_anchidate", "second_anchents", "second_centidates", "second_Candidates", "second_intents", "second_Candares", "second\u00b7canders", "second_canders", "second_centidate", "second_argers", "second\u00b7candares", "second_centers", "second_intidates", "second\u00b7candidates", "second\u00b7centares", "second_Canders", "second\u00b7centers", "second_candidate", "second_Candents", "second_anchers", "second\u00b7candidate", "second_argidate", "second_Candidate", "second_argidates", "second_candents", "second_intidate", "second_inters", "second_candares", "second\u00b7centidates", "second_centares", "second_anchidates", "second\u00b7centidate", "second_argares"], "answer": ["duration", "Answer", "conference", "response", "array", "audio", "image", "swers", "comment", "address", "average", "evidence", "score", "document", "name", "order", "example", "cover", "grade", "answered", "message", "area", "question", "data", "edge", "assembly", "equality", "music", "argument", "archive", "cache", "output", "issue", "video", "match", "size", "support", "settings", "username", "length", "field", "gallery", "number", "memory", "string", "reply", "result", "distance", "error", "word", "results"], "length_of_answer": ["length_of___number", "length_of_number", "length_of_video", "length_of67question", "length_of___issue", "length_of_Answer", "length_of_support", "length_of___question", "length_of_question", "length_of_issue", "length_of___answer", "length_of67support", "length_of67video", "length_of67answer"], "r": ["err", "p", "rb", "R", "br", "res", "dr", "tr", "rc", "ar", "gr", "m", "ro", "mr", "kr", "d", "h", "l", "ru", "rl", "f", "wr", "cr", "rd", "c", "fr", "nr", "str", "parser", "ir", "t", "e", "right", "rr", "rar", "rh", "rt", "rg", "rx", "w", "g", "s", "sr", "b", "hr", "reader", "pr", "rw", "rs", "er", "result"], "total_cases": ["max_classes", "max_cases", "max_lines", "total_devices", "total_classes", "total00cases", "total00classes", "max_tests", " total_lines", "totalaldevices", "total00lines", "total_lines", " total_tests", "total_tests", "totalallines", "total00tests", "totalaltests", "totalalcases", " total_devices"], "row": ["rown", "ver", "ow", "user", "group", "col", "month", "run", "range", "entry", "order", "ro", "max", "by", "f", "right", "rew", "ward", "no", "key", "num", "win", "rows", "round", "cell", "arrow", "match", "value", "column", "Row", "inter", "line", "diff", "block", "page", "bug", "error"]}}
{"code": " \\n  \\n  DX = (-1, -1, -1, 0, 1, 1, 1, 0)\\n  DY = (-1, 0, 1, 1, 1, 0, -1, -1)\\n  \\n  \\n  def compute(R, C, M):\\n      if M == 0:\\n          return empty(R, C)\\n      free = R * C - M\\n      if free == 1:\\n          return single_free(R, C)\\n      if R == 1:\\n          return single_row(C, M)\\n      if C == 1:\\n          return single_column(R, M)\\n      if R == 2:\\n          return two_rows(C, M)\\n      if C == 2:\\n          return two_columns(R, M)\\n      if free in (2,3,5,7):\\n          return \"\\nImpossible\"\\n      return at_least_three(R, C, M)\\n  \\n  \\n  def make_board(R, C, default='.'):\\n      return [[default for j in xrange(C)] for i in xrange(R)]\\n  \\n  \\n  def to_string(board):\\n      s = \"\"\\n      for i in xrange(len(board)):\\n          s += '\\n' + ''.join(board[i])\\n      return s\\n  \\n          \\n  def empty(R, C):\\n      board = make_board(R, C)\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def single_free(R, C):\\n      board = make_board(R, C, default='*')\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def single_row(C, M):\\n      board = make_board(1, C)\\n      board[0][0] = 'c'\\n      for i in xrange(M):\\n          board[0][C - 1 - i] = '*'\\n      return to_string(board)\\n  \\n  \\n  def single_column(R, M):\\n      board = make_board(R, 1)\\n      board[0][0] = 'c'\\n      for i in xrange(M):\\n          board[R - 1 - i][0] = '*'\\n      return to_string(board)\\n  \\n  \\n  def two_rows(C, M):\\n      if M % 2 != 0:\\n          return \"\\nImpossible\"\\n      if 2 * C - M < 4:\\n          return \"\\nImpossible\"\\n      board = make_board(2, C)\\n      for i in xrange(M / 2):\\n          board[0][C - 1 - i] = '*'\\n          board[1][C - 1 - i] = '*'\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def two_columns(R, M):\\n      if M % 2 != 0:\\n          return \"\\nImpossible\"\\n      if 2 * R - M < 4:\\n          return \"\\nImpossible\"\\n      board = make_board(R, 2)\\n      for i in xrange(M / 2):\\n          board[R - 1 - i][0] = '*'\\n          board[R - 1 - i][1] = '*'\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def finalize(R, C, M, board):\\n      mines = 0\\n      for i in xrange(R):\\n          for j in xrange(C):\\n              if board[i][j] == '0':\\n                  continue\\n              empty = False\\n              for d in xrange(8):\\n                  if i + DX[d] < 0 or i + DX[d] >= R or j + DY[d] < 0 or j + DY[d] >= C:\\n                      continue\\n                  if board[i + DX[d]][j + DY[d]] == '0':\\n                      empty = True\\n                      break\\n              if empty:\\n                  board[i][j] = '.'\\n              else:\\n                  board[i][j] = '*'\\n                  mines += 1\\n      for i in xrange(R):\\n          for j in xrange(C):\\n              if board[i][j] == '0':\\n                  board[i][j] = '.'\\n      board[0][0] = 'c'\\n      if mines != M:\\n          sys.stderr.write(\"mines:%s expected:%s\\n\" % (mines, M))\\n      return to_string(board)\\n  \\n  \\n  def at_least_three(R, C, M):\\n      board = make_board(R, C)\\n      board[0][0] = '0'\\n      free = R * C - M\\n      count = 4\\n      if count == free:\\n          return finalize(R, C, M, board)\\n      board[0][1] = '0'\\n      count += 2\\n      if count == free:\\n          return finalize(R, C, M, board)\\n      board[1][0] = '0'\\n      count += 2\\n      if count == free:\\n          return finalize(R, C, M, board)\\n      for j in xrange(2, C - 1):\\n          if count + 2 > free:\\n              break\\n          board[0][j] = '0'\\n          count += 2\\n      for i in xrange(2, R - 1):\\n          if count + 2 > free:\\n              break\\n          board[i][0] = '0'\\n          count += 2\\n      for i in xrange(1, R - 1):\\n          for j in xrange(1, C - 1):\\n              if count == free:\\n                  return finalize(R, C, M, board)\\n              board[i][j] = '0'\\n              count += 1\\n      sys.stderr.write(\"empty board?\\n\")\\n      return finalize(board)\\n  \\n  \\n  def parse():\\n      R, C, M = map(int, sys.stdin.readline().strip().split())\\n      return R, C, M\\n  \\n  \\n  if __name__ == \"__main__\":\\n      sys.setrecursionlimit(100000)\\n      T = int(sys.stdin.readline().strip())\\n      for i in xrange(T):\\n          sys.stderr.write(\"case:%s\\n\" % (i + 1))\\n          data = parse()\\n          result = compute(*data)\\n          print \"Case #%d: %s\" % (i + 1, result)\\n", "substitutes": {"DX": ["XP", "YD", "IV", "EX", "ID", "DS", "DL", "WD", "DA", "DC", "CD", "DT", "DD", "IE", "CT", "XL", "TH", "DE", "ONE", "IP", "DR", "D", "MD", "UX", "DI", "DOM", "XY", "MX"], "DY": [" DYY", "Py", "dy", "Dy", "PXY", "DYY", " DXY", "PYY", "dY", " Dy", "dYY", "PY", "DXY", "dXY"], "R": ["CC", "A", "WR", "MR", "RA", "CL", "RR", "RN", "K", "Rs", "E", "RH", "DR", "Order", "OR", "Rh", "RS", "Re", "Res", "RM", "Br", "Range", "KR", "JR", "B", "Ra", "Model", "RP", "c", "D", "G", "Reader", "Y", "Cl", "H", "RL", "SR", "CR", "S", "AR", "Run", "LR", "F", "X", "I", "ER", "RW", "All", "IR", "NR", "RO", "U", "V", "RG", "Q", "W", "RF", "P", "O", "RE", "L", "J", "BR", "Right", "r", "GR", "N", "RC"], "C": ["CC", "P", "O", "A", "SC", "CW", "Cr", "CR", "CS", "S", "B", "CI", "YC", "DC", "L", "CL", "CM", "AC", "F", "X", "K", "I", "WC", "CV", "c", "Ch", "CU", "E", "CT", "CN", "CNN", "CO", "VC", "D", "G", "EC", "MC", "r", "CAR", "U", "Count", "Y", "CA", "Cl", " c", "V", "H", "Cu", "Size", "Q", "Cor", "W", "N", "CE"], "M": ["CC", "Z", "_", "A", "all", "MR", "VM", "CL", "K", "DM", "E", "MD", "OR", "NM", "MX", "RM", "AM", "MN", "B", "m", "CM", "IM", "end", "D", "G", "Y", "H", "LM", "S", "F", "X", "I", "Man", "str", "All", "num", "MM", "MI", "OM", "U", "V", "MB", "Q", "W", "O", "P", "MF", "J", "L", "Me", "DC", "MS", "MC", "r", "g", "N"], "free": [" Free", "O", "FE", "fre", "all", "valid", "UN", "len", "MR", "m", "function", "null", "random", "float", "x", "true", "max", "F", "f", "fee", "right", "c", "e", "only", "FREE", "E", "no", "NO", "used", "none", "ME", "um", " unused", "MS", "OR", "con", "fe", "left", "allow", "FR", "complete", "use", "de", "min", "Re", "MW", "n", "void", "Free", "error"], "default": ["p", "desc", "switch", "new", "case", "id", "label", "enter", "dc", "current", "Default", "index", "name", "func", "null", "example", "second", "float", "arc", "x", " defaults", "parent", "f", "custom", "c", "member", "str", "no", "FAULT", "none", "DE", "description", "self", "D", "arrow", "initial", "value", "standard", "length", "design", "de", "common", "void", "n", "df", "slice", "option"], "j": ["ui", "ci", "ei", "iii", "jac", "ice", "ji", "ai", "bi", "ri", "gi", "ti", "gh", "xi", "di", "pi", "abi", "go", "je", "ni", "fi", "co", "ij", "g", "ib", "ct", "ac"], "i": ["p", "it", "o", "ui", "li", "id", "ci", "col", "ei", "m", "ini", "ai", "multi", "x", "bi", "phi", "ind", "l", "y", "f", "I", "gi", "h", "iv", "ii", "c", "ti", "e", "ir", "yi", "ie", "xi", "pi", "di", "k", "z", "r", "value", "a", "g", "mi", "b", "v", "ip", "u", "iw", "qi", "n", "io", "si", "int", "iu", "slice", "one"], "board": ["stroke", "lay", "image", "node", "case", "list", "lc", "layout", "index", "entry", "head", "player", "boards", "uc", "code", "ward", "frame", "draw", "join", "control", "ban", "way", "buffer", "bug", "clean", "cross", "comment", "plan", "view", " boards", "body", "menu", "card", "core", "c", "ack", "table", "back", "form", "hole", "sequence", "Board", "video", "note", "object", "flow", "p", "bit", "pool", "long", "ide", "boarding", "config", "function", "que", "custom", "builder", "flo", "client", "e", "bo", " row", "post", "cell", "cart", "check", "row", "line", "sync", "word", "coll", "off", "o", "switch", "child", " game", "square", " clipboard", "group", "deck", "channel", "loop", "base", "foot", "game", "che", "go", "co", "bar", "model", "design", "land", "string", "bank", "block", "feed", "lane"], "s": ["p", "o", "se", "ws", "lines", "S", "copy", "ss", "sb", "spec", "sc", "su", "ns", "m", "css", "strings", "es", "l", "h", "f", "c", "e", "t", "us", "sup", "options", "conf", "summary", "settings", "g", "sg", "b", "words", "ing", "sync", "comments", "u", "ed", "n", "sym", "si"], "empty": ["Empty", "element", "everything", "new", "square", "open", "full", "export", "channel", "null", "une", "space", "missing", "blank", "equal", "c", "ace", "e", "final", "none", "white", "ec", "initial", "size", "last", "union", "complete", "zero", "unknown", "clean", "clear", "error", "private", "esc"]}}
{"code": " \\n  \\n  def compute(r1, m1, r2, m2):\\n      valid1 = set(m1[r1 - 1])\\n      valid2 = set(m2[r2 - 1])\\n      valid = valid1 & valid2\\n      if len(valid) == 0:\\n          return 'Volunteer cheated!'\\n      if len(valid) > 1:\\n          return 'Bad magician!'\\n      return valid.pop()\\n  \\n  \\n  def parse_single():\\n      r = int(sys.stdin.readline().strip())\\n      m = []\\n      for i in xrange(4):\\n          m.append(map(int, sys.stdin.readline().strip().split()))\\n      return r, m\\n  \\n  def parse():\\n      r1, m1 = parse_single()\\n      r2, m2 = parse_single()\\n      return r1, m1, r2, m2\\n  \\n  \\n  if __name__ == \"__main__\":\\n      sys.setrecursionlimit(100000)\\n      T = int(sys.stdin.readline().strip())\\n      for i in xrange(T):\\n          data = parse()\\n          result = compute(*data)\\n          print \"Case #%d: %s\" % (i + 1, result)\\n", "substitutes": {"r1": ["cr2", "crOne", "rank1", "rank01", " r3", "cr1", "r3", "mOne", "er3", "er2", "R1", "rOne", "ROne", "sr01", "r01", "sr2", "er01", "crone", " rone", "sr3", "Rone", "R01", " rOne", " r01", "rank2", "rankone", "sr1", "R2", "er1", "mone", "rone"], "m1": ["arm2", "p1", "pone", "r3", "v1", "M2", "v0", "m3", "cone", "r0", "M1", "arm100", " mone", "p2", "c2", "M0", "c1", "v3", "r100", "m0", "armone", "Mone", "v2", "arm1", "c100", "p3", "M3", "m100", "mone", "rone"], "r2": [" rtwo", "cr2", "r4", "rb", "rg62", "drtwo", "cr1", "ertwo", "r92", "cr0", " r62", "m92", "er2", "r0", "R1", "rr2", " r4", "mb", " rb", "dr5", "er5", "rrtwo", "dr1", "rr62", " r5", " r92", "rg5", "m5", "rgtwo", " r0", "rtwo", "r62", "r5", "m0", "mtwo", "rr5", "R2", "rg2", "Rb", "m4", "er1", "cr92", "R4", "dr2"], "m2": ["roe", "r4", " m14", "v1", "fmTwo", "M2", "v0", "r14", "r0", "M1", "um2", " moe", "umtwo", "mall", " mall", "rTwo", "fm2", "vall", "mTwo", "Mtwo", "moe", "rtwo", "um1", "m0", "mtwo", "v14", "fm1", "v2", "m4", "M4", "m14", "rall", " m0", " mTwo", "fmoe", "um4"], "valid1": [" validone", "r3", "val3", "rOne", "variOne", "r01", "valone", "varione", " valid3", "vari3", "val1", "valOne", "vari1", "val01", "valid3", " valid01", "validOne", "valid01", "rone", "validone"], "valid2": ["val62", "valid5", " valid182", "m62", "valid62", "author3", "m3", "valid182", " valid3", "m5", "val2", "author2", "val1", "val5", "r62", "r5", "author182", "author1", "valid3", "m182"], "valid": ["split", "iter", "new", "single", "all", "val", "id", "active", "open", "list", "full", "long", "multiple", " validation", " invalid", "current", "index", "broken", "same", "required", "null", "multi", "fail", "body", "missing", "central", "f", "Valid", "update", "visible", "running", "compatible", "regular", "vari", "good", "eval", "form", "num", "status", "empty", "post", "check", "match", "value", "testing", "static", "non", "viol", "diff", "complete", "normal", "total", "failed", "generic", "error", "test", "old"], "r": ["err", "p", "rad", "rb", "R", "br", "id", "rc", "q", "ar", "ro", "mr", "d", "x", "rf", "h", "ru", "rl", "cr", "rd", "nr", "right", "c", "ir", "ur", "rr", "k", "rg", "reg", "g", "im", "re", "sr", "v", "b", "hr", "u", "rm", "lr", "n", "rs", "er"], "m": ["p", "o", "me", "gm", "mu", "mm", "fm", "nm", "sm", "mr", "d", "multi", "x", "am", "l", "y", "f", "imm", "c", "e", "bm", "t", "dm", "M", "hm", "cm", "mult", "a", "g", "mi", "b", "v", "u", "ms", "om", "tm", "rm", "n", "wm", "mc"], "i": ["bis", "p", "ui", "li", "start", "chi", "id", "ci", "index", "q", "d", "ai", "phi", "x", "bi", "multi", "ind", "ri", "l", "gi", "I", "f", "h", "ii", "c", "ti", "e", "eni", "zi", "mini", "uri", "xi", "pi", "di", "abi", "z", "uni", "a", "j", "b", "v", "u", "ip", "qi", "n", "si", "io", "gu", "iu", "int", "ih"], "T": ["Z", "TT", "P", "A", "O", "R", "S", "B", "L", "TB", "F", "X", "K", "I", "TS", "t", "E", "TN", "TH", "TR", "D", "M", "G", "U", "Y", "V", "C", "H", "Q", "W", "N", "Time"], "data": ["Data", "p", "o", "response", "array", "new", "res", "list", "config", "params", "d", "multi", "x", "body", "actions", "record", "raw", "arr", "args", "ata", "series", "media", "rows", "options", "dates", "input", "DATA", "dat", "sample", "a", "v", "n", "database", "test", "results"], "result": ["err", "response", "ver", "array", "comment", "res", "val", "report", "text", "success", "grade", "msg", "record", "message", "arr", "str", "final", "ret", "json", "status", "dict", "output", "rect", "obj", "tmp", "match", "value", "rate", "df", "Result", "attr", "diff", "complete", "total", "error", "test", "results", "date"]}}
{"code": " \\n  def read_line():\\n      return sys.stdin.readline().rstrip( '\\n' )\\n  \\n  def read_integer():\\n      return int( read_line() )\\n  \\n  def read_integers():\\n      return [ int( x ) for x in read_line().split() ]\\n  \\n  def flip( grid ):\\n      return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\\n  \\n  def grow( R, C, M ):\\n      grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\\n      b = R*C - M\\n      if C > R:\\n          R, C, grid = C, R, flip( grid )\\n          flipped = True\\n      else:\\n          flipped = False\\n      if b < 2*C:\\n          if b == 1:\\n              grid[ 0 ][ 0 ] = 'c'\\n          elif b == 3 and C >= 3:\\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\\n          elif b % 2:\\n              return\\n          else:\\n              grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\\n              grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\\n              grid[ 0 ][ 0 ] = 'c'\\n      else:\\n          r = 0\\n          while b >= C:\\n              grid[ r ] = bytearray( C*[ '.' ] )\\n              b -= C\\n              r += 1\\n          if b:\\n              if b >= 2:\\n                  grid[ r ][ : b ] = b*'.'\\n              elif C > 2 and r > 2:\\n                  grid[ r - 1 ][ -1 ] = '*'\\n                  grid[ r ][ : 2 ] = '..'\\n              else:\\n                  return\\n          grid[ 0 ][ 0 ] = 'c'\\n      return flip( grid ) if flipped else grid\\n      \\n  T = read_integer()\\n  for t in range( T ):\\n      print 'Case #%i:' % ( t + 1 )\\n      R, C, M = read_integers()\\n      grid = grow( R, C, M )\\n      print '\\n'.join( str( row ) for row in grid ) if grid else 'Impossible'\\n", "substitutes": {"x": ["p", "dx", " xx", "val", "ix", "col", "xxx", "xf", "index", "d", "xxxxxxxx", "ex", "y", "X", "f", "l", " i", "wx", "xa", "e", "i", "px", "xi", "xe", " y", "z", "xd", "xs", "xc", " X", "rx", "w", "xy", "v", "xp", "xxxx", "xx", "n", "xb", "byte"], "grid": ["format", "array", "node", "query", "case", "unit", "div", "list", "mu", "layout", "range", "plot", "entry", "order", "ico", "feature", "grade", "next", "default", "fit", "play", "code", "scale", "RH", "frame", "draw", "grain", "network", "reg", "device", "u", "bug", "page", "gu", "slice", "id", "hold", "export", "db", "init", "m", "multi", "card", "c", "ace", "data", "table", "back", "mode", "ga", "G", "set", "module", "IF", "mid", "remote", "int", "df", "layer", "lat", "tile", "news", "file", "d", "flat", "max", "record", "f", "Grid", "update", "edge", "client", "chain", "final", "temp", "complex", "num", "cell", "graph", "cart", "input", "hub", "U", "line", "dim", "gap", " Grid", "heat", "mat", "sky", "zip", "house", "parse", "new", "square", "group", "rank", "report", "q", "GA", "gui", "DC", "get", "tree", "connection", "shift", "rule", "cache", "move", "cube", "g", "wire", "last", "server", "model", "cells", " module", "block", "feed", "site"], "row": ["mod", "ver", "array", "node", "query", "id", "ow", "height", "tr", "group", "col", "user", "rank", "month", "range", "index", "rc", "run", "sc", "entry", "name", "order", "ro", "max", "record", "raw", "week", "c", "key", "batch", "num", "rows", "post", "round", "cell", "arrow", "value", "cm", "w", "length", "Row", "flow", "model", "number", "block", "feed", "page", "sel", "word", "layer"], "column": ["offset", "word", "unit", "group", "col", "month", "index", "entry", "channel", "variable", "ct", "y", "character", "position", "c", "Column", "day", "dimension", "rows", "year", "component", "attribute", "axis", "cell", "arrow", "value", "cycle", "length", "model", "line", "number", "dim", "umn", "block", "item", "letter", "section", "pixel", "slice"], "R": ["P", "A", "CR", "WR", "S", "B", "RA", "L", "RR", "LR", "F", "X", "K", "Grid", "I", "c", "Rs", "E", "RH", "DR", "RO", "D", "G", "Rh", "U", "Y", "GR", "RS", "V", "H", "Row", "Q", "W", "SR", "N", "RF", "Res", "RM"], "C": ["CC", "Z", "_", "A", "Cr", "lc", "CL", "K", "cr", "Sc", "Rs", "E", " c", "ac", "cy", "B", "Ra", "Cs", "CI", "CM", "c", "D", "G", "NC", "Y", "Co", "H", "Cu", "p", "CR", "ci", "S", "YC", "ar", "d", "F", "X", "I", "Grid", "e", "CU", "CT", "Max", "EC", "U", "cl", "V", "Q", "W", "Con", "P", "O", "CF", "sc", "DC", "L", "Ch", "CN", "MC", "Count", "CA", "N", "RC", "CE"], "M": ["Mo", "Z", "MQ", "P", "O", "LM", "MF", "S", "MN", "B", "MR", "Ms", "m", "Me", "L", "J", "CM", "F", "X", "K", "I", "DM", "Man", "E", "ME", "MM", "MU", "D", "G", "MI", "MS", "MC", "MD", "U", "Y", "V", "H", "MB", "Q", "NM", "W", "N", "MX", "RM"], "b": ["p", "o", "be", "rb", "eb", "B", "sb", "db", "range", "lb", "m", "nb", "null", "d", "base", "h", "ob", "l", "y", "f", "body", "http", "BB", "c", "e", "fb", "bp", "ba", "i", " B", "bs", "bas", "k", "z", "part", "type", "bb", "bf", "a", "w", "g", "ab", "bc", "wb", "bt", "ib", "v", "s", "j", "number", "u", "big", "bl", "block", "n", "bug", "bd", "bot", "ac"], "flipped": ["slipped", " flipper", "flided", "fluipped", "Flided", "fluipping", "Flipped", "slip", "flip", " floped", " flip", "slipping", " flided", "Flip", "flipper", "slided", "flipping", "slipper", "Floped", "fluoped", " flipping", "Flipping", "Flipper", "fluip", "floped"], "r": ["err", "p", "o", "rb", "br", "all", "dr", "tr", "B", "range", "rc", "ar", "m", "ro", "d", "h", "l", "ru", "rl", "cr", "f", "rd", "c", "nr", "right", "fr", "e", "Rs", "ur", "i", "rr", "k", "rh", "rt", "z", "a", "w", "g", "j", "sr", "v", "re", "u", "pr", "n", "rs", "er", "yr"], "T": [" N", "Z", "TT", "O", "P", "Length", "WT", "S", "B", "TA", "L", "TB", "F", "X", "I", "DT", "TS", "E", "CT", "Total", "G", "D", "Y", "H", "V", "Q", "N", "W", "NT"], "t": ["p", "tr", "txt", "tp", "st", "ts", "m", "ot", "dt", "time", "d", "text", "out", "l", "ind", "f", "y", "tz", "c", "e", "temp", "ret", "tt", "num", "i", "trial", "tw", "ta", "tmp", "nt", "v", "pt", "u", "n", "ut", "int", "test", "total", "ct", "qt", "tc"]}}
{"code": " \\n  def read_line():\\n      return sys.stdin.readline().rstrip( '\\n' )\\n  \\n  def read_integer():\\n      return int( read_line() )\\n  \\n  def read_integers():\\n      return [ int( x ) for x in read_line().split() ]\\n  \\n  def read_string():\\n      return read_line().strip()\\n  \\n  def read_strings():\\n      return read_line().split()\\n  \\n  def input_string_stack():\\n      data = []\\n      for line in sys.stdin.readlines():\\n          data.extend( line.split() )\\n      data.reverse()\\n      return data\\n  \\n  def input_integer_stack():\\n      return [ int( x ) for x in read_string_stack() ]\\n  \\n  class memoized( object ):\\n     def __init__( self, function ):\\n        self.function = function\\n        self.cache = {}\\n     def __call__( self, *arguments ):\\n        try:\\n           return self.cache[ arguments ]\\n        except KeyError:\\n           value = self.function( *arguments )\\n           self.cache[ arguments ] = value\\n           return value\\n  \\n  T = read_integer()\\n  for t in range( T ):\\n      row = read_integer()\\n      candidates = set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\\n      row = read_integer()\\n      candidates &= set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\\n      print 'Case #%i:' % ( t + 1 ), candidates.pop() if len( candidates ) == 1 else 'Bad magician!' if len( candidates ) > 1 else 'Volunteer cheated!'\\n", "substitutes": {"x": ["p", "_", "id", "ci", "ix", "ax", "xxx", "xf", "name", "width", "m", "d", "out", "ex", "y", "X", "f", "l", "wx", "h", "get", "c", "e", "code", "num", "i", "xi", "xe", "k", "z", "input", "xs", "xc", "w", "g", "xy", "v", "b", "xp", "number", "xxxx", "ctx", "exec", "u", "string", "xx", "n", "xb", "int", "ct"], "data": ["split", "Data", "format", "p", "response", "array", "la", "new", "all", "list", "lines", "config", "entry", "name", "variable", "text", "space", "d", "body", "write", "next", "message", "default", "update", "str", "code", "args", "values", "i", "media", "dict", "output", "sequence", "input", "type", "DATA", "dat", "a", "buffer", "object", "this", "reader", "content", "string", "feed", "n", "database", "result", "results", "source"], "line": ["unit", " Line", "lines", "lin", "ine", "log", "entry", " inline", "file", "name", "Line", "header", "d", "text", "point", "out", "body", "l", "message", "str", "code", "frame", "obj", "lined", "LINE", "cell", "inline", " lines", "buffer", "object", "reader", "string", "block", "item", "style", "word", "source", "byte"], "self": ["me", "response", "node", "all", "ws", "user", "proxy", "event", "h", "parent", "part", "w", "public", "this", "plus", "worker", "home", "Self", "full", "resp", "app", "c", "ng", "module", "object", "instance", "load", "pos", "ctx", "reader", "layer", "results", "p", "writer", "per", "f", "host", "github", "client", "e", "work", "call", "error", "private", "now", "one", "o", "q", "l", "http", "connection", "other", "shared", "k", "g", "context", "server", "master", "method"], "function": ["element", "array", "node", "unit", "command", "service", "full", "expression", "document", "run", "closure", "name", "func", "file", "python", "system", "feature", "parent", "fn", "f", "family", "connection", "functional", "code", "package", "callback", "form", "wrapper", "handler", "module", "library", "Function", "operator", "fun", "object", " Function", "context", "instance", "program", "role", "operation", "number", "action", "call", "string", "resource", "section", "interface", "word", "binary", "method"], "cache": ["parse", "array", "image", "engine", "list", "proxy", "config", "cookie", "write", "base", "parent", "body", "c", "client", "table", "code", "lib", "chain", "tag", "key", "hash", "api", "debug", "ache", "wrapper", "Cache", "module", "cell", "can", "cycle", "buffer", "object", "storage", "model", "use", "memory", "store", "call", "binary"], "value": ["element", "p", "response", "array", "unit", "val", "list", "valid", "document", "version", "current", "entry", "range", "variable", "parent", "max", "message", "default", "end", "key", "values", "num", "VALUE", "output", " Value", "type", "reg", "a", "w", "length", "object", "this", "v", "instance", "number", "content", "string", "resource", "result", "reference", "test", "Value", "one"], "arguments": ["paramument", "paramargs", "axeters", "paramls", "parameters", "aguments", "axuments", "argencies", "callencies", "argls", " argates", "paramuration", "argsument", "ageters", "arguration", "argargs", " arguration", "argsuration", " argargs", "argument", " argeters", "argsates", " argument", "calleters", "parates", "paruments", "agument", "argeters", "argates", "argseters", "argsuments", "argsargs", "callument", "paramuments", "axument", " argls", "argsls", "axencies", "agencies", "parargs", "parument", "calluments"], "T": [" N", "P", "TT", "O", " R", "R", "Length", "S", " TT", "B", "time", "L", "F", " C", "X", "I", "port", "table", "E", "TN", "D", "M", "G", "type", "U", "Y", "w", "C", "V", "length", "Row", "Q", "N", "W", "n", "total", "Time", " P"], "t": ["p", "start", "col", "dt", "m", "time", "text", "h", "y", "l", "f", "tz", "c", "e", "table", "thread", "temp", "tt", "i", "trial", "tower", "rows", "tf", "ta", "k", "z", "the", "type", "window", "w", "j", "length", "v", "tl", "u", "n", "test", "int", "total", "tc"], "row": ["p", "off", "offset", "R", "id", "tr", "col", "month", "q", "order", "ro", "head", "out", "y", "X", "f", "port", "c", "day", "end", "scale", "key", "batch", "tri", "num", "tt", "rows", "post", "round", "roll", "k", "cell", "rot", "type", "r", "column", "w", "length", "Row", "pos", "block", "test", "where", "tc"], "candidates": ["predidate", "Candidate", " candores", "colidates", "Candests", "prediders", " Candiders", "candores", "colates", "Candals", "coloters", "colations", "candiders", "Candoters", "candates", "candices", "candests", "candoters", "candles", "argplates", " Candles", "Candles", " candidate", "candplates", " Candidate", " candests", "candidate", "constices", " candals", "predests", "constators", " candles", "catoters", "argidates", "predators", "constidates", "colplates", "catidates", "predidates", "predices", "Candidates", "candators", "catates", " Candators", "candals", "colidate", " Candices", "argidate", "argations", "Candores", "candations", "catidate", " Candores", "Candations", "Candates", "predals", " Candidates", "Candplates", "constiders"], "index": ["level", "id", "long", "open", "valid", "weight", "version", "range", "name", "point", "ind", "out", "access", "character", "position", "default", "insert", "end", "inc", "num", "find", "match", "length", "instance", "diff", "loc", "call", "block", "int", "connect", "word", "where"]}}
{"code": "def Trivial(R,C,char):\\n      for i in range(R):\\n          Ans = '';\\n          for j in range(C):\\n              if (i==j==0):\\n                  Ans += 'c';\\n              else:\\n                  Ans += char;\\n          print Ans;\\n  \\n  \\n  def Draw1(R,C,Blank):\\n      Ans = \"c\";\\n      for i in range(Blank-1):\\n          Ans += '.';\\n      for i in range(R*C-Blank):\\n          Ans += '*';\\n      if (R == 1):\\n          print Ans;        \\n          return;\\n      if (C == 1):\\n          for i in range(len(Ans)):\\n              print Ans[i];\\n  \\n  def Draw2(R,C,Blank):\\n      if (Blank%2 != 0) or (Blank == 2):\\n          print \"Impossible\";\\n          return;\\n      Row1 = '.'*(Blank/2) + '*'*(Mine/2);\\n      Row0 = 'c' + Row1[1:];\\n      if R==2:\\n          print Row0;\\n          print Row1;\\n      else:\\n          for i in range(len(Row0)):\\n              print Row0[i]+Row1[i];\\n      return;\\n  \\n  \\n  def Generate(R, C, Blank):\\n      TODO = Blank;\\n      Spaces = [0]*R;\\n      if TODO <= 2*C:\\n          if TODO%2 == 0:\\n              Spaces[0] = TODO/2;\\n              Spaces[1] = TODO-Spaces[0];\\n          else:\\n              if (TODO == 7):\\n                  Spaces[0] = 3;\\n                  Spaces[1] = 2;\\n                  Spaces[2] = 2;\\n              else:\\n                  Spaces[0] = (TODO-3)/2;\\n                  Spaces[1] = (TODO-3)/2;\\n                  Spaces[2] = 3;\\n      else:\\n          row = 0;\\n          if (TODO >= 2*C+2):\\n              Spaces[0] = C;\\n              Spaces[1] = C;\\n              TODO -= 2*C;\\n              row = 2;\\n              \\n          while TODO > C+1:\\n              if (TODO == 2*C+1) and (C != 3):\\n                  Spaces[row] = C-1;\\n                  Spaces[row+1] = C-1;\\n                  Spaces[row+2] = 3;\\n                  TODO = 0;\\n              else:\\n                  Spaces[row] = C;\\n                  TODO -= C;\\n                  row += 1;\\n          if (TODO == C+1):\\n              Spaces[row] += C-1;\\n              Spaces[row+1] = 2;\\n              TODO = 0;\\n          Spaces[row] += TODO;\\n  \\n      for r in range(R):\\n          Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);\\n          if r == 0:\\n              Ans = 'c'+Ans[1:];\\n          print Ans;\\n  \\n  \\n  def Solve(R, C, M):\\n      Blank = R*C-M;\\n      if Blank == 0:\\n          print \"Impossible\";\\n          return;\\n  \\n      if (Blank == 1):\\n          Trivial(R,C,'*');\\n          return\\n      if (Blank == R*C):\\n          Trivial(R,C,'.');\\n          return\\n  \\n      if (R == 1) or (C == 1):\\n            Draw1(R,C,Blank);\\n            return\\n  \\n      if (R-2)*(C-2) == 0:\\n          Draw2(R,C,Blank);\\n          return\\n  \\n      if Blank in [2,3,5,7]:\\n          print \"Impossible\";\\n          return;\\n      \\n      if (R >= 3) and (C >= 3):\\n          Generate(R, C, Blank);\\n  \\n      return;\\n  \\n  \\n  T = int(raw_input());\\n  for q in range(T):\\n      [Row,Col,Mine] = map(int, raw_input().split());\\n  \\n      Blanks = Row*Col - Mine;\\n      \\n      print \"Case #%d:\" % (q+1)\\n      Solve(Row, Col, Mine);\\n      \\n          \\n", "substitutes": {"R": ["P", "O", "A", "CR", "S", "B", "ARR", "Ram", "J", "L", "RR", "Run", "F", "X", "Roman", "K", "I", "RP", "c", "RW", "Rs", "E", "NR", "RH", "Right", "DR", "RO", "D", "G", "Rank", "Reader", "Rh", "U", "Y", "RS", "Cl", "H", "V", "Co", "RG", "Q", "W", "N", "SR", "Re", "RC", "RM", "Res", "Br", "Range"], "C": ["CC", "Z", "P", "CW", "SC", "CR", "O", "A", "CS", "S", "B", "Cs", "CI", "COR", "JC", "YC", "CL", "L", "DC", "CM", "F", "X", "K", "I", "Sc", "c", "Ch", "CU", "E", "CT", "CNN", "VC", "D", "G", "EC", "U", "Count", "Ca", "CA", "Y", "Cl", "V", "H", "Co", "Case", "Cu", "CE", "Size", "Q", "W", "N", "CV"], "char": ["CC", "Cr", "CR", "ci", "ch", "CHAR", "RGB", "text", "f", "I", "character", "c", "String", "Character", "e", "Ch", "cell", "CCC", "U", "Char", "V", "short", "u", "string", "void", "int"], "i": ["p", "o", "ui", "li", "chi", "id", "ci", "ia", "ei", "index", "CI", "ori", "m", "ini", "d", "ai", "J", "x", "bi", "multi", "ind", "ri", "l", "gi", "I", "y", "f", "h", "ii", "c", "ti", "e", "yi", "ie", "pi", "xi", "di", "z", "ni", "a", "g", "im", "mi", "b", "v", "ip", "u", "qi", "n", "si", "io", "int", "iu"], "Ans": ["annobs", "Johnp", "Anch", "anb", "Anngs", "ANn", "Ap", "Annegs", "Annen", "Acd", " anns", "annses", "Acs", "ANp", " Angs", " Anks", " AnS", "Ann", "annb", "Cans", "Cand", "anns", "Annws", "Canss", "JohnS", "Anches", "Anneches", "annp", "Angs", "Annes", "And", "Avc", "Anns", "ANobs", "Anses", " Anch", " annns", " Anf", "Ass", "ANgs", "Aows", "Anf", " annch", "Anneb", "Anws", "Annesi", "Anss", "Annews", " Anss", "SignS", "Anb", "Anp", "Ansi", " Anches", "ANses", "Avns", " Anws", " Anns", " Anc", "Signf", "anngs", " annc", "Annsi", " ans", " And", " Anows", "anses", " Anb", "AnneS", " Ands", "ANss", " anS", "Anows", " Anp", " Ansi", "Signs", "Annens", "Acds", "Avs", "AnS", "As", "ans", "Anneks", "ANs", " anf", "Avch", "Anc", "Cands", "annns", "ANks", "ANows", " ansi", "ANns", "ANb", "Annns", "Johnches", "Annep", "Anks", "Anobs", "Signsi", "Johns", "Ands", "Acss", "anobs", " Ann"], "j": ["p", "o", "ci", "ix", "ch", "\u0438", "js", "jc", "ei", "oi", " ii", " bi", "jp", "m", "ji", "J", "x", "bj", "ind", "oj", "y", "gi", "l", "I", "ii", "c", "e", "jl", "xi", "k", "z", "jj", "je", "ja", "uni", "ij", " c", "g", "b", "v", "jo", "n", "si"], "Blank": ["Clanks", "Glank", "Clank", "BLank", "blanks", "BlANK", "blan", "Plank", "Silanking", "Plark", "Elanks", "BLace", "SilANK", "blanking", "BrANK", "Silank", "Flank", "BLan", "blank", "Glan", "ClANK", "Planking", "BLark", "BLanking", "Blace", "Glanking", "Elanking", " Blanking", " Blan", " Blark", "Glanks", "PlANK", "BLANK", "Clan", "Elank", "blark", "blANK", "BLanks", " Blace", "Brark", "Blark", "Flark", "Elark", "ErANK", "Brank", "blace", " BlANK", "Flanking", "Silark", "Erace", "Eranking", "FlANK", "Blanking", "Branking", "Clace", "Blan", "Glark", "Erank", "Glace"], "Row1": ["rowOne", "row3", "row0", "RowOne", "row2", "Line3", "Line1", "row1", "LineOne", " Row3", " RowOne", " Row2", "Line2", "Line0", "Row2", "Row3"], "Row0": ["Way150", "Col6", "Block0", "Col0", "row0", "row2", "Line1", "row1", "Line150", "Way2", "Row150", " Row8", "Way1", "Col1", "Block2", "Col2", " row1", " Row150", " row2", " Row2", "row6", "Line2", "Line6", "Row8", "Block1", "Row6", "Way0", " row8", "Line0", "row8", "Row2", " row0"], "TODO": ["TodP", "TodDo", "TodOME", "TODOL", "TOGOME", "TDDO", "TBDOs", "TODT", "TOKOME", "TDDOME", "TECO", "UTodOD", " TODOVER", "PODN", "TMODO", "TPDOs", "tOPOs", "TMODT", "TMODOVER", "TOHOF", "UTodOL", "TODRO", "TEMP", "TDDDo", "TODOME", "tOPOO", "UTodo", "TODOs", "TEDN", "TOKSO", " TODo", "TODo", "TOPOs", "TDDOs", "TBDE", "TOTALO", "tODOs", "DTODOO", "TodEO", "TOMO", "RODOL", "TPDRO", "TPDOE", " TPDOVER", "POKOME", "PODSO", "TECo", "tODE", "TEDH", "TUTOD", "TEDOME", "TUTO", "RODOF", "TodT", "PODO", "RODo", "tOPO", "TodO", "POKO", "DTBDOO", "PODo", "TBDOO", "TOTALOL", "DTODO", "tODDo", "TBDPO", "TMODOD", "TOTOO", "TOCOD", "tCDo", "TPDO", "TODSO", "tOPo", "TECN", "DTBDOs", " TodOD", "TODE", " TPDPO", "tODRO", "TODN", "TOCO", "DTODOs", "TEMT", "TEMOD", "TPDo", "TMODOO", "TBDo", "TODOE", "TOMOs", "TPDOVER", "todOME", "TOHO", "TOTO", "TOCOO", "TODPO", "TOTALo", "TodH", "TodOVER", "tODOO", "POKH", "TOKO", "TEDSO", "TOKOF", "TCDE", "TODDo", "TCDO", "todOs", "TOCOE", "TOGOs", "TOPo", "ROKo", "TOKN", "TOPE", "TodOO", "TOMOO", "ROKOL", " TodO", "tCDRO", "TOKo", " TodP", "TODP", "TCDRO", "TOHOL", "TOTALOF", " TODOs", "TECSO", "TOHo", " TodT", " TPDo", "PODEO", " TODOO", "Todo", "TOCOs", "tCDE", "TodOs", "tODO", "UTODO", "TEMO", "TCDo", "TCDOs", " TPDO", "ROKO", "PODH", "TMODOs", "TOKOO", "TMODP", "TOPPO", "TOKH", " TODT", " TPDOs", "DTBDO", "UTodO", "TEDO", "TOCo", " TPDOO", "TODOVER", "todO", "TODH", "todDo", " TODPO", "TOPOO", "TOMOE", "TOKEO", "TodOL", " TODOE", "TOGO", "TodRO", "POKN", "ROKOF", "tODOME", "TOTo", "RODO", "UTODOD", "TODEO", "UTODOL", "TEDo", "POKSO", "UTODo", "TPDOO", " TODP", " TODOD", "TodOD", "POKo", "TOTOs", "TOGDo", "DTODo", "tODo", "tCDO", "TOCOL", "TODOO", "TUTOL", "TEDEO", " TPDOE", "TODOF", "TOPO", "TUTo", "DTBDo", "TOKOs", "TODOD", "TBDO", "POKEO", "TOKOL", "TPDPO", "tCDOs", "PODOME"], "Spaces": ["Prefpaces", "Expplaces", "Appaces", "Chaces", " Spices", " Spacs", "Spplaces", "Spacers", "Slfaces", " space", "Spanks", "Preffaces", "Plays", "spaches", "Prefices", "Trapes", "Spays", "Spaps", "spaults", "spfaces", "Space", " Spacing", " Spans", "spays", "SPaps", "SPapes", " SpACE", "Sppaces", " Spplaces", "space", "Chplaces", "Slices", "Chpaces", " Spfaces", "Spaches", "Trplaces", "Spacs", "Spacing", "Skplaces", "Spfaces", " spacing", "SPACE", "SPace", "Phaces", "Spraces", "Appaults", " spacs", "Places", "SPaced", "Slays", "Spaults", "SPanks", "Skfaces", "SPays", "SPacers", "Phaced", "Infans", "Appans", "Infaults", "spices", "Phplaces", "Slace", "Appaches", "spans", " Spapes", " spaces", "Spaced", "spACE", " Spanks", "Phacing", "SPacs", "SPaces", " Space", "Expacing", "Plfaces", "SPans", "Chfaces", "spacers", "Spranks", "Expacers", "Traces", "spaced", "SPplaces", "SPacing", "Spans", "Expaces", "Infaches", "Slans", "Trans", "Placing", "Slacing", "Slaces", "Sprplaces", "Spapes", "Prefacing", "Spices", "spacing", "Spracing", "Infaces", "Prefaces", "Skpaces", " Spays", "spplaces", " Spaps", "spaps", "Plans", "spacs", " Spaced", "SpACE", "spaces", "Prefplaces", "SPfaces", "Placs", "Skaces"], "row": ["mod", "offset", "node", "query", "ow", "tr", "user", "col", "group", "month", "index", "range", "entry", "view", "sc", "order", "ro", "head", "container", "x", "max", "y", "step", "raw", "port", "count", "right", "c", "uc", "scale", "no", "key", "batch", "num", "rows", "year", "um", "post", "k", "cell", "module", "check", "value", "window", "column", "co", "w", "auto", "length", "low", "this", "flow", "server", "pos", "page", "block", "feed", "bug", "error", "slice", "cur"], "Mine": ["Repeat", "CC", "case", "MAX", "Block", "Diamond", "RGB", "Line", "Ram", "Mini", "Me", "Rec", "Roman", "cr", "Fill", "rock", "Num", "Continue", "Red", "White", "Circ", "Max", "cell", "CCC", "Case", "line", "CV", "Cut"]}}
{"code": "T = int(raw_input());\\n  for q in range(T):\\n      R1 = int(raw_input());\\n      Data1 = [];\\n      for i in range(4):\\n          Data1.append( map(int, raw_input().split()) );\\n          \\n      R2 = int(raw_input());\\n      Data2 = [];\\n      for i in range(4):\\n          Data2.append( map(int, raw_input().split()) );\\n  \\n      Ans = [];\\n      for entry in Data1[R1-1]:\\n          if entry in Data2[R2-1]:\\n              Ans.append(entry);\\n  \\n      print \"Case #%d:\" % (q+1),;\\n  \\n      if len(Ans) == 0:\\n          print \"Volunteer cheated!\";\\n      if len(Ans) == 1:\\n          print Ans[0];\\n      if len(Ans) > 1:\\n          print \"Bad magician!\"\\n          \\n", "substitutes": {"T": ["Z", "P", "O", "A", "R", "S", "B", "Type", " Q", "L", "F", "X", "K", "I", "t", "E", "Total", "D", "M", "G", "U", "Y", "C", "V", "H", "Q", "W", "N", "TI", "n", "Time"], "q": ["p", "_", "o", "depth", "iq", "qu", "query", "qq", "sq", "qa", "requ", "m", "time", "d", "x", "ind", "y", "f", "I", "dq", "c", "quant", "question", "t", "charge", "k", "z", "r", "a", "w", "g", "length", "row", "v", "u", "Q", "n", "int", "qt"], "R1": ["RR9", "r91", "Data91", "D9", "RR1", "R91", "R9", "r9", "r2", "D1", "RR2", "r1", "D2", "RR91"], "Data1": ["Group1", "Array1", "BlockOne", "RowOne", "Result1", "Array0", "Data01", "DataOne", "Row1", "Group2", "ROne", "ResultOne", "data0", "Result0", "Group01", "Row0", "Block2", "Result3", "data3", "Data3", "GroupOne", "R01", " DataOne", "Data0", "ArrayOne", "dataOne", "Block1", "Array3", " Data0", "data1", "Array2", "Row2", "Block01"], "i": ["p", "it", "o", "chi", "li", "qu", "id", "ci", "range", "ai", "x", "ind", "l", "f", "I", "ii", "c", "ti", "e", "ie", "pi", "r", "a", "im", "j", "s", "b", "v", "ip", "u", "qi", "io", "int", "iu"], "R2": ["Runii", " Rii", " RTwo", "Run1", " RSecond", "RR1", "rTwo", "r2", "RR2", "r1", "rii", "RSecond", "r62", "RTwo", " R62", "Rii", "RRSecond", "Run2", "R62", "RRTwo", "rSecond", "Run62"], "Data2": ["Na1", "DataTwo", "Sample1", "DataSecond", "Sampletwo", "Arraytwo", "SampleSecond", "Result1", "ArrayCloud", "data2", "dataTwo", " Datatwo", "Sample2", "Natwo", "Resulttwo", "SampleCloud", "Na0", "Result2", "Datatwo", "data0", " DataSecond", "Result0", " DataTwo", "Sample0", "Data0", "DataCloud", "ArraySecond", "SampleTwo", " Data0", "data1", "Array2", "Na2", " DataCloud"], "Ans": ["Acc", "annm", "ANc", "ANsi", "Annm", " Ansi", "Anl", "Anches", "anni", "Anm", "Ants", " Ants", "ANn", "annches", "Ant", "annsi", " Anfs", "annl", "Anni", "ANfs", " Anches", "ANt", "Ansi", "ANi", "ANs", "Annl", "Ars", " Ant", "Arks", "annfs", "Anc", "Arn", "Acts", "Act", " Anns", "annns", "ANks", "Annches", "ANts", "Acs", " Anm", " Anks", "ANns", " Anc", "Annns", " Anl", "Anks", "Arl", "Anns", "Ani", "ANm", "Anfs", "Ann", "Annt", "ANl", "annc", " Ann", "anns"], "entry": ["\u00eb", "desc", "it", "art", "new", "comment", "id", "idy", "name", "rival", "text", "arc", "vec", "ind", "next", "ence", "rant", "insert", "ient", "data", "ry", "e", "RY", "ries", "adr", "article", "ell", "ident", "ie", "archive", "draw", "tri", "ault", "info", "ue", "ner", "chapter", "vid", "nt", "cat", " entries", "match", "way", "incent", "par", "rent", "ent", "rue", "inter", "row", "line", "reader", " Entry", "rance", "Entry", "feed", "letter", "error", "ENT"]}}
{"code": " \\n  \\n  \\n  def show_board(board):\\n      for row in board:\\n          print ''.join(row)\\n  \\n  \\n  N = int(sys.stdin.readline())\\n  \\n  for T in range(1, N+1):\\n      (R, C, M) = map(int, sys.stdin.readline().split(' '))\\n      E = R*C-M # empty\\n      possible, reverse, need_adjust, column_base = (False, False, False, False)\\n      if C > R:\\n          (R, C) = (C, R)\\n          reverse = True\\n  \\n      W = 0\\n      lastRow = 0\\n      if E == 0:\\n          pass\\n      elif E == 1 or M == 0:\\n          W = C\\n          possible = True\\n      elif C == 1:\\n          W = 1\\n          if E > 0:\\n              possible = True\\n      elif C == 2:\\n          W = 2\\n          lastRow = int(E / 2) + 1   # 1 base\\n          if E % 2 == 0 and E >= 4:\\n              possible = True\\n      elif C >= 3:\\n          for w in range(2, C+1):\\n              lastRow = int(E / w) + 1   # 1 base\\n              if lastRow > R: continue\\n              lastRowNum = E % w\\n              \\n              if lastRow == 2 and lastRowNum == 0:\\n                  pass\\n              elif lastRow == 2:   # lastRow == 1 => impossible\\n                  if lastRowNum == 0:\\n                      W = w\\n                      possible = True\\n                      break\\n              elif lastRow >= 3:\\n                  if lastRowNum >= 2 or lastRowNum == 0:\\n                      W = w\\n                      possible = True\\n                      break\\n                  elif C >= 4 and lastRowNum == 1 and R >= 3:\\n                      W = w\\n                      possible = True\\n                      need_adjust = True\\n                      break\\n          if not possible:\\n              for w in range(2, R+1):\\n                  lastRow = int(E / w) + 1   # 1 base\\n                  if lastRow > R: continue\\n                  lastRowNum = E % w\\n                  if lastRow == 2 and lastRowNum == 0:\\n                      pass\\n                  elif lastRow == 2:   # lastRow == 1 => impossible\\n                      if lastRowNum == 0:\\n                          W = w\\n                          possible = True\\n                          column_base = True\\n                          break\\n                  elif lastRow >= 3:\\n                      if lastRowNum >= 2 or lastRowNum == 0:\\n                          W = w\\n                          possible = True\\n                          column_base = True\\n                          break\\n                      elif C >= 4 and lastRowNum == 1 and R >= 3:\\n                          W = w\\n                          possible = True\\n                          need_adjust = True\\n                          column_base = True\\n                          break\\n                                  \\n      if not possible:\\n          if reverse:\\n              R, C = (C, R)        \\n          ans = 'Impossible %sx%s M=%s' % (R, C, M)\\n          print 'Case #%(T)s: %(ans)s' % locals()\\n          continue\\n  \\n      board = [['*'] * C for i in range(R)]\\n      for i in range(E):\\n          if not column_base:\\n              c = i % W\\n              r = i / W\\n          else:\\n              r = i % W\\n              c = i / W            \\n          board[r][c] = '.'\\n      if need_adjust:\\n          board[lastRow-1][1], board[lastRow-2][-1] = board[lastRow-2][-1], board[lastRow-1][1]\\n      if reverse:\\n          board = map(list, zip(*board))\\n          R, C = (C, R)\\n  \\n      clicked = False\\n      for r in range(R):\\n          if clicked: break\\n          for c in range(C):\\n              cell = board[r][c]\\n              if cell != '.': continue\\n              if E == 1:\\n                  board[r][c] = 'c'\\n                  clicked = True\\n                  break\\n              \\n              if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue\\n              if r >= 1              and board[r-1][c]   == '*': continue\\n              if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue\\n              if             c >= 1  and board[r][c-1]   == '*': continue\\n              if             c < C-1 and board[r][c+1]   == '*': continue\\n              if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue\\n              if r < R-1             and board[r+1][c]   == '*': continue\\n              if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue\\n              board[r][c] = 'c'\\n              clicked = True\\n              break\\n  \\n      ans = 'Possible' if possible else 'Impossible'\\n      print 'Case #%(T)s:' % locals()\\n      show_board(board)\\n", "substitutes": {"board": ["array", "node", "square", "list", "deck", "col", "ode", "entry", "channel", "ro", "card", "boards", "c", "data", "flo", "table", "code", "rule", "form", "frame", "wall", "game", "hole", "rows", "post", "cell", "sequence", "Board", "input", "cart", "down", "buffer", "flow", "line", "reader", "feed", "interface", "word", "coll", "one"], "row": ["rown", "stroke", "node", "ow", "user", "col", "Block", "OW", "entry", "view", "loop", "channel", "null", "ro", "x", "X", "record", " rows", "raw", "port", "table", "ward", "frame", " Row", "ows", "rows", "post", "round", "cell", "Board", "Y", "bar", "buffer", "Row", "flow", "line", "server", "string", "page", "block", "feed", "section", "test", "word"], "N": ["Z", "P", "O", "A", "S", "B", " n", "Ns", "No", "Ne", "L", "F", "X", "K", "I", "Node", "D", "G", "U", "Y", "V", "H", "Size", "Q", "NS", "W", "NM", "n", "Ni", "NT"], "T": ["P", "O", "A", "S", "B", "L", "F", "X", "K", "I", "t", "D", "G", "U", "Y", "V", "H", "Row", "W", " t"], "R": ["P", "O", "A", "CR", "S", "B", "RA", "L", "RR", "F", "X", "K", "I", "Rs", "NR", "RO", "D", "G", "r", "U", "Y", "V", "H", "Q", "W", "SR"], "C": ["CC", "Z", "P", "O", "A", "CR", "S", "B", "Cs", "L", "CM", "X", "F", "K", "I", "c", "CU", "D", "G", "U", "Y", "V", "H", "Cu", "Q", "W"], "M": ["Z", "P", "O", "A", "LM", "S", "MN", "B", "MO", "m", "J", "L", "F", "X", "I", "K", "Man", "D", "G", "MD", "U", "Y", "V", "H", "Q", "W", "RM", "FM"], "E": ["Z", "P", "O", "A", "S", "B", "Edge", "L", "F", "X", "K", "I", "ES", "e", "IE", "GE", "G", "D", "EC", "U", "Y", "V", "H", "El", "Q", "W", "EF"]}}
{"code": " \\n  \\n  N = int(sys.stdin.readline())\\n  \\n  for T in range(1, N+1):\\n      first_ans = int(sys.stdin.readline())\\n      first_grid = []\\n      for i in range(4):\\n          row = [int(v) for v in sys.stdin.readline().split(' ')]\\n          first_grid.append(row)\\n      first_list = set(first_grid[first_ans-1])\\n      \\n      second_ans = int(sys.stdin.readline())\\n      second_grid = []\\n      for i in range(4):\\n          row = [int(v) for v in sys.stdin.readline().split(' ')]\\n          second_grid.append(row)\\n      second_list = set(second_grid[second_ans-1])\\n  \\n      intersection = first_list.intersection(second_list)\\n  \\n      if len(intersection) == 1:\\n          ans = intersection.pop()\\n      elif len(intersection) == 0:\\n          ans = 'Volunteer cheated!'\\n      else:\\n          ans = 'Bad magician!'\\n  \\n      print 'Case #%(T)s: %(ans)s' % locals()\\n", "substitutes": {"N": ["Z", "P", "O", "R", "S", "B", " n", "Ns", "Ne", "L", "NI", "F", "X", "RN", "K", "I", "Num", "NR", "TN", "D", "M", "NC", "G", "Y", "V", "C", "H", "NE", "NM", "NS", "n", "NA", "Ni", "NT"], "T": ["p", "_", "O", "o", "unit", "\u0438", "ei", "time", "d", "h", " I", "ind", "f", "I", "ii", "vi", "ti", "e", "t", "code", "abi", "k", "w", "j", "u", "page"], "first_ans": ["second_ars", "first_ann", " first_ANS", "second_an", "first_ars", "second_ann", "first_an", "first_ANS", " first_an", " first_ann"], "first_grid": ["last_list", "last_row", "first_range", "first_multi", "last_grid", " first_multi", "first_group", "last_group", "first_row", " first_range"], "i": ["il", "p", "it", "o", "id", "ci", "ar", "ai", "x", "ind", "l", "h", "f", "I", "iv", "ii", "c", "ti", "e", "yi", "ie", "pi", "k", "r", "a", "j", "b", "ip", "io", "int", "iu"], "row": ["element", "off", "stroke", "up", "child", "array", "node", "ow", "group", "col", "month", "range", "ko", "board", "view", "du", "channel", "order", "entry", "ro", "head", "container", "x", "port", "week", "grid", "seed", "ward", "ha", "key", "batch", "rows", "cell", "r", "check", "value", "cube", "column", "low", "field", "Row", "dd", "line", "flow", "server", "ip", "sync", "reader", "zero", "feed", "block", "bug", "section", "error", "slice", "one", "zip"], "v": ["p", "o", "ov", "conv", "ver", "val", "vs", "nv", "av", "q", "m", "d", "x", "h", "en", "l", "y", "f", "iv", "vi", "c", "lv", "volt", "t", "end", "va", "e", "var", "vert", "vid", "k", "z", "value", "ev", "w", "g", "j", "V", "ve", "s", "vv", "b", "vol", "u", "sv", "n"], "first_list": ["last_part", " first_layer", "first_part", "last_list", " first_lc", "first_chain", "last_grid", "first_layer", "last_chain", "first_lc"], "second_ans": ["two_an", "secondPann", "secondPans", "two_ans", "second_lan", "second_an", " second_ann", "two_san", "second_nas", "second_ann", "secondPan", "secondPsan", " second_nas", "second_san", "two_ann", " second_lan"], "second_grid": ["two_grid", "two_cart", "two_line", "two_list", "second_line", "secondscard", "secondslist", "second__list", "second_cell", "second_card", "two_cell", "second_cart", "two_row", "second__grid", "secondsrange", "second__range", "secondsgrid", "second_row", "second__card", "two_range", "two_card", "second_range"], "second_list": ["second_lc", " second_lc", "second_chain", "second_layer", " second_chain", "secondary_list", "second_List", "secondary_layer", "secondary_List"], "intersection": ["interestablishment", "subsector", "intersector", "intsector", "interection", "subsect", "cochange", "oversection", "Interestablishment", "innersect", "presector", "cosection", "intestablishment", "Intersector", "interrelation", "interleave", "interchange", " interrelation", "innersection", "subsection", "innerchange", "intersections", "coleave", "intsection", "partsect", "innerleave", "Interection", "intsect", "prerelation", " interestablishment", " interion", "Intersections", "partsection", "intersect", "presections", "subection", "overchange", "interion", "Interrelation", "presect", "Interion", " intersect", "Intersection", "cosect", "presection", "Intersect", " intersections", "overleave", "partsector", "oversect", "partection", " intersector", "preion"], "ans": ["aning", "cs", "amps", "san", "na", "aus", "ns", "ins", "anas", "ean", "ents", "ams", "cus", "nan", "nas", "ann", "lan", "anus", "sk", "ant", "ania", "leans", "atan", "anne", "anon", "os", "ants", "can", "ens", "anc", "AN", " means", "ks", "anes", "ars", "ani", "aned", "ANS", "mean", "ats", "ana", "an", "ads", "ds", "ane"]}}
{"code": " \\n  def solve(W, H, M):\\n    board = [['*' for x in xrange(H)] for x in xrange(W)]\\n    board[0][0] = 'c'\\n    \\n    S = [((H*W)-1, board, 0, 0, set())]\\n    H -= 1\\n    W -= 1\\n    while len(S) > 0:\\n      state = S.pop()\\n      mines = state[0]\\n      board = deepcopy(state[1])\\n      x = state[2]\\n      y = state[3]\\n      visited = deepcopy(state[4])\\n      visited.add((x, y))\\n      \\n      if mines == M:\\n        s = ''\\n        for row in board:\\n          s += ''.join(row)\\n          s += '\\n'\\n        return s\\n      \\n      elif mines > M:\\n        if x > 0 and board[x-1][y] == '*':\\n          board[x-1][y] = '.'\\n          mines -= 1\\n        \\n        if x < W and board[x+1][y] == '*':\\n          board[x+1][y] = '.'\\n          mines -= 1\\n        \\n        if y > 0 and board[x][y-1] == '*':\\n          board[x][y-1] = '.'\\n          mines -= 1\\n        \\n        if y < H and board[x][y+1] == '*':\\n          board[x][y+1] = '.'\\n          mines -= 1\\n        \\n        if x > 0 and y > 0 and board[x-1][y-1] == '*':\\n          board[x-1][y-1] = '.'\\n          mines -= 1\\n        \\n        if x > 0 and y < H and board[x-1][y+1] == '*':\\n          board[x-1][y+1] = '.'\\n          mines -= 1\\n        \\n        if x < W and y > 0 and board[x+1][y-1] == '*':\\n          board[x+1][y-1] = '.'\\n          mines -= 1\\n        \\n        if x < W and y < H and board[x+1][y+1] == '*':\\n          board[x+1][y+1] = '.'\\n          mines -= 1\\n        \\n        if x > 0 and not (x-1, y) in visited:\\n          S.append((mines, board, x-1, y, visited))\\n        \\n        if x < W and not (x+1, y) in visited:\\n          S.append((mines, board, x+1, y, visited))\\n        \\n        if y > 0 and not (x, y-1) in visited:\\n          S.append((mines, board, x, y-1, visited))\\n        \\n        if y < H and not (x, y+1) in visited:\\n          S.append((mines, board, x, y+1, visited))\\n        \\n        if x > 0 and y > 0 and not (x-1, y-1) in visited:\\n          S.append((mines, board, x-1, y-1, visited))\\n        \\n        if x > 0 and y < H and not (x-1, y+1) in visited:\\n          S.append((mines, board, x-1, y+1, visited))\\n        \\n        if x < W and y > 0 and not (x+1, y-1) in visited:\\n          S.append((mines, board, x+1, y-1, visited))\\n        \\n        if x < W and y < H and not (x+1, y+1) in visited:\\n          S.append((mines, board, x+1, y+1, visited))\\n    return 'Impossible'\\n  \\n  T = int(raw_input())\\n  for t in range(T):\\n    W, H, M = map(int, raw_input().split())\\n    print 'Case #%i:\\n%s' % (t+1, solve(W, H, M).strip())\\n", "substitutes": {"W": ["Z", "P", "CW", "A", "R", "WR", "WM", "B", "WS", "WN", "WP", "We", "DC", "L", "J", "Web", "F", "X", "WC", "K", "Gr", "Work", "GW", "Ch", "E", "WH", "VW", "G", "D", "U", "Y", "Wh", "w", "FW", "V", "C", "Sl", "WB", "Sw", "Q", "N", "SW", "MW", "WA", "SH", "WE"], "H": ["EH", "Z", "HI", "P", "O", "HM", "HY", "R", "Che", "HS", "Ph", "PH", "B", "He", "Hy", "Th", "FH", "J", "L", "h", "Kh", "F", "X", "K", "HC", "Gr", "Ha", "Work", "Ch", "E", " h", "RH", "WH", "TH", "NH", "G", "D", "DH", "MH", "Rh", "U", "OH", "Y", "Wh", "w", "Cl", "V", "C", "HD", "Sh", "Sl", "CH", "Sw", "Q", "N", "Hum", "SH", "HH", "Time", "HA"], "M": ["Z", "P", "O", "LM", "A", "R", "MN", "B", "m", "J", "L", "CM", "F", "X", "K", "DM", "I", "E", "SM", "MM", "G", "D", "MS", "MH", "U", "Y", "V", "C", "MB", "Q", "NM", "N", "MX"], "board": ["Z", "stroke", "SC", "A", "array", "node", "image", "all", "lay", "case", "list", "layout", "index", "document", "entry", "stream", "head", "player", "chart", "oo", "boards", "room", "code", "ward", "frame", "draw", "join", "wheel", "control", "way", "w", "panel", "bug", "clean", "slice", "home", "comment", "view", "ko", "body", "menu", "lock", "card", "ack", "table", "back", "form", "wall", "hole", "down", "sequence", "Board", "video", "door", "object", "flow", "boarding", "que", "f", "builder", "flo", "client", "bo", "book", "post", "cart", "input", "check", "U", "work", "line", "Q", "section", "word", "coll", "one", "o", "square", "group", "deck", "run", "sc", "channel", "loop", "null", "point", "foot", "rule", "game", "che", "bar", "b", "model", "design", "boy", "land", "bank", "block", "feed", "lane"], "x": ["ph", "zx", "image", "ix", "ax", "yx", "index", "wy", "event", "name", "ice", "any", "time", "ox", "h", "ex", "position", "area", "code", "no", "key", "xi", "z", "ic", "wa", "w", "yl", "xy", "v", "u", "ip", "on", "sex", "xml", "cross", "cy", "id", "height", "full", "pe", "xxx", "view", "width", "m", "python", "fx", "ux", "c", "ady", "i", "win", "xc", "gy", "rx", "xp", "pos", "ctx", "ty", "n", "int", "ct", "lat", "p", "ci", "com", "d", "dy", "X", "f", "wx", "host", "e", "el", "px", "xe", "check", "size", "xs", "a", "work", "j", "left", "line", "my", "content", "xx", "one", "o", "dx", " xx", "xf", "q", "lex", "point", "xt", "l", "ya", "oint", "www", "k", "r", "type", " X", "g", "ey", "b", "tx"], "S": ["Z", "P", "SL", "SC", "A", "R", "O", "B", "WS", "sb", "states", "SE", "ST", "L", "F", "SA", "D", "OSS", "U", "Y", "V", "C", "STATE", "Si", "OS", "Set", "SU", "State", "NS", "N", "south", "SH", "SS"], "state": ["p", "session", "node", "start", "case", "comment", "se", "address", "list", "image", "config", "range", "run", "states", "shadow", "order", "scope", "space", "head", "player", "body", "point", "parent", "step", "port", "message", "position", "area", "core", "data", "e", "rule", "scale", "key", "back", "dict", "shape", "post", "set", "k", "part", "r", "match", "size", "work", "g", "j", "object", "STATE", "model", "pos", "line", "sync", "State", "store", "private", "resource", "block", "style", "section", "slice", "stat"], "mines": ["eminions", "Minutes", "Miners", "minsodes", "Minenses", "menences", " mininates", "maines", "mainences", "minsies", "menES", "minsES", "minsss", "eminunes", "mainutes", "Minodes", "Minises", "Minores", "mininates", "emininates", "mainies", "minES", "minises", " minunes", " minues", "eminees", "minsutes", "eminues", " minss", "miners", "Minues", " minores", " minions", "MINues", " minES", "minenses", "minsers", "mainions", "minies", "MINes", "minores", " minees", "minss", "minsences", "minunes", "minsenses", "Mininates", " miners", "Minences", "Minions", "minsions", "minees", "minsises", "minses", " minodes", "minsores", "MINences", "MinES", "MINions", "Mines", "minsues", "Minies", "menes", "Minees", "minences", " minenses", "minutes", "MINES", " minises", "menss", " minences", "minions", "emines", "Minunes", "minues", "minodes"], "y": ["ix", "fy", "ch", "sy", "yx", "wy", "ly", "any", "ish", "ley", "h", "ery", "oo", "en", "iny", "area", "key", "year", "yd", "z", "w", "yl", "xy", "v", "u", "isy", "cy", "id", "height", "hy", "m", "out", "c", "yt", "ym", "ies", "ady", "yi", "ie", "i", "gy", "Y", "yn", "iy", "ty", "n", " Y", "p", "py", "file", "d", "yo", "dy", "f", "e", "el", "ky", "a", "j", "ys", "my", "yes", "sky", "yy", "yr", "o", "ity", "q", "ye", "ot", "ay", "ny", "ya", "yan", "vy", "hot", "ry", "yah", "type", "ey", "b", "hop", "zy", "oy"], "visited": ["Visiting", "Visited", "VISed", "denited", " vised", " visitors", "dened", "visiting", "versed", "mined", "Vised", "VISITED", "denitors", "minITED", "deniting", "VISored", "visITED", "vised", "versored", "minited", " visiting", "VISited", "minored", "versITED", "Visitors", "versited", "visored", "visitors"], "s": ["p", "o", "session", " parts", "single", "se", "ss", "sb", "states", "ns", "d", "h", "es", "l", "f", " ss", "c", "e", "ses", "series", "ings", "ions", "us", "i", "rows", "r", "settings", "a", "w", "g", "sg", "b", "its", "ing", "string", "south", "n", "si", "sl", "sv", "ed", "sym"], "row": ["up", "node", "col", "rank", "month", "range", "index", "entry", "view", "loop", "ro", "raw", "port", "week", "insert", "scan", "ward", "key", "frame", "hole", "rows", "rect", "round", "cell", "arrow", "r", "cube", "ross", "Row", "instance", "server", "line", "flow", "string", "page", "feed", "block", "ride", "result", "section", "sel", "slice"]}}
{"code": "T = int(raw_input())\\n  for i in range(T):\\n    index = int(raw_input())\\n    X = []\\n    for j in range(4):\\n      X.append(map(int, raw_input().split()))\\n    x1 = X[index-1]\\n    index = int(raw_input())\\n    X = []\\n    for j in range(4):\\n      X.append(map(int, raw_input().split()))\\n    x2 = X[index-1]\\n    ans = set(x1).intersection(set(x2))\\n    if len(ans) == 0:\\n      print 'Case #%i: Volunteer cheated!' % (i+1)\\n    elif len(ans) == 1:\\n      print 'Case #%i: %i' % (i+1, ans.pop())\\n    else:\\n      print 'Case #%i: Bad magician!' % (i+1)\\n", "substitutes": {"T": ["Z", "P", "O", "A", "TT", "R", "Length", "S", "TW", "B", "CI", "time", "L", "x", "F", "I", "K", "Index", "t", "Total", "TN", "G", "M", "D", "Y", "C", "V", "H", "length", "Q", "N", "TI", "Time"], "i": ["p", "it", "chi", "li", "ui", "id", "ci", "ix", "cli", "m", "ji", "ini", "phi", "ai", "multi", "x", "ind", "y", "l", "gi", "I", "f", "ii", "c", "ti", "e", "eni", "t", "yi", "zi", "key", "ie", "uri", "ik", "mini", "xi", "di", "pi", "axis", "z", "k", "type", "uni", "ij", "im", "ib", "dim", "ip", "iw", "u", "qi", "n", "si", "int", "iu", "slice"], "index": ["element", "iter", "it", "offset", "start", "sort", "id", "PI", "ix", "list", "EX", "xxx", "ID", "weight", "CI", "name", "null", "x", "span", "point", "ind", "I", "search", "Index", "IND", "position", "connection", "alpha", "end", "edit", "thread", "temp", "key", "condition", "inc", "num", "shape", "type", "match", "value", "degree", "column", "length", "FIX", "pos", "number", "diff", "action", "loc", "tick", "int", "test", "section", "slice", "date", "site", "tail"], "X": ["XP", "Z", "Test", "P", "Array", "A", "Do", "IX", "EX", "WS", "FC", "Content", "FF", "Input", "HTTP", "CL", "x", "L", "POST", "XT", "F", "K", "Box", "Index", "Work", "Current", "E", "CT", "XL", "IP", "Front", "Stack", "Int", "D", "M", "G", "Ex", "XX", "Cross", "XXX", "U", "Y", "ZX", "V", "H", "C", "Case", "JSON", "FIX", "OX", "ML", "Q", "W", "List", "MX", "N", "Single", "Event", "Time", "ENS"], "j": ["p", "_", "it", "q", "jp", "ji", "d", "J", "x", "ind", "l", "f", "get", "y", "c", "t", "jl", "ie", "k", "z", "jj", "r", "je", "g", "b", "n", "int", "ct"], "x1": ["X2", " x0", "viewFirst", "p1", "view5", "xFirst", "view2", "x0", "pOne", " xFirst", "X1", " xOne", "X5", "p2", " x5", "XFirst", "x5", "view1", "p0", "xOne", "X0", "XOne"], "x2": ["index1", "X2", "cross02", "v1", " x02", "X1", " x4", "cross2", "X4", "indextwo", "cross4", "index2", "xtwo", "Xtwo", "X02", "x02", "vtwo", "v2", "x4", "cross1"], "ans": ["aning", "meaning", "ons", "An", "A", "annot", "ls", "amps", "san", "na", "aus", "ns", "ins", "anas", "x", "ams", "es", "nas", "cus", "aos", "who", "ann", "lan", "anus", "names", "atan", "anne", "anon", "os", "ants", "can", "antis", "part", "ens", "AN", "anc", "gan", "a", "Ann", "ars", "ani", "aned", "ANS", "ana", "oss", "cas", "an", "cs", "ras", "cross", "cases"]}}
{"code": " \\n  def all_grids(R,C,M, lp=0,placed=0):\\n      rem = R*C-lp\\n      if M-placed >= rem:\\n          if M-placed > rem:\\n              return None\\n          \\n          res = set()\\n          for i in range(lp, R*C):\\n              res.add(i)\\n          return [res]\\n          \\n      if placed == M:\\n          return [set()]\\n  \\n      res = []\\n      for i in range(lp, R*C):\\n          sub_sol = all_grids(R,C,M,i+1, placed+1)\\n          if sub_sol is None:\\n              continue\\n              \\n          for s in sub_sol:\\n              s.add(i)\\n              res.append(s)\\n      return res\\n  \\n  def adj(R,C,i):\\n      \\n      res = []\\n      left_edge = i % C == 0\\n      top_edge = i // C == 0\\n      right_edge = (i+1) % C == 0\\n      bottom_edge = i // C == R-1\\n      \\n      if not left_edge:\\n          res.append(i-1)\\n          if not top_edge:\\n              res.append(i-1-C)\\n          if not bottom_edge:\\n              res.append(i+C-1)\\n              \\n      if not right_edge:\\n          res.append(i+1)\\n          if not top_edge:\\n              res.append(i+1-C)\\n          if not bottom_edge:\\n              res.append(i+1+C)\\n              \\n      if not bottom_edge:\\n          res.append(i+C)\\n      if not top_edge:\\n          res.append(i-C)\\n      return res\\n          \\n      \\n      \\n      \\n  def solution(R,C,g):\\n      M = R*C\\n      res = []\\n      num_zeroes = 0\\n      for i in range(M):\\n          if i in g:\\n              res.append('x')\\n              continue\\n          x = 0\\n          for a in adj(R,C,i):\\n              if a in g:\\n                  x += 1\\n          if x == 0:\\n              num_zeroes += 1\\n          res.append(x)\\n          \\n      for i in range(M):\\n          if i in g:\\n              continue\\n          r = res[i]\\n          if r == 0 and num_zeroes == 1:\\n              continue\\n          connected = False\\n          for a in adj(R,C,i):\\n              if res[a] == 0:\\n                  connected = True\\n                  break\\n          if not connected:\\n              return None\\n      \\n      return res.index(0)\\n  \\n  def transcribe(R,C, g, sol):\\n      res = []\\n      for i in range(R):\\n          r = []\\n          for j in range(C):\\n              x = i*C+j\\n              if x in g:\\n                  r.append('*')\\n              elif x == sol:\\n                  r.append('c')\\n              else:\\n                  r.append('.')\\n          res.append(r)\\n      return res\\n  \\n  def printed_sol(transcript):\\n      if transcript is None:\\n          return \"Impossible\"\\n      else:\\n          return \"\\n\".join(\"\".join(row) for row in transcript)\\n  \\n  def solve(R,C,M):\\n      if M == R*C-1:\\n          g = []\\n          for i in range(R*C-1):\\n              g.append(i)\\n          return transcribe(R,C, g, R*C-1)\\n      \\n      for g in all_grids(R,C,M):\\n          sol = solution(R,C,g)\\n          if sol is None:\\n              continue\\n          return transcribe(R,C, g, sol)\\n      return None\\n              \\n      \\n  def output_grid(R,C,g):\\n      for i in range(R):\\n          for j in range(C):\\n              if i*C+j not in g:\\n                  sys.stdout.write(\".\")\\n              else:\\n                  sys.stdout.write(\"*\")\\n          sys.stdout.write(\"\\n\")\\n  \\n  if __name__ == \"__main__\":\\n      T = int(raw_input())\\n      for i in range(1,T+1):\\n          R,C,M = map(int, raw_input().split())\\n          print \"Case #%d:\" % i\\n          print printed_sol(solve(R,C,M))\\n", "substitutes": {"R": ["P", "A", "WR", "CR", "KR", "S", "JR", "B", "Ra", "MR", "RA", "AR", "Rule", "RE", "L", "RR", "Run", "J", "LR", "F", "X", "RN", "BR", "K", "I", "RP", "ER", "Rec", "RW", "Rs", "E", "IR", "NR", "RH", "Right", "DR", "RO", "TR", "Rob", "D", "G", "Rh", "U", "GR", "RS", "Cl", "RL", "V", "H", "RG", "Q", "Re", "SR", "N", "W", "Res", "RM", "Br", "RC", "RIP", "Range"], "C": ["CC", "P", "O", "SC", "CF", "CR", "ERC", "A", "CS", "S", "B", "FC", "Cs", "CI", "YC", "JC", "DC", "L", "CL", "CM", "F", "X", "I", "K", "CV", "WC", "Sc", "c", "Ch", "GC", "CU", "E", "CT", "CN", "CNN", "VC", "D", "G", "Central", "EC", "MC", "NC", "U", "Count", "Y", "CA", "Cl", "H", "CP", "V", "Cu", "Size", "Q", "KC", "W", "N", "CE", "Con"], "M": ["p", "P", "O", "LM", "A", "MF", "S", "MN", "B", "mm", "MO", "MR", "m", "man", "J", "L", "MP", "MA", "CM", "F", "X", "I", "DM", "IM", "JM", "E", "REM", "Multi", "MM", "D", "G", "OM", "MC", "MD", "U", "cm", "Y", "V", "PM", "MT", "H", "EM", "ML", "MB", "Q", "NM", "W", "N", "MX", "RM", "FM", "Mi"], "lp": ["pl", "p", "pm", "fp", "LM", "PP", "pp", "li", "lf", "P", "ls", "pit", "lc", "mm", "LP", "lb", "len", "LI", "m", "np", "pa", "L", "base", "LR", "l", "cp", "RP", "lvl", "lv", "bp", "pre", "cm", "dl", "CP", "b", "Mp", "loc", "lr", "mp", "layer"], "placed": ["replace", "pl", "p", "pm", "P", "pool", "PL", "filled", "li", "powered", "sp", "holder", "B", "place", "ld", "mm", "seq", "lb", "len", "Position", "LP", "m", "LI", "led", "mr", "pa", "arent", "l", "central", "found", "shaped", "aid", "position", "mounted", "assembled", "no", "used", "ordered", "aced", "shared", "pre", "packed", "selected", "represented", "occupied", "places", "numbered", "fe", "reg", "cm", "pg", "controlled", "left", "mi", "b", "pos", "paid", "added", "owned", "loc", "marked", "ed", "claimed", "named", "section", "matched"], "rem": ["ref", "me", "pm", "sp", "resp", "place", "mm", " Rem", "rest", "Rem", "jp", "m", "pa", "mem", "pres", "REM", "ret", "cache", "repl", "prev", "pre", "pop", "ps", "prem", "cm", "reg", "remove", "recent", "cl", "im", "re", "kept", "min", "master", "xp", "remote", "rm", "original", "exp", "rep"], "res": ["ons", "response", "ios", "ws", "js", "rest", "powers", "details", "gr", "ins", "resolution", "RES", "Rs", "rus", "os", "rh", "reg", "RS", "sr", "ms", "Res", "ros", "cs", "ras", "cases", "pers", "vals", "resp", "relations", "params", "works", "es", "arr", "req", "right", "ries", "args", "rates", "rev", "models", "rules", "rez", "rx", "changes", "remote", "rs", "result", "exp", "results", "p", "resources", "lines", "S", "nos", "eps", "seq", "qs", "mr", "css", "rss", "max", "ids", "ES", "ret", "bs", "rel", "blocks", "Result", "loc", "err", "ris", "maps", "features", "resh", "runs", "rc", "errors", "yrs", "ns", "rys", "pres", "ress", "rows", "obj", "ps", " results", "re", "Results", "cells", " Res", "breaks"], "i": ["it", "iq", "chi", "image", "ios", "ix", "lc", "index", "cli", "ai", "y", "position", "ti", "eni", "zi", "uri", "xi", "z", "ic", "mi", "v", "ami", "ip", "u", "io", "slice", "ui", "isi", "id", "oi", "ori", "m", "ini", "phi", "multi", "bi", "ind", "gi", "c", "yi", "ie", "sci", "hi", "n", "int", "p", "li", "ci", "ei", "ji", "f", "I", "aci", "e", "t", "anti", "mini", "di", "info", "ni", "im", "si", "err", "iter", "o", "ia", " bi", "ri", "l", "ii", "ir", "api", "pi", "b", "iw", "qi", "iu"], "sub_sol": ["subjSol", "subregol", "subregsl", "Sub_Sol", " sub_oln", "subjoln", "Sub_sol", "subregsol", "Sub_sql", "sub_sl", "subjsol", "subpubrel", "subpubsol", "subjol", "subjsql", "subjrel", "subregSol", "sub_Sol", " sub_sl", " sub_ol", "subpuboln", " sub_Sol", "sub_oln", " sub_rel", "subpubol", "sub_sql", "sub_ol", "sub_rel"], "s": ["p", "o", "sq", "se", "ls", "ws", "sp", "sim", "S", "ss", "sb", "states", "spec", "sc", "details", "su", "ns", "m", "d", "resolution", "es", "l", "search", "c", "e", "ses", "sets", "ions", "sites", "os", "sub", "ps", "sec", "ages", "settings", "fs", "sg", "sr", "cells", "sys", "sf", "sl", "si", "n", "cs", "results"], "left_edge": ["left_line", "full_edge", "left_ee", "right_side", "left_end", "full_end", "full_side", "full_ee", "right_line", "left_side"], "top_edge": ["top\u00b7ide", "top_ge", "top_ide", "top\u00b7distance", "topingedge", "middle_distance", "root_hop", " top_end", "bottom_size", "top_distance", "topingelement", "top_size", "middle_edge", "top\u00b7line", "topingend", "middle\u00b7distance", "top_event", "top_gate", "top\u00b7edge", "root_edge", "middle\u00b7edge", "top_hop", "bottom_line", "middle_ide", "top_line", " top_ge", "middle\u00b7ide", "middle\u00b7line", "topingge", "bottom_event", "root_gate", "root_ge", "top_element", "top_end", "middle_line", " top_element"], "right_edge": ["right_age", "down_age", "top_pe", "right\u00b7enter", "right__edge", "top_enter", "right__age", "right_enter", "right\u00b7pe", "down_Edge", "right\u00b7edge", "right_tie", "right\u00b7end", "top_end", "down_edge", "right__Edge", "right_end", "down_tie", "right_pe", "right_Edge", "right__tie"], "bottom_edge": ["wrong\u00b7anne", "wrong_anne", "wrong_link", "wrong\u00b7layer", "wrong_edge", "wrong\u00b7link", "bottom_layer", " bottom_end", "front_edge", "front_degree", "bottom_error", "bottom_end", "bottom_enter", " bottom_enter", "bottom\u00b7anne", "bottom_degree", "front_line", "bottom\u00b7layer", "bottom\u00b7edge", "bottom_anne", "bottom_grade", "bottom_link", "wrong\u00b7edge", " bottom_grade", "bottom_route", "wrong_layer", "bottom_line", "top_error", "top_ense", "top_end", "bottom_ense", "bottom\u00b7link", "front_route"], "g": ["erg", "p", "CG", "gen", "ig", "GV", "ch", "bg", "group", "gm", "gb", "q", "gr", "m", "GS", "d", "GG", "h", "msg", "l", "gi", "f", "cfg", "c", "GF", "play", "e", "GC", "gs", "gh", "game", "ge", "gp", "Group", "ga", "G", "k", "gg", "go", "gre", "ic", "groups", "rg", "reg", "LG", "w", " G", "cl", "sg", "b", "v", "Gs", "mg", "gc", "n", "eg", "gl", "gu", "mc"], "num_zeroes": ["num_zooms", "num_zooes", "num_zoops", "num_zeros", "num_eroms", "num_eroes", "num_zops", "num_zoes", "num_zerops", "num_zonos", "num_zoeros", "num_zoos", "num_zzops", "num_zzos", "num_zeroms", "num_zoom", "num_zooom", "num_zzoes", "num_erops", "num_zeroom", "num_zos", "num_eros", "num_zereros", "num_zoms", "num_zonoes", "num_zoneros", "num_zonops", "num_zzoom"], "x": ["p", "dx", "id", "ix", "ax", "xxx", "xf", "index", "yx", "width", "m", "h", "ex", "y", "X", "f", "wx", "xt", "xxxxxxxx", "xa", "c", "e", "t", "xes", "px", "xi", "xe", "z", "rex", "xs", "xc", "rx", "w", "work", "xy", "v", "xp", "u", "xxxx", "xx", "xml", "xb", "int", "exp", "cross", "tx"], "a": ["err", "p", "o", "A", "ma", "la", "all", "br", "active", "ra", "aaa", "ia", "na", "aa", "ae", "sa", "m", "ar", "d", "ai", "ea", "ya", "y", "f", "alpha", "c", "area", "e", "t", "ha", "ba", "xi", "ga", "ta", "z", "ja", "ad", "wa", "w", "b", "u", "ana", "ca", "n", "an", "result", "int", "ac"], "r": ["err", "p", "o", "br", "array", "ar", "m", "d", "h", "l", "y", "f", "c", "nr", "e", "t", "ur", "k", "z", "w", "re", "b", "v", "sr", "attr", "u", "pr", "n", "rs", "er"], "connected": ["br", "thin", "bound", "rounded", "active", "open", "valid", "rational", "online", "supported", "path", "red", "run", "established", "broken", "tested", "sc", "function", "shown", "h", "ended", "central", "f", "tun", "connection", "linked", "Connect", "compatible", "visible", " disconnected", "opened", "rev", "no", "sect", "complex", "ordered", "graph", "selected", "conn", "con", "reg", "closed", "fitted", "public", "controlled", "hidden", "normal", "on", "loc", "rupt", "ed", "loaded", "connect", "finished", "wired", "charged"], "sol": ["ls", "poly", "gm", "col", "group", "q", "gr", "GS", "gi", "cr", "Gr", "Sol", "grid", "GF", "gs", "sql", "graph", "groups", "reg", "GR", " G", "sg", "ol", "model", "min", "mol", "gl", "gn"]}}
{"code": "def solve(c1, g1, c2, g2):\\n      row_1 = g1[c1-1]\\n      row_2 = g2[c2-1]\\n      inter = set(row_1) & set(row_2)\\n      if len(inter) == 0:\\n          return \"Volunteer cheated!\"\\n      if len(inter) > 1:\\n          return \"Bad magician!\"\\n      return str(inter.pop())\\n  \\n  if __name__ == \"__main__\":\\n      T = int(raw_input())\\n      for i in range(1,T+1):\\n          c1 = int(raw_input())\\n          g1 = []\\n          for j in range(4):\\n              g1.append(map(int, raw_input().split()))\\n          c2 = int(raw_input())\\n          g2 = []\\n          for j in range(4):\\n              g2.append(map(int, raw_input().split()))\\n          print \"Case #%d: %s\" % (i, solve(c1,g1,c2,g2)) \\n          \\n      \\n", "substitutes": {"c1": ["col2", "p1", "dc1", "c_", " c_", "c01", "cu_", "c0", "lc1", "pOne", "g4", " c01", " c0", "gOne", "colfirst", "g_", "g01", "lc2", "pfirst", "cfirst", "p2", "col1", "g0", " cOne", "cOne", "gfirst", "dc2", "colOne", "cu2", "lc4", "lc0", "dc4", "lcOne", "c4", "cu1", "cu01"], "g1": ["ga2", "g9", " g12", "c81", "p1", "g81", "gone", "G1", "gaart", "cone", "gOne", " g61", "ig61", "gup", "G9", "gen2", "c3", " gOne", "p81", "p2", "g61", " gd", " g81", "g3", "gart", "G2", "G61", "cOne", "ga1", "ig1", "gen1", "cart", "gen12", "ig2", "gaone", " g3", "pd", "geOne", "gd", " g9", "cd", " gone", "g12", "ge1", " gart", "gen3", "ig9", " gup", "geup", "cup", "ge2", "c12"], "c2": ["t5", "C2", "cSecond", "arc4", "c72", "e62", "cTwo", "ctwo", "g4", "i2", "dc5", "e5", " c62", " c5", "c62", "c5", "i5", "arcSecond", " ctwo", " cTwo", "arctwo", " c72", "t72", "arc2", "gSecond", "C1", "dcTwo", "iTwo", "dc2", "gtwo", "Ctwo", "arc1", "e2", "e72", "t2", "itwo", "c4", "dctwo", "t62", "CSecond", "C4"], "g2": ["ga2", "g02", "g002", "gaall", " g82", "cTwo", "gall", "c0", "G1", "g4", "c5", "gen5", "G02", "G002", "gen2", "ga4", "g0", "genTwo", "G2", "g82", "g3", " g02", "ga1", "ga02", "c002", "G0", " gTwo", " g3", " g0", "gen4", "g5", "G82", "G4", " g4", "G3", "c82", "call", "c4", "gTwo", " gall", " g002", "ga3", " g5"], "row_1": ["row_x", "rowA1", "column_1", "row_one", "rowAfirst", "row_first", "rowAx", "column_4", "rowA4", " row_one", " row_first", "column_x", "row_4", "column_first"], "row_2": ["row_22", "col_1", "col_22", "row_g", "row_two", "col_0", " row_two", " row_g", "col_2", "row_0"], "inter": ["iter", "air", "up", "ver", "square", "outer", "filter", "INTER", "cor", "pair", " Inter", "entry", "international", "ar", "ext", "feature", "double", "car", "mer", "step", "fr", "edge", "ace", "ir", "pointer", "chain", "inner", "intern", "inch", "intel", "Inter", "ter", "inc", "tri", "el", "pre", "inters", "ner", "part", "pin", "angle", "con", "match", "diff", "char", "quad", "si", "patch", "interface", "sel", "er", "int", "section", "ser", "over"], "T": ["Z", "P", "O", "A", "R", "S", "WT", "B", "time", "L", "F", "X", "I", "t", "TS", "E", "TN", "Ti", "G", "M", "D", "U", "Y", "C", "V", "H", "length", "Q", "W", "N", "TI", "Time"], "i": ["p", "it", "chi", "li", "ci", "index", "ji", "d", "phi", "J", "x", "ind", "y", "gi", "I", "f", "ri", "ii", "c", "ti", "e", "t", "uri", "pi", "xi", "di", "z", "a", "g", "b", "v", "u", "ip", "qi", "n", "io", "si", "int", "iu"], "j": ["p", "_", "it", "id", "js", "q", "jp", "ji", "d", "J", "x", "ind", "l", "f", "t", "jl", "job", "k", "z", "jj", "r", "ja", "g", "ij", "dj", "im", "row", "b", "v", "n", "int", "ge", "uj"]}}
{"code": " \\n  \\n  tCase = int(sys.stdin.readline())\\n  \\n  \\n  def map(R, C, Bombs):\\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\\n  \tprint Bombs\\n  \tm[R-1][C-1] = 'c'\\n  \tlastSkip = False\\n  \tfor i in xrange(R):\\n  \t\tfor j in xrange(C):\\n  \t\t\tif Bombs == 0:\\n  \t\t\t\tbreak\\n  \t\t\t\\n  \t\t\tif lastSkip:\\n  \t\t\t\tm[i][j] = 'f'\\n  \t\t\t\tcontinue\\n  \t\t\t\\n  \t\t\tif R - i == 2 or C - j == 2:\\n  \t\t\t\tif Bombs == 1:\\n  \t\t\t\t\tm[i][j] = 'f'\\n  \t\t\t\t\tlastSkip = True\\n  \t\t\t\t\tcontinue\\n  \t\t\t\\n  \t\t\t\t\\n  \t\t\tm[i][j] = '*'\\n  \t\t\tBombs -= 1\\n  \t\t\tlastSkip = False\\n  \t\tlastSkip = False\\n  \t\t\t\t\\n  \t\\n  \t\\n  \tfor line in m:\\n  \t\tfor c in line:\\n  \t\t\tprint c,\\n  \t\tprint\\n  \t\t\\n  \t\t\\n  def imprimir(m):\\n  \tfor line in m:\\n  \t\tfor c in line:\\n  \t\t\tprint c,\\n  \t\tprint\\n  \t\t\\n  def map2(R, C, Bombs):\\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\\n  \tm[R-1][C-1] = 'c'\\n  \tlastSkip = False\\n  \t\\n  \tii = 0\\n  \tjj = 0\\n  \twhile Bombs > 0:\\n  \t\tfor j in xrange(jj, C):\\n  \t\t\tif Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\\n  \t\t\t\tm[ii][j] = '*'\\n  \t\t\t\tBombs -= 1\\n  \t\t\telse:\\n  \t\t\t\tcontinue\\n  \t\t\\n  \t\t\\n  \t\tfor i in xrange(ii+1, R):\\n  \t\t\tif Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\\n  \t\t\t\tm[i][jj] = '*'\\n  \t\t\t\tBombs -= 1\\n  \t\t\telse:\\n  \t\t\t\tif Bombs > 0:\\n  \t\t\t\t\tprint \"Impossible\"\\n  \t\t\t\t\treturn\\n  \t\t\t\tcontinue\\n  \t\tjj += 1\\n  \t\tii += 1\\n  \timprimir(m)\\n  \t\\n  \t\t\t\t\\n  \t\\n  \t\\n  \\n  \t\t\\n  def main(R, C, M):\\n  \tvazios = R * C - M\\n  \\n  \tif R == 1 or C == 1 or vazios == 1 or vazios >= 4:\\n  \t\tmap2(R, C, M)\\n  \telse:\\n  \t\tprint \"Impossible\"\\n  \\n  \treturn \"\"\\n  \t\t\\n   \\n  if __name__ == '__main__':\\n  \tfor i in xrange(tCase):\t\\n  \t\t\\n  \t\tR, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tprint \"Case #%d:\" % (i + 1)\\n  \t\tmain(R, C, M)\\n", "substitutes": {"tCase": ["tfName", "ttName", "ttcase", "tfcases", "tcases", "TCase", "tfCase", "TName", "ttCase", "tfcase", "ttPath", " tPath", "tPath", "Tcase", " tcase", "Tcases", "tName", "tfPath", "TPath", " tcases", "tcase"], "R": ["P", "O", "A", "CR", "WR", "KR", "S", "JR", "B", "Ra", "Region", "Block", "RA", "T", "Line", "AR", "J", "L", "RR", "Run", "CL", "F", "X", "RN", "K", "I", "BR", "Rec", "ER", "Sc", "RW", "RP", "Rs", "E", "All", "IR", "NR", "RH", "Right", "DR", "RO", "TR", "D", "G", "r", " r", "Rh", "Par", "RE", "U", "Y", "GR", "RS", "Cl", "V", "H", "RL", "RG", "LR", "Q", "Re", "SR", "N", "W", "Res", "RM", "Br", "RIP", "Range", "Role"], "C": ["CC", "P", "O", "SC", "CR", "A", "CF", "CW", "Cr", "RFC", "CS", "S", "Code", "B", "Cs", "CI", "YC", "JC", "T", "DC", "L", "CL", "J", "CM", "AC", "X", "F", "I", "K", "CV", "Sc", "Ch", "GC", "CU", "E", "CN", "CNN", "VC", "D", "G", "EC", "MC", "U", "Y", "CA", "Ca", "Cl", "V", "H", "Cu", "Size", "Q", "KC", "W", "N", "CE"], "Bombs": ["Ambones", "bomb", "BFombs", "besses", "Balauts", "SBandals", "Bunks", " Borers", "OBombies", "Buffomers", "Baombie", "Bomb", "brees", "Bowers", "FBombs", "Phurches", " Bambers", "Bacteria", "Lambers", "UBombs", "Ubambers", "Blocks", " Baches", "Businessategories", "bouts", "Subunks", "BBacteria", "GBumbs", "Bashes", "BFesses", "SBombs", "Lombs", "Blombies", "MBombs", "Bumbs", "Bbusters", "Bliers", "Blockandals", "BFurches", "Ubombs", "bambers", "Balouts", "UBballs", "Ambbusters", "Bballs", "bomas", " Bomas", "bumbs", "Buffauts", "Biers", "Balballs", " Bumbs", "BBasm", "PBombs", "PBowers", "Bones", " Bones", "bombs", "GBambers", "FBashes", "Phomers", "Bomas", " Bballs", "MBambers", "BWaos", "GBiers", "basm", "Balresses", "BBouts", " Bauts", "Ambombs", "BWumbs", "bounces", "MBombies", "Bauts", "Bomes", "Bandals", "bones", "Balosion", "BWombs", "GBombs", "Besses", "SBorers", "Forders", " Baos", "Balombs", " Bandals", "bballs", "BBaos", "Borders", "baches", "OBumbs", "Suborers", " Bomb", " Bombie", "Ambomas", "bbusters", "Lumbs", "Baounces", "Fomb", "Ubballs", "BBomb", "BBombies", " Borders", "Buffombs", "Burches", "Businessombies", "Businessombs", "Balacteria", "FBresses", "OBambers", "MBumbs", "Bombies", "Baombs", "Bambers", "UBresses", "Bresses", "Baches", " Bbusters", "Bootorders", "Bootlocks", "Blategories", "blocks", "BBombs", "Basm", "Bomers", " Bounces", " Bouts", "baos", "Blacteria", "Balashes", "Bosion", "Blockauts", "bomes", " Brees", "FBballs", "Baos", "BFomers", "Bombie", "GBombies", "BFauts", "BFaches", "OBombs", "BWomb", " Bomes", "Bounces", "borders", "SBunks", "PBorders", "UBashes", "Bategories", "GBategories", "Bootombs", "BFomes", "Borers", " Besses", "Blockombs", "Fambers", "bombie", "bauts", " Bunks", "bosion", "Louts", "Balombies", "Phombs", "Phauts", "Businessiers", "Bootowers", "Subandals", "Fombs", "Subombs", "Blockosion", "Ubauts", "bowers", "Brees", "Balandals", "Bouts", "Barees", " Basm", "PBlocks", "Blouts", "bandals", "Blombs", "Buffurches"], "m": ["p", "o", "pm", "mo", "ma", "gm", "lin", "mu", "mm", "fm", "machine", "sm", "man", "mr", "d", "h", "am", "l", "y", "f", "ml", "message", "ym", "bm", "e", "t", "semble", "dm", "form", "mini", "md", "media", "um", "mos", "hm", "module", "em", "r", "z", "cm", "a", "w", "g", "im", "mi", "b", "v", "s", "ms", "u", "vm", "om", "rm", "n", "wm", "mc"], "x": ["p", "_", "ph", "vent", "ww", "id", "ix", "full", "ax", "xxx", "xf", "index", "event", "q", "fx", "lex", "xt", "h", "ex", "X", "l", "ux", "f", "y", "xxxxxxxx", "e", "code", "t", "xes", "rax", "xi", "k", "z", "r", "rex", "XX", "nex", "xs", "xc", "rx", "work", "co", "w", "a", "xy", "b", "v", "xp", "ctx", "u", "xxxx", "on", "sex", "xx", "n", "word", "cross", "tx"], "lastSkip": [" LastDiff", " Lastskip", "latestskip", "latestHop", "nextSkip", "LastJump", "LastHop", "lastJump", "firstskip", " LastSkip", " lastskip", "Lastskip", "nextJump", "lastskip", "lastCopy", "LastSkip", "firstSkip", " lastCopy", "nextCopy", " LastCopy", "nextskip", "LastCopy", "latestSkip", " lastDiff", " lastJump", " lastHop", "firstCopy", "latestCopy", "lastDiff", "firstJump", "lastHop", "LastDiff"], "i": ["p", "o", "it", "ui", "li", "id", "ci", "ix", "ei", "ori", "q", "ji", "ini", "d", "ai", "multi", "bi", "h", "l", "ri", "f", "I", "y", "gi", "iv", "ti", "vi", "e", "eni", "ir", "yi", "ili", "ie", "pi", "xi", "di", "z", "r", "ic", "ni", "fi", "a", "g", "ij", "im", "mi", "b", "v", "ani", "u", "ip", "qi", "n", "io", "si", "int", "iu"], "j": ["p", "o", "li", "ci", "ch", "ix", "js", "jc", "jit", "q", "jp", "ji", "d", "J", "h", "oj", "y", "l", "f", "ind", "adj", "e", "ir", "jl", "aj", "ie", "xi", "job", "k", "z", "note", "je", "r", "ja", "java", "a", "w", "ij", "im", "g", "dj", "b", "v", "jo", "jet", "u", "n", "uj"], "line": ["o", "li", "ync", "case", "word", "long", "link", "ino", "lines", "main", "online", "lin", "lc", "nc", "ine", "range", "ode", "log", "lining", "Line", "point", "l", "lock", "lace", "ite", "liner", "lo", "end", "code", "chain", "no", "nl", "ze", "ner", "set", "cell", "lined", "inline", "cycle", "cm", "co", "cl", "course", "eline", "sync", "store", "call", "string", "page", "block", "n", "le", "mc", "change"], "c": ["cu", "p", "case", "ci", "cc", "unc", "lc", "nc", "dc", "sc", "d", "out", "h", "l", "f", "cr", "uc", "e", "code", "cache", "ce", "fc", "ec", "k", "z", "r", "cat", "cycle", "cm", "xc", "co", "a", "cl", "w", "g", "cd", "b", "n", "cs", "mc", "pc", "ac", "cy"], "ii": ["ari", "ui", "li", "ci", "ix", "qa", "jc", "iii", "ei", "ice", "jp", "ji", "ini", "ai", "bi", "ind", "ri", "gi", "iv", "vi", "jl", "zi", "ie", "mini", "pi", "abi", "info", "di", "xi", "z", "ni", "uni", "fi", "sci", "ij", "II", "ani", "iw", "qi", "si", "inf", "ih", "iu", "ski"], "jj": ["CC", "Jump", "NJ", "jump", "li", "ww", "III", "ci", "ix", "cc", "JR", "jc", "qa", "jit", "iii", "mm", "ki", "rc", "ZZ", "JC", "jp", "q", "ji", "nn", "ai", "J", "kj", "ri", "gi", "aq", "Ja", "jl", "aj", "gh", "di", "pi", "ja", "java", "bb", "ni", "IJ", "ij", "II", "JJ", "dj", "jo", "iw", "qi", "xx", "yy", "uj"], "M": ["Mo", "Z", "P", "O", "LM", "A", "MF", "AM", "MN", "B", "MO", "T", "J", "L", "CM", "F", "X", "I", "K", "Man", "E", "MU", "D", "G", "MS", "MI", "MD", "MC", "U", "Y", "V", "H", "Q", "MX", "N", "W", "RM"], "vazios": ["vazeios", "Vazits", "vaudio", "baziol", "vachits", "vachio", "vaziol", "vaxicals", "vaslos", "vazixels", "vaudiol", "vazicho", " vazicals", "vaxio", "vachenos", "vazeiol", "baudios", "vasiol", "baudixels", "Vzits", "Vazio", "vzenos", "vzits", "vaudicho", "vzio", " vaudicals", "vazeits", " vazicho", "vaxios", "vaudlos", "Vzio", "vzicals", "vasios", "vasixels", "baudiol", "vachios", "vazeio", "vazits", "vzicho", "Vazenos", " vazio", "vazio", "bazlos", "vazlos", "vazeixels", "Vzenos", "vaudicals", "vaudixels", " vaudio", "vazicals", "vazenos", "vaxicho", "vazeenos", " vaudicho", "vzios", "vaudios", "bazios", "bazixels", "baudlos", "Vzios", "Vazios", " vaudios", "vazelos"]}}
{"code": " \\n  \\n  \\n  class Test(unittest.TestCase):\\n  \tdef test_1(self):\\n  \t\tself.assertEqual(main(5, 2, 2, [2,1]), 12)\\n  \tdef test_2(self):\\n  \t\tself.assertEqual(main(5,2,2,[1,2]), 12)\\n  \tdef test_3(self):\\n  \t\tself.assertEqual(main(3,3,4,[4,1,3,5]), 39)\\n  \tdef test_4(self):\\n  \t\tself.assertEqual(main(5,2,4,[5, 1, 1, 5]), 51)\\n  \\n  \\n  tCase = int(sys.stdin.readline())\\n  \\n  def main(A, B, AList, BList):\\n  \tresp = 0\\n  \tA = A - 1\\n  \tB = B - 1\\n  \tAlist = AList[A*4:A*4+4]\\n  \tBList = BList[B*4:B*4+4]\\n  \tcont = 0\\n  \tfor aa in Alist:\\n  \t\tif aa in BList:\\n  \t\t\tresp = aa\\n  \t\t\tcont += 1\\n  \t\t\\n  \tif cont == 1:\\n  \t\treturn resp\\n  \telif cont == 0:\\n  \t\treturn \"Volunteer cheated!\"\\n  \telse:\\n  \t\treturn \"Bad magician!\"\\n  \t\t\\n   \\n  if __name__ == '__main__':\\n  \tfor i in xrange(tCase):\t\\n  \t\t\\n  \t\tA = [int(x) for x in sys.stdin.readline().split(' ')][0]\\n  \t\tNList = [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tB = [int(x) for x in sys.stdin.readline().split(' ')][0]\\n  \t\tBList = [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tprint \"Case #%d: %s\" % (i + 1, main(A, B, NList, BList))\\n", "substitutes": {"self": ["err", "Self", "node", "case", "py", "full", "user", "driver", "worker", "app", "q", "func", "ns", "python", "writer", "h", "parent", "l", "http", "f", "host", "connection", "client", "e", "parser", "other", "cache", "us", "ng", "k", "work", "g", "w", "cl", "public", "object", "context", "this", "utils", "server", "plus", "instance", "ctx", "test", "er", "now"], "tCase": ["tCode", "testcase", "TTest", " tCode", "testCase", "tMode", "dtTest", "dtCase", "xcase", "TCase", "dtcase", "TMode", "Tcase", " tcase", "xCase", "testCode", "testMode", "TCode", "xTest", "tTest", "tcase", " tMode"], "A": ["AA", "Z", "P", "O", "Ma", "Na", "An", "R", "S", "Alpha", "API", "T", "AR", "GA", "As", "AAA", "AI", "L", "MA", "AC", "mA", "F", "X", "SA", "I", "K", "This", "AP", "E", "IA", "D", "G", "M", "AF", "PA", "At", "LA", "U", "Y", "CA", "a", "Ca", "Ac", "Am", "C", "H", "V", "OA", "Wa", "W", "N", "Ab", "EA", "NA", "Ar", "AU", "HA"], "B": ["P", "O", "NB", "R", "LB", "S", "BER", "DB", "T", "AR", "BE", "BF", "IB", "J", "L", "BB", "BC", "F", "X", "I", "K", "E", "BI", "D", "M", "G", "QB", "Two", " b", "U", "Be", "Y", "C", "V", "H", "b", "WB", "Q", "W", "N", "Ab", "OB", "Both", "Bs", "Other", "BM"], "AList": ["Alists", "AListed", "Alisted", "AlIST", "ULIST", "ULists", "ULelist", "ASisted", "ALLelist", "ALelist", "ALList", "ALLIST", "ASist", "ALLists", "Palelist", "ASIST", "ALists", "PalIST", "ASists", "UList", "ALIST", "Palists", "UListed", "Palist"], "BList": [" BData", "RList", "LLine", "LStr", "BLine", "VCount", "Llist", "ACount", "bCode", " BString", " BCount", " BSt", "YData", "YString", "YList", " BStr", "BStr", "LData", "BSt", "DArray", "NQueue", "NCount", "BData", "OLine", "OStr", "LCode", "LContent", " BArray", "OList", "OBList", "LArray", " BContent", "BCount", "OBCode", "DInfo", " BInfo", "bList", "OBlist", "YInfo", "DData", " Blist", "Vlist", "BInfo", "NSt", " BLine", "bBase", " BQueue", "BCode", "BContent", "DCode", "BBase", "DList", "BString", "OContent", "VList", "Blist", "RQueue", "BArray", " BCode", "blist", "BQueue", "OBBase", "LList", "RSt", " BBase", "RCount", "DString"], "resp": ["ref", "err", "p", "_", "response", "all", "res", "comp", "Response", "REP", "col", "na", "seq", "rest", "report", "null", "esp", "true", "Rec", "count", "arr", "req", "RES", "respond", "cond", "rec", "ret", "prev", "Rep", "rel", "rh", "cmp", "nt", "part", "Ret", "r", "conn", "Resp", "respons", "par", "CONT", "pos", "compl", "content", "result", "coll", "rep"], "Alist": ["Aist", "Alists", "Blists", "AlList", "Allists", " ALIST", "Alisted", "AListed", "Blist", "BlIST", "AlIST", "ALList", " AListed", "Aisted", "Alllist", "ALists", "Allist", "ALlist", "Bllist", "AIST", "ALIST", "AllIST", " ALList"], "cont": ["CC", "desc", "acc", "comp", "ci", "cc", "feat", "requ", "lc", "path", "current", "catch", "rest", "nc", "entry", "ext", "text", " Cont", "lat", "xt", "ont", "count", "c", "keep", "req", "dist", "code", "att", "sect", "inc", "Cont", " CONT", "nt", "ctr", "conn", "contin", "cm", "mult", "toc", "contract", "CONT", "diff", "compl", "complete", "const", "content", "nat", "common", "progress", "inf", "int", "ct", "dest", "cur", "ignore"], "aa": ["AA", "ari", "acc", "ma", "Na", "la", "cc", "aaa", "qa", "dc", "ia", "doc", "na", "oc", "ae", "sa", "null", "au", "account", "ai", "ea", "aska", "xa", "alpha", "ah", "arr", "c", "asha", "uc", "aaaa", "va", "ha", "adr", "ba", "inc", "abc", "aea", "ga", "aw", "ee", "bb", "a", "par", "ana", "ca", "df", "da", "ac", "af"], "i": ["p", "id", "ci", "ix", "ei", "text", "ind", "y", "gi", "I", "ii", "c", "ti", "opt", "code", "ait", "ie", "num", "xi", "z", "j", "instance", "iw", " iP", "io", "gu"], "x": ["ix", "ax", "sw", "index", "event", "plex", "any", "h", "ex", "y", "en", "code", "rax", "xi", "z", "w", "xy", "v", "plus", "u", "xxxx", "on", "sex", "xml", "cross", "cgi", "vent", "full", "m", "python", "fx", "es", "ux", "c", "php", "ady", "mx", "abc", "xc", "rx", "xp", "ctx", "ty", "n", "int", "ct", "exp", "p", "ci", "na", "d", "X", "f", "wx", "e", "t", "xes", "num", "px", "expl", "xs", "a", "work", "xx", "word", "dx", "ww", "q", "ext", "lex", "xt", "l", "get", "www", "g", "b", "tx"], "NList": ["NLi", "YZ", "BInt", "VCont", "NColl", "ZLIST", "YColl", "NLIST", "ZZ", "JData", " NSet", " NInt", "ZList", " Nlist", " NLIST", "CNList", " NZ", " NColl", "NLoop", " NPercent", "YLIST", "VList", "Blist", "IList", "ELoop", "Nlist", "JList", "ICont", "EData", "BLi", "NInt", "NCont", "IChain", "VChain", "VPercent", "EList", "CNlist", "JLoop", "NPercent", "NChain", " NChain", " NCont", "NData", "CNLi", "YList", " NLoop", "ESet", "ZColl", "JSet", " NLi", "NSet", "NZ", " NData", "IPercent", "CNInt"]}}
{"code": " \\n  def debug(v):\\n      pass#print(v)\\n  \\n  def read(f):\\n      t = tuple(int(v) for v in f.readline().split())\\n      debug(t)\\n      return t\\n  \\n  def readf(f):\\n      t = tuple(float(v) for v in f.readline().split())\\n      debug(t)\\n      return t\\n  \\n  def answer(f, X, ans):\\n      out = \"Case #{}:\\n{}\".format(X, ans)\\n      f.write(out)\\n      f.write(\"\\n\")\\n      print(out)\\n  \\n  def answer_cells(f, X, cells):\\n      out = \"Case #{}:\".format(X)\\n      f.write(out)\\n      f.write(\"\\n\")\\n      print(out)\\n      for row in cells:\\n          out = \"\".join(row)\\n          f.write(out)\\n          f.write(\"\\n\")\\n          print(out)\\n  \\n  def main(inf, outf):\\n      T, = read(inf)\\n      for casenmbr in range(1, T + 1):\\n          R, C, M = read(inf)\\n  \\n          if M == 0:\\n              cells = [['.'] * C for i in range(R)]\\n              cells[0][0] = 'c'\\n              answer_cells(outf, casenmbr, cells)\\n              continue\\n  \\n          empty = R * C - M\\n  \\n          if empty == 1:\\n              cells = [['*'] * C for i in range(R)]\\n              cells[0][0] = 'c'\\n              answer_cells(outf, casenmbr, cells)\\n              continue\\n  \\n          if R == 1 or C == 1:\\n              cells = [['.'] * C for i in range(R)]\\n              m = 0\\n              for r in range(R):\\n                  for c in range(C):\\n                      cells[r][c] = '*'\\n                      m += 1\\n                      if m == M:\\n                          break\\n                  else:\\n                      continue\\n                  break\\n              cells[-1][-1] = 'c'\\n              answer_cells(outf, casenmbr, cells)\\n              continue\\n  \\n          if empty in (2, 3, 5, 7):\\n              answer(outf, casenmbr, \"Impossible\")\\n              continue\\n  \\n          if (R == 2 or C == 2) and empty % 2:\\n              answer(outf, casenmbr, \"Impossible\")\\n              continue\\n  \\n          cells = [['*'] * C for i in range(R)]\\n  \\n  \\n          cells[0][0] = 'c'\\n          empty -= 1\\n          cc = 1\\n          rr = 1\\n          while empty > 0:\\n              if cc < C:\\n                  for r in range(rr):\\n                      if empty == 2 and r == rr - 1:\\n                          break\\n                      cells[r][cc] = '.'\\n                      empty -= 1\\n                      if empty == 0:\\n                          break\\n                  cc += 1\\n              if rr < R and empty > 0:\\n                  for c in range(cc):\\n                      if empty == 2 and c == cc - 1:\\n                          break\\n                      cells[rr][c] = '.'\\n                      empty -= 1\\n                      if empty == 0:\\n                          break\\n                  rr += 1            \\n  \\n          answer_cells(outf, casenmbr, cells)\\n  \\n  \\n  if __name__==\"__main__\":\\n      infname = sys.argv[1]\\n      outfname = os.path.splitext(infname)[0] + \".out\"\\n      with open(infname, \"r\") as inf:\\n          with open(outfname, \"w\") as outf:\\n              main(inf, outf)\\n", "substitutes": {"v": ["p", "o", "conv", "vp", "val", "vals", "vs", "version", "m", "h", "f", "c", "data", "lv", "uv", "env", "value", "vd", "w", "g", "j", "V", "vv", "model", "u", "kernel", "sv", "n"]}}
{"code": " \\n  def debug(v):\\n      pass #print(v)\\n  \\n  def read(f):\\n      t = tuple(int(v) for v in f.readline().split())\\n      debug(t)\\n      return t\\n  \\n  def answer(f, X, ans):\\n      out = \"Case #{}: {}\".format(X, ans)\\n      f.write(out)\\n      f.write(\"\\n\")\\n      print(out)\\n  \\n  \\n  \\n  def main(inf, outf):\\n      T, = read(inf)\\n      for X in range(1, T + 1):\\n          row1, = read(inf)\\n          cards1 = tuple(read(inf) for i in range(4))\\n          row2, = read(inf)\\n          cards2 = tuple(read(inf) for i in range(4))\\n  \\n          kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\\n  \\n          if kouho:\\n              if len(kouho) == 1:\\n                  ans = kouho.pop()\\n              else:\\n                  ans = \"Bad magician!\"\\n          else:\\n              ans = \"Volunteer cheated!\"\\n  \\n          answer(outf, X, ans)\\n  \\n  \\n  if __name__==\"__main__\":\\n      infname = sys.argv[1]\\n      outfname = os.path.splitext(infname)[0] + \".out\"\\n      with open(infname, \"r\") as inf:\\n          with open(outfname, \"w\") as outf:\\n              main(inf, outf)\\n", "substitutes": {"v": ["p", "o", "conv", "vp", "val", "vals", "vs", "version", "m", "h", "f", "c", "data", "lv", "uv", "env", "value", "vd", "w", "g", "j", "V", "vv", "model", "u", "kernel", "sv", "n"]}}
{"code": " \\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      t = int(f.readline())\\n      for _t in range(t):\\n  \\n          R, C, M = [int(x) for x in f.readline().split()]\\n          free_spots = R * C - M - 1\\n  \\n          if M == 0:\\n              answer = [[\".\" for x in range(C)] for y in range(R)]\\n              answer[0][0] = \"c\"\\n          elif R == 1:\\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\\n          elif C == 1:\\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\\n              answer = zip(*answer[::-1])\\n          elif free_spots >= 3: # and M % R >= 2:\\n              answer = [[\"*\" for x in range(C)] for y in range(R)]\\n              answer[0][0] = \"c\"\\n              answer[0][1] = \".\"\\n              answer[1][1] = \".\"\\n              answer[1][0] = \".\"\\n              free_spots -= 3\\n              tr, br, c = 0, 1, 2\\n              if c >= C:\\n                  tr, br, c = 2, 3, 0\\n              for _i in range(free_spots):\\n                  if answer[tr][c] == \"*\":\\n                      answer[tr][c] = \".\"\\n                  elif answer[br][c] == \"*\":\\n                      answer[br][c] = \".\"\\n                      if c < C-1:\\n                          c+=1\\n                      else:\\n                          tr, br = tr + 2, br + 2\\n                          c = 0\\n                          if br == R:\\n                              br, tr = br-1, tr-1\\n                  \\n          else:\\n              answer = [\"Impossible\",]\\n  \\n          \\n          \\n          print (\"Case #\" + str(_t+1) + \":\")\\n          for _i in answer:\\n              print \"\".join(_i)\\n      \\n  \\n", "substitutes": {"f": ["p", "o", "fp", "cf", "path", "fed", "file", "stream", "d", "h", "F", "l", "fo", "c", "fr", "fd", "e", "fb", "form", "i", "fc", "tf", "handler", "z", "r", "bf", "fe", "fs", "w", "g", "j", "v", "b", "u", "sf", "feed", "n", "fen", "df", "ff", "af"], "fn": ["format", "p", "o", "fin", "fp", "kn", "sn", "unc", "full", "txt", "feat", "cf", "path", "nc", "len", "fm", "file", "name", "func", "function", "ll", "syn", "F", "l", "c", "fd", "fb", "ln", "fl", "num", "fc", "output", "fat", "tf", "r", "nt", "bf", "FN", "fs", "fun", "bn", "method", "sf", "wl", "n", "fil", "dn", "source", "filename"], "t": ["p", "o", "offset", "start", "wt", "tp", "dt", "T", "ts", "d", "h", "l", "tz", "c", "ti", "e", "temp", "tt", "i", "ta", "tf", "z", "tmp", "nt", "type", "r", "w", "b", "v", "tm", "n", "int", "qt"], "_t": ["_T", "_m", " _T", " _p", " _m", "_p"], "R": ["P", "A", "CR", "S", "B", "Ra", "MR", "RA", "T", "L", "RR", "F", "X", "K", "RP", "c", "RW", "Rs", "E", "RH", "RO", "G", "D", "r", "Rh", "U", "Y", "RS", "V", "H", "RT", "RG", "Q", "W", "N", "SR", "RC", "RM"], "C": ["CC", "Z", "P", "O", "A", "CR", "Cr", "SC", "S", "B", "CI", "YC", "T", "DC", "L", "CL", "CM", "AC", "X", "F", "K", "c", "GC", "CU", "E", "VC", "D", "G", "r", "MC", "U", "Y", "CA", "Cl", "V", "H", "Cu", "Q", "W", "N", "RC", "CV"], "M": ["Mo", "Z", "P", "O", "LM", "A", "MF", "S", "MN", "AM", "B", "MO", "MR", "T", "J", "L", "MA", "CM", "F", "X", "I", "DM", "E", "MM", "MU", "G", "D", "MS", "MC", "r", "U", "Y", "V", "H", "MT", "Q", "W", "N", "MX", "RM", "Mi"], "x": ["p", "_", "dx", "ax", "xf", "index", " tx", " cx", "yx", "q", "d", "text", "h", "ex", "X", "l", "wx", "ux", "xt", "c", "opt", "ym", "e", "mx", "num", "i", "xi", "k", "z", "input", "r", "xs", "xc", " X", "rx", "w", "j", "xy", "b", "v", "xp", "u", "xx", "n", "xb", "test", "int", "tx"], "free_spots": ["free_tockets", "free_SpOTS", "free_spaceOTS", "free_spockets", "free_spaceots", "free_splots", "free_SPots", "free_spaceot", "free_splOTS", "free_pot", "free_Spies", "free_mots", "free_spOTS", "free_spaceonents", "free_Spot", "free_tots", "free_SPonents", "free_mot", "free_pies", "free_Spots", "free_splot", "free_Spokes", "free_mokes", "free_pots", "free_mOTS", "free_splowers", "free_Spowers", "free_Spockets", "free_pokes", "free_ties", "free_sponents", "free_ponents", "free_tot", "free_powers", "free_spokes", "free_spies", "free_spot", "free_SPOTS", "free_pockets", "free_SPot", "free_spowers", "free_pOTS"], "answer": ["replace", "Answer", "side", "response", "array", "audio", "comment", "swers", "address", "average", "evidence", "score", "expression", "document", "offer", "entry", "ae", "order", "python", "cover", "grade", "en", "answered", "energy", "search", "message", "equ", "update", "data", "question", "e", "respond", "ell", "after", "archive", "do", "knowledge", "output", "description", "issue", "round", "z", "r", "ee", "cash", "size", "support", "field", "v", "number", "complete", "string", "reply", "page", "result", "section", "word", "results", " answers", "option"], "y": ["p", "o", "ma", "py", "q", "ye", "ay", "d", "ya", "h", "am", "yo", "ym", "yd", "z", "k", "cm", "Y", "yl", "w", "j", "im", "b", "my", "om", "yu", "yr", "cy"], "m": ["mod", "p", "o", "pm", "mn", "ma", "mu", "mm", "man", "am", "ml", "l", "c", "ym", "e", "i", "z", "em", "r", "cm", "w", "g", "mi", "b", "v", "ms", "u", "n", "an", "mp", "mc"]}}
{"code": " \\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      t = int(f.readline())\\n      for _t in range(t):\\n          X = int(f.readline())\\n          cardsX = [[int(y) for y in f.readline().split()] for x in range(4)]\\n          row = cardsX[X-1]\\n          Y = int(f.readline())\\n          cardsY = [[int(y) for y in f.readline().split()] for x in range(4)]\\n          column = cardsY[Y-1]\\n          card = [x for x in row if x in column]\\n          if len(card) > 1:\\n              answer = \"Bad magician!\"\\n          elif len(card) == 0:\\n              answer = \"Volunteer cheated!\"\\n          else:\\n              answer = str(card[0])\\n          print (\"Case #\" + str(_t+1) + \": \" + answer)\\n      \\n  \\n", "substitutes": {"f": ["p", "o", "fp", "lf", "fast", "cf", "of", "file", "m", "stream", "d", "fx", "rf", "h", "F", "l", "fo", "fr", "c", "fd", "fa", "e", "fb", "fer", "fl", "form", "i", "fw", "fc", "info", "tf", "z", "buff", "r", "bf", "fe", "conf", "fs", "w", "g", "v", "b", "line", "u", "sf", "feed", "fen", "inf", "n", "io", "df", "folder", "af"], "fn": ["format", "p", "o", "fp", "lf", "kn", "sn", "unc", "full", "txt", "feat", "path", "len", "fm", "name", "file", "filename", "func", "function", "nm", "ll", "syn", "fa", "c", "fd", "fb", "lib", "ln", "wn", "fl", "utf", "fw", "fc", "output", "bf", "fi", "FN", "fs", "fun", "loc", "wl", "sf", "n", "fen", "fil", "dn", "source", "method"], "t": ["p", "it", "start", " T", "col", "index", "dt", "T", "m", "ts", "time", "d", "h", "out", "l", "c", "e", "temp", "tt", "i", "tw", "z", "type", "w", "length", "s", "b", "v", "pt", "n", "test", "int", "total"], "_t": [" _y", "ifn", "_y", "iff", "ify", "_v", " _f", "ift", "_f", "_trial", " _n", "_n"], "X": ["Z", "TT", "O", "P", "Col", "R", "ID", "FF", "T", "time", "DC", "L", "F", "K", "Column", "E", "XL", "TX", "IP", "D", "XX", "XXX", "U", "V", "H", "length", "Row", "C", "Width", "Q", "XY", "W", "N", "Time"], "cardsX": ["ballsC", " cardsC", "linesX", "linesx", "cardXL", "linesY", " cardsF", "ballsXL", " cardsXL", " cardsx", "cardsF", "ballsX", "cardC", "cardx", "linesF", "cardF", "cardsXL", "cardsC", "cardY", "cardsx", "cardX"], "y": ["p", "o", "py", "sy", "col", "wy", "q", "ye", "ot", "ay", "d", "ny", "ya", "yo", "dy", "vy", "h", "kit", "yt", "c", "ym", "e", "yi", "i", "ky", "yd", "z", "k", "type", "gy", "w", "yl", "j", "ey", "isy", "yn", "s", "v", "b", "ys", "u", "sys", "oy", "n", "int", "yy", "yu"], "x": ["p", "_", "ww", "id", "ci", "ix", "ax", "col", "xa", "xf", "index", "yx", "ice", "m", "time", "ay", "d", "ct", "ox", "h", "ex", "cross", "l", "max", "wx", "xt", "c", "day", "ady", "code", "key", "num", "el", "i", "oint", "px", "xi", "xe", "z", "xc", "rx", "w", "yl", "im", "co", "ross", "v", "xp", "u", "on", "sex", "xx", "n", "xb", "int", "word", "tx"], "row": ["rown", "offset", "array", "ow", "group", "col", "month", "range", "index", "entry", "view", "order", "ro", "record", "grid", "ack", "ward", "key", "ug", "rows", "year", "rot", "roll", "cell", "type", "arrow", "window", "Row", "xy", "flow", "line", "model", "rid", "block", "page", "feed", "ride", "section", "patch", "slice"], "Y": ["Z", "P", "A", "Col", "S", "col", "B", "Type", "ID", "T", "Year", "J", "L", "vy", "F", "Column", "E", "YY", "IP", "year", "G", "D", "U", "V", "C", "H", "Row", "Size", "Q", "XY", "W", "N", "oy", "Day", "Value", "cy"], "cardsY": ["cardsN", "cardy", "ardsX", "featuresX", "featuresF", "cardPy", " cardsPy", "ardsPy", " cardsN", "cardsF", "cardN", "ardsY", "cardF", "fieldsX", "cardsy", "cardsPy", "fieldsF", "featuresy", "fieldsY", "cardY", "fieldsy", "featuresY", "ardsN", "cardX"], "column": ["offset", "collection", "unit", "group", "col", "category", "index", "entry", "width", "channel", "header", "ct", "span", "character", "position", "grid", "Column", "key", "condition", "year", "axis", "cell", "sequence", "arrow", "value", "cycle", "left", "COL", "field", "line", "number", "pattern", "block", "page", "letter", "section", "int", "word", "slice"], "card": ["parse", "array", "node", "comment", "case", "id", "contact", "cards", "list", "request", "valid", "cf", "dc", "event", "center", "entry", "view", "text", "arc", "car", "cont", "message", "character", "c", "day", "data", "question", "code", "condition", "ck", "draw", "ce", "shape", "post", "cell", "cmp", "cart", "note", "check", "match", "cm", "cube", "carry", "field", "line", "compl", "Card", "ard", "fix", "content", "char", "string", "crit", "bug", "letter", "word", "folder"], "answer": ["err", "Answer", "format", "response", "array", "agree", "say", "comment", "address", "average", "evidence", "offer", "vale", "su", "ae", "aim", "name", "account", "example", "cover", "pole", "next", "answered", "blank", "message", "equ", "default", "area", "update", "question", "eni", "respond", "reason", "ell", "avoid", "archive", "knowledge", "ze", "output", "description", "issue", "episode", "value", "username", "field", "fix", "string", "reply", "result", "error", "test", "word", " answers", " Answer", "option"]}}
{"code": " \\n  '''\\n  Input\\n  The first line of the input gives the number of test cases, T. T lines follow. \\n  Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).\\n  \\n  Output\\n  For each test case, output a line containing \"Case #x:\", where x is the test case number. \\n  On the following R lines, output the board configuration with C characters per line, \\n  using '.' to represent an empty cell, '*' to represent a cell that contains a mine, \\n  and 'c' to represent the clicked cell. If there is no possible configuration, \\n  then instead of the grid, output a line with \"Impossible\" instead. \\n  If there are multiple possible configurations, output any one of them.\\n  \\n  Limits\\n  0 <= M < R * C.\\n  \\n  Small dataset\\n  1 <= T <= 230.\\n  1 <= R, C <= 5.\\n  \\n  Large dataset\\n  1 <= T <= 140.\\n  1 <= R, C <= 50.\\n  \\n  Sample\\n  ---Input \\n  5\\n  5 5 23\\n  3 1 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  \\n  ---Output \\n  Case #1:\\n  Impossible\\n  Case #2:\\n  c\\n  .\\n  *\\n  Case #3:\\n  Impossible\\n  Case #4:\\n  ......*\\n  .c....*\\n  .......\\n  ..*....\\n  Case #5:\\n  **********\\n  **********\\n  **********\\n  ****....**\\n  ***.....**\\n  ***.c...**\\n  ***....***\\n  **********\\n  **********\\n  **********\\n  \\n  \\n  '''\\n  \\n  \\n  f = open(sys.argv[1])\\n  def input(): return f.readline().strip();\\n  \\n  def genBoards(R, C, M):\\n      for mines in combinations( product(range(R), range(C)), M):\\n          board = [ ['.'] * C + [''] for _ in range(R) ]\\n          for row, col in mines:\\n              board[row][col] = '*'\\n          yield board + [[''] * (C+1)]\\n      pass\\n  \\n  def oneClickSolution(R, C, M):\\n      for bd in genBoards(R, C, M):\\n          minTile = 10\\n          for r in range(R):\\n              for c in range(C):\\n                  if bd[r][c] == '.':\\n                      n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))\\n                      bd[r][c] = `n`\\n                      if n <= minTile:\\n                          minTile = n\\n                          minR, minC = r, c\\n          if minTile < 10:\\n              queue = [ (minR, minC) ]\\n              nOpen = 0\\n              while queue:\\n                  r,c = queue.pop()\\n                  if bd[r][c] == '0':\\n                      for i in -1,0,1:\\n                          for j in -1,0,1:\\n                              if i or j: # we don't add the one we popped back\\n                                  queue.append( (r+i, c+j) )\\n                  if bd[r][c] not in '.*':\\n                      bd[r][c] = '.'\\n                      nOpen += 1\\n              if M + nOpen == R*C:\\n                  bd[minR][minC] = 'c'\\n                  return '\\n'.join( ''.join(row[:-1]) for row in bd[:-1] )\\n  \\n      return 'Impossible'\\n  \\n  \\n  clk = clock()\\n  \\n  for caseNo in xrange(1, int(input())+1):\\n      R, C, M = map(int, input().split())\\n      print >>sys.stderr, caseNo, R, C, M #, oneClickSolution(R, C, M)<>'Impossible'\\n      print 'Case #%d:' % caseNo  \\n      print oneClickSolution(R, C, M)\\n      \\n  print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\\n  \\n", "substitutes": {"f": ["p", "fp", "lf", "ef", "file", "q", "m", "d", "x", "h", "F", "l", "fo", "fn", "found", "fa", "fd", "e", "fb", "t", "form", "tf", "handler", "bf", "fs", "w", "s", "v", "b", "feed", "io", "df", "raf", "af"], "R": ["P", "O", "A", "CR", "Cr", "S", "B", "MR", "RA", "T", "L", "RR", "Run", "F", "X", "Ro", "K", "I", "BR", "RW", "Rs", "E", "NR", "RH", "Right", "DR", "RO", "D", "G", "Rh", "U", "Y", "GR", "RS", "V", "H", "Row", "RG", "Q", "W", "N", "SR", "RF", "Re", "RM", "Br", "Range"], "C": ["CC", "P", "O", "A", "CR", "S", "B", "Cs", "CI", "YC", "T", "DC", "L", "CL", "Code", "CM", "F", "X", "I", "K", "Column", "Ch", "CU", "E", "CNN", "VC", "G", "D", "MC", "cycle", "U", "Count", "Y", "CA", "Cl", "V", "H", "Cu", "Size", "Q", "W", "N"], "M": ["P", "O", "LM", "multiple", "S", "MN", "MF", "B", "AM", "MR", "Ms", "T", "m", "VM", "L", "CM", "TM", "F", "X", "I", "DM", "IM", "E", "MM", "Mode", "D", "G", "MI", "MS", "MC", "OM", "U", "Y", "V", "H", "MB", "Q", "NM", "W", "N", "RM", "FM"], "mines": ["innations", "innes", "tunes", "aminions", "aminations", "meles", "Minus", "mined", "Mine", "amines", "tune", " mine", "mineds", "tuneds", "minus", "minations", " minus", "meled", "minions", "Mines", "mine", "tunus", "melions", "innions", "melations", " mineds", "amined", "Mineds", "inned"], "board": ["box", "p", "o", "stroke", "array", "list", "deck", "layout", "boarding", "ode", "entry", "channel", "ro", "d", "x", "card", "boards", "core", "flo", "room", "bo", "table", "code", "ward", "back", "form", "hole", "control", "cell", "sequence", "Board", "cart", "bar", "buffer", "object", "b", "flow", "line", "panel", "block", "feed", "word"], "_": [" x", "p", "all", "x", "__", "self", "k", "g", " p"], "row": ["box", "stroke", "id", "ow", "uu", "tr", "group", "rank", "range", "rc", "entry", "q", "channel", "order", "ro", "x", "ox", "port", "uc", "ack", "ward", "key", "rows", "cell", "co", "w", "Row", "flow", "line", "server", "block", "page", "bug", "feed", "cur", "coll"], "col": ["p", "box", "Col", "mot", "ch", "x", "ox", "ind", "y", "core", "flo", "day", "chain", "key", "fl", "num", "win", "el", "fc", "rot", "round", "k", "cell", "cat", "con", "cm", "column", "co", "cl", "COL", "ol", "th", "min", "line", "loc", "act", "sel", "ct", "coll", "ac"], "bd": ["td", "sd", "online", "deck", "dc", "ld", "db", "gb", "sb", "nb", "hd", "d", "bj", "ml", "ob", "hide", "fd", "fb", "bm", "zb", "BD", "dm", "ba", "sh", "fl", "do", "md", "ng", "bs", "yd", "deb", "cdn", "pd", "ud", "od", "odo", "bb", "bf", "vd", "gd", "ad", "df", "cb", "abb", "wb", "cd", "bc", "nd", "bt", "b", "kk", "dd", "de", "bl", "dan", "bow", "ande", "bot", "ff", "ds", "ke"], "minTile": ["maxtile", "minFit", "smallPixel", "smallImage", "MinTex", " minTex", "maxFit", " minImage", "MinImage", "initialTile", " mintile", "ntile", "nTile", "maxTile", " minFit", "initialImage", "smallTile", "MinFit", " minTable", "nImage", "maxImage", "minImage", "minTex", "MinTile", "MinPixel", "initialTex", " minPixel", "minTable", "mintile", "smallTable", "MinTable", "minPixel", "Mintile"], "r": ["p", "o", "br", "rb", "dr", "range", "run", "rc", "q", "ar", "m", "ro", "d", "kr", "x", "rf", "h", "l", "ru", "cr", "rl", "rd", "nr", "right", "fr", "e", "ir", "t", "Rs", "ur", "rr", "self", "k", "rt", "rg", "rn", "a", "w", "g", "re", "b", "v", "sr", "s", "hr", "u", "pr", "attr", "lr", "rs", "er", "vr", "result"], "c": ["cu", "p", "o", "ci", "cc", "cf", "lc", "dc", "nc", "rc", "center", "sc", "q", "com", "m", "channel", "cn", "d", "x", "h", "max", "l", "y", "cr", "cp", "count", "uc", "vc", "e", "t", "code", "chain", "cache", "ce", "ec", "k", "cell", "z", "can", "cycle", "cm", "xc", "w", "course", "s", "b", "v", "u", "cs", "ct", "coll", "pc", "ac", "cy"], "n": ["p", "o", "nu", "sn", "nc", "len", "cn", "m", "ns", "pn", "nb", "d", "nn", "np", "x", "un", "nan", "l", "fn", "y", "nr", "e", "t", "no", "num", "z", "nt", "network", "ni", "rn", "w", "g", "yn", "sum", "b", "s", "v", "number", "u", "N", "ne", "an", "net", "dn"], "i": ["p", "it", "o", "chi", "li", "ui", "ci", "ia", "ei", "iii", "oi", "q", "m", "ini", "ji", "d", "ai", "phi", "bi", "h", "y", "l", "I", "gi", "ri", "ii", "ti", "e", "yi", "ie", "ik", "pi", "xi", "di", "z", "ni", "fi", "a", "g", "ij", "ib", "im", "b", "v", "iy", "u", "iw", "qi", "si", "io", "int", "ih", "iu"], "j": ["p", "o", "jump", "br", "ch", "js", "jit", "jc", "jan", "q", "jp", "ji", "d", "J", "x", "kj", "bj", "h", "oj", "y", "l", "ii", "adj", "e", "jl", "aj", "job", "obj", "k", "z", "cell", "jj", "je", "ja", "note", "ij", "im", "vision", "b", "v", "u", "jam", "uj"], "minR": ["diffF", "MinC", " minF", "MinCR", " minr", "miniR", "minF", "miniC", "Minr", "diffC", "diffr", "MinR", " minCR", "miniCR", "diffR", "minir", "MinF", "minCR", "minr"], "minC": ["minN", " minE", "rainL", "MinC", " minN", " minF", "minF", "partialc", "smallF", "MinN", "rainE", "partialL", "smallC", "minL", " minc", "minc", "smallN", "Minc", "partialC", "partialE", "rainc", "MinF", "rainC", " minL", "minE", "smallc"], "queue": ["p", "Que", "pool", "force", "id", "list", "group", "process", "config", "db", "event", "file", "q", "channel", "loop", "console", "delay", "que", "parent", "menu", "en", "stack", "count", "grid", "update", "e", "Queue", "batch", "cache", "status", "job", "ue", "route", "sequence", "buffer", "server", "line", "sync", "use", "Q", "block", "page", "progress", "worker"], "nOpen": ["cQueue", "cOpen", "NOpen", "copen", " nDraw", " nopen", " nQueue", "cDraw", "nopen", "NDraw", "nDraw", "Nopen", "nQueue", "NQueue"]}}
{"code": " \\n  '''\\n  ---Input \\n  3\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  3\\n  1 2 5 4\\n  3 11 6 15\\n  9 10 7 12\\n  13 14 8 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  3\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  \\n  ---Output \\n  Case #1: 7\\n  Case #2: Bad magician!\\n  Case #3: Volunteer cheated!\\n  '''\\n  \\n  \\n  \\n  \\n  \\n  f = open(sys.argv[1])\\n  def input(): return f.readline().strip();\\n  \\n         \\n  \\n  \\n  for caseNo in xrange(1, int(input())+1):\\n      row_no = int(input())\\n      for i in 1,2,3,4:\\n          row = input()\\n          if i == row_no:\\n              nums = set(row.split())\\n              \\n      row_no = int(input())\\n      for i in 1,2,3,4:\\n          row = input()\\n          if i == row_no:\\n              nums &= set(row.split())\\n  \\n      if not nums:\\n          res = 'Volunteer cheated!'\\n      elif len(nums) > 1:\\n          res = 'Bad magician!'        \\n      else:\\n          res = nums.pop()\\n      print 'Case #%d:' % caseNo, res\\n      \\n  \\n", "substitutes": {"f": ["ref", "p", "fp", "lf", "ef", "file", "m", "d", "x", "rf", "h", "F", "l", "fo", "c", "fa", "fd", "e", "fb", "t", "info", "tf", "handler", "r", "bf", "fs", "a", "w", "g", "s", "b", "v", "feed", "io", "df", "raf", "af"], "caseNo": ["ceno", " caseNum", "caseNO", "nameNo", "aseName", " caseno", "nameno", "Caseno", "aseNo", "nameName", "caseName", "ceNum", "CaseNum", "caseNum", "CaseNo", "CaseNO", "aseno", "nameNum", "aseNum", " caseName", " caseNO", "ceNo", "caseno", "ceNO"], "row_no": ["rowJnum", "cell_count", "row_id", "row_key", "rowjyes", "rowjno", "row_nos", "row_eno", "rowJnumber", "rows_nos", "rowJno", "rowxcount", " row_No", "rowxkey", " row_eno", "rows_number", "cell_no", "rowxid", "rowxno", "rowJeno", "rowjnumber", "row_count", "rows_no", "row_number", "row_No", "rows_num", "row_num", "cell_id", "cell_key", "rowjnos", "rows_yes", "row_yes", " row_yes", "rows_eno"], "i": ["il", "p", "it", "o", "iq", "ui", "li", "id", "ci", "ix", "col", "ia", "ei", "ori", "m", "ini", "d", "ai", "multi", "x", "bi", "ind", "l", "y", "I", "ii", "c", "ti", "e", "yi", "ie", "uri", "pi", "info", "xi", "r", "ic", "ni", "a", "j", "v", "ip", "u", "iw", "qi", "n", "io", "si", "int", "iu"], "row": ["up", "array", "image", "query", "id", "ow", "uu", "group", "col", "sel", "rank", "month", "range", "rc", "sc", "entry", "view", "we", "order", "ro", "raw", "grid", "uc", "ry", "data", "ack", "ward", "key", "frame", "ows", "rr", "rows", "cell", "input", "r", "ok", "way", "Row", "re", "server", "line", "ip", "reader", "block", "feed", "page", "bug", "result", "df", "error", "where"], "nums": ["Nums", "Names", " names", "numuss", " nuss", "unums", " numer", "Noms", "Numbers", "unuc", "cnubs", "Numer", "nuss", "ynums", "cnummies", "cums", "cuss", "cnumbers", "pubs", " nems", "pums", " nummies", "nummies", "names", "numer", "unumbers", "Num", "numumer", "ynumbers", "num", " numbers", "numums", " noms", " nuc", " num", "nems", "noms", "unuss", "Nems", "cames", "cumbers", "pummies", "cum", "pumbers", "ynoms", "nubs", "numbers", "Nuss", "numumbers", "nuc", "ynems", "cuc", " nubs", "cnums"], "res": ["err", "response", "exp", "col", "resp", "news", "rest", "rc", "our", "details", "gr", "resolution", "msg", "rss", "right", "req", "grid", "RES", "pres", "reset", "rec", "rev", "ret", "rem", "rus", "rr", "rel", "rez", "r", "reg", "re", "ms", "sys", "Res", "rs", "result", "error", "ras", "results", "rep"]}}
{"code": "t = int(input())\\n  \\n  VIDE = 0\\n  MINE = 1\\n  CURSEUR = 2\\n  \\n  def test_position(arr, lignes, cols, y, x):\\n      def voisinage_libre(arr, y, x):\\n          if y > 0:\\n              if x > 0 and arr[y-1][x-1] == MINE:\\n                  return False\\n              if arr[y-1][x] == MINE:\\n                  return False\\n              if x < cols - 1 and arr[y-1][x+1] == MINE:\\n                  return False\\n  \\n          if x > 0 and arr[y][x-1] == MINE:\\n              return False\\n          if x < cols - 1 and arr[y][x+1] == MINE:\\n              return False\\n  \\n          if y < lignes - 1:\\n              if x > 0 and arr[y+1][x-1] == MINE:\\n                  return False\\n              if arr[y+1][x] == MINE:\\n                  return False\\n              if x < cols - 1 and arr[y+1][x+1] == MINE:\\n                  return False\\n  \\n          return True\\n  \\n      def remplissage_rec(arr, y, x):\\n          if x < 0 or y < 0 or x >= cols or y >= lignes:\\n              return\\n          elif arr[y][x] == CURSEUR:\\n              return\\n  \\n          arr[y][x] = CURSEUR\\n          if voisinage_libre(arr, y, x):\\n              remplissage_rec(arr, y-1, x-1)\\n              remplissage_rec(arr, y-1, x)\\n              remplissage_rec(arr, y-1, x+1)\\n              remplissage_rec(arr, y, x-1)\\n              remplissage_rec(arr, y, x+1)\\n              remplissage_rec(arr, y+1, x-1)\\n              remplissage_rec(arr, y+1, x)\\n              remplissage_rec(arr, y+1, x+1)\\n  \\n      if arr[y][x] != VIDE:\\n          return False\\n  \\n      arr2 = [ [ arr[i][j] for j in range(0, cols) ] for i in range(0, lignes) ]\\n  \\n      remplissage_rec(arr2, y, x)\\n  \\n      for i in range(0, lignes):\\n          for j in range(0, cols):\\n              if arr2[i][j] == VIDE:\\n                  return False\\n      return True\\n  \\n  def dfs(arr, lignes, cols, mines, y, x):\\n      cases_restantes = (cols - x) + ((lignes - y) * cols)\\n  \\n      if cases_restantes < mines:\\n          return None\\n      elif mines <= 0:\\n          for i in range(0, lignes):\\n              for j in range(0, cols):\\n                  if test_position(arr, lignes, cols, i, j):\\n                      return (i, j)\\n      elif x >= cols:\\n          return dfs(arr, lignes, cols, mines, y+1, 0)\\n      elif y >= lignes:\\n          return None\\n      else:\\n          res = dfs(arr, lignes, cols, mines, y, x+1)\\n          if res != None:\\n              return res\\n  \\n          arr[y][x] = MINE\\n          res = dfs(arr, lignes, cols, mines-1, y, x+1)\\n          if res != None:\\n              return res\\n  \\n          arr[y][x] = VIDE\\n          return None\\n  \\n  for i in range(0, t):\\n      ligne  = input().split(\" \")\\n      lignes = int(ligne[0])\\n      cols   = int(ligne[1])\\n      mines  = int(ligne[2])\\n  \\n      arr = [ [VIDE] * cols for _ in range(0, lignes) ]\\n  \\n      res = dfs(arr, lignes, cols, mines, 0, 0)\\n  \\n      print (\"Case #\"+str(i+1)+\":\")\\n  \\n      if res == None:\\n          print (\"Impossible\")\\n      else:\\n          (y, x) = res\\n  \\n          for i in range(0, lignes):\\n              for j in range(0, cols):\\n                  if i == y and j == x:\\n                      print('c', end='')\\n                  elif arr[i][j] == VIDE:\\n                      print('.', end='')\\n                  else:\\n                      print('*', end='')\\n  \\n              print('', end='\\n')\\n", "substitutes": {"t": ["p", "it", "o", "bit", "all", " T", "tp", "ts", "T", "m", "ext", "d", "xt", "f", "c", "ti", "table", "num", "ta", "type", "a", "w", "g", "b", "u", "n", "total"], "VIDE": ["VIDe", "VISe", " VIDe", " VIDENCE", "VISE", "VPe", "VIDENCE", "VDF", "VDEA", "VISENCE", "VPEA", "VIDEA", "VENENCE", "VENF", "VDe", "VISEA", "VPE", "VDE", " VIDEA", "VPF", "VENe", "VENEA", "VENE", "VIDF"], "MINE": [" Mined", "Vina", " Mina", "REMME", "Hine", " MME", " Mining", "Mining", "Mina", "Pinite", "FISC", "JINE", "MAine", "FMining", "VME", "MAINE", "Hined", "Nina", "PINE", "mined", "REMINE", "Mine", "REMined", "VINE", "MKE", "HINE", " Minite", "Vined", "Jine", "FINE", "Vine", "FMined", "UNining", "UNined", "Vining", "mISC", "FMKE", "Fine", " Mine", "Fined", "Nining", "FMine", "mine", "Pined", "Pining", "Mined", "Fining", "UNine", "Nine", "REMine", "FKE", " MKE", "NKE", "Nined", "FMINE", "mINE", "JKE", "Pine", "Jining", "Minite", "UNINE", "MME", "HISC", "Hining", "Vinite", "MAined", "MAining", "MISC", "NINE"], "CURSEUR": ["CURSECur", "CURSEUL", "CRCSEARCH", "CURseUR", "CURSIIR", "CURseURR", "CURRseURR", "CURTEur", "CURseur", "CURRseur", "CURSUL", "CURSEIR", "CRCSEUR", "CRCSEur", "CURseIR", "CURRSEIR", "CURSur", "CURRSEURR", "CURSEARCH", "CURRSEVER", "CURSIUR", "CURseARCH", "CRCseUR", "CRCSEUL", "CURSIur", "CURSURR", "CURTEUL", "CURSIARCH", "CURRseUL", "CURseVER", "CURSECIR", "CURSEURR", "CURSARCH", "CURSECVER", "CURSIUL", "CURSEVER", "CRCseUL", "CURSUR", "CURSECUR", "CURseUL", "CURRSEUR", "CURRseVER", "CURRSEUL", "CURTEUR", "CURSIVER", "CURSEur", "CURRseUR", "CRCseur", "CURRseIR", "CURTEURR", "CRCseARCH", "CURRSEur"], "arr": ["array", "div", "list", "tr", "plot", "av", "gr", "order", "arc", "adv", "var", "mk", "arch", "z", "ray", "xml", "test", "aa", "align", "acc", "rb", "az", "app", "au", "ind", "arm", "req", "data", "aj", "abc", "archive", "aug", "dict", "arrow", "abs", "dat", "attr", "bl", "rs", "int", "lat", "rep", "ar", "car", "arb", "fr", "str", "el", "bb", "work", "par", "ab", "war", "hr", "yy", "Ar", "coll", "enc", "yr", "err", "img", "air", "br", "art", "dr", "aaa", "feat", "ay", "ext", "ann", "inst", "ir", "adr", "att", "batch", "cache", "rr", "obj", "r", "cat", "bar", "frac", "arp"], "lignes": [" lucs", "lgnions", "ligninguses", "Lignumes", " lignses", "lignines", "elignings", "eligningions", " luces", "ligningions", "lignings", "lIGNines", "ligninges", "lucues", "lignses", "ligningines", "lignumes", "lignmentuses", "linales", "linals", "lIGNes", "lgnses", "ligns", " ligningines", " ligningues", "lignmentses", "Ligns", "eligns", "lignments", " ligninges", "linalses", "lignues", "lIGNuses", "lIGNs", "Lignuses", "lignmentumes", "lgnes", "lgns", " lignines", "lucs", "luces", "lancues", "lignmentues", "lancses", " lignings", "lignmentes", "lignions", "eligningses", "elignses", "lignmentions", "lIGNumes", "eligninges", "Lignments", "Lignmentes", "linalues", " lucues", "lucses", "Lignmentuses", "lIGNues", "ligningues", "lignuses", "ligningses", "lancs", "elignes", "Lignmentumes", "elignions", "lances", " ligns", "Lignes", " lucses", "lignmentines", "ligningumes", " lignues"], "cols": ["columns", "Cold", "columnes", "Coln", "Cols", " colops", "COLn", "lls", " cold", " collines", "Colns", " coles", "Colals", " colsi", "colops", "columnn", "Colops", " colss", "coles", "Coles", "llses", "colss", "llops", "colless", "columnts", " colabs", "columnlines", "colabs", "coln", "colals", "colts", "columnabs", " coln", "Colabs", "Colss", "colses", "COLes", " colless", "llss", "velsi", "Colses", "colsi", " colses", "COLs", "columnsi", "cold", " colals", " colns", "COLns", "lles", "columnless", "collines", "lld", "vels", "Collines", "colns", "llals", " colts", "velless", "velts"], "y": ["ix", "fy", "ch", "sy", "wy", "any", "asy", "h", "ery", "key", "year", "yd", "uy", "z", "yl", "xy", "u", "isy", "cy", "id", "hy", "idy", "m", "python", "out", "by", "yt", "c", "ym", "ady", "yi", "ie", "gy", "Y", "auto", "yn", "iy", "ty", "n", "arty", "p", "say", "py", "yo", "dy", "f", "e", "ky", "ys", "my", "yes", "sky", "yy", "yr", "o", "yang", "ye", "ay", "ny", "ya", "yan", "base", "vy", "ry", "yah", "type", "bar", "ey", "b", "zy", "sys", "acy", "oy", "yu"], "x": ["image", "ix", "ax", "yx", "index", "event", "name", "any", "time", "h", "ex", "xa", "en", "day", "code", "no", "key", "xi", "shape", "z", "wa", "w", "yl", "xy", "v", "high", "u", "xml", "sex", "page", "cross", "id", "full", "hy", "pe", "xxx", "view", "width", "m", "python", "fx", "by", "alpha", "c", "data", "php", "ady", "xc", "Y", "rx", "gy", "xp", "n", "int", "ct", "p", "bit", "long", "at", "na", "d", "dy", "X", "f", "wx", "host", "e", "xes", "el", "px", "xe", "size", "xs", "a", "work", "im", "my", "content", "yes", "xx", "one", "dx", "xf", "q", "ye", "ay", "ext", "lex", "ya", "xt", "l", "large", "k", "r", "type", "g", "ey", "s", "b", "tx"], "arr2": ["array4", "arr4", "arc0", "str2", "array2", "arr3", " arr0", "arr0", "arr1", " arr3", "array\n", " arr1", "array0", "str4", "arc\n", "str3", " arr4", "array3", "array1", "str1"], "i": ["p", "o", "li", "id", "index", " ii", "jp", "m", "ji", "d", "ai", "h", "l", "I", "f", "ii", "c", "e", "yi", "ie", "xi", "di", "k", "z", "ij", "b", "v", "u", "n", "si", "iu"], "j": ["p", "o", "li", "ci", "ix", "js", "jc", " k", " ii", "q", "jp", "ji", "d", "J", "kj", "h", "oj", "l", "f", "ii", "adj", "c", "e", "jl", "ie", "xi", "k", "z", "jj", "je", "ja", "ij", " jo", "b", "v", "jo", " J", " il", "n", "uj"]}}
{"code": " \\n  \\n  data Test = Test {\\n        choix1 :: Int\\n      , table1 :: [[Int]]\\n      , choix2 :: Int\\n      , table2 :: [[Int]]\\n      } deriving Show\\n  \\n  data Solution = Bonne Int | BadMag | Cheat\\n  \\n  instance Show Solution where\\n      show (Bonne i) = show i\\n      show BadMag    = \"Bad magician!\"\\n      show Cheat     = \"Volunteer cheated!\"\\n  \\n  main = do\\n      interact (unlines . map showCase . zip [1..] . map (resoudre) . goTest . tail . lines)\\n  \\n    where\\n      goTest [] = []\\n      goTest ls =\\n          let (c1, t1, ls')  = goTable ls\\n              (c2, t2, ls'') = goTable ls'\\n          in Test c1 t1 c2 t2 : goTest ls''\\n  \\n      goTable (n:ls) =\\n          let c = read n\\n              (t, ls') = splitAt 4 ls\\n          in (c, map goLigne t, ls')\\n  \\n      goLigne = map read . words\\n  \\n      showCase :: (Int, Solution) -> String\\n      showCase (i, s) = printf \"Case #%d: %s\" i (show s)\\n  \\n  resoudre :: Test -> Solution\\n  resoudre Test {..} =\\n      let choisis1 = table1 !! (choix1 - 1)\\n          choisis2 = table2 !! (choix2 - 1)\\n          communs  = filter (`elem` choisis1) choisis2\\n      in case communs of\\n          [x]     -> Bonne x\\n          (_:_:_) -> BadMag\\n          []      -> Cheat\\n", "substitutes": {"Test": ["File", "Data", "Stage", "_", "Array", "Examples", "Temp", "Report", "Example", "Unit", "It", "Response", "Config", "Script", "Type", "Check", "Class", "Version", "Title", "T", "Search", "Rule", "LT", "Code", "Runner", "Best", "Lie", "If", "Model", "X", "Index", "Step", "Sample", "String", "Ch", "Fit", "Text", " test", "Base", "Path", "All", "Train", "The", "Question", "Exception", "Feature", "Beta", "Info", "Format", "Loop", "Reader", "Fix", "Lib", "Table", "Testing", "Result", "Case", "Try", "Fixed", "Name", "Match", "Part", "Server", "Long", "App", "test", "Course", "Sub", "Success", "Value", "Time", "Solution", "Split"], "data": ["Data", "format", "response", "div", "case", "group", "doc", "channel", "example", "default", "area", "table", "scale", "ata", "series", "no", "complex", "debug", "mode", "media", "info", "output", "graph", "input", "DATA", "dat", "sample", "window", "script", "model", "complete", "action", " Data", "error", "result", "style", "results", "cases"], "show": ["_", "study", "help", "plot", "index", "details", "h", "default", "play", " demonstrate", "display", "do", "debug", "draw", "sub", "output", "self", "episode", "dd", "select", "clear", "style", "test", "make", "where", "stage", "id", "full", "export", "ss", "version", "view", "console", "shown", "ind", "ng", "description", "set", "summary", "nd", "hi", "Sh", "shows", "Show", "result", "how", "long", "spect", "print", "config", "log", "echo", "max", "info", "project", "create", "small", "use", "SH", "error", "desc", "parse", "new", "raw", "get", "hide", "eq", " Show", "series", "sh", "include", " shows", "figure", "see", "model", "block", "change"], "main": ["p", "id", "doc", "plot", "run", "loop", "gui", "src", "example", "m", "Main", "next", "results", "code", "Train", "ng", "output", "obj", "module", "mult", "j", "exit", " Main", "script", "Result", "section", "result", "json"], "goTest": ["goSample", "goCase", " goIt", "GOSample", "coTesting", "goneTest", "coIt", "goIt", "goServer", " goCase", "coSample", "GOIt", "coTest", "GOTest", "coTable", " goTesting", "goneSample", " goServer", "goTesting", "goneTesting", "GOTable", "GoTesting", " goTable", "GoCase", "GoTable", "goTable", "goneTable", "GOServer", "coServer", "GOCase", "GoSample", " goSample", "GoTest"]}}
{"code": "def get_a(r, c, f='.'):\\n      A = []\\n      for i in xrange(r):\\n          A.append([f] * c)\\n      return A\\n  \\n  \\n  def apply(A, r, c, B):\\n      for i, b in enumerate(B):\\n          for j, v in enumerate(b):\\n              A[r + i][c + j] = v\\n  \\n  \\n  def draw(A):\\n      if A is None:\\n          return '\\nImpossible'\\n      res = ['']\\n      for a in A:\\n          res.append(''.join(a))\\n      return '\\n'.join(res)\\n  \\n  \\n  def trans(A):\\n      if not A:\\n          return None\\n      B = get_a(len(A[0]), len(A))\\n      for i, a in enumerate(A):\\n          for j, v in enumerate(a):\\n              B[j][i] = v\\n      return B\\n  \\n  \\n  def check(A, m, r, c):\\n      if A is None:\\n          return True\\n      cnts = {'c': 0, '*': 0, '.': 0}\\n  \\n      assert len(A) == r\\n      for i in xrange(r):\\n          assert len(A[i]) == c\\n          for j in xrange(c):\\n              cnts[A[i][j]] += 1\\n      assert cnts['*'] == m\\n      assert cnts['c'] == 1\\n      assert cnts['.'] == r * c - m - 1\\n  \\n  \\n  def CASE(IN):\\n      def rstr():\\n          return IN.readline().strip()\\n  \\n      def rint():\\n          return int(rstr())\\n  \\n      def rints():\\n          return map(int, rstr().split())\\n      r, c, m = rints()\\n      A = solve(m, r, c)\\n      if A:\\n          A[-1][-1] = 'c'\\n      check(A, m, r, c)\\n      return draw(A)\\n  \\n  \\n  def solve(m, r, c):\\n      if r > c:\\n          return trans(solve(m, c, r))\\n      assert r <= c\\n      assert m != r * c\\n      e = r * c - m\\n      if e == 1:\\n          A = get_a(r, c, '*')\\n          return A\\n      if r == 1:\\n          A = get_a(1, c, '.')\\n          for i in xrange(m):\\n              A[0][i] = '*'\\n          return A\\n      if r == 2:\\n          if e == 2 or e % 2 == 1:\\n              return None\\n          A = get_a(2, c, '.')\\n          assert m % 2 == 0\\n          for i in xrange(m / 2):\\n              A[0][i] = A[1][i] = '*'\\n          return A\\n      assert r >= 3\\n      A = get_a(r, c, '*')\\n      if e in (2, 3, 5, 7):\\n          return None\\n      E = [c] * (e / c) + ([e % c] if e % c else [])\\n      if sum(E) < e:\\n          E.append(e % c)\\n          assert sum(E) == e\\n      if len(E) == 1:\\n          E = [e / 2] * 2\\n          if sum(E) < e:\\n              e.append(1)\\n      if E[0] != E[1]:\\n          s = sum(E[:2])\\n          E[0] = E[1] = s / 2\\n          if sum(E[:2]) != s:\\n              assert len(E) == 2\\n              E.append(1)\\n      if E[-1] == 1:\\n          if len(E) > 3:\\n              E[-2] -= 1\\n              E[-1] += 1\\n          else:\\n              E[0] -= 1\\n              E[1] -= 1\\n              E[2] += 2\\n      for i in xrange(len(E)):\\n          for j in xrange(E[i]):\\n              A[-i - 1][-j - 1] = '.'\\n      return A\\n  \\n  \\n  def RUN(IN, OUT):\\n      t = int(IN.readline().strip())\\n      for i in xrange(1, t + 1):\\n          OUT.write(\"Case #%i: %s\\n\" % (i, CASE(IN)))\\n  \\n  if __name__ == \"__main__\":\\n      RUN(sys.stdin, sys.stdout)\\n", "substitutes": {"r": ["err", "p", "o", "rb", "R", "dr", "ra", "tr", "range", "rc", "q", "ar", "ro", "mr", "d", "x", "h", "l", "ru", "cr", "rl", "rd", "nr", "fr", "ir", "Rs", "end", "ur", "rr", "k", "rh", "z", "rg", "w", "g", "re", "sr", "u", "pr", "rm", "n", "rs", "er", "cur", "yr"], "c": ["p", "o", "cu", "ci", "ch", "cc", "col", "jc", "lc", "dc", "nc", "cf", "rc", "sc", "q", "d", "x", "h", "l", "y", "cr", "count", "cp", "rec", "ce", "fc", "ec", "k", "z", "can", "con", "cm", "xc", "w", "co", "C", "g", "u", "n", "cs", "mc", "pc", "ac", "cy"], "f": ["p", "fp", "ef", "cf", "of", "fm", "q", "d", "fx", "x", "rf", "h", "F", "l", "fa", "fr", "fb", "fl", "form", "fc", "bf", "fe", "fi", "fs", "g", "fun", "field", "u", "fold", "sf", "feed", "df", "ff", "af"], "A": ["Empty", "AA", "_", "Ma", "array", "all", "There", "Alpha", "Gener", "RA", "Instance", "Ap", "mA", "K", "Ha", "This", "General", "Order", "AF", "M", "Parts", "Am", "Wa", "Ab", "Res", "App", "Product", "First", "R", "AM", "Ant", "MA", "ap", "alpha", "New", "Action", "data", "end", "And", "Act", "Adam", "D", "G", "Min", "At", "Y", "C", "H", "AS", "NA", "AU", "HA", "Data", "p", "Array", "An", "S", "Any", "API", "Content", "AR", "ar", "d", "Art", "Code", "AC", "F", "X", "If", "I", "Mult", "All", "The", "AD", "U", "Ca", "OA", "System", "V", "Result", "Q", "W", "Ar", "P", "O", "Az", "Input", "Auth", "T", "GA", "Average", "As", "L", "AP", "AV", "Error", "PA", "Args", "LA", "Ac", "CA", "g", "Ad", "Entry", "N"], "i": ["p", "o", "it", "ui", "li", "id", "ci", "index", "ori", "ini", "d", "ai", "x", "bi", "h", "l", "y", "I", "ri", "gi", "ind", "ii", "ti", "yi", "zi", "ie", "pi", "xi", "di", "k", "z", "ni", "g", "im", "u", "ip", "n", "si", "int", "io", "iu"], "B": ["AA", "Z", "P", "O", "CB", "R", "NB", "AB", "S", "T", "J", "L", "BB", "BC", "F", "X", "I", "K", "BL", "BI", "D", "M", "G", "U", "Y", "V", "C", "H", "WB", "BA", "MB", "Q", "W", "N", "Ab", "Bs", "Other", "BM"], "b": ["p", "o", "br", "sb", "nb", "d", "x", "un", "h", "l", "y", "BB", "base", "bs", "k", "z", "w", "g", "ab", "u", "n"], "j": ["p", "o", "_", "br", "li", "ch", "js", "jc", "q", "jp", "ji", "d", "J", "x", "ind", "oj", "y", "l", "h", "ii", "str", "jl", "aj", "key", "ie", "k", "z", "jj", "ja", "ij", "im", "g", "jo", "u", "n", "si", "int", "uj"], "v": ["p", "o", "conv", "ver", "vs", "nv", "av", "q", "d", "x", "h", "l", "y", "vi", "lv", "va", "uv", "k", "z", "value", "w", "g", "ve", "V", "vv", "u", "sv", "n"], "res": ["err", "ris", "p", "ons", "response", "R", " R", "vals", "resp", "relations", "powers", "details", "gr", "RE", "resolution", "es", "arr", "right", "data", "RES", "pres", "Rs", "args", "rev", "values", "ress", "os", "bs", "ps", "rh", " results", "blocks", " resolution", "RS", "Result", "re", "Results", "ms", "rap", "remote", "Res", "ros", " Res", "rs", "result", "ras", "results", "breaks"], "a": ["p", "Array", "ma", "art", "array", "all", "response", "ra", "aaa", "ia", "na", "app", "av", "ae", "ar", "sa", "au", "ach", "ai", "d", "ap", "am", "actions", "h", "alpha", "area", "args", "va", "ha", "aj", "ba", "api", "analysis", "ga", "z", "aw", "parts", "ad", "wa", "w", "ab", "u", "n", "an", "ac", "aa"], "m": ["p", "o", "pm", "R", "all", "mu", "mm", "range", "q", "ar", "sm", "mr", "d", "x", "h", "am", "l", "y", "ym", "bm", "ur", "md", "um", "M", "z", "k", "cm", "w", "g", "im", "C", "re", "mi", "u", "rm", "n", "er", "an", "mc"], "cnts": ["ecntns", "cNTs", "CNTps", "Cnots", "ecNTs", "Cnotp", "cntps", "cntd", " contns", "Cnti", "cnotps", "cptps", "ecnts", "Cndls", "Cndi", "cptd", "cnti", "cnots", "contns", "cNTp", "countp", "ccts", " conti", "crts", "countches", "cndi", " cntns", "crte", "ecNTns", "Cntd", "cndl", " conts", "crtd", "ecntls", "cctns", "Cntps", "categs", "cwni", "cwns", "Cntls", "cndls", "categi", "Cnte", "cntns", "cnotp", "cNTe", "criti", "conti", "Cntl", "cpte", "Cntches", "critp", "crtps", "cNTi", " cnti", "cntls", "cntches", "cnds", "cntl", "CNTd", "cnte", "categns", "cNTches", "cNTl", "Cnds", "cNTns", "Cnotches", "Cndl", "cctls", "crits", "Cnts", "CNTs", "cNTd", "cntp", "cnotches", "ecntp", "critns", "cNTls", "cwnl", "cNTps", "ecNTls", "counts", "critls", "CNTe", "Cntp", "conts", "cctp", "Cnotps", "cpts", "ecNTp", "countps", "cwnls"], "IN": ["IC", "MN", "Input", "URI", "RAW", "ins", "CL", "AC", "I", "INT", "IM", "bin", "INS", "BL", "inner", "CON", "AL", "IR", "IO", "M", "PIN", "EN", "input", "Reader", "URL", "DATA", "FILE", "LIB", "AN", "AD", "IL", "Out", "In", "OU", "LIN", "Con"], "e": ["err", "p", " eb", "se", "range", "ae", "d", "x", "h", "es", "l", "y", "end", "ce", "ec", "z", "ee", " ce", "fe", "w", "u", "ed", "n", "er"]}}
{"code": "def CASE(IN):\\n      def rstr(): return IN.readline().strip()\\n      def rint(): return int(rstr())\\n      def rints(): return map(int, rstr().split())\\n      def rr():\\n          x = rint()\\n          m = [rints() for i in xrange(4)]\\n          return set(m[x-1])\\n      s = rr().intersection(rr())\\n      if not s:\\n          return \"Volunteer cheated!\"\\n      if len(s) == 1:\\n          return s.pop()\\n      return \"Bad magician!\"\\n  \\n  \\n  def RUN(IN, OUT):\\n      t = int(IN.readline().strip())\\n      for i in xrange(1,t+1):\\n          OUT.write(\"Case #%i: %s\\n\" % (i, CASE(IN)))\\n  \\n  if __name__ == \"__main__\":\\n      RUN(sys.stdin, sys.stdout)\\n", "substitutes": {"IN": ["NG", "IC", "EX", "S", "MN", "ID", "URI", "Input", "RAW", "ins", "READ", "HTTP", "CL", "AC", "BC", "X", "TIME", "INT", "IND", "SQL", "String", "INS", "INE", "GE", "DIR", "NO", "IR", "AL", "IP", "UL", "IO", "LINE", "PIN", "EN", "DATA", "URL", "AN", "FILE", "input", "OSS", "TEXT", "STR", "MIN", "IL", "IT", "Out", "II", "NE", "In", "OU", "NAME", "LIN", "WIN", "NS", "N", "FIN"], "x": ["p", "o", "dx", "ww", "id", "ix", "ax", "xxx", "index", "q", "fx", "xt", "ex", "y", "X", "f", "c", "e", "xes", "xi", "k", "z", "xs", "xc", "rx", "w", "j", "xy", "v", "xp", "u", "xx", "sex", "n", "int", "tx"], "m": ["p", "o", "gm", "mm", "range", "fm", "sm", "mr", "d", "h", "y", "l", "f", "imm", "c", "ym", "e", "bm", "dm", "M", "hm", "r", "cm", "g", "mi", "b", "v", "ms", "u", "tm", "rm", "n", "mc"], "i": ["p", "o", "li", "id", "ci", "ix", "ei", "index", "ime", "d", "ai", "ind", "l", "ri", "f", "I", "gi", "ii", "c", "ti", "e", "ir", "ie", "xi", "abi", "pi", "z", "r", "a", "j", "b", "v", "ip", "u", "on", "qi", "n", "si", "int", "ih", "iu"], "s": ["p", "o", "ls", "ws", "lines", "S", "ss", "ches", "acks", "errors", "ns", "ins", "ips", "d", "es", "ops", "l", "y", "f", "rors", "strings", "c", "e", "ses", "gs", "ions", "os", "ows", "rows", "ps", "r", "abs", "xs", "a", "g", " lines", "its", "b", "v", "ing", "ms", "ments", "n", "sym", "rs", "an", "cs", "eds", "results", "ds"], "OUT": ["OT", "NG", "VERSION", "WR", "WARN", "EX", "ERROR", "UN", "PATH", "RAW", "READ", "NER", "ST", "EXT", "CL", "out", "PUT", "INT", "VER", "ISO", "INS", "UT", "IR", "IO", "Output", "TER", "FILE", "TEXT", "STR", "Out", "USE", "OU", "NET", "OS", "STDOUT", "NAME", "RET", "FS"], "t": ["p", "wt", "at", "tp", "st", "dt", "ts", "T", "time", "ot", "d", "out", "h", "y", "l", "f", "tz", "c", "ti", "e", "temp", "tt", "ta", "z", "r", "w", "g", "j", "b", "v", "pt", "u", "ty", "n"]}}
{"code": " \\n  \\n  \\n  class Minesweeper_2014_QC(puzutils.CodeJamProblem):\\n    def __init__(self, inputFilename):\\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\\n  \\n      self.T = None\\n  \\n    def load(self):\\n      \"\"\"\\n        input:\\n  \\n        T (number of test cases)\\n  \\n        R C M (integers)\\n  \\n      \"\"\"\\n  \\n      self.tests = []\\n  \\n      with open(self.inputFilename, \"rt\") as file:\\n        self.T = int(file.readline().strip())\\n  \\n        for i in xrange(self.T):\\n          (R,C,M) = [int(x) for x in file.readline().split(' ')]\\n  \\n          self.tests.append([R,C,M])\\n  \\n      return True\\n  \\n    def boardToString(self, board):\\n      retval = \"\"\\n  \\n      for row in board:\\n        retval = retval + \"\\n\" + \"\".join(row)\\n  \\n      return retval\\n  \\n    def executeTest(self, test):\\n      \"\"\"\\n        Run a test and return output.\\n      \"\"\"\\n  \\n      (R,C,M) = test\\n  \\n      spaces = R * C\\n      blanks = spaces - M\\n  \\n      if (blanks <= 0):\\n        return \"Impossible\"\\n  \\n      board = [['.' for x in range(C)] for y in range(R)]\\n  \\n      board[R-1][C-1] = \"c\"\\n  \\n      badpositions=[]\\n      positions=[]\\n  \\n      for x in xrange(C):\\n        for y in xrange(R):\\n          if (x == (C-1)) and (y == (R-1)):\\n            continue\\n          if (x == (C-1)) and (y == (R-2)):\\n            badpositions.append((x,y))\\n            continue\\n          if (x == (C-2)) and (y == (R-1)):\\n            badpositions.append((x,y))\\n            continue\\n          if (x == (C-2)) and (y == (R-2)):\\n            badpositions.append((x,y))\\n            continue\\n  \\n          positions.append((x,y))\\n  \\n      positions.reverse()\\n  \\n      for x in badpositions:\\n        positions.insert(0, x)\\n  \\n      m = M\\n  \\n      while (m > 0):\\n        if len(positions) <= 0:\\n          return \"Impossible\"\\n  \\n        pos = positions.pop()\\n        (x,y) = pos\\n  \\n        if (board[y][x] != \".\"):\\n          return \"Impossible\"\\n  \\n        board[y][x] = '*'\\n        m = m - 1\\n  \\n      mines = sum([x.count('*') for x in board])\\n  \\n      if (mines != M):\\n        return \"Impossible\"\\n  \\n      if (blanks > 1):\\n        if (R > 1):\\n          if board[R - 2][C - 1] == \"*\":\\n            return \"Impossible\"\\n  \\n        if (C > 1):\\n          if board[R - 1][C - 2] == \"*\":\\n            return \"Impossible\"\\n  \\n        if (R > 1) and (C > 1):\\n          if board[R - 2][C - 2] == \"*\":\\n            return \"Impossible\"\\n  \\n      return self.boardToString(board)\\n  \\n  with Minesweeper_2014_QC(sys.argv[1]) as problem:\\n    problem.load()\\n  \\n    problem.run()\\n", "substitutes": {"self": ["me", "all", "node", "case", "ws", "user", "event", "parent", "default", "part", "w", "driver", "public", "this", "plus", "er", "worker", "Self", "comment", "full", "resp", "app", "view", "func", "es", "c", "args", "form", "ng", "object", "instance", "load", "student", "ctx", "n", "layer", "results", "p", "spec", "file", "writer", "function", "f", "host", "client", "e", "wrapper", "hub", "work", "cl", "error", "private", "ref", "lf", "q", "base", "l", "http", "connection", "other", "cache", "k", "r", "static", "g", "context", "s", "server", "block", "method"], "inputFilename": ["inputFILE", "outputfilename", "requestFile", "outputDirectory", "inputDirectory", "sourceFilename", "InputFile", "InputFilename", "requestSourceFile", "requestFILE", "sourceDirectory", "inputSourceFile", "tempSourceFile", " inputfilename", "Inputfilename", "outputFilename", "outputSourceFile", "tempFile", "inputFile", "InputSourceFile", "tempDirectory", "outputFILE", "outputFile", "requestFilename", "inputfilename", "sourceSourceFile", " inputSourceFile", "sourceFile", " inputFile", " inputFILE", "tempFilename"], "T": ["Z", "Test", "P", "TT", "O", "A", "Length", "S", "WT", "B", "TA", "LT", "L", "TB", "F", "X", "I", "K", "t", "TS", "E", "CT", "TH", "TN", "Ts", "D", "G", "U", "Y", "V", "H", "Q", "W", "N", "TI", "TE", "TF", "NT"], "tests": ["steps", "features", "forms", "files", "runs", "lines", "classes", "reports", "ches", "suits", "ts", "tips", "times", "Times", "reads", "scripts", "boards", "TS", "events", "checks", "values", "testers", "ests", "videos", "rows", "rules", "sections", "types", "tools", "testing", "Testing", "ports", "tracks", "amples", "results", "cases"], "i": ["o", "bit", "id", "ci", "ix", "col", "ei", "xf", "index", "iii", "ind", "h", "f", "I", "ti", "ace", "e", "xi", "axis", "z", "j", "xy", "xp", "ip", "u", "sex", "io", "xb"], "R": ["CC", "Z", "P", "O", "A", "CR", "SC", "KR", "S", "JR", "B", "MR", "RA", "AR", "Run", "RE", "L", "RR", "CL", "LR", "F", "X", "J", "K", "I", "BR", "RN", "ER", "Rec", "RW", "Rs", "E", "IR", "NR", "RH", "Right", "DR", "RO", "D", "G", "r", "Rh", "U", "Y", "GR", "RS", "Cl", "V", "H", "RL", "RG", "Q", "HR", "W", "N", "SR", "RF", "RC", "RM", "Re", "DC", "Range"], "C": ["CC", "P", "CW", "SC", "CR", "A", "O", "Cr", "CS", "S", "B", "YC", "CI", "Cs", "CL", "DC", "L", "Code", "CM", "AC", "X", "F", "K", "I", "CV", "Sc", "c", "Ch", "CU", "CT", "E", "CN", "CNN", "CO", "VC", "D", "NC", "G", "EC", "MC", "U", "Y", "CA", "Ca", "Cl", "V", "CP", "H", "Co", "Cu", "CE", "CH", "Q", "KC", "W", "N", "RC"], "M": ["CC", "MQ", "Mo", "P", "O", "LM", "CR", "Z", "A", "Mass", "S", "MN", "MF", "B", "Multiple", "MR", "CL", "L", "VM", "CM", "F", "X", "I", "DM", "K", "E", "ME", "mode", "MM", "D", "OM", "MS", "MI", "MC", "MD", "G", "Mac", "U", "cm", "Y", "V", "H", "length", "EM", "MB", "number", "Q", "NM", "MX", "N", "W", "n", "RM", "FM"], "x": ["image", "case", "ix", "ch", "ax", "yx", "index", "event", "name", "time", "h", "ex", "xa", "position", "code", "key", "xi", "z", "match", "ic", "wa", "w", "yl", "xy", "v", "xxxx", "u", "ip", "on", "sex", "xb", "cross", "cy", "id", "pe", "xxx", "width", "ux", "c", "data", "mx", "xc", "Y", "rx", "xp", "ctx", "number", "n", "int", "ct", "p", "d", "X", "f", "wx", "step", "e", "t", "px", "xe", "check", "xs", "cl", "j", "xx", "an", "word", "one", "o", "dx", "xf", "q", "ay", "ext", "xt", "l", "g", "ey", "s", "b", "model", "tx"], "board": ["box", "array", "comment", "case", "square", "list", " clipboard", "deck", "problem", "boarding", "layout", "path", "rank", "view", "loop", "channel", "ro", " boards", "player", "card", "boards", "core", "ack", "room", "code", "table", "bo", "back", "form", "frame", "game", "hole", "control", "shape", "axis", "cell", "sequence", "Board", "arrow", "cart", " Board", "cube", "co", "bar", "home", "buffer", "object", "flow", "line", "reader", "string", "bank", "block", "bug", "word", "coll"], "retval": ["retVal", " retVal", "interVal", " retvals", "RETvalue", "RETVal", "returnVal", "intereval", "returnvals", " retvalue", " reteval", "Retvals", "Retval", "returnvalue", "retvalue", "interval", "retvals", "RETval", "RETvals", "Reteval", "Retvalue", "reteval", "returnval", "RetVal"], "row": ["array", "node", "comment", "val", "user", "col", "rank", "run", "range", "entry", "view", "ro", "record", "raw", "insert", "ack", "str", "key", "rows", "round", "roll", "cell", "arrow", "value", "buffer", "object", "Row", "flow", "line", "server", "reader", "string", "block", "page", "item", "ride", "result", "error", "feed", "bug"], "test": ["iter", "Test", "p", "_", "array", "all", "unit", "case", "py", "long", "pack", "valid", "txt", "run", "est", "slave", "loop", "example", "true", "xt", " Test", "F", "X", "f", "host", "fit", "c", "table", "t", "code", "temp", "form", "sub", "trial", "shape", "che", "check", "match", "arg", "value", "testing", "sample", "top", "buffer", "script", "v", "server", "min", "line", "model", "pattern", "instance", "call", "string", "mat", "result", "int", "train"], "spaces": ["spanks", "brace", "Spans", "brans", "branks", "space", "stans", "stanks", "spacing", "spans", "Spanks", " space", "staces", "Spacing", " spacing", " spans", "Spaces", " spanks", "braces", "stacing", "Space"], "blanks": ["plank", "planks", "Blank", " blaces", " blans", "blacks", "blaces", " blank", "Blaces", "blank", "blans", "Blacks", "Blans", "places", "Blanks", "plans", " blacks", "placks"], "y": ["o", "id", "py", "ch", "sy", "col", "hy", "q", "ye", "ay", "ish", "ny", "ya", "dy", "h", "yo", "vy", "yan", "iny", "yt", "c", "ry", "ym", "ies", "ady", "e", "t", "yi", "year", "ky", "yd", "z", "r", "yer", "gy", "Y", "yl", "j", "ey", "isy", "yn", "xy", "b", "iy", "ys", "zy", "my", "ty", "oy", "yy", "yu", "yr", "cy"], "badpositions": ["badositions", "badpositiones", "goodposresses", "Badposations", "BadPositions", "badposites", " badposites", "badPosresses", "badosites", "Badposition", "badnosits", " badositions", "badcondits", "goodPosresses", "badpositionites", " badoses", "badlocitions", "badlocions", "badPositions", "badPosits", "badposals", "badPoses", " badposions", "badposes", "badcondition", " badosions", " badposations", "BadPosites", "Badpositions", " badosites", "goodposits", "badPosition", "Badposions", "BadPosals", "BadPosition", "badpositionions", "badPosations", "badposits", "badosions", "goodPosions", " badposes", "badnosresses", "badcondions", "badconditions", "badnositions", "goodpositions", "Badposites", "goodposions", "badposition", "Badposals", " badosations", "badoses", "badosations", "badposations", "BadPosations", "badposresses", "badcondresses", "badlocals", "badposions", "badlocition", "goodPositions", "badPosions", "badPosites", "badPosals", "badpositionations", "BadPosions", "goodPosits", "badcondals", "badnosions", "badpositionitions"], "positions": ["locations", "partences", "locitions", "locions", "locelines", "psations", "posals", "condances", "locresses", "posices", "Position", "psances", " posensions", "psresses", "partits", "posences", "Posresses", "position", "psitions", "condions", "Posals", "potits", "posits", "Positions", "condations", "posances", "Posices", " position", "posensions", "conditions", "Posances", "posations", " posresses", "partensions", " posals", "potitions", " posions", "potensions", "potences", "posions", "partals", "poselines", " posences", "Posions", "condelines", "Posations", " posations", "partitions", " posits", "posresses", "partition", " posices", "condresses", " poselines", "partices"], "m": ["p", "o", "pm", "gm", "mu", "mm", "machine", "man", "sm", "mr", "d", "am", "l", "f", "c", "ym", "e", "bm", "t", "dm", "mini", "um", "meta", "z", "r", "cm", "w", "im", "mi", "b", "v", "ms", "u", "tm", "n", "mc", "mass"], "pos": ["trans", "pl", "p", "o", "st", " Pos", "d", "l", "f", "found", "lab", "position", "e", "cond", "no", "pro", "po", " position", "ps", "object", "s", "POS", "loc", "n", "Pos", " POS"]}}
{"code": " \\n  \\n  \\n  class Magic_2014_QA(puzutils.CodeJamProblem):\\n    def __init__(self, inputFilename):\\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\\n  \\n      self.T = None\\n  \\n    def load(self):\\n      \"\"\"\\n        input:\\n  \\n        T (number of test cases)\\n  \\n        A (answer to first question)\\n        x x x x\\n        x x x x\\n        x x x x\\n        x x x x\\n        B (answer to second question)\\n        x x x x\\n        x x x x\\n        x x x x\\n        x x x x\\n  \\n      \"\"\"\\n  \\n      self.tests = []\\n  \\n      with open(self.inputFilename, \"rt\") as file:\\n        self.T = int(file.readline().strip())\\n  \\n        for i in xrange(self.T):\\n          a = int(file.readline().strip())\\n          test = {'a': a}\\n          board = []\\n          \\n          for j in xrange(4):\\n            line = file.readline().strip()\\n            row = set([int(x) for x in line.split(' ')])\\n            board.append(row)\\n  \\n          test['aboard'] = board\\n  \\n          b = int(file.readline().strip())\\n          test['b'] = b\\n          board = []\\n          \\n          for j in xrange(4):\\n            line = file.readline().strip()\\n            row = set([int(x) for x in line.split(' ')])\\n            board.append(row)\\n  \\n          test['bboard'] = board\\n  \\n          self.tests.append(test)\\n  \\n      return True\\n  \\n    def executeTest(self, test):\\n      \"\"\"\\n        Run a test and return output.\\n      \"\"\"\\n  \\n  \\n      rowA = test['aboard'][test['a'] - 1]\\n      rowB = test['bboard'][test['b'] - 1]\\n  \\n  \\n      intersect = rowA.intersection(rowB)\\n  \\n  \\n      if (len(intersect) == 1):\\n        (element,) = intersect\\n        return element\\n      elif (len(intersect) == 0):\\n        return \"Volunteer cheated!\"\\n      else:\\n        return \"Bad magician!\"\\n  \\n  with Magic_2014_QA(sys.argv[1]) as problem:\\n    problem.load()\\n  \\n    problem.run()\\n", "substitutes": {"self": ["me", "all", "node", "case", "user", "event", "time", "h", "parent", "job", "part", "w", "public", "ess", "this", "plus", "er", "worker", "old", "home", "gen", "Self", "comment", "full", "resp", "app", "view", "func", "m", "python", "es", "c", "args", "ng", "module", "object", "instance", "load", "pos", "ctx", "n", "result", "results", "layer", "manager", "p", "spec", "file", "function", "f", "host", "client", "e", "str", "work", "cl", "my", "error", "private", "ref", "parse", "lf", "q", "http", "connection", "other", "cache", "k", "r", "g", "context", "s", "server", "model", "master", "method"], "inputFilename": ["outputfilename", "outputDirectory", "inputDirectory", "sourceFilename", "InputFile", "InputFilename", "sourceDirectory", "inputSourceFile", "sourcefilename", " inputfilename", "Inputfilename", "outputFilename", "outputSourceFile", "inputFile", "InputSourceFile", "outputFile", "InputDirectory", "inputfilename", " inputSourceFile", "sourceFile", " inputFile"], "T": ["Z", "Test", "TT", "P", "A", "O", "R", "Length", "S", "WT", "B", "Type", "TA", "L", "TB", "F", "X", "K", "t", "TS", "E", "TH", "TN", "Ts", "D", "M", "G", "PT", "Y", "C", "V", "H", "Q", "W", "N", "TI", "TE", "TF", "NT"], "tests": ["steps", "features", "forms", "files", "runs", "lines", "classes", "reports", "tested", "suits", "ts", "errors", "modules", "reads", "scripts", "models", "checks", "events", "testers", "ests", "rows", "rules", "sections", "types", "groups", "tools", "testing", "settings", "thumbnails", "fixes", "results", "cases"], "i": ["iq", "id", "ix", "ei", "q", "ji", "ai", "ind", "y", "gi", "I", "ii", "c", "ti", "e", "ie", "num", "xi", "k", "z", "ij", "ib", "ip", "u", "on", "n", "io", "iu"], "a": ["p", "A", "ma", "la", "array", "qa", "na", "aa", "ae", "sa", "au", "ai", "ea", "am", "asa", "alpha", "area", "c", "fa", "va", "ata", "aj", "ba", "ga", "wa", "ad", "tta", "ab", "oa", "action", "ana", "ca", "n", "an", "da", "ac"], "test": ["Test", "all", "unit", "case", "list", "pack", "est", "rest", "event", "fail", "parent", "default", "code", "scale", "both", "shape", "match", "fill", "rate", "script", "this", "bug", "style", "cross", "old", "acc", "comment", "stage", "full", "ss", "app", "example", "data", "table", "form", "tt", "trial", "set", "the", "load", "diff", "result", "train", "valid", "config", "tested", "file", "build", "port", "t", "temp", "cell", "check", "create", "sync", "use", "call", "off", "new", "dev", "show", "report", "catch", "run", "sc", "null", "target", "search", "rule", "game", "type", "value", "testing", "server", "model", "master", "complete", "pattern", "feed", "transfer"], "board": ["array", "list", "layout", "head", "ox", "boards", "area", "scale", "code", "ward", "control", "buffer", "length", "bug", "ca", "clean", "cross", "home", "comment", "view", "une", "menu", "card", "data", "ack", "table", "back", "form", "down", "sequence", "Board", "hack", "flow", "number", "bee", "col", "boarding", "que", "flo", "bo", "cell", "cart", "bean", "course", "error", "word", "coll", "one", "box", "team", "square", "group", "deck", "loop", "foot", "road", "oard", "game", "che", "type", "co", "bar", "union", "model", "design", "land", "store", "string", "block", "away", "lane"], "j": ["p", "o", "id", "q", "jp", "ji", "d", "J", "ind", "y", "f", "l", "c", "jl", "ie", "job", "obj", "k", "z", "r", "je", "ja", "ij", "dj", "im", "v", "ip", "jam", "n", "uj"], "line": ["band", "la", "word", "unit", "comment", "case", "label", "list", "lines", "link", "se", "lin", "lc", "pe", "ine", "log", "file", "entry", "Line", "loop", "name", "point", "write", "l", "lock", "message", "liner", "lo", "play", "code", "chain", "ell", "frame", "el", "ze", "source", "cell", "lined", "pin", "cle", "inline", "co", "home", "buffer", "byte", "object", "sync", "string", "block", "page", "feed", "style", "lane", "coll", "one"], "row": ["box", "stroke", "coll", "node", "case", "link", "group", "col", "pe", "view", "entry", "loop", "order", "ro", "fail", "step", "raw", "scale", "ward", "key", "rows", "ner", "roll", "cell", "r", "value", "way", "column", "bar", "Row", "server", "sync", "reader", "block", "feed", "ride", "bug", "page", "sel", "cross", "where", "one"], "x": ["p", "ph", "bit", "id", "ix", "full", "ax", "xxx", "index", "q", "m", "time", "d", "lex", "h", "ex", "y", "X", "f", "l", "xt", "ux", "out", "c", "day", "data", "e", "code", "t", "ck", "num", "xi", "ga", "z", "xs", "gy", "xc", "rx", "w", "u", "on", "string", "xx", "n", "int", "word", "ct", "one"], "b": ["p", "new", " eb", "B", "sb", "lb", "nb", "d", "bi", "body", "base", "h", "l", "y", "f", "ob", "c", "bin", "e", "t", "book", "ba", "r", "bb", "w", "g", "ab", "bc", "bar", "s", "v", "u", "boot", "n", "binary"], "rowA": ["colC", "colA", "serverB", "rowa", "colB", "roA", "serverA", "RowC", "rowC", "RowA", "serverC", "roB", " rowa", "servera", "roa", "RowB", " rowC", "roC"], "rowB": [" rowb", "bugb", "colA", "rob", "Rowb", "colB", "roA", "roBB", "colb", "RowA", "rowb", "roB", "bugB", "rowBB", "bugA", "RowBB", "RowB", " rowBB"], "intersect": ["corsection", "crossconnect", "consections", "interect", "corception", "consection", "surpass", "extsections", "Interception", "crosssect", "surcept", "crosspass", "extsect", "crossect", "extsection", "corsect", "interception", "surconnect", "consect", "intersections", "intercept", "Interconnect", "Interpass", "crosssection", "extcept", "crossception", "precept", "Intersections", "preconnect", "intersection", "presect", "interconnect", "concept", "corect", "interpass", "Intersection", "Intercept", "sursection", "presection", "Intersect", "sursect", "Interect"], "element": ["array", "lement", "node", "unit", "div", "address", "all", "case", "document", "entry", "ele", "null", "feature", "parent", "Element", "member", "e", "table", "article", "sect", "empty", "component", "module", "cell", "sequence", "ee", "match", "value", "length", "object", "union", "instance", "server", "root", "this", "action", "item", "section", "style", "result", "layer", "option"]}}
{"code": " \\n  f = open(sys.argv[1])\\n  T = int(f.readline())\\n  for test in range(T):\\n      R, C, M = map(int, f.readline().strip().split())\\n      Rorig = R\\n      Corig = C\\n      impossible = False\\n      grid = [['.' for i in range(C)] for j in range(R)]\\n  \\n      curr_coord = [0,0]\\n      while M > 0 and not impossible:\\n          if (C > R): # more columns - fill one in\\n              num_mines_in_column = R\\n              if M < R:\\n                  num_mines_in_column = min(R - 2, M)\\n              if num_mines_in_column <= 0:\\n                  impossible = True\\n                  break\\n              for ii in range(num_mines_in_column):\\n                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'\\n              C -= 1\\n              curr_coord[1] += 1\\n              M -= num_mines_in_column\\n          else:\\n              num_mines_in_row = C\\n              if M < C:\\n                  num_mines_in_row = min(C - 2, M)\\n              if num_mines_in_row <= 0:\\n                  impossible = True\\n                  break\\n              for ii in range(num_mines_in_row):\\n                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'\\n              R -= 1\\n              curr_coord[0] += 1\\n              M -= num_mines_in_row\\n  \\n      print \"Case #%d:\" % (test + 1)\\n      if impossible:\\n          print \"Impossible\"\\n      else:\\n          for ii in range(Rorig):\\n              for jj in range(Corig):\\n                  if grid[ii][jj] == '.':\\n                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':\\n                          grid[ii][jj] = 'dirty'\\n                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\\n                          grid[ii][jj] = 'dirty'\\n                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\\n                          grid[ii][jj] = 'dirty'\\n  \\n          for ii in range(Rorig):\\n              for jj in range(Corig):\\n                  if grid[ii][jj] == 'dirty':\\n                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':\\n                          grid[ii][jj] = '.'\\n                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':\\n                          grid[ii][jj] = '.'\\n                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\\n                          grid[ii][jj] = '.'\\n                      else:\\n                          if ii != Rorig - 1 or jj != Corig - 1:\\n                              impossible = True\\n  \\n          if impossible:\\n              print \"Impossible\"\\n          else:\\n              grid[Rorig-1][Corig-1] = 'c'\\n  \\n              for ii in range(Rorig):\\n                  print \" \".join([val for val in grid[ii]])\\n  \\n  \\n", "substitutes": {"f": ["ref", "iter", "p", "o", "fp", "lf", "fast", "file", "m", "d", "fx", "x", "h", "F", "l", "fo", "fn", "c", "fr", "fd", "e", "fb", "t", "form", "fw", "info", "tf", "buff", "z", "handler", "r", "fs", "w", "g", "s", "b", "v", "feed", "fen", "io", "folder", "af"], "T": ["TG", "Z", "Test", "TT", "P", "O", "TC", "S", "WT", "Type", "B", "TA", "L", "TB", "F", "X", "DT", "I", "TS", "t", "E", "CT", "TN", "Ts", "D", "U", "Y", "V", "H", "Q", "N", "TF", "Time", "Tab"], "test": ["tim", "py", "tr", " cp", " temp", "time", "d", "ind", "times", " me", " check", "c", "ti", "e", "code", "t", "nt", "r", " now", " b", " z", " seq", "g", " ti", "n", "ct"], "R": ["P", "A", "CR", "S", "B", "Ra", "MR", "RA", "AR", "J", "L", "RR", "RE", "F", "X", "I", "RN", "K", "RP", "ER", "RW", "Rs", "E", "NR", "RH", "Right", "RO", "D", "G", "r", " r", "Rh", "U", "Y", "RS", "V", "H", "RT", "RG", "Q", "W", "N", "SR", "RM"], "C": ["CC", "P", "O", "A", "CF", "CR", "S", "B", "Cs", "CI", "JC", "DC", "L", "CL", "CM", "F", "X", "K", "I", "c", "CU", "E", "CT", "CN", "RH", "CO", "CNN", "Cy", "D", "G", "NC", "EC", "U", "Y", "CA", "Cl", " c", "V", "Co", "H", "Cu", "Size", "CE", "W", "N", "CV"], "M": ["P", "O", "S", "MN", "B", "m", "J", "L", "F", "X", "I", "DM", "IM", "JM", "E", "MOD", "D", "G", "MS", "MD", "r", "MC", "U", "Y", "V", "H", "MT", "PM", "Q", "W", "N", "RM", "MON"], "Rorig": ["Rseq", "RGorig", "RGseq", "Torig", "Ccoll", "COrig", "RGcoll", "ROrig", "Cseq", "Rcoll", "RGOrig", "TOrig", "Tcoll", "Tseq"], "Corig": ["Stig", "corig", "StIG", "Stigs", " Corrig", "corrig", " Corigs", "Strig", "Corigs", "Corrig", "corIG", " CorIG", "CorIG", "corigs"], "impossible": ["compossibly", "compossibility", "impossibly", "Impossibility", "Impact", "ispossibility", "compable", "impable", "ispact", "pable", "Impossible", "Impable", "pact", "ispossible", "impact", "Impossibly", "compossible", "possibly", "impossibility", "possible", "ispossibly", "possibility"], "grid": ["A", "id", " chain", " grids", "ID", " cells", " Q", "Grid", " QR", " np", " row", "chain", " mat", " cell", " structure", " residue", " mask", " sim", " G", " trace", " coord", " block", " seq", " solution", " id", " Grid", "mat", " data"], "i": ["p", "o", "op", "id", "ci", "ix", " bi", "q", "d", "ai", "h", " I", "y", "gi", "I", "e", "ir", "ie", "z", "a", "co", "g", "im", "bc", "ib", "b", "iw", "pc", "ac"], "j": ["id", "cor", "q", "ar", "jp", "d", "J", "x", "ind", "y", "c", "ym", "ir", "ie", "num", "k", "z", "r", "co", "g", "im", "ij", "b", "pos", " J", "u", "n", "ct"], "curr_coord": ["curr2orig", "curr_num", "curr2pos", "curvr_pos", "curr_orig", "curvr_orig", "curvr_coord", "curvr2num", "curvr2coord", "curvr2pos", "curvr_num", "curr_pos", "curvr2orig", "curr2num", "curr2coord"]}}
{"code": " \\n  f = open(sys.argv[1])\\n  T = int(f.readline())\\n  for test in range(T):\\n      first_row_index = int(f.readline())\\n      first_row = []\\n      for ii in range(4):\\n          if (ii + 1) == first_row_index:\\n              first_row = f.readline().strip().split()\\n          else:\\n              f.readline()\\n      second_row_index = int(f.readline())\\n      second_row = []\\n      for ii in range(4):\\n          if (ii + 1) == second_row_index:\\n              second_row = f.readline().strip().split()\\n          else:\\n              f.readline()\\n      combined = [val for val in first_row if val in second_row]\\n  \\n      print \"Case #%d:\" % (test + 1), \"Bad magician!\" if len(combined) > 1 else \"Volunteer cheated!\" if len(combined) == 0 else combined[0]\\n  \\n  \\n", "substitutes": {"f": ["iter", "p", "fp", "lf", "fu", "fast", "full", "of", "fm", "file", "m", "function", "d", "fx", "x", "rf", "h", "F", "l", "fo", "fn", "http", "found", "y", "c", "fr", "fd", "fa", "e", "fb", "t", "form", "api", "i", "fw", "fc", "info", "tf", "z", "handler", "bf", "fe", "fing", "conf", "fs", "w", "g", "s", "b", "v", "feed", "fen", "io", "inf", "df", "ff", "af"], "T": ["Test", "TT", "P", "O", "R", "S", "WT", "B", "L", "F", "X", "I", "TS", "t", "E", "TN", "Ti", "D", "M", "G", "Y", "C", "V", "H", "Q", "W", "N", "TI", "Tu"], "test": ["err", "iter", "Test", "tests", "acc", "ver", "unit", "id", "py", "case", "pack", "txt", "ss", "init", "seq", "est", "app", "ice", "loop", "order", "example", "x", "ind", "out", "y", "gi", "count", "vi", "ti", "t", "seed", "temp", "sect", "tri", "num", "i", "trial", "di", "match", "testing", "v", "diff", "dim", "fix", "int", "train"], "first_row_index": ["first_row_width", "first_rows_num", "first_rows_width", "first_col_length", "first_col_index", "first_col_num", "first_rows_index", "first_row_length", "first_row_num"], "first_row": [" first_entry", "second_line", " first_rows", "first_ro", "first_rows", "last_col", "last_rows", "first_col", "last_row", "last_ro", "first_entry", "first_line", " first_col", "second_entry", "second_rows"], "ii": ["img", "iter", "iq", "chi", "li", "ui", "id", "ci", "ix", " iii", "qa", "iii", "ei", "index", "ice", "ini", "ji", "ai", "ien", "ind", "agi", "gi", "iff", "vi", "ti", "yi", "zi", "ie", "mini", "i", "lli", "di", "pi", "xi", "z", "ni", "fi", "sci", "II", "hi", "iw", "qi", "si", "inf", "ih", "iu", "ou"], "second_row_index": ["second_row_length", "second_row0length", "second_col_index", "second_row0index", "second_col_length", "second_row_num", "second_col_end", "second_row_end", "second_col_num", "second_row0end"], "second_row": ["second_page", "next_page", "first_rows", "first_ow", "second_month", "next_index", "two_row", "second_raw", "first_raw", "two_rows", "two_month", "next_rows", "next_row", "second_ow", "second_entry", "second_rows", "two_entry", "second_index"], "combined": ["combination", "comining", "Combined", "combinated", "comaned", "confinated", " combining", "Combinated", "laminated", "combines", "labined", "comined", "comboded", "declaned", "decloded", "lamined", " combaned", "lamine", " comboded", "declined", "confines", "combine", "Combine", "laboded", "comered", " combination", "comines", " combered", "combining", "comoded", "confine", "combered", "declered", "confoded", "combaned", "confination", "confered", "confined", "Combining", "labination", " combines", "confining", "lamining", "labered"], "val": ["ref", "il", "p", "pl", " v", "VAL", "all", "unit", "vals", "div", "py", "id", "valid", "col", "index", "std", "ot", "x", "ind", "l", "data", "str", "eval", "key", "var", "num", "value", "arg", "fill", "fi", "g", "viol", "elt", "v", "li", "pos", "Val", "bl", "pr", "item", "sl", "int", "sel", "dev"]}}
{"code": "\"\"\"\\n  Google Code Jam 2014 Qualification Problem C\\n  Usage:\\n      python c.py < input.txt > output.txt\\n  \"\"\"\\n  \\n  \\n  def iter_neighbors(x, y, cells):\\n      columns = len(cells[0])\\n      rows = len(cells)\\n  \\n      if y > 0:\\n          if x > 0:\\n              yield x - 1, y - 1\\n          yield x, y - 1\\n  \\n          if x + 1 < columns:\\n              yield x + 1, y - 1\\n  \\n      if x > 0:\\n          yield x - 1, y\\n  \\n      if x + 1 < columns:\\n          yield x + 1, y\\n  \\n      if y + 1 < rows:\\n          if x > 0:\\n              yield x - 1, y + 1\\n  \\n          yield x, y + 1\\n  \\n          if x + 1 < columns:\\n              yield x + 1, y + 1\\n  \\n  \\n  def try_to_click(x, y, cells, remaining):\\n      if remaining == 0:\\n          return cells\\n  \\n      recent = []\\n  \\n      opened = 0\\n  \\n      for n_x, n_y in iter_neighbors(x, y, cells):\\n          if cells[n_y][n_x] == \"?\":\\n              cells[n_y][n_x] = \".\"\\n              opened += 1\\n              recent.append((n_x, n_y))\\n  \\n      if opened == remaining:\\n          return cells\\n  \\n      if opened > remaining:\\n          return []\\n  \\n      for n_x, n_y in recent:\\n          solution = try_to_click(n_x, n_y, copy.deepcopy(cells), remaining - opened)\\n          if solution:\\n              return solution\\n  \\n      return []\\n  \\n  \\n  def solve_problem(rows, columns, mines):\\n  \\n      for x in xrange(columns):\\n          for y in xrange(rows):\\n              cells = [[\"?\" for i in xrange(columns)] for j in xrange(rows)]\\n              cells[y][x] = \"c\"\\n              solution = try_to_click(x, y, cells, rows * columns - mines - 1)\\n  \\n              if solution:\\n                  return \"\\n\".join([\"\".join(row) for row in solution]).replace(\"?\", \"*\")\\n  \\n      return \"Impossible\"\\n  \\n  \\n  if __name__ == \"__main__\":\\n      num_of_cases = int(sys.stdin.readline().strip())\\n      for i in xrange(1, num_of_cases + 1):\\n  \\n          rows, columns, mines = map(int, sys.stdin.readline().strip().split())\\n  \\n          print \"Case #{0}:\\n{1}\".format(i, solve_problem(rows, columns, mines))\\n", "substitutes": {"x": ["_", "image", "ix", "ch", "ax", "yx", "index", "event", "name", "any", "h", "ex", "code", "no", "xi", "z", "ic", "w", "xy", "v", "u", "on", "xml", "cy", "id", "pe", "xxx", "m", "by", "right", "c", "win", "xc", "Y", "rx", "ty", "n", "int", "ct", "p", "ci", "col", "na", "d", "dy", "X", "f", "wx", "inx", "e", "t", "xes", "ck", "px", "cell", "xs", "a", "work", "ys", "my", "yes", "xx", "o", "dx", "val", "q", "ye", "ay", "lex", "ya", "xt", "l", "ry", "k", "g", "ey", "s", "b", "tx"], "y": ["p", "o", "id", "py", "ch", "ci", "sy", "col", "hy", "idy", "yx", "wy", "q", "ye", "m", "ay", "ish", "d", "ny", "ya", "dy", "yo", "vy", "ery", "h", "l", "yt", "c", "ry", "ies", "ym", "ady", "t", "e", "yi", "year", "ky", "yd", "z", "cell", "type", "gy", "Y", "a", "yl", "w", "ey", "yn", "xy", "b", "v", "iy", "ys", "min", "zy", "ty", "my", "yes", "n", "sky", "oy", "yy", "yu", "yr", "cy"], "cells": ["tests", "_", "all", "files", "sheets", "case", "cards", "reports", "details", "books", "cel", "true", "facts", "points", "items", " cell", "z", "holes", "ks", "versions", "words", "comments", "ed", "cs", "windows", "cases", "cy", "rooms", "Cell", "ches", "states", "fields", "c", "ells", "ies", "ries", "models", "values", "keys", "rules", "groups", "parts", "ports", "images", " Cells", "ls", "ci", "lines", "codes", "false", "grid", "xes", "events", "ce", "cell", "sections", "cats", "blocks", "xs", "charges", "apps", "pages", "features", "ences", "classes", "inches", "plugins", "yrs", "styles", "games", "l", "phones", "ces", "csv", "ions", "sites", "cache", "ows", "objects", "letters", "conf", "settings", "cb", "s", "members", "south", "breaks"], "columns": ["colths", "Columnes", "coles", "wellues", "platformes", "columnows", "columnfs", "columnths", "columnches", "widthensions", "maximumths", "colses", "Columnstates", "paragraphments", "columnops", "wellns", "colns", "patternions", "paragraphses", "widthumes", "columnes", " columnes", "columnses", "maximumes", "widthches", "widthes", "Columnches", "pathstates", "colions", "Columnfs", "columnensions", "paths", "widthues", "colues", "welles", "columnns", "Columns", "Columnses", "yls", "colings", "patterns", "ylns", "widthops", "platforms", "colments", "Columnions", "colows", "cellops", "platformths", "colches", "colfs", "widths", "cols", "paragraphs", " columnments", "ylues", "widthows", "patternes", "columnumes", "paragraphings", " columnings", "colstates", " columnses", "columnings", "columnions", "colops", " columnensions", "maximumses", "columnments", "pathches", "platformses", "wells", "columnues", "cellumes", "cellows", "colensions", "widthions", "pathes", "maximums", "columes", "patternses", "yles", "widthfs", " columnues", "columnstates", "Columnows"], "rows": ["rown", "tests", "rooms", "features", "forms", "projects", "files", "runs", "rics", "height", "lines", "col", "reports", "relations", "users", "acks", "ins", "yards", "opens", "fields", "times", "ids", "reads", "c", "faces", "ries", "breaks", "flows", "views", "events", "checks", "values", "ows", "frames", "posts", "rules", "keys", "dates", "types", "holes", "r", "blocks", "groups", "ks", "vers", "w", "headers", "length", "boxes", "s", "orders", "months", "ports", "members", "heads", "planes", "tracks", "rs", "windows", "rings", "cases", "pages"], "remaining": ["romaining", "resain", "Remerving", "remain", "romains", "Remained", "expains", " remain", "romain", "remerving", "expain", "Remains", "reserving", " remained", "resained", "resains", " remerving", "romained", "Remstanding", "remains", "Remain", "resstanding", "expaining", " remending", "remending", "remained", "remstanding", "resaining", "Remaining", "Remending", "expained", " remstanding", "resending"], "recent": ["latest", "new", "exp", "old", "hold", "active", "today", "open", "valid", "region", "modern", "apse", "current", "event", "fresh", "opens", "later", "shown", "created", "true", "confirmed", "record", "raw", "past", "successful", "right", "client", "updated", "apsed", "many", "items", "events", "complex", "archive", "available", "Recent", "quick", "sofar", "partial", "ready", "initial", "best", "closed", "window", "unique", "last", "instance", " recently", "small", "short", "complete", "popular", "accessible", "memory", "remote", "original", "progress", "ances", "close", "folder", "correct", "exclusive"], "opened": ["played", "connected", "aled", "called", "open", "rated", "ened", "established", "drawn", "pressed", "nc", "expected", "opens", "raised", "shown", "created", "ended", "answered", "released", "orig", "confirmed", "successful", "edited", " reopened", " consumed", "updated", "signed", "apsed", "adjusted", "assembled", "used", "ordered", "focused", "forced", "aced", "rawn", "initialized", "started", "lined", "early", "awed", "posted", "selected", "size", "closed", "opening", "sized", "eno", "worked", "ned", "added", "produced", "handled", "ed", "original", "locked", "anged", "served"], "n_x": ["n_z", "n_ux", " n_dx", "N_x", "en_z", "n_dx", "nNewx", "n_wy", "n_ci", "enFz", "en_wy", " n_na", " n_ci", "nNewy", "N_wx", "enFy", "N_rx", "nFx", " n_ya", "nFy", "n_ya", "enFx", "n_yx", " n_yx", "en_y", "nNewrx", " n_z", "enFwy", "nNewwx", "nFz", "N_y", "en_x", "n_rx", "n_na", "nFwy", " n_ux", "n_wx"], "n_y": ["n_z", "N_x", "tXyi", "n___yn", "nLogz", "n_wy", "nXy", "t_x", " n_gy", "n_yn", "no_y", "N_ym", "n_ym", "tXy", "nNewyn", "tXi", "nin_ey", "nXx", "nin_y", " n_wy", "nNewy", "N_yt", "no_yn", "nNewny", "n_yl", "nin_yi", "n_yt", "t_yi", "n___gy", "n___x", "nLogx", "no_yl", "n_yi", "nLogwy", "no_ny", "n_i", "n_ey", "nXyi", "t_i", " n_yn", "n___y", "nNewyl", "tXx", "n_gy", " n_z", "t_y", "N_y", "nXi", "n_ny", "nin_z", "nLogy"], "solution": ["setsolved", "Solving", "suffolving", "fsolution", "colve", "colutions", "sesolutions", "psolution", "sour", "absolution", "ssolver", "setsolve", "sesolved", "ssolving", "setsolver", "solved", "fsolver", "ssour", "folving", "absolutions", "sesolving", "solving", "solutions", " solve", "Solve", "psour", "ssolved", "suffolution", "ssolve", " solving", "folver", "ssolution", " solutions", "setsolution", "sesolver", "colver", "folved", "colution", "ssolutions", "Solutions", "fsolve", "setsolving", "absolver", "folution", "Solved", "setsour", "sesolve", "suffolver", "fsolving", "suffolved", "absolve", "solver", "sesolution", "psolve", " solved", "psolved", "Solution", "Solver", "solve"], "mines": ["MINuses", "tenies", "millions", "Minutes", "Mins", "Minies", " minies", "minuses", "Minions", "mins", "millutes", "millizes", "minutes", " minuses", " minutes", "tens", "Minizes", "minions", " minions", "MINions", "minizes", "MINs", "Mines", "minies", "Minuses", "MINes", "tenes", "tenions", " minizes", " mins", "milles"], "i": ["it", "li", "ci", "ix", "col", "ia", "q", "m", "d", "ai", "ind", "l", "f", "h", "ii", "c", "e", "yi", "pi", "xi", "z", "im", "b", "v", "iy", "ip", "iw", "u", "n", "io", "int"], "j": ["p", "o", "ci", "hy", "q", "m", "ji", "ay", "ny", "h", "dy", "yu", "ry", "ady", "k", "z", " ye", "je", "cm", "co", "ij", "b", "iy", "zy", "my", "yy", "ct", "yr"], "row": ["rown", " v", "node", "query", " ro", "ow", "uu", " ur", "col", " key", "range", "rc", "entry", "ye", " col", "container", "raw", " u", " Row", " tr", "cer", "rect", "cell", "r", " r", "value", "cube", " z", "co", " c", "Row", "xy", "server", "line", "v", "model", "char", " d", "bug", "item", "feed", "error", "result", "sel"], "num_of_cases": ["num_of_windows", "num_of_tests", "num_of_case", "num_of_times", "num_of_blocks"]}}
{"code": "\"\"\"\\n  Google Code Jam 2014 Qualification Problem A\\n  Usage:\\n      python a.py < input.txt > output.txt\\n  \"\"\"\\n  \\n  \\n  def solve_problem(first, first_rows, second, second_rows):\\n      intersection = set(first_rows[first - 1]) & set(second_rows[second - 1])\\n  \\n      if not intersection:\\n          return \"Volunteer cheated!\"\\n      elif len(intersection) > 1:\\n          return \"Bad magician!\"\\n      else:\\n          return intersection.pop()\\n  \\n  \\n  \\n  if __name__ == \"__main__\":\\n      num_of_cases = int(sys.stdin.readline().strip())\\n  \\n      for i in xrange(1, num_of_cases + 1):\\n          first_answer = int(sys.stdin.readline().strip())\\n          first_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\\n  \\n          second_answer = int(sys.stdin.readline().strip())\\n          second_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\\n  \\n          print \"Case #{0}: {1}\".format(i, solve_problem(first_answer, first_arrangement, second_answer, second_arrangement))\\n", "substitutes": {"first": ["split", "latest", "start", "all", "case", "full", "current", "st", "same", "name", "fifth", "next", "central", "missing", "alpha", "third", "default", "right", "only", "table", "final", "front", "prev", "self", "leading", "fourth", "part", "initial", "value", "top", "left", "last", "th", "primary", "now", "First", "one"], "first_rows": ["second_ows", "first_results", "last_cells", "last_lines", "last_rows", "last_row", "first_lines", "first_ows", "second_results", "first_cells", "second_row", "first_row"], "second": ["split", "latest", "new", "Second", "multiple", "current", "same", "fifth", "later", "also", "double", "again", "next", "follow", "secret", "member", "site", "other", "final", "after", "middle", "both", "two", "secondary", "fourth", "video", "initial", "future", "left", "last", "another", "lower", "south", "common", "seconds", "one"], "second_rows": ["two_cells", "second_lines", "two_lines", "two_row", "two_cases", "two_rows", "second_cases", "second_row", "second_cells"], "intersection": ["corsection", "tersections", "intersector", "overection", "intsector", "interection", "incscription", "oversection", "terscription", "tersector", "intection", "overscription", "extsect", "Intersector", "extsection", "corsect", " interunion", "incection", "intscription", "extection", "INTERsection", "INTERection", "intersections", "intsection", "intsections", "Interection", "incsections", "Interunion", "oversections", "interunion", "incsection", "tersection", "Intersections", "intersect", "corunion", " interscription", "interscription", " intersect", "INTERsector", "Intersection", "extsector", "corsections", "Intersect", " intersections", " intersector", "INTERsect"], "num_of_cases": ["num_ofoftimes", "num_ofoftests", "num_Of_cases", "num_Ofoftimes", "num_ofofcase", "num_of_tests", "num_of_lines", "num_ofoflines", "num_of_steps", "num_of_case", "num_Of_lines", "num_Ofofcase", "num_of_times", "num_ofofcases", "num_ofofsteps", "num_Of_times", "num_Ofofcases", "num_Of_case", "num_Ofoflines"], "i": ["o", "it", "p", "start", "id", "ci", "ix", "iii", "index", "phi", "ai", "ind", "y", "ri", "f", "I", "gi", "ii", "c", "ti", "e", "eni", "t", "end", "yi", "uri", "xi", "pi", "k", "r", "a", "j", "u", "ip", "qi", "n", "io", "int", "si"], "first_answer": ["first___answer", "first__response", "first___acid", "first_result", "first___response", "first_Answer", "first__Answer", "pre_examination", " first_response", " first__Answer", "pre_answer", "first__result", "first__answer", " first__result", "pre_response", "first_examination", " first_result", " first__response", "pre_acid", " first__answer", " first_Answer", "first_acid", "first_response", "first___examination"], "first_arrangement": ["first_arrongement", "first_arrangmentation", "first_arrancement", "first_arrongmentation", "first_arranginggment", "first_aranguration", "first_arongment", "first_aranguation", "first_arrancuation", "first_arrangingement", "first_arracment", "first_arranguration", "first_arrancgment", "first_arronggment", "first_aranggment", "first_aronguration", "first_aronguation", "first_arranguation", "first_arronguration", "first_arangement", "first_arrangingment", "first_arronguation", "first_arangmentation", "first_aronggment", "first_arongmentation", "first_arracuration", "first_arangment", "first_arraguration", "first_arragmentation", "first_arragement", "first_arrangment", "first_arrongment", "first_arragment", "first_arranggment", "first_arracement", "first_arranginguation", "first_arongement", "first_arracmentation", "first_arrancment"], "x": ["p", "_", "ph", "id", "ix", "ax", "col", "pe", "xf", "index", "d", "ex", "l", "X", "f", "wx", "xa", "c", "e", "code", "num", "xi", "ga", "ic", "xc", "xy", "v", "xp", "ip", "u", "xx", "page", "n", "word"], "second_answer": ["secondLsquare", "second_question", "second_square", "second_Answer", "secondary_Answer", "second_eni", "secondary_answer", "secondary_eni", "secondLquestion", "secondary_question", "secondLAnswer", "secondLanswer", "secondary_square"], "second_arrangement": ["second_arrangignment", "second_arrongignment", "second_arongignment", "second_aronggment", "second_arrrangament", "second_arangament", "second_arrongament", "second_arongment", "second_arongament", "second_arronggment", "second_arranggment", "second_arrrangements", "second_arrangeement", "second_aranggment", "second_arrandignment", "second_arongement", "second_arrandment", "second_arrongement", "second_arrandgment", "second_arangement", "second_arrrangement", "second_arrandement", "second_arrongements", "second_arangignment", "second_arrandament", "second_arongements", "second_arrandements", "second_arangements", "second_arrrangment", "second_arrangeignment", "second_arrangament", "second_arrangment", "second_arrongment", "second_arrangements", "second_arangment", "second_arrangegment"]}}
{"code": " if len(sys.argv) == 1:\\n      sys.stdin = open(\"C.in\")\\n  else:\\n      sys.stdin = open(sys.argv[1])\\n  \\n  def to_ints(s):\\n      return map(int, s.split())\\n  \\n  def get_ints():\\n      return to_ints(raw_input())\\n  \\n  sys.setrecursionlimit(4000)\\n  \\n  def fill(rows, cols, mines):\\n      seen = set()\\n      visited = set()\\n  \\n      def search(numbered, zeros, min_numbered):\\n          left = (rows * cols - mines) - len(numbered)\\n          if left == 0:\\n              raise StopIteration((numbered, zeros))\\n          if left < 0:\\n              return\\n          for n in xrange(min_numbered, len(numbered)):\\n              number = numbered[n]\\n              if number in zeros:\\n                  continue\\n              row, col = number\\n              neigh = []\\n              if row > 0:\\n                  if col > 0: neigh.append((row - 1, col - 1))\\n                  neigh.append((row - 1, col))\\n                  if col < cols - 1: neigh.append((row - 1, col + 1))\\n              if col > 0: neigh.append((row, col - 1))\\n              if col < cols - 1: neigh.append((row, col + 1))\\n              if row < rows - 1:\\n                  if col > 0: neigh.append((row + 1, col - 1))\\n                  neigh.append((row + 1, col))\\n                  if col < cols - 1: neigh.append((row + 1, col + 1))\\n              neigh = list(set(neigh) - set(numbered))\\n              zeros.add(number)\\n              search(numbered + neigh, zeros, n + 1)\\n              zeros.remove(number)\\n  \\n      try:\\n          for row in xrange(rows):\\n              for col in xrange(cols):\\n                  search([(row, col)], set(), 0)\\n      except StopIteration, e:\\n          numbered, zeros = e.message\\n          board = {}\\n          for row, col in numbered + list(zeros):\\n              board[row, col] = '.'\\n          if zeros:\\n              board[zeros.pop()] = 'c'\\n          else: # case where first click is on a number\\n              board[0, 0] = 'c'\\n          out = ''\\n          for row in xrange(rows):\\n              for col in xrange(cols):\\n                  out += board.get((row, col), '*')\\n              out += '\\n'\\n          return out.strip()\\n      return 'Impossible'\\n  \\n  n_cases = input()\\n  for case in xrange(1, n_cases + 1):\\n      rows, cols, mines = get_ints()\\n  \\n      result = fill(rows, cols, mines)\\n  \\n      print \"Case #%d:\" % case\\n      print result\\n", "substitutes": {"sys": ["p", "parse", "py", "sim", "hw", "process", "run", "std", "shell", "machine", "system", "python", "gui", "func", "np", "ll", "console", "host", "c", "scan", "site", "parser", "util", "lib", "cache", "os", "win", "socket", "linux", "proc", "self", "module", "wp", "input", "Sys", "fs", "auto", "tty", "script", "server", "ys", "sync", "exec", "kernel", "call", "er", "cs", "net", "pc", "mac"], "stdin": ["stdsin", "stout", "STDins", "STDin", " STDin", " stdsin", " STDsin", " stddin", "stin", "STDout", "stins", "stdins", "stdout", "stddin", " STDout", " stdins", "STDsin", " stdout", " STDins", "STDdin"], "s": ["p", "o", "array", "sq", "ls", "S", "ss", "sb", "su", "m", "d", "second", "strings", "l", "f", "c", "str", "e", "ssl", "r", "services", "a", "w", "g", "sg", "b", "v", "string", "sf", "sv", "sl", "si", "source"], "rows": ["rown", "tests", "rooms", "features", "files", "runs", "lines", "users", "ips", "ins", "opens", "x", "fields", "times", "ids", "locks", "boards", "levels", "ries", "xes", "items", "flows", "views", "checks", "values", "ows", "frames", "keys", "sels", "sections", "cats", "holes", "blocks", "groups", "xs", "ks", "vers", "thumbnails", "boxes", "orders", "months", "cells", "balls", "ports", "heads", "words", "planes", "tracks", "grades", "rs", "shows", "rings", "cases", "pages"], "cols": ["columns", "keepn", "colgs", "columnes", " colports", "Coln", "Cols", "collgs", "columnp", " Colses", " colops", " colp", "colls", " Cols", "columnrows", "columnses", "columnions", "collops", "Coli", " coles", " Coles", "colports", "roundops", "colops", "columni", "rounds", "columnn", "coles", "Coles", "colc", " Coli", "colions", "coln", " colgs", " coln", "colses", "keepes", " coli", "keeps", "roundgs", " colses", "collports", "roundports", "Colp", "Colions", "Colrows", "columnc", "Colc", "coli", "keepc", " colions", "colrows", "colp", " colrows"], "mines": ["tunions", "Mins", "Minists", "tunes", "ninenses", "Minions", "Minenses", "mins", "coles", "mineds", "tuneds", "colions", "minions", "colists", "tunenses", " minions", "nineds", "minenses", "minists", "Mines", " minists", "nines", " mins", "ninions", "Mineds"], "seen": ["killed", "connected", "sent", "expected", "shown", "missing", "confirmed", "found", "given", "changed", "visible", "used", "ordered", "known", "started", "see", "selected", "lost", "registered", "hidden", " unseen", "kept", "master", "generated", "finished", "written", "received", "served"], "visited": ["visenced", "navenced", "navited", "navorted", "navized", "versionited", "versionized", "versionenced", "visized", "expized", "expenced", "versionorted", "exported", "visorted", "expited"], "numbered": ["meaning", "steps", "encrypted", "drawn", "index", "layout", "player", "en", "pointer", "inner", "won", "initialized", "initial", "length", "sized", "winner", "generated", "zero", "locked", "total", "issued", "done", "colored", "filled", "umbered", "address", "multi", "interrupted", "shown", "shaped", "given", "member", "limited", "signed", "rawn", "lined", "sequence", "kk", "joined", "loaded", "padding", "written", "matched", "identified", "collection", "blocking", "starting", "lines", "config", "specified", "log", "later", "que", "printed", "modified", "meter", "running", "below", "ln", "none", "num", "nil", "partial", "started", "occupied", "blocks", "uno", "balls", "line", "original", "named", "loader", "coll", "rown", "iter", "found", "mentioned", "series", "umbers", "provided", "ordered", "nor", "aligned", "made", "even", "selected", "runner", "ned", "design", "complete", "string", "received"], "zeros": ["zerbos", "persoos", "zerols", "logos", "demons", "eros", "zeoids", "zos", "zersoes", "zeos", "zersbos", "zybos", "zero", "demo", "zOS", "zons", "demoes", "economos", "erues", "zeo", "zerops", "logoos", "zyol", "zors", "persbos", "zerues", "erors", "zedo", "econombos", "zersoids", "zyoids", "zedons", "bios", "erops", "logols", "ero", "zedops", "logbos", "zersros", "zedos", "zeoes", "economoes", "zros", "economops", "demros", "zeroids", "zeol", "bions", "zeroos", "zoes", "zersols", "zerons", "zersOS", "zersoos", "zersos", "zerol", "zerros", "persos", "zersors", "zedOS", "zues", "zeroes", "erons", "zo", "zedoes", "bioes", "zyos", "zerOS", "zebos", "zersons", "demops", "bio", "zerso", "zersops", "zeops", "persols", "demos", "eroes", "zerors", "zersol", "zops", "zersues"], "min_numbered": ["min_colored", "min_sized", " min_colored", "len_number", "len_colored", "len_sized", " min_drawn", "min_drawn", "len_numbered", "min_number"], "left": ["pl", "p", "offset", "li", "label", "lc", "index", "Left", "len", "null", "d", "l", "counter", "found", "position", "right", "hide", "flo", "cost", "inner", "ell", "ln", "fl", "none", "used", "nl", "two", "empty", "ner", "partial", "roll", "cell", "leave", "cle", "initial", "size", "cl", "low", "last", "length", "small", "min", "diff", "pos", "zero", "loc", "le", "ne", "lo", "coll"], "n": ["p", "o", "nin", "sn", "nc", "na", "len", "index", "m", "nb", "ns", "pn", "nn", "d", "x", "un", "nan", "l", "f", "count", "c", "e", "ln", "no", "num", "i", "nor", "k", "z", "nt", "r", "nw", "network", "size", "w", "non", "j", " c", "nd", "b", "u", "N", "ne"], "number": ["rown", "node", "square", "div", "word", "address", "label", "group", "month", "index", "version", "range", "name", "null", "nn", "x", "un", "counter", "count", "position", "umber", "nr", "member", "c", "no", "none", "num", "two", "even", "note", "r", "initial", "value", "size", "phone", "mult", "column", "work", "non", "length", "object", "b", "line", "Number", "zero", "string", "N", "page", "block", "result", "total", "error", "letter", "coll"], "row": ["rown", "box", "ver", "node", "ow", "user", "group", "tr", "rank", "month", "index", "range", "rc", "entry", "view", "name", "order", "ro", "head", "x", "step", "record", "port", "family", "position", "right", "c", "ry", "keep", "chrom", "ack", "ward", "key", "num", "ull", "ug", "rr", "ew", "year", "rect", "post", "round", "roll", "cell", "rh", "rot", "r", "arch", "arrow", "value", "column", "co", "length", "Row", "line", "model", "rid", "loc", "rw", "page", "feed", "block", "pull", "sel", "cur", "coll", "zip"], "col": ["div", "ch", "poly", "lc", "path", "icol", "index", "cel", "ll", "y", "day", "ell", "key", "year", "nt", "con", "cm", "fact", "length", "ill", "min", "char", "page", "sel", "cy", "cal", "pl", "cor", "nc", "ind", "fn", "c", "pol", "win", "fc", "roll", "sec", " column", "column", "ol", "pos", "int", "ct", "il", "p", "Col", "long", "log", "file", "near", "f", "count", "inc", "fl", "num", "el", "rot", "rel", "cell", "cl", "COL", "line", "loc", "ne", "lo", "word", "coll", "zip", "ref", "child", "val", " Col", "ail", "x", "cp", "keep", "byn", "cond", "round", "cat", "cycle", "co", "field", "block", "oy", "fil", "cur"], "neigh": ["naoph", "naalth", "neighth", "seuth", "noph", " neux", "nail", "noteig", "meighth", "nighth", "NEir", "geighth", "nechel", "pseuth", "Nealth", " neque", "seagle", "noteeks", "neux", "nchel", " nechel", "anneigh", "noteque", "pseigh", " neighth", "noteighth", "naight", " nealth", "noteigh", "neuth", "neoph", "neisen", "nachel", "naigh", " neagle", "pseig", " kneoph", "unealth", "unechel", "nalth", "pseoph", "naeks", "Neigh", "NEalth", "nyih", " neig", "night", "neil", "nig", " neir", "nigh", "neir", "beil", "nyigh", "naighth", "neig", "neque", "naque", "enneigh", "neeks", "enneig", " neoph", "notealth", " neuth", "NEigh", "gealth", "neight", " knealth", "nair", "neagle", "uneibling", "bealth", "seoph", "geoph", "enneight", "neibling", "seigh", "geigh", " kneigh", "seig", "nyalth", "naih", "nagle", "annealth", "mechel", "Neoph", "pseagle", " kneisen", "beih", "NEagle", "Neisen", " neibling", "ennealth", " neisen", "anneibling", "annechel", "beigh", "meoph", "geux", "nyil", "naig", "nealth", "meigh", "uneigh", "geig", "pseighth", "nux", "seighth", "neih", "naagle", " neeks"], "board": ["box", "conference", "la", "comment", "list", " clipboard", "group", "deck", "holder", "path", "layout", "league", "view", "loop", "channel", "stream", " boards", "bird", "menu", "card", "foot", "boards", "flo", "room", "table", "code", "bo", "chain", "book", "form", "game", "hole", "control", "sequence", "Board", "cart", "phone", "bar", "buffer", "object", "flow", "model", "land", "store", "bank", "feed", "block", "bug", "error", "coll"], "pop": ["highest", "drop", "op", "reverse", "crop", "Pop", "head", "stack", "clone", "shift", "peak", "delete", "back", "prev", "pick", "fork", "top", "remove", "flush", "last", "first", "high", "pull", "clear", "bottom", "close", "push", "tail"]}}
{"code": " if len(sys.argv) == 1:\\n      sys.stdin = open(\"A.in\")\\n  else:\\n      sys.stdin = open(sys.argv[1])\\n  \\n  def to_ints(s):\\n      return map(int, s.split())\\n  \\n  def get_ints():\\n      return to_ints(raw_input())\\n  \\n  n_cases = input()\\n  \\n  for case in xrange(1, n_cases + 1):\\n      a_row, = get_ints()\\n      a_layout = [get_ints() for _ in range(4)]\\n      b_row, = get_ints()\\n      b_layout = [get_ints() for _ in range(4)]\\n  \\n      poss = set(a_layout[a_row - 1])\\n      poss.intersection_update(b_layout[b_row - 1])\\n  \\n      result = 'Bad magician!'\\n  \\n      if len(poss) == 0:\\n          result = 'Volunteer cheated!'\\n      elif len(poss) == 1:\\n          result = poss.pop()\\n  \\n      print \"Case #%d: %s\" % (case, result)\\n", "substitutes": {"sys": ["parse", "py", "sim", "hw", "user", "process", "so", "sb", "run", "std", "math", "shell", "machine", "system", "python", "gui", "np", "ll", "host", "util", "os", "win", "linux", "proc", "self", "pkg", "module", "wp", "input", "mac", "Sys", "window", "fs", "script", "server", "ys", "exec", "kernel", "call", "int", "cs", "net", "windows", "site"], "stdin": ["builtins", "stout", "STDins", "stdinc", "STDin", " stddin", " stdinc", "stin", "STDout", "stins", "stdins", "stdout", "builtout", "builtinc", "stddin", " stdins", " stdout", "builtin", "STDinc", "STDdin"], "s": ["p", "o", "array", "sq", "ls", "S", "ss", "sb", "su", "m", "d", "second", "strings", "l", "f", "c", "e", "args", "ssl", "i", "r", "services", "a", "w", "g", "sg", "b", "v", "sync", "string", "sf", "sl", "si", "source"], "n_cases": ["nxcases", "nnumsections", "nnumcells", "nnumrows", "nxcells", "n_lines", " n_sections", "nnumcases", "n_cells", " n_rows", "nxlines", "n_sections", " n_lines", "nxrows", " n_cells", "n_rows"], "case": [" x", " example", "se", " line", "address", "ide", " sub", "catch", " cases", "sea", "ice", " feat", "space", "x", "slice", "base", " code", " loop", "count", " me", "c", "ace", "core", "client", "code", " u", " position", "i", "mode", "ce", "trial", "match", " num", "chance", " seq", " p", " c", "bc", "length", "Case", " id", "instance", " d", " count", " CASE", " Case", "ase", "race", "bug", "section", "test", " fe", "cases"], "a_row": ["a_col", " a_col", " a_entry", "a_entry", "a_rows", " a_rows"], "a_layout": ["a_col", "b_col", "b_style", "b_shape", "b_layer", "b_position", "a_shape", "a_position", "a_layer", "a_style"], "_": ["p", "all", "val", "m", "d", "x", "un", "en", "f", "al", "a", "non", "ning", "ing", "flow", "line", "ip", "block", "n", "ed"], "b_row": ["b_cell", "b__layout", "bkrow", "bklayout", "b_col", "b_range", " b_range", " b_cell", "b__row", "b__range", "b__col", " b_col", "bkcol", "bkcell"], "b_layout": ["b_section", "a_section", "b_range", "b_position", "a_range", "a_position"], "poss": ["Powers", " pense", "Passes", "Pobs", "Poses", "pose", "Pss", "lpasses", "powers", "pore", " pore", "spore", "exposs", "lpense", " pobs", "ppos", "expobs", "expss", " pss", "boss", " ppos", "POSS", "Pense", "bens", "poses", " poses", "expOSS", "toses", "lppos", "tOSS", " posit", "apass", "tpos", "toss", " pens", "spass", "pens", "Posit", " passes", "aposs", "pense", "pss", "pOSS", "pobs", " pOSS", "Pens", "passes", "spose", "Ppos", "lposs", "bowers", "posit", "apore", " pose", " powers", "apose", "sposs", "Poss", "bosit"], "result": ["err", "date", "response", "comment", "res", "main", "valid", "score", "report", "catch", "rc", "our", "name", "su", "success", "grade", "msg", "step", "message", "default", "successful", "data", "answer", "reason", "final", "ret", "status", "description", "notice", "r", "match", "cash", "summary", "warning", "runner", "Result", "term", "root", "diff", "compl", "effect", "page", "cup", "error", "test", "results", "source"]}}
{"code": " \\n  NEIGHBOURS = [\\n      (-1, -1), (-1, 0), (-1, 1),\\n      ( 0, -1),          ( 0, 1),\\n      ( 1, -1), ( 1, 0), ( 1, 1),\\n  ]\\n  \\n  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n  \\n  def valid(size, location, changes):\\n      y, x = location\\n      for y1, x1 in changes:\\n          y1 += y\\n          x1 += x\\n          if y1 < 0 or y1 >= size[0]:\\n              continue\\n          if x1 < 0 or x1 >= size[1]:\\n              continue\\n          yield (y1, x1)\\n  \\n  def click(size, grid, location):\\n      y, x = location\\n      if grid[y][x] is 0:\\n          return None\\n  \\n      grid = [row[:] for row in grid]\\n      grid[y][x] = 0\\n  \\n      for y, x in valid(size, location, NEIGHBOURS):\\n          if grid[y][x]:\\n              grid[y][x] = False\\n  \\n      return grid\\n  \\n  def sweep(R, C, M):\\n      grid = [[True] * C for _ in range(R)]\\n      size = (R, C)\\n  \\n      if M + 1 == R * C:\\n          grid[0][0] = False\\n          return grid, (0, 0)\\n  \\n      states = []\\n      for y in range(R):\\n          for x in range(C):\\n              location = (y, x)\\n              states.append((click(size, grid, location), location))\\n  \\n      while states:\\n          grid, location = states.pop(0)\\n  \\n          mines_count = sum([sum(row) for row in grid])\\n          if mines_count == M:\\n              return grid, location\\n  \\n          if mines_count < M:\\n              continue\\n  \\n          for new_location in valid(size, location, NEIGHBOURS):\\n              new_grid = click(size, grid, new_location)\\n              if new_grid:\\n                  states.insert(0, (new_grid, new_location))\\n  \\n      return None\\n  \\n  def validate(size, grid, location):\\n  \\n      result = [row[:] for row in grid]\\n  \\n      y, x = location\\n      result[y][x] = sum([\\n          grid[y1][x1]\\n          for y1, x1 in valid(size, (y, x), NEIGHBOURS)\\n      ])\\n      assert result[y][x] == 0\\n  \\n      seen = set([location])\\n      locations = set([location])\\n  \\n      while locations:\\n          location = locations.pop()\\n          for y, x in valid(size, location, NEIGHBOURS):\\n              assert grid[y][x] is not True\\n              result[y][x] = sum([\\n                  grid[y1][x1]\\n                  for y1, x1 in valid(size, (y, x), NEIGHBOURS)\\n              ])\\n              if result[y][x] == 0 and (y, x) not in seen:\\n                  locations.add((y, x))\\n                  seen.add((y, x))\\n  \\n      for row in result:\\n          for col in row:\\n              assert col is not False\\n  \\n      for y, row in enumerate(result):\\n          output = ''\\n          for x, col in enumerate(row):\\n              if col is True:\\n                  output += '*'\\n              else:\\n                  output += str(col)\\n          print output\\n  \\n  \\n  def process(case, R, C, M):\\n      result = sweep(R, C, M)\\n  \\n      print 'Case #%d:' % (case + 1)\\n      if not result:\\n          print 'Impossible'\\n          return\\n  \\n      grid, location = result\\n      for y, row in enumerate(grid):\\n          output = ''\\n          for x, col in enumerate(row):\\n              if (y, x) == location:\\n                  output += 'c'\\n              elif col:\\n                  output += '*'\\n              else:\\n                  output += '.'\\n          print output\\n  \\n  \\n  \\n  def main():\\n      cases = int(sys.stdin.readline())\\n  \\n      for case in range(cases):\\n          R, C, M = map(int, sys.stdin.readline().split())\\n          process(case, R, C, M)\\n  \\n      return\\n      for case in range(100):\\n          R = random.randrange(51) + 1\\n          C = random.randrange(51) + 1\\n          M = random.randrange(R * C - 1) + 1\\n          process(case * 100000 + M - 1, R, C, M)\\n  \\n  \\n  if __name__ == '__main__':\\n      main()\\n", "substitutes": {"NEIGHBOURS": ["NEIGHEBOURS", "NEIGHBouRT", "NEIGHBOUNPS", "NEIGHEBOUrs", "NEIGHBOPLERT", "NEIGHBOOLS", "NEIGHEBouRT", "NEIGHBOPLEPS", "NEIGHBOWrs", "NEIGHBOUDS", "NEIGHBHOUPS", "NEIGHBOUNDS", "NEIGHBOPLERS", "NEIGHBouPS", "NEIGHNBOULS", "NEIGHNBOODS", "NEIGHBOULS", "NEIGHBOUTRS", "NEIGHBOPLErs", "NEIGHBOUTS", "NEIGHNBOORS", "NEIGHBHOUDS", "NEIGHEBOUTTS", "NEIGHEBOUTrs", "NEIGHEBOUTS", "NEIGHBOUrs", "NEIGHBouTS", "NEIGHNBOUDS", "NEIGHBOUNRS", "NEIGHNBOOPS", "NEIGHEBouPS", "NEIGHBOUTTS", "NEIGHNBOUPS", "NEIGHBOOTS", "NEIGHBHOURS", "NEIGHBOODS", "NEIGHBOWRS", "NEIGHEBOURT", "NEIGHEBours", "NEIGHNBOURS", "NEIGHBOOPS", "NEIGHEBOUTRS", "NEIGHEBOUTPS", "NEIGHNBOOLS", "NEIGHBOUTPS", "NEIGHEBouRS", "NEIGHBours", "NEIGHBOUTrs", "NEIGHBOWRT", "NEIGHBHOULS", "NEIGHBOUNLS", "NEIGHBOORS", "NEIGHBOUPS", "NEIGHEBOUPS", "NEIGHBOOrs", "NEIGHBOURT", "NEIGHBOWPS", "NEIGHBouRS"], "MOVES": ["MOUSes", "MATCHES", "MOVED", "MOUSED", "MATCHING", "MOVes", "MARKED", "MOVING", "MATCHes", " MOUSes", " MOUSES", " MOUSED", "MARKes", "MARKING", " MOUSING", "MOUSES", "MOUSING", " MOVING", " MOVes", "MARKES", " MOVED", "MATCHED"], "size": ["unit", "region", "name", "speed", "time", "scene", "grade", "position", "area", "day", "scale", "code", "uri", "draw", "year", "shape", "z", "cm", "sized", "Size", "general", "capacity", "action", "style", "ui", "address", "engine", "zone", "export", "width", "m", "example", "external", "core", "c", "member", "form", "mode", "ng", "SIZE", "sample", "Y", "remote", "security", "ci", "function", "count", "city", "edge", "activity", "state", "chain", "status", "ize", "six", "course", "small", "sync", "content", "loc", "si", "square", "center", "connection", "cache", "empty", "large", "settings", "sum", "storage", "model", "string", "south", "source", "site"], "location": ["response", "node", "LOC", "command", "image", "unit", "language", "region", "lc", "division", "layout", "range", "event", "Location", "entry", "feature", "position", "area", "community", "directory", "uri", "draw", "shape", "network", "length", "generation", "operation", "local", "slice", "home", "address", "m", "c", "member", "i", "mode", "description", "module", "selection", "auto", "Y", "instance", "gallery", "remote", "moving", "station", "layer", "definition", "filename", "collection", "function", "origin", "d", "X", "message", "state", "cell", "density", "content", "loc", "direction", "section", "error", "folder", "box", "new", "place", "center", "ion", "null", "success", "L", "point", "l", "connection", "site", "localhost", "population", "move", "g", "storage", "model", "south", "activity"], "changes": ["steps", "maps", "features", "images", "files", "lines", "errors", "details", "codes", "works", "marks", " moves", "actions", "fields", "changed", "breaks", "items", "events", "values", "status", "objects", "rows", "shape", "history", "dates", "Changes", "places", "xs", "settings", "boxes", "cells", "diff", "comments", "content", "moving", "grades", "results", "change"], "y": ["ix", "ch", "sy", "yx", "h", "story", "area", "key", "year", "yd", "uy", "z", "w", "yl", "ory", "xy", "v", "cy", "service", "id", "height", "hy", "m", "c", "yt", "ym", "ady", "yi", "i", "module", "gy", "Y", "yn", "n", "p", "ci", "py", "sim", "d", "yo", "dy", "f", "client", "e", "t", "country", "yp", "hub", "j", "ys", "my", "loc", "sky", "yy", "yr", "o", "yang", "q", "ye", "ay", "ny", "ya", "vy", "ry", "game", "type", "r", "ey", "b", "zy", "oy"], "x": ["image", "ix", "ax", "yx", "index", "event", "name", "ice", "time", "h", "xa", "ex", "position", "key", "xi", "z", "wa", "w", "yl", "xy", "v", "u", "xml", "sex", "xb", "cross", "cy", "id", "xxx", "view", "width", "m", "example", "c", "ady", "i", "ng", "xc", "Y", "rx", "column", "xp", "pos", "act", "n", "int", "ct", "exp", "p", "na", "X", "f", "wx", "host", "e", "t", "px", "xe", "xs", "work", "create", "im", "j", "cl", "my", "content", "loc", "xx", "dx", "xf", "q", "ay", "xt", "ya", "l", "r", "change"], "y1": ["y3", "ry4", " y81", "yOne", "ry3", "ry2", "y4", "Y1", "vy1", " y0", "Y0", " y3", "vyOne", "Y4", "ey1", "x0", "vy2", "ya81", " y4", "ya1", " yed", " y01", "Y3", "Yed", "x2", "ey01", " yOne", "y01", "yed", " y2", "y2", "y0", "vy81", "ya01", "ey81", "y81", "yaOne", "x81", "Y2", "xed", "ry1", "xOne", "ya0", "ya2"], "x1": ["y3", "xx1", " x0", "x10", "zone", "xiOne", "xx3", "x0", "xi1", "X1", "x3", " x10", " xOne", "X\n", "z81", "x2", " yOne", "xt1", "xone", "y10", " xone", " x2", " y2", "xt0", "y2", " x81", "y0", "z10", "xt2", "xtone", "xi2", "y81", "z2", "x81", "xOne", "z1", "z0", "yone", "X3"], "grid": ["image", "unit", "node", "query", "div", "main", "all", " grids", "layout", "range", "details", "gr", "domain", "grade", "parent", "cfg", "default", "scale", "code", "frame", "draw", "debug", "age", "uri", "route", "network", "cm", "general", "gru", "page", "ed", "bug", "hold", "address", "export", "db", "multi", "lock", "ace", "data", "back", "form", "plugin", "module", "window", "column", "mid", "flow", "gallery", "cum", "remote", "station", "layer", "security", "tile", "active", "sim", "valid", "config", "file", "function", "Grid", "message", "update", "edge", "client", "gate", "state", "chain", "num", "status", "graph", "cell", "cart", "input", "line", "sync", " Grid", "gap", "dim", "content", "house", "new", "square", "contact", "link", "group", "gui", "scope", "point", "connection", "site", "rule", "cache", "game", "move", "cube", "static", "g", "sum", "storage", "server", "model", "cells", "block", "feed", "activity"], "row": ["element", "box", "up", "image", "query", "node", "link", "user", "group", "month", "range", "entry", "view", "order", "ro", "container", "build", "record", "port", "area", "day", "client", "scale", "ward", "state", "key", "form", "frame", "status", "wheel", "rows", "year", "post", "round", "roll", "cell", "module", "r", "arrow", "column", "way", "co", "device", "field", "Row", "flow", "server", "line", "model", "zero", "page", "feed", "bug", "block", "item", "error", "oy", "week"], "R": ["P", "O", "Cr", "CR", "A", "S", "JR", "B", "MR", "RA", "T", "RE", "L", "RR", "F", "X", "K", "ER", "RW", "Rs", "E", "NR", "RH", "DR", "RO", "TR", "D", "r", "Rh", "U", "Y", "GR", "RS", "H", "V", "RG", "Q", "N", "SR", "RM"], "C": ["CC", "Z", "P", "O", "A", "CR", "CS", "S", "B", "CI", "T", "DC", "L", "CL", "CM", "AC", "X", "F", "K", "I", "c", "CU", "E", "CN", "D", "G", "EC", "U", "Y", "V", "H", "CP", "Cu", "Size", "Q", "W", "N", "CE"], "M": ["P", "O", "LM", "A", "S", "MN", "B", "T", "m", "J", "L", "CM", "F", "X", "K", "I", "E", "SM", "D", "G", "MS", "r", "MC", "U", "Y", "V", "H", "MT", "Q", "NM", "W", "N", "RM"], "_": ["p", "new", "cc", "oc", "q", "X", "f", "ck", "Y", "j", "ac"], "states": ["steps", "features", "images", "files", "active", "runs", "lines", "reports", "relations", "plugins", "errors", "details", "powers", "ins", "works", "jobs", "strings", "actions", "modules", "ids", "States", "locks", "plays", "points", "args", "state", "gs", "items", "models", "flows", "events", "rates", "sites", "status", "rows", "keys", "rules", "stats", "sections", "services", "ages", "blocks", "groups", "parts", "settings", "s", "storage", "charges", "cells", "ports", "south", "uses", "results", "chains", "stores"], "mines_count": ["mines_len", "mines_child", "minES_count", "minises_count", "minises_Count", "minesh_count", "mines_code", "mines_sum", "mines_dist", "minesh_dist", "minesh_child", "minises_len", "mines_Count", "minES_code", "minES_sum"], "new_location": ["new67location", " new_site", "new67address", "new_module", " new_position", "newJmodule", " new_address", "New_loc", "new_loc", "new_position", "New_position", "new_address", "newJlocation", "new67loc", "new_region", "new_site", "New_location", "newJaddress", " new_module", " new_loc", "New_region", "new67module", "newJloc"], "new_grid": ["newsstate", "new_storage", " new_state", "newjlocation", "newnetvolume", "new_media", "New_row", "newnetgrid", " new_volume", "newjmodule", "new_module", "new_volume", "New_media", "New_state", "newsstorage", "New_grid", " new_storage", "newjgrid", "newjstate", "new_row", "new_state", "newsvolume", " new_module", "newnetstorage", "newnetstate", "newsgrid"], "result": ["err", "response", "new", "res", "group", "range", "report", "function", "product", "success", "found", "search", "done", "default", "data", "table", "dist", "final", "status", " Result", "r", "match", "Result", "sum", "root", "diff", "master", "complete", "content", "now", "page", "progress", "test", "results", "source"]}}
{"code": " \\n  \\n  def main():\\n      cases = int(sys.stdin.readline())\\n  \\n      for case in range(cases):\\n          row1 = int(sys.stdin.readline())\\n          arrangement1 = [\\n              map(int, sys.stdin.readline().split())\\n              for _ in range(4)\\n          ]\\n          chosen1 = set(arrangement1[row1 - 1])\\n  \\n          row2 = int(sys.stdin.readline())\\n          arrangement2 = [\\n              map(int, sys.stdin.readline().split())\\n              for _ in range(4)\\n          ]\\n          chosen2 = set(arrangement2[row2 - 1])\\n  \\n          chosen = chosen1 & chosen2\\n  \\n          if not chosen:\\n              print 'Case #%d: Volunteer cheated!' % (case + 1)\\n          elif len(chosen) != 1:\\n              print 'Case #%d: Bad magician!' % (case + 1)\\n          else:\\n              print 'Case #%d: %d' % (case + 1, chosen.pop())\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "substitutes": {"cases": ["tests", "steps", "features", "rooms", "ls", "runs", "lines", "classes", "pieces", "ches", "details", "tips", "times", "count", "c", "cycles", "events", "ends", "values", "trial", "rows", "shape", "sections", "types", "blocks", "groups", "size", "settings", "length", "its", "Case", "cells", "comments", "changes", "days", "loc", "ase", "shows", "test", "section", "chains"], "case": ["se", "id", "address", "hyp", "division", "path", "config", "catch", "month", "sea", "name", "ice", "order", "time", "space", "x", " i", "step", "count", "connection", "character", "c", "position", "ace", "client", "uc", "default", "code", "no", "condition", "key", "i", "trial", "shape", "set", "type", "match", "size", "length", "row", "Case", "instance", "line", "bug", "test", "section", "patch", "slice"], "row1": ["rowOne", "row3", "col3", "col2", "colFirst", "bugFirst", "rowD", "serverD", "serverFirst", "colD", "bug2", " rowOne", "caseOne", "case2", "server1", "col1", "server2", "case1", "case3", "colOne", "bug1", "rowFirst", "bugD", " row3"], "arrangement1": ["arrangationOne", "arrangmentA", "arrangation81", "arrongement2", "arrangements81", "arrangement0", "arrongement1", "arrangment1", "arrongment2", "arrangeement1", "arrangament1", "arranglementA", "arrangment2", "arrangements2", "arrangeementOne", "arrangamentA", "arrangament0", "arranglement0", "arrangeements1", "arranglement2", "arrangeementsOne", "arrangementsOne", "arrongementA", "arrangeement2", "arrangament2", "arrangmentOne", "arrangementOne", "arrangeements81", "arrangement81", "arrangment81", "arrongment0", "arrongmentA", "arrangements1", "arrangeement81", "arrangation2", "arrangeements2", "arrangation1", "arrangementA", "arrongement0", "arrangment0", "arranglement1", "arrongment1"], "_": ["p", "all", "val", "place", "m", "time", "ay", "d", "x", "un", "out", "f", "count", "get", "c", "__", "k", "a", "non", "g", "s", "ing", "ip", "block", "n", "ac"], "chosen1": ["chosenone", "choin01", "choosed2", "choren1", "choren0", "choin1", "choinOne", "anchoin1", "choosed01", "choren2", "choosen01", "anchosenOne", "choin0", "chosed2", "choinone", "choosen0", "anchosen3", "choosen2", "choren01", "choosed1", "chosingone", "anchosen1", "anchoinone", "anchoin3", "chosing1", "choin3", "chosen3", "chosedOne", "chosedone", "choin2", "chosed01", "anchoinOne", "choosed0", "anchosenone", "chosed1", "chosed3", "chosed0", "chosen0", "choosen1", "chosingOne", "chosenOne", "chosen01", "chosing3"], "row2": ["ry2", "rank02", "ry02", "ranksecond", "rowsecond", "owTwo", "rankTwo", "ry22", "row02", "blocksecond", " row62", " row22", "block2", "rank22", "rankSecond", "row22", "ow2", "rank2", "owsecond", "blockSecond", "rowSecond", "rowTwo", " row02", "rank62", "blockTwo", "ry62", "row62", "owSecond"], "arrangement2": ["arrangEMENT2", "arrongement2", "arrangEMENT4", "arrangEMENT3", "arranguation4", "arrangement0", "arrangements4", "arrongement1", "arrangment1", "arrongment2", "arrangment2", "arrangements2", "arrongement3", "arranguation0", "arrangment4", "arrangement3", "arrangEMENT0", "arrangEMENT1", "arranguation1", "arrongment4", "arrangment3", "arrongement4", "arrongment0", "arrongment3", "arrangement4", "arrangements1", "arrangements3", "arrongement0", "arranguation2", "arrangment0", "arrongment1"], "chosen2": ["cherntwo", "cheosen2", "chosed02", "chonne02", "chonne2", " chosentwo", "chosen4", "chown2", "choser3", "cheoser52", "chosed2", "chosed4", "chonnetwo", "choser1", " chonne2", "cheosen52", "chern2", "cheoser1", "chosedtwo", " chonne4", "chern4", "chown1", "chown3", "choser52", "cheosen1", "chosen3", "chosen02", " chosen02", "chern52", "cheosen3", "chern3", " chonne02", "chosentwo", "cheoser2", " chonnetwo", " chosen4", "chern1", "choser2", "chown52", "chonne4", "chern02", "chosen52", "cheoser3"], "chosen": ["chnoin", "chuc", " choin", "Chitched", "Choin", " chuc", "chaoser", "echoin", "candlied", "choosen", "Chosen", " chitched", " chlied", "chnitched", "chnosen", "cheroin", "chaoren", "CHosing", "chooren", "choin", "candoin", " choren", "chaosen", "cherosen", " choser", "chouc", "echosen", " chosing", "candosen", "cherlied", "chooser", "Choser", "choser", "chlied", "chisson", " chisson", "CHisson", "chnoser", "cheroren", "candoren", "CHoin", "chosing", "CHosen", "echosing", "chauc", "chitched", "echisson", "choren"]}}
{"code": " \\n  T = int(raw_input())\\n  \\n  def generate(R, C, a, sw):\\n      if sw:\\n          R, C = C, R\\n      res = [['*']*C for i in xrange(R)]\\n      for i in xrange(len(a)):\\n          for j in xrange(a[i]):\\n              if sw:\\n                  res[j][i] = '.'\\n              else:\\n                  res[i][j] = '.'\\n      res[0][0] = 'c'\\n      return str(res)[2:-2].replace(' ', '').replace(\"'\",'').replace('[', '').replace('],','\\n').replace(',', '')\\n  \\n  \\n  def solveEq(k, s, x1):\\n      if 2*(x1 + k - 2) > s or k*x1 < s:\\n          return None\\n      r = [0]*k\\n      r[0] = r[1] = x1\\n      s -= 2*x1\\n      for i in xrange(k-2, 0, -1):\\n          t = min(x1, s - 2*i + 2)\\n          r[k-i] = t\\n          s -= t\\n      return r\\n  \\n  def solve(R, C, M):\\n      S = R*C\\n      nm = S - M\\n      if R == 1 or C == 1:\\n          if R == 1:\\n              return '*'*M + '.'*(S-M-1) + 'c'\\n          else:\\n              return '*\\n'*M + '.\\n'*(S-M-1) + 'c'\\n      else:\\n          sw = False\\n          if R > C:\\n              R, C = C, R\\n              sw = True\\n          if nm == 2 or nm == 3 or nm == 5 or nm == 7 or (R == 2 and nm%2 == 1 and nm > 1):\\n              return \"Impossible\"\\n          if nm == 1:\\n              return generate(R, C, [1], sw)\\n          for k in xrange(2, R+1):\\n              for x1 in xrange(2, C+1):\\n                  r = solveEq(k, nm, x1)\\n                  if r != None:\\n                      return generate(R, C, r, sw)\\n          return \"Something wrong\"\\n  \\n  for z in xrange(T):\\n      c, f, x = map(int, raw_input().split())\\n      print \"Case #%d:\\n%s\" % (z+1, solve(c, f, x))\\n", "substitutes": {"T": ["Z", "P", "O", "A", "TT", "TC", "B", "L", "TB", "TM", "F", "X", "K", "I", "TN", "TR", "G", "D", "Y", "V", "H", "N", "W", "Time", "NT"], "R": ["P", "O", "A", "CR", "rb", "KR", "JR", "B", "Ra", "ARR", "MR", "RA", "J", "L", "RR", "Run", "F", "X", "RN", "K", "I", "Tr", "RP", "RW", "Rs", "E", "NR", "RH", "DR", "RO", "TR", "D", "G", "Rh", "U", "Y", "GR", "RS", "V", "H", "RT", "RG", "Q", "Re", "N", "Res", "SR", "W", "RM", "Range"], "C": ["CC", "P", "O", "A", "CR", "SC", "CS", "B", "Cs", "CI", "YC", "Cos", "L", "CL", "DC", "CM", "F", "X", "K", "I", "Sc", "Ch", "CU", "E", "CT", "CN", "NR", "CO", "VC", "D", "NC", "G", "EC", "U", "Y", "CA", "V", "H", "Co", "Cu", "Q", "KC", "W", "N", "CE", "Con"], "a": ["p", "o", "A", "Na", "array", "all", "ra", "aaa", "at", "na", "ar", "ae", "sa", "m", "au", "ai", "am", "alpha", "area", "arr", "e", "args", "aj", "wa", "w", "ab", "b", "u", "ca", "n", "an", "da", "ac", "aa"], "sw": ["switch", "response", "wrap", "ww", "array", "sn", " SW", "ws", "sp", " Sw", "hw", "ow", "cc", "WS", "nc", "est", "sc", "su", "sa", "sm", "null", "stream", "h", "cv", "igh", "wx", "cr", "default", "sk", "RW", "rew", "WR", "sh", "wn", "ng", "tw", "ew", "rh", "wp", "nw", "wh", "wa", "w", "im", "row", "sr", "hop", "sync", "iw", "Sw", "zero", "SW", "W", "rw", "sf", "sl", "oss", "now", "coll", "wt", "zip"], "res": ["err", "ris", "p", "ons", "response", "br", "vals", "runs", "resp", "eps", "rest", "rc", "qs", "q", "gr", "ns", "mr", "resolution", "es", "rss", "cr", "req", "arr", "data", "RES", "pres", "e", "args", "Rs", "rev", "ret", "rem", "os", "rows", "bs", "sol", "rh", "rez", " results", "blocks", "reg", "re", "ms", "remote", "Res", " Res", "rs", "result", "cs", "ras", "results", "rep"], "i": ["p", "o", "iq", "ui", "li", "id", "ci", "ei", "index", "q", "m", "ini", "ji", "d", "ai", "phi", "l", "y", "I", "gi", "ii", "ti", "e", "yi", "zi", "ie", "ik", "xi", "pi", "di", "g", "im", "ij", "mi", "b", "v", "u", "ip", "qi", "n", "si", "io", "int", "iu"], "j": ["p", "o", "br", "li", "ci", "jc", " ii", "q", "jp", "ji", "d", "J", "kj", "ind", "oj", "y", "gi", "l", "ii", "str", "e", "jl", "aj", "ie", "xi", "jj", "je", "ja", "ni", "IJ", "ij", "g", "b", "v", "u", "n", "si", "iu", "uj"], "k": ["p", "o", "_", "it", "uk", "ch", "ko", "q", "m", "d", "h", "max", "y", "l", "K", "ku", "kw", "sk", "key", "ck", "ak", "mk", "ky", "tk", "ok", "ks", "w", "g", "b", "v", "kk", "u", "N", "n", "kin", "ke"], "s": ["p", "o", "sq", "se", "ws", "ls", "ss", "tp", "su", "ts", "m", "ns", "sa", "d", "second", "span", "es", "h", "y", "l", "sk", "e", "gs", "os", "sup", "sec", "sign", "ps", "ks", "xs", "w", "g", "b", "v", "sync", "u", "ms", "ats", "south", "n", "si", "sym", "rs", "cs", "sv", "ds"], "x1": ["Xn", "X2", " x0", "p1", "xn", "xi0", "z4", "x0", "xi1", "X1", " x4", "X4", "xN", "p2", "x2", "xone", "wn", "xione", " xone", " x2", "zN", "f0", "y2", "y0", "p0", "f1", "y1", "XN", "xi2", "Xone", "w1", "z2", " xn", "w2", "z1", "x4", " xN", "X0"], "r": ["err", "p", "o", "P", "rb", "br", "range", "rc", "q", "ar", "m", "mr", "kr", "d", "RR", "h", "l", "cr", "ru", "right", "nr", "fr", "e", "ir", "Rs", "ur", "rr", "nor", "rh", "rt", "rg", "w", "g", "sr", "b", "v", "re", "hr", "u", "pr", "lr", "n", "rs", "er", "result"], "t": ["p", "o", "new", "wt", "at", "tp", "ts", "m", "ot", "d", "h", "target", "l", "y", "ti", "e", "tt", "te", "tf", "ta", "tor", "w", "g", "b", "v", "u", "tm", "n", "test", "total"], "M": ["Mo", "MQ", "Z", "P", "O", "A", "LM", "MN", "B", "Ms", "m", "J", "L", "CM", "F", "X", "I", "K", "DM", "JM", "E", "ME", "D", "G", "MI", "MC", "MD", "U", "Y", "V", "H", "GM", "Q", "NM", "W", "N", "n"], "S": ["P", "O", "A", "SC", "SL", "B", "SE", "US", "L", "F", "X", "SA", "I", "K", "Rs", "E", "SI", "IS", "D", "G", "U", "Y", "Su", "RS", "V", "H", "SU", "Q", "NS", "W", "N", "SR", "Single", "n", "SH", "FS", "SS"], "nm": [" N", "me", " n", "pm", "NW", "mn", "LM", "nu", "all", "range", "CW", "MN", "nc", "mm", "fm", "cn", "nv", "Ms", "m", "ns", "sm", "mr", "nn", "ny", "np", "CM", "arm", "nr", "ym", "bm", "Num", "dm", "NR", "TN", "num", "md", "nl", " NM", "nor", "NC", "nom", "nt", "nw", "ni", "cm", "rn", "mid", "PM", "mi", "NL", "ms", "NM", "NS", "rm", "N", "Ns", "km", "n", "RM", "ne", "wm", "NT"], "z": ["Z", "o", "p", "q", "time", " o", "d", "h", "y", "tz", "ti", "e", "temp", " w", "zi", "ze", "ta", " y", " Z", "nz", "Y", "w", "b", " ti", "u", "iz"], "c": ["p", "ci", "dc", "q", "m", "d", "h", "y", "l", "e", "con", "cm", "w", "g", "b", "v", "u", "n", "cy"], "f": ["p", "o", "cf", "q", "m", "d", "h", "F", "fn", "y", "l", "fa", "fd", "e", "fl", "num", "fc", "fe", "w", "g", "v", "b", "u", "sf", "n", "ff"], "x": ["p", "o", "q", "m", "d", "h", "ex", "y", "X", "l", "e", "xes", "xs", "xc", "rx", "w", "b", "v", "xp", "u", "xx", "n"]}}
{"code": "T = int(raw_input())\\n  \\n  def readSq(n):\\n      res = []\\n      for i in xrange(n):\\n          res.append(set(map(int, raw_input().split())))\\n      return res\\n  \\n  def solve():\\n      a1 = int(raw_input())\\n      s1 = readSq(4)\\n      a2 = int(raw_input())\\n      s2 = readSq(4)\\n      ans = s1[a1-1] & s2[a2-1]\\n      if len(ans) == 0:\\n          return \"Volunteer cheated!\"\\n      if len(ans) > 1:\\n          return \"Bad magician!\"\\n      return str(list(ans)[0])\\n  \\n  for z in xrange(T):\\n      print \"Case #%d: %s\" % (z+1, solve())\\n", "substitutes": {"T": ["Z", "TT", "P", "A", "O", "R", "TC", "S", "WT", "TW", "B", "L", "F", "X", "I", "K", "t", "TS", "E", "TN", "TH", "Ts", "G", "M", "D", "Y", "V", "C", "H", "Q", "W", "N", "TF", "Time", "NT"], "n": ["p", "o", "sn", "ns", "m", "nb", "d", "x", "l", "y", "f", "en", "c", "e", "t", "num", "k", "r", "w", "j", "s", "b", "u", "N", "ne", "net"], "res": ["_", "response", "resources", "R", "vals", "runs", "resp", "powers", "details", "q", "resolution", "out", "ids", "ES", "arr", "right", "RES", "str", "pres", "Rs", "args", "ret", "os", "ps", "sol", " results", "r", "rez", "blocks", "reg", "RS", "Result", "re", "Results", "s", "Res", " Res", "rs", "result", "cs", "ras", "results"], "i": ["p", "iq", "li", "id", "ci", "ix", "ei", " ii", "q", "ini", "ai", "ind", " I", "y", "gi", "I", "f", "ii", "c", "ti", "ie", "xi", "ni", "j", "ip", "iu"], "a1": ["aa3", "an3", "aOne", "sa3", "asOne", "saOne", " aOne", "A1", "AOne", "aone", "anone", "aaOne", "A3", "saone", " a3", "aaone", "as3", " aone", "as1", "sa1", "anOne", "a3", "Aone", "asone", "an1", "aa1"], "s1": ["p1", "pone", " sone", " s13", "a01", "Sone", "a13", "S2", "S1", "p01", "p2", "aone", "saone", "s01", "s13", "sone", "S01", "sa13", "sa1", "sa2"], "a2": ["an02", "a4", "a02", " a02", "a5", "b2", "an5", " aTwo", "an2", "aTwo", " a5", "bTwo", "anTwo", " a4", "b02", "sa1", "sa4", "sa2", "s4", "b5"], "s2": ["a8", " s8", "an3", "a5", "atwo", "s3", "anstwo", "an2", "as2", "ans2", "ans5", "an8", "ans1", "as1", "s8", "s5", "as5", "a3", "astwo", " s3", "stwo", "an1"], "ans": ["aning", "ons", "An", "amps", "plan", "san", "na", "ds", "aus", "ns", "ins", "anas", "ai", "ents", "ams", "span", "nas", "ids", "ann", "reads", "lan", "anus", "sk", "scan", "ant", "args", "atan", "ays", "anne", "ions", "anon", "os", "ants", "can", "antis", "ens", "AN", "anc", "a", "s", "ars", "oa", "anned", "aned", "ANS", "ani", "ats", "ana", "an", "ras", "cross", "cases"], "z": ["zer", "Z", "p", "az", "zone", "za", "ld", "q", "ice", "zen", "d", "x", "ind", "y", "tz", "c", "zz", "e", "t", "zh", "gz", "zi", "ze", "k", " Z", "nz", "a", "j", "v", "zy", "u", "iz", "int", "cz", "ez", "zip"]}}
{"code": " \\n  T = int(input())\\n  \\n  for n in range(1, T+1):\\n      print(\"Case #%d:\" % n)\\n      (R, C, M) = (int(x) for x in input().split())\\n      dots = R*C - M\\n      if M == 0:\\n          print(\"\\n\".join([\"c\"+(C-1)*\".\"] + (R-1)*[C*\".\"]))\\n      elif dots == 0:\\n          print(\"Impossible\")\\n      elif R == 1:\\n          assert C - M > 0\\n          print(\"c\"+(C-M-1)*\".\"+M*\"*\")\\n      elif C == 1:\\n          assert R - M > 0\\n          print(\"c\\n\"+(R-M-1)*\".\\n\"+M*\"*\\n\", end='')\\n      elif dots == 1:\\n          print(\"\\n\".join([\"c\"+ (C-1)*\"*\"] + (R-1)*[C*\"*\"]))\\n      elif dots > 3:\\n          if (dots == 5) or (dots == 7):\\n              print(\"Impossible\")\\n              continue\\n          if (R == 2) or (C == 2):\\n              if dots%2 != 0 :\\n                  print(\"Impossible\")\\n                  continue\\n              elif R == 2:\\n                  l = int(dots/2)\\n                  print(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\\n                  print(l*\".\"+(C-l)*\"*\")\\n                  continue\\n              elif C == 2:\\n                  l = int(dots/2)\\n                  print(\"c.\")\\n                  print((l-1)*\"..\\n\", end='')\\n                  print(int(M/2)*\"**\\n\", end='')\\n                  continue\\n          (lines, extra) = divmod(dots, C)\\n          temp = []\\n          if (lines >= 2) and (extra != 1):\\n              temp.append(\"c\"+(C-1)*\".\")\\n              temp.extend((lines-1)*[C*\".\"])\\n              temp.append(extra*\".\"+(C-extra)*\"*\")\\n              temp.extend((R-lines-1)*[C*\"*\"])\\n              print(\"\\n\".join(temp))\\n              continue\\n          elif (lines > 2) and (extra == 1):\\n              temp.append(\"c\"+(C-1)*\".\")\\n              temp.extend((lines-2)*[C*\".\"])\\n              temp.append((C-1)*\".\"+\"*\")\\n              temp.append(\"..\"+ (C-2)*\"*\")\\n              temp.extend((R-lines-1)*[C*\"*\"])\\n              print(\"\\n\".join(temp))\\n              continue\\n          elif (lines == 2) and (extra == 1):\\n              temp.append(\"c\"+(C-2)*\".\"+\"*\")\\n              temp.append((C-1)*\".\"+\"*\")\\n              temp.append(3*\".\"+(C-3)*\"*\")\\n              temp.extend((R-3)*[C*\"*\"])\\n              print(\"\\n\".join(temp))\\n              continue\\n          elif lines < 2:\\n              (l, rem) = divmod(dots, 2)\\n              if rem == 1:\\n                  l -= 1\\n                  rem += 2\\n              temp.append(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\\n              temp.append(l*\".\"+(C-l)*\"*\")\\n              temp.append(rem*\".\"+(C-rem)*\"*\")\\n              temp.extend( (R-3)*[ C*\"*\" ])\\n              print(\"\\n\".join(temp))\\n              continue\\n      else:\\n          print(\"Impossible\")\\n  \\n", "substitutes": {"T": [" N", "Z", "P", "O", "TT", "A", "Length", "TC", "S", "WT", "B", "time", "L", "TB", "F", "X", "I", "t", "TS", "E", "TN", "D", "G", "Y", "V", "H", " t", "N", "W", "Time", "NT"], "n": [" N", "p", "o", "nc", "na", "Ns", "ns", "m", "ot", "d", "nn", "L", "un", "y", "f", "c", "e", "t", "ln", "num", "i", "k", "z", "nt", "r", "a", "w", "g", "j", "nd", "s", "b", "v", "u", "N"], "R": ["P", "O", "A", "CR", "Cr", "S", "B", "Ra", "MR", "RA", "AR", "RE", "L", "RR", "CL", "J", "LR", "F", "X", "Rec", "K", "RN", "BR", "ER", "c", "RP", "RW", "Rs", "E", "IR", "NR", "RH", "DR", "RO", "D", "G", "r", " r", "Rh", "U", "Y", "GR", "RS", "Cl", "UR", "V", "H", "RL", "RT", "Co", "RG", "Q", "W", "N", "SR", "Re", "RC", "RM"], "C": ["CC", "P", "O", "SC", "A", "Cr", "CF", "CR", "CS", "S", "Code", "B", "Cs", "CI", "YC", "JC", "DC", "L", "CL", "CD", "CM", "AC", "X", "F", "K", "I", "CV", "count", "Sc", "c", "Ch", "CU", "E", "CT", "CN", "CNN", "VC", "D", "G", "NC", "EC", "MC", "LINE", "U", "Count", "Y", "CA", "Cl", "V", "Co", "H", "CP", "Cu", "Q", "W", "N", "LC", "SR", "RC", "Extra", "CE"], "M": ["Z", "MQ", "P", "O", "LM", "A", "VM", "MF", "S", "MN", "AM", "B", "MO", "MR", "m", "CL", "L", "J", "MA", "CM", "TM", "F", "X", "K", "I", "DM", "IM", "Mor", "E", "SM", "D", "G", "MI", "MC", "MD", "r", "U", "Y", "V", "H", "MT", "EM", "Sl", "ML", "Q", "NM", "MX", "N", "W", "RM"], "x": ["p", "ax", "xa", "xxx", "xf", "q", "m", "d", "xxxxxxxx", "ex", "y", "X", "f", "wx", "h", "hex", "ux", "c", "e", "t", "i", "xi", "xe", "z", "xd", "r", "xs", "xc", "rx", "w", "g", "j", "xy", "v", "xp", "xxxx", "u", "xx", "xb"], "dots": [" durtles", " diffs", " dumbers", "dours", "diffs", "sdumbers", "dot", "pumps", "ldots", " dotted", "mots", "durtles", "fours", "didiffs", "Dots", "dott", "pots", "dips", "Diffs", "dets", "dyot", "fotted", "pops", "Dips", "didops", "tots", "didots", "lrots", " dours", "dumps", "fot", " dOTS", "Dashes", "lOTS", "ldott", "ldOTS", " dOTT", "dyOTT", "didurtles", "potted", "fots", " dot", "didips", "ldumps", "dumbers", "dotted", "Dumbers", "tOTS", "Drots", "Dumps", "Durtles", "Dets", "dashes", "sdOTS", "didOTS", "DOTS", "dops", "Dot", "Dotted", "pOTS", "mOTS", "tumps", "dyops", "tets", "sdots", "sdashes", "lots", "drots", " drots", "lashes", "diots", "mashes", "dOTS", "Dott", "dyots", "diOTS", "diumps", "Dops", "pashes", "diets", "DOTT", "pott", " dips", " dashes", " dott", " dops", "dOTT", "motted", "Dours"], "l": ["pl", "p", "o", "il", "li", "all", "ls", "lin", "lc", "len", "m", "d", "ll", "L", "h", "ul", "f", " L", "c", "al", "e", "t", "ell", "ln", "fl", "i", "el", "Li", "nl", "z", "r", "kl", "w", "dl", "j", "g", "s", "b", "v", "ol", "line", "u", "loc", "le", "sl"], "lines": ["notes", "p", "all", "ls", "runs", "lin", "log", "limits", "Line", "ns", "ins", "codes", "d", "strings", "LR", "h", "f", "count", "times", "levels", "c", "pages", "cycles", "points", "Rs", "models", "ln", "ends", "lins", "i", "nl", "rows", "z", "LINE", "letters", "links", "size", "inline", "blocks", "ines", "length", " Lines", "s", "b", "v", "cells", "line", "NL", "comments", "planes", "N", "rs", "cases", "breaks"], "extra": ["err", "needed", "outer", "esc", "current", "internal", "rc", "q", "order", "ignore", "ext", "origin", "random", "EXT", "special", "external", "Extra", "ex", "missing", "base", "next", "alpha", "custom", "max", "default", "area", "regular", "other", "args", "inner", "after", "background", " extras", "skip", "wrapper", "empty", "white", "info", "di", " Extra", "inline", "zip", "border", "size", "length", "margin", "plus", "line", "diff", "comments", "added", "fake", "radius", "original", "ne", "error", "optional", "ras", "magic", "exclusive"], "temp": ["err", "iter", "p", "Temp", "response", "single", "unit", "list", "full", "copy", "holder", "export", "index", "init", "multi", "base", "flat", "body", "get", "stack", "tree", "adj", "data", "edit", "inner", "key", "cache", "mini", "api", "pre", "empty", "output", "white", "template", "partial", "tmp", "note", "let", "size", "j", "buffer", "left", "diff", "fake", "now", "clean", "test", "slice", "ignore", "zip"]}}
{"code": " ncases = int(input())\\n  \\n  for n in range(1, ncases+1):\\n      row = int(input())\\n      for m in range(1, 5):\\n          if m == row:\\n              r1list = [int(x) for x in input().split()]\\n              assert len(r1list) == 4\\n          else:\\n              tmp = input()\\n      row = int(input())\\n      for m in range(1,5):\\n          if m == row:\\n              r2list = [int(x) for x in input().split()]\\n              assert len(r1list) == 4\\n          else:\\n              tmp = input()\\n      nset = set(r1list) & set(r2list)\\n      if len(nset) == 1:\\n          print(\"Case #%d:\" % n, nset.pop())\\n      elif len(nset) > 1:\\n          print(\"Case #%d:\" % n, \"Bad magician!\")\\n      else:\\n          print(\"Case #%d:\" % n, \"Volunteer cheated!\")\\n", "substitutes": {"ncases": ["NCasts", "bcasing", "nvasing", "aucased", "aucasing", "NCasing", "lcasing", "ncased", "nvamps", "ncasts", "bcamps", "nsases", "nvased", "nsamps", "lcases", "aucases", "bcases", "nsased", "NCased", "nvases", "ncasing", "NCases", "lcasts", "ncamps", "nsasing", "lcased", "bcased", "aucasts"], "n": ["p", "o", "mn", "nu", "nc", "na", "cn", "nm", "name", "ns", "nb", "pn", "nn", "d", "un", "en", "max", "l", "f", "y", "c", "e", "t", "ln", "num", "i", "k", "z", "nt", "r", "rn", "w", "j", "s", "v", "min", "u", "on", "N", "net"], "row": ["mod", "node", "ow", "uu", "tr", "group", "col", "user", "month", "range", "index", "run", "entry", "order", "ro", "channel", "dy", "max", "y", "raw", "f", "port", "pri", "right", "c", "ry", "ack", "end", "no", "key", "batch", "num", "i", "skip", "rows", "year", "round", "k", "cell", "roll", "ok", "r", "auto", "w", "Row", "instance", "server", "min", "block", "page", "feed", "bug", "error", "micro", "where", "one"], "m": ["p", "o", "pm", "mo", "mn", "ma", "id", "col", "mu", "mm", "fm", "nm", "sm", "d", "h", "am", "y", "l", "f", "c", "ym", "e", "bm", "dm", "num", "i", "um", "k", "M", "z", "r", "cm", "mult", "mi", "b", "v", "min", "ms", "om", "u", "rm", "an"], "r1list": ["r7list", "r3List", "r2cont", "R2bl", "r0List", " r1List", " r3List", "r5list", "R1set", " r3set", "r0list", " r3list", "r1cont", "r2set", "r6string", "R1bl", "R1string", "r7set", "r2List", "r6list", "R1List", "r9bl", "r01List", "r5string", "r5List", "R2list", "r6cont", "r7List", "r3set", "r9List", "r3list", "R2string", "r9list", "r01list", "R1cont", "R1list", "r1string", "r1List", "r0set", " r1set", "R2List", "r5cont", "r1set", "R2set", "r9set", "r2bl", "R2cont", "r1bl", "r01bl", "r01set", "r6List", "r2string"], "x": ["p", "ph", "bit", "ww", "word", "id", "ix", "ch", "ax", "xxx", "xf", "event", "q", "d", "h", "ex", "y", "X", "f", "xt", "c", "e", "t", "xes", "num", "i", "px", "xi", "k", "z", "r", "xs", "xc", "w", "cl", "b", "v", "u", "xxxx", "xx", "sex", "xb", "int", "test", "ct"], "tmp": ["img", "rb", "nu", "qq", "yy", "copy", "txt", "mu", "mm", "rc", "nb", "np", "cont", "rup", "area", "stuff", "seed", "temp", "batch", "form", "mmm", "cache", "pre", "proc", "sup", "obj", "emp", "buf", "cmp", "part", "nt", "bb", "rm", "upload", "mp", "now", "ignore", "zip"], "r2list": ["r3List", "r4List", "c4l", "r2l", "r2x", "r1l", " r2x", "r4x", "r3x", "c2List", " r4list", "r4list", "r2List", "c4List", "c4list", " r2List", "r4l", " r2l", "r3list", " r4x", "r1List", "c2list", "c2l", " r4List", "r3l", " r4l", "r1x"], "nset": ["Nset", "rset", "nsc", "cnlist", "nnset", "nnmatch", " nsync", "cnset", "nSet", " nSet", "Nsc", " nlist", "nnsc", "dlist", "rlist", "nsection", "dsync", "nsync", "ncheck", "Nst", "unst", "unsc", "dset", " nmatch", "Nmatch", " nst", "rcheck", "nst", "unSet", "Nsection", " nsets", " nsection", "cnsets", "nlist", "nnsection", "dcheck", "rsets", "unset", "nsets", " ncheck", "NSet", "cnsync", " nsc", "rsync", "nmatch"]}}
{"code": " \\n  \\n  IMPOSSIBLE = []\\n  \\n  def transpose(grid):\\n      return map(list, zip(*grid))\\n  \\n  def find_grid(R, C, M):\\n      \"\"\"Return a grid of a solution, if one exists, otherwise []\\n  \\n      Observations:\\n      * WLOG, C <= R (otherwise, take the transpose of a solution)\\n      * Trivial cases are:\\n        - M = 0 or  M = RC - 1\\n        - C = 1\\n        - (R, C) = (2, 2)\\n        - (R, C, M) = (3, 3, 2)\\n        - (C, M) = (2, 1)\\n      * If M >= C >= 2 and R >= 3, we can add a row of C mines to the bottom and consider M'=M-C, R'=R-1\\n      * The remaining cases are M <= R-2, and M + 1 == R == C >= 4, which are both solvable\\n      \"\"\"\\n      if M == 0:\\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          return grid\\n      elif M == R * C - 1:\\n          grid = [['*' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          return grid\\n      elif C > R:\\n          return transpose(find_grid(C, R, M))\\n      elif C == 1:\\n          return [['c']] + [['.'] for i in xrange(R-M-1)] + [['*'] for i in xrange(M)]\\n      elif (R, C) == (2, 2) or (R, C, M) == (3, 3, 2) or (C, M) == (2, 1):\\n          return IMPOSSIBLE\\n  \\n      assert 2 <= C <= R >= 3, \"R={} C={} M={}\".format(R, C, M)\\n  \\n      if M >= C:\\n          s = find_grid(R-1, C, M-C)\\n          return s and s + [['*' for c in xrange(C)]]\\n      elif M <= R-2 and C >= 3:\\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          for i in xrange(M):\\n              grid[R-i-1][C-1] = '*'\\n          return grid\\n      elif M + 1 == R == C >= 4:\\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          grid[R-1][C-2] = '*'\\n          for i in xrange(M-1):\\n              grid[R-i-1][C-1] = '*'\\n          return grid\\n  \\n      assert False, \"R={} C={} M={}\".format(R, C, M)\\n  \\n  def check_soln(grid, R, C, M):\\n      \"\"\"checking, because debugging...\"\"\"\\n      error = \"R={} C={} M={}\".format(R, C, M)\\n      assert sum(row.count('*') for row in grid) == M, error\\n      assert sum(row.count('c') for row in grid) == 1, error\\n      assert len(grid) == R, error\\n      assert all(len(row) == C for row in grid), error\\n      _ = [i for i, row in enumerate(grid) if 'c' in row][0]\\n      click = (_, [i for i, c in enumerate(grid[_]) if c == 'c'][0])\\n  \\n      def neighbours(r, c):\\n          ns = [(i, j) for i in range(max(r-1,0),min(r+2,R)) for j in range(max(c-1,0),min(c+2,C))]\\n          ns.remove((r, c))\\n          return ns\\n  \\n      cpy = map(list, grid)\\n      def fill(cpy, pos):\\n          cpy[pos[0]][pos[1]] = str(sum(1 for i, j in neighbours(*pos) if grid[i][j] == '*'))\\n          if cpy[pos[0]][pos[1]] == '0':\\n              for i, j in neighbours(*pos):\\n                  if cpy[i][j] == '.':\\n                      fill(cpy, (i, j))\\n      fill(cpy, click)\\n      assert sum(row.count('.') for row in cpy) == 0, error\\n  \\n  def solve(R, C, M):\\n      soln = find_grid(R, C, M)\\n      if soln == IMPOSSIBLE:\\n          return \"Impossible\"\\n      else:\\n          check_soln(soln, R, C, M)\\n          return '\\n'.join(''.join(row) for row in soln)\\n  \\n  if __name__ == '__main__':\\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\\n      with fin, fout:\\n          T = int(fin.readline())\\n          for case in xrange(1, T+1):\\n              r, c, m = map(int, fin.readline().split())\\n              soln = solve(r, c, m)\\n              print >> fout, \"Case #{0}:\\n{1}\".format(case, soln)\\n  \\n", "substitutes": {"IMPOSSIBLE": ["IMPASSIBLE", "IMPESSORS", "IMPESSible", "IMpASSIBLE", "IMPUSIBLE", "IMPESSibles", "IMPOSURE", "IMPOSSURE", "IMpASSORS", "IMPOSible", "IMpOSSIVE", "IMpOSSIBLE", "IMPOSIBLE", "IMPASSURE", "IMpOSSible", "IMpASSIVE", "IMpASSibles", "IMPUSORS", "IMpOSSORS", "IMpOSSURE", "IMPOSSible", "IMPESSIBLE", "IMPESSURE", "IMpOSSibles", "IMPASSible", "IMPOSIVE", "IMPASSORS", "IMPESSIVE", "IMPOSSORS", "IMPUSible", "IMPUSibles", "IMpASSible", "IMPOSSIVE", "IMPOSSibles", "IMPASSibles", "IMpASSURE", "IMPASSIVE"], "grid": ["array", "node", "query", "lay", "unit", "sort", "list", "plot", "layout", "index", "range", "mu", "order", "gr", "play", "frame", "draw", "age", "network", "reg", "cm", "sg", "panel", "page", "align", "id", "db", "out", "card", "arr", "data", "table", "dict", "G", "module", "sequence", "window", "column", "flow", "df", "layer", "lat", "manager", "filter", "sim", "copy", "file", "flat", "f", "Grid", "edge", "str", "client", "chain", "complex", "cell", "graph", "input", "method", "line", "dim", "gap", "mat", "ge", "house", "square", "group", "q", "volume", "x", "tree", "choice", "cache", "rr", "rows", "type", "move", "cube", "g", "storage", "server", "model", "cells", "block", "site"], "R": ["P", "A", "CR", "WR", "S", "JR", "B", "Ra", "MR", "RA", "AR", "RE", "L", "RR", "Run", "LR", "F", "X", "RN", "K", "Ro", "Rec", "RP", "ER", "RW", "Rs", "E", "IR", "NR", "RH", "DR", "RO", "TR", "D", "G", "Rh", "U", "Y", "GR", "RS", "Cl", "V", "H", "RT", "RG", "Q", "W", "N", "SR", "Re", "RC", "RM", "Range"], "C": ["CC", "P", "O", "Cr", "CR", "SC", "A", "CS", "S", "B", "Cs", "CI", "YC", "DC", "L", "CL", "CM", "AC", "X", "F", "K", "I", "CV", "Ch", "CU", "E", "CT", "CN", "CO", "VC", "D", "NC", "G", "EC", "MC", "U", "Y", "CA", "V", "H", "Co", "Cu", "Q", "W", "N", "RC", "CE"], "M": ["CC", "Z", "Mo", "P", "O", "LM", "A", "CR", "VM", "S", "MN", "AM", "B", "MO", "MR", "RA", "AR", "J", "L", "DC", "MA", "CM", "CL", "F", "X", "I", "DM", "Me", "K", "IM", "Man", "Mor", "CU", "E", "MOD", "ME", "DR", "MM", "D", "G", "OM", "MI", "MC", "MD", "U", "cm", "Y", "V", "H", "RR", "MB", "Mc", "Q", "W", "N", "RC", "RM", "Range"], "c": ["p", "cu", "ch", "cc", "unc", "col", "cf", "lc", "cn", "d", "x", "arc", "h", "l", "f", "cr", "e", "code", "ce", "ec", "k", "z", "cat", "ic", "con", "cm", "xc", "a", "co", "g", "cl", "b", "v", "ca", "n", "cs", "ct", "ac"], "r": ["err", "p", "o", "it", "br", "rb", "id", "range", "ar", "gr", "x", "l", "f", "ru", "fr", "e", "ir", "t", "ur", "ner", "rg", "rn", "g", "re", "b", "sr", "v", "u", "pr", "lr", "n", "rs", "er", "yr"], "i": ["p", "it", "iq", "id", "ci", "col", "q", "ar", "ai", "x", "arc", "bi", "ind", "l", "I", "ii", "ti", "e", "ir", "xi", "pi", "z", "ic", "g", "im", "b", "v", "ip", "n", "int", "iu"], "s": ["p", "o", "sq", "sim", "ws", "S", "ss", "sb", "states", "su", "ts", "d", "es", "h", "y", "l", "f", "e", "t", "ses", "sets", "gs", "sites", "ps", "services", "abs", "blocks", "sample", "a", "w", "g", "sg", "b", " S", "storage", "sync", "cells", "v", "u", "n", "si", "sym"], "row": ["rown", "array", "ho", "unit", "ow", "copy", "col", "run", "sc", "ice", "ro", "head", "ox", "rug", "plane", "ack", "rows", "roll", "cell", "cube", "column", "Row", "flow", "rid", "block", "ros", "roc"]}}
{"code": " \\n  \\n  def read_row(fin, n):\\n      rows = [set(map(int, fin.readline().strip().split())) for i in xrange(4)]\\n      return rows[n-1]\\n  \\n  def solve(rowa, rowb):\\n      both = rowa & rowb\\n      if len(both) == 1:\\n          return list(both)[0]\\n      elif len(both) > 1:\\n          return \"Bad magician!\"\\n      elif not both:\\n          return \"Volunteer cheated!\"\\n  \\n  if __name__ == '__main__':\\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\\n      with fin, fout:\\n          T = int(fin.readline())\\n          for case in xrange(1, T+1):\\n              n = int(fin.readline())\\n              rowa = read_row(fin, n)\\n              n = int(fin.readline())\\n              rowb = read_row(fin, n)\\n              soln = solve(rowa, rowb)\\n              print >> fout, \"Case #{0}: {1}\".format(case, soln)\\n  \\n", "substitutes": {"fin": ["fp", "res", "div", "tr", "details", "syn", "fail", "en", "fit", "bin", "inner", "do", "prem", "die", "fun", "raf", "FIN", "nu", "inn", "send", "txt", "init", "nit", "ini", "fn", "end", "rec", "win", "skip", "proc", "conn", "inv", "fi", "commit", "Fin", "before", "inf", "df", "kin", "token", "start", "pub", "lin", "len", "spec", "pen", "file", "rf", "f", "fr", "fa", "pid", "dir", "fine", "final", "ln", "ur", "front", "info", "serv", "hr", "fen", "br", "thin", "dev", "report", "run", "rin", "tin", "fd", "after", "han", "fat", "rt", "cin", "tick", "close"], "n": [" N", "p", "o", "nu", "sn", "nc", "na", "len", "m", "nb", "ns", "d", "np", "x", "L", "h", "l", "y", "f", "count", "en", "un", "c", "nr", "e", "t", "num", "k", "z", "nt", "r", "ni", "size", "w", "g", "s", "b", "v", "number", "u", "N", "ne", "net"], "rows": ["files", "vals", "runs", "lines", "col", "reports", "relations", "index", "users", "ins", "fields", "ids", "reads", "items", "flows", "views", "models", "events", "values", "ows", "frames", "keys", "dict", "rules", "groups", "blocks", "ks", "headers", "row", "cells", "members", "feed", "result", "results", "cases", "pages"], "i": ["p", "iq", "li", "id", "ci", "ix", "index", "q", "ice", "d", "ai", "ind", "gi", "I", "c", "ti", "e", "key", "ie", "k", "ic", "j", " c", "instance", "ip", "u", "item"], "rowa": [" rowsa", "rollp", "rollb", "Rowp", "rowsb", "oxada", "oxsa", " rowarea", "rawp", "Rowa", "rawas", "Rowb", "rowada", " rowada", "Rowsa", "rosa", "roada", "colb", "rowas", "rolla", "rowssa", "Rowas", "oxarea", "rawb", "rowp", " rowp", "rowarea", "rowsas", "rowsa", "cola", "rawa", "roa", "oxa", "roarea", " rowas", "colp"], "rowb": ["rown", "viewc", "rollb", "arroweb", "viewl", "col", "ryf", "viewn", " rowf", "rob", "rowf", " rowba", "arrowa", "arrowb", "rowc", " rowbb", "rollf", "cob", "rolla", "rolleb", "rollba", "rowl", "rya", "ryeb", " rowc", "viewa", " rown", " roweb", "con", "rowba", "rowbb", "coa", "vieweb", "roba", "arrowc", "roa", "viewb", " rowl", "roweb", "rollbb", "robb", "ryb"], "both": ["p", "off", "all", "list", "multiple", "full", "each", " Both", "alone", "pair", "same", "null", "odd", "either", "also", "multi", "who", "l", "equal", "always", "between", "right", "only", "other", "t", "many", "inner", "none", "yet", "two", "tw", "empty", "partial", "part", "wh", "holes", "sometimes", " neither", "three", "length", "left", "hand", "this", "then", "diff", "short", "now", "half", "Both", "balanced", "before", "private", "total", "cho", "old", "one"], "fout": [" fOut", " Fin", " fouts", "Fouts", "fOUT", "fOut", "sfobj", " fio", " Fobj", "fsout", "fsouts", "sfOut", "FOut", " fOUT", "sfio", "FOUT", "fouts", " Fout", "fobj", "sfin", "fsOut", " fobj", "fsin", "sfouts", "Fin", "sfout", "sfOUT", " Fio", "fio", "Fout"], "T": [" N", "tests", "P", "O", "TT", "R", "S", "B", "time", "L", "max", "F", "X", "I", "t", "E", "TN", "trial", "D", "M", "C", "V", "H", "Case", "number", "Q", "N", "test", "Time", "NT"], "case": ["p", "switch", "se", "id", "rice", "pe", "su", "name", "ice", "time", "X", "position", "c", "ace", "end", "code", "chain", "trial", "ce", "type", "match", "exc", "C", "Case", "row", "instance", "line", "de", "race", "use", "ase", "loc", "call", "bug", "section", "test", "cases", "one"], "soln": ["solk", "esolen", "sln", "ssoln", "esols", "ssol", "esoln", "esolk", " sol", "esol", "ssln", "sol", " sln", "sols", " sols", "ssols", "ssolen", " solk", "esln", "solen", " solen", "ssolk"]}}
{"code": " \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n   \\n  \\n  \\n  \\n  \\n  def debug(*args):\\n      print(*args, file=sys.stderr)\\n  \\n  fin = sys.stdin\\n  T = int(fin.readline())\\n  for case in range(1, T + 1):\\n      RR, CC, M = map(int, fin.readline().split())\\n      R, C = None, None\\n      blocks = RR*CC - M\\n      inverse = False\\n      if RR > CC:\\n          inverse = True\\n          R, C = CC, RR\\n      else:\\n          R, C = RR, CC\\n      result = None\\n      if R == 1:\\n          result = [('.' * blocks) + ('*' * M)]\\n      elif R == 2:\\n          if blocks == 1:\\n              result = ['.' + ('*' * (C-1)), '*' * C]\\n          elif blocks % 2 == 0 and blocks != 2:\\n              cc = blocks // 2\\n              result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \\n          else:\\n              result = None\\n      else:\\n          if blocks == 1:\\n              result = ['*' * C] * R\\n          elif blocks == 4:\\n              result = ['..' + (C-2)*'*']*2\\n              result += ['*'*C] * (R-2)\\n          elif blocks == 6:\\n              result = ['...' + (C-3)*'*']*2\\n              result += ['*'*C] * (R-2)\\n          for rows in range(3, R+1):\\n              for columns in range(rows, C+1):\\n                  size = rows * columns\\n                  if size - blocks >= 0:\\n                      if size - blocks <= columns - 2: \\n                          result = []\\n                          for r in range(rows):\\n                              if r < rows - 1:\\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\\n                              else:\\n                                  cc = columns - (size - blocks)\\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\\n                          for r in range(R - rows):\\n                              result.append('*' * C)\\n                      elif size - blocks == columns - 1 and rows >= 4:\\n                          result = []\\n                          for r in range(rows):\\n                              if r < rows - 2:\\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\\n                              elif r == rows - 2:\\n                                  cc = columns - 1\\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\\n                              else:\\n                                  cc = 2\\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\\n                          for r in range(R - rows):\\n                              result.append('*' * C)\\n                      \\n  \\n  \\n  \\n      print(\"Case #%d: \" % (case))\\n      if result is None:\\n          debug('impossible', blocks, RR, CC)\\n          print(\"Impossible\")\\n      else:\\n          mines = 0\\n          for r in range(RR):\\n              row = ''\\n              for c in range(CC):\\n                  rr, cc = r, c\\n                  if inverse:\\n                      rr, cc = c, r\\n                  if rr == 0 and cc == 0:\\n                      row += 'c'\\n                  else:\\n                      row += result[rr][cc]\\n                      if result[rr][cc] == '*':\\n                          mines += 1\\n              print(row)\\n          if mines != M:\\n              raise Exception(\"%d != %d %d x %d\" % (mines, M, RR, CC))\\n              \\n  \\n  \\n", "substitutes": {"fin": ["iter", "fp", "rb", "nu", "thin", "br", "div", "inn", "lin", "init", "len", "tin", "rin", "file", "su", "ini", "h", "en", "fn", "f", "tun", "fa", "fr", "fd", "bin", "fit", "util", "fine", "inner", "ln", "el", "os", "ran", "fat", "conn", "fi", "inv", "die", "serv", "Fin", "fen", "inf", "lo", "kin", "raf", "FIN"], "T": [" N", "Z", "TT", "O", "P", "TC", "S", "B", "time", "L", "TB", "X", "F", "K", "t", "TS", "E", "CT", "TN", "TH", "TR", "D", "Y", "V", "H", "RT", "Q", " t", "N", "W", "TF", "Time"], "case": ["p", "P", "TC", "cor", "B", "seq", "ice", "time", "d", " time", "X", "times", "ace", "end", "e", "num", "trial", "sec", "bc", "length", "b", "v", "line", "test", "section", "cases", "tc"], "RR": ["CR", "WR", "JR", "ARR", "MR", "RA", "DC", "LR", "RN", "RP", "RW", "RD", "Rs", "RB", "IR", "NR", "RH", "DR", "RO", "TR", "CCC", "Rh", "GR", "RS", "RL", "RT", "RG", "HR", "SR", "RF", "RC", "RM", "CV"], "CC": ["Z", "CW", "SC", "CF", "CR", "CB", "TC", "FC", "FF", "OC", "CL", "DC", "CD", "GG", "BC", "CM", "X", "WC", "AC", "CV", "GC", "CT", "CON", "CO", "CNN", "VC", "PC", "MM", "UC", "NC", "CCC", "MC", "EC", "XX", "CA", "RS", "CP", "CH", "LC", "RC", "RM", "CE"], "M": ["P", "O", "LM", "A", "MF", "S", "MN", "B", "MR", "m", "CL", "L", "DC", "CM", "AC", "F", "TM", "K", "DM", "I", "IM", "MOD", "CNN", "MM", "D", "G", "MS", "MI", "MC", "MD", "CCC", "OM", "U", "Y", "V", "H", "Q", "W", "N", "RC", "RM"], "R": ["P", "A", "CR", "S", "JR", "B", "Block", "MR", "RA", "L", "Run", "LR", "F", "X", "RN", "BR", "I", "K", "RP", "right", "RW", "RD", "Rs", "E", "RB", "IR", "NR", "RH", "Right", "DR", "RO", "TR", "D", "G", "Rh", "U", "GR", "Y", "RS", "RL", "V", "RT", "H", "Co", "RG", "Q", "W", "SR", "RF", "N", "RC", "RM", "Range"], "C": ["Z", "SC", "A", "CL", "BC", "K", "Sc", "E", "CNN", "CCC", "Size", "Length", "B", "Cs", "CI", "JC", "Control", "CM", "WC", "CO", "NC", "D", "G", "Y", "Cl", "Co", "H", "Cu", "CV", "CR", "S", "YC", "Code", "AC", "F", "X", "CU", "CT", "VC", "EC", "U", "V", "Q", "W", "P", "CW", "O", "CF", "CS", "DC", "L", "HC", "Ch", "GC", "CON", "CN", "Right", "MC", "Count", "CA", "N", "RC", "CE"], "blocks": ["steps", "CB", "files", "Block", "ins", "BC", "K", "locks", "levels", "cycles", "Rs", "items", "Blocks", "units", "PC", "control", "ks", "RS", "length", "words", "heads", " Blocks", "bits", "cases", "B", "pieces", "limits", "users", "values", "frames", "rules", "quarters", "bars", "groups", "bc", "n", "results", "lines", "S", "nos", "ops", "RESULTS", "X", "F", "BL", "checks", "events", "bs", "cl", "balls", "W", "pages", "maps", "CW", "features", "outs", "runs", "classes", "plugins", "errors", "L", "jobs", "TM", "packages", "modules", "times", "flows", "ions", "bytes", "rons", "MS", " results", "MC", "types", "cb", "boxes", "s", "b", "cells", "days", "N", "planes", "block", "chains", "breaks"], "inverse": ["INverted", "insverted", "outverse", "uninreverse", "Inreverse", "outverted", "insverse", "Include", "insvert", "Invert", "inreverse", "INreverse", "outreverse", "insreverse", "INclude", "include", "outvert", "INverse", "uninverted", "uninclude", "uninverse", "inverted", "invert", "Inverse", "Inverted"], "result": ["response", "array", "res", "pack", "list", "rest", "math", "event", "details", "account", "true", "grade", "default", "output", "color", "match", "length", "buffer", "page", "test", "comment", "params", "func", "view", "product", "data", "table", "reason", "dict", "description", "rules", "summary", "root", "attr", "number", "diff", "memory", "df", "results", "json", "replace", "filter", "valid", "config", "function", "record", "message", "final", "ret", "package", "status", "info", "Result", "use", "error", "date", "coll", "err", "desc", "features", "group", "report", "current", "catch", "success", "follow", "found", "search", "answer", "rule", "cache", " Result", "round", "url", "runner", "Results", "master", "compl", "complete", "block", "source", "method"], "cc": ["cca", "acc", "coll", "cv", "sq", "ci", "cf", "dc", "nc", "ucc", "FC", "lc", "rc", "cci", "sc", "weight", "rank", "mm", "ll", "DC", "cr", "cp", "count", "uc", "lv", "code", "cost", "inc", "ck", "PC", "fc", "ce", "shape", "control", "tc", "ec", "cell", "sec", "anc", "con", "cm", "co", "cb", "cl", "bc", "length", "cd", "ced", "kk", "cells", "content", "mc", "loc", "block", "RC", "ca", "cs", "CE", "ct", "ff", "cases", "pc", "ac"], "rows": ["tests", "_", "forms", "all", "ins", "h", "items", "rh", "ks", "RS", "length", "orders", "heads", "ros", "cs", "cases", "height", "users", "es", "right", "end", "ries", "views", "values", "frames", "keys", "rules", "OWS", "groups", "n", "rs", "results", "p", "lines", "col", "qs", "d", "rss", "count", "checks", "events", "sections", "xs", "pages", "rown", "features", "runs", "rank", "rc", "errors", "sc", "DC", "x", "times", "ows", "types", "vers", "boxes", "s", "cells", "members", "planes", "breaks"], "columns": ["columnes", "Columnses", "patterns", "columnings", "columnrows", "indexs", "columnses", "methodS", "indexsets", "Columnows", "columnb", "structings", "Columnes", "columners", "rounds", "Columnsets", "coles", "Columners", "scrollb", "colows", "columnS", "roundrows", "columnows", "colsets", "colb", "colrows", "cellrows", " columnb", "Columnrows", "Columnns", "structes", "celles", "patternns", "colS", "columnensions", "paragraphses", "paragraphows", "ColumnS", "Columns", "colses", "indexes", "patternes", "patternings", "cellensions", "colensions", "methods", "Columnl", "methodes", "rounders", "methodows", "colers", "cols", "scrollS", "structs", "structns", "columnns", "paragraphs", " columnS", "roundes", " columnows", "cells", "Columnings", "Columnensions", "scrollows", "scrolls", "paragraphes", "indexl", "coll", "columnsets", "columnl"], "size": ["sort", "sn", "address", "ci", "len", "sc", "name", "width", "order", "time", "x", "external", "es", "en", "when", "count", "default", "position", "core", "member", "area", "shift", "enc", "scale", "code", "form", "mode", "ows", "empty", "shape", "large", "ize", "white", "SIZE", "z", "see", "sec", "year", "rate", "support", "column", "w", "cl", "six", "length", "sized", "s", "small", "cells", "Size", "number", "use", "capacity", "content", "loc", "radius", "n", "clean", "cs", "source"], "r": ["p", "rb", "br", "resh", "range", "rc", "ar", "gr", "m", " rc", "ro", "d", "x", "rf", "h", "l", "ru", "cr", "f", "rl", "rd", "fr", "nr", "right", "e", "ir", "rec", "ur", "i", "ner", "k", "rh", "z", "rg", "w", "g", "sr", "v", "b", "pr", "lr", "rw", "n", "rs", "er", "yr"]}}
{"code": " \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  def debug(*args):\\n      print(*args, file=sys.stderr)\\n  \\n  fin = sys.stdin\\n  T = int(fin.readline())\\n  for case in range(1, T + 1):\\n      answer1 = int(fin.readline())\\n      rows1 = []\\n      for i in range(4):\\n          rows1.append(set(map(int, fin.readline().split())))\\n      answer2 = int(fin.readline())\\n      rows2 = []\\n      for i in range(4):\\n          rows2.append(set(map(int, fin.readline().split())))\\n  \\n      possibilities1 = rows1[answer1-1]\\n      possibilities2 = rows2[answer2-1]\\n  \\n      numbers = possibilities1.intersection(possibilities2)\\n      result = None\\n      if len(numbers) == 1:\\n          result = list(numbers)[0]\\n      elif len(numbers) == 0:\\n          result = 'Volunteer cheated!'\\n      else:\\n          result = 'Bad magician!'\\n  \\n  \\n      print(\"Case #%d: %s\" % (case, result))\\n  \\n", "substitutes": {"fin": ["trans", "iter", "br", "nu", "thin", "div", "inn", "lin", "init", "len", "report", "tin", "rin", "file", "gener", "ini", "zen", "spec", "vec", "en", "fn", "central", "f", "nir", "tun", "cook", "fr", "fa", "fd", "bin", "util", "fine", "dir", "final", "inner", "ln", "han", "front", "ran", "ven", "fat", "proc", "rt", "conn", "prem", "non", "die", "fun", "Fin", "pos", "reader", "finder", "fen", "n", "loader", "kin", "raf", "FIN"], "T": [" N", "Z", "O", "TT", "P", "A", "R", "S", "B", "time", "L", " time", "F", "X", "I", "t", "TS", "E", "Total", "TN", "D", "M", "Y", "C", "H", "V", "Q", " t", "N", "n", "TI", "test", "Time", " P"], "case": ["me", "switch", "se", "id", "tim", "seq", "adi", "sea", "su", "ice", "name", "time", "loop", "x", "phase", "count", "c", "day", "ace", "answer", "code", "t", "key", "trial", "ce", "ue", "sequence", "match", "size", "U", "C", "length", "Case", "row", "instance", "line", "use", "race", "ase", "page", "bug", "section", "test", "cases"], "answer1": ["Answer1", "rank1", "response1", "AnswerOne", "address1", "answerone", "response2", "address01", "answerOne", "responseOne", "size01", " answerOne", "sizeone", "rankone", "answer01", "size1", "Answer2", "addressone", "rank01"], "rows1": ["rowOne", "owsone", "owsOne", "orders2", "row0", "row2", "ordersone", "rowsone", "row1", "blocks1", "orders1", "rowsOne", "reads0", "reads1", "blocksone", "ows01", "rowone", "ows0", "ows2", "rows0", "rows01", "blocks2", "orders01", "readsone", " rowsOne", "reads2", "blocks01", "ows1"], "i": ["p", "it", "o", "iq", "chi", "li", "ui", "id", "ci", "ei", "index", "ai", "x", "ind", "l", "ri", "gi", "I", "f", "ii", "c", "ti", "e", "ait", "ie", "pi", "k", "r", "isin", "j", "v", "ip", "u", "qi", "si", "io", "int", "iu"], "answer2": ["Answer4", "response02", "address02", "issue5", "issue4", "responsetwo", "responseTwo", "response2", "issueTwo", "replytwo", "answertwo", "replyTwo", "reply2", "address2", "addressTwo", "answerTwo", "result5", "addresstwo", "answer02", "issue2", "answer5", "answer4", "result2", "reply02", "Answer2", "AnswerTwo", "Answer5", "result4", "resultTwo"], "rows2": [" rows02", "showstwo", "ows4", "row0", "shows4", "row2", "rows02", "row02", "readstwo", "ows62", "shows62", "row1", "reads02", "reads1", "row4", " rows0", "owstwo", "ows0", "ows2", "rows0", "rows4", " rowstwo", "rowstwo", "shows2", "reads2", "ows02", "rows62", "ows1", "rowtwo", "row62"], "possibilities1": ["pposibilityone", "pposibilities1", "possibility3", "possives3", "possives1", "possibilitiesone", "possibility01", "possitions2", "pposibilities2", "pOSSibilities1", "pOSSibilities3", "possibles1", "pOSSibilities2", "pposibilitiesone", "pposibility2", "possibility2", "possitions01", "pOSSibles3", "pOSSibles2", "possibilityone", "possibilities01", "possibles01", "pOSSibles1", "possitions1", "possibility1", "possitionsone", "pposibility1", "possiblesone", "possibles3", "possibles2", "pposibilities01", "possives2", "possibilities3", "pposibility01"], "possibilities2": ["possities1", "pOSSibilityTwo", "possities2", "possibility4", "possesTwo", "possities4", "pOSSibility4", "pOSSibilities1", "possibles1", "pOSSibilities2", "pOSSibilitiesTwo", "possibilityTwo", "possibility2", "possipes2", "posses2", "possibilities4", "pOSSibilities4", "possipes1", "possibility1", "posses1", "pOSSibility1", "pOSSibility2", "possibles2", "possitiesTwo", "possibilitiesTwo", "posses4"], "numbers": ["Nums", " nefficients", "neums", "cumber", "generodes", " numer", "Nefficients", "Nodes", "Numbers", " nums", "nodes", "Numer", "codes", "cums", "cumer", "pums", "rnums", "numer", "generumbers", "generumer", "rnumbers", "neumer", "rnodes", "pumber", "nums", "neefficients", "cumbers", "number", "Number", "pumbers", "nefficients", "podes", "neumbers", "rnumer", "generums"], "result": ["err", "mate", "response", "comment", "res", "main", "valid", "division", "report", "catch", "current", "our", "su", "folder", "account", "product", "success", "grade", "msg", "search", "message", "default", "successful", "data", "answer", "reason", "final", "ret", "package", "repl", "status", "ise", "output", "description", "rect", "obj", "type", "match", "cash", "summary", "length", "runner", "Result", "winner", "root", "diff", "compl", "effect", "cup", "error", "test", "results", "date", "source"]}}
{"code": " \\n  def generate_matrix(r, c, char):\\n  \tmat = [[char for i in range(c)] for j in range(r)]\\n  \treturn mat\\n  \t\\n  def merge(mat1, mat2):\\n  \tfor i in range(len(mat1)):\\n  \t\tfor j in range(len(mat1[i])):\\n  \t\t\tmat2[i][j] = mat1[i][j]\\n  \treturn mat2\\n  \\n  def solve(r, c, m):\\n  \tif 0 == m:\\n  \t\tmat = generate_matrix(r, c, '.')\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \t\t\\n  \tf = r * c - m\\n  \t\\n  \tif 0 == f:\\n  \t\treturn False\\n  \t\t\\n  \tif 1 == f:\\n  \t\tmat = generate_matrix(r, c, '*')\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \t\t\\n  \tif 1 == min(r, c):\\n  \t\tmat = generate_matrix(r, c, '*')\\n  \t\tfor i in range(f):\\n  \t\t\tmat[0 if 1 == r else i][0 if 1 == c else i] = '.'\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \\n  \tif 2 == min(r, c):\\n  \t\tif (0 != f % 2) or (2 == f):\\n  \t\t\treturn False\\n  \t\tmat = generate_matrix(r, c, '*')\\n  \t\tfor i in range(f // 2):\\n  \t\t\tmat[0 if 2 == r else i][0 if 2 == c else i] = '.'\\n  \t\t\tmat[1 if 2 == r else i][1 if 2 == c else i] = '.'\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \t\t\\n  \tif (3 == r) and (3 == c):\\n  \t\tif (4 == f) or (6 == f):\\n  \t\t\tmat = generate_matrix(r, c, '*')\\n  \t\t\tfor i in range(f // 2):\\n  \t\t\t\tmat[0][i] = '.'\\n  \t\t\t\tmat[1][i] = '.'\\n  \t\t\tmat[0][0] = 'c'\\n  \t\t\treturn mat\\n  \t\tif 8 == f:\\n  \t\t\tmat = generate_matrix(r, c, '.')\\n  \t\t\tmat[2][2] = '*'\\n  \t\t\tmat[0][0] = 'c'\\n  \t\t\treturn mat\\n  \t\treturn False\\n  \t\t\\n  \trows_to_reduce = min(r - 3, m // c)\\n  \tif 0 < rows_to_reduce:\\n  \t\tres = solve(r - rows_to_reduce, c, m - rows_to_reduce * c)\\n  \t\tif False == res:\\n  \t\t\treturn False\\n  \t\tmat = merge(res, generate_matrix(r, c, '*'))\\n  \t\treturn mat\\n  \t\t\\n  \tcols_to_reduce = min(c - 3, m // r)\\n  \tif 0 < cols_to_reduce:\\n  \t\tres = solve(r, c - cols_to_reduce, m - cols_to_reduce * r)\\n  \t\tif False == res:\\n  \t\t\treturn False\\n  \t\tmat = merge(res, generate_matrix(r, c, '*'))\\n  \t\treturn mat\\n  \t\\n  \tmat = generate_matrix(r, c, '.')\\n  \tfor i in range(min(m, r - 2)):\\n  \t\tmat[r - i - 1][c - 1] = '*'\\n  \tif m == r - 1:\\n  \t\tmat[r - 1][c - 2] = '*'\\n  \tmat[0][0] = 'c'\\n  \treturn mat\\n  \t\t\t\\n  \\n  t = int(sys.stdin.readline().strip())\\n  \\n  for i in range(t):\\n  \tprint \"Case #\" + str(i + 1) + \":\"\\n  \\n  \tr, c, m = [int(i) for i in sys.stdin.readline().strip().split()]\\n  \t\\n  \tres = solve(r, c, m)\\n  \t\\n  \tif False == res:\\n  \t\tprint \"Impossible\"\\n  \telse:\\n  \t\tfor i in range(r):\\n  \t\t\tfor j in range(c):\\n  \t\t\t\tsys.stdout.write(res[i][j])\\n  \t\t\tprint\\n", "substitutes": {"r": ["err", "p", "rb", "R", "br", "dr", "ra", "range", "run", "rc", "q", "ar", "ro", "d", "x", "rf", "h", "l", "y", "ru", "cr", "nr", "fr", "right", "e", "ir", "ur", "rr", "k", "rh", "rt", "z", "rg", "rn", "a", "w", "g", "s", "b", "sr", "v", "re", "hr", "u", "pr", "n", "rs", "er", "yr"], "c": ["p", "cu", "ci", "ch", "cc", "col", "cf", "lc", "dc", "nc", "rc", "sc", "q", "d", "ct", "x", "arc", "h", "l", "y", "cp", "cr", "uc", "e", "rec", "ce", "ec", "k", "z", "cin", "cell", "ic", "con", "cm", "a", "w", "cl", "g", "C", "s", "b", "v", "u", "ca", "n", "cs", "mc", "ac", "cy"], "char": ["id", "ci", "ch", "tr", "dc", "rc", "q", "ar", "d", "x", "h", "gi", "cr", "I", "character", "fr", "uc", "e", "k", "cell", "ctr", "cm", "co", "Char", "g", "im", "w", "C", "s", "v", "u", "letter", "int", "cs", "mc"], "mat": [" matrix", "format", "it", "_", "array", "all", "unit", "wt", "mun", "wat", "doc", "plot", "mu", "math", "fm", "struct", "h", "mic", "bm", "ata", "atten", "match", "wa", "cm", "ht", "bt", "min", "mol", "sat", "test", "qt", "mac", "ac", "mot", "app", "comb", "fn", "arr", "opt", "mag", "ha", "mx", "abc", "mode", "map", "dict", "module", "hm", "dat", "ort", "mult", "mt", "mon", "act", "ut", "tab", "ct", "lat", "layer", "token", "MAT", "p", "hat", "ith", "col", "at", "mm", "na", "mar", "file", "man", "Mat", "text", "d", "flat", "mem", "et", "tag", "mit", "num", "md", "graph", "atom", "mitt", "agg", "dim", "loc", "crit", "net", "Matrix", "pat", "stat", "mate", "ma", "mas", "feat", "x", "cont", "hot", "util", "met", "att", "template", "rt", "cat", " Mat", "b", "om", "nat", "material", "mp", "mc"], "i": ["it", "mu", "index", "name", "ai", "h", "y", "iv", "ti", "zi", "key", "uri", "xi", "z", "mi", "v", "u", "ip", "io", "ui", "id", "oi", "ini", "phi", "bi", "ind", "gi", "vi", "yi", "ie", "n", "int", "p", "li", "ci", "ei", "ji", "d", "I", "e", "ment", "di", "ni", "a", "loc", "hip", "si", "o", "ia", "ion", "q", "x", "ri", "l", "ii", "ir", "api", "pi", "k", "g", "ij", "b", "qi", "iu"], "j": ["p", "o", "it", "br", "li", "ci", "ch", "js", "jc", "q", "jp", "ji", "d", "J", "x", "ind", "l", "oj", "y", "h", "ii", "e", "jl", "k", "z", "jj", "a", "ij", "g", "b", "v", "u", "qi", "n", "si", "iu", "uj"], "mat1": [" mat5", "nat2", "mat7", "ha2", "mat10", " mat7", "natr", "m3", "mat0", "m7", "mm0", "Mat2", "Mat1", " matr", "mat5", " mat10", "Mat7", "Mat0", "matr", "m1", "mm3", "mat3", "m5", "nat10", "ha1", "mm2", " mat0", "mm1", "Matr", "m0", "Mat10", "nat1", "Mat3", "ha0", "m2", "ha5"], "mat2": [" mat5", "nat2", "math1", "cat5", "mat0", " matrixall", "mp0", " matrix4", "Mat2", "Mat1", " matrix2", "mat5", "cat1", " mat4", "cat2", "Matall", "mat4", "mp2", "mp1", " mat0", "nat5", "math2", "mp5", "nat1", "matall", " matrix1", " matall", "math5", "cat0", "Mat4"], "m": ["p", "o", "mu", "range", "mm", "fm", "q", "mr", "d", "x", "h", "l", "y", "mad", "e", "M", "z", "k", "cm", "a", "w", "g", "mi", "b", "v", "s", "u", "n", "mc"], "f": ["p", "o", "fp", "all", "cf", "of", "xf", "fm", "q", "function", "d", "x", "rf", "h", "l", "F", "y", "found", "fr", "fit", "fa", "e", "fb", "form", "fc", "tf", "k", "z", "fe", "fs", "a", "w", "g", "s", "b", "v", "u", "fold", "sf", "feed", "n", "fen", "df", "ff"], "rows_to_reduce": ["rows_to_redown", "rows_to_induce", "rows_to_meruction", "rows_to_reduction", "rows_to_indolve", "rows_to_dolve", "rows_to_merown", "rows_to_indown", "rows_to_merolve", "rows_to_meruce", "rows_to_duce", "rows_to_duction", "rows_to_redolve", "rows_to_down", "rows_to_induction"]}}
{"code": " \\n  def read_row():\\n  \ta = int(sys.stdin.readline().strip())\\n  \tfor j in range(a - 1):\\n  \t\tsys.stdin.readline()\\n  \tread_set = set(sys.stdin.readline().strip().split(\" \"))\\n  \tfor j in range(5 - a - 1):\\n  \t\tsys.stdin.readline()\\n  \t\t\\n  \treturn read_set\\n  \\n  \\n  t = int(sys.stdin.readline().strip())\\n  \\n  for i in range(t):\\n  \tprint \"Case #\" + str(i + 1) + \":\",\\n  \\n  \tset1 = read_row()\\n  \tset2 = read_row()\\n  \t\\n  \tintersect = set1.intersection(set2)\\n  \t\\n  \tif 1 == len(intersect):\\n  \t\tprint intersect.pop()\\n  \telif 0 == len(intersect):\\n  \t\tprint \"Volunteer cheated!\"\\n  \telse:\\n  \t\tprint \"Bad magician!\"\\n", "substitutes": {"a": ["p", "offset", "A", "ma", "la", "all", "active", "ia", "sa", "m", "au", "ai", "ea", "x", "am", "l", "y", "f", "alpha", "count", "area", "c", "data", "va", "ata", "aj", "ba", "ta", "ga", "z", "w", "ab", "b", "u", "eta", "ca", "n", "an", "int", "da", "aa", "af"], "j": ["p", "_", "it", "q", "jp", "ai", "J", "x", "h", "y", "f", "l", "str", "e", "jl", "aj", "ie", "job", "k", "z", "jj", "je", "ja", "r", "w", "g", "ij", "dj", "b", "v", "u", "n"], "read_set": ["read64gen", "Read_Set", " read1gen", "read2section", "readfSet", "read_Set", " read1set", "read_section", "read1gen", "readfset", " read1section", "Read_count", "read1set", "read1sc", " read_sc", "read2sc", "read_gen", "read6Set", "read6set", "read_sc", "Read_list", "read_list", " read_section", "readflist", "read6count", "read2gen", "read64sc", "read6list", "read64set", " read_gen", "read_count", "readfcount", "read64section", "read1section", " read1sc", "Read_set", "read2set"], "t": ["p", "it", "o", " T", "at", " total", "ts", "T", "m", "dt", "time", "d", "x", "h", "l", "y", "f", "trace", "c", "ti", "e", "ation", "tt", "trial", "ta", "set", "z", "nt", "type", "r", "w", "g", "s", "b", "v", "u", "ty", "n", "test", "total", "tc"], "i": ["p", "isi", "li", "start", "id", "ci", "index", "m", "ini", "d", "ai", "phi", "x", "ind", "y", "l", "f", "I", "ii", "c", "e", "ie", "pi", "di", "xi", "k", "z", "type", "b", "u", "n", "si", "int", "ih", "iu"], "set1": ["caseone", "set01", "etOne", "setOne", "setone", "et1", "caseOne", "et01", "case2", " set01", "case1", "et2", "case3", "etone", " setone", "case01", "set3", " setOne", " set3", "et3"], "set2": ["readTwo", "sectionTwo", " set62", "set62", "section62", "section02", "read62", "et1", "set0", "set02", "setTwo", " set0", "read1", "section1", "et2", "et02", "et0", " set02", "read2", " setTwo", "section0", "section2"], "intersect": ["iterct", "interect", "artsection", "oversection", "preect", "interct", "artcept", "partcept", "intercept", "partsect", "iterect", "arcept", "arect", "partsection", "partect", "overect", "prect", "intersection", "arsect", "artsect", "arsection", "presect", "itersection", "overcept", "itersect", "Intersection", "Intercept", "presection", "Intersect", "oversect", "Interect", "artect", "Interct"]}}
{"code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'\\n  \\n  \\n  \\n  def solve_one_case (R,C,M):\\n          l = []\\n          for i in range(R):\\n              for j in range(C):\\n                  l.append((i,j))\\n  \\n          empty_mat = []\\n          for i in range(R):\\n              empty_mat.append(['.']*C)\\n  \\n          found = False\\n  \\n          assert (0,0) in l\\n          l = l[1:]\\n          l = l[::-1]\\n          assert (0,0) not in l\\n          \\n          output = ''\\n          \\n          for mine_placement in itertools.combinations(l,M):\\n              mat = deepcopy(empty_mat)\\n              for cell in mine_placement:\\n                  mat[cell[0]][cell[1]] = '*'\\n              if isOneClick(mat, R, C, M):\\n                  mat[0][0] = 'c'\\n                  for line in mat:\\n                      output += ''.join(line) + '\\n'\\n                  found = True\\n                  return output\\n              \\n          if not found:\\n              return 'Impossible\\n'\\n          \\n          assert ValueError()\\n          \\n  def solve (f_in, f_out):\\n      T = int(f_in.readline())\\n      for testcase in range(1,T+1):\\n          line = f_in.readline()\\n          R,C,M = [int(q) for q in line.split()]\\n          print (testcase,R,C,M)\\n  \\n          output = solve_one_case (R,C,M)\\n          f_out.write('Case #' + str(testcase) + ':\\n')\\n          f_out.write(output)\\n  \\n          \\n  \\n  \\n  def isOneClick (mat, R, C, M):\\n  \\n      mat_cpy = deepcopy(mat)\\n      oneclickcells = [(0,0)]\\n      while oneclickcells:\\n          node = oneclickcells.pop()\\n          mat_cpy[node[0]][node[1]] = 'v'\\n          if noNearbyMines(mat_cpy,node):\\n              oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))\\n  \\n      return sum([l.count('.') for l in mat_cpy]) == 0\\n      \\n  \\n  def getNearbyUnvisited(mat, node):\\n      R = len(mat)\\n      C = len(mat[0])\\n      deltas_r = [0]\\n      deltas_c = [0]\\n      if node[0] > 0:\\n          deltas_r.append(-1)\\n      if node[1] > 0:\\n          deltas_c.append(-1)\\n      if node[0] < R-1:\\n          deltas_r.append(1)\\n      if node[1] < C-1:\\n          deltas_c.append(1)\\n  \\n      ret_list = []\\n      for delta_r in deltas_r:\\n          for delta_c in deltas_c:\\n              next_node = (node[0]+delta_r, node[1] + delta_c)\\n              if mat[next_node[0]][next_node[1]] not in ['*','v']:\\n                  ret_list.append((next_node[0],next_node[1]))\\n  \\n      return ret_list\\n  \\n  def noNearbyMines(mat,node):\\n      R = len(mat)\\n      C = len(mat[0])\\n      deltas_r = [0]\\n      deltas_c = [0]\\n      if node[0] > 0:\\n          deltas_r.append(-1)\\n      if node[1] > 0:\\n          deltas_c.append(-1)\\n      if node[0] < R-1:\\n          deltas_r.append(1)\\n      if node[1] < C-1:\\n          deltas_c.append(1)\\n  \\n      for delta_r in deltas_r:\\n          for delta_c in deltas_c:\\n              if mat[node[0] + delta_r][node[1] + delta_c] == '*':\\n                  return False\\n      return True\\n      \\n  def main_run():\\n      filenames = [x for x in os.listdir (directory)]\\n      filenames = [x for x in filenames if x.endswith('.in')]\\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\\n      chosen_filename =  sorted(l1)[-1][1][:-3]\\n  \\n      print ('Directory : ', directory)\\n      print ('Chosen Filename : ',chosen_filename)\\n      print()\\n      print ('Start : ', time.ctime())\\n      print()\\n      \\n      f_in = open(directory+chosen_filename+'.in')\\n      f_out = open(directory+chosen_filename+'.out', 'w')\\n      solve(f_in,f_out)\\n      f_in.close()\\n      f_out.close()\\n  \\n      print ()\\n      print ('End : ', time.ctime())\\n  \\n  \\n  main_run()\\n  \\n", "substitutes": {"directory": ["desc", "prefix", "files", "unit", "command", "language", "path", "config", "Directory", "document", "entry", "d", "tree", "cont", "dir", "uri", "mode", "description", "module", "cat", "comments", "pattern", "generated", "content", "page", "folder", "home", "filename"], "R": ["_", "A", "WR", "all", "MR", "RA", "RR", "RN", "K", "Rs", "E", "RH", "DR", "Rh", "RS", "Re", "Res", "ed", "RM", "Range", "id", "JR", "B", "example", "D", "G", "Y", "RL", "H", "pos", "SR", "CR", "S", "AR", "Line", "d", "LR", "F", "X", "I", "RW", "IR", "NR", "RO", "input", "U", "V", "RG", "Q", "W", "P", "L", "BR", "r", "GR", "g", "s", "pattern", "N", "RC"], "C": ["CC", "Z", "P", "O", "Cr", "CR", "A", "SC", "CW", "CS", "S", "B", "Cs", "CI", "YC", "JC", "DC", "L", "CL", "Code", "CM", "AC", "X", "F", "K", "I", "Sc", "c", "CU", "E", "CT", "CN", "VC", "D", "G", "NC", "EC", "MC", "U", "Y", "CA", "V", "H", "Cu", "CE", "Size", "Q", "KC", "W", "N", "CV", "Con"], "M": ["MQ", "Z", "P", "O", "LM", "Memory", "MF", "S", "MN", "AM", "B", "range", "MR", "Ms", "m", "J", "L", "VM", "CL", "CM", "F", "X", "I", "DM", " L", "Man", "K", "E", "ME", " m", "MM", "MU", "D", "G", "MS", "MD", "MC", "r", "U", "Y", "V", "H", "v", "EM", "Q", "NM", "W", "N", "MX", "n", "RM", "FM"], "l": ["pl", "p", "o", "it", "la", "li", "all", "lf", "ls", "long", "list", "lines", "lin", "lc", "len", "ly", "m", "lit", "ll", "d", "L", "ml", "ul", "f", "rl", " L", "c", "e", "lv", "t", "ln", "fl", "el", "nl", "z", "acl", "r", "kl", "dl", "g", "left", "lp", " lines", "s", "b", "ol", "v", "u", "loc", "le", "n", "sl", "sel", "lis"], "i": ["p", "it", "ui", "li", "start", "id", "ci", "m", "ini", "d", "ai", "bi", "ind", "ri", "f", "I", "y", "ii", "c", "ti", "e", "yi", "ie", "pi", "xi", "di", "k", "r", "ni", "a", "b", "v", "u", "ip", "qi", "n", "si", "io", "int", "iu"], "j": ["p", "li", "js", "jc", "jp", "m", "ji", "d", "J", "f", "y", "I", "c", "ii", "jl", "ie", "k", "z", "jj", "r", "ja", "ij", "g", "b", "v", "jam", "n"], "empty_mat": ["empty67mas", "white_math", "empty_mas", "blank_match", "empty_list", "empty_batch", "empty_match", "empty67math", " empty_tab", "blank_all", "empty_mm", "white_mat", "empty_tab", "empty_format", " empty_mm", " empty_format", "white_batch", "blank_mat", "empty_all", "empty67mat", "blank_list", "white_mas", "empty67batch", "empty_math"], "found": ["defined", "filled", "new", " find", " Found", "broken", "still", "expected", "ll", "printed", "missing", "confirmed", "f", "search", "count", "given", "Found", "successful", "default", "finding", "built", "Find", "temp", "sect", "fl", "used", "like", "form", "fall", "z", "find", "fe", "lost", "fixed", "left", "failed", "finder", "error", "loaded", "finished", "now", "old", "source", "matched"], "output": ["format", "response", "all", "unit", "command", "image", "language", "doc", "document", "shell", "struct", "dot", "lib", "display", "debug", "control", "job", "plain", "generation", "generated", "xml", "style", "comment", " Output", "full", "expression", "version", "console", "example", "out", "fn", "end", "reason", "module", "summary", "resource", "n", "result", "layer", "written", "config", "log", "file", "text", "message", "str", "ln", "graph", "input", "left", "content", "production", "new", "current", "L", "write", "target", "connection", "analysis", "Output", "value", "model", "complete", "string", "letter"], "mine_placement": ["mine_Placing", "mine_splacing", "mine_Placements", "mine_expluster", "mine_Placement", "mine_explacements", "mine_replignment", "mine_plignment", "mine_placing", "mine_Pluster", "mine_Plignment", "mine_replacing", "mine_placements", "mine_repluster", "mine_splacement", "mine_replacement", "mine_replacements", "mine_explacing", "mine_splignment", "mine_explacement", "mine_pluster", "mine_splacements"], "mat": ["format", "array", "unit", "wt", "list", "plot", "document", "math", "dot", "h", "position", "atten", "nt", "match", "wa", "reg", "mol", "test", "qt", "mac", "mot", "m", "phi", "fn", "c", "arr", "table", "map", "dict", "module", "hm", "mult", "mt", "act", "n", "ut", "tab", "ct", "layer", "lat", "p", "hat", "lin", "col", "at", "config", "mm", "na", "file", "man", "Mat", "text", "flat", "grid", "temp", "md", "graph", "atom", "dim", "loc", "net", "Matrix", "pat", "stat", "ma", "la", "dom", "feat", "ml", "lab", "att", "cat", "pot", "nat", "material", "mp"], "cell": ["element", "p", "unit", "case", "contact", "label", "cc", "lic", "list", "group", "col", "lc", "Cell", "shell", "entry", "cel", "character", "c", "edge", "ell", "key", "el", "ce", "k", "cat", "match", "cle", "column", "co", "cl", "object", "field", "row", "v", "cells", "char", "model", "call", "letter", "word", "layer", "cy"], "line": ["lf", "li", "unit", "case", "label", "list", "lines", "link", "lin", "col", "lc", "run", "len", "log", "range", "shell", "name", "file", "Line", "entry", "live", "look", "header", "text", "point", "out", "ml", "data", "str", "lo", "e", "code", "chain", "ln", "frame", "nl", "lined", "LINE", "input", "match", "inline", "cycle", "column", "left", "row", "model", "sync", "string", "block", "page", "n", "int", "section", "error", "word", "layer", "source"], "f_in": ["f64out", "sf_in", "fLogout", "f__in", "fLogins", "sf_resource", "f64inner", "fLoginner", "sf_ins", "f64in", "sf_out", "f2inner", "cf_out", "f_ins", "fLogin", "f64ins", "f__inner", "f_In", "f__out", "sf_In", "sf_inner", "cf_ins", "f__ins", "cf_inner", "f2ins", "f_resource", "f2in", "cf_in", "f2out", "f_inner"], "f_out": ["f__io", "firmengine", "f_engine", " f2output", "f__in", "f__err", "c_err", "f2output", "fiddlein", "f_err", "c_out", "fiddleout", "c_io", "f_output", "f_temp", "firmtemp", "f_io", "f2io", " f_io", "f__out", " f_output", "fiddleengine", "firmin", " f2out", "f2err", " f2in", "c_in", " f2io", "firmout", " f_temp", "f2in", " f_engine", "f2out", "fiddletemp"], "T": ["Z", "TT", "P", "O", "Length", "S", "WT", "B", "Type", "TA", "L", "F", "X", "DT", "K", "I", "TS", "t", "Total", "CT", "E", "TN", "Ts", "TR", "D", "U", "Y", "V", "H", "Q", "W", "N", "TI", "Time", "NT"], "testcase": ["testtype", "testnce", "showcase", "showtype", "testCase", "Testtype", "Testcase", "xtcase", "catchsequence", "fitnumber", "estcase", "testnumber", "xtCase", "xtnumber", "testtrial", "esttrial", "Testsequence", "catchtype", "estCase", "testposition", "testsequence", "Testtrial", "xtposition", " testCase", "fitCase", "showsequence", " testposition", "estnce", "catchcase", "exampletrial", "Testnce", "examplecase", "catchCase", "examplence", "exampleCase", " testnumber", "fitposition", "fitcase", "showCase", "TestCase"], "q": ["p", "iq", "qu", "qq", "query", "sq", "id", "comment", " question", "col", " query", "qa", " qu", "seq", " Q", "name", "d", "y", "dq", "quant", "question", "e", "t", "num", "k", "z", "type", "r", "match", "a", "w", "g", " seq", "row", "b", "v", "s", "char", "pattern", "Q", "n", "ct", "qt"], "mat_cpy": ["mat_fpy", "mat_Cpu", "mat_fPy", "mat_cpe", "mat_cpsy", "mat_fpu", "mat_fopy", "mat_Copy", "mat_cps", "mat_Cpc", "mat_Cpsy", "mat_ppe", "mat_Cpy", "mat_Cpes", "mat_locpes", "mat_ncpsy", "mat_ccpe", "mat_cpc", "mat_lopy", "mat128cpy", "mat_Cpython", "mat_pPy", "mat_cpes", "mat_fpes", "mat_cachepe", "mat_ncpe", "mat_locpc", "mat_lpe", "mat_Cps", "mat_ncpy", "mat_fpc", "mat_lp", "mat_fps", "mat_Cpe", "mat_cachepsy", "mat_locpy", "mat_Cp", "mat128cpe", "mat_cPy", "mat_ncpython", "mat_ccps", "mat128ccpu", "mat_locpe", "mat_ccpy", "mat128cps", "mat_lpy", "mat_fp", "mat_cpython", "mat_fpe", "mat_ccpu", "mat_copy", "mat_cp", "mat_cachepython", "mat_ppy", "mat_CPy", "mat_cachepy", "mat128ccpe", "mat128ccps", "mat128cpu", "mat_popy", "mat_cpu", "mat128ccpy"], "oneclickcells": ["onecrossells", " onechipcells", "oneleftcell", "onechipcats", "oneclickrows", " oneswitchcases", "onepixelcats", " oneclickcases", "onebuttoncells", "onefocuscases", " oneswitchells", "onechipells", "onecrosscases", "oneClicklines", "oneswitchcases", "oneClickcells", "onebuttonells", " oneclicklines", "oneclickstates", "oneswitchrows", "oneswitchcells", "oneclickholes", " oneclickholes", "oneclickcell", " onebuttonells", "oneswitchells", " onechipcats", " oneswitchcells", " oneswitchrows", "onechipcs", " oneclickcs", "oneClickcell", "oneleftcells", "onechipcells", " onebuttonholes", " oneclickstates", "onefocusells", "oneclickcases", "oneClickstates", "oneclickcats", "onepixelcells", "oneclicklines", "onefocuscells", "onecrossrows", "oneswitchholes", " onebuttoncells", "onechiplines", "onefocusrows", "onebuttonholes", " oneclickcell", " oneclickells", "oneClickcats", "onepixellines", "oneclickcs", "onechipholes", "onecrosscells", " onebuttoncs", "onebuttoncs", " oneclickcats", " oneclickrows", " onechiplines", "oneleftstates", "oneclickells", "oneswitchcs"], "node": ["element", "leaf", "gen", "stroke", "parse", "child", "comment", "op", "id", "link", "label", "valid", "path", "index", "ode", "event", "document", "name", "live", "nn", "scene", "un", "parent", "missing", "card", "f", "tree", "connection", "Node", "day", "edge", "core", "e", "enc", "seed", "cut", "ha", "package", "key", "none", "mor", "location", "component", "post", "cdn", "route", "part", "input", "dest", "set", "object", "anch", "row", "load", "model", "root", "remote", "loc", "N", "block", "n", "local", "word", "layer", "source"]}}
{"code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/A/'\\n  \\n  \\n  \\n  def solve (f_in, f_out):\\n      T = int(f_in.readline())\\n      for testcase in range(1,T+1):\\n          \\n          c1 = int(f_in.readline())\\n          l1 = []\\n          for i in range(4):\\n              l1.append(f_in.readline())\\n          \\n          c2 = int(f_in.readline())\\n          l2 = []\\n          for i in range(4):\\n              l2.append(f_in.readline())\\n  \\n          d1 = l1[c1-1].split()\\n          d2 = l2[c2-1].split()\\n  \\n          foundFlag = False\\n          chosenCard = None\\n          badMagician = False\\n          for card in d1:\\n              if card in d2:\\n                  if not foundFlag:\\n                      foundFlag = True\\n                      chosenCard = card\\n                  else:\\n                      badMagician = True\\n  \\n          f_out.write('Case #' + str(testcase) + ': ')\\n          if badMagician:\\n              f_out.write('Bad magician!\\n')\\n          elif not foundFlag:\\n              f_out.write('Volunteer cheated!\\n')\\n          else:\\n              f_out.write(chosenCard + '\\n')\\n  \\n  \\n  \\n  \\n  def main_run():\\n      filenames = [x for x in os.listdir (directory)]\\n      filenames = [x for x in filenames if x.endswith('.in')]\\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\\n      chosen_filename =  sorted(l1)[-1][1][:-3]\\n  \\n      print ('Directory : ', directory)\\n      print ('Chosen Filename : ',chosen_filename)\\n      print()\\n      print ('Start : ', time.ctime())\\n      print()\\n      \\n      f_in = open(directory+chosen_filename+'.in')\\n      f_out = open(directory+chosen_filename+'.out', 'w')\\n      solve(f_in,f_out)\\n      f_in.close()\\n      f_out.close()\\n  \\n      print ()\\n      print ('End : ', time.ctime())\\n  \\n  \\n  main_run()\\n", "substitutes": {"directory": ["duration", "prefix", "timeout", "collection", "service", "command", "language", "division", "path", "config", "Directory", "document", "category", "expression", "machine", "filename", "system", "python", "volume", "office", "d", "space", "password", "tree", "message", "connection", "environment", "dir", "package", "archive", "mode", "location", "output", "description", "source", "template", "module", "project", "library", "selection", "whatever", "direct", "window", "drive", "tty", "home", "storage", "root", "number", "direction", "resource", "database", "distance", "minute", "folder", "picture", "binary", "definition", "manager", "application"], "f_in": ["f_inn", "fLogins", "sf_out", "fLogin", "f__inner", "sf_inn", "f__out", "f_In", "f__IN", "fLogout", "f__in", "f_IN", "sf_int", "f8nin", " f_In", "sf_inner", "rf_nin", "f8out", " f_ins", "sf_in", "f8ins", "fLoginside", "f_bin", " f_inner", "rf_bin", "f8in", "f__inn", "sf_init", "f_again", "f__In", "sf_nin", "rf_out", " f_nin", " f_again", "sf_ins", "f_init", "sf_IN", "f_ins", "f_nin", " f_inside", "f_int", "rf_in", "f__init", "f_inner", "f_inside"], "f_out": ["fadeagain", "f_err", "fadew", "fockagain", "f2again", "c_outs", "f__out", "f__again", "c_again", "f__in", "fockout", " f_w", "f__outs", " f_OUT", "f__Out", "f2in", "f2out", "f_Out", " f_Out", "c_out", "f__OUT", "f_OUT", "f_again", " f_err", "fockouts", "f2err", " f_again", "f_w", "fadein", "c_in", "fadeout", "f_outs", "fockin"], "T": ["Test", "TT", "P", "O", "A", "R", "Length", "S", "B", "time", "L", "F", "X", "DT", "I", "t", "E", "Total", "TN", "IP", "trial", "D", "M", "G", "Y", "C", "V", "H", "Q", "W", "N", "NUM", "TI", "Time"], "testcase": [" testcode", "newc", "newcases", "testingCase", "newcase", "testCase", "testingsection", "Testcase", "matchc", " testc", "testcases", "matchsection", "Testtest", "newcode", "testtest", "testc", "matchcases", " testcases", "matchCase", "matchcase", "testingtest", "testsection", "testingcase", "testcode", "Testsection", "matchtest", "matchcode", "TestCase"], "c1": ["C2", "c0", " c3", " c0", "lc1", "lc2", "c3", " cOne", "cOne", "C1", "COne", "C3", "l0", "lc0", "l3", "lOne", "lcOne"], "l1": ["lnfirst", "t61", "r4", "Lanks", "l001", " lanks", "c0", "L001", "li1", "lc1", "d61", "c001", " l0", "ln0", " l61", "lc2", "t1", "li0", "c3", "cfirst", "L2", "ln1", "r2", "li001", "r1", "L0", "L4", "l4", "rfirst", "lc4", "lcfirst", "l0", "ln3", "d0", "t2", "l3", "L1", "li2", "t0", "lanks", "lianks", "dfirst", "d3", "Lfirst", "lfirst", "l61"], "i": ["p", "it", "li", "id", "ci", "index", "ai", "ind", "l", "h", "f", "I", "ii", "c", "ti", "e", "ie", "pi", "di", "z", "r", "isin", "a", "g", "j", "b", "v", "ip", "u", "n", "io", "int", "iu"], "c2": ["n02", "cs2", "n2", "ceTwo", "cstwo", "cTwo", "n0", "l96", "ctwo", "c0", "ce5", " c0", " c5", "c5", "n96", "c02", " ctwo", " c02", " cTwo", "cs5", " c96", "csTwo", "c96", "cetwo", "l0", "ce2", "l02"], "l2": ["li02", "d6", "el2", "i1", "el6", "d02", "ctwo", "rl4", "i2", " ltwo", "isecond", "el02", "c3", "li3", " l4", "l6", "li6", " lsecond", "csecond", "rltwo", "dsecond", "l4", "lsecond", "i3", "l3", "l02", "li2", "ltwo", "rl2", "rlsecond", "c4", "d3", "el3"], "d1": ["f3", "ld2", "f4", "ld1", "ld4", "c3", "ldOne", "f2", "cOne", "l4", "dOne", "f1", "lOne", "l3", "d4", "c4", "d3"], "d2": ["l8", "n2", "cTwo", "ctwo", "c7", " dtwo", "n7", "dtwo", "d7", " d8", "nTwo", " dTwo", "dTwo", " d4", "c8", "d8", "ltwo", "d4", "n4", "c4", " d7"], "foundFlag": ["givenflag", "givenFlags", " Foundflag", "foundFlags", "FoundFlag", "findCard", " foundflag", "findFlag", "foundCard", " foundCard", "givenFlag", "FoundCard", "FoundFlags", " foundFlags", "foundflag", " FoundFlag", "Foundflag"], "chosenCard": ["chosedLine", "choinLine", "choserCard", "corosenCase", "chainedCat", "chosenCat", " chainedChar", "corosercard", " ChosenCat", " ChosenLine", " chainedCat", "chosedFlag", "corosenCard", " chosenChar", "chribedChar", "chosercard", "chribedCat", " ChoinLine", "chribedFlag", "choinCat", "chosenCase", "chribedCase", " ChoinCard", "chosenFlag", "chribedCell", " chainedCell", "chrawnLine", "coroserCase", "choincard", "chosenChar", " chainedCard", "chosencard", " chosenCell", "chainedChar", " Chosencard", " ChoinCat", " Choincard", "chribedcard", "chainedCard", "chosenLine", "chrawnCat", "chosenCell", " chosenCat", "choinCard", "choserCase", " ChosenCard", "choinChar", "chribedCard", "coroserFlag", "chrawncard", "chosedcard", "chrawnCard", "chosedCard", "corosenFlag", "coroserCard", "chosedCase", "chainedCell", "corosencard", "chosedCat", "choserFlag", "choinCell"], "badMagician": ["badTechnician", "badMatick", "BadMagian", "badMericator", "badMAGician", "badmagicator", "badMaticians", "badMerician", "Badmagicians", "badmagicians", "BadMagician", "badMerick", "badmagian", "BadMagicians", "badmagician", "Badmagick", "badMatian", "Badmagician", "badMagnian", "badTechnicians", "badTechnick", "badMagnicator", "badMagnician", "badMericians", "badTechnian", "badMatician", "badMagicians", "badMagnicians", "badmagick", "badMagicator", "badMAGicians", "badMagian", "BadMagicator", "badMerian", "Badmagian", "BadMagick", "badMagick", "Badmagicator", "badMAGick", "badMAGian"], "card": ["defined", "Na", "A", "comment", "div", "id", "dom", "cards", "list", "ci", "valid", "cf", "category", "Default", "du", "man", "any", "null", "d", "arc", "coord", "cont", "custom", "X", "character", "default", "day", "ward", "no", "none", "draw", "D", "cell", "cart", "check", "match", "cat", "co", "viol", "cd", "C", "Case", "compl", "char", "Card", "ard", "yes", "crit", "void", "gu", "word", "coll"], "filenames": ["filennations", " filenuments", "filrenumbers", "filernamed", "filfenums", "filennews", "filonenews", "fillenumbers", "filrenamed", "fileenames", " filonenumbers", "filenations", "ilenumbers", " filonenews", "filfenumbers", " filenumbers", "ilennames", " filenAMES", "filonenames", "filENAMES", "filvenaming", "ilenames", "filENames", "filonenamed", "fileernumbers", "fillenums", "filenuments", " filonrams", "filonenaming", "filfenations", "fileenaming", "filtenAMES", "ilenums", "filennums", "filenAMES", "filenumbers", "ilennumbers", "filernaming", "filENrams", "filenews", "filenums", " filenews", "filenrams", "filonuments", "filtenames", "filvenames", "filenaming", "filtenuments", "ilenations", "filENuments", "filenamed", "filonrams", "fileernamed", "filtenrams", " filonenamed", " filenamed", " filenrams", "filfenames", "filonenumbers", "fillenations", "filonAMES", "fileernames", "filonames", "fillenames", "filvenamed", "filvenumbers", "filennumbers", "fileenumbers", "filennamed", "fileenamed", " filonuments", "ilennums", "filennames", "filrenews", "filernumbers", " filonAMES", "ilennations", " filonenames", "filrenames", "fileernaming", "filernames", " filonames"], "x": ["ph", "_", "array", "ch", "ix", "ax", "path", "index", "name", "time", "h", "xa", "ex", "y", "code", "rax", "xi", "z", "w", "xy", "v", "xxxx", "xml", "sex", "xb", "test", "cross", "xxx", "m", "fx", "ux", "c", "opt", "data", "php", "mx", "xd", "xc", "rx", "xp", "ctx", "n", "ct", "filename", "p", "ci", "file", "com", "d", "X", "f", "wx", "e", "t", "xes", "xe", "rex", "xs", "a", "work", "content", "xx", "prefix", "dx", " xx", "xf", "q", "ext", "lex", "xt", "l", "search", "hex", "www", "nex", " X", "co", "g", "string", "upload", "tx"], "chosen_filename": ["choted_name", "chosen_directory", "choted_string", "chosen_name", "chosing_Filename", "chitched_directory", "chosenPFilename", "chosen_string", "choseningfile", "chosen2name", "choseningname", "chotedPfilename", "choseningFilename", "chosen_file", "chosing_name", "chosenPstring", "choted_Filename", "choted_filename", "chosen2Filename", "chotedPFilename", "chosing_file", "choseningfilename", "chosen_Filename", "chosenPname", "chitched_filename", "chosen2file", "chitched_template", "chosen2filename", "chosenPfilename", "chotedPname", "chosen_path", "chotedPstring", "chosen_template", "chosing_filename", "chitched_path"]}}
{"code": " \\n  \\n  FREE = '.'\\n  BOMB = '*'\\n  CLICK = 'c'\\n  \\n  \\n  class Board:\\n  \\n  \tdef __init__(self, R, C, M):\\n  \t\tself.initial_M = M\\n  \t\tself.R = R\\n  \t\tself.C = C\\n  \t\tself.M = M\\n  \t\tself.matrix = [[FREE for c in range(C)] for r in range(R)]\\n  \t\tself.endx = len(self.matrix[0])\\n  \t\tself.endy = len(self.matrix)  # 0 < R * C\\n  \t\tself.startx = 0\\n  \t\tself.starty = 0\\n  \\n  \tdef fill_row(self, row):\\n  \t\tfor c in self.range_active_cols:\\n  \t\t\tself.matrix[row][c] = BOMB\\n  \t\tself.starty += 1\\n  \t\tself.M -= self.active_cols\\n  \\n  \tdef fill_col(self, col):\\n  \t\tfor r in self.range_active_rows:\\n  \t\t\tself.matrix[r][col] = BOMB\\n  \t\tself.startx += 1\\n  \t\tself.M -= self.active_rows\\n  \\n  \tdef pprint(self):\\n  \t\tfor row in self.matrix:\\n  \t\t\tfor cell in row:\\n  \t\t\t\tprint(cell, end='')\\n  \t\t\tprint()\\n  \\n  \t@property\\n  \tdef active_rows(self):\\n  \t\treturn self.endy - self.starty\\n  \\n  \t@property\\n  \tdef active_cols(self):\\n  \t\treturn self.endx - self.startx\\n  \\n  \tdef optimize(self):\\n  \t\twhile 1:\\n  \t\t\tif (self.active_cols <= self.active_rows\\n  \t\t\t\t\tand self.active_cols <= self.M):\\n  \t\t\t\tself.fill_row(self.starty)\\n  \t\t\telif (self.active_rows < self.active_cols\\n  \t\t\t\t\tand self.active_rows <= self.M):\\n  \t\t\t\tself.fill_col(self.startx)\\n  \t\t\telse:\\n  \t\t\t\tbreak\\n  \\n  \t@property\\n  \tdef range_active_cols(self):\\n  \t\treturn range(self.startx, self.endx)\\n  \\n  \t@property\\n  \tdef range_active_rows(self):\\n  \t\treturn range(self.starty, self.endy)\\n  \\n  \tdef is_free(self, row, col):\\n  \t\treturn self.matrix[row][col] == FREE\\n  \\n  \tdef place_bomb(self):\\n  \t\tfor row in self.range_active_rows:\\n  \t\t\tfor col in self.range_active_cols:\\n  \t\t\t\tif (self.is_free(row, col) \\n  \t\t\t\t\t\tand row + 2 < self.R\\n  \t\t\t\t\t\tand col + 2 < self.C):\\n  \t\t\t\t\tself.matrix[row][col] = BOMB\\n  \t\t\t\t\tself.M -= 1 \\n  \t\t\t\t\treturn True\\n  \t\tfor col in self.range_active_cols:\\n  \t\t\tfor row in self.range_active_rows:\\n  \t\t\t\tif (self.is_free(row, col)\\n  \t\t\t\t\t\tand row + 2 < self.R\\n  \t\t\t\t\t\tand col + 2 < self.C):\\n  \t\t\t\t\tself.matrix[row][col] = BOMB\\n  \t\t\t\t\tself.M -= 1\\n  \t\t\t\t\treturn True\\n  \t\treturn False\\n  \\n  \tdef mark_click(self):\\n  \t\tself.matrix[-1][-1] = 'c'\\n  \\n  \tdef win_condition(self):\\n  \t\tclick_row = len(self.matrix) - 1\\n  \t\tclick_col = len(self.matrix[0]) - 1\\n  \t\tif (click_col - 1 >= 0\\n  \t\t\t\tand not self.is_free(click_row, click_col - 1)):\\n  \t\t\treturn False\\n  \\n  \t\tif (click_row - 1 >= 0\\n  \t\t\t\tand not self.is_free(click_row - 1, click_col)):\\n  \t\t\treturn False\\n  \\n  \t\tif (click_row -1 >= 0\\n  \t\t\t\tand click_col -1 >= 0\\n  \t\t\t\tand not self.is_free(click_row - 1, click_col - 1)):\\n  \t\t\treturn False\\n  \t\t\\n  \t\treturn True\\n  \\n  \tdef win_cond2(self):\\n  \t\tif self.initial_M + 1 == self.C * self.R:\\n  \t\t\treturn True\\n  \t\treturn False\\n  \\n  \tdef solve(self):\\n  \t\tself.optimize()\\n  \t\twhile self.M > 0 and self.place_bomb():\\n  \t\t\tpass\\n  \t\tif self.M == 0 and (self.win_condition() or self.win_cond2()):\\n  \t\t\tself.mark_click()\\n  \t\t\tself.pprint()\\n  \t\telse:\\n  \t\t\tprint('Impossible')\\n  \\n  \\n  def read_case(f):\\n  \treturn map(int, f.readline().split())\\n  \\n  \\n  def main():\\n  \tfn = sys.argv[1]\\n  \twith open(fn, encoding='utf-8') as f:\\n  \t\tncases = int(f.readline())\\n  \t\tfor case in range(1, ncases + 1):\\n  \t\t\tR, C, M = read_case(f)\\n  \t\t\tprint('Case #{}:'.format(case))\\n  \t\t\tb = Board(R, C, M)\\n  \t\t\tb.solve()\\n  \\n  \\n  def main1():\\n  \tb = Board(2, 1, 1)\\n  \tb.solve()\\n  \\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "substitutes": {"FREE": ["ARE", "DER", "FE", "WARN", "ANY", "ARM", "ERROR", "UN", "MAX", "GAME", "KER", "RA", "OK", "random", "RE", "F", "X", "ER", "WER", "NEW", "UM", "END", "choice", "GE", "NOR", "REM", "FA", "CON", "NR", "ME", "ONE", "DE", "VALUE", "CO", "RO", "D", "ERE", "FW", "FIR", "NE", "ORE", "WARNING", "FR", "NAME", "free", "W", "EW", "NUM", "DEM", "Free", "MW", "DEF", "MON"], "BOMB": [" BOUNDE", " BOWE", "BOME", " BCOMB", " BOWb", " BOUNDB", " BCOMb", "BCOME", " BOMb", " BOUNDBER", "BCOMB", " BOWBER", "BCOMBER", "BOMBER", " BCOME", " BCOMBER", " BOWB", " BOUNDb", "BOMb", " BOME", "BCOMb", " BOMBER"], "CLICK": [" CLEX", "clICAL", "CLEX", "clEX", " CLACK", "SLACK", "CLACK", " CLICAL", "clACK", "SLICAL", "clICK", "SLEX", "CLICAL", "SLICK"], "self": ["me", "extra", "node", "case", "force", "user", "qa", "proxy", "event", "player", "parent", "default", "both", "shape", "part", "w", "this", "plus", "high", "er", "style", "worker", "Self", "full", "misc", "func", "system", "m", "view", "python", "np", "params", "out", "data", "args", "G", "module", "object", "utils", "hand", "instance", "load", "pos", "ctx", "n", "result", "layer", "results", "manager", "p", "comp", "config", "spec", "man", "function", "d", "per", "X", "f", "host", "client", "e", "wrapper", "work", "cl", "non", "use", "error", "private", "mod", "P", "parse", "show", "q", "scope", "x", "base", "access", "add", "connection", "other", "cache", "game", "k", "co", "static", "g", "context", "members"], "R": ["P", "A", "CR", "S", "B", "MR", "RA", "T", "RE", "L", "RR", "F", "X", "RN", "RP", "ER", "Rs", "E", "NR", "RH", "Right", "DR", "RO", "D", "G", "U", "Y", "GR", "RS", "V", "RT", "RG", "W", "N", "RF", "SR", "RM"], "C": ["CC", "P", "O", "A", "ERC", "CR", "S", "B", "COR", "Cs", "CI", "T", "DC", "L", "CL", "CM", "F", "X", "K", "I", "CV", "Ch", "CU", "E", "CNN", "CO", "VC", "D", "G", "EC", "MC", "U", "Y", "H", "V", "Co", "Cu", "Cor", "W", "N", "CE"], "M": ["P", "O", "LM", "A", "MF", "S", "Manager", "MN", "B", "AM", "MO", "RA", "T", "m", "J", "L", "MA", "CM", "F", "X", "I", "Man", "MAN", "Mor", "CU", "E", "MM", "G", "D", "MH", "MC", "MD", "U", "Y", "V", "H", "Q", "MX", "W", "N", "RM"], "initial_M": ["final_M", "initial_m", "initial_C", "final_m", "final_C", "initial_R", "final_R"], "matrix": ["Matdata", "Matrices", "matrices", "mituration", "latdata", "mitangle", "Matfix", "MatMatrix", " matrices", "mitagonal", "mitfix", " maturation", "latMatrix", "mitdata", "Matangle", "maturation", "Matrix", "latrix", "matagonal", "mitrix", "matdata", " matfix", " matagonal", "mitrices", "latrices", " matMatrix", " matangle", "Maturation", "matMatrix", "Matagonal", "matfix", "mitMatrix", "matangle"], "c": ["p", "cor", "cf", "lc", "nc", "rc", "m", "ct", "arc", "rf", "f", "cr", "uc", "chain", "rec", "ce", "fc", "cin", "anc", "cm", "rn", "a", "bc", "b", "roc", "mc", "pc", "ac"], "r": ["err", "p", "ra", "run", "rc", "ar", "m", "ro", "rf", "l", "f", "cr", "rd", "nr", "ir", "ur", "rr", "cm", "rn", "j", "re", "sr", "b", "u", "rm", "rs", "yr"], "endx": [" endi", "starti", "endedx", "endedy", "endedi", "starty", "startx", "endi"], "endy": [" endY", "endY", "endedy", "Endy", "endyy", "endedpy", " endyy", "EndY", "endpy", " endpy", "endedY", "endedyy", "Endyy", "Endpy"]}}
{"code": " \\n  \\n  \\n  def read_grid(f):\\n  \treturn [\\n  \t\t[int(x) for x in line.split()]\\n  \t\tfor line in [f.readline() for _ in range(4)]\\n  \t]\\n  \\n  def read_case(f):\\n  \tanswer1 = int(f.readline())\\n  \tgrid1 = read_grid(f)\\n  \tanswer2 = int(f.readline())\\n  \tgrid2 = read_grid(f)\\n  \treturn (grid1[answer1 - 1], grid2[answer2 - 1])\\n  \\n  \\n  def solve(r1, r2):\\n  \tres = set(r1) & set(r2)\\n  \tif len(res) == 0:\\n  \t\treturn 'Volunteer cheated!'\\n  \tif len(res) == 1:\\n  \t\treturn list(res)[0]\\n  \treturn 'Bad magician!'\\n  \\n  \\n  \\n  def main():\\n  \tfn = sys.argv[1]\\n  \twith open(fn, encoding='utf-8') as f:\\n  \t\tncases = int(f.readline())\\n  \t\tfor case in range(1, ncases + 1):\\n  \t\t\trow1, row2 = read_case(f)\\n  \t\t\tsolution = solve(row1, row2)\\n  \t\t\tprint('Case #{}: {}'.format(case, solution))\\n  \\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "substitutes": {"f": ["ref", "p", "fp", "lf", "files", "full", "of", "xf", "fm", "file", "m", "function", " F", "d", "fx", "rf", "flat", "h", "F", "l", "http", "fr", "c", "fd", "fore", "e", "fb", "t", "fa", "form", "frame", "i", "fw", "fc", "self", "tf", "buff", "handler", "r", "input", " df", "bf", "fe", "fi", "fs", "w", "g", "b", "v", "finder", "sf", "feed", "fen", "inf", "df", "folder", "ff", "af"], "x": ["p", "dx", " xx", "id", "ix", "yx", "index", "pair", "q", "ex", "y", "X", "c", "str", "e", "t", "key", "px", "i", "xi", "xe", " y", "z", "r", "xs", "xc", " X", "rx", "w", "xy", "row", "v", "xp", "xx", "n", "int"], "line": ["p", "lf", "li", "id", "lines", "lin", "lc", "ine", "range", "len", "run", "name", "file", "Line", "d", "l", "c", "fr", "answer", "e", "str", "code", "chain", "ln", "fl", "frame", "nl", "cell", "lined", "r", "inline", " lines", "row", "b", "string", "page", "n", "block", "int", "word"], "_": ["p", "all", "long", "len", "file", "time", " time", "l", "by", "k", "g", "non"], "answer1": ["response1", "addressOne", "address1", "issueone", "response0", "answerone", "answer0", "answerOne", "responseOne", " answer0", " answerone", " answerOne", "response01", "answer01", "issue1", "responseone", "address0", "addressone", "issue01", " answer01"], "grid1": ["rowBack", "rank1", "grain2", "line2", "lineone", "rankpart", "grainBack", " grid01", "grid01", "rowpart", "gridpart", "gridBack", "rowone", "rank2", "grainone", "grain1", "gridone", " gridpart", "line1", "lineBack", "row01", "rank01"], "answer2": ["grid02", "Answer1", "response02", "response22", "responseTwo", "response2", "result02", "answer22", "grid22", "answerTwo", "answer02", "result22", "gridTwo", "result2", "Answer2", "AnswerTwo", "resultTwo", " answerTwo"], "grid2": ["row0", "grid4", "answer0", "gridall", "rangeTwo", "rowall", "row4", " grid0", "rangetwo", "range2", "grid0", "gridTwo", " gridTwo", " gridtwo", "rowTwo", " grid4", "gridtwo", "range4", " gridall", "answerall", "rowtwo"], "r1": ["ra83", "ro83", " r3", "r51", "r3", "srone", "ro1", "r83", "rh01", "R1", "ro01", "r01", "rh51", "ro51", "rh83", "sr2", " rone", "sr3", "ra51", "Rone", "ra01", "sr1", "R3", "rh1", "R2", "ra1", "rone"], "r2": ["r4", "sr0", "p1", "r0", "R1", " r4", "sr02", "sr2", "p2", "sr4", "p4", " r0", " r02", "p0", "sr1", "R02", "r02", "R2", "R0"], "res": ["err", "box", "response", "ver", "R", "resh", "val", "vals", "resp", "rest", "spec", "our", "details", "des", "gr", "vre", "resolution", "rss", "grid", "core", "data", "RES", "right", "pres", "req", "rec", "rev", "rem", "ret", "os", "reed", "rr", "rect", "rel", "sol", "rh", "part", "r", "rez", "reg", "Result", "re", "row", "remote", "rm", "Res", "rs", "result", "ras", "results"], "fn": ["p", "fin", "fp", "kn", "hn", "sn", "wt", "feat", "cf", "path", "cn", "fm", "func", "file", "nm", "function", "np", "syn", "ff", "fd", "bin", "fb", "ln", "fl", "fc", "output", "cdn", "conn", "bf", "fe", "arf", "rn", "FN", "fs", "fun", "bn", "b", "method", "sf", "wl", "fen", "fil", "dn", "filename"], "ncases": ["nase", "nased", "aucased", "aucasing", "aucase", "necase", "ncased", "nicase", "ncase", "aucases", "necased", "necasing", "nases", "ncasing", "necases", "nasing", "nicased", "nicasing", "nicases"], "case": ["id", "rice", "pe", "division", "path", "sc", "name", "ice", "du", "time", "space", "base", "position", "core", "data", "ace", "nce", "code", "rule", "condition", "ce", "cer", "trial", "shape", "sequence", "r", "match", "size", "chance", "a", "length", "Case", "row", "instance", "number", "fold", "ase", "string", "section", "result", "test", "cases", "definition", "change"], "row1": ["row3", "roone", "Row01", "ry2", " row01", "ro1", "rowsone", "Row1", "ow1", "ry9", "rows1", "rows2", "ryone", "rows9", "rowone", "ro9", "row9", "row01", " row3", "ro2", "ow01", "ry1", "ow3", "Row3"], "row2": [" rowTwo", "line2", "rowsTwo", "ow4", "line4", "orderTwo", "owTwo", "ow1", "order4", "linetwo", "rows1", "row4", "ow2", "rows2", "order2", "ordertwo", "rows4", "rowTwo", "lineTwo", " row4", " rowtwo", "rowtwo"], "solution": ["insolution", "ssolver", "solved", " solver", "solutions", " solve", "ssolved", "Solve", "ssolve", "ssolution", " solutions", "ssolutions", "Solutions", "insolved", "solver", "insolve", " solved", "insolver", "Solution", "Solver", "solve"]}}
{"code": " \\n  lines = [line.strip() for line in open(sys.argv[1])]\\n  count = int(lines[0])\\n  \\n  for i in xrange(count):\\n      R,C,M = map(int, lines[i+1].split())\\n      print \"Case #%s:\" % (i+1)\\n  \\n      w = max(R,C)\\n      h = min(R,C)\\n      X = R*C - M\\n      assert X > 0\\n  \\n      if X == 1:\\n          rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]\\n      elif h == 1:\\n          rows = ['c' + '.' * (X-1) + '*' * M]\\n      elif X == 4:\\n              rows = [\\n                  'c.' + '*' * (w-2),\\n                  '..' + '*' * (w-2),\\n              ] + ['*' * w] * (h-2)\\n      elif h == 2:\\n          if X%2 == 1 or X == 2:\\n              rows = None\\n          else:\\n              rows = [\\n                  'c' + '.' * (X/2-1) + '*' * (M/2),\\n                  '.' + '.' * (X/2-1) + '*' * (M/2)\\n              ]\\n      elif X <= 5 or X == 7:\\n          rows = None\\n  \\n      elif X%2 == 0 and X <= w*2:\\n          r = X/2\\n          rows = [\\n              'c' + '.' * (r - 1) + '*' * (w-r),\\n                    '.' * r       + '*' * (w-r),\\n          ] + ['*' * w] * (h-2)\\n  \\n      elif X <= w*3 and (X % 3) != 1:\\n          n = (X+1) / 3\\n          t = X - 2*n\\n          rows = [\\n              'c' + '.' * (n-1) + '*' * (w-n),\\n                    '.' * n     + '*' * (w-n),\\n                    '.' * t     + '*' * (w-t)\\n          ] + ['*' * w] * (h-3)\\n      else:\\n          n = X / w\\n          t = X % w\\n          if t == 1:\\n              rows = (\\n                      ['c' + (w-1) * '.']\\n                  +   ['.' * w] * (n-2)\\n                  +   ['.' * (w-1) + '*']\\n                  +   ['..' + '*' * (w-2)]\\n                  +   ['*' * w] * (h - n - 1)\\n              )\\n          else:\\n              k = 1 if t == 0 else 0\\n              rows = (\\n                      ['c' + (w-1) * '.']\\n                  +   ['.' * w] * (n-1)\\n                  +   ['.' * t + '*' * (w-t)] * (1 - k)\\n                  +   ['*' * w] * (h - n - 1 + k)\\n              )\\n  \\n      if rows:\\n          if R > C:\\n              rows = [\"\".join(row[i] for row in rows) for i in xrange(R)]\\n  \\n          for row in rows:\\n              print row\\n  \\n          assert len(rows) == R\\n          assert len(rows[0]) == C\\n          assert sum(1 for row in rows for col in row if col == '*') == M\\n  \\n      else:\\n          print \"Impossible\"\\n  \\n", "substitutes": {"lines": ["files", "vals", "ls", "runs", "vs", "plugins", "qs", "limits", "ips", "ins", "strings", "es", "l", "ids", "points", "args", "breaks", "items", "ses", "models", "values", "lins", "objects", "posts", "elines", "lined", "los", "letters", "links", "blocks", "xs", "groups", "headers", "ines", " Lines", "s", "words", "cells", "ds", "pages"], "line": ["split", "lf", "li", "link", "lin", "lc", "ine", "file", "name", "Line", "m", "d", "l", "f", "c", "day", "str", "e", "code", "nl", "cell", "LINE", "cle", "inline", "strip", "v", "de", "lane", "block", "page", "sl", "le", "sel", "word", "source"], "count": ["depth", "start", "case", "id", "ch", "cc", "index", "len", "q", "m", "x", "base", "max", "y", "l", "counter", "found", "c", "code", "num", "z", "con", "size", "limit", "Count", "length", "sum", "b", "number", "N", "call", "total", "coll"], "i": ["p", "iq", "ui", "start", "li", "chi", "id", "ci", "index", "m", "ini", "d", "ai", "multi", "x", "phi", "ind", "y", "l", "I", "gi", "c", "ii", "ti", "vi", "e", "eni", "yi", "inner", "mini", "uri", "pi", "xi", "di", "j", "mi", "my", "u", "qi", "si", "int", "iu", "slice"], "R": ["P", "A", "CR", "S", "B", "RA", "T", "L", "RR", "F", "I", "K", "Rs", "E", "IR", "NR", "RH", "RO", "D", "G", "Rh", "U", "Y", "GR", "RS", "H", "V", "Q", "W", "N", "SR", "Res", "RC", "RM"], "C": ["CC", "Z", "P", "O", "A", "CR", "Cr", "SC", "S", "B", "T", "DC", "L", "CM", "AC", "WC", "I", "K", "F", "c", "Ch", "E", "Max", "VC", "D", "G", "MC", "U", "Y", "Cl", "H", "V", "Q", "W", "N"], "M": ["Z", "P", "O", "A", "Mass", "S", "AM", "MN", "B", "MR", "T", "m", "J", "L", "Me", "CM", "F", "I", "K", "E", "ME", "MM", "D", "G", "MS", "MH", "MC", "MD", "U", "Y", "H", "V", "ML", "Q", "W", "N"], "w": ["wt", "ws", "sw", "time", "y", "tw", "z", "aw", "wa", "way", "v", "west", "u", "wd", "width", "m", "wave", "wal", "c", "wall", "win", "ew", "Wh", "Y", "wb", "H", "p", "ow", "d", "max", "f", "kw", " W", "a", "work", "W", "rw", "word", "o", "ww", "hw", "TW", "q", "we", "x", "l", "sh", "wh", "g", "s", "b", "iw", "wl", "week"], "h": ["p", "ph", "o", "ww", "all", "ch", "hw", "q", "width", "m", "time", "d", "x", "max", "y", "l", "f", "hh", " H", "ah", "c", "bh", "e", "sh", "gh", "z", "hm", "rh", "wh", "wa", "a", "g", "j", "H", "hi", "ht", "b", "v", "th", "min", "hr", "u", "oh", "W", "uh", "ih", "HH"], "X": ["XP", " x", "Z", "P", "O", "PE", "A", "WR", "Length", "Do", "DX", "IX", "S", "TW", "PH", "B", "WS", "ID", "MAX", "Any", "FF", "T", "HTTP", "J", "x", "L", "F", "y", "K", "I", "Work", "E", "XM", "XL", "TH", "RH", "WH", "TX", "Right", "D", "z", "XX", "MC", "Ex", "Cross", "XXX", "U", "Y", "Count", "FW", "Wh", "ZX", "H", "V", "Width", "Size", "ML", "CH", "Q", "XY", "W", "N", "MX", "Event", "CE", "Time"], "rows": ["rown", "tests", "features", "rooms", "forms", "images", "files", "workers", "array", "ws", "runs", "classes", "relations", "index", "users", "errors", "x", "works", "fields", "raw", "ids", "times", "data", "breaks", "items", "flows", "models", "views", "checks", "values", "events", "ays", "roots", "ews", "ows", "frames", "posts", "keys", "rules", "OWS", "holes", "blocks", "groups", "headers", "orders", "Row", "cells", "ports", "members", "heads", "planes", "tracks", "rs", "results", "cases", "pages"], "r": ["p", "o", "br", "rc", "q", "ar", "m", "ro", "d", "x", "rf", "l", "y", "ru", "cr", "c", "right", "nr", "fr", "e", "rr", "nor", "rh", "z", "a", "g", "j", "sr", "b", "v", "re", "hr", "u", "rw", "rs", "er"], "n": [" N", "p", "o", "all", "at", "nc", "q", "name", "m", "ns", "nb", "ot", "d", "nn", "x", "en", "y", "l", "f", "un", "out", "c", "e", "no", "num", "nor", "z", "nt", "a", "g", "j", "s", "b", "v", "u", "on", "N", "ne", "an", "net"], "t": ["p", "o", "it", " T", "tn", "at", "tp", "dt", "ts", "T", "m", "q", "time", "d", "ot", "x", "out", "y", "l", "f", "c", "e", "tt", "ta", "z", "nt", "type", "a", "g", "j", "s", "b", "v", "pt", "u", "ty", "N"]}}
{"code": " \\n  \\n  lines = [map(int, line.strip().split(\" \")) for line in open(sys.argv[1]).readlines()]\\n  [count] = lines[0]\\n  assert count * 10 + 1 == len(lines)\\n  \\n  for i in xrange(count):\\n      base = i*10\\n      [n1] = lines[base+1]\\n      [n2] = lines[base+6]\\n      row1 = set(lines[base+1+n1])\\n      row2 = set(lines[base+6+n2])\\n      common = row1.intersection(row2)\\n      print \"Case #%s:\" % (i+1),\\n      if len(common) == 1:\\n          print list(common)[0]\\n      elif not common:\\n          print \"Volunteer cheated!\"\\n      else:\\n          print \"Bad magician!\"\\n", "substitutes": {"lines": ["les", "tests", "steps", "files", "sheets", "vals", "ls", "runs", "vs", "ones", "lists", "log", "limits", "users", "pins", "ips", "ins", "books", "codes", "styles", "strings", "l", "ids", "locks", "data", "names", "faces", "points", "args", "breaks", "items", "flows", "models", "values", "lins", "frames", "objects", "rows", "verts", "posts", "elines", "rules", "los", "sections", "lights", "links", "blocks", "groups", "parts", "headers", "ines", "s", "orders", "words", "cells", "comments", "balls", "heads", "shows", "results", "pages"], "line": ["lf", "word", "li", "val", "lin", "lc", "ine", "len", "entry", "file", "name", "Line", "header", "d", "x", "l", "e", "ln", "key", "el", "nl", "cell", "LINE", "lined", "inline", "kl", "column", "strip", "row", "de", "char", "string", "block", "page", "sl", "letter", "lane", "source", "byte"], "count": ["p", "depth", "start", "case", "id", "list", "col", "index", "weight", "len", "current", "file", "name", "ind", "max", "found", "c", "core", "area", "code", "key", "num", "part", "check", "limit", "size", "Count", "length", "sum", "number", "loc", "n", "int", "total"], "i": ["p", "it", "ui", "li", "start", "id", "ci", "ix", "col", "index", "q", "ai", "x", "bi", "ind", "y", "l", "f", "I", "gi", "position", "c", "ii", "e", "zi", "ie", "mini", "uri", "pi", "part", "type", "limit", "a", "j", "b", "pos", "u", "ip", "qi", "n", "si", "int", "slice"], "base": ["p", "prefix", "offset", "start", "unit", "case", "id", "pe", "index", "range", "len", "basic", "init", "file", "name", "birth", "bi", "build", "x", "parent", "y", "body", "flat", "family", "area", "core", "c", "scale", "Base", "key", "batch", "ie", "based", "cache", "year", "bas", "set", "part", "check", "cycle", "size", "create", "home", "length", "b", "server", "pos", "number", "root", "ase", "letter", "n", "source", "site", "change"], "n1": ["N3", "n01", "p1", "N1", "p5", "l2", "N01", "n3", " n5", "p01", "l01", "N2", "p2", " n3", "l1", "N5", "n5", "p3"], "n2": ["n02", "cTwo", "nodeTwo", " nTwo", " n6", "N02", "noe", "N2", " ntwo", "coe", "nTwo", "c2", "v6", "node2", "nodeoe", "v02", "ntwo", " n02", " noe", "vtwo", "n6", "N6", "v2", "Ntwo"], "row1": ["row3", "col3", "col01", "col2", " row01", "rows3", "rowsone", "raw1", "col1", "rows1", "rawone", "rows2", " rowone", "rowone", "rows8", "rows01", "raw2", "raw8", "row01", " row3", " row8", "row8"], "row2": ["row3", "line2", "ow5", "ow4", "line4", " rowtwo", "line3", "node5", "line6", "row5", "cell2", "nodetwo", "row4", "ow2", "cell3", "owtwo", "node2", "row6", " row6", " row5", "cell4", " row3", "node4", " row4", "cell6", "rowtwo"], "common": ["extra", "la", "comment", "new", "long", "valid", "lc", "Common", "basic", "same", "broad", "norm", "parent", "central", "found", "similar", "family", "custom", "seen", "c", "core", "specific", "compatible", "dist", "other", "no", "complex", "ordered", "known", "shared", "ban", "con", "border", "recent", "public", "unique", "standard", "low", "union", "diff", "general", "normal", "total", "generic", "local"]}}
{"code": " \\n  \\n  \\n  \\n  INPUT = \"tiny\"\\n  INPUT = \"C-small-attempt1.in\"\\n  \\n  def debug(*args):\\n      sys.stderr.write(str(args) + \"\\n\")\\n  \\n  class Memoize:\\n      def __init__(self,function):\\n          self._cache = {}\\n          self._callable = function\\n              \\n      def __call__(self, *args, **kwds):\\n          cache = self._cache\\n          key = self._getKey(*args,**kwds)\\n          try: return cache[key]\\n          except KeyError:\\n              cachedValue = cache[key] = self._callable(*args,**kwds)\\n              return cachedValue\\n      \\n      def _getKey(self,*args,**kwds):\\n          return kwds and (args, ImmutableDict(kwds)) or args    \\n  \\n  IMPOSSIBLE = set([(2,2,2), (2,2,1), (2,3,1), (2,4,1), (2,5,1)])\\n  \\n  for i in range(2,51):\\n      IMPOSSIBLE.add((2,i,1))\\n      IMPOSSIBLE.add((i,2,1))\\n  \\n  SOLN = {\\n      (1,2,1) : [\"c*\"],\\n      (2,1,1) : [\"c\", \"*\"],\\n      (2,2,3) : [\"c*\", \"**\"],\\n  }\\n  \\n  def solve(R, C, M):\\n      if M == 0:\\n          s = [\"c%s\" % ('.' * (C-1))]\\n          for i in range(R-1):\\n              s.append('.' * C)\\n          return s\\n      t = (R, C, M)\\n      if t in IMPOSSIBLE:\\n          debug(\"** %s %s %s\" % t)\\n          raise ValueError\\n      if t in SOLN:\\n          return SOLN[t]\\n  \\n      if C < M and R > 2:\\n          try:\\n              return solve(R-1, C, M-C) + [\"*\" * C]\\n          except ValueError:\\n              pass\\n  \\n      if C <= R:\\n          if M >= C and R > 2:\\n              return solve(R-1, C, M-C) + [\"*\" * C]\\n      else:\\n          if M >= R and C > 2:\\n              return [\"%s*\" % s for s in solve(R, C-1, M-R)]\\n      if R > 2:\\n          mines = min(C, M)\\n          if mines == C - 1:\\n              mines -= 1\\n          try:\\n              return solve(R-1, C, M-mines) + [(\".\" * (C - mines)) + (\"*\" * mines)]\\n          except ValueError:\\n              if C > 2:\\n                  mines = min(R, M)\\n              if mines == R - 1:\\n                  mines -= 1\\n              s = [\"%s%s\" % (s, '*' if k > C-mines else '.') for k, s in enumerate(solve(R, C-1, M-mines))]\\n              return s\\n      debug(R, C, M)\\n      return []\\n  \\n  def do_trial(R, C, M):\\n      try:\\n          r = solve(R,C,M)\\n          s = \"\\n\" + '\\n'.join(r)\\n          assert len(r) == R\\n          for r1 in r:\\n              assert len(r1) == C\\n          assert len(''.join(k for k in s if k == '*')) == M\\n          return s\\n      except ValueError:\\n          return \"\\nImpossible\"\\n  \\n  \\n  def all():\\n      for R in range(1,50):\\n          for C in range(1,50):\\n              for M in range(R*C):\\n                  print(R, C, M)\\n                  print(do_trial(R, C, M))\\n      sys.exit(0)\\n  \\n  \\n  f = file(INPUT)\\n  T = int(f.readline()[:-1])\\n  for i in range(T):\\n      R, C, M = [int(x) for x in f.readline().split()]\\n      v = do_trial(R, C, M)\\n      print \"Case #%d: %s\" % (i+1, v)\\n", "substitutes": {"INPUT": ["OUTInput", " inLINE", " inVERT", "INVERT", "inPUT", "OUTLINE", "INInput", " INLINE", "INLINE", " INInput", " inInput", "inLINE", "OUTVERT", "inInput", "inVERT", " INVERT", "OUTPUT", " inPUT"], "self": ["ref", "me", "p", "_", "Self", "session", "parse", "node", "case", "all", "child", "full", "user", "proxy", "current", "app", "layer", "event", "func", "q", "python", "view", "per", "parent", "point", "host", "connection", "c", "data", "client", "e", "other", "args", "form", "api", "ng", "plugin", "part", "w", "work", "g", "public", "object", "context", "this", "instance", "server", "load", "plus", "ctx", "master", "now", "call", "resource", "er", "private", "patch", "worker", "manager"], "function": ["array", "node", "new", "unc", "full", "document", "closure", "func", "name", "python", "float", "fn", "F", "position", "functional", "package", "callback", "wrapper", "module", "handler", "library", "Function", "fun", " func", " Function", "object", "this", "instance", "operation", "number", "call", "string", "resource", "word", "method"], "_cache": [" _object", "logache", "logcache", "allCache", "allfunction", "logobject", "pyCache", "pyconfig", "allconfig", "pycache", "allcache", "_Cache", " _call", "_function", "_ache", " _ache", "_object", "logcall", "_call", "_config", "pyfunction"], "_callable": [" _caller", " _callables", " _Callables", "_callables", "_cables", "_createer", "_generable", "_cable", " _CallFunction", "_createing", "_calling", " _Calling", "_Callable", "_callb", "_cb", " _callb", "_createFunction", "_Callables", "_CallFunction", "_callFunction", " _calling", "_cer", "_generables", " _callFunction", "_caller", " _Caller", "_createable", "_generer", "_generb", "_Calling", "_Caller", " _Callable", " _Callb", "_Callb"], "cache": ["p", "parse", "pool", "session", "array", "case", "config", "index", "null", "cookie", "base", "parent", "lock", "get", "default", "c", "data", "client", "table", "code", "args", "temp", "hash", "ache", "api", "wrapper", "dict", "Cache", "can", "module", "cat", "match", "value", "conf", "object", "instance", "storage", "root", "model", "fake", "store", "call", "result", "mc", "ac"], "key": ["p", "ver", "service", "query", "id", "link", "copy", "path", "index", "entry", "file", "name", "base", "parent", "KEY", "y", "connection", "c", "core", "data", "str", "ace", "code", "reason", "temp", "hash", "keys", "sign", "type", "value", "size", "object", "sum", "root", "Key", "call", "string", " Key", "item", "page", "result", "int", "error", "section", "date", "source", "method"], "cachedValue": ["codedVal", "encodedValue", "scappedValue", "cappedVal", "encodedVal", "codedValues", "cappedValue", "cashedvalue", "scachedValues", "casedValues", "cappedvalue", "cryptedvalue", "encodedValues", "cashedValue", "cashedKey", "cryptedValues", "encachedvalue", "cappedValues", "cachedVal", "cashedValues", "cryptedKey", "scachedValue", "cachedKey", "encachedValue", "codedvalue", "cachedValues", "encachedValues", "casedvalue", "codedValue", "scappedvalue", "cachedvalue", "cryptedValue", "scachedKey", "casedValue", "scappedValues", "encodedvalue", "scappedKey", "encachedVal", "casedVal", "scachedvalue", "cappedKey"], "IMPOSSIBLE": ["IMPASSIBLE", "IMLPASSible", "IMPASSibilities", "IMpASSibility", "IMPESSible", "IMpASSIBLE", "IMPUSIBLE", "IMpESSibles", "IMPossible", "IMPESSibles", "IMLPOSSIBLE", "IMLPASSibles", "IMPISSible", "IMPASSibility", "IMPUSibility", "IMpOSSibility", "IMPRECibles", "IMpOSSIBLE", "IMpOSSible", "IMLPASSIBLE", "IMPossIBLE", "IMpASSibles", "IMLPOSSibility", "IMLPASSibility", "IMPISSibilities", "IMPOSSibility", "IMPOSSibilities", "IMPOSSible", "IMPESSIBLE", "IMPossibility", "IMPISSibles", "IMpESSibility", "IMpOSSibles", "IMPESSibility", "IMpESSIBLE", "IMPASSible", "IMPRECibility", "IMpESSible", "IMPossibilities", "IMPUSible", "IMPUSibles", "IMLPOSSible", "IMpASSible", "IMPossibles", "IMPOSSibles", "IMLPOSSibles", "IMPRECible", "IMPASSibles", "IMPRECIBLE", "IMPISSIBLE"], "i": ["p", "o", "li", "id", "ci", "index", "m", "phi", "ai", "d", "bi", "ind", "y", "h", "gi", "I", "l", "ri", "ii", "c", "ti", "e", "ie", "two", "pi", "xi", "z", "cm", "a", "j", "im", "b", "ip", "u", "qi", "n", "si", "io", "int", "iu"], "SOLN": ["SOLNG", "SILM", "sOLn", "SVOLN", " SALN", "SALn", "SLM", "SOLNT", "sOLM", "SILn", " SOLn", "SVOLNs", "SOLK", " SOLNT", "SOLNE", "SSoln", "SVOLn", "Soln", "SolK", "solNE", "SILNE", "SolNG", "SSolN", "SSOLK", "SRLN", " SOLNs", "SolNE", " SALNT", "SRLn", "SolM", "SILN", "solM", "SOLNs", "SALK", "SLNE", "SOVNG", "SALNs", "SOVK", "SOVN", "solN", "SALNG", "SOLM", "SSolNG", "SRLNT", "SLn", "SSOLn", "sOLN", "SVOLNT", "SOVn", " SALNs", "SSOLN", " SALn", "SOLn", "SolN", "SRLNs", "SALN", "SSolK", "SLN", "SSOLNG", "sOLNE", "soln", "SALNT"], "R": ["P", "A", "CR", "WR", "S", "JR", "B", "MR", "RA", "AR", "m", "RE", "L", "RR", "Run", "F", "X", "RN", "I", "Rec", "K", "RP", "ER", "c", "RW", "Rs", "E", "IR", "NR", "RH", "DR", "RO", "D", "G", "Rh", "U", "Y", "V", "H", "RG", "W", "N", "SR", "Re", "RC", "RM", "Range"], "C": ["CC", "P", "O", "A", "CF", "Cr", "SC", "CR", "CS", "S", "B", "Cs", "CI", "YC", "DC", "L", "CL", "CM", "AC", "X", "F", "I", "K", "CV", "Sc", "c", "Ch", "CU", "E", "CT", "CO", "CNN", "VC", "Cache", "D", "NC", "G", "EC", "MC", "U", "Count", "Y", "CA", "Cl", " c", "H", "V", "Cu", "Size", "Mc", "Q", "W", "N", "CE"], "M": ["MQ", "P", "O", "LM", "A", "S", "MN", "AM", "B", "MR", "m", "J", "L", "MA", "RE", "CM", "TM", "F", "X", "I", "K", "IM", "Ch", "E", "MM", " m", "D", "G", "MI", "OM", "MD", "MC", "U", "Y", "V", "H", "PM", "MT", "Mc", "Q", "W", "N", "RM"], "s": ["p", "o", "_", "array", "ls", "lines", "S", "ss", "states", "ts", "m", "ns", "params", "ins", "d", "strings", "h", "y", "es", "als", "c", "https", "e", "args", "gs", "ings", "ssl", "sites", "os", "ps", "services", "a", "w", "g", "its", "b", "u", "string", "south", "n", "sl", "rs", "ed", "cs", "ds"], "t": ["p", "it", "o", "all", "tim", "tr", "S", "st", "ts", "m", "dt", "d", "out", "h", "y", "l", "c", "ti", "str", "e", "temp", "tip", "tt", "te", "ta", "tf", "z", "tor", "tmp", "type", "the", "tg", "a", "w", "g", "j", "this", "b", "u", "tm", "string", "n", "ut", "int", "test", "tc"]}}
{"code": " \\n  \\n  \\n  INPUT = \"tiny\"\\n  if 1:\\n      INPUT = \"A-large.in\"\\n      INPUT = \"A-small-attempt0.in\"\\n  \\n  def debug(*args):\\n      return\\n      sys.stderr.write(str(args) + \"\\n\")\\n  \\n  class Memoize:\\n      def __init__(self,function):\\n          self._cache = {}\\n          self._callable = function\\n              \\n      def __call__(self, *args, **kwds):\\n          cache = self._cache\\n          key = self._getKey(*args,**kwds)\\n          try: return cache[key]\\n          except KeyError:\\n              cachedValue = cache[key] = self._callable(*args,**kwds)\\n              return cachedValue\\n      \\n      def _getKey(self,*args,**kwds):\\n          return kwds and (args, ImmutableDict(kwds)) or args    \\n  \\n  def do_trial(a1, r1, a2, r2):\\n      p1 = set(r1[a1-1])\\n      p2 = set(r2[a2-1])\\n      u = p1.intersection(p2)\\n      if len(u) < 1:\\n          return \"Volunteer cheated!\"\\n      if len(u) > 1:\\n          return \"Bad magician!\"\\n      return list(u)[0]\\n  \\n  f = file(INPUT)\\n  T = int(f.readline()[:-1])\\n  for i in range(T):\\n      rows1 = []\\n      a1 = int(f.readline()[:-1])\\n      for r in range(4):\\n          rows1.append([int(x) for x in f.readline().split()])\\n      a2 = int(f.readline()[:-1])\\n      rows2 = []\\n      for r in range(4):\\n          rows2.append([int(x) for x in f.readline().split()])\\n      v = do_trial(a1, rows1, a2, rows2)\\n      print \"Case #%d: %s\" % (i+1, v)\\n", "substitutes": {"INPUT": ["INULT", "InInput", "InLINE", "inputinput", "INFILE", "InVERT", "inputFILE", "INCT", "inputPUT", " INULT", "inFILE", "ininput", "outPUT", "INVERT", " InLINE", "inputInput", "inPUT", "INInput", " INLINE", "outFILE", "INLINE", " INCT", "outInput", " InInput", " InULT", " inULT", " inInput", " INInput", "InULT", "inLINE", "inInput", " InPUT", "inVERT", " INVERT", "INinput", "InPUT", "inULT", " inPUT", " inCT", "outinput", "inCT"], "self": ["me", "p", "Self", "child", "session", "py", "case", "full", "user", "worker", "app", "q", "func", "m", "python", "d", "per", "parent", "point", "h", "host", "connection", "c", "right", "data", "client", "e", "other", "ack", "args", "form", "api", "shared", "plugin", "module", "part", "type", "work", "g", "w", "public", "object", "context", "this", "s", "instance", "server", "load", "plus", "ctx", "master", "now", "remote", "call", "er", "private", "patch", "layer", "manager"], "function": ["array", "new", "node", "unit", "unc", "full", "document", "closure", "func", "name", "python", "parent", "fn", "F", "c", "functional", "package", "callback", "wrapper", "job", "handler", "module", "library", "Function", "fun", " func", "object", " Function", "instance", "operation", "number", "action", "call", "resource", "section", "word", "method"], "_cache": [" _code", "objcache", "jconfig", "objcall", "objkey", "jcache", "jkey", "pycode", "pyconfig", "jcall", "pycache", " _call", "lexcache", "_code", "lexcall", " _config", "pycall", " _key", "lexcode", "objconfig", "_call", "_key", "lexconfig", "_config"], "_callable": ["lexgenerables", "lexgenerable", " _functionable", "_callables", "_iterate", "_generable", "_callative", "_functionative", "lexcallables", "_Callable", "lexcallability", "_loadFunction", "_loadability", "_generability", "_Callability", "_Callate", "lexgenerability", "_Callables", "_CallFunction", "lexcallate", "_iterability", "_callFunction", "_iterables", "_loadable", " _callability", " _callative", "_generables", "_Callative", " _callFunction", "_callate", "_iterable", " _functionability", "_functionability", "lexcallable", " _functionFunction", " _functionative", "_generate", "_callability", "lexgenerate", "_loadative", "_functionFunction", "_functionable"], "cache": ["p", "parse", "pool", "session", "query", "py", "config", "index", "cookie", "base", "parent", "default", "c", "data", "client", "table", "lib", "args", "code", "temp", "hash", "ache", "api", "dict", "Cache", "empty", "cell", "module", "can", "cmp", "cat", "match", "conf", "object", "storage", "root", "sync", "model", "fake", "store", "call", "ca", "ac"], "key": ["element", "service", "case", "id", "link", "full", "path", "index", "entry", "name", "file", "base", "KEY", "y", "by", "host", "connection", "c", "core", "data", "str", "code", "rule", "reason", "temp", "hash", " entry", "year", "keys", "k", "type", "check", "match", "value", "size", "sum", "root", "sync", "Key", "string", " Key", "call", "item", "page", "section", "result", "error", "date", "source", "mac"], "cachedValue": ["codedVal", "ucachedValue", "capedValue", "cappedVal", "casedKey", "cappedValue", "cashedvalue", "casedValues", "cappedvalue", "capedKey", "cashedValue", "cashedKey", "ucasedValue", "capedValues", "encachedvalue", "cachedVal", "cashedValues", "ucasedKey", "encachedValue", "cachedKey", "ucachedvalue", "codedvalue", "encappedKey", "encappedvalue", "cachedValues", "ucasedvalue", "ucasedValues", "ucachedKey", "casedvalue", "encappedValue", "codedValue", "cachedvalue", "codedKey", "casedValue", "cashedVal", "encachedVal", "encappedVal", "encachedKey", "ucachedValues", "capedvalue", "cappedKey"], "a1": [" a01", "a4", "A4", "pone", "r3", "A2", "a01", "r01", "p01", "A1", "aone", "alpha3", "A3", " a3", "p4", "alphaone", "alpha2", " aone", " a4", "a3", "Aone", "alpha01", "p3", "alpha1", "rone"], "r1": ["pb", "rb", " r3", "arone", "pone", "r3", "r11", "ar2", " rb", "ar1", "ar11", "aone", "p11", "ab", "a3", "p3", "a11", "rone"], "a2": ["ga2", "a4", "gaTwo", "r4", "ar62", "p72", " a52", "p5", "ar2", "ga62", "a5", "u52", "aa4", "ar5", "aII", "ar1", "ga4", "a62", "u2", " aTwo", "aa62", "u72", "p62", " a5", "aTwo", "p4", "uII", " a62", " a72", "a52", " a4", " aII", "aa2", "p52", "aaTwo", "a72", "pII"], "r2": ["a8", "a4", "r4", "p8", " r3", "r3", "f4", " r8", "atwo", "f2", "p4", "r8", "ftwo", "rtwo", "f1", "a3", "p3", "ptwo"], "p1": [" pone", "pone", "r3", " p3", "pa2", "r0", " p0", "aone", "pa1", "p0", "a0", "pa3", "a3", "p3", "rone"], "p2": ["tTwo", "ttwo", "a02", "cTwo", "ctwo", "r0", "p02", "t1", " p0", "rTwo", "c2", "c1", "p0", "rtwo", "pTwo", "r02", "t2", "a0", " p02", "ptwo"], "u": ["p", "cu", "o", "up", "ui", "nu", "fu", "bu", "uu", "mu", "current", "ups", "universal", "su", "du", "m", "eu", "un", "ku", "h", "l", "ul", "ru", "c", "uc", "chu", "e", "t", "uv", "hu", "ur", "us", "uri", "tu", "uy", "U", "uni", "uno", "g", "home", "b", "lu", "you", "ut", "iu", "ou", "uid"], "f": ["p", "fp", "lf", "fast", "ch", "full", "fac", "of", "xf", "version", "file", "m", "stream", "d", "fx", "h", "F", "l", "fn", "fo", "c", "fr", "fd", "fb", "e", "t", "fl", "form", "frame", "fw", "fc", "info", "tf", "z", "buff", "handler", "part", "bf", "fe", "conf", "fs", "w", "g", "b", "line", "feed", "fen", "io", "inf", "df", "folder", "ff"], "T": ["TT", "P", "O", "A", "R", "WT", "S", "B", "TA", "time", "L", "F", "X", "I", "K", "TS", "t", "E", "Total", "TN", "D", "M", "G", "U", "Y", "V", "H", "C", "Q", "W", "N", "NUM", "TI", "n", "Time", "NT"], "i": ["bis", " ir", "it", "p", "chi", "li", "id", "ci", "index", "q", "cli", "d", "phi", "bi", "h", "ri", "y", "l", "I", "gi", "ii", "vi", "ti", "c", "e", "ir", "t", "zi", "ie", "uri", "mini", "xi", "pi", "di", "k", "z", "go", "uni", "j", " c", "hi", "b", "ip", "qi", "n", "si", "slice"], "rows1": ["owsone", "ows4", "row0", "rows3", "row2", "rowsone", "row1", "blocks1", " rows4", "blocks3", "blocksone", "ows01", " rows0", " rowsone", " rows3", "blocks4", "ows0", "rows0", "ows2", "rows01", "blocks2", "rows4", "blocks0", "blocks01", "ows3", " rows01", "ows1"], "r": ["err", "p", "o", "br", "R", "run", "range", "rc", "q", "ar", "m", "ro", "d", "un", "h", "l", "cr", "rd", "nr", "c", "ir", "t", "like", "ur", "rr", "ner", "k", "rg", "re", "b", "lr", "rs", "yr"], "x": ["p", "_", "id", "ix", "ch", "ax", "xxx", "xf", "index", "q", "time", "d", "h", "ex", "y", "X", "wx", "xt", "l", "c", "e", "t", "code", "xes", "rax", "sect", "xi", "k", "z", "rex", "xs", "xc", " X", "rx", "w", "xy", "xp", "ctx", "on", "xx", "sex", "n", "int", "test", "ct"], "rows2": ["row3", " rows32", "ows4", "rows3", "row2", "loads2", " rows102", "rows32", "row1", " rows4", "row32", "loads3", "rows102", "loads4", "row4", "ows32", " rows3", "ows2", "rows4", "loads102", "ows102", "ows3", "ows1"], "v": ["p", "conv", "val", "vals", "vs", "version", "av", "q", "m", "variable", "d", "h", "l", "iv", "c", "vi", "e", "volt", "t", "vari", "va", "uv", "k", "z", "value", "ev", "vd", "w", "g", "ve", "V", "s", "vv", "sv", "n"]}}
{"code": " \\n  lines = iter('''\\n  13\\n  5 5 23\\n  3 1 1\\n  1 3 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  10 1 4\\n  1 10 5\\n  2 10 8\\n  10 2 8\\n  2 10 9\\n  10 2 7\\n  5 3 3\\n  '''.splitlines(False)[1:])\\n  out = sys.stdout\\n  \\n  sys.setrecursionlimit(1500)\\n  \\n  \\n  class MyException(Exception):\\n  \tpass\\n  lines = iter(open(r'C-small-attempt7.in').readlines(False))\\n  out = open('c-small.answer', 'w')\\n  \\n  def solve(C, R, M):\\n  \tboard = [['.']*C for _ in range(R)]\\n  \tboard[-1][-1] = 'c'\\n  \ttry:\\n  \t\tfor r in range(R-2):\\n  \t\t\tfor c in range(C-2):\\n  \t\t\t\tif r == R-3 and c == C-3:\\n  \t\t\t\t\traise StopIteration()\\n  \t\t\t\tboard[r][c] = '*'\\n  \t\t\t\tM -= 1\\n  \t\t\t\tif M == 0:\\n  \t\t\t\t\treturn board \\n  \texcept StopIteration:\\n  \t\tpass\\n  \t\t\\n  \tif M % 2 == 0:\\n  \t\tfor r in range(R-3):\\n  \t\t\tboard[r][C-1] = '*'\\n  \t\t\tboard[r][C-2] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\tfor c in range(C-3):\\n  \t\t\tboard[R-1][c] = '*'\\n  \t\t\tboard[R-2][c] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\t\\n  \t\t\\n  \t\traise MyException()\\n  \telse:\\n  \t\tboard[R-3][C-3] = '*'\\n  \t\tM -= 1\\n  \t\tif M == 0:\\n  \t\t\treturn board\\n  \t\tfor r in range(R-2):\\n  \t\t\tboard[r][C-1] = '*'\\n  \t\t\tboard[r][C-2] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\tfor c in range(C-2):\\n  \t\t\tboard[R-1][c] = '*'\\n  \t\t\tboard[R-2][c] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\t\\n  \t\traise MyException()\\n  \t\t\\n  \t\\n  caseCnt = int(next(lines))\\n  \\n  for case in range(1, caseCnt+1):\\n  \tR,C,M = map(int, next(lines).split())\\n  \t\\n  \tprint('Case #%d:'%case, file=out)\\n  \tif M == 0:\\n  \t\tprint('c' + '.'*(C-1), file=out)\\n  \t\tfor _ in range(R-1):\\n  \t\t\tprint('.'*C, file=out)\\n  \telif R*C==M+1:\\n  \t\tprint('c' + '*'*(C-1), file=out)\\n  \t\tfor _ in range(R-1):\\n  \t\t\tprint('*'*C, file=out)\\n  \telif C == 1 and R == 1:\\n  \t\tprint('Impossible', file=out)\\n  \telif C == 1:\\n  \t\tif M > R-1:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c', file=out)\\n  \t\t\tfor _ in range(R-M-1):\\n  \t\t\t\tprint('.', file=out)\\n  \t\t\tfor _ in range(M):\\n  \t\t\t\tprint('*', file=out)\\n  \telif R == 1:\\n  \t\tif M > C-1:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c' + '.'*(C-M-1) + '*'*M, file=out)\\n  \telif C == 2:\\n  \t\tif M %2 or M//2 > R-2:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c.', file=out)\\n  \t\t\tfor _ in range(R-M//2-1):\\n  \t\t\t\tprint('..', file=out)\\n  \t\t\tfor _ in range(M//2):\\n  \t\t\t\tprint('**', file=out)\\n  \telif R == 2:\\n  \t\tif M %2 or M//2 > C-2:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)\\n  \t\t\tprint(      '.'*(C-M//2)   + '*'*(M//2), file=out)\\n  \telif M > R*C-4:\\n  \t\tprint('Impossible', file=out)\\n  \telse:\\n  \t\ttry:\\n  \t\t\tboard = solve(C, R, M)\\n  \t\t\tfor line in board:\\n  \t\t\t\tprint(''.join(line), file=out)\\n  \t\texcept MyException:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\\n  \t\\n", "substitutes": {"lines": ["rooms", "files", "ls", "runs", "lin", "plugins", "log", "limits", "mails", "errors", "scenes", "Line", "ips", "users", "codes", "books", "strings", "l", "f", "ids", "locks", "boards", "faces", "breaks", "items", "ses", "models", "lins", "drivers", "frames", "objects", "rows", "ze", "bytes", "elines", "posts", "rules", "los", "LINE", "holes", "lights", "inline", "links", "blocks", "letters", "liners", "headers", "ines", "boxes", "cells", "comments", "balls", "sticks", "ances", "lo", "ipes", "pages"], "out": ["err", "o", "array", "outs", "comment", "image", "list", "copy", "user", "doc", "problem", "log", "name", "writer", "channel", "file", "dot", "again", "parent", "bin", "client", "data", "code", "inner", "output", "co", "w", "Out", "buffer", "OUT", "sys", "call", "block", "io", "error", "result", "net", "word", "ac"], "C": ["CC", "Z", "P", "O", "A", "CR", "From", "Col", "S", "B", "Cs", "T", "DC", "L", "CL", "Code", "CM", "AC", "X", "F", "WC", "I", "K", "Rec", "Sc", "Ch", "Rs", "E", "VC", "D", "G", "EC", "U", "Count", "Y", "CA", "Cl", "H", "V", "Co", "St", "Chain", "Channel", "Size", "Cu", "Q", "Cor", "W", "N", "Country", "RC"], "R": ["P", "O", "A", "CR", "Cr", "S", "JR", "B", "Ra", "T", "Line", "Code", "L", "RR", "Run", "J", "F", "X", "Rec", "K", "I", "Sc", "RW", "Ch", "Rs", "E", "All", "IR", "RH", "Review", "Right", "Read", "RO", "Group", "D", "G", "Rh", "U", "Rev", "Y", "RS", "Cl", "V", "H", "Co", "Row", "RL", "Q", "W", "N", "SR", "Re", "RC", "RM", "Range", "Record"], "M": ["Mo", "MQ", "Z", "P", "O", "LM", "A", "MF", "S", "MN", "AM", "B", "ARM", "MO", "Ms", "T", "m", "J", "L", "MA", "MAL", "CM", "TM", "F", "X", "Me", "I", "K", "DM", "IM", "Mor", "JM", "E", "SM", "All", "ME", "MM", " m", "D", "G", "MI", "MS", "MC", "OM", "OR", "MD", "U", "Y", "V", "H", "MT", "PM", "EM", "MB", "ML", "Q", "NM", "W", "N", "MX", "RM", "FM"], "board": ["stroke", "array", "lay", "list", "layout", "ode", "event", "entry", "stream", "head", "player", "boards", "play", "room", "code", "ward", "frame", "draw", "join", "control", "ban", "bug", "void", "home", "comment", "problem", "view", "body", "menu", "bridge", "core", "ack", "table", "back", "form", "hole", "sequence", "Board", "video", "door", "object", "flow", "student", "result", "p", "ide", "boarding", "function", "que", "d", "builder", "flo", "client", "bo", " row", "ba", "cart", " Board", "work", "row", "call", "error", "word", "coll", "one", " game", "square", " clipboard", "deck", "rank", "catch", "ion", "sc", "channel", "loop", "broad", "point", "foot", "road", "rock", "oard", "game", "ault", "che", "cat", "co", "b", "model", "design", "boy", "land", "bank", "block", "feed", "lane"], "_": ["p", "all", "x", "h", "l", "f", "t", "code", "rec", "i", "con", "row"], "r": ["err", "p", "o", "P", "rb", "br", "all", "ch", "range", "rc", "q", "ar", "m", "ro", "mr", "d", "x", "RR", "h", "l", "ru", "cr", "f", "rd", "nr", "right", "e", "ir", "t", "Rs", "ur", "i", "rr", "nor", "k", "rg", "rn", "a", "w", "g", "j", "re", "sr", "b", "v", "u", "pr", "lr", "n", "rs", "er", "yr"], "c": ["ch", "cc", "lc", "path", "name", "orc", "arc", "h", "y", "cr", "uc", "code", "z", "cm", "w", "v", "u", "ca", "cs", "ac", "cy", "unc", "cor", "dc", "nc", "m", "rec", "i", "fc", "n", "ct", "cu", "p", "ci", "col", "cn", "d", "f", "count", "e", "t", "chain", "ce", "a", "cl", "cd", "coll", "o", "cf", "rc", "sc", "q", "channel", "x", "l", "cp", "cont", "cache", "ec", "k", "cat", "anc", "cycle", "rn", "g", "b", "roc", "mc", "cur"], "caseCnt": [" casector", "caseScnt", " caseCtx", "caseGCn", "casecNT", " casecnt", "casector", "caseSctx", "caseScn", "casectx", "caseSctor", "caseCtor", "caseCtx", "casecnt", "caseGCNT", " caseCn", " caseCNT", "caseScNT", "caseCn", "caseGCnt", " casecNT", " caseCtor", "caseGCtor", "casecn", "caseCNT", " casectx", " casecn"], "case": ["range", "m", "time", "x", "max", "when", "character", "ace", "end", "code", "choice", "match", "bc", "length", "Case", "row", "number", "loc", "ase", "block", "section", "cases"]}}
{"code": " \\n  input = open(r'C:\\MyDocument\\home\\gcj\\2014-04-12\\A-small-attempt0.in')\\n  caseCnt = int(input.readline())\\n  for caseNo in range(1, caseCnt+1):\\n  \tans1 = int(input.readline())\\n  \tfor i in range(1, 5):\\n  \t\tline = input.readline()\\n  \t\tif ans1 == i:\\n  \t\t\tcandidates = set(map(int, line.split()))\\n  \t\t\\n  \tans2 = int(input.readline())\\n  \tfor i in range(1, 5):\\n  \t\tline = input.readline()\\n  \t\tif ans2 == i:\\n  \t\t\tanswers = candidates.intersection(set(map(int, line.split())))\\n  \t\t\\n  \tif len(answers) == 0:\\n  \t\tprint('Case #%d: Volunteer cheated!'%caseNo)\\n  \telif len(answers) > 1:\\n  \t\tprint('Case #%d: Bad magician!'%caseNo)\\n  \telif len(answers) == 1:\\n  \t\tanswer = answers.pop()\\n  \t\tprint('Case #%d: %d'%(caseNo, answer))\\n", "substitutes": {"input": ["element", "inside", "parse", "audio", "session", "image", "single", "request", "command", "active", "addin", "ou", "process", "qa", "enter", "document", "current", "accept", "event", "Input", "view", "volume", "file", "machine", "stream", "upload", "container", "double", "again", "agent", "raw", "f", "http", "keep", "client", "table", "submit", "temp", "batch", "ssl", "form", "socket", "output", "initial", "url", "driver", "buffer", "context", "this", "instance", "plus", "reader", "string", "resource", "select", "inf", "error", "int", "io", "pull", "loader", "source", "interface"], "caseCnt": ["caseCunt", "caseScnt", "casecnc", " caseCnc", "caseCnc", "casecNT", " caseCust", " casecnt", " casecust", "caseScn", "caseCust", "caseCuNT", "casecnt", " caseCn", "casecust", " caseCNT", "caseScNT", "caseCn", "caseScnc", " casecNT", "caseCun", "casecn", "caseCNT", "caseCuust", " casecn"], "caseNo": ["conditionNO", " caseId", "seaNo", " caseNum", "patchNo", "blockN", "caseNO", "seano", "caseId", " caseno", "seaNO", "Caseno", "iceNo", "seaName", "conditionNo", "caseName", "patchNO", "blockNO", "CaseNum", "CaseName", "caseNum", "CaseNo", "CaseNO", "iceNO", "blockNo", "caseN", "patchId", "CaseId", "blockNum", " caseName", "iceN", " caseNO", "caseno", "CaseN", "iceNum", "conditionno", "conditionNum", "patchNum"], "ans1": ["an0", "lan1", "cs2", "cs01", "ns0", "lan0", "nsone", "amsone", "ansone", "ans3", "ns1", "as01", "ns3", "lanone", "ans0", "ams0", "as0", "an2", "as2", "cs1", "an01", "as1", "ans01", "ams1", "lan3", "cs0", "ams3", "an1"], "i": ["p", "o", "ui", "li", "id", "ci", "index", "oi", "m", "ai", "multi", "x", "bi", "ind", "l", "y", "gi", "I", "f", "ii", "c", "ti", "e", "yi", "ie", "pi", "xi", "di", "k", "z", "ni", "a", "im", "j", "b", "v", "ip", "u", "qi", "n", "si", "io", "int", "iu"], "line": ["side", "parse", "lf", "li", "unit", "comment", "single", "link", "lines", "online", "lin", "lc", "range", "log", "entry", "file", "name", "channel", "Line", "shell", "time", "live", "text", "look", "l", "message", "data", "lo", "end", "rule", "chain", "key", "el", "cell", "LINE", "pin", "inline", "cle", "match", "url", "non", "strip", "row", "sync", "char", "lane", "string", "block", "le", "letter", "item", "section", "page", "word", "layer", "source"], "candidates": ["Candidate", "chids", "candues", "continues", "Candiders", "candiders", "coriders", "callidate", "Candues", "candids", "continidate", "corplates", "candplates", "callplates", "Candids", "candidate", "chues", "callidates", "continids", "Candidates", "coridate", "calliders", "chidates", "continidates", "chidate", "coridates", "Candplates"], "ans2": ["an0", "an02", "lan1", "cs2", "lan2", "lan02", "aus1", "ANS1", "aus2", "lan0", "an5", "ANS5", "cs5", "ans0", "an2", "aus0", "ANS2", "ans02", "ans5", "cs1", "csTwo", "ansTwo", "anTwo", "aus02", "ANSTwo", "an1"], "answers": ["answsers", "anworders", "answorder", "annwered", "answackers", "answinackers", "answaitners", "answorders", "answsERS", "annewlers", "answordERS", "answser", "answoer", "answiners", "ansewlers", "answordered", "answordackers", "ansewer", "anwERS", "answaitERS", "ansswERS", "answered", "annwer", "answoers", "annswERS", "ansewered", "annwlers", "anworder", "annswners", "annewered", "answaiters", "anwordERS", "annwards", "ansWers", "answoERS", "anwordackers", "ansewners", "annwners", "answsards", "anwers", "answaiter", "answlers", "ansswners", "ansswlers", "ansewers", "annswers", "answoered", "ansewards", "anwackers", "answners", "annewERS", "answiner", "ansswer", "answordards", "annewer", "ansWERS", "annwers", "answERS", "annwERS", "annewards", "answinERS", "ansWackers", "answards", "anwer", "ansWer", "ansswers", "answordlers", "annewers", "ansewERS", "annswer"], "answer": ["Answer", "response", "array", "say", "comment", "address", "average", "score", "entry", "name", "text", "grade", "next", "answered", "blank", "message", "default", "equ", "area", " answered", "question", "data", "edge", "eni", "issue", "match", "exit", "length", "term", "complete", "fix", "string", "reply", "feed", "result", "error", "test", "word", "option"]}}
{"code": " \\n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tyield line_index, line.strip().split(' ')\\n  \\n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 1\\n  \t\tcase = []\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not line_index % n:\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \\n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 0\\n  \t\tnew_case = True\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tif new_case:\\n  \t\t\t\tnew_case = False\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\\n  \t\t\t\tlines_left = int(line.strip())\\n  \t\t\t\tif not lines_left:\\n  \t\t\t\t\tnew_case = True\\n  \t\t\t\t\tyield case_counter, case\\n  \t\t\t\tcontinue\\n  \t\t\tif lines_left:\\n  \t\t\t\tlines_left -= 1\\n  \t\t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not lines_left:\\n  \t\t\t\tnew_case = True\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\\n  def part_of_list_to_int(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(int(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_int(array):\\n  \treturn part_of_list_to_int(array, [True] * len(array))\\n  \\n  def part_of_list_to_float(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(float(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_float(array):\\n  \treturn part_of_list_to_float(array, [True] * len(array))\\n  \\n  def get_max_array_on_index(array, index):\\n  \telem_len = len(array[0])\\n  \tassert index < elem_len\\n  \tfor elem in array:\\n  \t\tassert elem_len == len(elem)\\n  \tmax_sub = array[0][index]\\n  \tmax_elem = array[0]\\n  \tfor elem in array:\\n  \t\tif elem[index] > max_sub:\\n  \t\t\tmax_sub = elem[index]\\n  \t\t\tmax_elem = elem\\n  \treturn max_elem\\n  \\n  def list_index_in_sorted_with_position(a_list, value, pos):\\n  \tlist_len = len(a_list)\\n  \tif list_len == 1:\\n  \t\tif a_list[0] == value:\\n  \t\t\treturn pos\\n  \t\treturn -1\\n  \tif a_list[list_len/2] > value:\\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\\n  \telse:\\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\\n  \t\\n  def list_index_in_sorted_list(a_list, value):\\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\\n  \\n  def copy_list(list):\\n  \tres = []\\n  \tfor elem in list:\\n  \t\tres.append(elem)\\n  \treturn res\t\\n  \\n  \\n  def conj_mat(a):\\n  \tR = len(a)\\n  \tC = len(a[0])\\n  \tres = [['.' for _ in xrange(R)] for __ in xrange(C)]\\n  \tfor i in xrange(R):\\n  \t\tfor j in xrange(C):\\n  \t\t\tres[j][i] = a[i][j]\\n  \treturn res\\n  \\n  def one_line_builder(R, C, M):\\n  \tres = []\\n  \tres.extend(['*'] * M)\\n  \tres.extend(['.'] * (C - M))\\n  \tres[-1] = 'c'\\n  \treturn [res]\\n  \t\\n  def two_line_builder(R, C, M):\\n  \tline = []\\n  \tline.extend(['*'] * (M / 2))\\n  \tline.extend(['.'] * (C - M / 2))\\n  \tres = [line, copy_list(line)]\\n  \tres[1][-1] = 'c'\\n  \tif M%2 == 1:\\n  \t\tres[0][-1] = '*'\\n  \treturn res\\n  \t\\n  def three_line_builder(R, C, M):\\n  \tres = [['.' for _ in xrange(C)] for __ in xrange(R)]\\n  \tres[-1][-1] = 'c'\\n  \tm = min([M, R * C - 9])\\n  \tstop_flag = False\\n  \tfor j in xrange(C):\\n  \t\tif stop_flag:\\n  \t\t\tbreak\\n  \t\tfor i in xrange(R):\\n  \t\t\tif m == 0:\\n  \t\t\t\tstop_flag = True\\n  \t\t\t\tbreak\\n  \t\t\tres[i][j] = '*'\\n  \t\t\tm -= 1\\n  \tprint i,j\\n  \tif i == 2:\\n  \t\tres[1][j-1] = '.'\\n  \t\tif j == C - 3:\\n  \t\t\tres[0][j] = '*'\\n  \t\telse:\\n  \t\t\tres[0][-1] = '*'\\n  \t\\n  \tif M <= R * C - 9:\\n  \t\treturn res\\n  \telse:\\n  \t\tm = M - (R * C - 9)\\n  \t\tassert m not in [2, 4, 6, 7, 9]\\n  \t\tassert m > 0\\n  \t\tassert m < 10\\n  \t\t\\n  \t\tres[-3][-3] = '*'\\n  \t\tm -= 1\\n  \t\tif m == 0: return res\\n  \t\tres[-2][-3] = '*'\\n  \t\tres[-1][-3] = '*'\\n  \t\tm -= 2\\n  \t\tif m == 0: return res\\n  \t\tres[-3][-2] = '*'\\n  \t\tres[-3][-1] = '*'\\n  \t\tm -= 2\\n  \t\tif m == 0: return res\\n  \t\tres[-2][-2] = '*'\\n  \t\tres[-2][-1] = '*'\\n  \t\tres[-1][-2] = '*'\\n  \t\tm -= 3\\n  \t\tif m == 0: return res\\n  \t\tassert False\\n  \t\\n  \t\\n  \t\\n  def over_three_line_builder(R, C, M):\\n  \tif M <= (R - 3) * C:\\n  \t\tres = [['*' for _ in xrange(C)] for __ in xrange(M / C)]\\n  \t\tflag = False\\n  \t\tif (M % C) != (C - 1):\\n  \t\t\tline = ['*' for _ in xrange(M % C)]\\n  \t\t\tline.extend(['.' for _ in xrange(C - (M % C))])\\n  \t\telse:\\n  \t\t\tline = ['*' for _ in xrange((M % C) - 1)]\\n  \t\t\tline.extend(['.' for _ in xrange((C - (M % C)) + 1)])\\n  \t\t\tflag = True\\n  \t\tres.append(line)\\n  \t\tindex = len(res)\\n  \t\tres.extend([['.' for _ in xrange(C)] for __ in xrange(R - len(res))])\\n  \t\tif flag:\\n  \t\t\tres[index][0] = '*'\\n  \t\tres[-1][-1] = 'c'\\n  \t\tassert len(res) == R\\n  \t\tassert len(res[0]) == C\\n  \t\treturn res\\n  \telse:\\n  \t\tres = [['*' for _ in xrange(C)] for __ in xrange(R - 3)]\\n  \t\tM -= (R - 3) * C\\n  \t\ttmp = three_line_builder(3, C, M)\\n  \t\tif len(tmp) != 3: # error msg\\n  \t\t\treturn tmp\\n  \t\tres.extend(tmp)\\n  \t\treturn res\\n  \t\\n  def solve(R, C, M):\\n  \tres = None\\n  \t\\n  \tif M == R * C:\\n  \t\treturn 'Impossible'\\n  \tif R >= 3 and C >= 3:\\n  \t\tif R*C - M in [7, 5, 3, 2]:\\n  \t\t\treturn 'Impossible'\\n  \t\treturn over_three_line_builder(R, C, M)\\n  \t\t\\n  \telif R != 1 and C != 1:  #which means one of them is 2, and the other not 1\\n  \t\tif (R*C - M) % 2 == 1:\\n  \t\t\tif M < R*C - 1:\\n  \t\t\t\treturn 'Impossible'\\n  \t\tif M + 2 == R * C:\\n  \t\t\treturn 'Impossible'\\n  \t\telse:\\n  \t\t\tif R == 2:\\n  \t\t\t\treturn two_line_builder(R, C, M)\\n  \t\t\telse:\\n  \t\t\t\ttmp = two_line_builder(C, R, M)\\n  \t\t\t\treturn conj_mat(tmp)\\n  \t\\n  \telse:\t\t\t\t\t#which means one of them is 1\\n  \t\tif R == 1:\\n  \t\t\treturn one_line_builder(R, C, M)\\n  \t\telse:\\n  \t\t\ttmp = one_line_builder(C, R, M)\\n  \t\t\treturn conj_mat(tmp)\\n  \t\t\\n  \treturn res\\n  \\n  def mat_to_str(a):\\n  \tif a in ['Impossible', 'Not Implemented']:\\n  \t\treturn a\\n  \tstr_out = ''\\n  \tfor row in a:\\n  \t\tfor elem in row:\\n  \t\t\tstr_out += elem\\n  \t\tstr_out += '\\n'\\n  \treturn str_out[:-1]\\n  \t\\n  def calc_result(case):\\n  \tresult = None\\n  \t\\n  \tR = int(case[0])\\n  \tC = int(case[1])\\n  \tM = int(case[2])\\n  \tprint R, C, M\\n  \t\\n  \tresult = solve(R, C, M)\\n  \t\\n  \tstr_out = mat_to_str(result)\\n  \tm = str_out.count('*')\\n  \tassert (m==0 or m==M)\\n  \tprint str_out\\n  \t\\n  \treturn '\\n%s' % str_out\\n  \\n  def main(filepath):\\n  \tstart_time = time.time()\\n  \twith file('output.txt', 'wb') as f_out:\\n  \t\t\\n  \t\tfor case_index, case in iterate_cases_1lpc(filepath):\\n  \t\t\t\\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\\n  \t\t\tresult = calc_result(case)\\n  \t\t\t\\n  \t\t\tf_out.write(\"Case #%d: %s\\n\" % (case_index, result))\\n  \t\t\t\t\\n  if __name__ == '__main__':\\n  \tmain(sys.argv[1])\\n", "substitutes": {"filepath": ["filecase", " filecase", "Filepath", "fPath", "filePath", "fcase", "fname", "Filecase", "fpath", "FilePath", " filename", "Filename", " filePath", "filename"]}}
{"code": " \\n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tyield line_index, line.strip().split(' ')\\n  \\n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 1\\n  \t\tcase = []\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not line_index % n:\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \\n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 0\\n  \t\tnew_case = True\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tif new_case:\\n  \t\t\t\tnew_case = False\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\\n  \t\t\t\tlines_left = int(line.strip())\\n  \t\t\t\tif not lines_left:\\n  \t\t\t\t\tnew_case = True\\n  \t\t\t\t\tyield case_counter, case\\n  \t\t\t\tcontinue\\n  \t\t\tif lines_left:\\n  \t\t\t\tlines_left -= 1\\n  \t\t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not lines_left:\\n  \t\t\t\tnew_case = True\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\\n  def part_of_list_to_int(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(int(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_int(array):\\n  \treturn part_of_list_to_int(array, [True] * len(array))\\n  \\n  def part_of_list_to_float(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(float(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_float(array):\\n  \treturn part_of_list_to_float(array, [True] * len(array))\\n  \\n  def get_max_array_on_index(array, index):\\n  \telem_len = len(array[0])\\n  \tassert index < elem_len\\n  \tfor elem in array:\\n  \t\tassert elem_len == len(elem)\\n  \tmax_sub = array[0][index]\\n  \tmax_elem = array[0]\\n  \tfor elem in array:\\n  \t\tif elem[index] > max_sub:\\n  \t\t\tmax_sub = elem[index]\\n  \t\t\tmax_elem = elem\\n  \treturn max_elem\\n  \\n  def list_index_in_sorted_with_position(a_list, value, pos):\\n  \tlist_len = len(a_list)\\n  \tif list_len == 1:\\n  \t\tif a_list[0] == value:\\n  \t\t\treturn pos\\n  \t\treturn -1\\n  \tif a_list[list_len/2] > value:\\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\\n  \telse:\\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\\n  \t\\n  def list_index_in_sorted_list(a_list, value):\\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\\n  \\n  def copy_list(list):\\n  \tres = []\\n  \tfor elem in list:\\n  \t\tres.append(elem)\\n  \treturn res\t\\n  \\n  \\n  def intersect(arr_A, arr_B):\\n  \tprint '\\t\\t%s\\n\\t\\t%s' % (arr_A, arr_B)\\n  \tres = []\\n  \tfor a in arr_A:\\n  \t\tif arr_B.count(a):\\n  \t\t\tres.append(a)\\n  \tprint '\\t\\t%s' % res\\n  \treturn res\\n  \\n  def solve(row_A_selected, board_A,\\n  \t\t  row_B_selected, board_B):\\n  \tres = intersect(board_A[row_A_selected - 1], \\n  \t\t\t\t\tboard_B[row_B_selected - 1])\\n  \tif len(res) == 0:\\n  \t\treturn 'Volunteer cheated!'\\n  \tif len(res) == 1:\\n  \t\treturn res[0]\\n  \treturn 'Bad magician!'\\n  \t\\n  def calc_result(case):\\n  \tresult = None\\n  \t\\n  \trow_A_selected = int(case[0][0])\\n  \trow_B_selected = int(case[5][0])\\n  \tboard_A = case[1:5]\\n  \tboard_B = case[6:10]\\n  \t\\n  \tprint \"row_A_selected: %s\" % row_A_selected\\n  \tprint \"row_B_selected: %s\" % row_B_selected\\n  \tprint \\n  \tprint board_A\\n  \tprint \\n  \tprint board_B\\n  \tprint\\n  \t\\n  \tresult = solve(row_A_selected, board_A,\\n  \t\t\t\t   row_B_selected, board_B)\\n  \tprint result\\n  \t\\n  \t\\n  \treturn result\\n  \\n  def main(filepath):\\n  \tstart_time = time.time()\\n  \twith file('output.txt', 'wb') as f_out:\\n  \t\t\\n  \t\tfor case_index, case in iterate_cases_nlpc(filepath, 10):\\n  \t\t\t\\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\\n  \t\t\tresult = calc_result(case)\\n  \t\t\t\\n  \t\t\tf_out.write(\"Case #%d: %s\\n\" % (case_index, result))\\n  \t\t\t\t\\n  if __name__ == '__main__':\\n  \tmain(sys.argv[1])\\n", "substitutes": {"filepath": ["filecase", " filecase", "Filepath", "fPath", "filePath", "fcase", "fname", "Filecase", "fpath", "FilePath", " filename", "Filename", " filePath", "filename"]}}
{"code": " \\n  def Fill(outmat,R,C,F):\\n      nF=F\\n      outmat[:2,:2]='.'\\n      nF-=4\\n      if nF==0: return\\n  \\n      outmat[2,:2]='.'\\n      nF-=2\\n      if nF==0: return    \\n  \\n      outmat[:2,2]='.'\\n      nF-=2\\n      if nF==0: return\\n  \\n      for iC in xrange(3,C):\\n          if nF==1:\\n              outmat[2,2]='.'\\n              return\\n          outmat[:2,iC]='.'\\n          nF-=2\\n          if nF==0: return\\n          \\n      for iR in xrange(3,R):\\n          if nF==1:\\n              outmat[2,2]='.'\\n              return\\n          outmat[iR,:2]='.'\\n          nF-=2\\n          if nF==0: return\\n  \\n      for iR,iC in ( (iR,iC) for iR in xrange(2,R)\\n                     for iC in xrange(2,C)):\\n          outmat[iR,iC]='.'\\n          nF-=1\\n          if nF==0: return\\n      \\n  \\n  \\n  \\n  def Solve(R,C,M):\\n      F=R*C-M\\n      if F==0: return '\\nImpossible'\\n      if (R>1 and C>1 and F in (2,3)):\\n          return '\\nImpossible'\\n  \\n      outmat=np.zeros( (R,C), dtype='S1')\\n      outmat[:,:]='*'\\n  \\n      if R==1:\\n          for i in xrange(F):\\n              outmat[0][i]='.'\\n      \\n      elif C==1:\\n          for i in xrange(F):\\n              outmat[i][0]='.'\\n  \\n      elif F>1:\\n          if F in (2,3,5,7): return \"\\nImpossible\"\\n          elif (R==2 or C==2) and F%2 != 0:\\n              return \"\\nImpossible\"\\n          elif R==2:\\n              outmat[:,:F/2]='.'\\n          elif C==2:\\n              outmat[:F/2,:]='.'\\n          else: Fill(outmat,R,C,F)\\n          \\n      outmat[0,0]='c'\\n      outmatlines=[ ''.join(x) for x in outmat ]\\n      answer='\\n'+'\\n'.join(outmatlines)\\n  \\n      Verify(answer,F)\\n  \\n      return answer\\n  \\n  disp=[ (dx,dy) for dx in (-1,0,1)\\n      for dy in (1,0,-1) if (dx !=0 or dy!=0) ]\\n  \\n  def Verify(answer,F):\\n      lines=[list(x) for x in answer.split('\\n')]\\n      if len(lines[0])==0: lines.pop(0)\\n      R,C=len(lines),len(lines[0])\\n      assert lines[0][0]=='c'\\n      assert answer.count('.')+1==F\\n      q=Queue.Queue()\\n      q.put( (0,0) )\\n  \\n      def adjToMine(x,y):\\n          for dx,dy in disp:\\n              if 0<=x+dx<R and 0<=y+dy<C:\\n                  if lines[x+dx][y+dy]=='*': return True\\n          return False\\n                  \\n  \\n      while not q.empty():\\n          x,y=q.get()\\n          for dx,dy in disp:\\n              if 0<=x+dx<R and 0<=y+dy<C:\\n                  if lines[x+dx][y+dy]=='c': continue\\n                  lines[x+dx][y+dy]='c'\\n                  if not adjToMine(x+dx,y+dy):\\n                      q.put( (x+dx,y+dy) )\\n  \\n      clicked='\\n'.join([ ''.join(x) for x in lines])\\n      if clicked.find('.')>=0:\\n          print '\\n','*'*20,\"\\nERROR, input:\"\\n          print answer\\n          print 'OUTPUT:'\\n          print clicked\\n      \\n  \\n  \\n  \\n  def parse(infile):\\n      R,C,M=map(int, infile.readline().split() )\\n      return R,C,M\\n  \\n  \\n  \\n  class GCJ_Parser( object ):\\n      def __init__(self,fname):\\n          self.infile=open(fname,'r')\\n          self.NumCases=int(self.infile.readline().strip() )\\n          self.caseNum=0\\n  \\n      def __iter__(self): return self\\n  \\n      def next(self):\\n          if self.caseNum==self.NumCases: raise StopIteration\\n          self.caseNum += 1\\n          args=parse(self.infile)\\n          return self.caseNum , args\\n  \\n  \\n  def runmain():\\n      myCases=GCJ_Parser(sys.argv[1])\\n  \\n      outname=sys.argv[1].rstrip('.in')+'.out'\\n      if os.path.isfile(outname):\\n          oldout=outname+'.old'\\n          ii=0\\n          while os.path.isfile(oldout):\\n              ii+=1\\n              oldout=outname+'.old'+str(ii)\\n          os.rename(outname,oldout)\\n          print 'Rename: %s -> %s'%(outname,oldout)   \\n   \\n      outfile=open(outname,'w')\\n  \\n      for iCase, args in myCases:\\n          answer=Solve(*args)\\n  \\n          print 'Case #'+str(iCase)+':',answer\\n          print >> outfile, 'Case #'+str(iCase)+':',answer\\n  \\n  \\n  \\n  \\n  if __name__=='__main__':\\n      runmain()\\n", "substitutes": {"outmat": ["outputlat", "outcat", "OUTmol", " outmatch", "againcat", "upmat", "OUTMat", "againMat", "Outformat", "offmatch", "Outmult", "atmol", "againmath", "Outmol", "outputmat", "outputcat", "OUTmult", "Outmat", "OUTmath", "outputformat", "outformat", "offmat", "atmath", "againflat", "OUTflat", "againlat", "resultmat", "OUTlat", "outmath", " outMat", "upmol", "Outlat", "upmatch", "outmatch", "inmol", "outputmot", " outmot", "OUTformat", "upformat", "inMat", "offcat", "inflat", "resultmult", " outmol", " outlat", " outmath", "againmot", "outmol", "informat", "againmat", "OutMat", " outformat", "outMat", "outputmol", "resultMat", "resultmol", "inmat", "offmol", "Outmath", " outcat", "outflat", "atmat", "againmatch", "Outcat", " outmult", "inmult", "outputmatch", "againformat", "atcat", "OUTmat", "againmult", "incat", "outlat", "outmult", "outputMat", "outmot", "OUTmot", "Outmot", "againmol", "inmath"], "R": ["P", "O", "A", "CR", "WR", "KR", "S", "JR", "B", "Ra", "MR", "RA", "T", "AR", "RE", "L", "RR", "Run", "X", "Ro", "K", "I", "RN", "RP", "Rec", "BR", "RW", "Rs", "E", "IR", "NR", "RH", "Right", "DR", "RO", "TR", "D", "G", "Rank", "r", "OR", "Rh", " r", "U", "Y", "GR", "RS", "UR", "V", "H", "RL", "RG", "Q", "HR", "W", "SR", "N", "Re", "RF", "RM", "Br", "RC", "Range"], "C": ["CC", "P", "CW", "SC", "Cr", "CR", "A", "O", "CS", "S", "B", "FC", "Cs", "CI", "YC", "JC", "T", "DC", "L", "CL", "CM", "AC", "X", "K", "I", "CV", "Sc", "c", "Ch", "GC", "CU", "E", "CT", "Three", "CNN", "VC", "D", "G", "NC", "EC", "U", "Y", "CA", "Or", "Cl", "Ca", " c", "V", "H", "Cu", "Cor", "KC", "W", "N", "CE", "Con"], "F": ["File", "Z", "P", "FE", "O", "CF", "DF", "A", "new", "FO", "CR", "S", "B", "FC", "cf", "FF", "Fun", "FH", "T", "Fs", "Fl", "FG", "L", "J", "WF", "FB", "X", "f", "I", "K", "If", "GF", "Far", "ELF", "Fit", "E", "FA", "Fe", "IO", "PF", "D", "FL", "G", "IF", "AF", "EC", "Fine", "OF", "U", "Y", "Fi", "V", "H", "Fixed", "Family", "FR", "Q", "W", "N", "EF", "TF", "FD"], "nF": ["iE", "nW", "lC", "unD", " nf", "Nf", "nwL", "nFile", "dnF", "pnELF", "nELF", "iFile", " nV", "nM", "ynELF", "unC", "wW", "dnD", "lG", " nOF", "NE", "NELF", "NL", "NM", "nwF", "nL", "nf", "noneFamily", " nH", "nOF", "nwW", "nQ", "pf", "unF", "cnF", "nanF", "NOF", "nFamily", "lnF", "wL", "neC", " nL", " nG", "fnD", "lnFamily", "fnE", "NC", "pE", "lF", "unQ", "cnM", "cnE", " nE", "dnC", "nG", "pF", "lnQ", "pnF", " nU", " nEF", "lD", "noneV", "nanFamily", "nD", " nFamily", "ynF", "connE", "wf", "ynD", "neF", " nQ", "unFile", "lnE", "nV", "pEF", "cnf", "nE", "nanOF", "lnH", "connFile", "fnf", "neG", "nH", "connf", "nEF", " nM", "NFamily", "lFamily", "nwf", "noneF", "lnf", "nanQ", " nW", " nFile", "nC", "fnU", "dnFamily", "noneE", "NV", " nC", "pnL", "lnEF", "nanE", "pnD", "neD", "fnF", "NFile", "ND", "connF", "nanC", " nD", "iF", "ynL", "wF", "neU", "unFamily", "unH", "fnC", "nU", "NF", "fnV"], "iC": [" iT", "liCNN", "niN", "iM", "iiN", "iiF", "jM", "aU", "siU", "aC", "iN", "eniCNN", "iuR", "iU", "iuC", "iiU", "aR", " iL", "siL", "niC", "biR", "siCs", " iDC", "niL", " iCs", " iSc", "iuM", "liF", "iCNN", " iM", "niR", "siM", "eniDC", "liC", "iL", "eniF", "eniC", "iSc", "jR", "jC", "niM", "liDC", "iuSc", "biM", "siC", "iiM", " iN", " iCNN", "iF", "iiC", "iCs", "jT", "iT", " iF", "siF", "aSc", "aM", "iiR", "biT", "siR", "niCs", "iDC", "aF", "biC"], "iR": [" iAr", "iRs", "pRs", "pM", "iiG", "iM", " iRh", "iN", "jRs", "cC", "siAr", " iB", "ciC", "biR", "ciN", "siRh", "ciM", "iG", "siN", "cB", " iM", "cR", "siM", "iRh", "uM", "aiR", "jR", "uR", "uC", "jC", "iAr", "aiAr", "cAr", "iiRs", "biM", "aiC", "siC", "ciAr", " iN", "pR", "uRs", "iiC", "ciRs", "biRs", " iRs", "ciR", " iG", "iiR", "jRh", "siR", "aiB", "pC", "siRs", "iB", "biC", "siG"], "M": ["Z", "P", "A", "MF", "MN", "B", "MR", "T", "m", "J", "L", "CM", "X", "I", "K", "c", "E", "MM", "D", "MS", "G", "MI", "MC", "OR", "U", "Y", "V", "H", "Q", "W", "N", "RM"], "i": ["p", "it", "li", "id", "ci", "index", "ar", "m", "ini", "phi", "ai", "multi", "d", "l", "f", "I", "c", "ti", "e", "t", "ie", "pi", "xi", "z", "r", "ic", "ni", "a", "j", "im", "mi", "b", "v", "u", "qi", "n", "io", "int", "si", "iu"], "outmatlines": ["outMatlin", "Outmatlines", "out_line", "outcatline", "outcatlin", "outmatlin", "Outmatline", "OutMatlin", "outcatlines", "out_lin", "outMatlines", "out_lines", "outmatline", "outMatline", "OutMatlines", "Outmatlin", "OutMatline"]}}
{"code": " \\n  \\n  def Solve(F1,r1,F2,r2):\\n      s1=set(F1[r1-1])\\n      s2=set(F2[r2-1])\\n      sx=s1.intersection(s2)\\n      if len(sx)>1:\\n          return \"Bad magician!\"\\n      elif len(sx)==0:\\n          return \"Volunteer cheated!\"\\n      else:\\n          return sx.__iter__().next()\\n  \\n  \\n  \\n  def parse(infile):\\n      r1=int(infile.readline().strip())\\n      F1=[]\\n      for i in xrange(4):\\n          F1.append( map(int, infile.readline().split() ))\\n      r2=int(infile.readline().strip())\\n      F2=[]\\n      for i in xrange(4):\\n          F2.append( map(int, infile.readline().split() ))\\n      return F1,r1,F2,r2\\n  \\n  \\n  \\n  class GCJ_Parser( object ):\\n      def __init__(self,fname):\\n          self.infile=open(fname,'r')\\n          self.NumCases=int(self.infile.readline().strip() )\\n          self.caseNum=0\\n  \\n      def __iter__(self): return self\\n  \\n      def next(self):\\n          if self.caseNum==self.NumCases: raise StopIteration\\n          self.caseNum += 1\\n          args=parse(self.infile)\\n          return self.caseNum , args\\n  \\n  \\n  def runmain():\\n      myCases=GCJ_Parser(sys.argv[1])\\n  \\n      outname=sys.argv[1].rstrip('.in')+'.out'\\n      if os.path.isfile(outname):\\n          oldout=outname+'.old'\\n          ii=0\\n          while os.path.isfile(oldout):\\n              ii+=1\\n              oldout=outname+'.old'+str(ii)\\n          os.rename(outname,oldout)\\n          print 'Rename: %s -> %s'%(outname,oldout)   \\n   \\n      outfile=open(outname,'w')\\n  \\n      for iCase, args in myCases:\\n          answer=Solve(*args)\\n  \\n          print 'Case #'+str(iCase)+':',answer\\n          print >> outfile, 'Case #'+str(iCase)+':',answer\\n  \\n  \\n  \\n  \\n  if __name__=='__main__':\\n      runmain()\\n", "substitutes": {"F1": ["fOne", "f3", "Fs2", "Fs1", "fone", "F91", "Fn", "F6", "PF2", "Fone", "M2", "f91", "R1", "M1", " F91", "ROne", "fn", "R6", "Fsn", " F3", "F81", "f81", "f6", "Rone", "f2", "PF1", "F3", " Fn", "Fs91", "FOne", "f1", " Fone", "R3", " F6", "R2", "PF3", "M81", "M3", " FOne", "R81"], "r1": ["fOne", "f3", "srx", " r3", "r3", "nrone", "c01", "r0", "R1", "rh2", "nr0", "rOne", "ROne", "rh3", "r01", "sr2", " rone", "sr3", "c2", "Rone", "f2", "R01", " rOne", "c1", "Rx", "cOne", " r0", " r01", "f1", "sr1", "rx", "R3", "rh1", "nr2", "R2", "R0", "nr1", "rhx", "rone"], "F2": ["f3", "F02", "FII", "f4", "R1", " F0", " FII", "F8", " F4", "FSecond", " F3", "FO3", " FSecond", "f2", "f0", "FO4", "F0", "RII", "R8", " F02", "F3", "RSecond", "R22", "f1", "FOSecond", "R3", "f22", "f8", "R02", "R2", "R0", "F4", " F22", "fII", "FO2", "f02", " F8", "F22", "R4"], "r2": ["r4", " R4", "rgTwo", "R1", " r4", " r8", "F8", "fTwo", "rTwo", "r56", "f2", "rg02", "rg1", "R8", "r8", " r56", "f1", "R02", "r02", "R56", "R2", "rg2", " R2", "RTwo", "F4", " R1", "f02", "R4", " R56"], "s1": ["S3", "ss2", "S2", "S1", "ssx", "s3", "f81", " s10", "ss3", "f2", " s81", "s81", "f1", "ss1", "f10", "s10", " s3", "Sx"], "s2": ["s52", "STwo", "S2", "S1", " s0", "S52", "rTwo", "s0", "s62", "S0", "sTwo", "f2", "f0", "f52", " s62", "r62", "f1", " sTwo", "S62", " s52"], "sx": ["sesX", "sesx", "sxs", "sz", "Sxx", " sxy", "ssxs", "sespx", "esx", "spx", "sxx", "S1", "ssx", " sxs", "ssxy", " sX", "esxy", "esX", "esxs", "esz", "es1", "esxx", "Sxs", "Spx", "ssX", "sxy", "sesxs", "Sx", "sX", "Sz", "SX"], "infile": ["outfolder", "iniFile", "outline", "outFile", "infilename", "insfolder", " inf", " inhandle", "outfilename", "Inline", " inline", "outstream", "ininame", "binline", " inFile", "outf", "InFile", "insfile", "incline", "Infilename", " infilename", "incFile", "insfilename", " inname", "instream", "Infolder", "inifile", "insline", " instream", " infolder", "inistream", "inline", "inihandle", "inifilename", "Instream", "outhandle", "inname", "binf", "inhandle", "incfile", "Infile", "inf", "binfile", "inFile", "binFile", "infolder", "incfolder"], "i": ["p", "it", "o", "iq", "li", "id", "ci", "ai", "x", "ind", "l", "h", "f", "I", "c", "ti", "pi", "z", "r", "a", "g", "j", "b", "v", "ip", "u", "n", "io", "int", "iu"], "self": ["me", "_", "session", "node", "case", "ws", "user", "event", "time", "h", "parent", "default", "os", "tmp", "part", "cmp", "w", "public", "this", "plus", "worker", "home", "Self", "request", "full", "resp", "app", "view", "func", "python", "m", "es", "c", "data", "proc", "exc", "object", "instance", "pos", "ctx", "reader", "n", "result", "results", "p", "config", "spec", "function", "f", "wx", "host", "selves", "client", "e", "parser", "temp", "work", "cl", "call", "error", "private", "now", "ref", "parse", "q", "ns", "x", "l", "http", "other", "cache", "ps", "k", "r", "type", "co", "g", "context", "s", "b", "master", "sys", "method"], "fname": ["fName", "inName", "inno", "Ffile", "fno", "fileName", "Fname", "Fpath", "outpath", "fileno", "flatName", "filefile", "fpath", "filepath", "ffile", "flatname", "inname", "FName", "flatfile", "outName", "flatno", "filename"], "NumCases": ["NumCams", "NumberScase", "NumAcodes", "NumPams", "numCase", "numAcases", "NumScalls", "NumCaces", "NumPalls", "NumScases", "numAcams", "Numcalls", "numAcase", "NumAcase", "Numcase", "NumCase", "NumScaces", "NumberCalls", "NumFams", "Numcaces", "NumFases", "NumCalls", "NumPases", "NumberCaces", "NumAcases", "NumberScases", "NumberCases", "NumPodes", "numAcodes", "NumAcams", "NumCodes", "NumPase", "NumFase", "numCams", "NumScase", "NumberCase", "NumPaces", "NumberScalls", "NumFodes", "numCases", "numCodes", "Numcases", "NumberScaces"], "caseNum": ["aseVal", "asenum", " caseVal", "CaseVal", "CaseNumber", "testNo", "testnum", "casenum", "testNum", "Casenum", "caseNumber", " casenum", "trialnum", "CaseNum", "CaseNo", "trialNum", "testNumber", "aseNumber", "aseNum", "trialNo", " caseNo", "caseNo", "caseVal", "trialNumber", " caseNumber"], "args": ["_", "gen", "parse", " arguments", "ig", "extra", "all", "py", "long", "ix", "lines", "ax", "doc", "aux", "init", "spec", "limits", "params", "ar", "ae", "ay", "GS", "ams", "x", "body", "works", "fields", "arr", "data", "parser", "other", "plays", "gs", "items", "argument", "inc", " arg", "dict", "obj", "stats", "aw", "arg", "parts", "Args", "flags", "ages", "conn", "a", "w", "g", "atts", "s", "words", "Arg", "pos", "loc", "call", "ass", "gu", "cs", "ras", "now", "ds"], "myCases": ["MyAcaser", "MyAcases", "MyCases", "myChakes", "myAcakes", "myAcase", "myCsases", "MyCased", "MyCase", "myCsakes", "myAcaser", "myAcased", "MyCaser", "myCsase", "myCsaser", "myChases", "MyAcased", "MyAcase", "myAcases", "myChaser", "MyCakes", "MyAcakes", "myChased", "myCase", "myCased", "myCsased", "myCakes", "myChase", "myCaser"], "outname": ["outline", "inName", "outsize", "OUTfile", "infilename", " outsize", "outbase", "OUTname", "outnamed", "Outline", "OutName", "outputName", "outfilename", "Outfilename", "outpath", "OUTnamed", "OUTbase", "Outfile", "inpath", "inbase", "insize", "outputname", "OUTName", "Outpath", " outName", "outputfile", " outpath", "outputsize", "offName", "inline", "innamed", "Outnamed", "inname", "Outbase", "Outname", "offname", " outfilename", "outName", "offline", "offpath", " outline"], "oldout": ["oldOUT", "Oldname", " oldagain", "OldOut", " oldname", "newouts", "olderout", "oldname", "oldnet", "Oldouts", "Oldout", "oldin", "newOut", "oldagain", "Oldin", "oldernet", "newagain", " oldOut", "olderin", "OLDout", "newout", " oldOUT", " oldin", "OLDOut", "oldouts", " oldnet", "Oldagain", "OLDin", "OLDOUT", "OLDouts", "oldOut", "newin", "OldOUT", "OLDname", "Oldnet"], "ii": ["img", "ui", "li", "ci", "uu", " iii", "ei", "index", "iii", "ori", "ice", "ini", "ai", "imi", "bi", "flat", "ind", "agi", "gi", "vi", "ti", "eni", "ili", "zi", "mini", "lli", "di", "abi", "pi", "ni", "ali", "fi", "uni", "sci", "II", "hi", "ani", "iss", "lu", "iat", "qi", "si", "inf", "iana", "iso"], "outfile": ["exname", "outline", "OutFile", " outFile", "outFile", "Outfile", "exfile", "Outname", "Outline", "exFile", "exline", " outline"], "iCase": ["ISection", "acase", "aSection", " iSection", "Icase", "ICase", "icase", "iSection", "aCase", " icase"], "answer": ["Answer", "response", "array", "resp", " result", "entry", "su", "example", "answered", "search", "arr", "data", "respond", "ell", "cache", "output", "match", "size", "Result", "number", "now", "call", "reply", "result", "results", " answers", " Answer"]}}
{"code": "f = open('input.in')\\n  g = open('output', 'w')\\n  \\n  T = int(f.readline()[:-1])\\n  \\n  for case in xrange(T) :\\n      R, C, M = map(int, f.readline()[:-1].split())\\n      FREE = R*C - M\\n      if FREE == 0 : res = '\\nImpossible'\\n      elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\\nImpossible'\\n      elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\\nImpossible'\\n      else :\\n          MAP = [['.' for c in range(C)] for r in range(R)]\\n          MAP[0][0] = 'c'\\n          if R == 1 :\\n              for i in range(C-1, C-M-1, -1) : MAP[0][i] = '*'\\n          elif C == 1 :\\n              for i in range(R-1, R-M-1, -1) : MAP[i][0] = '*'\\n          elif R == 2 :\\n              for i in range(C-1, C-M/2-1, -1) : MAP[0][i], MAP[1][i] = '*', '*'\\n              if FREE == 1 : MAP[1][0] = '*'\\n          elif C == 2 :\\n              for i in range(R-1, R-M/2-1, -1) : MAP[i][0], MAP[i][1] = '*', '*'\\n              if FREE == 1 : MAP[0][1] = '*'\\n          else :\\n              com = M / C\\n              for i in range(R-1, max(R-com-1, 2), -1) :\\n                  MAP[i] = ['*' for j in range(C)]\\n                  M -= C\\n              I = max([i for i, j in enumerate(MAP) if j[0] == '.'])\\n              if I == 2 :\\n                  com = M / 3\\n                  if com == 0 : i = C\\n                  for i in range(C-1, C-com-1, -1) :\\n                      MAP[0][i], MAP[1][i], MAP[2][i] = '*', '*', '*'\\n                      M -= 3\\n                  if M >= 1 : MAP[2][i-1] = '*'\\n                  if M >= 2 :\\n                      if i != 1 : MAP[2][i-2] = '*'\\n                      else : MAP[1][0] = '*'\\n              else :\\n                  for i in range(C-1, C-M-1, -1) : MAP[I][i] = '*'\\n                  if i == 1 :\\n                      MAP[I][i] = '.'\\n                      MAP[I-1][C-1] = '*'\\n          res = '\\n' + '\\n'.join([''.join(i) for i in MAP])\\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\\n      g.write(output + '\\n')\\n      print output\\n  \\n  f.close()\\n  g.close()\\n", "substitutes": {"f": ["p", "o", "fp", "lf", "file", "m", "d", "x", "rf", "h", "F", "l", "fr", "fd", "e", "fb", "t", "form", "fc", "info", "tf", "z", "input", "fs", "w", "s", "v", "b", "uf", "u", "sf", "feed", "n", "io", "df", "ff"], "g": ["gen", "group", "gm", "gb", "log", "q", "m", "gui", "mem", "h", "gi", "cfg", "gz", "gs", "ng", "gp", "ga", "G", "k", "gg", "go", "z", "gd", "w", "sg", "gc", "gl", "wm"], "T": ["Z", "P", "TT", "TC", "S", "TA", "L", "TB", "TM", "F", "X", "DT", "TS", "t", "UT", "CT", "E", "TN", "TH", "TX", "D", "G", "SIZE", "TEXT", "Y", "V", "GT", "H", "Q", "W", "N", "TF", "NT"], "case": ["O", "SC", "TC", "cor", "TA", "seq", "REC", "ice", "time", "x", "X", "times", "ace", "ti", "E", "CO", "trial", "TR", "sec", "EC", "cycle", "size", "U", "cm", " X", "toc", "bc", "row", "test"], "R": ["P", "O", "A", "CR", "WR", "S", "JR", "B", "Ra", "COR", "MR", "RA", "AR", "Rem", "NER", "RE", "L", "RR", "CL", "F", "X", "RN", "K", "Rec", "RP", "ER", "YR", "RW", "Ch", "Rs", "E", "IR", "NR", "RH", "CO", "VC", "DR", "RO", "Group", "G", "D", "RED", "Rh", "U", "Y", "GR", "RS", "Cl", "UR", "V", "H", "Co", "RT", "RG", "Q", "W", "SR", "N", "Re", "RC", "RM", "Range"], "C": ["CC", "SC", "A", "COR", "CL", "K", "Sc", "E", "CNN", "Cache", "Core", "RFC", "B", "Cs", "CI", "JC", "ANC", "CM", "WC", "CO", "G", "D", "NC", "CAR", "Y", "Cl", "Co", "CP", "H", "Cu", "SR", "CV", "CR", "S", "YC", "CAN", "Code", "AC", "F", "X", "CU", "CT", "VC", "EC", "U", "Ca", "V", "Q", "W", "Con", "P", "CW", "O", "ERC", "CS", "FC", "DC", "L", "J", "Ch", "GC", "CON", "CN", "MC", "CA", "N", "RC", "CE"], "M": ["Mo", "Z", "P", "O", "LM", "A", "MF", "S", "MN", "AM", "B", "MO", "MR", "RA", "m", "AR", "VM", "L", "MA", "CL", "CM", "J", "F", "X", "DM", "K", "IM", "E", "MM", "MU", "G", "D", "MI", "MS", "MC", "MD", "OM", "Mon", "U", "Y", "V", "H", "MT", "Q", "W", "N", "MX", "RM", "FM", "COM"], "FREE": ["ARE", "DER", "FE", "CLE", "WR", "HOW", "WARN", "RES", "BER", "MAX", "MER", "UN", "COR", "REC", "YOU", "RA", "ERROR", "NER", "RE", "F", "OVER", "ICE", "MON", "ER", "NOR", "REE", "NEW", "ALE", "GE", "CRE", "REM", "CON", "NO", "NR", "FIELD", "CO", "ONE", "VALUE", "ZE", "DE", "RO", "ROM", "SIZE", "EN", "WE", "FILE", "ERE", "GR", "USE", "NE", "CONT", "ORE", "UM", "WARNING", "FR", "NAME", "free", "MODE", "Re", "MORE", "MW", "NUM", "MEN", "Free", " FRE", "TYPE", "EW", "CLOSE", "ENT", "LE", "USER", "NULL"], "res": ["err", "response", "VAL", "resh", "resp", "release", "REC", "our", "details", "gr", "css", "RE", "resolution", "msg", "req", "arr", "RES", "pres", "reason", "reset", " RES", "rus", "REG", "cache", "ress", "reed", "MS", "rez", "match", "lear", "reg", "GR", "re", "rap", "Res", "resource", "clear", "result", "ras", "results", "correct"], "MAP": ["ARE", "CC", "maps", "LM", "LOC", "LOAD", "PER", "MN", "MAX", "SO", "UN", "MO", "ACE", "MR", "PATH", "RAW", "MAC", "ACC", "OP", "CL", "MA", "MP", "CAP", "PUT", "KEY", "RESULTS", "LIST", "DO", "RES", "AP", "MAS", "CT", "CON", "SM", "REG", "APP", "CO", "map", "SET", "RO", "TR", "SIZE", "MS", "Maps", "MH", "MC", "DATA", "FILE", "USE", "GROUP", "GET", "JSON", "ML", "NAME", "MODE", "MW", "MEN", "RM", "NUM", "TYPE", "Map", "COM", "WE", "NULL", "MAT"], "c": ["p", "o", "cc", "cf", "lc", "cn", "m", "d", "x", "h", "l", "cp", "e", "ec", "k", "z", "cm", "w", "cl", "b", "u", "n", "ct"], "r": ["err", "p", "range", "rc", "ar", "m", "ro", "rf", "cr", "e", "ir", "rec", "ur", "rr", "rg", "rn", "cm", "co", "re", "b", "v", "u", "yr"], "i": ["it", "chi", "mu", "index", "cli", "ish", "ai", "h", "y", "ti", "zi", "uri", "xi", "z", "ic", "mi", "v", "u", "ip", "io", "ui", "id", "CI", "m", "ini", "phi", "multi", "bi", "ind", "gi", "yi", "ie", "fi", "II", "n", "int", "il", "p", "li", "comp", "ci", "ei", "ji", "d", "e", "mini", "di", "ni", "a", "im", "si", "o", "ia", "q", "x", "ri", "l", "ii", "pi", "k", "ij", "ib", "s", "b", "iw", "qi", "iu"], "com": ["Com", "CC", "mod", "Component", "up", "all", "dom", "comp", "sim", "TC", "lim", "COR", "CI", "log", "comb", "CL", "x", "CM", "mem", " Com", "X", " COM", "company", "ex", "IM", "uc", "al", "lam", "communication", "CU", "SIM", "REM", "rem", "ME", "CO", "num", "OM", "imp", "con", "conf", "cm", "co", "cl", "im", "ab", "CONT", "min", "cum", "om", "tm", "loc", "common", "comm", "COM", "WE", "tc", "cal"], "j": ["p", "_", "o", "it", "li", "ci", "js", "jit", "q", "jp", "m", "ji", " it", "J", "bj", "l", "oj", "adj", "t", "jl", "aj", "num", " Dj", "obj", "k", "z", "jj", "ja", "IJ", "ij", "im", "dj", " jo", "b", "v", "jo", " J", "n", "si", "item", "json"], "I": ["Z", "P", "IC", "PI", "ci", "VI", "B", "Is", "LI", "CI", "AI", "J", "L", "NI", "X", "F", "GI", "SI", "IA", "BI", "VC", "MI", "KI", "U", "Y", "IJ", "DI", "II", "IT", "V", "UI", "Q", "W", "N"]}}
{"code": "f = open('input.in')\\n  g = open('output', 'w')\\n  \\n  T = int(f.readline()[:-1])\\n  \\n  for case in xrange(T) :\\n      a1 = int(f.readline()[:-1])\\n      M1 = [map(int, f.readline()[:-1].split()) for i in range(4)]\\n      a2 = int(f.readline()[:-1])\\n      M2 = [map(int, f.readline()[:-1].split()) for i in range(4)]\\n      r1 = M1[a1-1]\\n      r2 = M2[a2-1]\\n      res = set(r1).intersection(set(r2))\\n      if len(res) == 1 : res = res.pop()\\n      elif len(res) == 0 : res = 'Volunteer cheated!'\\n      else : res = 'Bad magician!'\\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\\n      g.write(output + '\\n')\\n      print output\\n  \\n  f.close()\\n  g.close()\\n", "substitutes": {"f": ["p", "fp", "lf", "fu", "full", "file", "m", "d", "rf", "h", "F", "l", "fo", "c", "fr", "fd", "fa", "fb", "e", "t", "form", "frame", "fw", "fc", "info", "tf", "handler", "r", "input", "conf", "bf", "fe", "fs", "a", "w", "s", "v", "b", "plus", "uf", "flow", "sf", "feed", "fen", "n", "inf", "df", "folder", "ff", "af"], "g": ["p", "o", "ig", "gen", "bg", "gm", "group", "gb", "file", "m", "gui", "d", "x", "h", "msg", "l", "out", "gi", "cfg", "c", "e", "t", "gz", "gs", "game", "ge", "G", "og", "go", "r", "rg", "w", "j", "sg", "s", "b", "v", "gc", "u", "io", "vg"], "T": ["Z", "TT", "P", "O", "A", "R", "Length", "S", "WT", "B", "time", "L", "F", "X", "K", "I", "TS", "t", "E", "TH", "TN", "D", "M", "G", "U", "Y", "V", "C", "H", "Q", "W", "N", "Time", "NT"], "case": ["ASE", "me", "id", "rice", "catch", "CI", "name", "ice", "time", "x", "X", "step", "phase", "c", "ace", "end", "nce", "code", "choice", "num", "ce", "trial", "match", "a", "USE", "length", "C", "Case", "instance", "line", "number", "race", " CASE", "loc", "ase", "bug", "section", "test", "CE", "patch", "slice", "date", "cases"], "a1": ["ga2", "a81", "A2", "a01", " a81", "r01", "A01", "A1", "area81", "aone", "area1", "ga1", " aone", "gaone", "A81", "area2", "areaone", "Aone", "ga01", "rone"], "M1": ["MOne", "F1", "A2", " M10", "mOne", "R1", "ROne", "A1", "AOne", "m1", "M0", "Rone", "F10", "F2", "F0", "M10", "Mone", "R2", "R0", "R10", " M0", "Aone", "m2", "mone"], "i": ["il", "p", "o", "it", "ui", "li", "id", "ci", "ai", "x", "ind", "l", "I", "ii", "ti", "e", "pi", "xi", "di", "k", "r", "j", "b", "v", "ip", "n", "si", "int", "io", "iu"], "a2": ["a02", " a02", "ma02", "i2", " a22", "atwo", "rTwo", " aTwo", " atwo", "aa02", "aTwo", "i02", "iTwo", "a22", "rtwo", "aatwo", "r02", "aa22", "aa2", "itwo", "ma22", "ma2", "matwo"], "M2": ["A2", "A0", "R1", "m02", "A02", "M02", "A1", "m1", "M0", " M4", "R02", "m0", "R2", "R0", "m4", "M4", "m2", "R4"], "r1": [" r3", "r3", "mOne", "m3", "R1", "rOne", "ROne", " rone", "m1", "Rone", " rOne", "R3", "R2", "m2", "mone", "rone"], "r2": ["cr2", "a4", "r4", "cr1", "a02", "crTwo", "cr0", "r0", "R1", "m02", "rTwo", "m1", "mTwo", "R02", "m0", "r02", "R2", "R0", "RTwo", "m4", "m2", "R4"], "res": ["err", "ris", "response", "R", "resources", "ver", "vals", "resp", "range", "rest", "our", "details", "des", "gr", "RE", "success", "resolution", "msg", "rss", "arr", "req", "right", "RES", "core", "pres", "Rs", "str", "reset", "rates", "reason", "rev", "rem", "ret", "key", "rus", "ress", "os", "rr", "rect", "obj", "rel", "ps", "rh", "sol", "part", "r", "rez", "reg", "rx", "RS", "Result", "re", "Results", "sum", "rap", "remote", "loc", "Res", "rm", "resource", "content", "rises", "rs", "result", "error", "ras", "results", "coll", "rep"], "output": ["img", "format", "O", "response", "four", "unit", "outer", "op", "open", " Output", "full", "region", "print", "expression", "plot", "document", "report", "version", "current", "Input", "struct", "console", "file", "log", "st", "example", "text", "dot", "write", "out", "en", "message", "pretty", "core", "fore", "information", "str", "respond", "cut", "final", "display", "debug", "description", "Output", "input", "r", "plain", "summary", "w", "CONT", "complete", "content", "resource", "n", "letter", "io", "result", "section", "method"]}}
{"code": " \\n  \\n  '''\\n  ...\\n  ...\\n  ...\\n  ...\\n  ...\\n  '''\\n  \\n  for i in range(int(input())):\\n  \\n      r, c, m = tuple(map(int, str.split(input())))\\n      count = r * c - m\\n      field = dict(map(lambda c: (c, \"*\"), itertools.product(range(c), range(r))))\\n      answer = \"Impossible\"\\n  \\n      if m == 0:\\n  \\n          answer = field\\n  \\n      elif 1 in (r, c):\\n  \\n          for p in itertools.islice(itertools.product(range(c), range(r)), count):\\n  \\n              field[p] = \".\"\\n  \\n          answer = field\\n  \\n      elif count in (0, 2, 3, 5, 7):\\n  \\n          pass\\n  \\n      elif count == 1:\\n  \\n          answer = field\\n  \\n      elif count // 2 < c or count == c * 2 + 1:\\n  \\n          if count % 2 != 0:\\n  \\n              tail = 3\\n              ncount = count - 3\\n  \\n          else:\\n  \\n              tail = 0\\n              ncount = count\\n  \\n          for x in range(ncount // 2):\\n  \\n              field[(x, 0)] = field[(x, 1)] = \".\"\\n  \\n          for x in range(tail):\\n  \\n              field[(x, 2)] = \".\"\\n  \\n          answer = field\\n  \\n      elif not (c == 2 and count % c == 1):\\n  \\n          for x in range(c):\\n  \\n              field[(x, 0)] = field[(x, 1)] = \".\"\\n  \\n          count -= 2 * c\\n          tail = 0\\n          if count % c == 1:\\n  \\n              tail = 2\\n              count -= 1\\n  \\n          y = 2\\n          while count > 0:\\n  \\n              rx = min(count, c)\\n              for x in range(rx):\\n  \\n                  field[(x, y)] = \".\"\\n  \\n              count -= rx\\n              y += 1\\n  \\n          for x in range(tail):\\n  \\n              field[(x, y)] = \".\"\\n  \\n          answer = field\\n  \\n      field[(0, 0)] = \"c\"\\n      print(str.format(\"Case #{}:\", i + 1))\\n      if isinstance(answer, dict):\\n  \\n          for y in range(r):\\n  \\n              print(str.join(\"\", map(lambda x: field[(x, y)], range(c))))\\n  \\n      else:\\n  \\n          print(answer)\\n", "substitutes": {"i": ["iq", "ui", "li", "id", "ci", "ix", "index", "ice", "ini", "phi", "ai", "multi", "ind", "f", "I", "ii", "ti", "e", "eni", "mini", "uri", "xi", "pi", "di", "z", "im", "j", "mi", "v", "ip", "u", "n", "si", "int", "iu", "slice"], "r": ["o", "rb", "R", "range", "rc", "q", "ar", "ro", "d", "rf", "h", "l", "ru", "f", "cr", "nr", "right", "e", "ir", "t", "ur", "rr", "k", "rar", "rh", "rn", "w", "g", "a", "re", "sr", "b", "v", "s", "u", "pr", "radius", "n", "rs", "er", "cur"], "c": ["cu", "o", "ci", "ch", "cc", "unc", "col", "cf", "lc", "nc", "dc", "cn", "rc", "sc", "q", "d", "arc", "h", "max", "l", "f", "cr", "uc", "vc", "e", "code", "t", "rec", "cache", "ce", "fc", "ec", "k", "z", "con", "size", "cm", "xc", "cycle", "a", "w", "co", "g", "C", "s", "b", "v", "u", "mc", "n", "cs", "ct", "coll", "pc", "ac", "cy"], "m": ["o", "pm", "more", "mm", "range", "q", "mr", "d", "h", "l", "f", "e", "num", "pi", "M", "z", "size", "cm", "mult", "co", "g", "j", "C", "length", "mi", "b", "v", "number", "u", "dim", "n", "mc"], "count": ["depth", "ount", "all", "level", "force", "case", "ch", "cc", "list", "lc", "score", "index", "range", "name", "order", "time", "h", "parent", "cr", "default", "code", "key", "age", "z", "match", "con", "cm", "carry", "w", "length", "v", "min", "allow", "race", "const", "ac", "offset", "comment", "scroll", "id", "nc", "weight", "ind", "counter", "core", "flag", "C", "number", "n", "col", "len", "log", "d", "max", "f", "e", "num", "size", "content", "loc", "call", "error", "coll", "zip", "child", "more", "process", "cf", "current", "catch", "q", "null", "base", "l", "found", "cond", "cache", "type", "value", "limit", "conf", "cycle", "Count", "sum", "b", "mc"], "field": ["element", "format", "_", "array", "pp", "query", "force", "all", "list", "user", "index", "document", "range", "entry", "order", "player", "default", "play", "question", "lib", "seed", "key", "output", "attribute", "match", "dd", "page", "test", "comment", "service", "id", "fields", "data", "end", "table", "FIELD", "form", "plugin", "the", "C", "object", "diff", "number", "fix", "result", "layer", "term", "manager", "label", "file", "man", "function", "d", "ground", "record", "f", "custom", "message", "equ", "update", "e", "only", "info", "post", "cell", "input", "check", "size", "row", "line", "word", "folder", "option", "box", "child", "group", "q", "cover", "variable", "rule", "condition", "upp", "cache", "type", "value", "url", "wire", "Field", "model", "string", "block", "patch", "source"], "answer": ["side", "response", "array", "image", "query", "swers", "metadata", "evidence", "score", "document", "name", "order", "player", "grade", "parent", "energy", "area", " answered", "question", "eni", "ell", "entity", "output", "issue", "attribute", "ee", "fill", "margin", "fake", "comment", "address", "expression", "arel", "example", "answered", "ace", " explanation", "archive", "form", "description", "video", "number", "fix", "memory", "result", "term", "replace", "say", "message", "equ", "fee", " answering", "update", "edge", "knowledge", "size", "reply", "error", "correct", "option", "err", "Answer", "install", "audio", "average", "offer", "cover", " answers", "practice", "after", "cache", "value", "string", "source", " Answer"], "p": ["ph", "pm", "P", "o", "fp", "pp", "py", "col", "pe", "q", "python", "pn", "np", "ach", "d", "param", "h", "l", "get", "cp", "f", "e", "code", "t", "like", "pre", "pi", "proc", "post", "z", "a", "w", "g", "j", "lp", "b", "v", "pos", "u", "ip", "n", "int", "patch", "pc"], "tail": ["offset", "collection", "wrap", "child", "li", "unit", "sn", "start", "all", "col", "lc", "index", "weight", "len", "run", "ail", "width", "head", "stop", "span", "body", "ind", "target", "l", "lex", "position", "end", "code", "thread", "t", "chain", "tag", "condition", "batch", "cache", "type", "limit", "size", "zip", "lead", "cycle", "support", "length", "left", "sum", "margin", "term", "row", "sync", "number", "line", "loc", "tails", "call", "act", "n", "pull", "tick", "patch", "local", "test", "slice", "coll", "tc"], "ncount": ["llength", "llimit", "ltail", "nncount", "clength", "Nlimit", "nlimit", "nntail", "dcount", "nnlength", "dtail", " nlimit", "ncall", "ccount", "zlength", "Nsize", "nsize", "lcount", "ccall", "ntail", "zcall", "nlength", "ncoll", "dcoll", "Ncount", "nncoll", "lcoll", "dlength", "lcall", "zcount", "lsize", " nsize"], "x": ["ix", "ax", "yx", "index", "name", "ice", "any", "time", "h", "ex", "xa", "code", "no", "key", "xi", "self", "z", "ic", "w", "xy", "v", "plus", "u", "xxxx", "on", "sex", "cross", "id", "full", "pe", "xxx", "view", "es", "ux", "php", "xc", "xp", "n", "int", "ct", "exp", "col", "d", "X", "f", "wx", "e", "t", "xes", "num", "el", "px", "xe", "check", "xs", "work", "j", "row", "my", "xx", "one", "o", "ww", "xf", "q", "lex", "xt", "l", "search", "k", "co", "g", "s", "b", "tx"], "y": ["o", "id", "py", "sy", "col", "q", "ye", "ay", "d", "ny", "python", "ya", "dy", "h", "vy", "f", "l", "get", "iny", "yt", "ry", "ym", "e", "t", "code", "yi", "key", "year", "yd", "z", "type", "Y", "a", "w", "yl", "j", "ey", "yn", "xy", "b", "v", "ys", "zy", "u", "ty", "oy", "n", "yy", "isy", "yr", "cy"], "rx": ["rb", "R", "ra", "col", "lc", "nc", "index", "rc", "circ", "width", "lex", "rf", "xxxxxxxx", "rss", "cross", "ex", "wx", "cr", "ri", "rl", "rd", "core", "nr", "ry", "rec", "mx", "abc", "rr", "fc", "rh", "rt", "cycle", "limit", "size", "co", "sync", "min", "loc", "rw", "radius", "act", "pull", "n", "rs", "lr", "push", "coll", "tx"]}}
{"code": "def read_case():\\n  \\n      answer = int(input())\\n      lines = tuple(map(lambda _: set(str.split(input())), range(4)))\\n      return lines[answer - 1]\\n  \\n  \\n  for i in range(int(input())):\\n  \\n      intersection = read_case() & read_case()\\n      count = len(intersection)\\n      if count == 1:\\n  \\n          answer = intersection.pop()\\n  \\n      elif count > 1:\\n  \\n          answer = \"Bad magician!\"\\n  \\n      elif count < 1:\\n  \\n          answer = \"Volunteer cheated!\"\\n  \\n      print(str.format(\"Case #{}: {}\", i + 1, answer))\\n", "substitutes": {"answer": ["duration", "format", "response", "array", "ix", "evidence", "score", "index", "name", "order", "account", "grade", "next", "energy", "blank", "area", "question", "amount", "eni", "code", "ell", "age", "year", "output", "issue", "episode", "ee", "length", "page", "test", "offset", "comment", "address", "example", "une", "answered", "ace", "archive", "description", "support", "number", "fix", "n", "result", "int", "say", "len", "text", "span", "message", "edge", "e", "respond", "size", "username", "line", "reply", "section", "word", "now", "err", "Answer", "audio", "average", "offer", "cover", "x", "nr", "after", "empty", "see", "cash", "field", "string", " answers"], "lines": ["notes", "files", "runs", "states", "errors", "ips", "codes", "strings", "ids", "reads", "faces", "points", "cycles", "breaks", "items", "models", "values", "objects", "rows", "posts", "elines", "rules", "sections", "letters", "blocks", "parts", "groups", "ines", " Lines", "words", "line", "cells", "comments", "changes", "results", "cases", "pages"], "i": ["p", "it", "iq", "start", "li", "id", "ci", "ix", "index", "ai", "x", "ind", " I", "h", " j", "I", "f", "ii", "c", "ti", "e", "eni", "end", "ie", "uri", "info", "k", "r", "j", "ib", "field", "instance", "ip", "u", "n", "item", "int"], "intersection": [" interection", "intersector", "intsector", "interection", "presector", "intection", "Intersector", " interdivision", "INTERsection", "intsection", "intersections", "intsections", "interdivision", "intdivision", "Interection", "intsect", "INTERsections", "Interdivision", "Intersections", "intersect", "presections", "presect", " intersect", "INTERsector", "Intersection", "presection", "Intersect", " intersections", " intersector", "INTERsect"], "count": ["depth", "child", "array", "start", "all", "force", "div", "case", "id", "list", "more", "group", "catch", "len", "weight", "index", "current", "second", "span", "base", "ind", "parent", "next", "missing", "f", "found", "c", "area", "code", "handle", "cache", "empty", "every", "find", "part", "type", "check", "match", "limit", "size", "Count", "length", "low", "sum", "number", "content", "call", "test", "int", "coll"]}}
{"code": " \\n  class Solver(object):\\n      def __init__(self):\\n          pass\\n      \\n      def solve(self, inputs):\\n          R, C, M = [int(x) for x in inputs[0].split()]\\n          mp = []\\n          for r in range(R):\\n              mp.append(['.']*C)\\n          mp[0][0] = 'c'\\n          outputs = []\\n          if M == 0:\\n              for row in mp:\\n                  outputs.append(''.join(row))\\n              return outputs\\n          rr, cc, rm = R, C, M\\n          while rm >= min(rr, cc):\\n              if rr <= cc:\\n                  for r in range(rr):\\n                      mp[r][cc-1] = '*'\\n                  cc -= 1\\n                  rm -= rr\\n              else:\\n                  for c in range(cc):\\n                      mp[rr-1][c] = '*'\\n                  rr -= 1\\n                  rm -= cc\\n          \\n          if rm == 0:\\n              if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:\\n                  return ['Impossible']\\n          else:\\n              if min(rr, cc) - rm >= 2:\\n                  if rr <= cc:\\n                      for r in range(rr-rm, rr):\\n                          mp[r][cc-1] = '*'\\n                  else:\\n                      for c in range(cc-rm, cc):\\n                          mp[rr-1][c] = '*'\\n              else:\\n                  if min(rr, cc) >= 4:\\n                      if rr <= cc:\\n                          for r in range(2, rr):\\n                              mp[r][cc-1] = '*'\\n                          mp[rr-1][cc-2] = '*'\\n                      else:\\n                          for c in range(2, cc):\\n                              mp[rr-1][c] = '*'\\n                          mp[rr-2][cc-1]='*'\\n                  elif min(rr,cc) == 3:\\n                      if max(rr, cc) == 3:\\n                          return ['Impossible']\\n                      else:\\n                          if rr <= cc:\\n                              mp[2][cc-1] = '*'\\n                              mp[2][cc-2] = '*'\\n                          else:\\n                              mp[rr-1][2] = '*'\\n                              mp[rr-2][2] = '*'\\n                  else:\\n                      return ['Impossible']\\n                      \\n          for row in mp:\\n              outputs.append(''.join(row))\\n          return outputs\\n          pass\\n      \\n      def feed(self, inputs):\\n          lines = [x.strip() for x in inputs]\\n          outputs = []\\n          test_case_n = int(lines[0])\\n          cur = 1\\n          for i in range(test_case_n):\\n              i = i\\n              case_line_cnt = 1\\n              case_inputs = lines[cur:cur+case_line_cnt]\\n              cur += case_line_cnt\\n              R, C, M = [int(x) for x in case_inputs[0].split()]\\n              rslt = self.solve(case_inputs)\\n              if self.verify(rslt, R, C, M):\\n                  outputs.append(rslt)\\n              else:\\n                  raise 'Failed'\\n          return outputs\\n      \\n      def verify(self, outputs, RR, CC, MCNT):\\n          if 'Impossible' == outputs[0]:\\n              return True\\n          rr = len(outputs)\\n          cc = len(outputs[0])\\n          if RR != rr or CC != cc:\\n              return False\\n          bd = []\\n          mask = []\\n          for i in range(rr):\\n              mask.append([1]*cc)\\n              bd.append([0]*cc)\\n              for j in range(cc):\\n                  if outputs[i][j] == '*':\\n                      bd[i][j] = 9\\n                  elif outputs[i][j] == 'c':\\n                      start = (i, j)\\n          for r in range(rr):\\n              for c in range(cc):\\n                  if bd[r][c] == 9:\\n                      for i in [r-1,r,r+1]:\\n                          for j in [c-1,c,c+1]:\\n                              if 0 <= i < rr and 0 <= j < cc:\\n                                  if bd[i][j] != 9:\\n                                      bd[i][j] += 1\\n  \\n          nlist = [start]\\n          while len(nlist):\\n              i, j = nlist.pop(0)\\n              if mask[i][j] != 0:\\n                  mask[i][j] = 0\\n                  if bd[i][j] == 9:\\n                      raise '!!! BOMB'\\n                  elif bd[i][j] == 0:\\n                      for ii in [i-1,i,i+1]:\\n                          for jj in [j-1,j,j+1]:\\n                              if 0<=ii<rr and 0<=jj<cc:\\n                                  if ii != i or jj != j:\\n                                      nlist.append((ii,jj))\\n          mcnt = 0\\n          for r in range(rr):\\n              for c in range(cc):\\n                  if mask[r][c] == 1:\\n                      mcnt += 1\\n                  if mask[r][c] == 1 and bd[r][c] != 9:\\n                      return False\\n                  if mask[r][c] != 1 and bd[r][c] == 9:\\n                      return False\\n          return (mcnt == MCNT)\\n                  \\n  \\n  if __name__ == '__main__':\\n      iname = 'C-small-attempt0.in'\\n      sample_in = '''\\n  7\\n  5 5 23\\n  3 1 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  3 4 0\\n  2 2 3\\n      '''\\n      sample_out = '''\\n  Case #1: 1.0000000\\n  Case #2: 39.1666667\\n  Case #3: 63.9680013\\n  Case #4: 526.1904762\\n      '''\\n      if os.path.exists(iname):\\n          with open(iname) as f:\\n              inputs = f.readlines()\\n      else:\\n          inputs = [x.strip() for x in sample_in.split('\\n') if x.strip()]\\n      solver = Solver()\\n      outputs = solver.feed(inputs)\\n      fail_flag = False\\n      if os.path.exists(iname):\\n          with open(iname+'.out', 'w') as f:\\n              for i, v in enumerate(outputs):\\n                  print >> f, 'Case #%d:'%(i+1)\\n                  print >> f, '\\n'.join(v)\\n      print '===================================================='\\n      for i, v in enumerate(outputs):\\n          print 'Case #%d:'%(i+1)\\n          print '\\n'.join(v)\\n      print '===================================================='\\n      print 'done' if not fail_flag else 'fail'\\n      pass\\n", "substitutes": {"self": ["p", "_", "gen", "Self", "py", "user", "resp", "app", "q", "func", "d", "h", "f", "host", "selves", "client", "e", "t", "os", "obj", "k", "w", "g", "object", "this", "s", "n", "er", "worker"], "inputs": ["outputsets", "Inputp", " inputtests", "Inputsets", "dicts", "outputlines", "Inputd", "inputlines", "inputp", "outputtests", " inputp", " inputlines", "Inputs", "dictsets", "Inputlines", "dictd", "Inputtests", "outputd", "outputp", "dictlines", "inputtests", "inputd", "inputsets"], "R": ["P", "A", "CR", "S", "B", "MR", "RA", "T", "L", "LR", "F", "X", "RN", "K", "Rs", "E", "NR", "RH", "DR", "RO", "D", "G", "U", "Y", "GR", "RS", "V", "H", "RT", "RG", "W", "SR", "N", "RF", "RC", "RM"], "C": ["P", "O", "A", "CR", "SC", "CW", "CS", "S", "B", "CI", "T", "DC", "L", "CL", "CM", "X", "F", "WC", "K", "I", "cr", "CU", "E", "CN", "VC", "D", "NC", "G", "CCC", "MC", "U", "CA", "Cu", "KC", "W", "N", "RC", "RM", "CE"], "M": ["P", "O", "LM", "A", "MF", "S", "MN", "B", "mm", "MR", "T", "m", "L", "CM", "F", "X", "I", "E", "MM", "D", "G", "MH", "MC", "MD", "U", "Y", "V", "H", "Q", "MX", "N", "W", "RM", "mc"], "x": ["p", "dx", "ww", "id", "ix", "ax", "xxx", "xf", "d", "fx", "lex", "xxxxxxxx", "ex", "y", "X", "xa", "ux", "f", "xt", "wx", "e", "t", "xes", "mx", "px", "xi", "xe", "z", "xd", "xs", "xc", " X", "rx", "w", "xy", "xp", "xxxx", "xx", "sex", "exp", "tx"], "mp": ["me", "ph", "fp", "pp", "gm", "fm", "MP", "mph", "mk", "frame", "tmp", "cmp", "match", "cm", "Mp", "ms", "ip", "aps", "mac", "pl", "pm", "amps", "lim", "pe", "app", "params", "m", "mop", "cop", "np", "ap", "msg", "mag", "mx", "cap", "map", "proc", "emp", "imp", "mult", "amp", "pg", "lp", "rep", "p", "mo", "up", "op", "comp", "eps", "mm", "spec", "mb", "mem", "company", "px", "md", "MM", "post", "meta", "yp", "par", "agg", "omp", "loc", "mc", "pc", "zip", "mod", "mate", "ma", "vp", "sp", "ep", "jp", "cp", "rup", "csv", "upp", "large", "ps", "wp", "clip", "mom"], "r": ["err", "p", "rb", "br", "dr", "range", "rc", "oc", "ar", "m", "order", "ro", "rf", "h", "l", "ru", "cr", "rl", "f", "rd", "nr", "fr", "e", "ir", "ur", "rar", "rh", "rt", "k", "rg", "rn", "w", "re", "sr", "b", "attr", "hr", "u", "pr", "loc", "lr", "rs", "er", "yr"], "outputs": ["columns", "OutputS", "outputi", "outputks", "columnions", "Outputks", " outputi", "outputS", " outputps", "outputlines", "inputlines", "Outputions", "outputions", "inputi", "columnlines", " outputks", "Outputi", "Outputlines", "Outputps", "outputps", "Outputs", "columnks", "inputps", " outputS", " outputions", " outputlines", "inputS"], "row": ["mod", "rown", "up", "array", "ow", "col", "rank", "month", "mm", "rc", "mar", "entry", "sc", "order", "ro", "mr", "raw", "record", "rup", "arr", "ack", "rew", "rec", "frame", "ows", "rows", "post", "round", "cell", "input", "match", "cm", "rn", "w", "agg", "Row", "line", "model", "roc", "mat", "feed", "micro", "slice", "gram", "mc", "mac", "rep"], "rr": ["rack", "pp", "tr", "gr", "order", "arc", "orig", "h", "ru", "cr", "wr", "uc", "vc", "code", "rh", "route", "rol", "actor", "sr", "dd", "pr", "bug", "er", "vr", "gro", "aa", "rer", "ac", "rb", "rl", "arr", "req", "ack", "rec", "irc", "gg", "rx", "attr", "lr", "act", "rs", "CR", "ra", "ar", "mr", "rf", "addr", "rss", "f", "rd", "fr", "inc", "ck", "ce", "rar", "bb", "agg", "hr", "ror", "loc", "call", "rw", "error", "coll", "err", "iter", "air", "dr", "cf", "rc", "q", "cover", "kr", "add", "nr", "ir", "adr", "rt", "rg", "rn", "co", "g", "track", "RC", "mc", "der"], "cc": ["case", "lc", "ll", "cr", "uc", "vc", "code", "cmp", "CCC", "ic", "con", "cm", "ca", "cs", "aa", "ac", "cca", "cy", "acc", "dc", "ucc", "nc", "oc", "ack", "rec", "fc", "can", "gg", "xc", "bc", "kk", "rs", "ct", "cu", "ci", "col", "cci", "cn", "com", "f", "custom", "lv", "inc", "ck", "ce", "cell", "bb", "cl", "cd", "loc", "call", "ff", "coll", "pc", "cv", "cf", "rc", "sc", "q", "cp", "sk", "rule", "ec", "k", "go", "anc", "rn", "co", "cb", "g", "RC", "mc"], "rm": ["err", "mod", "ref", "pm", "mn", "rb", "dr", "ci", "mir", "lc", "mm", "range", "rc", "fm", "MR", "nm", "cn", "m", "mr", "kr", "rf", "arm", "cr", "cp", "RP", "rd", "nr", "ym", "bm", "ir", "adr", "cond", "dm", "rom", "rem", "md", "nor", "rh", "cmp", "rt", "cdn", "cre", "cm", "rn", "rx", "co", "orr", "cb", "irm", "cd", "orm", "mi", "sr", "attr", "min", "vm", "lr", "RC", "RM", "km", "mc", "pc"], "c": ["cu", "p", "ci", "unc", "col", "lc", "nc", "dc", "cn", "rc", "sc", "q", "m", "d", "arc", "un", "h", "l", "f", "cp", "count", "cr", "uc", "e", "code", "cache", "ce", "ec", "k", "anc", "con", "ic", "cm", "xc", "co", "cl", "g", "cd", "b", "u", "mc", "loc", "n", "cs", "ct", "coll", "pc", "ac", "cy"]}}
{"code": " \\n  class Solver(object):\\n      def __init__(self):\\n          pass\\n      \\n      def solve(self, inputs):\\n          r1 = int(inputs[0])\\n          cs1 = set([int(x) for x in inputs[r1].split()])\\n          r2 = int(inputs[5])\\n          cs2 = set([int(x) for x in inputs[5+r2].split()])\\n          r = cs1.intersection(cs2)\\n          cnt = len(r)\\n          if 1 == cnt:\\n              return max(r)\\n          elif 0 == cnt:\\n              return 'Volunteer cheated!'\\n          else:\\n              return 'Bad magician!'\\n          pass\\n      \\n      def feed(self, inputs):\\n          lines = [x.strip() for x in inputs]\\n          outputs = []\\n          test_case_n = int(lines[0])\\n          cur = 1\\n          for i in range(test_case_n):\\n              i = i\\n              case_line_cnt = 10\\n              case_inputs = lines[cur:cur+case_line_cnt]\\n              cur += case_line_cnt\\n              outputs.append(self.solve(case_inputs))\\n          return outputs\\n  \\n  if __name__ == '__main__':\\n      iname = 'A-small-attempt0.in'\\n      sample_in = '''\\n      3\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  3\\n  1 2 5 4\\n  3 11 6 15\\n  9 10 7 12\\n  13 14 8 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  3\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n      '''\\n      sample_out = '''\\n   Case #1: 7\\n  Case #2: Bad magician!\\n  Case #3: Volunteer cheated!\\n      '''\\n      if os.path.exists(iname):\\n          with open(iname) as f:\\n              inputs = f.readlines()\\n      else:\\n          inputs = [x.strip() for x in sample_in.split('\\n') if x.strip()]\\n      solver = Solver()\\n      outputs = solver.feed(inputs)\\n      fail_flag = False\\n      if os.path.exists(iname):\\n          with open(iname+'.out', 'w') as f:\\n              for i, v in enumerate(outputs):\\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\\n      else:\\n          ans = set([x.strip() for x in sample_out.split('\\n') if x.strip()])\\n          for i, v in enumerate(outputs):\\n              t = 'Case #%d: %s'%(i+1, str(v))\\n              if t not in ans:\\n                  print '!!! Wrong:', t\\n                  fail_flag = True\\n      print '===================================================='\\n      for i, v in enumerate(outputs):\\n          print 'Case #%d: %s'%(i+1, str(v))\\n      print '===================================================='\\n      print 'done' if not fail_flag else 'fail'\\n      pass\\n", "substitutes": {"self": ["p", "_", "Self", "node", "ws", "full", "user", "app", "q", "view", "m", "writer", "d", "h", "parent", "f", "host", "selves", "connection", "c", "client", "e", "other", "cache", "os", "k", "super", "work", "w", "g", "cl", "j", "context", "object", "this", "b", "server", "master", "reader", "er", "worker", "peer"], "inputs": ["pullds", "acceptwords", "inputes", "subjectwords", "Inputerences", "subjectds", "inclines", "pulld", "Inputn", "subjecterences", "Inputes", "Inputds", "Inputgroups", "outputuments", "Inputs", "inputments", "subjects", " inputments", "inputsets", "Inputwords", "columns", " inputl", "outputn", "subjectd", "Inputd", "columnuments", "inputds", "columnss", " inputds", "columngroups", " inputples", "inputn", "Inputlines", "outputd", "inputb", "outputerences", "inputd", "columnsets", "Inputb", "outputsets", "subjectes", "pulles", "columnples", " inputd", "Inputsets", " inputn", "accepterences", "outputlines", " inputerences", "inputlines", "pulls", "columnlines", "outputments", "inputwords", "incs", " inputsets", " inputss", " inputwords", "acceptlines", "Inputss", "incuments", "outputwords", "incsets", "accepts", "Inputples", "inputuments", "columnb", "subjectsets", "inputples", "inputss", "Inputl", " inputlines", " inputgroups", "inputerences", " inputb", "inputl", "acceptments", "inputgroups", "outputl", "acceptd"], "r1": ["sr0", "r7", "rr1", "sr5", "nr5", "r0", "R1", " r61", "rr2", "nr0", "sr2", "rr61", "R61", "R5", "rr7", "sr1", "r5", "nr2", "R2", "R0", "nr1", "R7", "r61", " r7"], "cs1": ["CS2", "css0", "CS1", "c0", "csone", "cone", "c91", "c5", "qs1", "cs5", "css2", " cs91", "c2", "c1", " csone", "css1", "qs5", "cs91", "css5", "qs2", "CS91", "cs0", "CSone", "qs0"], "x": ["_", "case", "ix", "ax", "index", "read", "est", "plex", "name", "h", "ex", "y", "xa", "code", "xi", "z", "w", "yl", "xy", "u", "xxxx", "sex", "xml", "test", "cross", "id", "xxx", "m", "python", "fx", "out", "ux", "c", "data", "ady", "xc", "rx", "xp", "n", "int", "ct", "layer", "p", "config", "file", "d", "text", "X", "f", "wx", "inx", "str", "e", "xes", "px", "input", "rex", "expl", "xs", "work", "content", "xx", "word", "dx", "xf", "q", "lex", "xt", "l", "k", "nex", " X", "g", "s", "string", "tx"], "r2": ["Rtwo", "ertwo", "sr5", "c0", "er2", "ar2", "r0", "R1", "c5", "ar5", "ar0", "ar1", "er5", "sr2", " r5", "c2", "c1", " r0", "R5", "rtwo", "srtwo", "sr1", "r5", "R2", "er1"], "cs2": ["csn", "CS2", "acs2", "cTwo", "CS1", "c0", "cn", "cssTwo", "c5", "cs5", "CSn", "css2", "CS0", "c2", "acsTwo", "c1", "csTwo", " cs0", "css1", "css5", " csn", "cs0", "acs1", "acs5"], "r": ["p", "o", "rb", "R", "br", "range", "q", "m", "d", "kr", "h", "l", "cr", "c", "arr", "fr", "right", "e", "ir", "nr", "rec", "rev", "rr", "k", "rh", "rg", "rx", "w", "g", "s", "b", "sr", "re", "u", "rw", "radius", "n", "rs", "er", "result"], "cnt": ["fcct", "lcnd", "pcst", "cnc", "connt", "lcst", "conrt", " cst", "lcrt", "connc", "rcnt", "rcnd", "lcct", " cne", "pcnt", "pcnc", "crt", "cst", " cnc", "lcnc", "fcnc", "rcct", "lcne", "pcrt", "fcnt", "fcnd", "lcnt", "conne", "cct", "cnd", "rcnc", " crt", "cne"], "lines": ["tests", "steps", "files", "vals", "ls", "runs", "vs", "ws", "plugins", "log", "limits", "pins", "ins", "codes", "works", "strings", "es", "l", "ids", "reads", "faces", "pages", "cycles", "points", "ses", "items", "models", "values", "lins", "sites", "frames", "objects", "rows", "elines", "rules", "sections", "blocks", "groups", "xs", "liners", "ines", "s", "words", "line", "cells", "comments", "rings", "cases", "breaks"], "outputs": [" outputd", "inputes", " outputes", "putts", "outputn", "outputes", " outputn", "putl", "putlines", "outputlines", "Outputes", "inputlines", " outputl", "methodd", "Outputlines", "paths", "methodn", "outputments", "Outputs", "Outputments", "inputwords", " outputments", "methods", "puts", "pathd", "outputts", " outputlines", "outputd", "inputl", "inputments", "pathn", "Outputl", " outputwords", "Outputwords", " outputts", "outputl", "outputwords", "inputts"], "test_case_n": ["test_case_c", "case_cases_num", "test_cases_p", "test_cases_c", "test_cases_n", "case_cases_N", "case_cases_size", "case_case__size", "case_case_num", "case_case__N", "test_cases_num", "case_case__n", "test_case_p", "case_case_N", "case_case__num", "case_case_n", "test_case_num", "case_cases_n", "case_case_size"], "cur": ["iter", "cu", "ph", "ver", "start", "div", "dr", "ci", "ch", "id", "case", "cor", "Cur", "pub", "focus", "current", "rc", "dec", "sc", "rest", "sur", "usr", "ind", "oct", "count", "cr", "ah", "c", "uc", "shift", "keep", "rev", "inc", "ur", "tri", "num", "sth", "prev", "aug", "ctr", "con", " Cur", "length", "row", "sr", "th", "char", "pr", "const", "loc", "quad", "ct", "enc", "ser"], "i": ["p", "it", "chi", "li", "start", "id", "ci", "ix", "ch", "index", "rest", "ini", "phi", "ai", "d", "bi", "ind", "y", "l", "gi", "I", " I", "h", "f", "ii", "c", "ti", "e", "inner", "uri", "xi", "pi", "k", "z", "a", "j", "b", "pos", "u", "ip", "n", "si", "int", "ih", "iu"], "case_line_cnt": ["case_line_ucnt", "case_line_cn", "case_line_lcct", "case_line_ucct", "case_line_ucn", "case_line_cnc", "case_line_lcNT", "case_line_cct", "case_line_CNT", "case_line_lcno", "case_line_acn", "case_line_Cnc", "case_line_acnt", "case_line_nnt", "case_line_Cno", "case_line_Cnt", "case_line_acnc", "case_line_acno", "case_line_cno", "case_line_ucNT", "case_line_cNT", "case_line_nn", "case_line_acct", "case_line_acNT", "case_line_nNT", "case_line_lcnc", "case_line_lcnt", "case_line_nct"], "case_inputs": ["case_selectes", "case_inputes", "case_outputes", "case_columnlines", "case_controllines", "case_controlerences", "case_configes", "case_inputlines", "case_outputs", "case_controlstates", "case_configlines", "case_columns", "case_columnerences", "case_columnstates", "case_selectlines", "case_controls", "case_selects", "case_outputstates", "case_inputerences", "case_configs", "case_outputlines", "case_inputstates", "case_outputerences"], "iname": ["ninAME", "IName", " inamer", " inamed", "ninaming", "iniamed", "ninasm", "inamed", "inAME", "name", "INnam", "iniames", " inames", " inaming", "inaming", "iniAME", "iniame", "innam", "inamer", "insaming", "insasm", "inasm", "iniamer", "inames", "insame", "niname", "INamer", "INames", "insAME", "named", "namer", "nAME", " inasm", "ininam", " innam", " inAME"], "sample_in": ["sample2ins", "samplepleout", "sample2conn", "sample_ins", "sample2in", "sampleplein", "sample_conn", " sample_IN", "samplepleconn", "sample_IN", "sample2out", "samplepleins", " sample_ins", " sample_conn"], "sample_out": ["samplepagain", "case_list", "sample_list", "case_again", "samplepout", "case_out", "sampleplist", "sample_again", "case_in", "samplepin"], "solver": ["setsolved", "setsolve", "solar", "setsolver", "solved", "sistor", " solar", "Sistor", "solution", " solve", "Solve", "Solar", "setsolution", " solution", "setsistor", "Solved", " sistor", " solved", "setsolar", "Solution", "Solver", "solve"], "fail_flag": ["cond\n", " fail\n", "fail\n", "success\n"]}}
{"code": "'''\\n  Created on Apr 12, 2014\\n  \\n  @author: mostasem\\n  '''\\n  \\n  def getFloorRoots(m):\\n      r1 = -1 + math.sqrt(1 + (8 * m))/2\\n      r2 = -1 - math.sqrt(1 + (8 * m))/2\\n      return int(math.floor(r1))\\n      \\n  def boardHasZero(R,C,M):\\n      if(R > 1 and C > 1):\\n          S = M/C\\n          Sr = M % C\\n          print S,Sr\\n          return R >= S+3 or (R == S+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (R == S+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)\\n      else :\\n          return M <= ((R*C) - 2)\\n  \\n  \\n  def generateMineSweeperCase(R,C,M):\\n  \\n      board = \"\"\\n  \\n      if( R > 1 and C > 1 ): # generate special\\n          S = M/C\\n          Sr = M % C\\n          print S,Sr\\n          if(S): # all rows of *\\n              board +=\"\\n\"\\n              if(R >= S+3 or (R == S+2 and Sr % 2 == 0)):\\n                  board += (S - 1) * ((C*\"*\") + \"\\n\")\\n              else:\\n                  board += (S - 2) * ((C*\"*\") + \"\\n\")\\n              board +=  ((C*\"*\"))\\n              \\n          if(R >= S+3):\\n              if(Sr):\\n                  board +=\"\\n\"\\n                  board += ((Sr *\"*\") + ((C - Sr) *\".\"))\\n              Rm = R - (S + 1)\\n              if(Rm):\\n                  board +=\"\\n\"\\n                  board += (Rm - 1) * ((C*\".\") + \"\\n\")\\n                  board +=  ((C*\".\"))\\n                  \\n          elif(R == S + 2):\\n              Sm = 0\\n              if(Sr % 2 == 0):\\n                  board +=\"\\n\"\\n                  board += (((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\") +\"\\n\")\\n                  board += ((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\")\\n              else:\\n                  board +=\"\\n\"\\n                  board += (((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\") +\"\\n\")\\n                  board += ((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\")\\n          else :\\n              Sm = Sr + C\\n              board +=\"\\n\"\\n              board += (((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\") +\"\\n\")\\n              board += ((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\")\\n                  \\n          list_board = list(board)\\n          list_board[len(list_board) - 1] = 'c'\\n          board = \"\".join(list_board)\\n      else:\\n          board +=\"\\n\"\\n          if(C == 1):\\n              board += M * \"*\\n\"\\n              board += (R-M-1) * \".\\n\"\\n              board +=  \"c\"\\n          else:\\n              board += M * \"*\"\\n              board += (C-M-1) * \".\"\\n              board += \"c\"\\n              \\n      return board\\n         \\n         \\n         \\n  \\n  f_r = open('C.in',\"r\")\\n  n_test=int(f_r.readline().strip()) \\n  f_w = open(\"C.out\", \"w\")\\n  result = \"\"\\n  for i in range(n_test):\\n      R,C,M = map(int,f_r.readline().split())\\n      print R,C,M\\n      if(boardHasZero(R,C,M)):\\n          result = generateMineSweeperCase(R,C,M)\\n      else :\\n          result =\"\\nImpossible\"\\n      print result\\n      output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)\\n      f_w.write(output_str+'\\n')\\n      \\n  f_r.close()\\n", "substitutes": {"m": ["p", "o", "mn", "gm", "mu", "mm", "fm", "mr", "d", "x", "h", "l", "y", "f", "c", "bm", "e", "dm", "i", "hm", "r", "a", "w", "g", "im", "j", "mi", "s", "v", "b", "dim", "ms", "tm", "rm", "n", "km", "wm"], "r1": ["sr0", "p8", "p1", " r3", "r3", "r0", "R1", " r8", "sr2", "p2", "sr3", " r0", "p0", "R8", "r8", "sr1", "R3", "R2", "R0"], "r2": ["R1", " r4", " R2", "R2", "R0", "r4", " R1", " R4", " r0", " R0", "R4", "r0"], "R": ["P", "O", "A", "WR", "JR", "B", "Ra", "RA", "T", "AR", "RE", "L", "RR", "F", "X", "RN", "K", "I", "BR", "RP", "ER", "RW", "Rs", "E", "IR", "RH", "Right", "DR", "RO", "D", "G", "r", " r", "U", "Y", "GR", "RS", "V", "H", "Q", "W", "N", "Re", "SR", "Res", "RM"], "C": ["CC", "P", "CW", "A", "O", "CR", "CF", "B", "Cs", "CI", "YC", "JC", "T", "CL", "DC", "L", "Code", "CM", "X", "F", "I", "K", "CV", "Sc", "c", "Ch", "CU", "Cow", "E", "CN", "CO", "CNN", "VC", "Cache", "D", "G", "NC", "EC", "MC", "Custom", "U", "Count", "Y", "Ca", "CA", " c", "V", "H", "Co", "Cu", "Size", "Mc", "Q", "W", "N", "CE"], "M": ["Z", "P", "O", "LM", "A", "MF", "B", "T", "J", "L", "MA", "CM", "F", "X", "I", "K", "c", "E", "SM", "MM", "D", "G", "MC", "U", "Y", "V", "H", "Q", "W", "N", "RM"], "S": ["P", "SL", "A", "O", "SC", "CS", "B", "SE", "Ns", "T", "L", "Sa", "F", "X", "SA", "K", "Sc", "Ps", "Rs", "TS", "E", "SI", "D", "G", "MS", "r", "U", "Y", "Sec", "RS", "System", "V", "H", "s", "Si", "Sl", "Sh", "AS", "SU", "Q", "NS", "W", "N", "SH", "SS"], "Sr": ["Usr", "Usra", "Statessr", "Srs", "Dsr", "Psr", "Dsri", " Sra", "PSr", "Psrs", "Psri", " Spr", "Aspr", "Sir", " Src", "Desr", "sr", "Spr", " Ssr", "SSra", "SSpr", "CSsr", "skr", "Usrs", "src", "SSr", "Statesr", "SSnr", "PSrc", "Dsrs", " SSr", "UsR", "SSyr", "Scr", "CSr", "Desir", " SSsr", "Ssr", "SSir", "Skr", "Statesrr", "Statespr", "SR", "sR", "Asr", "ssr", "Pspr", "Scrs", "CSnr", "Syr", " Skr", "Srr", "Pssr", "Nr", "ScR", "NR", "Sra", " SSkr", "SSsr", "Scra", "Psrr", "Dsra", "PSrs", " Sir", "Nnr", "Despr", "Nrc", " SSR", "Nsr", "Sri", "Assr", "Src", "Psrc", "CSyr", " SR", "PSri", "Nyr", "DsR", "Desra", "Asrr", "Dsrc", "Snr"]}}
{"code": "'''\\n  Created on Apr 11, 2014\\n  \\n  @author: mostasem\\n  '''\\n  \\n  \\n  \\n  def getIntersection(A,B):\\n      intersect_list = []\\n      dict = {};\\n      for i in range(4):\\n          if(dict.get(A[i]) <> None):\\n              dict[A[i]] += 1\\n              if(intersect_list.count(A[i]) == 0):\\n                  intersect_list.append(A[i])\\n          else:\\n              dict[A[i]] = 1\\n          if(dict.get(B[i]) <> None):\\n              dict[B[i]] += 1\\n              if(intersect_list.count(B[i]) == 0):\\n                  intersect_list.append(B[i])\\n          else:\\n              dict[B[i]] = 1\\n  \\n      return intersect_list\\n  \\n  f_r = open('A.in',\"r\")\\n  n_test=int(f_r.readline().strip()) \\n  f_w = open(\"A.out\", \"w\")\\n  result = \"\"\\n  for i in range(n_test):\\n      cards1 = []\\n      row_index_1 = int(f_r.readline()) - 1\\n      for j in range(4):\\n          cards1.append(map(int,f_r.readline().split()))\\n      cards2 = []\\n      row_index_2 = int(f_r.readline()) - 1\\n      for j in range(4):\\n          cards2.append(map(int,f_r.readline().split())) \\n      int_list =  getIntersection(cards1[row_index_1], cards2[row_index_2])\\n      result = \"\"\\n      if(len(int_list) == 0):\\n          result = \"Volunteer cheated!\"\\n      elif(len(int_list)  == 1):\\n          result = str(int_list[0])\\n      else:\\n          result = \"Bad magician!\"\\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\\n      print output_str\\n      f_w.write(output_str+'\\n')\\n  f_r.close()\\n  f_w.close()\\n", "substitutes": {"A": ["File", "AA", "Data", "Acc", "P", "Array", "From", "An", "There", "S", "Alpha", "One", "Any", "API", "Default", "Input", "Auth", "T", "Average", "As", "Ant", "L", "F", "X", "If", "I", "New", "Action", "Ha", "This", "AP", "Init", "E", "All", "And", "Australia", "The", "Center", "Apple", "D", "M", "G", "At", "LA", "Args", "Ca", "a", "CA", "Y", "Am", "Ang", "C", "Part", "W", "N", "Ab", "App", "Product", "Ar", "First"], "B": ["File", "Data", "Test", "P", "O", "NB", "R", "AB", "LB", "Bar", "Second", "S", "UB", "Ub", "DB", "Band", "Block", "T", "BF", "BE", "L", "Cloud", "BB", "BC", "F", "X", "I", "Bi", "BS", "AP", "Base", "BD", "E", "BI", "Beta", "D", "M", "G", "QB", "Two", "GB", "U", "Y", "C", "V", "b", "Bah", "WB", "BA", "But", "W", "N", "OB", "Both", "Bs", "Other", "Big", "Sub"], "intersect_list": ["intersect_all", "intersectxmap", "intersectingtable", "intercept_List", "intersectadview", "intersect_l", "intersect_lists", "intersecterlc", "intersect_lc", "intersectadlists", "intersect_file", "intersectadl", "intersectinglist", "intersectenlisted", "intersectinglisted", "intersectenlist", "intersect_map", "intersection_all", "intercept_list", "intersectxlisted", "intercept_l", "intersection_lists", "intersection_listed", "intersect_view", "intersection_view", "intersect_listed", "intersectertable", "intersection_l", "intersectadlist", "intersectenall", "intersect_List", "intersecterlist", "intersection_table", "intersectenl", "intersect_table", "intersectxlist", "intersectxl", "intersection_list", "intersection_map", "intersecterl", "intersection_lc", "intersectingl", "intercept_file"], "dict": ["session", "array", "id", "list", "col", "doc", "config", "db", "pair", "document", "index", "file", "details", "view", "ignore", "d", "body", "lock", "get", "cont", "host", "count", "default", "f", "c", "arr", "data", "client", "collect", "table", "code", "cond", "dir", "rec", "state", "key", "inc", "condition", "cache", "batch", "hash", "json", "map", "self", "module", "sign", "dat", "con", "conf", "conn", "ict", "utils", "sum", "b", "model", "diff", "compl", "sync", "fix", "const", "block", "clean", "bug", "n", "int", "df", "patch", "coll"], "i": ["it", "chi", "index", "name", "cli", "ai", "h", "y", "ti", "zi", "key", "uri", "xi", "z", "v", "u", "ip", "io", "slice", "ui", "isi", "id", "init", "oi", "ori", "ini", "phi", "multi", "bi", "ind", "gi", "counter", "c", "yi", "ie", "trial", "fi", "hi", "n", "int", "bis", "p", "li", "ci", "ei", "iii", "ji", "d", "f", "I", "e", "t", "mini", "di", "info", "ni", "ali", "a", "si", "o", "ki", "x", "ri", "l", "ii", "udi", "pi", "k", "type", "r", "ij", "g", "s", "b", "qi", "iu"], "f_r": ["f64rr", "feilerro", "fpyro", "fipar", "f23r", "f5rr", "f_err", "fd_out", "fipt", " f_h", " f2r", "f13r", "fe_ro", "f__r", "z_p", "filerreader", "f25w", "f25r", "fs_rb", "fs5rb", " f2rl", "fLogr", "f__rl", "f_t", "z23p", "f_or", "f2r", "f_ro", "fe_r", "f64err", "f_c", "f13or", "fpyp", "f64r", "f__c", "f5err", "fs5r", "f13h", "f23p", "f_writer", "fipout", "fLogw", "fd_r", "f_rr", "z23ro", "f__writer", "fs_rr", "fpyr", "z23r", "f_rd", "z_rd", "f2b", "f2rl", "f__b", "z_ro", "filerc", " f_writer", "f12h", "fadep", "fs5rr", " f_rt", "f5r", "feilerc", "fLogwriter", "fpyrd", " f_or", "feilerreader", "f12rt", "fs5err", "fd_t", "fs_r", "f25rl", "f13rt", "f_p", "f__w", "fs_err", "f_rl", "f64rb", "fadero", "fader", " f_b", "f_rb", "f25b", " f2w", " f2b", "filerro", " f_rl", "f12r", "f5rb", "f_rt", " f_c", "f_reader", "z_r", "f_h", "fLogc", "faderd", "filerr", "f23rd", "f12or", "fe_reader", "f_ar", "fe_c", "fipr", "f2w", "f_b", "f_out", "fd_ar", "z23rd", "feilerr", "f23ro"], "n_test": [" n_testing", "N_test", "n_testing", "n__Test", "N_Test", "n__test", "N_tested", "n_match", "n__testing", " n_match", "n_tested", "n_Test", "n__tested", "N_testing"], "f_w": ["firmr", "f2writer", " f_wa", " f_rw", "fadewa", "f_writer", " f_ex", "firmw", " f2r", "f_ex", " f_W", "fadew", "f_write", "f2ex", "firmwrite", " f2ex", "firmwriter", " f2writer", " f2write", "f_rw", "f_W", "f2w", "f2W", " f_writer", " f_write", "fader", "f2write", "faderw", "f2r", " f2W", "f_wa", " f2w"], "result": ["err", "format", "mate", "response", "array", "comment", "res", "case", "main", "report", "catch", "our", "name", "example", "product", "success", "msg", "card", "search", "message", "default", "html", "data", "answer", "str", "reason", "final", "ret", "json", "status", "output", "description", "r", "match", "value", "summary", "warning", "Result", "diff", "compl", "complete", "content", "string", "page", "cup", "test", "error", "results", "date", "term", "method"], "cards1": [" cardsA", "fields81", " cards81", "card1", "rowsb", "cardb", "cardOne", "fields2", "card81", " cardsOne", "listsA", "card2", "rowsOne", "rows1", "fields1", "lists81", "rows2", "lists1", "cardsOne", "listsOne", "cardsA", "fieldsOne", " cardsb", "fieldsA", "cardsb", "cards81"], "row_index_1": ["row_indexE1", "row_slice_8", "row_index08name", "row_index087", "row_index___25", "row_index_7", "row_indexE25", "row_index___8", "row_index081", "row_index_part", "row_index_25", "row_indexEpart", "row_index_8", "row_slice_part", "row_index___1", "row_index___part", "row_index_name", "row_index082", "row_indexE8", "row_slice_1", "row_slice_25"], "j": ["p", "_", "it", "q", "jp", "m", "d", "J", "x", "un", "ind", "h", "l", "f", "c", "end", "e", "t", "aj", "num", "job", "k", "z", "jj", "r", "g", "im", "ij", "b", "v", "jam", "n", "uj"], "cards2": ["cardTwo", "card1", "lines02", "cards4", "lights2", "checks02", "continTwo", "card22", "linesTwo", "contin1", "card2", "checks2", "cards22", "capsTwo", "lights0", " cards22", "cardsTwo", "cards02", "checks4", " cards4", "card0", "contin2", "caps02", "card4", "lights1", " cards0", "lines2", "lines4", "caps4", "checksTwo", " cardsTwo", "lights4", "caps2", "cards0", "contin22"], "row_index_2": ["row_indexL2", "row_key_10", "row_key_l", "row_index_02", "row_keyL2", "row_length_2", "row_length_second", "row_indexLl", "row_index_second", "row_indexF2", "row_indexLTwo", "row_index_Two", "row_index_l", "row_key_Two", "row_indexF10", "row_length_4", "row_indexFTwo", "row_indexFl", "row_index_10", "row_index_4", "row_keyL10", "row_keyLl", "row_length_02", "row_indexL10", "row_keyLTwo", "row_key_2"], "int_list": [" int_pair", "int_part", "number_list", "intedpart", "intdlist", "int24dict", "void24listed", "int24load", "void_count", "switch64list", "int_load", "number_test", "int_listed", "int9list", "int64list", "int24lists", "void_listed", "int64lists", "switch_part", " int8list", "number_load", "switch64stack", "int_detail", "switch_list", "int24list", "intPlisted", "int_dict", " int8detail", "number_lists", "intdcount", "intPlist", "intddict", "switch64lists", " int8coll", "int_coll", " int8pair", "switch_stack", "int_count", "void24dict", "int_test", "number24test", " int_detail", "number24list", "int8detail", "int24detail", "int_lists", "void24count", "switch64part", "int8list", "int8pair", "int9stack", "int24coll", "void24list", "void_dict", "int24pair", "intedlist", "int_stack", " int_coll", "switch_lists", "intPcount", "number24load", "intedlists", "int_pair", "int8coll", "void_list", "int24test", "intdlisted", "int24count", "number24lists", "int64stack", "int64part", "intedstack", "int9lists", "int24listed", "int9part", "intPdict"], "output_str": ["Output_strike", "text_arr", "outputMarr", " output_string", "textMarr", "output2list", "textMlist", "output2arr", "text_list", "outputpystr", " output_res", "text_Str", "output_Str", " output_arr", "output_arr", "outputpystrike", "output2Str", "Output_arr", "Output_spr", "outputpyspr", "output_res", "output2str", "outputpyarr", "output_spr", "outputMstr", "Output_str", "text_str", "output_list", "output_string", "textMstr", "output_strike", "outputMlist", "textMStr", "outputMStr"]}}
{"code": " \\n  FILE_NAME_BASE = 'C-small-attempt0'\\n  NUM_PROCESSES = 0\\n  MEM_LIMIT_GB = 1.5 # per worker process\\n  RECURSION_LIMIT = 1000\\n  \\n  def parse(inp):\\n  \trows, cols, mines = (int(x) for x in inp.readline().split())\\n  \treturn rows, cols, mines\\n  \\n  def search(rows, cols, mines):\\n  \\n  \tassert 0 <= mines < rows * cols\\n  \tif mines == 0:\\n  \t\treturn ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)\\n  \tif mines == rows * cols - 1:\\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\\n  \\n  \tif rows == 1:\\n  \t\treturn ['c' + '.' * (cols - 1 - mines) + '*' * mines]\\n  \tif cols == 1:\\n  \t\treturn ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines\\n  \\n  \tif mines > rows * cols - 4:\\n  \t\treturn None\\n  \\n  \\n  \treturn None\\n  \\n  class SearchBoard(object):\\n  \\n  \tdef __init__(self, rows, cols):\\n  \t\tself.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]\\n  \t\tself.mineCount = 0\\n  \\n  \tdef addMine(self, row, col):\\n  \t\tcounts = self.counts\\n  \t\tassert counts[row + 1][col + 1] < 10\\n  \t\ttop = counts[row + 0]\\n  \t\ttop[col + 0] += 1\\n  \t\ttop[col + 1] += 1\\n  \t\ttop[col + 2] += 1\\n  \t\tmid = counts[row + 1]\\n  \t\tmid[col + 0] += 1\\n  \t\tmid[col + 1] += 10\\n  \t\tmid[col + 2] += 1\\n  \t\tbot = counts[row + 2]\\n  \t\tbot[col + 0] += 1\\n  \t\tbot[col + 1] += 1\\n  \t\tbot[col + 2] += 1\\n  \t\tself.mineCount += 1\\n  \\n  \tdef removeMine(self, row, col):\\n  \t\tcounts = self.counts\\n  \t\tassert counts[row + 1][col + 1] >= 10\\n  \t\ttop = counts[row + 0]\\n  \t\ttop[col + 0] -= 1\\n  \t\ttop[col + 1] -= 1\\n  \t\ttop[col + 2] -= 1\\n  \t\tmid = counts[row + 1]\\n  \t\tmid[col + 0] -= 1\\n  \t\tmid[col + 1] -= 10\\n  \t\tmid[col + 2] -= 1\\n  \t\tbot = counts[row + 2]\\n  \t\tbot[col + 0] -= 1\\n  \t\tbot[col + 1] -= 1\\n  \t\tbot[col + 2] -= 1\\n  \t\tself.mineCount -= 1\\n  \\n  \tdef checkConnected(self):\\n  \t\tcounts = self.counts\\n  \t\tcols = len(counts[0]) - 2\\n  \t\trows = len(counts) - 2\\n  \\n  \t\tfor rowIdx, row in enumerate(counts):\\n  \t\t\tif rowIdx == 0 or rowIdx > rows:\\n  \t\t\t\tcontinue\\n  \t\t\ttry:\\n  \t\t\t\tcolIdx = row.index(0, 1, -1)\\n  \t\t\texcept ValueError:\\n  \t\t\t\tpass\\n  \t\t\telse:\\n  \t\t\t\tclick = (rowIdx, colIdx)\\n  \t\t\t\tbreak\\n  \t\telse:\\n  \t\t\treturn None\\n  \\n  \t\trevealed = set()\\n  \t\tdef reveal(row, col):\\n  \t\t\tif 1 <= row <= rows and 1 <= col <= cols:\\n  \t\t\t\tpos = (row, col)\\n  \t\t\t\tif pos not in revealed:\\n  \t\t\t\t\trevealed.add(pos)\\n  \t\t\t\t\tcount = counts[row][col]\\n  \t\t\t\t\tif count == 0:\\n  \t\t\t\t\t\tfor dr in (-1, 0, 1):\\n  \t\t\t\t\t\t\tfor dc in (-1, 0, 1):\\n  \t\t\t\t\t\t\t\tif dr != 0 or dc != 0:\\n  \t\t\t\t\t\t\t\t\treveal(row + dr, col + dc)\\n  \t\t\t\t\telse:\\n  \t\t\t\t\t\tassert count < 10\\n  \t\treveal(*click)\\n  \t\tnumNonMines = rows * cols - self.mineCount\\n  \t\tif len(revealed) != numNonMines:\\n  \t\t\tassert len(revealed) < numNonMines\\n  \t\t\treturn None\\n  \\n  \t\tboard = [\\n  \t\t\t\t['.' if cell < 10 else '*' for cell in row[1 : -1]]\\n  \t\t\t\tfor row in counts[1 : -1]\\n  \t\t\t\t]\\n  \t\tboard[click[0] - 1][click[1] - 1] = 'c'\\n  \t\treturn [''.join(row) for row in board]\\n  \\n  def searchBruteForce(rows, cols, mines):\\n  \tif mines == rows * cols - 1:\\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\\n  \\n  \tsearchBoard = SearchBoard(rows, cols)\\n  \\n  \tdef searchRec(idx, remaining):\\n  \t\tif remaining == 0:\\n  \t\t\treturn searchBoard.checkConnected()\\n  \t\telif idx < remaining:\\n  \t\t\treturn None\\n  \t\telse:\\n  \t\t\tpos = divmod(idx, cols)\\n  \t\t\tsearchBoard.addMine(*pos)\\n  \t\t\tfound = searchRec(idx - 1, remaining - 1)\\n  \t\t\tsearchBoard.removeMine(*pos)\\n  \t\t\tif found is not None:\\n  \t\t\t\treturn found\\n  \t\t\treturn searchRec(idx - 1, remaining)\\n  \\n  \treturn searchRec(rows * cols - 1, mines)\\n  \\n  def solve(rows, cols, mines):\\n  \tboard = search(rows, cols, mines)\\n  \\n  \tif board is None:\\n  \t\tboard = searchBruteForce(rows, cols, mines)\\n  \t\tif board is None:\\n  \t\t\treturn '\\n' + 'Impossible'\\n  \t\tprint 'ERROR: fast search missed solution for %dx%d board, %d mines:' \\\\n  \t\t\t\t% (rows, cols, mines)\\n  \t\tfor row in board:\\n  \t\t\tprint row\\n  \t\tprint\\n  \\n  \tassert len(board) == rows\\n  \tassert all(len(row) == cols for row in board)\\n  \tcounts = { 'c': 0, '.': 0, '*': 0 }\\n  \tfor row in board:\\n  \t\tfor cell in row:\\n  \t\t\tcounts[cell] += 1\\n  \tassert counts['c'] == 1\\n  \tassert counts['*'] == mines\\n  \\n  \tflowBoard = [\\n  \t\t\t['.' if cell == 'c' else cell for cell in row]\\n  \t\t\tfor row in board\\n  \t\t\t]\\n  \tdef countMinesOn(row, col):\\n  \t\tif 0 <= row < rows and 0 <= col < cols:\\n  \t\t\treturn 1 if flowBoard[row][col] == '*' else 0\\n  \t\telse:\\n  \t\t\treturn 0\\n  \tdef countMinesNear(row, col):\\n  \t\treturn sum(\\n  \t\t\tcountMinesOn(row + dr, col + dc)\\n  \t\t\tfor dr in (-1, 0, 1)\\n  \t\t\tfor dc in (-1, 0, 1)\\n  \t\t\t)\\n  \tdef reveal(row, col):\\n  \t\tif 0 <= row < rows and 0 <= col < cols:\\n  \t\t\tassert flowBoard[row][col] != '*'\\n  \t\t\tif flowBoard[row][col] == '.':\\n  \t\t\t\tcount = countMinesNear(row, col)\\n  \t\t\t\tflowBoard[row][col] = str(count)\\n  \t\t\t\tif count == 0:\\n  \t\t\t\t\tfor dr in (-1, 0, 1):\\n  \t\t\t\t\t\tfor dc in (-1, 0, 1):\\n  \t\t\t\t\t\t\treveal(row + dr, col + dc)\\n  \tclickRow, = [i for i, row in enumerate(board) if 'c' in row]\\n  \tclickCol = board[clickRow].index('c')\\n  \treveal(clickRow, clickCol)\\n  \tassert all('.' not in row for row in flowBoard), flowBoard\\n  \\n  \tassert all(type(row) == str for row in board)\\n  \treturn '\\n' + ''.join('\\n' + ''.join(row) for row in board)\\n  \\n  def main():\\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\\n  \\n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\\n  \\n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\\n  \tnumCases = int(inp.readline())\\n  \tif NUM_PROCESSES == 0:\\n  \t\tresults = [\\n  \t\t\tsolve(*parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \telse:\\n  \t\tpool = Pool(NUM_PROCESSES)\\n  \t\tresults = [\\n  \t\t\tpool.apply_async(solve, parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \tinp.close()\\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\\n  \tfor case, result in enumerate(results):\\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\\n  \t\tout.write('Case #%d: %s\\n' % (case + 1, value))\\n  \t\tout.flush()\\n  \tout.close()\\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "substitutes": {"FILE_NAME_BASE": ["FILE_NAME_BASH", "FILE_NAME_BUASE", "FILE_NAME_HASH", "FILE_NAME_LASH", "FILE_NAME_LARS", "FILE_NAME_HASE", "FILE_NAME_BANCE", "FILE_NAME_LASE", "FILE_NAME_LANCE", "FILE_NAME_HARS", "FILE_NAME_BUARS", "FILE_NAME_BUANCE", "FILE_NAME_HANCE", "FILE_NAME_BARS", "FILE_NAME_BUASH"], "NUM_PROCESSES": ["NUM_PRECProcessURES", "NUM_PROCUMORS", "NUM_PROCProcessURES", "NUM_PROCESSORS", "NUM_PRECESSURES", "NUM_PROCNECTES", "NUM_PRECProcessES", "NUM_PROCNECTes", "NUM_PROCProcessORS", "NUM_PROCESSURES", "NUM_PROCUMURES", "NUM_PRECProcessORS", "NUM_PRECESSes", "NUM_PROCUMES", "NUM_PRECESSORS", "NUM_PROCProcesses", "NUM_PROCNECTURES", "NUM_PROCProcessES", "NUM_PRECESSES", "NUM_PRECProcesses", "NUM_PROCUMes", "NUM_PROCESSes", "NUM_PROCNECTORS"], "MEM_LIMIT_GB": ["MEM_LIMITED_G", "MEM_LIMITINGMB", "MEM_LIMIT_SEC", "MEM_LIMITINMB", "MEM_LIMITINSEC", "MEM_LIMITINGB", "MEM_LIMITINGG", "MEM_LIMITED_GB", "MEM_LIMITINGGB", "MEM_LIMITED_SEC", "MEM_LIMIT_MB", "MEM_LIMITINGSEC", "MEM_LIMIT_G", "MEM_LIMITED_MB", "MEM_LIMITING"]}}
{"code": " \\n  FILE_NAME_BASE = 'A-small-attempt0'\\n  NUM_PROCESSES = 0\\n  MEM_LIMIT_GB = 1.5 # per worker process\\n  RECURSION_LIMIT = 1000\\n  \\n  def parseBoard(inp):\\n  \trowSel, = (int(x) for x in inp.readline().split())\\n  \tboard = tuple(\\n  \t\ttuple(int(x) for x in inp.readline().split())\\n  \t\tfor _ in xrange(4)\\n  \t\t)\\n  \treturn board, rowSel - 1\\n  \\n  def parse(inp):\\n  \tbefore, beforeSel = parseBoard(inp)\\n  \tafter, afterSel = parseBoard(inp)\\n  \treturn before, beforeSel, after, afterSel\\n  \\n  def solve(before, beforeSel, after, afterSel):\\n  \tcandidates = set(before[beforeSel]) & set(after[afterSel])\\n  \\n  \tif len(candidates) == 0:\\n  \t\treturn \"Volunteer cheated!\"\\n  \telif len(candidates) == 1:\\n  \t\treturn candidates.pop()\\n  \telse:\\n  \t\treturn \"Bad magician!\"\\n  \\n  def main():\\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\\n  \\n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\\n  \\n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\\n  \tnumCases = int(inp.readline())\\n  \tif NUM_PROCESSES == 0:\\n  \t\tresults = [\\n  \t\t\tsolve(*parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \telse:\\n  \t\tpool = Pool(NUM_PROCESSES)\\n  \t\tresults = [\\n  \t\t\tpool.apply_async(solve, parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \tinp.close()\\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\\n  \tfor case, result in enumerate(results):\\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\\n  \t\tout.write('Case #%d: %s\\n' % (case + 1, value))\\n  \t\tout.flush()\\n  \tout.close()\\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "substitutes": {"FILE_NAME_BASE": ["FILE_NAME_BAS", "FILE_NAME_BEAS", "FILE_NAME_FANCE", "FILE_NAME_FASE", "FILE_NAME_BENAME", "FILE_NAME_BEASE", "FILE_NAME_BNAME", "FILE_NAME_BANCE", "FILE_NAME_bANCE", "FILE_NAME_bASE", "FILE_NAME_FAS", "FILE_NAME_FNAME", "FILE_NAME_BEANCE", "FILE_NAME_bNAME", "FILE_NAME_bAS"], "NUM_PROCESSES": ["NUM_PROCESSED", "NUM_PROCNECTES", "NUM_PROCNECTED", "NUM_PRECProcessES", "NUM_PROCACTED", "NUM_PROCACTES", "NUM_PROCESSS", "NUM_PROCNECTes", "NUM_PROCProcessS", "NUM_PRECProcessS", "NUM_PRECESSED", "NUM_PRECESSes", "NUM_PROCProcessED", "NUM_PROCNECTS", "NUM_PROCProcesses", "NUM_PROCACTes", "NUM_PROCProcessES", "NUM_PRECESSES", "NUM_PRECProcesses", "NUM_PRECESSS", "NUM_PROCESSes", "NUM_PROCACTS", "NUM_PRECProcessED"], "MEM_LIMIT_GB": ["MEM_LIMIT_GW", "MEM_LIMITED_G", "MEM_LIMITINGW", "MEM_LIMITINMB", "MEM_LIMITEDG", "MEM_LIMITINGB", "MEM_LIMITED_GB", "MEM_LIMIT_MB", "MEM_LIMIT_G", "MEM_LIMITEDGW", "MEM_LIMITED_GW", "MEM_LIMITED_MB", "MEM_LIMITING", "MEM_LIMITEDMB", "MEM_LIMITEDGB"]}}
{"code": "T = int(raw_input().strip())\\n  misses = set()\\n  \\n  for i in xrange(T):\\n  \tR, C, M = map(int, raw_input().strip().split(' '))\\n  \tF = R * C - M\\n  \timpossible = False\\n  \tif F == 1:\\n  \t\tmatrix = [\"c\" + \"*\" * (C - 1)]\\n  \t\tfor _ in xrange(R - 1):\\n  \t\t\tmatrix.append(\"*\" * C)\\n  \telif R == 1:\\n  \t\tmatrix = [\"c\" + \".\" * (F - 1) + \"*\" * (C - F)]\\n  \telif C == 1:\\n  \t\tmatrix = [\"c\"]\\n  \t\tfor _ in xrange(F - 1):\\n  \t\t\tmatrix.append(\".\")\\n  \t\tfor _ in xrange(R - F):\\n  \t\t\tmatrix.append(\"*\")\\n  \telif R == 2:\\n  \t\tif F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):\\n  \t\t\tmatrix = [\\n  \t\t\t\t\"c\" + \".\" * (F / 2 - 1) + \"*\" * (C - F / 2),\t\\n  \t\t\t\t\".\" * (F / 2) + \"*\" * (C - F / 2)\\n  \t\t\t]\\n  \t\telse:\\n  \t\t\tmatrix = []\\n  \t\t\timpossible = True\\n  \telse:\\n  \t\tstack = []\\n  \t\tmatrix = []\\n  \t\tfor j in xrange(C, 1, -1):\\n  \t\t\tif F - 2 * j >= 0 and (R - 2) * j >= F - 2 * j:\\n  \t\t\t\tstack.append([j, j])\\n  \\n  \t\twhile stack:\\n  \t\t\telems = stack.pop()\\n  \t\t\tse = sum(elems)\\n  \t\t\tif se == F:\\n  \t\t\t\tfor count in elems:\\n  \t\t\t\t\tmatrix.append(\".\" * count + \"*\" * (C - count))\\n  \t\t\t\tfor _ in xrange(R - len(elems)):\\n  \t\t\t\t\tmatrix.append(\"*\" * C)\\n  \t\t\t\tmatrix[0] = \"c\" + matrix[0][1:]\\n  \t\t\t\tbreak\\n  \t\t\telif len(elems) < R:\\n  \t\t\t\tfor j in xrange(elems[-1], 1, -1):\\n  \t\t\t\t\tif F - se - j >= 0 and (R - len(elems)) * j >= F - se:\\n  \t\t\t\t\t\tstack.append(elems[::] + [j])\\n  \\n  \t\tif matrix == []:\\n  \t\t\timpossible =True\\n  \\n  \tprint \"Case #%s:\" % (i + 1)\\n  \tif impossible:\\n  \t\tprint \"Impossible\"\\n  \telse:\\n  \t\tfor row in matrix:\\n  \t\t\tprint row\\n", "substitutes": {"T": ["Z", "TT", "P", "O", "TC", "S", "B", "TA", "L", "TB", "X", "I", "TS", "t", "E", "Total", "TN", "D", "U", "Y", "V", "H", "Q", "W", "N", "TF", "Time", "NT"], "misses": ["liced", "manits", "maned", "processages", "processits", "processes", "manages", "licages", "licits", "missages", "manes", "missits", "lices", "processed", "missed"], "i": ["p", "iq", "all", "id", "cor", "col", "d", "J", "ind", " I", "h", "I", "gi", "ii", "c", "ti", "D", "z", "r", "g", "im", "ip", "N", "n", "int"], "R": ["P", "O", "A", "CR", "S", "JR", "B", "MR", "RA", "J", "L", "RR", "X", "K", "BR", "I", "RW", "Rs", "E", "NR", "RH", "Right", "RO", "D", "G", "r", "Rh", "U", "Y", "RS", "V", "H", "RT", "RG", "Q", "W", "N", "SR", "RF", "RC", "RM", "Re", "n", "Range"], "C": ["CC", "P", "O", "A", "CF", "Cr", "CR", "S", "B", "COR", "CI", "YC", "Cs", "DC", "L", "CL", "CM", "AC", "X", "I", "K", "c", "Ch", "J", "CU", "E", "CT", "CO", "CNN", "D", "G", "EC", "MC", "r", "U", "Count", "Y", "CA", "Cl", "V", "Co", "H", "Cu", "Size", "CE", "Cor", "Q", "W", "N", "CV"], "M": ["Z", "P", "O", "A", "CR", "MF", "S", "MN", "B", "m", "L", "CM", "X", "I", "DM", "E", "MM", "D", "G", "MS", "MC", "U", "Y", "V", "H", "Q", "W", "N", "RM", "FM"], "F": ["File", "Z", "P", "FE", "O", "CF", "A", "FO", "DF", "Fa", "S", "B", "FC", "FF", "SF", "FH", "Fs", "Fl", "Full", "J", "L", "BF", "FB", "FG", "X", "f", "I", "K", "GF", "Far", "Inf", "E", "All", "IO", "PF", "G", "D", "OF", "FL", "AF", "Fine", "IF", "U", "Y", "Fi", "V", "H", "Fixed", "Family", "FR", "Q", "W", "N", "RF", "FS", "EF", "FM", "FD"], "impossible": ["greatossibly", "compossibly", " impective", "compossibility", "impossibly", "greaturity", "Impective", " impossibility", "Impossibility", "ispossibility", "ispure", "Impossible", "greatossibility", "compurity", "ispossible", "ispective", "impurity", "greatossible", "compossible", "ispurity", "impossibility", " impure", "ispossibly", "impective", "Impure", "impure"], "matrix": ["mrices", "Matrices", " matribution", "mmrice", "mathral", "rubrix", "matx", " matrices", "matride", "atrices", "metogram", "metment", "Matment", " matract", "rubvector", "Matogram", "attric", "atri", " matx", "matric", " matensor", " matrics", "matMatrix", "MATrices", "atrix", "trices", "mfix", "latric", " matric", "mortrix", "atuster", "tvector", " matride", "matrics", "tric", "macrices", " matogram", "latfix", "attrix", "matrow", "molrix", "matensor", " matment", "matri", "rubplex", " matri", "MATx", "rubrices", "matrice", "matogram", "latrices", "scherices", "metrow", "attrices", "matfix", "attral", " matress", "scherix", "mmrices", "matrices", "latplex", "metrics", "atric", "atract", "latvector", "latx", "molrices", "Matride", "macress", "macrix", "trix", "matuster", "latMatrix", "mathuri", "latrix", "scheuster", " matfix", "matux", " matral", "mortric", "scheri", "metric", "tplex", "MATfix", " matMatrix", "latrice", "metract", "atMatrix", "metrices", "molric", "mortux", "Matrix", " matrow", "Matric", "matribution", "atrics", "tensor", "matress", "mathribution", "mmric", "Matfix", "matvector", "mmrix", "matract", " matplex", "matral", "mathric", " matuster", "mathux", "mride", "atrow", " maturi", "attrice", "attribution", "matplex", "mathensor", "macric", "morturi", "maturi", " matux", "molress", "mathrix", "atplex", "mathrices", "mrix", "metrix", "MATrix", "matment"], "_": ["p", "o", "up", "A", "all", "val", "___", " un", "of", "place", "q", "x", "lex", "out", "d", "l", "al", "__", "k", "U", "a", "non", "g", "s", "ing", "ip", "u", "n", "ac"], "stack": ["parse", "switch", "wrap", "array", "new", "scroll", "stage", "force", "la", "list", "pack", "reverse", "lc", "st", "index", "layer", "document", "sc", "view", "shell", "loop", "file", "function", "scope", "stream", "console", "ind", "l", "tree", "trace", "fr", "shift", "data", "str", "ack", "scale", "chain", "batch", "back", "cache", "pop", "Stack", "white", "self", "set", "roll", "z", "sequence", "history", "check", "cycle", "cube", "queue", "work", "cl", "left", "context", "first", "v", "diff", "string", "sl", "pull", "int", "slice", "push", "zip"], "j": ["p", "o", "br", "li", "py", "ch", "sp", "js", "jc", "index", "seq", "q", "jp", "m", "ji", "d", "J", "x", "h", "ind", "l", "y", "f", "adj", "c", "ii", "fr", "e", "t", "jl", "aj", "sh", "fl", "ie", "num", "el", "k", "z", "note", "jj", "r", "ja", "je", "ij", "g", "dj", "b", "v", "jo", "pos", "jet", "pr", "n", "si", "int", "uj"], "elems": ["elns", " elemes", "lemks", "olemes", "elm", "elec", " elem", "olements", "lemns", "lemmes", "Elec", " elec", "lemm", "Elem", "lemes", "eleks", "elments", "elem", "lemlems", "elements", "Elens", "Elems", "elks", "Elemes", "oleks", " elens", " elelems", "elemes", "elmes", "elms", "lems", "olems", " eleks", "Eleks", "ellems", "elelems", "lem", "lements", "lemments", "elens", "elc", "olem", "lemms"], "se": ["sem", "me", "parse", "be", "arse", "sq", "pse", "ci", "sp", "ch", "sy", "sd", "pe", "ss", "SE", "est", "sea", "su", "ae", "sa", "fr", "e", "ses", "sh", "ie", "ce", "ze", "see", "sec", " SE", "ose", "ee", "nt", "fe", "size", "ve", "sed", "length", "nd", "sum", "Se", "th", "sle", "de", "use", "ase", "le", "sl", "si", "ne", "sel", "ge", "ser", "ke", " Se"], "count": ["p", "ph", "depth", "child", "start", "li", "id", "ch", "list", "cc", "col", "cf", "index", "len", "seq", "weight", "q", "base", "ind", "max", "l", "f", "core", "c", "e", "code", "key", "cache", "num", "ge", "z", "see", "nt", "cat", "cycle", "size", "Count", "length", "last", "sum", "th", "number", "loc", "n", "ct", "mass", "cur", "coll"]}}
{"code": "T = int(raw_input().strip())\\n  \\n  for j in xrange(T):\\n  \trow_num1 = int(raw_input().strip())\\n  \tfor i in xrange(4):\\n  \t\tif i + 1 == row_num1:\\n  \t\t\trow1 = set(map(int, raw_input().strip().split(' ')))\\n  \t\telse:\\n  \t\t\traw_input()\\n  \trow_num2 = int(raw_input().strip())\\n  \tfor i in xrange(4):\\n  \t\tif i + 1 == row_num2:\\n  \t\t\trow2 = set(map(int, raw_input().strip().split(' ')))\\n  \t\telse:\\n  \t\t\traw_input()\\n  \tcommon = row1 & row2\\n  \tlc = len(common)\\n  \tif lc == 1:\\n  \t\tstuff = list(common)[0]\\n  \telif lc > 1:\\n  \t\tstuff = \"Bad magician!\"\\n  \telse:\\n  \t\tstuff = \"Volunteer cheated!\"\\n  \\n  \tprint \"Case #%s: %s\" % (j + 1, stuff)\\n", "substitutes": {"T": ["Z", "HI", "TT", "P", "O", "R", "TC", "S", "TW", "B", "TA", "L", "TB", "TM", "F", "X", "I", "t", "E", "TN", "num", "M", "Y", "C", "V", "H", "W", "N", "TI", "Time", "NT"], "j": ["p", "o", "jump", "li", "ch", "jit", "jc", "q", "jp", "ji", "time", "m", "d", "ai", "J", "kj", "bj", "y", "f", "I", "l", "ii", "c", "adj", "e", "t", "jl", "ie", "xi", "obj", "k", "z", "note", "jj", "ij", "im", "ib", "g", "b", "jo", "ip", "u", "n", "uj"], "row_num1": ["row_no3", "row_sum0", "row1dim0", "row1dim2", "row1num2", "row_dim3", "row_NumOne", "row_sumOne", "row1num0", "row1num1", "row_no1", "row_sum3", "row_sum2", "row1num3", "row_dimOne", "row1dim3", "row_Num3", "row_no2", "row_dim0", "row_Num1", "row_Num2", "row_numOne", "row_num3", "row_dim1", "row_no0", "row_sum1", "row1dim1", "row_dim2", "row_num0"], "i": ["p", "it", "ui", "li", "isi", "id", "ci", "ei", "oi", "ori", "ini", "phi", "ai", "d", "x", "ind", "l", "y", "f", "I", "ii", "c", "ti", "e", "t", "yi", "zi", "ie", "pi", "xi", "di", "k", "z", "ni", "im", "ib", "hi", "b", "v", "ip", "u", "qi", "n", "si", "io", "int", "iu"], "row1": ["rowOne", "row3", "col3", "col2", "blockOne", "rows3", "block1", " rowOne", "block2", "rowsOne", "col1", "rows1", "rows2", " row3", "block3"], "row_num2": ["row_no3", "row2no4", "row_sum0", "row2num2", "row_dim3", "row2num3", "row2noII", "row2no3", "row2numII", "row_norm2", "row_Num4", "row_sum2", "row_num4", "row_Num3", "row_no2", "row_dimII", "row2no2", "row_Num0", "row_norm52", "row_Num1", "row_NumII", "row_norm0", "row2num4", "row_noII", "row_Num52", "row_Num2", "row_dim4", "row_sum52", "row_num3", "row_no4", "row_numII", "row_norm1", "row_sum1", "row_dim2", "row_num0", "row_num52"], "row2": ["colx", "col2", "rowx", " rowx", "feed6", " rowtwo", "feed4", "col_", "cell2", "col1", "rows1", "row4", "rows2", "cell6", " row_", "rowsx", "row_", "row6", " row6", "celltwo", "rows_", "cell4", " row4", "feedtwo", "feed2", "rowtwo"], "common": ["conference", "extra", "all", "Common", "misc", "basic", "same", "name", "null", "multi", "special", "base", "flat", "central", "company", "custom", "similar", "seen", "data", "specific", "compatible", "other", "simple", "complex", "none", "known", "shared", "media", "con", "non", "public", "unique", "standard", "low", "union", "server", "diff", "general", "normal", "generic", "local"], "lc": ["uci", "lf", "li", "la", "ls", "lic", "ci", "list", "nc", "len", "rc", "lb", "sc", "ly", "cli", "oi", "LT", "ll", "LR", "l", "icc", "c", "lvl", "lam", "lv", "lib", "ln", "fc", "tc", "usc", "sec", "nt", "kl", "dl", "cl", "lp", "lu", "sync", "lict", "loc", "LC", "wl", "lr", "n", "cs", "lt", "coll", "pc"], "stuff": ["luck", "say", "start", "comment", "case", "feat", "rank", "place", "kind", "what", "cause", "name", "space", "food", "nothing", "wow", "thing", "ticket", "company", "know", "pretty", "question", " Stuff", "like", "just", "mmm", "front", "ie", "www", "info", "obj", "shit", "maybe", "notice", "part", "type", "tmp", "hack", "kick", "something", "eddy", "standard", "field", "concept", "sorry", "yeah", "strip", " shit", "kk", "things", "string", "sex", "bug", "cheat", "style", "test", "fortune", "now"]}}
{"code": " \\n  \\n  f = open(sys.argv[1],'r')\\n  \\n  num = int(f.readline())\\n  \\n  def count(z, r, c):\\n      return len(z_and_nei(z,r,c))\\n  \\n  def nei(z, r, c):\\n      s = z_and_nei(z, r, c)\\n      s -= set(z)\\n      return s\\n  \\n  def z_and_nei(z, r, c):\\n      s = set()\\n      for x in z:\\n          s.add(x)\\n          s.add((x[0]-1,x[1]-1))\\n          s.add((x[0]-1,x[1]))\\n          s.add((x[0]-1,x[1]+1))\\n          s.add((x[0],x[1]-1))\\n          s.add((x[0],x[1]+1))\\n          s.add((x[0]+1,x[1]-1))\\n          s.add((x[0]+1,x[1]))\\n          s.add((x[0]+1,x[1]+1))\\n      o = set()\\n      for x in s:\\n          if x[0] < 0 or x[0] > r-1 or x[1] < 0 or x[1] > c-1:\\n              o.add(x)\\n      s-=o\\n      return s\\n  \\n  def find_config(z, r, c, t):\\n      if count(z,r,c) == t:\\n          return z\\n      if count(z,r,c) > t:\\n          return []\\n      n = nei(z,r,c)\\n      for x in n:\\n          z.append(x)\\n          if find_config(z,r,c,t) != []:\\n              return z\\n          z.pop()\\n      return []\\n  \\n  for i in range(num):\\n      print 'Case #{}:'.format(i+1)\\n      r, c, m = [int(x) for x in f.readline().split()]\\n      if r*c-m == 1:\\n          print 'c' + '*'*(c-1)\\n          for i in range(r-1):\\n              print '*'*c\\n      else:\\n          z = find_config([(0,0)], c, r, c*r-m)\\n          if z == []:\\n              print \"Impossible\"\\n          else:\\n              s = z_and_nei(z, c, r)\\n              for j in range(r):\\n                  for k in range(c):\\n                      if j == 0 and k == 0:\\n                          print 'c',\\n                      elif (k,j) in s:\\n                          print '.',\\n                      else:\\n                          print '*',\\n                  print\\n  \\n  \\n", "substitutes": {"f": ["ref", "p", "fp", "fast", "ch", "file", "stream", "d", "fx", "h", "l", "F", "fo", "y", "fr", "fd", "e", "fb", "form", "fc", "info", "proc", "tf", "handler", "conf", "arf", "fs", "w", "g", "b", "v", "ft", "feed", "io", "df", "af"], "num": ["iter", "p", "cu", "nu", "sn", "col", "nc", "na", "len", "name", "nb", "norm", "np", "multi", "h", "en", "fn", "max", "count", "bin", "Num", "temp", "no", "inc", "um", "ctr", "con", "size", "uni", "cm", "w", "g", "sum", "b", "number", "u", "om", "loc", "NUM", "total"], "z": ["zer", "Z", "p", "all", "az", "zone", "za", "zo", "config", "ld", "q", "zen", "d", "h", "y", "l", "count", "tz", "zz", "e", "zh", "gz", "code", "zi", "like", "fl", "ce", "ze", " Z", "wa", "nz", "a", "w", "g", "zl", "cl", "b", "v", "zy", "u", "zn", "bug", "ed", "iz", "er", "cz", "ez", "one", "zip"], "r": ["err", "p", "rb", "R", "br", "dr", "tr", "range", "rc", "q", "ar", "d", "rf", "h", "l", "y", "ru", "cr", "fr", "nr", "e", "ir", "rec", "ur", "rr", "nor", "rh", "rn", "a", "w", "g", "C", "re", "b", "sr", "v", "hr", "u", "pr", "lr", "rs", "er", "yr"], "c": ["p", "cu", "ci", "ch", "cc", "cf", "lc", "dc", "nc", "cn", "rc", "sc", "q", "d", "h", "l", "y", "count", "cr", "uc", "e", "ce", "cin", "cell", "con", "cm", "a", "w", "cl", "g", "C", "b", "v", "u", "ca", "cs", "ct", "pc", "ac", "cy"], "s": ["ws", "js", "so", "ves", "ts", "ips", "h", "y", "ends", "us", "os", "options", "services", "ks", "w", "sg", "v", "u", "ed", "sv", "er", "cs", "ss", "sb", "states", "users", "sa", "multi", "es", "ies", "sets", "ssl", "set", "groups", "ing", "sym", "rs", "p", "ls", "lines", "S", "qs", "su", "d", "strings", "e", "ses", "gs", "events", "status", "posts", "size", "xs", "fs", "a", "sync", "ys", "uns", "ments", "si", "an", "sn", "vs", "sc", "ns", "opens", "l", "ans", "times", "sh", "ions", "sites", "rows", "ps", "g", "its", "sum", "b", "sys", "south", "sl", "ds", "site"], "x": ["ph", "_", "zx", "case", "ix", "ax", "sw", "index", "event", "any", "time", "h", "ex", "y", "code", "xi", "self", "ic", "wa", "w", "xy", "v", "u", "on", "sex", "xml", "xb", "cross", "id", "pe", "xxx", "view", "python", "fx", "ux", "alpha", "opt", "data", "xc", "rx", "xp", "int", "ct", "exp", "p", "ci", "config", "na", "d", "X", "wx", "e", "xes", "px", "check", "rex", "xs", "a", "work", "cl", "loc", "xx", "one", "dx", "ww", "xf", "q", "ext", "lex", "xt", "l", "hex", "go", " X", "co", "g", "b", "tx"], "o": ["off", "O", "p", "op", "so", "ot", "ro", "d", "yo", "h", "out", "l", "y", "oo", "ob", "e", "bo", "other", "no", "do", "os", "oe", "w", "g", "b", "v", "oa", "u", "on", "io", "ou"], "t": ["p", "it", " T", "tr", "at", "tp", "q", "ts", "T", "time", "ot", "d", "dt", "h", "out", "l", "y", "tz", "e", "tt", "ta", "tf", "nt", "type", "a", "g", "b", "v", "pt", "u", "tm", "int", "total", "tc"], "n": ["p", "all", "sn", "nc", "q", "ns", "nb", "ot", "nn", "d", "en", "l", "y", "e", "nt", "ni", "con", "a", "w", "g", "b", "v", "N", "ne", "cs", "net", "ct"], "i": ["p", "iq", "ui", "li", "id", "ci", "ix", "index", "q", "ini", "phi", "ai", "multi", "ind", "y", "h", "gi", "I", "l", "ri", "ii", "ti", "e", "eni", "ie", "uri", "pi", "xi", "di", "im", "b", "v", "u", "ip", "qi", "io", "si", "ih", "int", "iu", "slice"], "m": ["p", "range", "mm", "q", "d", "h", "y", "l", "e", "mini", "um", "M", "cm", "a", "w", "g", "C", "mi", "b", "v", "u", "ms", "mc"]}}
{"code": " \\n  \\n  f = open(sys.argv[1],'r')\\n  \\n  num = int(f.readline())\\n  \\n  for i in range(num):\\n      q1 = int(f.readline())\\n      for j in range(4):\\n          if j+1 == q1:\\n              line1 = f.readline()\\n          else:\\n              f.readline()\\n      q2 = int(f.readline())\\n      for j in range(4):\\n          if j+1 == q2:\\n              line2 = f.readline()\\n          else:\\n              f.readline()\\n      line1 = [int(x) for x in line1.split()]\\n      line2 = [int(x) for x in line2.split()]\\n      count = 0\\n      for x in line1:\\n          if x in line2:\\n              count += 1\\n              y = x\\n      if count == 0:\\n          print 'Case #{}: Volunteer cheated!'.format(i+1)\\n      elif count == 1:\\n          print 'Case #{}: {}'.format(i+1, y)\\n      else:\\n          print 'Case #{}: Bad magician!'.format(i+1)\\n", "substitutes": {"f": ["p", "o", "fp", "lf", "fu", "fast", "full", "of", "fm", "file", "m", "function", "d", "fx", "rf", "h", "F", "l", "fo", "fn", "c", "fr", "fd", "fa", "e", "fb", "t", "form", "api", "fw", "fc", "tf", "z", "handler", "r", "conf", "bf", "fs", "w", "g", "s", "b", "v", "sf", "feed", "io", "inf", "df", "ff", "af"], "num": ["split", "nu", "unit", "div", "id", "col", "lim", "index", "init", "name", "m", "nb", "np", "multi", "coord", "en", "max", "ul", "c", "end", "Num", "no", "inc", "um", "con", "size", "uni", "sum", "b", "min", "number", "dim", "loc", "NUM", "n", "cal"], "i": ["p", "iq", "ui", "isi", "li", "id", "ci", "ix", "index", "m", "ai", "bi", "ind", "l", "I", "gi", "ii", "c", "e", "zi", "key", "ie", "mini", "uri", "pi", "info", "sup", "k", "z", "r", "type", "a", "im", "b", "v", "u", "ip", "qi", "n", "io", "si", "int", "iu", "slice"], "q1": ["q13", " qone", "p1", "query1", "pone", "q11", "query13", "v11", " q13", "v1", "qN", "v13", "Qone", "qone", "p2", " q11", "query11", "QN", "query2", "Q2", " qN", "v2", "Q1", "pN"], "j": ["p", "_", "o", "ax", "jc", " n", "q", "jp", "m", "ji", "d", "J", "bj", "h", "l", "c", "e", "jl", "aj", "job", "k", "z", "jj", "r", "ja", "je", "ij", "dj", "g", "b", "v", "jo", "jam", "on", "n", "uj"], "line1": [" lineone", " line0", "lineOne", "style1", "caseone", "Line4", "lin1", "linOne", "Line3", "Line1", "line4", "linone", "lineone", "l2", "line3", "block1", "styleHead", "lineHead", "LineHead", "caseOne", "block2", "qone", "line0", "lin2", "styleone", "LineOne", "case1", " lineOne", "l1", "l4", "block0", "lin0", "lin3", "Line2", "Lineone", "qOne", "caseHead", "l3", "styleOne", "lin4", "blockone"], "q2": ["qu2", "q82", "q12", " q12", "qtwo", " qtwo", " q20", "quest20", "questtwo", "question02", "f2", "question2", "qu82", " q82", "question82", "quest2", "question12", "qu02", "ftwo", "qII", "qu12", "questII", "fII", "f20", "q02", "q20", " q02", " qII"], "line2": [" line0", "lines1", "Linetwo", " linesecond", " linetwo", "lin1", "lane1", "lintwo", "Line1", "line4", " line4", "l2", "ine02", "linestwo", "ine2", "pagetwo", "line02", " line02", "linsecond", "line0", "lin2", "linetwo", "page1", "linesecond", "lin02", "lanetwo", "lines0", "l1", "lines2", "l4", "lane4", "lin0", "inesecond", "lane2", "Line2", "page0", "lin4", "ltwo", "page2", "Line0", "ine4"], "x": ["p", "ph", "_", "id", "ci", "ix", "ax", "yx", "index", "xf", "event", "q", "width", "m", "name", "time", "d", "lex", "point", "h", "ex", "X", "xt", "ux", "l", "c", "e", "t", "code", "xes", "oint", "px", "xi", "k", "z", "check", "xs", "xc", "Y", "rx", "w", "work", "im", "xy", "s", "v", "b", "plus", "number", "u", "on", "loc", "content", "xx", "sex", "n", "int", "mass", "cross"], "count": ["p", "depth", "offset", "child", "start", "id", "label", "list", "cc", "col", "index", "len", "catch", "weight", "q", "nb", "time", "span", "base", "ind", "l", "counter", "found", "c", "code", "no", "key", "z", "note", "part", "type", "check", "match", "nt", "size", "Count", "length", "sum", "line", "number", "call", "n", "test", "total", "coll"], "y": ["p", "py", "ch", "fy", "sy", "col", "q", "ay", "ya", "dy", "yo", "l", "vy", "c", "yi", "year", "z", "type", "Y", "yl", "xy", "b", "xx", "oy", "n", "yy", " Y", "cy"]}}
{"code": " \\n  def check_bounds(state, coord):\\n      if coord[0] < 0 or coord[1] < 0:\\n          return False\\n      elif coord[0] > (len(state) - 1):\\n          return False\\n      elif coord[1] > (len(state[coord[0]]) - 1):\\n          return False\\n      else:\\n          return True\\n  \\n  def clear(state, coord):\\n      for r in range(-1,2):\\n          for c in range(-1,2):\\n              row = coord[0] + r\\n              col = coord[1] + c\\n              if check_bounds(state, (row, col)):\\n                  state[row][col] = 0\\n  \\n  def count(state):\\n      return sum([sum(x) for x in state])\\n  \\n  def state_print(state):\\n      print(\"c\" + \"\".join([\"*\"  if x else \".\" for x in state[0][1:]]))\\n      for line in state[1:]:\\n          print(\"\".join([\"*\"  if x else \".\" for x in line]))\\n  \\n  def solve(state, mines):\\n      prev_state = deepcopy(state)\\n      for row in range(len(state)):\\n          for col in range(len(state[row])):\\n              new_state = deepcopy(state)\\n              clear(new_state, (row, col))\\n              c = count(new_state)\\n              if(c < mines):\\n                  state = prev_state\\n              elif( c == mines):\\n                  state_print(new_state)\\n                  return True\\n              else:\\n                  if col == len(state[row]) -2:\\n                      prev_state = deepcopy(state)\\n                  state = new_state\\n      print(\"Impossible\")\\n      return False\\n  \\n  \\n  \\n  \\n  def main():\\n      filename = \"C-small-attempt0.in\"\\n  \\n  \\n      inp = open(filename, \"rU\")\\n  \\n      n = int(inp.readline().strip())\\n  \\n      for case in range(1, n + 1):\\n          R, C, M = map(int, inp.readline().strip().split(\" \"))\\n          state = [[1 for x in range(C)] for y in range(R)]\\n          print(\"Case #{}:\".format(case))\\n          solve(state, M)\\n  \\n  main()\\n", "substitutes": {"state": ["session", "node", "unit", "force", "all", "list", "region", "range", "ode", "machine", "name", "order", "time", "un", "grade", "parent", "power", "position", "area", "code", "scale", "seed", "key", "frame", "shape", "self", "output", "part", "match", "public", "length", "bug", "style", "test", "local", "slice", "old", "cal", "statement", "address", "pe", "states", "m", "oper", "space", "body", "core", "data", "ace", "back", "form", "down", "can", "object", "STATE", "instance", "State", "resource", "layer", "p", "start", "config", "st", "pair", "file", "function", "step", "f", "port", "count", "message", "update", "al", "history", "cell", "size", "work", "j", "sync", "use", "loc", "error", "private", "section", "now", "date", "stat", "zip", "parse", "new", "run", "scope", "point", "l", "connection", "rule", "cache", "type", "value", "model", "store", "string", "block", "patch", "source"], "coord": [" coordinate", "word", "dom", "node", "comp", "address", "dc", "cand", "config", "index", "pair", "range", "layer", "com", "du", "order", "channel", "loop", "span", "point", "record", "connection", "position", "area", "data", "code", "ord", " coordinates", "batch", "form", "num", "location", "rect", "shape", "component", "cell", "route", "color", "cat", "con", "cube", "co", "xy", "pos", "dim", "gap", "ctrl", "char", "ctx", "loc", "call", "direction", "number", "xxxx", "patch", "error", "pixel", "lat", "date", "coll", "cal"], "r": ["p", "br", "range", "rc", "q", "ar", "m", "ro", "d", "h", "l", "f", "cr", "rd", "nr", "e", "ir", "end", "i", "rr", "k", "rh", "z", "rg", "rn", "w", "g", "re", "b", "v", "s", "rs"], "c": ["p", "cu", "ci", "ch", "cc", "unc", "cf", "lc", "dc", "nc", "rc", "center", "sc", "m", "d", "h", "l", "f", "cr", "count", "uc", "e", "chain", "i", "ce", "ec", "k", "z", "con", "cycle", "cm", "a", "w", "co", "j", "g", "toc", "s", "b", "v", "bc", "min", "u", "mc", "ca", "cs", "ct", "coll", "pc", "ac", "cy"], "row": ["node", "tr", "user", "range", "index", "entry", "order", "head", "h", "area", "uc", "scale", "key", "frame", "con", "w", "length", "Row", "xy", "min", "rid", "page", "bug", "offset", "view", "ro", "lock", "right", "ack", "i", "arrow", "column", "flow", "pos", "p", "ow", "month", "dy", "record", "f", "port", "none", "num", "post", "cell", "low", "loc", "coll", "one", "rown", "group", "rank", "rc", "sc", "ri", "ry", "batch", "rows", "k", "co", "field", "hop", "server", "block", "feed", "oy", "cur"], "col": ["p", "o", "offset", "Col", "word", "val", "ci", "ch", "cor", " Col", "cf", "path", "index", "seq", "rc", "ail", "ind", "l", "f", "cp", "count", "foot", "h", "cr", "keep", "ady", "key", "fl", "num", "win", "el", "i", "fc", "year", "rot", "rel", "k", "cell", "sec", "cat", "con", "column", "co", "w", "yl", "cl", "j", "COL", "ol", "min", "pos", "loc", "act", "oy", "int", "ct", "cur", "coll", "cy"], "x": ["p", "_", "dx", "array", "id", "long", "ix", "ax", "pe", "xxx", "yx", "index", "xf", "q", "d", "lex", "point", "h", "ex", "X", "f", "ux", "xt", "xa", "wx", "inx", "l", "e", "t", "code", "xes", "i", "px", "oint", "xi", "xe", "z", "check", "rex", "ic", "expl", "xs", "xc", " X", "rx", "w", "g", "co", "work", "xy", "v", "xp", "ctx", "u", "on", "xx", "sex", "xb", "test", "int", "exp", "cross"], "line": ["o", "li", "val", "lines", "lin", "pe", "range", "len", "log", "run", "name", "Line", "time", "un", "point", "max", "l", "day", "str", "end", "code", "ln", "frame", "cell", "lined", "inline", "cycle", "con", "column", "co", "length", "pos", "number", "string", "block", "ne", "slice"], "mines": ["minxes", "Minxes", "generics", "generES", "generes", "Minions", "minics", "Minus", "raines", "coles", "Minics", "MINations", "minus", "minations", " minus", "colions", "minions", "MinES", " minores", "colores", "rainics", " minions", "Mines", "rainES", "Minations", "Minores", "MINes", "MINores", "minores", "rainions", " minations", "colxes", "generions", " minxes", "minES", "MINus"], "prev_state": ["vious_resource", "prev_line", " prev_name", " prev_states", " prev_position", "vious_line", "prev_resource", "prev_position", "prev_states", "vious_key", "vious_state", "prev_stat", "prev_key", " prev_start", " prev_stat", "prev_name", "prev_start", " prev_resource"], "new_state": ["new67state", "newParresource", "newamstate", "new67private", "cleanJobject", "new67style", "newJstates", "new_row", "cleanJstates", "newamcomponent", "prev_style", "new_scope", "new_style", "next_call", "cleanJspace", "clean_object", "newJobject", "cleanJstate", "new_component", "prev_component", "new_resource", "newParstate", "prev_private", "newamscope", "new_space", "prev_rule", "newJspace", "clean_state", "clean_space", "new67rule", "newParorder", "newamstyle", "prev_resource", "new_object", "new67row", "next_row", "new_order", "new_slice", "new_rule", "prev_order", "next_slice", "new67slice", "prev_scope", "next_state", "clean_states", "newJstate", "new_states", "new_private", "new_call", "new67call"], "filename": ["File", "il", "aml", "fp", "subject", "files", "ls", "open", "ppa", "path", "document", "file", "phrase", "approximately", "profile", "fn", "dll", "connection", "fd", "amer", "directory", "jl", "mph", "jpg", "utf", "download", "iled", "nil", "figure", "FILE", "ema", "kl", "Filename", "itled", "username", "SourceFile", "sheet", "title", "jet", "sf", "ename", "appy", "database", "fil", "which", "binary"], "inp": ["insh", "kinpt", "inpo", "Inp", "INc", "incpt", "kinf", "Inl", " inc", "INproc", "incps", "Inps", " inl", "inh", "Inh", "Inf", "insc", "kinps", "innproc", "incp", " inh", "INpo", "insl", "inc", "insp", "inpt", "kinp", " inpo", "innc", "inproc", "INp", "innpo", "inl", "innp", "Inc", " inproc", "inf", "inps", "Inpt", "incf"], "n": ["p", "o", "nu", "sn", "nc", "len", "cn", "ns", "nb", "m", "span", "un", "en", "l", "count", "t", "num", "i", "k", "nt", "network", "con", "size", "ni", "j", "s", "b", "number", "N", "ne"], "case": ["p", "me", "SC", "id", "config", "catch", "name", "ice", "time", "count", "cp", "position", "uc", "ace", "e", "nce", "code", "key", "mode", "trial", "ce", "match", "size", "a", "bc", "length", "Case", "mi", "instance", "number", "use", "ase", "call", "loc", "block", "section", "test", "patch", "cases", "change"], "R": ["p", "P", "A", "CR", "S", "B", "MR", "T", "L", "RR", "F", "X", "RN", "K", "I", "Rs", "E", "RH", "DR", "RO", "D", "G", "Rh", "U", "Y", "RS", "V", "H", "State", "Q", "W", "N", "RM"], "C": ["CC", "P", "O", "A", "Col", "CR", "S", "B", "COR", "CI", "T", "DC", "L", "CL", "X", "F", "I", "K", "CV", "CU", "E", "D", "G", "U", "Y", "V", "Co", "H", "Cu", "Q", "W", "N", "CE"], "M": ["P", "O", "LM", "MF", "S", "MN", "B", "MO", "T", "m", "J", "L", "CM", "F", "X", "I", "DM", "E", " m", "MM", "G", "D", "MS", "MC", "MD", "U", "Y", "V", "H", "MT", "Q", "W", "N", "RM"], "y": [" yr", "ch", "month", "q", "ye", "ay", "d", "ya", "dy", "h", "day", "ry", "ym", "ady", "year", "yd", "z", "cycle", "gy", "Y", "yl", "j", "xy", "my", "oy", "yy", "yr", "cy"]}}
{"code": " \\n  filename = \"A-small-attempt0.in\"\\n  \\n  inp = open(filename, \"rU\")\\n  \\n  n = int(inp.readline().strip())\\n  \\n  for case in range(1, n+1):\\n      gr = lambda x: [list(map(int, inp.readline().strip().split(\" \"))) for p in range(4)][x-1]\\n      ans1 = int(inp.readline().strip())\\n      row1 = set(gr(ans1))\\n      ans2 = int(inp.readline().strip())\\n      row2 = set(gr(ans2))\\n      sect = row1 & row2\\n      if len(sect) <= 0:\\n          print(\"Case #{}: Volunteer cheated!\".format(case))\\n      elif len(sect) == 1:\\n          print(\"Case #{}: {}\".format(case, sect.pop()))\\n      elif len(sect) > 1:\\n          print(\"Case #{}: Bad magician!\".format(case))\\n      else:\\n          print(\"ERROR\")\\n", "substitutes": {"filename": ["il", "prefix", "fp", "files", "ppa", "full", "path", "maximum", "document", "file", "phrase", "name", "knife", "fn", "dll", "f", "fd", "directory", "final", "utf", "iled", "download", "location", "nil", "figure", "FILE", "summary", "kl", "Filename", "url", "username", "SourceFile", "sheet", "title", "jet", "sf", "ename", "appy", "database", "fil", "which", "binary"], "inp": ["inb", "insh", "inassp", "inasb", "binp", "incl", "iniproc", "insproc", "binps", "inip", "inips", " inf", "Inp", "insb", "insper", "inasp", " inc", "insfp", "binper", "Insp", " inper", "asb", " inl", "inh", "Inh", "insc", "innproc", " inb", "iniper", "incp", "insf", "insl", "insp", "inc", "incc", " insp", "inper", "inproc", "ash", "inaspp", "inl", "innper", "innp", "inP", "infp", "inpp", " inps", " infp", "Inpp", " inpp", "InP", " inproc", "innfp", "asp", "asP", "inf", "inps", "insP", "Inb", "incf", "binproc"], "n": ["o", "nu", "nc", "cn", "ns", "nb", "m", "ot", "nn", "d", "x", "span", "l", "y", "f", "c", "t", "num", "i", "k", "z", "nt", "r", "network", "conn", "size", "w", "g", "j", "s", "b", "number", "u", "N", "net"], "case": ["li", "address", "ch", "rice", "pe", "division", "config", "path", "catch", "sea", "face", "pair", "name", "ice", "m", "time", "example", "space", "base", "h", "ex", "y", "X", "connection", "position", "c", "uc", "ace", "client", "code", "charge", "serial", "key", "condition", "num", "trial", "ce", "shape", "cell", "type", "match", "exc", "xc", "bc", "Case", "instance", "model", "line", "number", "fold", "ase", "section", "test", "patch", "cases", "definition"], "gr": ["err", "br", "res", "dr", "div", "ch", "tr", "group", "col", "cor", "range", "our", "order", "mr", "usr", "grade", "ru", "cr", "Gr", "grid", "arr", "fr", "chain", "grad", "ur", "rr", "arch", "gg", "r", "match", "groups", "reg", "mult", "GR", "rg", "g", "row", "sr", "hr", "gap", "pr", "char", "patch", "gor", "ge", "ravel", "yr"], "p": ["pl", "P", "pp", "ax", "col", "pe", "q", "pn", "d", "point", "h", "y", "X", "f", "c", "e", "t", "i", " xp", "r", "w", "j", " pe", "b", "pos", "ip", "u", "pc"], "ans1": ["lan1", "casp", "lan2", "ansp", "lan0", "cas1", "ass1", "ann0", "ass81", "anp", "cas2", "casOne", "annp", "ans0", "an2", "lan81", "ann1", "ass2", "ann81", "ass0", "ans81", "anOne", "annOne", "ansOne", "ann2", "an1"], "row1": ["rowOne", "row3", "col2", "line2", "rows3", " row01", "line01", "rowsone", "line3", "rowsOne", "col1", "rows1", "rows2", "passOne", "passone", "rowone", "colOne", "rows01", "pass2", "pass1", "line1", "row01", " row3", "colone"], "ans2": ["an02", "ras2", "ras62", "ras1", "can02", "ans62", "can1", "annTwo", "ann02", "atan62", "canTwo", "anssecond", "can2", "an2", "ans02", "atansecond", "atan1", "ann1", "annsecond", "atan2", "rassecond", "ansTwo", "ann62", "anTwo", "ann2", "an1"], "row2": ["col2", "Row02", "row0", "rows02", "coltwo", "row02", "Row1", "rows1", "ow2", "Row0", "rows2", "owtwo", "rows0", " row02", " rowtwo", "Row2", " row0", "rowtwo"], "sect": ["sequ", "subject", "array", "sq", "respect", "feat", "qa", "sw", "lc", "config", "na", "seq", "sector", "closure", "sc", "struct", "zen", "body", " sections", "access", " section", "cont", "fts", "equ", "rup", "col", "ign", "form", "connect", "rows", "fat", "sections", "sequence", "part", "conn", "six", "ect", "contract", "chn", "dit", "row", " intersect", "cells", "pect", "ctx", "pattern", "west", "fold", "rupt", "loc", "crit", "act", "sex", "pull", "section", "patch", "test", "ct", "cross", "zip"]}}
{"code": " \\n  def transpose(result, R, C):\\n  \tresultSplitted = result.split(\"\\n\")\\n  \taux = R*[\"\"]\\n  \tfor i in xrange(R):\\n  \t\tfor j in xrange(C):\\n  \t\t    aux[i] += resultSplitted[j][i]\\n  \t\taux[i] += \"\\n\"\\n  \tresult = \"\"\\n  \tfor item in aux:\\n  \t\tresult += item + \"\\n\"\\n  \treturn result.strip()\\n  \\n  \\n  inputFileName = sys.argv[1]\\n  \\n  f = file(inputFileName)\\n  fout = file(\"output.txt\", \"w\")\\n  \\n  T = int(f.readline())\\n  \\n  for case in xrange(T):\\n  \tdata = f.readline().strip().split(\" \")\\n  \tR = int(data[0])\\n  \tC = int(data[1])\\n  \tM = int(data[2])\\n  \\n  \tresult = \"\"\\n  \\n  \tx = min(R,C)\\n  \ty = max(R,C)\\n  \\n  \tif M > (y - 2)*x and M != y*x - 1:\\n  \t\tN = M - (y-2)*x\\n  \t\tif N%2 == 1 or y*x - M == 2:\\n  \t\t\tresult = \"Impossible\"\\n  \tif result != \"Impossible\":\\n  \t\ti = 0\\n  \t\twhile M > 0: # 2\\n  \t\t\tif i < y - 2:\\n  \t\t\t\tif M >= x:\\n  \t\t\t\t\tresult += x*\"*\" + \"\\n\"\\n  \t\t\t\t\tM -= x\\n  \t\t\t\t\ti += 1\\n  \t\t\t\telif M <= x - 2:\\n  \t\t\t\t\tresult += M*\"*\" + (x - M) * \".\" + \"\\n\"\\n  \t\t\t\t\tM = 0\\n  \t\t\t\t\ti += 1\\n  \t\t\t\telif i + 2 < y - 1:\\n  \t\t\t\t\tresult += (M-1)*\"*\" + (x - M + 1) * \".\" + \"\\n\" + \"*\" + (x-1)*\".\" + \"\\n\"\\n  \t\t\t\t\tM = 0\\n  \t\t\t\t\ti += 2\\n  \t\t\t\telse:\\n  \t\t\t\t\tresult = \"Impossible\"\\n  \t\t\t\t\tbreak\\n  \t\t\telse:\\n  \t\t\t\tif M%2 != 0:\\n  \t\t\t\t\tresult += x*\"*\" + \"\\n\"\\n  \t\t\t\t\tresult += (x-1)*\"*\" + \"c\"\\n  \t\t\t\telse:\\n  \t\t\t\t\tn = M/2\\n  \t\t\t\t\tresult += n*\"*\" + (x-n)*\".\" + \"\\n\"\\n  \t\t\t\t\tresult += n*\"*\" + (x-n-1)*\".\" + \"c\"\\n  \t\t\t\tM = 0\\n  \t\t\t\ti += 2\\n  \t\t\t\t\t\\n  \t\twhile i <= y - 1 and result != \"Impossible\":\\n  \t\t\tif i == y - 1:\\n  \t\t\t\tresult += (x-1)*\".\" + \"c\"\\n  \t\t\telse:\\n  \t\t\t\tresult += x*\".\" + \"\\n\"\\n  \t\t\ti += 1\\n  \t\\n  \tif R < C and result != \"Impossible\":\\n  \t\tresult = transpose(result, R, C)\\n  \\n  \tfout.write(\"Case #%d:\\n%s\\n\" %(case + 1, result))\\n", "substitutes": {"result": ["err", "replace", "ULT", "response", "array", "new", "res", "valid", "expression", "report", "config", "event", "current", "catch", "view", "function", "null", "example", "product", "text", "success", "out", "RESULTS", "search", "message", "default", "answer", "table", "reason", "final", "ret", "package", "transform", "cache", "status", "output", "description", "figure", "job", "sequence", "input", "r", "match", "value", "summary", "df", "exit", "buffer", "runner", "Result", "Results", "this", "re", "root", "compl", "number", "content", "string", "resource", "page", "test", "error", "results", "source", "method"], "R": ["P", "A", "array", "CR", "S", "JR", "B", "Ra", "range", "RA", "J", "L", "RR", "F", "X", "RN", "I", "ru", "RW", "RD", "Rs", "E", "NR", "RH", "Max", "DR", "RO", "D", "G", "Rank", "r", "Rh", "U", "Y", "Rad", "RS", "V", "Result", "row", "H", "RG", "root", "Cor", "Q", "W", "SR", "RF", "RC", "RM"], "C": ["CC", "Z", "P", "O", "SC", "CW", "CR", "CS", "S", "B", "Cs", "CI", "YC", "JC", "DC", "L", "J", "CL", "CM", "X", "F", "I", "c", "Ch", "CU", "E", "CT", "VC", "Max", "Cy", "D", "G", "NC", "MC", "U", "Y", "CA", "Cl", "V", "CP", "H", "Cu", "Q", "W", "CE"], "resultSplitted": [" resultsplited", " resultsplitized", "ResultSpited", "resultSplashed", " resultsplitted", "resultSlitized", "resultSpitting", "resultSplilled", "resultSpited", "resultClited", " resultsplashed", "resultSlitted", "resultSlited", "resultsplitized", "ResultSplilled", "ResultSpitting", "resultsplited", "ResultSpilled", "resultsplitted", "resultClitting", "resultsplashed", " resultSplitized", "resultSplited", "resultClilled", "ResultSplited", "resultSplitited", " resultSplashed", "resultSplititted", "resultSplititized", "resultSplitized", "ResultSplitted", "resultSplitting", "resultSplititting", "ResultSplitting", "resultClitted", "resultSplitashed", "resultSpitted", "resultSlashed", "resultSpilled", " resultSplited", "resultSplitilled", "ResultSpitted"], "aux": ["Array", "array", "extra", "ui", "ww", "long", "main", "feat", "frac", "Items", "lc", "config", "seq", "null", "au", "ext", "ai", "special", "flat", "external", "ex", "ru", "ux", "uc", "args", "items", "temp", "final", "events", "assembled", "sect", "abc", "sub", "front", "ault", "auc", "aligned", "partial", "sequence", "tmp", "input", "cmp", "iterator", "amp", "ursive", " auxiliary", "utils", "union", "exec", "iliary", "cas", "section", "total", "asc", "AU", "af"], "i": ["p", "o", "it", "ui", "li", "id", "ci", "ei", "index", "ori", "q", "m", "ini", "d", "ai", "J", "bi", "ind", "l", "h", "I", "ri", "ii", "c", "ti", "e", "ir", "t", "pi", "xi", "k", "z", "r", "ni", "a", "g", "im", "mi", "b", "v", "ip", "u", "qi", "n", "io", "si", "int", "iu"], "j": ["p", "li", "ci", "ch", "js", "index", "q", "jp", "m", "ji", "d", "J", "h", "ind", "l", "c", "ii", "adj", "e", "code", "key", "ie", "num", "xi", "obj", "k", "z", "jj", "g", "im", "ij", "b", "v", "u", "qi", "n", "si", "ct"], "item": ["p", "array", "extra", "new", "val", "foo", "current", "event", "entry", "name", "order", " it", "function", "example", "Item", "step", "X", "I", "raw", "other", "items", "temp", " Item", "num", "trial", "obj", "input", "value", "bar", "object", "row", "this", "v", "instance", "root", "ip", "string", "section", "anything", "option"], "inputFileName": ["inputFolderNum", "inputJarName", "inputJarDescription", "inputfileName", "inputJarDesc", "inputFolderName", "fileJarDescription", "inputFolderDir", "inputDirPath", "InputfileNum", "inputSourceFileUrl", "fileFileDescription", "InputFileUrl", "InputfileUrl", "inputfileUrl", "InputfileName", "inputSourceFileDir", "inputFileDescription", "inputFileDesc", "InputFileNum", "InputFileName", "inputfilePath", "inputDirName", "inputSourceFileNum", "fileJarName", "inputfileDir", "inputfileNum", "inputDirDescription", "inputSourceFileName", "inputFileUrl", "fileJarDesc", "inputFileNum", "fileFilePath", "InputFileDir", "inputFilePath", "inputDirDesc", "inputfileDesc", "inputJarPath", "fileFileDesc", "InputfileDir", "fileFileName", "inputfileDescription", "inputFolderUrl", "fileJarPath", "inputFileDir"], "f": ["p", "fp", "file", "m", "d", "rf", "h", "F", "l", "fn", "fo", "c", "fr", "fd", "e", "fb", "t", "form", "fw", "fc", "info", "tf", "z", "buff", "r", "input", "fs", "w", "s", "v", "b", "feed", "io", "inf", "df", "folder", "ff", "af"], "fout": [" fstr", "fdstr", "FOut", " fOut", " fouts", "fstr", "Fouts", "fdout", "fdOut", "fOut", "Fstr", "fdouts", "fouts", "Fout"], "T": ["Z", "P", "O", "TT", "A", "S", "B", "TA", "J", "L", "TB", "TM", "F", "X", "K", "I", "TS", "t", "E", "TN", "D", "G", "U", "Y", "V", "H", "Q", "W", "Time", "NT"], "case": ["val", "tim", "ci", "col", "seq", "q", "ice", "time", "ai", "h", "gi", "times", "c", "shift", "ti", "code", "temp", "job", "obj", "cell", "z", "sec", "je", "cycle", "ib", " ti", "section", "test", "ct"], "data": ["split", "Data", "p", "date", "response", "array", "start", "id", "list", "lines", "xxx", "config", "index", "current", "aa", "na", "details", "m", "function", "d", "body", "missing", "default", "c", "e", "code", "args", "items", "rec", "series", "key", "batch", "none", "pad", "output", "info", "input", "DATA", "r", "dat", "value", "sample", "a", "object", "first", "s", "load", "pos", "number", "content", "string", "block", "n", "int", "da", "slice", "source", "one"], "M": ["Mo", "Z", "P", "O", "LM", "A", "S", "MN", "B", "m", "J", "L", "MA", "F", "X", "I", "K", "DM", "IM", "E", "ME", "MM", "D", "G", "MI", "MS", "MD", "MC", "U", "Y", "V", "H", "MT", "Q", "NM", "W", "MX"], "x": ["p", "o", "ci", "ix", "ax", "index", "width", "m", "d", "L", "h", "max", "X", "ex", "l", "wx", "c", "e", "t", "xes", "num", "xi", "z", "r", "size", "xs", "xc", "Y", "rx", "w", "xy", "s", "v", "b", "min", "number", "u", "my", "xx", "n", "int", "ct"], "y": ["p", "o", "py", "ch", "sy", "m", "ay", "d", "ny", "ya", "dy", "yo", "l", "X", "h", "vy", "c", "ym", "e", "t", "ky", "z", "r", "type", "gy", "Y", "a", "w", "ey", "xy", "b", "v", "min", "my", "n", "oy", "yy", " Y", "yr", "cy"], "N": ["P", "O", "S", "MN", "B", " n", "Ns", "m", "No", "J", "L", "NI", "F", "X", "I", "E", "NO", "D", "G", "U", "Y", "V", "NM", "Q", "W", "NS", "n", "Ni", "NT"]}}
{"code": " \\n  inputFileName = sys.argv[1]\\n  \\n  f = file(inputFileName)\\n  fout = file(\"output.txt\", \"w\")\\n  \\n  T = eval(f.readline())\\n  \\n  for case in xrange(T):\\n  \\n  \tA1 = int(f.readline().strip())\\n  \\n  \tfor i in xrange(4):\\n  \t\tif i == A1 - 1:\\n  \t\t\tpossibles1 = f.readline().strip().split(\" \")\\n  \t\telse:\\n  \t\t\tf.readline().strip().split(\" \")\\n  \\n  \tA2 = int(f.readline().strip())\\n  \\n  \tfor i in xrange(4):\\n  \t\tif i == A2 - 1:\\n  \t\t\tpossibles2 = f.readline().strip().split(\" \")\\n  \t\telse:\\n  \t\t\tf.readline().strip().split(\" \")\\n  \\n  \tfinal = []\\n  \tfor item in possibles2:\\n  \t\tif item in possibles1:\\n  \t\t\tfinal.append(item)\\n  \\n  \tif len(final) == 0:\t\\n  \t\tfout.write(\"Case #%d: Volunteer cheated!\\n\" %(case + 1))\\n  \telif len(final) == 1:\\n  \t\tfout.write(\"Case #%d: %s\\n\" %(case + 1, final[0]))\\n  \telse:\\n  \t\tfout.write(\"Case #%d: Bad magician!\\n\" %(case + 1))\\n", "substitutes": {"inputFileName": ["inputLineLocation", "inputClassCopy", "inputPathLocation", "inputfileName", "inputClassName", "inputClassPath", "inputFileLocation", "outputLineLocation", "inputFullNames", "inputTableLocation", "inputTablePath", "inputTableName", "outputClassNames", "inputLinePath", "outputClassName", "inputfileCopy", "outputLineName", "inputLineName", "outputLineCopy", "inputfilePath", "inputFileCopy", "inputTableCopy", "outputLinePath", "outputFileNames", "inputfileNames", "inputClassNames", "outputClassPath", "inputPathPath", "outputFilePath", "inputFullName", "inputFilePath", "inputPathName", "outputClassCopy", "inputPathCopy", "inputFileNames", "inputLineCopy", "inputFullCopy", "outputFileName", "outputFileCopy", "inputFullPath", "outputFileLocation"], "f": ["p", "o", "fp", "lf", "fast", "full", "more", "cf", "of", "fm", "file", "func", "m", "function", "d", "fx", "x", "rf", "flat", "l", "F", "fn", "fo", "found", "c", "fr", "fd", "fa", "e", "t", "fl", "form", "fw", "fc", "info", "tf", "z", "r", "input", "conf", "bf", "fe", "fs", "w", "g", "s", "v", "b", "u", "fold", "sf", "feed", "fen", "io", "inf", "ff"], "fout": [" fOut", "fin", "fOUT", "Fouts", " fouts", "fOut", "affsync", "fsync", "fileOut", "sfuser", " fin", "fileuser", "cfint", "ifout", "fpout", " fOUT", "fpOUT", "fpin", "fuser", "FOUT", "fouts", "sfagain", "sfin", " fagain", "ifecho", " fecho", "fint", "filein", " fint", "fileagain", "cfOut", "fileint", "fpouts", "cfin", "affecho", "fileout", "cfout", " fsync", "Fin", "sfout", "ifsync", "affout", " fuser", "fagain", "fecho", "Fout"], "T": ["TT", "O", "A", "P", "R", "TC", "S", "WT", "B", "LT", "L", "F", "X", "I", "TS", "t", "E", "D", "M", "U", "V", "C", "Q", "W", "N", "TE", "Time", "NT"], "case": ["switch", "li", "id", "address", "config", "catch", "seq", "sea", "name", "ice", "time", "slice", "point", "phase", "position", "c", "shift", "ace", "client", "end", "e", "code", "t", "choice", "chain", "charge", "key", "ie", "num", "ce", "trial", "shape", "type", "match", "cycle", "size", "ape", "bc", "length", "C", "Case", "instance", "line", "ip", "ase", "bug", "test", "patch", "section", "cases", "change"], "A1": ["C81", "a8", "AName", " A61", " AOne", "AreaName", "A8", "LA1", "a1", "Area1", "AOne", "A9", " A81", " AName", "a9", "C1", " A9", "COne", "LA61", "A61", "A81", " A8", "CName", "Area81", "LA8", "AreaOne", "a61", "LA9"], "i": ["p", "o", "it", "ui", "li", "chi", "id", "ci", "oi", "ori", "cli", "phi", "ai", "d", "x", "bi", "ind", "l", "I", "gi", "ii", "c", "ti", "vi", "e", "t", "yi", "zi", "ie", "uri", "pi", "xi", "di", "ic", "ni", "a", "j", "s", "v", "ip", "qi", "n", "si", "io", "int", "iu"], "possibles1": ["pOSSible3", "possibility3", "possible2", "possibilityOne", "possible3", "possibilitiesOne", "pOSSiblesOne", "possibility2", "possablesOne", "possibleOne", "pOSSible1", "possables1", "pOSSibles3", "pOSSibles2", "possibilities2", "pOSSibles1", "pOSSibleOne", "possibility1", "possible1", "possibles3", "possiblesOne", "possibilities1", "pOSSible2", "possables2", "possibilities3"], "A2": ["AllSecond", "All3", "A72", "HA72", " A72", "LA62", "All72", " A62", "All2", "HA3", " A3", "A3", "ASecond", "HASecond", "LASecond", "HA62", " ASecond", "HA2", "LA2", "A62"], "possibles2": ["posibility1", "posibles1", "possibl5", "possibility4", "possible2", "possibles0", "possibl2", "possibility0", "possible0", "pOSSible5", "posibles2", "possibles5", "pOSSible4", "possibles4", "posibility4", "possibility2", "pOSSible1", "pOSSibles4", "pOSSibles2", "possibl4", "possibilities4", "possibilities2", "pOSSibles1", "possibilities0", "possibility1", "possibl1", "possible4", "posibility0", "possible1", "possibility5", "pOSSibles5", "possibilities1", "possible5", "posibility2", "pOSSible2", "posibles4", "posibles0"], "final": ["p", "latest", "new", "all", "extra", "single", "full", "valid", "aux", "current", "version", "null", "later", "random", "special", "real", "external", "confirmed", "close", "stack", "update", "data", "other", "Final", "serial", "temp", "package", "empty", "local", "actual", "partial", "part", "initial", "size", "static", "fixed", "unique", "standard", "last", "public", "small", "general", "complete", "upper", "private", "finals", "original", "result", "clean", "total", "finished", "section", "old", "done"], "item": ["it", "extra", "li", "unit", "val", "id", "exp", "index", "event", "entry", "name", "example", "Item", "parent", "missing", "step", "custom", "character", "member", "data", "individual", "edit", "items", "temp", "inner", "rec", "trial", "atom", "match", "value", "something", "im", "bar", "object", "row", "hop", "instance", "root", "number", "ip", "gap", "loc", "string", "page", "section", "result", "test", "word", "layer", "source", "anything"]}}
{"code": " \\n  \\n  EOL = \"\\n\"\\n  \\n  \\n  def is_equal_approx(x, y, epsilon=1e-6):\\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\\n      \\n      By default, 'epsilon' is 1e-6.\\n      \"\"\"\\n      if -epsilon <= x - y <= epsilon:\\n          return True\\n  \\n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\\n          return False\\n  \\n      return (-epsilon <= (x - y) / x <= epsilon\\n          or -epsilon <= (x - y) / y <= epsilon)\\n    \\n  def read_syms(fd):\\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\\n      return fd.readline().strip().split()\\n  \\n  def read_ints(fd):\\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\\n      return [int(p) for p in read_syms(fd)]\\n  \\n  def read_floats(fd):\\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\\n      return [float(p) for p in read_syms(fd)]\\n  \\n  \\n  class Mtrx(object):\\n      \"\"\"A matrix object.\"\"\"\\n      \\n      def __init__(self, rows, cols, data):\\n          assert len(data) == rows * cols\\n          self.rows = rows\\n          self.cols = cols\\n          self.data = data\\n          \\n      def cell(self, r, c):\\n          return self.data[r * self.cols + c]\\n      \\n      def getrow(self, i):\\n          return [self.cell(i, c) for c in xrange(self.cols)]\\n  \\n      def getcol(self, i):\\n          return [self.cell(c, i) for c in xrange(self.rows)]\\n      \\n      @classmethod\\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\\n          \\n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\\n          Pre-determined size can be passed using `rows` and `cols`.\\n          \"\"\"\\n          data = []\\n          if rows is None:\\n              assert cols is None\\n              rows, cols = read_ints(fd)\\n          else:\\n              assert cols is not None\\n          for _ in range(rows):\\n              line = readfunc(fd)\\n              assert len(line) == cols\\n              data.extend(line)\\n          return Mtrx(rows, cols, data)\\n              \\n      @classmethod\\n      def read_int_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_ints, rows, cols)\\n              \\n      @classmethod\\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_syms, rows, cols)\\n              \\n      def __str__(self):\\n          res = \"\"\\n          for i in xrange(self.rows):\\n              res += str(self.getrow(i)) + EOL\\n          return res\\n      \\n      def __repr__(self):\\n          return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\\n                                         self.cols, self.data)\\n  \\n  \\n  cachetotals = 0\\n  cachemisses = 0\\n  \\n  def statreset():\\n      global cachemisses, cachetotals\\n      cachemisses = 0\\n      cachetotals = 0\\n  \\n  class memoizeit(object):\\n      \"\"\"Decorator. Caches a function's return value each time it is called.\\n      \\n      If called later with the same arguments, the cached value is returned \\n      (not reevaluated).\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          self.cache = {}\\n          \\n      def __call__(self, *args):\\n          \\n          global cachetotals, cachemisses\\n          cachetotals += 1\\n          \\n          try:\\n              return self.cache[args]\\n          except KeyError:\\n              \\n              cachemisses += 1\\n              \\n              value = self.func(*args)\\n              self.cache[args] = value\\n              return value\\n          except TypeError:\\n  \\n              cachemisses += 1\\n  \\n              return self.func(*args)\\n      \\n      @property\\n      def __name__(self):\\n          return self.func.__name__\\n      \\n      def __get__(self, obj, objtype):\\n          \"\"\"Support instance methods.\"\"\"\\n          return functools.partial(self.__call__, obj)\\n  \\n  \\n  class timeit(object):\\n      \"\"\"Decorator that times a function.\\n      \\n      When function ends, print name, runtime, return value and cache stats.\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          \\n      def __call__(self, *args):\\n          start = time.time()\\n          value = self.func(*args)\\n          delta = time.time() - start\\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\\n              cachetotals else 0\\n          print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\\n              delta, value, cachedata)\\n          return value\\n      \\n      def __get__(self, obj, objtype):\\n          return functools.partial(self.__call__, obj)\\n  \\n  \\n  def read_input(filename):\\n      data = []\\n      with open(filename, \"r\") as f:\\n          cases = read_ints(f)[0]\\n          for _ in xrange(cases):\\n              case = {}\\n              case[\"R\"], case[\"C\"], case[\"M\"] = read_ints(f)\\n              data.append(case)\\n      return data\\n  \\n  def make_output(fname, output):\\n      CASE_PRFX = \"Case #%s: \"\\n      fname = fname + time.strftime(\"%H%M%S\") + \".out\"\\n      with open(fname, \"w\") as f:\\n          restext = []\\n          print \"Output content ===============\"\\n          for i, outdata in enumerate(output):\\n              line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL\\n              print line,\\n              restext.append(line)\\n          print \"=\" * 30\\n          f.writelines(restext)\\n  \\n  \\n  MINE = \"*\"\\n  CLICK = \"c\"\\n  UNK = \".\"\\n  \\n  class Board(object):\\n      \\n      def __init__(self, r, c):\\n          self.rows = r\\n          self.cols = c\\n          self.edge_row_idx = self.rows - 1\\n          self.edge_col_idx = self.cols - 1\\n          self.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]\\n          self.board[0][0] = CLICK\\n  \\n      def fill_edge_row(self, m):\\n          i = self.edge_col_idx\\n          while m > 0 and i >= 0:\\n              self.board[self.edge_row_idx][i] = MINE\\n              i -= 1\\n              m -= 1\\n          self.edge_row_idx -= 1\\n  \\n      def fill_edge_col(self, m):\\n          i = self.edge_row_idx\\n          while m > 0 and i >= 0:\\n              self.board[i][self.edge_col_idx] = MINE\\n              i -= 1\\n              m -= 1\\n          self.edge_col_idx -= 1\\n  \\n      def __str__(self):\\n          return EOL.join([\"\".join(r) for r in self.board])\\n  \\n  @memoizeit\\n  def is_stage_solvable(rows, cols, mines):\\n      \"\"\"Return True iff stage is solvable. \\n      Also return fill instruction:\\n      0 if impossible/dontcare, 1 to fill row, 2 to fill column, \\n      3 for row special (most in the row), 4 for col special (most in the col)\\n      \"\"\"\\n      rc = rows * cols\\n      \\n      if mines == rc:\\n          return False, 0\\n  \\n      if rows == 1:\\n          return mines <= rc - 1, 2\\n      if cols == 1:\\n          return mines <= rc - 1, 1\\n      \\n      if mines == rc - 1:\\n          return True, 1  # doesn't matter what to fill\\n      \\n      if mines > rc - 4:\\n          return False, 0\\n      \\n      if rows == 2:\\n          return (False, 0) if mines == 1 else (True, 2)\\n      if cols == 2:\\n          return (False, 0) if mines == 1 else (True, 1)\\n          \\n      if rows <= cols:\\n          if mines >= rows:\\n              return True, 2\\n          if mines == rows - 1:\\n              if mines == cols - 1:\\n                  if rows == 3:\\n                      return False, 0\\n                  return True, 4 # L shape fill, most in the column\\n              else:\\n                  return True, 1 # fill row\\n          return True, 2 \\n      else:\\n          if mines >= cols:\\n              return True, 1\\n          if mines == cols - 1:\\n              if mines == rows - 1:\\n                  if cols == 3:\\n                      return False, 0\\n                  return True, 3 # L shape fill, most in the row\\n              else:\\n                  return True, 2 # fill column\\n          return True, 1 \\n  \\n  @timeit\\n  def solveit(case):\\n      rows = case[\"R\"]\\n      cols = case[\"C\"]\\n      mines = case[\"M\"]\\n      \\n      b = Board(rows, cols)\\n      r, c, m = rows, cols, mines\\n      \\n      while m >= 0:\\n          okgo, howtofill = is_stage_solvable(r, c, m)\\n          if not okgo:\\n              return \"Impossible\"\\n          if howtofill == 1: # fill row\\n              b.fill_edge_row(m)\\n              if m <= c:\\n                  break # fill and done\\n              m -= c\\n              r -= 1\\n          elif howtofill == 2: # fill column\\n              b.fill_edge_col(m)\\n              if m <= r:\\n                  break # fill and done\\n              m -= r\\n              c -= 1\\n          elif howtofill == 3: # L shape fill, most in the row\\n              b.fill_edge_row(m - 1)\\n              b.fill_edge_col(1)\\n              break # fill and done\\n          elif howtofill == 4: # L shape fill, most in the column\\n              b.fill_edge_col(m - 1)\\n              b.fill_edge_row(1)\\n              break # fill and done\\n          else:\\n              assert False\\n  \\n      return str(b) \\n  \\n  \\n  \\n  @timeit\\n  def main(fname):\\n      data = read_input(fname)\\n      output = []\\n      for case in data:\\n          statreset() # reset cache stats\\n          res = solveit(case)\\n          output.append(res)\\n      make_output(fname, output)\\n  \\n  \\n  if __name__ == '__main__':\\n      main(\"C-small-attempt0.in\")\\n", "substitutes": {"EOL": ["EOC", "eol", " Eol", "EBOC", "eOF", "EBOF", " EOC", "EOF", "eOC", "EBol", " EOF", "EBOL", "Eol", "eOL"], "x": ["ph", "dx", "id", "ix", "ax", "yx", "xf", "wy", "width", "ay", "time", "d", "h", "ex", "X", "l", "point", "ya", "f", "wx", "xa", "e", "t", "px", "win", "xi", "xe", "k", "z", "cell", "xs", "xc", "Y", "rx", "w", "a", "xy", "b", "v", "u", "ty", "on", "xx", "sex", "n", "int"], "y": ["o", "py", "sy", "hy", "wy", "ye", "ay", "d", "ny", "ya", "dy", "yo", "vy", "f", "l", "yt", "ry", "ym", "e", "ies", "ady", "t", "yi", "year", "ky", "yd", "z", "Y", "yl", "w", "j", "ey", "b", "v", "iy", "ys", "zy", "ty", "oy", "n", "yy", "yr", "cy"], "epsilon": ["epssilen", "iprilor", "epilen", "EPsilency", "apillron", "epiolons", "epinelon", "eprilron", "epillons", "apilloner", "epeltON", "apsilron", "eprilone", "epalron", "epilony", "ppeltron", "epiolan", "apsiloner", "eprilor", "epillone", "epillON", "epssiloton", "epsilan", "epeltency", "epeltons", "EPsilony", "epelton", "ppelton", "ppeltone", "epsilor", "epineloner", "iprilron", "ppeltony", "epillon", "epsilone", "epillhen", "epsalron", "ipsilon", "epineloton", "epalan", "apillony", "epsilON", "ppillON", "epilron", "epilON", "epsilen", "eprilony", "epslan", "epsalons", "epalON", "epillan", "EPelton", "ppsilony", "EPeltone", "epslON", "EPsilone", "epsilhen", "epalyson", "eprilency", "epSilor", "ppsilen", "epillron", "epinelron", "epssilON", "eprilons", "ppillon", "epsilons", "epssilhen", "epsilron", "epssilons", "epalysoton", "epeltoner", "epiloton", "ppillen", "epslon", "epeltony", "epiolon", "apsilony", "ipsilron", "epssilone", "epilon", "epeltron", "epsalan", "epillony", "epalysoner", "ppsilone", "epsalON", "epilor", "apillon", "epSilony", "EPsilon", "epssilron", "EPeltency", "epalhen", "epsilency", "eprilen", "epilons", "iprilon", "ipsilony", "eprilon", "iprilony", "epsiloner", "ppsilON", "epssiloner", "epssilan", "eprilON", "ppsilon", "epalon", "ppillron", "epalysron", "epiolhen", "epssilon", "epSilon", "epssilony", "epsiloton", "epsalon", "apsilon", "epilan", "epillency", "epsilony", "epilloner", "epsalhen", "eprilan", "ipsilor", "epSilron", "epeltone", "EPeltony", "ppsilron", "epillen", "epslron", "epilone", "epalons", "epiloner", "epelten"], "fd": ["fin", "fp", "td", "rb", "lf", "pdf", "draft", "cf", "dc", "ld", "af", "fed", " fid", "fm", "db", "file", "wd", "ds", "stream", "hd", "d", "fx", "fn", "f", "ecd", "fr", "fa", "fb", "dir", "handle", "fl", "draw", "fw", "fc", "fat", "handler", "pd", "buf", "bf", "fe", "gd", "fi", "df", "fs", "cb", "dl", "driver", "wb", "nd", "dd", "reader", "pipe", "vd", "sf", "feed", "fen", "cod", "bd", "folder", "ff", "wind", "FD"], "p": ["o", "P", "fp", "ph", "pp", "op", "vp", "sp", "py", "ep", "tp", "q", "jp", "python", "np", "d", "pa", "ap", "h", "l", "f", "cp", "pid", "e", "t", "bp", "pi", "gp", "wp", "type", "g", "lp", "b", "v", "u", "ip", "pr", "n", "mp", "pc"], "self": ["node", "all", "ws", "user", "qa", "proxy", "event", "h", "parent", "default", "us", "os", "z", "tmp", "part", "w", "this", "plus", "page", "er", "cs", "worker", "old", "home", "gen", "Self", "full", "resp", "app", "ko", "view", "es", "req", "end", "form", "ng", "plugin", "object", "instance", "pos", "ctx", "n", "df", "results", "config", "spec", "d", "per", "f", "wx", "host", "github", "client", "e", "events", "wrapper", "fs", "a", "work", "cl", "j", "error", "now", "ff", "ref", "err", "new", "lf", "dev", "q", "l", "http", "other", "gh", "k", "co", "g", "context", "s", "b", "master", "sys"], "rows": ["tests", "forms", "all", "files", "ws", "reports", "index", "ips", "ins", "head", "reads", "levels", "faces", "points", "items", "devices", "holes", "ks", "length", "orders", "heads", "char", "tracks", "ros", "cs", "rooms", "vals", "relations", "users", "es", "fields", "ries", "models", "views", "values", "frames", "keys", "rules", "OWS", "groups", "window", "headers", "ports", "pos", "rs", "results", "ls", "lines", "qs", "d", "ops", "ids", " row", "events", "checks", "posts", "blocks", "xs", " lines", "row", "rings", "pages", "rown", "features", "runs", "docs", "aults", "errors", "opens", "modules", "times", "flows", "roots", "ows", "types", "boxes", "s", "cells", "members", "days", "planes", " columns", "olds", "breaks"], "cols": ["cld", "coles", "pooli", "columnows", "columnsd", "colabs", "colles", "colln", "columnabs", " colS", "colds", "Colabs", " colcount", "cold", "Colts", "columnsi", "columnops", "columncount", "threadts", "ylp", "columns", "colgs", "Cold", "columnes", " colls", " cold", " coles", "columni", "collows", "ColS", " colw", "ylls", "columnS", "colb", "pooln", "columnw", "colS", "threads", "Colls", "Colp", "COLops", " colts", "colw", "clcs", " colds", "colsi", "yls", " colp", "COLgs", "colls", "yln", "COLn", " colops", "Colsd", "Coli", "dicti", " colsi", "dicts", "poolsi", "colows", "colsd", "columnts", "pools", " colabs", "Colb", "colts", "COLsd", " coln", "Colds", " colb", " coli", "COLts", "columnd", "colcount", "COLs", "COLabs", "Colows", "colli", "Coln", "Cols", "columnb", "colops", "columnds", " colows", "threadgs", "columnn", "dictn", "cles", "coln", " colgs", "Colw", "columncs", "collcount", "COLd", "colcs", "coli", " colcs", "colp"], "data": ["format", "steps", "response", "array", "image", "all", "div", "list", "index", "actions", "parent", "next", "missing", "default", "code", "scale", "items", "ata", "draw", "devices", "buffer", "dd", "xxx", "multi", "body", "alpha", "arr", "table", "values", "form", "dict", "dat", "window", "column", "sample", "load", "pos", "reader", "memory", "result", "da", "json", "results", "Data", "li", "lines", "valid", "config", "d", "text", "f", "str", "di", "source", "post", "partial", "cell", "input", "DATA", "blocks", "a", "row", "content", "zip", "la", "group", "float", "raw", "batch", "api", "media", "bytes", "append", "cells", "model", "string", "block", "feed", "breaks"], "r": ["rb", "R", "ra", "col", "range", "entry", "q", "ar", "d", "l", "f", "cr", "ru", "nr", "right", "e", "rec", "rr", "k", "z", "rar", "rh", "w", "j", "row", "b", "v", "sr", "s", "u", "lr", "n", "rs", "er"], "c": ["cu", "ci", "ch", "cc", "unc", "col", "cf", "lc", "nc", "dc", "d", "arc", "h", "l", "f", "cr", "cp", "uc", "e", "code", "t", "rec", "ce", "fc", "ec", "k", "z", "cell", "cat", "ic", "cm", "xc", "co", "cl", "C", "s", "row", "v", "b", "u", "n", "int", "cs", "ct", "pc", "ac", "cy"], "i": ["it", "cu", "ui", "li", "id", "ci", "ix", "ch", "col", "lc", "index", "oi", "q", "ini", "d", "ai", "l", "f", "I", "ri", "ii", "e", "yi", "xi", "di", "pi", "z", "cell", "ic", "j", "mi", "s", "v", "b", "u", "ip", "qi", "n", "si", "io", "int", "iu"], "cls": ["CLs", "Cls", "CLabs", " clsb", "clabs", " clp", " Clp", "clp", "hellsb", " clsys", " Clsys", "Classsg", "clsys", "CLS", "Clsys", "Classsb", "wells", "wellsb", "Clabs", "CLsb", "Clusters", " clabs", "Clp", "Clsg", "ClS", "Clsb", "clusters", "clsg", "clsb", "clS", "CLsg", " clusters", "Classs", "hells", "wellusters", " Cls", "hellS"], "readfunc": ["readfun", "writefunc", "loadfun", "readfunction", "writeproc", "loadfunc", " readproc", "readproc", "writefunction", " readfunction", "loadproc", " readfun", "writefun", "loadfunction"], "_": ["all", "q", "un", "l", "f", "al", "k", "g", "non"], "line": ["band", "lf", "li", "lines", "lin", "col", "lc", "range", "len", "log", "entry", "file", "name", "Line", "header", "d", "text", "body", "base", "l", "record", "str", "end", "code", "no", "frame", "el", "cell", "LINE", "input", "inline", "limit", "column", "length", "buffer", "row", "model", "number", "reader", "char", "sync", "content", "string", "block", "page", "item", "section", "lo", "byte", "zip"]}}
{"code": " \\n  \\n  EOL = \"\\n\"\\n  \\n  \\n  def is_equal_approx(x, y, epsilon=1e-6):\\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\\n      \\n      By default, 'epsilon' is 1e-6.\\n      \"\"\"\\n      if -epsilon <= x - y <= epsilon:\\n          return True\\n  \\n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\\n          return False\\n  \\n      return (-epsilon <= (x - y) / x <= epsilon\\n          or -epsilon <= (x - y) / y <= epsilon)\\n    \\n  def read_syms(fd):\\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\\n      return fd.readline().strip().split()\\n  \\n  def read_ints(fd):\\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\\n      return [int(p) for p in read_syms(fd)]\\n  \\n  def read_floats(fd):\\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\\n      return [float(p) for p in read_syms(fd)]\\n  \\n  class Mtrx(object):\\n      \"\"\"A matrix object.\"\"\"\\n      \\n      def __init__(self, rows, cols, data):\\n          assert len(data) == rows * cols\\n          self.rows = rows\\n          self.cols = cols\\n          self.data = data\\n          \\n      def cell(self, r, c):\\n          return self.data[r * self.cols + c]\\n      \\n      def getrow(self, i):\\n          return [self.cell(i, c) for c in xrange(self.cols)]\\n  \\n      def getcol(self, i):\\n          return [self.cell(c, i) for c in xrange(self.rows)]\\n      \\n      @classmethod\\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\\n          \\n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\\n          Pre-determined size can be passed using `rows` and `cols`.\\n          \"\"\"\\n          data = []\\n          if rows is None:\\n              assert cols is None\\n              rows, cols = read_ints(fd)\\n          else:\\n              assert cols is not None\\n          for _ in range(rows):\\n              line = readfunc(fd)\\n              assert len(line) == cols\\n              data.extend(line)\\n          return Mtrx(rows, cols, data)\\n              \\n      @classmethod\\n      def read_int_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_ints, rows, cols)\\n              \\n      @classmethod\\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_syms, rows, cols)\\n              \\n      def __str__(self):\\n          res = \"\"\\n          for i in xrange(self.rows):\\n              res += str(self.getrow(i)) + EOL\\n          return res\\n      \\n      def __repr__(self):\\n          return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\\n                                         self.cols, self.data)\\n  \\n               \\n  cachetotals = 0\\n  cachemisses = 0\\n  \\n  def statreset():\\n      global cachemisses, cachetotals\\n      cachemisses = 0\\n      cachetotals = 0\\n  \\n  class memoizeit(object):\\n      \"\"\"Decorator. Caches a function's return value each time it is called.\\n      \\n      If called later with the same arguments, the cached value is returned \\n      (not reevaluated).\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          self.cache = {}\\n          \\n      def __call__(self, *args):\\n          \\n          global cachetotals, cachemisses\\n          cachetotals += 1\\n          \\n          try:\\n              return self.cache[args]\\n          except KeyError:\\n              \\n              cachemisses += 1\\n              \\n              value = self.func(*args)\\n              self.cache[args] = value\\n              return value\\n          except TypeError:\\n  \\n              cachemisses += 1\\n  \\n              return self.func(*args)\\n      \\n      @property\\n      def __name__(self):\\n          return self.func.__name__\\n      \\n      def __get__(self, obj, objtype):\\n          \"\"\"Support instance methods.\"\"\"\\n          return functools.partial(self.__call__, obj)\\n  \\n  class timeit(object):\\n      \"\"\"Decorator that times a function.\\n      \\n      When function ends, print name, runtime, return value and cache stats.\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          \\n      def __call__(self, *args):\\n          start = time.time()\\n          value = self.func(*args)\\n          delta = time.time() - start\\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\\n              cachetotals else 0\\n          print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\\n              delta, value, cachedata)\\n          return value\\n      \\n      def __get__(self, obj, objtype):\\n          return functools.partial(self.__call__, obj)\\n  \\n", "substitutes": {"EOL": ["EOC", "eol", " Eol", "EBOC", "eOF", "EBOF", " EOC", "EOF", "eOC", "EBol", " EOF", "EBOL", "Eol", "eOL"], "x": ["ph", "dx", "id", "ix", "ax", "yx", "xf", "wy", "width", "m", "ay", "time", "d", "h", "ex", "X", "l", "point", "ya", "f", "wx", "xa", "e", "t", "px", "win", "xi", "xe", "k", "z", "cell", "xs", "xc", "Y", "rx", "w", "a", "xy", "b", "v", "u", "ty", "on", "xx", "sex", "n", "int"], "y": ["o", "py", "sy", "hy", "wy", "ye", "ay", "d", "ny", "ya", "dy", "yo", "vy", "f", "l", "yt", "ry", "ym", "e", "ies", "ady", "t", "yi", "year", "ky", "yd", "z", "Y", "yl", "w", "j", "ey", "b", "v", "iy", "ys", "zy", "ty", "oy", "n", "yy", "yr", "cy"], "epsilon": ["epssilen", "iprilor", "epilen", "EPsilency", "apillron", "epiolons", "epinelon", "eprilron", "epillons", "apilloner", "epeltON", "apsilron", "eprilone", "epalron", "epilony", "ppeltron", "epiolan", "apsiloner", "eprilor", "epillone", "epillON", "epssiloton", "epsilan", "epeltency", "epeltons", "EPsilony", "epelton", "ppelton", "ppeltone", "epsilor", "epineloner", "iprilron", "ppeltony", "epillon", "epsilone", "epillhen", "epsalron", "ipsilon", "epineloton", "epalan", "apillony", "epsilON", "ppillON", "epilron", "epilON", "epsilen", "eprilony", "epslan", "epsalons", "epalON", "epillan", "EPelton", "ppsilony", "EPeltone", "epslON", "EPsilone", "epsilhen", "epalyson", "eprilency", "epSilor", "ppsilen", "epillron", "epinelron", "epssilON", "eprilons", "ppillon", "epsilons", "epssilhen", "epsilron", "epssilons", "epalysoton", "epeltoner", "epiloton", "ppillen", "epslon", "epeltony", "epiolon", "apsilony", "ipsilron", "epssilone", "epilon", "epeltron", "epsalan", "epillony", "epalysoner", "ppsilone", "epsalON", "epilor", "apillon", "epSilony", "EPsilon", "epssilron", "EPeltency", "epalhen", "epsilency", "eprilen", "epilons", "iprilon", "ipsilony", "eprilon", "iprilony", "epsiloner", "ppsilON", "epssiloner", "epssilan", "eprilON", "ppsilon", "epalon", "ppillron", "epalysron", "epiolhen", "epssilon", "epSilon", "epssilony", "epsiloton", "epsalon", "apsilon", "epilan", "epillency", "epsilony", "epilloner", "epsalhen", "eprilan", "ipsilor", "epSilron", "epeltone", "EPeltony", "ppsilron", "epillen", "epslron", "epilone", "epalons", "epiloner", "epelten"], "fd": ["fin", "fp", "td", "rb", "lf", "pdf", "draft", "cf", "dc", "ld", "af", "fed", " fid", "fm", "db", "file", "wd", "ds", "stream", "hd", "d", "fx", "fn", "f", "ecd", "fr", "fa", "fb", "dir", "handle", "fl", "draw", "fw", "fc", "fat", "handler", "pd", "buf", "bf", "fe", "gd", "fi", "df", "fs", "cb", "dl", "driver", "wb", "nd", "dd", "reader", "pipe", "vd", "sf", "feed", "fen", "cod", "bd", "folder", "ff", "wind", "filename", "FD"], "p": ["o", "P", "fp", "ph", "pp", "op", "vp", "sp", "py", "ep", "tp", "q", "jp", "m", "python", "np", "d", "pa", "ap", "h", "l", "f", "cp", "pid", "e", "t", "bp", "pi", "gp", "wp", "type", "g", "lp", "b", "v", "u", "ip", "pr", "n", "mp", "pc"], "self": ["node", "all", "case", "ws", "user", "qa", "proxy", "event", "h", "parent", "default", "us", "os", "output", "z", "tmp", "part", "w", "this", "plus", "page", "er", "cs", "worker", "old", "home", "gen", "Self", "full", "resp", "app", "ko", "view", "m", "es", "req", "end", "form", "ng", "plugin", "object", "instance", "pos", "ctx", "n", "df", "results", "config", "spec", "d", "per", "f", "wx", "host", "github", "client", "e", "events", "wrapper", "fs", "a", "work", "cl", "j", "error", "now", "ff", "ref", "err", "new", "lf", "dev", "q", "l", "http", "other", "gh", "k", "co", "g", "context", "s", "b", "master", "sys"], "rows": ["tests", "forms", "all", "files", "ws", "reports", "index", "ips", "ins", "head", "reads", "levels", "faces", "points", "items", "devices", "holes", "ks", "length", "orders", "heads", "char", "tracks", "ros", "cs", "cases", "rooms", "vals", "relations", "users", "es", "fields", "ries", "models", "views", "values", "frames", "keys", "rules", "OWS", "groups", "window", "headers", "ports", "pos", "rs", "results", "ls", "lines", "qs", "d", "ops", "ids", " row", "events", "checks", "posts", "blocks", "xs", " lines", "row", "rings", "pages", "rown", "features", "runs", "docs", "aults", "errors", "opens", "modules", "times", "flows", "roots", "ows", "types", "boxes", "s", "cells", "members", "days", "planes", " columns", "olds", "breaks"], "cols": ["cld", "coles", "pooli", "columnows", "columnsd", "colabs", "colles", "colln", "columnabs", " colS", "colds", "Colabs", " colcount", "cold", "Colts", "columnsi", "columnops", "columncount", "threadts", "ylp", "columns", "colgs", "Cold", "columnes", " colls", " cold", " coles", "columni", "collows", "ColS", " colw", "ylls", "columnS", "colb", "pooln", "columnw", "colS", "threads", "Colls", "Colp", "COLops", " colts", "colw", "clcs", " colds", "colsi", "yls", " colp", "COLgs", "colls", "yln", "COLn", " colops", "Colsd", "Coli", "dicti", " colsi", "dicts", "poolsi", "colows", "colsd", "columnts", "pools", " colabs", "Colb", "colts", "COLsd", " coln", "Colds", " colb", " coli", "COLts", "columnd", "colcount", "COLs", "COLabs", "Colows", "colli", "Coln", "Cols", "columnb", "colops", "columnds", " colows", "threadgs", "columnn", "dictn", "cles", "coln", " colgs", "Colw", "columncs", "collcount", "COLd", "colcs", "coli", " colcs", "colp"], "data": ["format", "steps", "response", "array", "image", "all", "div", "list", "index", "actions", "parent", "next", "missing", "default", "code", "scale", "items", "ata", "draw", "output", "devices", "buffer", "dd", "xxx", "multi", "body", "alpha", "arr", "table", "values", "form", "dict", "dat", "window", "column", "sample", "load", "pos", "reader", "memory", "result", "da", "json", "results", "Data", "li", "lines", "valid", "config", "d", "text", "f", "str", "di", "source", "post", "partial", "cell", "input", "DATA", "blocks", "a", "row", "content", "zip", "la", "group", "float", "raw", "batch", "api", "media", "bytes", "append", "cells", "model", "string", "block", "feed", "breaks"], "r": ["rb", "R", "ra", "col", "range", "rc", "entry", "q", "ar", "m", "d", "l", "f", "cr", "ru", "nr", "right", "e", "rec", "rr", "k", "z", "rar", "rh", "w", "j", "row", "b", "v", "sr", "s", "u", "lr", "n", "rs", "er"], "c": ["cu", "ci", "ch", "cc", "unc", "col", "cf", "lc", "nc", "dc", "m", "d", "arc", "h", "l", "f", "cr", "cp", "uc", "e", "code", "t", "rec", "ce", "fc", "ec", "k", "z", "cell", "cat", "ic", "cm", "xc", "co", "cl", "C", "s", "row", "v", "b", "u", "n", "int", "cs", "ct", "pc", "ac", "cy"], "i": ["it", "cu", "ui", "li", "id", "ci", "ix", "ch", "col", "lc", "index", "oi", "q", "ini", "d", "ai", "l", "f", "I", "ri", "ii", "e", "yi", "xi", "di", "pi", "z", "cell", "ic", "j", "mi", "s", "v", "b", "u", "ip", "qi", "n", "si", "io", "int", "iu"], "cls": ["CLs", "Cls", "CLabs", " clsb", "clabs", " clp", " Clp", "clp", "hellsb", " clsys", " Clsys", "Classsg", "clsys", "CLS", "Clsys", "Classsb", "wells", "wellsb", "Clabs", "CLsb", "Clusters", " clabs", "Clp", "Clsg", "ClS", "Clsb", "clusters", "clsg", "clsb", "clS", "CLsg", " clusters", "Classs", "hells", "wellusters", " Cls", "hellS"], "readfunc": ["readfun", "writefunc", "loadfun", "readfunction", "writeproc", "loadfunc", " readproc", "readproc", "writefunction", " readfunction", "loadproc", " readfun", "writefun", "loadfunction"], "_": ["all", "q", "un", "l", "f", "al", "k", "g", "non"], "line": ["band", "lf", "li", "lines", "lin", "col", "lc", "range", "len", "log", "entry", "file", "name", "Line", "header", "d", "text", "body", "base", "l", "record", "str", "end", "code", "no", "frame", "el", "cell", "LINE", "input", "inline", "limit", "column", "length", "buffer", "row", "model", "number", "reader", "char", "sync", "content", "string", "block", "page", "item", "section", "lo", "byte", "zip"]}}
{"code": " \\n  \\n  \\n  directions = list(itertools.product([1, 0, -1], [1, 0, -1]))\\n  def count_neighbors(table, r, c):\\n      cols = len(table[0])\\n      rows = len(table)\\n      return sum(table[r + x][c + y] == \"*\" for x, y in directions \\n                  if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\\n  \\n  def is_valid(table):\\n      cols = len(table[0])\\n      rows = len(table)\\n      for r in xrange(rows):\\n          for c in xrange(cols):\\n              has_zero = any(table[r + x][c + y] == 0 for x, y in directions \\n                              if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\\n              if table[r][c] != \"*\" and not has_zero:\\n                  return False\\n  \\n      return True\\n  \\n  \\n  def draw_table(table, hide=False):\\n      cols = len(table[0])\\n      rows = len(table)\\n      ascii_table = \"\"\\n      for r in xrange(rows):\\n          for c in xrange(cols):\\n              if table[r][c] != \"*\":\\n                  ch = \"c\" if r == 0 and c == 0 else \".\"\\n                  table[r][c] = count_neighbors(table, r, c) if not hide else ch\\n  \\n              ascii_table += str(table[r][c])\\n  \\n          ascii_table += \"\\n\"\\n  \\n      return ascii_table[:-1]\\n  \\n  def solve(R, C, M):\\n      r = c = 0\\n      current_mines = R * C\\n      table = [[\"*\"] * C for k in xrange(R)]\\n      while M < current_mines:\\n          if table[r][c] == '*':\\n              table[r][c] = \".\"\\n              current_mines -= 1\\n  \\n          if current_mines > M and r + 1 < R and table[r+1][c] == \"*\":\\n              table[r+1][c] = \".\"\\n              current_mines -= 1\\n  \\n          draw_table(table)\\n          c += 1\\n          if c >= C:\\n              c = 0\\n              r += 1\\n  \\n      return table\\n  \\n  for i in xrange(readint()):\\n      R, C, M = readintarray()\\n  \\n      print \"Case #%d:\" % (i + 1)\\n      if M < (R * C) - 1:\\n          table = solve(R, C, M)\\n          if is_valid(table):\\n              print draw_table(table, hide=True)\\n          else:\\n              table = solve(C, R, M)\\n              rotated = [[\"*\"] * C for k in xrange(R)]\\n              for r in xrange(R - 1, -1, -1):\\n                  for c in xrange(C):\\n                      rotated[R - r - 1][c] = table[c][r]\\n  \\n              print draw_table(rotated, hide=True) if is_valid(rotated) else \"Impossible\"\\n  \\n      elif M == R * C:\\n          print \"Impossible\"\\n  \\n      else:\\n          table = [[\"*\"] * C for k in xrange(R)]\\n          table[0][0] = '.'\\n          print draw_table(table, hide=True)\\n", "substitutes": {"directions": ["Direction", "Directors", "struction", "directionions", "Directations", "connectories", "directionors", "directionives", "irectives", "structors", "connections", "connection", "irectations", "directories", "Directories", "Directives", "connectors", "structations", "irectors", "directations", "directors", "directionion", "irections", "structions", "irection", "direction", "irectories", "directives", "Directions"], "table": ["element", "session", "array", "image", "query", "case", "div", "list", "tr", "range", "machine", "time", "stream", "feature", "container", "chart", "story", "code", "stable", "article", "key", "frame", "output", "buffer", "this", "panel", "page", "test", "style", "total", "slice", "conference", "comment", "stage", "db", "app", "view", "system", "python", "m", "body", "out", "character", "core", "data", "transform", "form", "module", "sequence", "window", "object", "root", "database", "tab", "result", "layer", "term", "py", "col", "month", "config", "file", "function", "flat", "f", "count", "message", "e", "t", "chain", "package", "MM", "cell", "input", "course", "row", "section", "error", "interface", "q", "channel", "header", "profile", "base", "tree", "TABLE", "connection", "rule", "choice", "batch", "cache", "figure", "round", "che", "cube", "Table", "bar", "b", "server", "model", "master", "block", "source"], "r": ["err", "p", "o", "rb", "br", "dr", "ra", "tr", "user", "range", "rc", "q", "ar", "m", "gr", "ro", "mr", "d", "kr", "h", "l", "f", "ru", "cr", "rd", "nr", "right", "fr", "e", "ir", "t", "Rs", "rec", "ur", "rr", "rh", "rt", "rg", "a", "w", "g", "j", "row", "sr", "b", "v", "re", "hr", "u", "pr", "lr", "n", "rs", "er", "vr", "yr"], "c": ["_", "cc", "lc", "arc", "h", "cr", "uc", "vc", "code", "z", "con", "cm", "w", "v", "u", "ca", "cs", "ac", "cy", "unc", "dc", "nc", "oc", "m", "rec", "fc", "xc", "n", "ct", "p", "cu", "ci", "col", "cn", "ar", "function", "d", "f", "count", "e", "t", "chain", "ce", "a", "cl", "course", "cd", "pc", "o", "cf", "rc", "sc", "q", "l", "cp", "cache", "ec", "cat", "co", "g", "s", "b", "mc"], "cols": ["colx", "colws", "icolws", "critlines", "methodws", "rollways", "pathcs", "lengthws", " colours", "llws", "colours", "colses", "calcs", "llsi", "columnsi", "contractws", "columnops", "contractcs", "rolls", "pathments", "critubs", "columns", "patherences", "poollines", "fils", "columnses", "llx", "rollss", " colss", " colways", "colss", "colways", "llcs", "paths", "icolses", "filx", "colerences", "colsi", "columnubs", "poolubs", "lls", "filops", "contracts", "methodses", "contractsi", "colments", "llses", " colerences", "llops", "pools", "columnlines", "calments", "poolments", "cals", "methods", " colses", "filses", "COLs", "columnsym", "colsym", "lengthsym", "lengths", " colsym", "colops", "crits", "rollours", "columnments", "icols", "critments", "COLses", "columncs", "calerences", "COLws", " colws", "columnws", "lengthses", "columnx", "colcs", "collines", "colubs", " colments", " colcs"], "rows": ["rown", "tests", "features", "rooms", "rog", "forms", "ws", "runs", "ow", "lines", "classes", "reports", "relations", "rc", "users", "errors", "wards", "acks", "ips", "opens", "ums", "fields", "times", "cr", "ids", "levels", "rew", "ries", "breaks", "items", "flows", "views", "events", "checks", "values", "roots", "ows", "frames", "posts", "olds", "rules", "OWS", "rh", "cats", "types", "holes", "blocks", "groups", "ks", "vers", "ubs", "length", "boxes", "row", "orders", "cells", "members", "heads", "planes", "rw", "roc", "tracks", "ros", "rs", "cs", "results", "cases", "pages"], "x": ["p", "o", "id", "ci", "ix", "py", "ax", "index", "wy", "com", "any", "m", "ye", "time", "d", "fx", "ay", "lex", "h", "ex", "X", "l", "f", "xt", "ya", "dy", "es", "wx", "e", "t", "xes", "px", "win", "xi", "z", "ic", "xs", "xc", "Y", "rx", "w", "a", "j", "ey", "work", "s", "b", "v", "xy", "ys", "my", "u", "on", "xml", "xx", "n", "int", "ct", "cross", "tx", "cy"], "y": ["p", "py", "ci", "sy", "col", "hy", "wy", "ye", "m", "ay", "d", "ny", "ya", "dy", "h", "vy", "f", "yt", "ies", "ym", "e", "ry", "t", "yi", "ky", "yd", "z", "Y", "yl", "w", "j", "ey", "yn", "s", "b", "iy", "ys", "zy", "ty", "n", "oy", "yy", "yr", "cy"], "has_zero": [" has_one", "has_money", " has_0", "have_one", "have_Zero", "have_zero", "has_alpha", "has_one", "have_money", "has_Zero", "has_0", " has_alpha"], "hide": ["child", "isi", "li", "show", "case", "id", "label", "ide", "late", "plot", "layout", "hid", "sea", "shadow", " hidden", "broad", "ignore", "cover", "que", "shown", "h", "ider", "secret", "shift", "fit", "code", "ha", "display", "sub", "mask", "ise", "info", "disable", "fe", " show", "bar", "hidden", "ib", "hi", "use", "bare", "fake", "loc", "ride", "Hide", "rub", "home"], "ascii_table": ["ascii_cache", "ascii_trace", "asciini_comb", "asciini_list", "asciui_body", "asciini_section", "ascii_Table", "asciini_term", "asciio_trace", "ascii_body", "ascii_list", "asciini_table", "ascii_term", "asciiettable", "asciietlist", "ascii_section", "asciio_table", "asciietcomb", "asciio_section", "ascii2section", "asciini_body", "asciui_table", "ascii2table", "asciui_cache", "ascii_comb", "asciui_Table", "ascii2trace"], "ch": ["chi", "qu", "div", "case", "ci", "cor", "channel", "chart", "h", "f", "cp", "cr", "character", "Ch", "chrom", "e", "code", "chain", "che", "chan", "conf", "cb", "cl", "j", "cd", "root", "sch", "CH", "char", "n", "cur"], "R": ["P", "O", "A", "CR", "Cr", "S", "B", "Ra", "MR", "RA", "T", "J", "L", "RR", "F", "X", "K", "I", "RP", "Rs", "E", "RH", "RO", "D", "G", "Rh", "U", "Y", "GR", "V", "H", "Q", "W", "N", "SR", "Re", "RM"], "C": ["CC", "Z", "P", "O", "A", "CR", "CW", "CF", "S", "B", "CI", "T", "DC", "L", "CM", "X", "F", "K", "I", "Ch", "CU", "E", "VC", "D", "G", "MC", "U", "Y", "H", "V", "Q", "W", "N"], "M": ["Z", "P", "O", "Ma", "MF", "S", "B", "T", "m", "J", "L", "CM", "F", "X", "I", "K", "E", " m", "MM", "D", "G", "MS", "MC", "U", "Y", "V", "H", "Q", "W", "N", "MW", "RM", "Mi"], "current_mines": ["current_mnizes", "current_mnes", "current_milles", "current_minES", "current_mnodes", "current_minsES", "current_masteres", "current_Mine", "current_minse", "current_maxe", "current_minsis", "current_minser", "current_manions", "current_minss", "current_MinES", "current_partions", "current_versionizes", "current_Miner", "current_mons", "current_minses", "current_partes", "current_Minions", "current_minodes", "current_partis", "current_masterodes", "current_manes", "current_minsors", "current_millions", "current_versions", "current_mnions", "current_masterizes", "current_monizes", "current_minsions", "current_mones", "current_versionions", "current_Mines", "current_miner", "current_maxizes", "current_mins", "current_minsodes", "current_versiones", "current_minsizes", "current_minizes", "current_minis", "current_miller", "current_millES", "current_maxes", "current_Minizes", "current_masterions", "current_mine", "current_manis", "current_minions", "current_maxions", "current_minors", "current_monions", "current_partors", "current_manors"], "k": ["cc", "cor", "q", "d", "ku", "get", "K", "cr", "ces", "ck", "ket", "ky", "ner", "ks", "co", "w", "g", "a", "king", "kk", "n", "km", "cs", "ct", "ke"]}}
{"code": " \\n  def readint():\\n      return int(sys.stdin.readline())\\n  \\n  def readintarray():\\n      return map(int, sys.stdin.readline().strip().split())\\n  \\n  def readpairs(start=0):\\n      elems = readintarray()[start:]\\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\\n  \\n  def readstring():\\n      return sys.stdin.readline()[:-1]\\n  \\n", "substitutes": {"start": ["p", "offset", "se", "id", "send", "range", "len", "index", "st", "stop", "x", "ind", "next", "add", "f", "count", "shift", "end", "e", "seed", "ie", "skip", "set", "k", "part", "size", "s", "v", "pos", "use", "n", "int", "Start", "source"], "elems": [" elecs", "Elemas", "elns", " elemes", "elemas", " elements", "elm", "elema", " elem", "lemns", "lemmes", "Elecs", "lemm", "elments", "elem", "elmas", "elements", " elema", "Elemes", "Elems", "lemcs", " elens", "elemes", "elmes", "elms", "elcs", "elma", "elecs", "lemments", "lemma", "elens", " elemas", "lemms"], "i": [" x", "p", "li", "id", "ci", "ix", "col", "index", "oi", " n", "ini", "ai", "x", "bi", "ind", "ri", "l", "f", "I", " j", " I", "ii", "c", "ti", "e", "xi", "pi", "di", "k", "z", "fi", " index", "a", "j", "mi", "v", "pos", "u", "qi", "n", "si", "int", "iu"]}}
{"code": " \\n  \\n  ncases = int(sys.stdin.readline().strip())\\n  \\n  def print_board(r, c, free):\\n      board = {}\\n      for row in range(0, r):\\n          board[row] = {}\\n          for col in range(0, c):\\n              board[row][col] = '*'\\n  \\n      pending = free\\n  \\n      if free == 1:\\n          board[0][0] = '.'\\n      elif r == 1 or c == 1:\\n          for row in range(0, r):\\n              for col in range(0, c):\\n                  if pending > 0:\\n                      pending -= 1\\n                      board[row][col] = '.'\\n      else:\\n          for row in range(0,2):\\n              for col in range(0,2):\\n                  board[row][col] = '.'\\n          pending -= 4\\n          col=2\\n          row=2\\n  \\n          while pending >= 2 and (col<c or row<r):\\n              if pending >= 2 and col<c:\\n                  board[0][col] = '.'\\n                  board[1][col] = '.'\\n                  col += 1\\n                  pending -= 2\\n              if pending >= 2 and row<r:\\n                  board[row][0] = '.'\\n                  board[row][1] = '.'\\n                  row += 1\\n                  pending -= 2\\n  \\n          for row in range(2, r):\\n              for col in range(2, c):\\n                  if pending > 0:\\n                      board[row][col] = '.'\\n                      pending -= 1\\n  \\n      board[0][0] = 'c'\\n  \\n      for row in range(0, r):\\n          line = ''\\n          for col in range(0, c):\\n              line += board[row][col]\\n          print(line)\\n  \\n  \\n  for t in range(1, ncases+1):\\n      values = sys.stdin.readline().strip().split()\\n      r = int(values[0])\\n      c = int(values[1])\\n      m = int(values[2])\\n  \\n      cells = r * c\\n      free = cells - m\\n  \\n      possible = False\\n  \\n      if r == 1 or c == 1:\\n          if free >= 1:\\n              possible = True\\n      elif r == 2 or c == 2:\\n          if free == 1 or (free >= 4 and free%2 == 0):\\n              possible = True\\n      else:\\n          if free == 1 or (free >= 4 and free != 5 and free != 7):\\n              possible = True\\n  \\n      print(\"Case #{0}:\".format(t))\\n  \\n      if possible:\\n          print_board(r, c, free)\\n      else:\\n          print(\"Impossible\")\\n", "substitutes": {"ncases": ["curses", "case", "cased", "necase", "lcasing", "ncased", "ncasts", "ncase", "nsases", "ncurses", "lcase", "lcases", "necased", "necasts", "ncasing", "lcurses", "necases", "nsase", "lcasts", "casing", "nsasing", "lcased", "casts", "nsurses", "cases"], "r": ["err", "p", "o", "rb", "R", "br", "ch", "ra", "tr", "range", "rc", "q", "ar", "order", "ro", "d", "kr", "x", "rf", "h", "l", "f", "cr", "ru", "rd", "right", "fr", "nr", "e", "ir", "ur", "i", "rr", "nor", "k", "z", "rt", "rar", "rg", "rn", "w", "g", "j", "b", "sr", "v", "s", "re", "u", "pr", "n", "rs", "er", "yr"], "c": ["cu", "p", "o", "R", "ci", "ch", "cc", "cor", "cf", "lc", "nc", "dc", "rc", "sc", "q", "d", "x", "h", "l", "y", "f", "cr", "ru", "cp", "e", "rec", "i", "ce", "fc", "ec", "k", "cell", "z", "con", "cm", "a", "co", "w", "C", "bc", "b", "v", "s", "u", "ca", "n", "cs", "ct", "cur", "pc", "ac", "cy"], "free": ["all", "unit", "outer", "range", "un", "usable", "covered", "stable", "FREE", "no", "used", "floor", "cle", "con", "fun", "mi", "min", "const", "common", "Free", "total", "version", "func", "required", "random", "out", "rec", "sec", "n", "fre", "open", "valid", "len", "function", "rf", "F", "f", "fee", "fr", "e", "size", "non", "left", "low", "use", "lower", "error", "err", "off", "sp", "cf", "current", "release", "float", "raw", "found", "util", "rule", "available", "cache", "empty", "price", "fe", "co", "static", "lease", "re", "complete", "vol", "N"], "board": ["stroke", "lay", "node", "array", "list", "layout", "ode", "stream", "player", "boards", "room", "code", "ward", "draw", "control", "ban", "buffer", "length", "bug", "clean", "home", "comment", "ko", "view", "menu", "card", "lock", "bridge", "core", "data", "ack", "table", "back", "form", "hole", "plugin", "sequence", "Board", "object", "flow", "pool", "ide", "config", "boarding", "que", "builder", "flo", "client", "bo", "book", "cell", "cart", "phone", "work", "course", "sync", "error", "word", "coll", "square", " clipboard", "group", "deck", "rank", "channel", "loop", "point", "rule", "game", "che", "server", "model", "design", "boy", "land", "bank", "block", "feed", " dashboard", "lane"], "row": ["node", "query", "ch", "tr", "user", "range", "index", "entry", "name", "order", "container", "h", "y", "cr", "uc", "day", "scale", "ward", "key", "draw", "wheel", "year", "rh", "nt", "device", "w", "length", "Row", "u", "page", "sel", "offset", "ko", "view", "oc", "system", "ro", "right", "core", "ack", "table", "form", "roll", "module", "arrow", "column", "object", "flow", "mo", "ver", "ow", "month", "max", "record", "port", "rot", "post", "cell", "sync", "loc", "rw", "error", "word", "coll", "mod", "rown", "o", "ear", "group", "rank", "hour", "run", "rc", "sc", "q", "channel", "x", "raw", "keep", "ry", "ull", "rr", "rows", "rect", "round", "value", "co", "bar", "re", "server", "model", "block", "feed", "roc", "micro", "ou", "cur"], "col": ["ch", "lc", "path", "name", "ll", "arc", "y", "day", "vc", "ell", "key", "year", "color", "nt", "con", "cm", "w", "length", "min", "char", "page", "ca", "io", "sel", "ac", "cy", "cal", "cor", "ro", "fn", "core", "win", "fc", "can", "column", "act", "n", "int", "ct", "pixel", "il", "p", "collection", "Col", "ci", "ow", "seq", "cn", "file", "car", "f", "count", "flo", "chain", "temp", "fl", "num", "el", "rot", "rel", "cell", "cl", "j", "left", "COL", "loc", "word", "coll", "enc", "ref", "child", "q", "ail", "channel", "x", "point", "l", "cp", "cond", "sect", "cat", "cycle", "co", "g", "field", "block", "oy", "patch", "ou"], "pending": ["opaging", " paging", "pushed", "opaying", " pended", "lpaging", "npended", "lpended", " pushed", " pend", "jpaying", "opending", "Pend", "opoding", "Poding", "ppaging", "ppending", "pended", "apushed", "lpending", " padding", " poding", "npanging", "cpadding", "jpend", "lpushed", "spending", " paying", "apaging", "ppended", "fending", "paging", "paying", "spaging", "opended", "Padding", "cpended", "poding", "spanging", "fadding", "fended", "spend", "opadding", "Pended", "opend", "cpending", "cpend", "npoding", "foding", "panging", "spended", "npending", "jpushed", "Pending", "jpending", "npadding", "npend", "Paging", "apended", "jpoding", "opushed", "Panging", "Pushed", "spadding", "jpended", "pend", "apending", "lpend", "spoding", "padding", "ppend"], "line": ["lf", "li", "comment", "long", "link", "lines", "lin", "pe", "range", "log", "entry", "file", "name", "text", "write", "base", "point", "l", "message", "str", "code", "frame", "el", "cell", "LINE", "cle", "value", "inline", "cl", "object", "strip", "content", "string", "block", "page", "letter", "feed", "section", "le", "item", "source", "definition", "zip"], "t": ["it", "tr", "T", "time", "d", "y", "l", "f", "times", "ti", "lo", "e", "table", "cut", "task", "i", "te", "nt", "type", "cat", "co", "toc", "got", "n", "tab", "ct", "tile"], "values": ["Values", "tests", "maps", "images", "forms", "files", "vals", "vs", "docs", "lines", "ves", "pins", "details", "codes", "strings", "es", "results", "fields", "boards", "vi", "names", "pages", "players", "fine", "items", "flows", "views", "events", "roots", "frames", "objects", "rows", "keys", "bytes", "rules", "bs", "verts", "dates", "value", "blocks", "gets", "xs", "settings", "places", " lines", "comments", "members", "ms", "ports", "changes", "days", "grades", "seconds", "lists"], "m": ["p", "o", "mn", "mm", "range", "fm", "nm", "q", "d", "y", "l", "f", "e", "num", "i", "M", "z", "cell", "con", "cm", "co", "w", "mi", "b", "v", "margin", "s", "ms", "u", "n", "mc", "mass"], "cells": ["p", "features", "files", "runs", "lines", "classes", "states", "mins", "ns", "l", "fields", "f", "y", "levels", "ells", "faces", "breaks", "items", "flows", "models", "units", "frames", "rows", "keys", "bytes", "rules", "cell", "cats", "blocks", "ks", "cm", "groups", "fe", "s", "b", "v", "members", "ms", "planes", "n", "cs", "mc", "pages"], "possible": ["pausible", "sporsche", "Pausible", "Porsche", " porsche", "cossibility", " pable", "picted", "spossible", "spossibility", "xpossible", "cossible", "causible", "xpossibility", "pable", " possibly", " pausible", "Possibility", "Possibly", "xpable", " possibility", "cossibly", "Possible", " picted", "spossibly", "possibly", "Picted", "possibility", "xpicted", "porsche", "Pable"]}}
{"code": " \\n  \\n  ncases = int(sys.stdin.readline().strip())\\n  \\n  def read_arrangement():\\n      arr = []\\n      for row in range(0,4):\\n          arr.append(sys.stdin.readline().strip().split(' '))\\n      return arr\\n  \\n  for t in range(1, ncases+1):\\n      answer1 = int(sys.stdin.readline().strip())\\n      arrang1 = read_arrangement()\\n      answer2 = int(sys.stdin.readline().strip())\\n      arrang2 = read_arrangement()\\n  \\n      row1 = arrang1[answer1-1]\\n      row2 = arrang2[answer2-1]\\n  \\n      intersect = set(row1) & set(row2)\\n  \\n      if len(intersect) == 1:\\n          print(\"Case #{0}: {1}\".format(t, intersect.pop()))\\n      elif len(intersect) == 0:\\n          print(\"Case #{0}: Volunteer cheated!\".format(t))\\n      else:\\n          print(\"Case #{0}: Bad magician!\".format(t))\\n", "substitutes": {"ncases": ["nsannels", "aucones", "aucased", "aucodes", "NCasing", "ncodes", "ncased", "necances", "nsases", "aucases", "necones", "necased", "necasing", "ncones", "NCased", "ncasing", "NCases", "NCannels", "necodes", "necases", "nsances", "ncances", "nsasing", "NCones", "NCodes", "necannels", "NCances", "ncannels"], "arr": ["err", "img", "p", "air", "align", "acc", "br", "array", "Array", "coll", "res", "all", "list", "seq", "app", "av", "ar", "gr", "au", "ext", "arc", "x", "l", "stack", "ann", "fr", "data", "adj", "str", "adr", "att", "aj", "abc", "i", "dict", "obj", "r", "cat", "dat", "a", "par", "ab", "g", "ray", "append", "attr", "bl", "mat", "n", "test", "Ar", "train", "enc", "aa", "rep"], "row": ["array", "ow", "user", "col", "seq", "order", "time", "ay", "d", "x", "f", "insert", "e", "num", "rows", "obj", "r", "w", "v", "line", "u", "week"], "t": ["p", "it", "o", "tests", " T", "tim", "tr", "at", "st", "dt", "ts", "T", "q", "time", "name", "d", "m", "x", "y", "l", "f", "tz", "c", "e", "task", "ait", "num", "i", "tt", "te", "tower", "ta", "tf", "the", "nt", "r", "type", "w", "g", "ab", "kt", "s", "b", "v", "title", "ty", "tm", "n", "test"], "answer1": ["response1", "issueone", "answerone", "response2", "reply2", " answerone", "reply91", "issue2", "row91", "issue1", " answer91", "responseone", "reply1", "answer91"], "arrang1": ["arrongFirst", "arrangeOne", "arongOne", "arrong3", "arongFirst", "arrannFirst", "arrbang3", "arrange0", "arang3", "arang2", "arrbang1", "arrann1", "arong0", "arrangFirst", "arong1", "arrann3", "arrannOne", "arrang0", "arrange2", "arrong2", "arrang3", "arangOne", "arrange1", "arrongOne", "arranging0", "arranging1", "arang1", "arong3", "arong2", "arrbangFirst", "arrbangOne", "arrangOne", "arrangingOne", "arrong0", "arangFirst", "arang0", "arranging2", "arrong1"], "answer2": ["response02", "response1", "array2", "answer102", "responseTwo", "response2", "result02", "result1", "reply2", "issue102", "array102", "answerTwo", "reply102", "answer02", "issue2", " answer02", "result2", "reply02", "array02", "issue02", "resultTwo", " answerTwo"], "arrang2": ["arrong3", "arrag1", "arrangtwo", "arang3", "arrlang3", "arrng1", "arang2", "arangtwo", "arongTwo", "arrng0", "arranchTwo", "arrong1", "arrng3", "arong0", "arong1", "arrang0", "arrong2", "arrag2", "arrang3", "arranch1", "arragtwo", "arranch2", "arrlang1", "arrlang2", "arang1", "arrongTwo", "arong2", "arong3", "arangTwo", "arrongtwo", "arongtwo", "arrong0", "arrng2", "arang0", "arrlang0", "arragTwo", "arranchtwo", "arrangTwo"], "row1": ["row3", "row0", "rows3", "ro1", "feed1", "feed0", "feed3", "row5", "rows5", "rows1", "ro5", "rows2", "rows0", " row5", " row3", "ro2", "ro3", "feed2", " row0"], "row2": ["col2", "arraytwo", "array2", "Rowtwo", " rowb", "Row42", "rows02", "arrayb", "Rowb", "array42", "row02", "col1", "rows1", "row4", "col4", "rows2", "rowb", " row42", "rows4", "row42", "col02", " row4", " row02", " rowtwo", "Row2", "rowtwo"], "intersect": ["corsection", "Interrupt", "INTERect", "surect", "versection", "conect", "consections", "interect", "consection", "surcept", "corsect", "earsect", "INTERsection", "consect", "earrupt", "intersections", "versect", "partcept", "intercept", "partsect", "earcept", "Intersections", "partsection", "partect", "intersection", "verect", "corect", "concept", "interrupt", "earsection", "Intersection", "Intercept", "sursection", "corsections", "vercept", "Intersect", "Interect", "sursect", "INTERsect", "INTERcept", "conrupt"]}}
{"code": " \\n  def read_word(f):\\n      return next(f).strip()\\n  \\n  def read_int(f, b=10):\\n      return int(read_word(f), b)\\n  \\n  def read_letters(f):\\n      return list(read_word(f))\\n  \\n  def read_digits(f, b=10):\\n      return [int(x, b) for x in read_letters(f)]\\n  \\n  def read_words(f, d=' '):\\n      return read_word(f).split(d)\\n  \\n  def read_ints(f, b=10, d=' '):\\n      return [int(x, b) for x in read_words(f, d)]\\n  \\n  def read_floats(f, d=' '):\\n      return [float(x) for x in read_words(f, d)]\\n  \\n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\\n      return [reader(f, *args, **kwargs) for i in range(R)]\\n  \\n  def solve(solver, fn, out_fn=None):\\n      in_fn = fn + '.in'\\n      if out_fn is None:\\n          out_fn = fn + '.out'\\n      with open(in_fn, 'r') as fi:\\n          with open(out_fn, 'w') as fo:\\n              T = read_int(fi)\\n              for i in range(T):\\n                  case = read_case(fi)\\n                  res = solver(case)\\n                  write_case(fo, i, res)\\n  \\n  \\n  def read_case(f):\\n      return read_ints(f)\\n  \\n  def write_case(f, i, res):\\n      f.write('Case #%d: '%i)\\n      if isinstance(res, list):\\n          res[0][0] = 'c'\\n          res = '\\n'.join(''.join(c for c in r) for r in res)\\n      f.write('\\n%s'%res)\\n      f.write('\\n')\\n  \\n  \\n  def solve_small(case):\\n      (R, C, M) = case\\n      if R == 1:\\n          return 'c' + '.'*(C-M-1) + '*'*M\\n      if C == 1:\\n          return '\\n'.join(['c'] + ['.']*(R-M-1) + ['*']*M)\\n      m = R*C - M\\n      res = [['*']*C for r in range(R)]\\n      if m == 1:\\n          return res\\n      for r in range(2, R+1):\\n          c = m // r\\n          z = m % r\\n          if c < 2 or c + (z>0) > C:\\n              continue\\n          if z == 1 and (r < 3 or c < 3):\\n              continue\\n          for x in range(r):\\n              for y in range(c):\\n                  res[x][y] = '.'\\n          for y in range(z):\\n              res[y][c] = '.'\\n          if z == 1:\\n              res[z][c] = '.'\\n              res[r-1][c-1] = '*'\\n          return res\\n      return 'Impossible'\\n  \\n  def solve_large(case):\\n      return solve_small(case)\\n  \\n  DEBUG = 'f'\\n  \\n", "substitutes": {"f": ["p", "fp", "lf", "files", "cf", "of", "xf", "fed", "fm", "file", "func", "function", "fx", "rf", "h", "F", "l", "fo", "fr", "fd", "fit", "e", "fb", "t", "fa", "form", "frame", "fw", "fc", "info", "self", "tf", "buff", "bf", "fe", "conf", "fi", "fs", "a", "w", "g", "j", "fun", "s", "v", "this", "ft", "uf", "u", "fold", "sf", "feed", "fen", "inf", "df", "ff", "af"], "b": ["p", "o", "be", "rb", "B", "db", "sb", "lb", "nb", "bi", "body", "base", "h", "l", "dy", "e", "t", "end", "bs", "k", "bb", "bf", "a", "w", "g", "j", "ab", "length", "wb", "s", "v", "u", "n"], "x": ["p", "_", "bit", "id", "ix", "ax", "valid", "xxx", "xf", "index", "q", "fx", "h", "ex", "X", "l", "xa", "wx", "max", "get", "e", "t", "num", "xi", "xe", "k", "input", "xs", "xc", "rx", "w", "g", "j", "xy", "s", "v", "xp", "u", "xxxx", "xx", "n", "xb", "int", "word"], "d": ["split", "p", "o", "dx", "id", "sd", "dc", "ld", "db", "dt", "name", "dy", "h", "l", "data", "fd", "e", "end", "t", "dir", "do", "md", "di", "D", "k", "dat", "ad", "a", "w", "g", "dl", "j", "cd", "nd", "v", "dd", "dim", "u", "n", "da", "ds"], "R": ["P", "O", "A", "CR", "S", "JR", "B", "range", "RA", "AR", "J", "L", "RR", "RE", "CL", "F", "X", "RN", "I", "K", "RP", "Rs", "E", "RH", "DR", "RO", "TR", "D", "G", "rh", "U", "Y", "GR", "RS", "V", "H", "RL", "RG", "Q", "W", "N", "RF", "SR", "Res", "RM", "Re", "RC", "Range"], "reader": ["iter", "reading", "rb", "array", "lc", "read", "rc", "entry", "writer", "loader", "builder", "ctor", "parser", "inner", "argument", "callback", "rr", "wrapper", "ner", "handler", "library", "input", "Reader", "value", "driver", "w", "length", "runner", "row", "instance", "finder", "upper", "rw", "feed", "io", "ride", "er", "transfer", "slice", "method"], "i": ["p", "it", "iq", "chi", "li", "id", "ci", "ix", "index", "q", "ini", "ai", "phi", "bi", "ind", "l", "I", "gi", "ri", "ii", "ti", "e", "t", "zi", "uri", "di", "xi", "pi", "k", "ni", "fi", "a", "im", "j", "s", "v", "mi", "ip", "u", "qi", "n", "io", "int", "si", "iu"], "solver": ["Solving", "insoper", "ssolver", "soper", "ssolving", "solving", "seolving", " solve", "Solve", "solves", "ssolve", " solving", "Solves", "seolve", "Soper", "ssolves", "insolving", "seolves", "seolver", "insolve", "insolver", " soper", "Solver", "solve"], "fn": ["format", "p", "o", "orn", "fp", "node", "kn", "sn", "wt", "feat", "path", "nc", "cn", "name", "file", "nm", "function", "syn", "write", "out", "h", "native", "fa", "fd", "typ", "fb", "lib", "ln", "fl", "fc", "output", "fat", "fi", "FN", "fun", "v", "loc", "n", "io", "fen", "dn", "enc", "filename"], "out_fn": ["outPfn", "in_file", "out_path", "outqbin", "out_file", "outFilefp", "outFilepath", "in_filename", "flat_fp", "outingfn", "outPfp", "out2file", "outqfn", "outPfunc", "outFilefun", "flatingfc", "out_fun", "outingfp", "extraPn", "extraPfp", "out_filename", "outqfc", "outPn", "extra_func", "out2fd", "outqfp", "flat_bin", "outingfc", "extraPfunc", "out_bin", "outingbin", "out2filename", "flatingfn", "outFilefn", "extraPfn", "extra_n", "extra_fp", "in_fd", "out_func", "flat_fn", "out_fp", "output_fun", "flatingbin", "flat_fc", "out2fn", "output_fn", "out_fd", "output_fp", "output_path", "out_n", "extra_fn", "out_fc", "flatingfp"], "in_fn": ["in_fp", "inwfilename", "bin_fp", "in_mn", "bin_mn", "bin_fn", "inwfn", "in_filename", "in_fil", "in_folder", "out_folder", "inwmn", "out_fil", "out_fp", "bin_filename", "inwfp"], "T": ["Z", "p", "P", "O", "A", "S", "B", "TA", "CI", "J", "L", "F", "X", "I", "t", "TS", "E", "G", "D", "U", "Y", "V", "H", "Q", "W", "N", "NT"], "case": ["p", "switch", "force", "rice", "ch", "pe", "config", "catch", "pair", "rest", "sc", "ice", "time", "function", "profile", "base", "X", "fo", "cp", "default", "fa", "ace", "uc", "e", "end", "code", "key", "cache", "ce", "ise", "trial", "info", "cer", "shape", "type", "match", "fi", "fact", "cl", "Case", "instance", "use", " CASE", "ase", "loc", "call", "cas", "string", "ride", "test", "result", "section", "slice", "cases", "change"], "res": ["response", "ch", "rest", "details", "gr", "resolution", "ex", "RES", "Rs", "os", "rh", "match", "reg", "RS", "ms", "Res", "ros", "cs", "ras", "cases", "esc", "resp", "ches", "ro", "out", "es", "arr", "core", "data", "req", "right", "rec", "rev", "rez", "exc", "fi", "rx", "Case", "rap", "remote", "resource", "rs", "result", "results", "p", "rice", "spec", "su", "mr", "fr", "e", "ret", "Result", "error", "err", "ris", "val", "catch", "rc", "ns", "vre", "ri", "ces", "pres", "rem", "ps", "re", "s", " Res"], "c": ["p", "cu", "ci", "ch", "cc", "unc", "cf", "dc", "lc", "cn", "rc", "sc", "h", "l", "cp", "uc", "e", "t", "rec", "k", "anc", "con", "xc", "a", "w", "co", "cd", "v", "n", "cs", "ct", "ac"], "r": ["err", "p", "br", "rb", "all", "range", "rc", "gr", "ro", "h", "ri", "l", "ru", "rl", "cr", "str", "e", "ir", "ur", "rh", "co", "w", "re", "v", "u", "pr", "rm", "n", "rs", "result"], "C": ["CC", "P", "O", "A", "Cr", "SC", "CW", "CS", "S", "B", "CI", "DC", "L", "CL", "F", "X", "I", "K", "Ch", "CU", "E", "CN", "CO", "VC", "D", "G", "NC", "MC", "U", "Y", "CA", "Cl", "V", "H", "Cu", "Q", "W", "N"], "M": ["CC", "MQ", "Z", "P", "O", "LM", "A", "MF", "S", "MN", "B", "J", "L", "CM", "F", "X", "I", "E", "MM", "D", "G", "MI", "MC", "MD", "U", "Y", "V", "H", "Q", "W", "N", "MX", "RM"]}}
{"code": " \\n  def read_word(f):\\n      return next(f).strip()\\n  \\n  def read_int(f, b=10):\\n      return int(read_word(f), b)\\n  \\n  def read_letters(f):\\n      return list(read_word(f))\\n  \\n  def read_digits(f, b=10):\\n      return [int(x, b) for x in read_letters(f)]\\n  \\n  def read_words(f, d=' '):\\n      return read_word(f).split(d)\\n  \\n  def read_ints(f, b=10, d=' '):\\n      return [int(x, b) for x in read_words(f, d)]\\n  \\n  def read_floats(f, d=' '):\\n      return [float(x) for x in read_words(f, d)]\\n  \\n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\\n      return [reader(f, *args, **kwargs) for i in range(R)]\\n  \\n  def solve(solver, fn, out_fn=None):\\n      in_fn = fn + '.in'\\n      if out_fn is None:\\n          out_fn = fn + '.out'\\n      with open(in_fn, 'r') as fi:\\n          with open(out_fn, 'w') as fo:\\n              T = read_int(fi)\\n              for i in range(T):\\n                  case = read_case(fi)\\n                  res = solver(case)\\n                  write_case(fo, i, res)\\n  \\n  \\n  def read_case(f):\\n      R1 = read_int(f)\\n      Q1 = read_arr(f, 4)\\n      R2 = read_int(f)\\n      Q2 = read_arr(f, 4)\\n      return (R1, Q1, R2, Q2)\\n  \\n  def write_case(f, i, res):\\n      f.write('Case #%d: '%i)\\n      f.write('%s'%res)\\n      f.write('\\n')\\n  \\n  \\n  def solve_small(case):\\n      (R1, Q1, R2, Q2) = case\\n      s = set(Q1[R1-1]) & set(Q2[R2-1])\\n      if len(s) == 0:\\n          return 'Volunteer cheated!'\\n      if len(s) == 1:\\n          return s.pop()\\n      return 'Bad magician!'\\n  \\n  def solve_large(case):\\n      return solve_small(case)\\n  \\n  DEBUG = 'i'\\n  \\n", "substitutes": {"f": ["p", "fp", "lf", "files", "full", "fac", "cf", "of", "xf", "fed", "fm", "file", "func", "m", "tif", "function", "fx", "rf", "h", "F", "l", "fo", "c", "fr", "fd", "fit", "e", "fb", "t", "fa", "fore", "form", "frame", "fw", "fc", "info", "tf", "buff", "r", "fam", "bf", "fe", "conf", "fi", "fs", "w", "g", "j", "fun", "die", "v", "this", "ft", "uf", "u", "fff", "fold", "sf", "feed", "fen", "inf", "df", "fish", "ff", "af"], "b": ["p", "o", "be", "rb", "B", "db", "sb", "lb", "m", "nb", "bi", "body", "base", "h", "l", "y", "dy", "c", "e", "t", "fb", "bs", "k", "z", "r", "bb", "bf", "a", "w", "g", "j", "ab", "length", "bc", "wb", "ib", "v", "u", "n"], "x": ["p", "_", "bit", "id", "ix", "ax", "xxx", "xf", "index", "q", "m", "fx", "h", "ex", "y", "X", "l", "xa", "xxxxxxxx", "wx", "get", "c", "e", "t", "num", "xi", "xe", "self", "k", "z", "r", "input", "xs", "xc", "rx", "w", "g", "co", "j", "xy", "v", "xp", "u", "xx", "n", "xb", "int", "word"], "d": ["split", "p", "o", "dx", "id", "dc", "ld", "db", "dt", "name", "m", "dy", "h", "l", "y", "c", "fd", "data", "e", "t", "end", "dir", "dm", "do", "di", "D", "ud", "z", "k", "r", "dat", "ad", "w", "g", "dl", "j", "cd", "nd", "v", "dd", "dh", "diff", "dim", "u", "n", "da", "ds"], "R": ["P", "O", "A", "rb", "CR", "runs", "S", "B", "RA", "J", "L", "RR", "F", "X", "RN", "I", "Rs", "NR", "RO", "D", "M", "G", "r", "U", "Y", "V", "C", "H", "RG", "Q", "W", "N", "RF", "SR", "RM"], "reader": ["iter", "format", "reading", "rb", "word", "array", "dr", "lc", "read", "rc", "spec", "entry", "writer", "function", "loader", "RW", "parser", "inner", "argument", "rr", "wrapper", "handler", "input", "Reader", "r", "value", "rx", "w", "driver", "length", "runner", "buffer", "row", "finder", "rw", "feed", "io", "ride", "er", "df", "transfer", "slice", "source", "method"], "i": ["p", "it", "ui", "li", "chi", "id", "ci", "ix", "col", "ei", "index", "q", "m", "ini", "ai", "phi", "bi", "ind", "ri", "y", "gi", "I", "l", "ii", "c", "ti", "e", "t", "zi", "uri", "xi", "di", "pi", "k", "z", "r", "type", "ic", "ni", "fi", "a", "im", "j", "mi", "v", "ip", "u", "qi", "n", "io", "int", "si", "iu"], "solver": ["Solving", "Safer", "safer", "ssolver", "ssolving", "saver", " saver", "seolving", "solving", " solve", "Solve", "ssolve", " solving", "ssaver", "seolve", " safer", "seolver", "Saver", "seafer", "Solver", "solve"], "fn": ["format", "p", "o", "fp", "node", "kn", "sn", "wt", "feat", "path", "nc", "document", "cn", "name", "file", "nm", "function", "syn", "rf", "out", "h", "native", "c", "fa", "fd", "fb", "ln", "fl", "fc", "output", "fat", "bf", "fi", "FN", "fun", "v", "n", "io", "fen", "filename"], "out_fn": ["outlogfn", "in_fp", "output_fn", "bin_cf", "in_file", "outUfolder", "bin_fp", "in_n", "in_function", "out_file", "output_fp", "bin_fc", "outUfile", "bin_fn", "outlogcf", "outingfc", "outlogfc", "in_filename", "outUfp", "out_n", "outingfp", "outlogfp", "biningcf", "out_fc", "outingfn", "biningfn", "out_folder", "biningfc", "out_filename", "biningfp", "outingcf", "out_fp", "output_folder", "outUfn", "out_cf", "output_file", "out_function"], "in_fn": ["in_fp", "out_fd", " in_sn", " in_fp", " in_path", "in_dn", "in_fd", "in_sn", "out_fp", "in_path", "out_dn"], "T": ["Z", "P", "O", "A", "S", "B", "Type", "TA", "CI", "L", "F", "X", "I", "t", "TS", "E", "CT", "D", "M", "G", "type", "U", "Y", "C", "V", "H", "Q", "W", "N", "NT"], "case": ["p", "_", "P", "switch", "force", "rice", "lic", "ch", "id", "pe", "config", "catch", "pair", "sea", "sc", "q", "ice", "time", "profile", "base", "X", "default", "c", "core", "ace", "fa", "e", "code", "key", "cache", "sub", "ce", "ise", "trial", "info", "shape", "type", "r", "match", "conf", "exc", "fi", "co", "fact", "C", "Case", "instance", "ase", "string", "cas", "feed", "ride", "test", "result", "section", "slice", "cases"], "res": ["err", "ris", "me", "response", "rice", "ch", "val", "resp", "catch", "range", "rest", "spec", "rc", "details", "su", "mr", "resolution", "out", "req", "RES", "pres", "rev", "ret", "rem", "ress", "us", "os", "ce", "ise", "rh", "r", "match", "exc", "reg", "fi", "co", "Result", "re", "Case", "sr", "ms", "rap", "Res", "resource", " Res", "rs", "result", "error", "results"], "R1": ["X2", "r4", "RunONE", " R81", "I2", "QONE", "P01", "Run001", "P1", "RONE", "X1", "r81", "Run1", "ROne", "X4", " R001", "Q001", " RONE", "R001", "X81", " ROne", "RR1", "Q01", "Q4", "r2", "R01", "RR2", "QOne", "RR0", "I1", "r1", "Q0", "Q81", "POne", "R0", "I0", "P2", "Run81", " R01", "R81", "R4"], "Q1": ["QU10", "q2", "Qu3", " Q10", "Q3", " Q31", " QN", "X1", "P1", " Q6", "QUN", "RN", "Q6", "QU1", "P3", "R4", "R9", "Q4", "Q31", " Q3", "Query4", "Q10", "QN", "Query1", "QU2", "q4", "Qu6", "q1", " Q9", "R3", "Q9", "P9", "Qu31", "R10", "Query2", "P2", "X31", "X6", "Qu1", "X3"], "R2": ["r4", " R02", "RA2", "Rh2", " R4", "Q72", "Rsecond", "Rh02", " R0", " Rsecond", "Qsecond", "r14", "r0", "RA8", "Q02", "rB", "RA5", "RB", "Q4", "Rhsecond", "r2", "Rh72", "RA4", "r1", " RB", "Q0", "R8", "r8", "R5", " R5", "QB", "R02", "r5", "r02", "R0", "R14", " R14", " R8", "Q14", " R72", "R4", "R72"], "Q2": ["q2", "IQ_", "q12", " Qtwo", "Query22", "IQ02", "q22", " Q14", "Q12", "qtwo", "IQtwo", "Q02", "P1", "P4", "Q22", "Query62", " Q12", "Q_", "q_", "IQ2", " Q02", "R4", "Q4", "Q62", "q62", "Query1", "q4", "q1", "R5", "R22", " Q_", "Q5", "Qtwo", "R14", "P5", "q02", "Query2", "P2", "Q14", "q5", "q14", "R62", "R12"], "s": ["p", "session", "start", "ws", "S", "ss", "sb", "m", "ns", "h", "es", "l", "y", "strings", "c", "e", "t", "args", "gs", "ses", "sets", "ssl", "set", "sections", "r", "type", "services", "parts", "a", "g", "v", " S", "sync", "u", "string", "n", "sym", "cs", "slice", "cases"]}}
{"code": "__author__ = 'jrokicki'\\n  \\n  RL = lambda: sys.stdin.readline().strip()\\n  IA = lambda: map(int, RL().split(\" \"))\\n  LA = lambda: map(long, RL().split(\" \"))\\n  FA = lambda: map(float, RL().split(\" \"))\\n  \\n  T = int(sys.stdin.readline())\\n  \\n  def clear(R,C,b, x, y):\\n      b = b[:]\\n      n = 0\\n      for i in range(max(0,x-1), min(R,x+2)):\\n          for j in range(max(0,y-1), min(C, y+2)):\\n              if b[C*i+j] == '*':\\n                  n += 1\\n                  b = b[:C*i+j] + '.' + b[C*i+j+1:]\\n      return b, n\\n  mem = dict()\\n  def pb(R,C,b):\\n      for x in range(R):\\n          print b[x*C:x*C+C]\\n  \\n  def board(R,C,b,x,y,M,m):\\n      global mem\\n      print x\\n      key = (R,C,b,M,x,y,m)\\n      if key in mem: return mem[key]\\n      if x >= R or y >= C:\\n          mem[key] = None\\n      else:\\n          lb = b\\n          n = 0\\n          good = False\\n          for i in range(y,C):\\n              nb,nn = clear(R,C, lb, x, i)\\n              n += nn\\n              if m - n - M == 0:\\n                  mem[key] = nb\\n                  good = True\\n                  break\\n              elif m - n - M < 0:\\n                  break\\n              lb = bb\\n          mem[key] = board(R,C,bb,M,x+1,0,m-n)\\n      return mem[key]\\n  \\n  for CASE in range(T):\\n      R,C,M = IA()\\n      IMPOSSIBLE = \"Impossible\"\\n  \\n      b = \"\"\\n      cleared = R*C-M\\n      for x in range(R):\\n          b += \"*\" * C\\n      if M == R*C-1:\\n          b = \"c\" + b[1:]\\n          answer = b\\n      else:\\n          good = False\\n          x,y = 0,0\\n          q = [(b,0,0,0)]\\n          mem = {}\\n          while not good and q:\\n              board,total_cleared,x,y = q.pop(0)\\n              if (board,total_cleared,x,y) in mem:\\n                  continue\\n              mem[(board,total_cleared,x,y)] = True\\n              if x >= R: continue\\n              if y >= C:\\n                  q.append((last_board,total_cleared,x+1,0))\\n                  continue\\n              last_board = board\\n              new_board, cleared_mines = clear(R,C,last_board,x,y)\\n              total_cleared += cleared_mines\\n  \\n              if total_cleared == cleared:\\n                  good = True\\n                  last_board = new_board\\n                  q = []\\n                  break\\n              elif total_cleared - cleared == -1:\\n                  q.append((new_board,total_cleared,x,y+1))\\n                  q.append((new_board,total_cleared,x+1,0))\\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\\n              elif total_cleared > cleared:\\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\\n              else:\\n                  q.append((new_board,total_cleared,x,y+1))\\n              last_board = new_board\\n          if good:\\n              answer = last_board\\n          else:\\n              answer = None\\n      if not answer:\\n          answer = \"Impossible\"\\n      else:\\n          b = \"\"\\n          for x in range(R):\\n              b += answer[x*C:x*C+C] + \"\\n\"\\n          answer = \"c\" + b[1:-1]\\n      print \"Case #%d:\\n%s\" % (CASE+1, answer)\\n  \\n", "substitutes": {"__author__": ["__author___", "__title___", "__version__", "__version___", " __author___", "__title__", " __version__", " __version___", "__alias__", "__alias___"], "RL": ["VR", "SL", "CR", "rb", "WR", "OL", "TL", "LP", "ARR", "MR", "REL", "LT", "DL", "CL", "L", "RR", "Ul", "LR", "rl", "BR", "LD", "LL", "BL", "RB", "IR", "XL", "LU", "UL", "DR", "IO", "FL", "URL", "STR", "GR", "IL", "RS", "HL", "LS", "NL", "ML", "El", "SB", "HR", "SR", "LC", "RC", "EL", "QL", "VL"], "IA": ["AA", "A", "CR", "ci", "VI", "ia", "TA", "LI", "CI", "RA", "AR", "GA", "IB", "AI", "MA", "NI", "DA", "BB", "SA", "I", "IM", "area", "IE", "SI", "IR", "BI", "IP", "IO", "MI", "IG", "BBC", "Y", "CA", "IL", "a", "II", "AE", "BA", "Q", "ca", "NA", "HA"], "LA": ["LM", "la", "LB", "TA", "LP", "LI", "GA", "LT", "CL", "MA", "LR", "SA", "La", "LL", "SI", "LU", "Li", "LAN", "LO", "LIB", "LG", "CA", "IL", "LS", "Lu", "BA", "NA", "AU"], "FA": ["FFFF", "AA", "FE", "FI", "FF", "GA", "FG", "MA", "FB", "fa", "GF", "Fe", "VA", "FL", "PA", "FP", "AAA", "Fi", "FW", "CA", "PLA", "WA", "EA", "Fa", "HF", "FIN", "HA", "FD"], "T": ["Z", "P", "TT", "O", "S", "B", "J", "L", "TB", "TM", "F", "X", "I", "K", "t", "TS", "E", "TN", "TX", "D", "G", "U", "Y", "V", "H", "Q", "W", "N"], "R": ["RI", "P", "A", "CR", "WR", "KR", "S", "JR", "B", "Ra", "MR", "RA", "AR", "J", "L", "RR", "RE", "F", "X", "RN", "I", "BR", "K", "ER", "Rs", "E", "IR", "NR", "RH", "DR", "RO", "D", "G", "r", " r", "Rh", "U", "Y", "GR", "RS", "V", "H", "RT", "RG", "Q", "HR", "W", "SR", "N", "Re", "RC", "RM"], "C": ["CC", "Z", "P", "O", "A", "CR", "Cr", "SC", "IX", "CF", "CS", "S", "B", "Cs", "CI", "YC", "DC", "L", "CL", "Code", "CM", "X", "F", "I", "K", "AC", "Sc", "c", "Ch", "CU", "E", "CT", "CN", "VC", "Cy", "D", "G", "NC", "EC", "r", "MC", "U", "Y", "CA", "Ca", " c", "V", "H", "CP", "Co", "Cu", "Q", "KC", "W", "N", "CE", "Con"], "b": ["_", "all", "bu", "h", "ob", "bin", "bp", "E", "beta", "z", "w", "bool", "buffer", "bt", "v", "u", "xb", "emb", "rb", "id", "B", "sb", "db", "bi", "c", "fb", "D", "bf", "bc", "wb", "bl", "bd", "binary", "p", "bit", "be", "gb", "d", "mb", "X", "f", "message", "e", "t", "ba", "num", "bs", "bb", "abb", "a", "ab", "MB", "pb", "o", "eb", "base", "BB", "l", "k", "r", "ub", "cb", "g", "ib", "s"], "x": ["_", "ix", "ax", "index", "h", "xa", "ex", "code", "xi", "z", "ic", "w", "xy", "v", "min", "u", "on", "sex", "ed", "cy", "id", "width", "c", "mx", "win", "xc", "Y", "rx", "hi", "int", "p", "ci", "d", "max", "X", "f", "wx", "I", "e", "t", "num", "xe", "rex", "xs", "a", "im", "my", "xx", "one", "o", "dx", " xx", "ay", "xt", "l", "k", "r", " X", "g", "s", "tx", "change"], "y": ["p", "o", "py", "ch", "sy", "ay", "time", "d", "ny", "ya", "dy", "yo", "vy", "l", "h", "I", "c", "yt", "ry", "ym", "e", "t", "yi", "z", "k", "r", "type", "Y", "a", "w", "yl", "ey", "yn", "s", "v", "ys", "u", "ty", "oy", "sky", "yy", " Y", "yr", "cy"], "n": [" N", "p", "o", "nu", "all", "sn", "nc", "na", "init", "len", "cn", "name", "ns", "d", "ny", "np", "un", "out", "l", "f", "h", "en", "c", "e", "t", "no", "ln", "num", "nl", "k", "z", "nt", "r", "ni", "w", "g", "nd", "yn", "v", "min", "number", "u", "N", "ne", "net", "dn"], "i": ["p", "o", "ui", "li", "id", "ci", "ix", "ia", "index", "ji", "ini", "phi", "ai", "d", "bi", "ind", "l", "f", "I", "c", "ii", "e", "eni", "t", "yi", "ie", "xi", "pi", "di", "k", "z", "r", "ni", "Y", "g", "im", "hi", "mi", "v", "u", "ip", "qi", "io", "si", "int", "iu"], "j": ["p", "o", "li", "ix", "ch", "js", "jc", "jp", "ji", "d", "J", "h", "l", "f", "c", "ii", "e", "t", "jl", "aj", "ie", "k", "z", "jj", "r", "je", "ja", "w", "ij", "g", "xy", "v", "jo", "u", "si"], "mem": ["me", "Mem", "image", "all", "node", "range", "index", "struct", "am", "ram", "bm", "lib", " MEM", "ME", "um", "nt", "reg", "buffer", "mi", "de", "vm", "item", "BM", "gram", "pm", " memory", "comment", "lim", "comb", "member", "data", "ym", "map", "note", "em", "summary", "nd", "program", "bl", "memory", " Mem", "rm", "tm", "gl", "tab", "term", "mo", "mm", "gb", "function", "mb", "max", "imm", "temp", "num", "mini", "md", "info", "dem", "im", "loc", "mod", "ref", "val", "link", "hw", "nm", "asm", "access", "rem", "cache", "mor", "large", "value", "ib", "sum", "EM", "store", "mc"], "M": ["Z", "p", "P", "O", "A", "MF", "S", "MN", "B", "Ms", "J", "L", "CM", "F", "X", "I", "K", "c", "E", "ME", "D", "G", "MS", "r", "MC", "MD", "U", "cm", "Y", "V", "H", "MT", "v", "EM", "Q", "NM", "W", "N", "RM", "Mi", "BM"], "m": ["p", "o", "pm", "mn", "mm", "fm", "nm", "sm", "mr", "d", "h", "l", "f", "en", "c", "ym", "e", "bm", "t", "dm", "mini", "z", "r", "cm", "Y", "w", "g", "im", "mi", "v", "s", "min", "ms", "om", "u", "tm", "N", "mc"], "key": ["case", "index", "name", "order", "parent", "code", "no", "ee", "match", "arg", "Key", "char", "cy", "id", "cor", "msg", "KEY", "lock", "core", "c", "ace", "right", "rec", "keys", "note", "sec", "number", "fix", "int", "p", "ver", "label", "col", "f", "count", "kw", "e", "ck", "num", "info", "cell", "row", "sync", "short", "my", "use", "loc", "ne", "error", "ke", "ref", "switch", "val", "link", "base", "ry", "cache", "k", "go", "sign", "type", "value", "co", "field", "N", "block", "close", "source", "change"], "lb": ["pl", "pb", "rb", "la", "lf", "eb", "li", "LB", "ls", "lin", "B", "lc", "sb", "gb", "lbs", "ll", "L", "bi", "ml", "BB", "l", "rl", "lab", "lot", "lam", "fb", "bm", "lib", "ln", "abc", "nl", "BBC", "acl", "ub", "abl", "bb", "cm", "cb", "dl", "wb", "bc", "lp", "lu", "bl", "blog", "lr", "afe", "lt", "BM"], "good": ["err", "bad", "show", "comment", "valid", "Good", " bad", "kind", "broken", "same", "success", "next", " Good", "pretty", "stuff", "fine", "like", "better", " nice", "wrong", "job", "ready", " bug", "ok", "improve", "check", "hack", "best", "gy", "fun", " cool", "big", "nice", "slow", "little", "fix", "bugs", "yes", "bug", "clean", "error", "quick", "result", " GOOD", "done"], "nb": ["NB", "nu", "sn", "nc", "sb", "len", "cn", "ns", "dn", "ny", "np", "bi", "dy", "count", "nr", "adj", "bm", "fb", "ln", "num", "nl", "tmp", "nt", "bb", "ni", "bf", "cb", "abb", "ab", "wb", "bc", "nd", "bn", "number", "kb", "bd"], "nn": ["NB", "mn", "nu", "kn", "sn", "inn", "nc", "na", "len", "nv", "nm", "ns", "pn", "NN", "ny", "np", "dy", "nan", "fn", "ann", "ii", "nr", "byn", "ln", "wn", "nl", "nt", "nw", "bb", "ni", "nz", "abb", "nd", "bn", "ne", "dn", "gn"], "CASE": ["Rases", "CUASE", "CMASE", "RASS", "CASS", "RASE", "CUODY", "CODY", "CMases", "CUases", "CMASS", "RODY", "CUASS", "Cases", "CMODY"], "IMPOSSIBLE": ["IMPORTSBILITY", "IMPossible", "IMPORTSIBLE", "IMpOSSIVE", "IMpOSSIBLE", "IMpOSSible", "IMpossible", "IMPossIBLE", "IMpOSSBILITY", "IMPOSSible", "IMPOSSBILITY", "IMPORTSible", "IMpossBILITY", "IMPossBILITY", "IMPENSIBLE", "IMPENSible", "IMPOSSIVE", "IMPORTSIVE", "IMpossIVE", "IMPENSIVE", "IMpossIBLE", "IMPossIVE", "IMPENSBILITY"], "cleared": ["Cleanned", "cleed", "Cleared", "CLEared", "clearing", "CLEanned", "Cleed", "CLEed", "Clearing", " cleed", "CLEaring", "cleanned", " clearing", " cleanned"], "answer": ["err", "Answer", "comment", "eb", "gain", "gb", "aa", "rc", "ll", "BB", "blank", "f", "question", "fb", "ell", "abc", "back", "better", "rr", "z", "best", "abb", "ab", "short", "reply", "result", "ac"], "q": ["p", "bit", "iq", "qq", "query", "comment", "id", " question", "qa", "ll", "quit", "dq", "question", "like", "back", " quick", "k", "z", "buff", "check", "ad", "g", "nd", " questions", "short", "Q", "quick", "qt"], "board": ["lay", "forward", "comment", "deck", "loop", "channel", "player", "boards", "c", "uc", "ack", "play", "table", "bo", "ward", "book", "cache", "draw", "game", "hole", "pad", "post", "Board", "video", "hack", "bc", "buffer", "row", "flow", "design", "line", "program", "bank", "bug", "block", "error", "word"]}}
{"code": "__author__ = 'jrokicki'\\n  \\n  RL = lambda: sys.stdin.readline().strip()\\n  IA = lambda: map(int, RL().split(\" \"))\\n  LA = lambda: map(long, RL().split(\" \"))\\n  \\n  T = int(sys.stdin.readline())\\n  \\n  for CASE in range(T):\\n      g1 = IA()[0]-1\\n      board1 = []\\n      for i in range(4):\\n          board1.append(IA())\\n      g2 = IA()[0]-1\\n      board2 = []\\n      for i in range(4):\\n          board2.append(IA())\\n  \\n      r1 = board1[g1]\\n      r2 = board2[g2]\\n  \\n      answer = set(r1).intersection(r2)\\n      if len(answer) > 1:\\n          answer = \"Bad magician!\"\\n      elif len(answer) == 0:\\n          answer = \"Volunteer cheated!\"\\n      else:\\n          answer = list(answer)[0]\\n  \\n      print \"Case #%d: %s\" % (CASE+1, answer)\\n  \\n", "substitutes": {"__author__": ["_title__", "_title_", "__author___", "__title___", "__version__", "_author___", "__version___", "__creator_", "__title__", "__title_", "_title___", "__author_", "__creator___", "_author__", "__version_", "__creator__", "_author_"], "RL": ["VR", "SL", "LM", "CR", "R", "WR", "PL", "LB", "JR", "TL", "LP", "ARR", "MR", "RA", "LT", "DL", "CL", "L", "RR", "Ul", "LR", "BR", "LL", "BL", "RB", "IR", "XL", "LU", "UL", "DR", "FL", "IL", "RS", "HL", "LS", "NL", "ML", "LV", "HR", "SR", "LC", "lr", "RC", "EL", "VL"], "IA": ["ILA", "AA", "KA", "ISA", "ICA", "A", "LM", "IV", "SPA", "PI", "Area", "ia", "Wikipedia", "TA", "API", "LI", "CI", "RA", "GA", "IB", "AI", "MA", "LR", "SA", "I", "La", "IM", "IE", "FA", "SI", "IR", "IP", "AV", "IO", "IAN", "LAN", "MI", "AF", "IF", "LG", "CA", "IL", "FW", "II", "ACA", "League", "HA", "IJ", "AE", "ATA", "CHA", "WA", "EA", "NA", "AU", "CIA"], "LA": ["ILA", "KA", "LM", "la", "TA", "LP", "LI", "GA", "AR", "MA", "LR", "SA", "La", "LL", "LU", "UL", "CLA", "LAN", "LO", "PA", "LG", "CA", "IL", "LS", "BA", "LC", "NA", "LE"], "T": ["TG", "Z", "P", "TT", "A", "O", "R", "S", "WT", "Type", "B", "L", "F", "X", "DT", "I", "TS", "t", "E", "TN", "D", "M", "G", "Y", "C", "H", "Q", "N", "TE", "TF", "Time"], "CASE": [" COPLE", "ACase", " CPE", " CASS", "PACE", "BASS", "ACASS", " CACH", "cASE", "Base", "cOPLE", "cACH", "cACE", "COPLE", "POPLE", "CASS", "PACH", "BPE", "ACPE", "ACASE", "PASE", "BASE", "Case", " CACE", " Case", "CACE", "CPE", "CACH"], "g1": ["ga2", "gone", " g01", "g01", "gameone", "game1", "gg2", "gg1", "agg1", "ga1", "ggone", "gaone", "game01", "agg01", "game2", "gg01", "ga01", "agg2"], "board1": ["lineOne", "row3", "rowN", "rowOne", "board0", "rank1", "rank0", "row0", "line2", "row2", " boardOne", "group2", " board3", "boards3", "row1", "group3", "lineN", "group1", "board3", "rank2", "boardOne", "line1", "boards1", " boardN", "boardN", "group0", "rank3", "boards2"], "i": ["p", "it", "o", "li", "range", "m", "d", "ai", "x", "ind", "l", "f", "I", "ii", "c", "e", "ir", "t", "ie", "xi", "r", "g", "im", "j", "s", "b", "v", "u", "ip", "n", "int", "iu"], "g2": ["r4", "g4", "r0", "i2", "i32", "rTwo", "g32", "g0", " g62", "G2", "r32", "iTwo", " gTwo", "G0", "r62", "i0", "G4", "g62", "GTwo", " g4", "G62", "gTwo", "G32"], "board2": ["ga2", "board0", " board64", "line2", " board22", "group2", "line4", "boardsTwo", "ga3", "boards64", "line22", "group3", "boardtwo", " boardTwo", "block2", "boardTwo", "linetwo", "group1", "blocktwo", "g0", "Board2", "Boardtwo", "g3", "ga1", "board3", "Board22", "board4", "board22", " boardtwo", " board4", "Board4", "ga0", "block64", "group0", "boardstwo", "board64", "blockTwo", "boards2"], "r1": ["gone", "g15", "r0", "R1", "hr15", "rg15", "hr1", "hr5", " rone", "g0", "rg5", "Rone", " r0", "rg1", "r15", "r5", "g5", "R2", "R0", "rg2", "hr2", "rone"], "r2": ["g22", "rb", "r4", "gb", "er2", "er22", "g4", "R1", "r0", " r4", " rb", " r22", "g0", "r22", " r0", "R2", "R0", "er4", "Rb", "er1"], "answer": ["duration", "side", "response", "array", "swers", "case", "evidence", "score", "range", "name", "order", "grade", "next", "energy", "area", " answered", "question", "eni", "code", "ell", "equality", "output", "issue", "episode", "ee", "match", "length", "race", "test", "comment", "address", "expression", "example", "answered", "data", "assembly", "archive", "edition", "description", "video", "support", "number", "result", "results", "term", "replace", "say", "message", "equ", "fee", "update", "edge", "e", "respond", "status", "knowledge", "notice", "username", "reply", "section", "error", "word", "err", "Answer", "audio", "new", "average", "current", "offer", "vale", "pole", " answers", "eden", "cache", "topic", "see", "r", "value", "string", "translation", " Answer"]}}
{"code": "class Sweeper(object):\\n      def __init__(self, r, c, m):\\n          self.matrix = [['.' for j in range(0, c)] for i in range(0, r)]\\n          self.matrix[0][0] = 'c'\\n  \\n          self.r = r\\n          self.c = c\\n          self.m = m\\n          self.current_r = r\\n          self.current_c = c\\n          self.current_m = m\\n  \\n      def fill_row(self):\\n          if self.current_r >= 3 and self.current_m >= self.current_c:\\n              for i in range(0, self.current_c):\\n                  self.matrix[self.current_r - 1][i] = '*'\\n              self.current_r -= 1\\n              self.current_m -= self.current_c\\n              return True\\n          return False\\n  \\n      def fill_col(self):\\n          if self.current_c >= 3 and self.current_m >= self.current_r:\\n              for i in range(0, self.current_r):\\n                  self.matrix[i][self.current_c - 1] = '*'\\n              self.current_c -= 1\\n              self.current_m -= self.current_r\\n              return True\\n          return False\\n  \\n      def fill_partial(self):\\n          if self.current_r >= 3:\\n              fill_num = min(self.current_m, self.current_c - 2)\\n              for i in range(0, fill_num):\\n                  self.matrix[self.current_r - 1][self.current_c - 1 - i] = '*'\\n              self.current_m -= fill_num\\n              if fill_num > 0:\\n                  self.current_r -= 1\\n          if self.current_c >= 3:\\n              fill_num = min(self.current_m, self.current_r - 2)\\n              for i in range(0, fill_num):\\n                  self.matrix[self.current_r - 1 - i][self.current_c - 1] = '*'\\n              self.current_m -= fill_num\\n              if fill_num > 0:\\n                  self.current_c -= 1\\n          if self.current_m > 0:\\n              return False\\n          else:\\n              return True\\n  \\n      def fill_special_one(self):\\n          if self.current_r * self.current_c == self.current_m + 1:\\n              for i in range(0, self.current_r):\\n                  for j in range(0, self.current_c):\\n                      self.matrix[i][j] = '*'\\n              self.matrix[0][0] = 'c'\\n              self.current_r = 0\\n              self.current_c = 0\\n              self.current_m = 0\\n              return True\\n          return False\\n  \\n      def fill_special_col(self):\\n          if self.current_c == 1 and self.current_r > self.current_m:\\n              for i in range(0, self.current_m):\\n                  self.matrix[self.current_r - 1 - i][0] = '*'\\n              self.matrix[0][0] = 'c'\\n              self.current_m = 0\\n              self.current_r = 0\\n              self.current_c = 0\\n              return True\\n          return False\\n  \\n      def fill_special_row(self):\\n          if self.current_r == 1 and self.current_c > self.current_m:\\n              for i in range(0, self.current_m):\\n                  self.matrix[0][self.current_c - 1 - i] = '*'\\n              self.matrix[0][0] = 'c'\\n              self.current_m = 0\\n              self.current_r = 0\\n              self.current_c = 0\\n              return True\\n          return False\\n  \\n  def print_matrix(matrix):\\n      for row in matrix:\\n          s = ''\\n          for col in row:\\n              s += col\\n          print s\\n  \\n      \\n  def solve_case(t):\\n      r, c, m = [int(num) for num in raw_input().strip().split()]\\n      sweeper = Sweeper(r, c, m)\\n      print 'Case #%d:' % (t,)\\n      if sweeper.fill_special_one() or sweeper.fill_special_col() or sweeper.fill_special_row():\\n          print_matrix(sweeper.matrix)\\n          return\\n      f_result = True\\n      while sweeper.current_m > 0 and f_result:\\n          f_result = False\\n          f_result |= sweeper.fill_row()\\n          f_result |= sweeper.fill_col()\\n      if sweeper.current_m > 0:\\n          sweeper.fill_partial()\\n      if sweeper.current_m > 0:\\n          print 'Impossible'\\n      else:\\n          print_matrix(sweeper.matrix)\\n  \\n  def main():\\n      t = int(raw_input().strip())\\n      for i in range(1, t + 1):\\n          solve_case(i)\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "substitutes": {"self": ["me", "extra", "node", "all", "case", "res", "ws", "ch", "user", "qa", "lc", "event", "time", "h", "parent", "next", "missing", "default", "world", "no", "os", "part", "w", "public", "this", "v", "plus", "high", "page", "style", "er", "worker", "cross", "Self", "full", "resp", "app", "func", "view", "es", "right", "data", "ack", "args", "form", "ng", "skip", "map", "plugin", "proc", "ok", "object", "utils", "hand", "load", "instance", "pos", "ctx", "remote", "n", "result", "layer", "results", "mass", "manager", "p", "comp", "config", "spec", "man", "d", "per", "f", "wx", "host", "client", "e", "temp", "wrapper", "a", "work", "cl", "method", "line", "error", "private", "word", "coll", "ref", "err", "mate", "o", "new", "lf", "group", "q", "ns", "x", "base", "point", "l", "raw", "http", "other", "cache", "game", "www", "k", "go", "type", "co", "g", "context", "field", "b", "master", "complete", "kernel", "sys", "site"], "r": ["p", "rb", "R", "dr", "ra", "range", "rc", "ar", "ro", "mr", "d", "x", "rf", "h", "l", "y", "ru", "f", "cr", "rd", "fr", "nr", "right", "e", "ir", "rr", "k", "rh", "rg", "w", "sr", "b", "v", "re", "hr", "u", "radius", "n", "rs", "er"], "c": ["p", "cu", "ci", "ch", "cc", "lc", "dc", "nc", "rc", "cn", "q", "d", "x", "h", "l", "y", "f", "cr", "count", "e", "rec", "ce", "k", "z", "cat", "con", "cm", "a", "w", "g", "C", "b", "v", "u", "n", "mc", "ac", "cy"], "m": ["p", "o", "pm", "mu", "mm", "range", "q", "mr", "d", "x", "h", "max", "l", "y", "f", "e", "md", "M", "z", "k", "cm", "a", "w", "g", "mi", "b", "v", "u", "ms", "rm", "n", "mc", "ac"], "matrix": ["matpack", "Matrices", "Matbox", "mrib", "matrices", "matq", "atric", "latric", "atvector", " matric", "matvector", "mbox", "attpack", "mensor", "attrow", " matrices", "dimrix", "latq", "matcost", " matvector", "trix", "matrib", "atmap", "matmap", "Matensor", "atrices", "latment", "latrow", "atrow", "atpack", "attrix", "matrow", "latrix", "Matrix", "Matment", "tq", "matensor", "atcost", "attmap", "tment", "matment", "attric", "latrices", "Matrib", " matpack", "matric", " matcost", "attrices", "matbox", "dimensor", "Matcost", " matmap", "mrix", "Matvector", "dimrib", "dimbox", "atrix", "Matq", "trices"], "j": ["o", "iii", " ii", " bi", "ji", " o", "ai", "bi", "ri", "gi", "iv", "zi", "ie", "xi", " si", "abi", "di", "k", "z", "je", "ja", " b", "ij", " ni", " ti", "b", "ati", "ime"], "i": ["p", "o", "ui", "li", "id", "ci", "ix", "ia", "ei", "index", "oi", "ji", "ini", "phi", "ai", "multi", "x", "bi", "h", "ri", "l", "f", "I", "gi", "y", "ii", "ti", "e", "ir", "yi", "zi", "ie", "mini", "xi", "pi", "di", "k", "z", "ic", "ni", "ij", "mi", "b", "v", "ip", "u", "iw", "qi", "n", "si", "io", "int", "iu"], "current_r": ["reported_rc", "reported_m", "current_rb", "currentQm", "reported_rb", "current___reb", "currentDreb", "current_rate", "reported_l", "current_row", "current_e", "current_col", "currentAllrf", "current___r", "current__e", "currentMc", "currentDc", "reported_rate", "currentQr", "reported_mr", "currentVm", "currentMr", "currentPrb", "currentPr", "currentXr", "reported_reb", "reported_e", "currentVr", "reported_r", "current_rc", "current__c", "currentAllc", "reported_rr", "currentQc", "current_hr", "reported_R", "reported_c", "currentMR", "currentDmr", "currentAllr", "current_rf", "reported_col", "currentSc", "current_reb", "currentVc", "current__m", "current__r", "currentAllm", "current_mr", "currentSr", "currentXm", "currentScol", "currentXrg", "current_R", "current___mr", "currentXc", "currentSm", "reported_hr", "reported_row", "currentPc", "currentQrr", "current_rr", "currentVrate", "currentDr", "current___c", "current_l", "current_rg", "currentMm", "reported_rg", "reported_rf", "currentPm"], "current_c": ["reported_mc", "_", "currentLc", "all", "reported_m", "reported_rc", "currentAr", "currentIPr", "currentIPm", "current_n", "current_cur", "w", "currentDc", "currentMemfc", "reported_rec", "current_pc", "currentDmc", "current_d", "reported_fc", "currentPr", "current_cin", "currentIcount", "currentLr", "currentXr", "end", "currentAc", "currentIPcin", "currentMemr", "currentAh", "current_b", "reported_cur", "reported_r", "reported_rn", "currentMemm", "current_rc", "pos", "current_h", "currentParw", "reported_cin", "current_count", "currentIc", "reported_c", "currentAcur", "current_rn", "currentParrn", "currentLrec", "reported_d", "currentPd", "currentLm", "current_rec", "current_mc", "reported_h", "reported_count", "reported_pc", "currentXm", "currentParc", "current_fc", "currentXc", "reported_w", "currentImc", "currentIPc", "currentMemc", "currentIr", "currentPc", "reported_n", "currentDr", "currentParr", "currentDcount", "reported_b", "current_w", "currentPm", "currentXpc"], "current_m": ["reported_mc", "currentJr", "reported_m", "currentKm", "current64nm", "current_am", "current_co", "current_p", "currentDc", "current_mu", "currentDmc", "current_ar", "current64r", "currentOco", "currentJp", "currentWm", "currentOm", "currentDm", "reported_ar", "current_b", "reported_r", "reported_mu", "current64m", "currentOc", "currently_m", "current64c", "currentJm", "reported_c", "reported_am", "current_f", "reported_nm", "current_nm", "reported_nr", "currentKc", "currentWr", "current_mc", "reported_f", "currentKr", "currently_r", "currentJc", "reported_co", "currentOr", "currentKnr", "currently_c", "current_nr", "currently_p", "currentDr", "currentWmu", "currentWc", "reported_b"], "fill_num": ["fill_gap", "fill_net", "ill_common", "fillencommon", "update_num", " fill_multi", "fillennum", "fill_um", "ill_num", " fill_Num", " fill_net", "fill32mom", "fill64gap", "fill_mom", "fillNsum", "update_n", "fill32multi", " fill_mom", "ill_none", "fill32Num", "fillingnone", "fill67num", "fill___net", "fill67sum", "fill_n", "fill_multi", "fill_common", "fill64num", "update_nu", "fill_Num", "fill64sum", "fill___Num", "fillingnum", "update_um", " fill_number", "fillNnum", "fill_none", "fillingum", "fillingnu", "update_none", " fill_nb", " fill_dim", " fill_sum", "fillNnone", "fill___sum", "fillNcommon", "fill67nb", "fill32num", "ill_sum", "fill_number", "fill2num", "fill___num", "fill2number", "fill_sum", "fillennone", " fill_name", "update_sum", "fill_dim", "fill2name", "fill_nb", "fill2sum", "fillensum", "fill64nb", "fill67gap", " fill_gap", "fill_name", "fill_nu"]}}
{"code": "def solve_case(t):\\n      interested_row = int(raw_input().strip())\\n      i = 1\\n      while i <= 4:\\n          row = raw_input()\\n          if i == interested_row:\\n              first_set = set(row.strip().split())\\n          i += 1\\n      interested_row = int(raw_input().strip())\\n      i = 1\\n      while i <= 4:\\n          row = raw_input()\\n          if i == interested_row:\\n              second_set = set(row.strip().split())\\n          i += 1\\n      ans_set = first_set & second_set\\n      if len(ans_set) == 1:\\n          print 'Case #%d: %s' % (t, ans_set.pop(),)\\n      elif len(ans_set) > 1:\\n          print 'Case #%d: Bad magician!' % (t,)\\n      else:\\n          print 'Case #%d: Volunteer cheated!' % (t,)\\n  \\n  def main():\\n      t = int(raw_input().strip())\\n      for i in range(1, t + 1):\\n          solve_case(i)\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "substitutes": {"t": ["p", "o", "it", "start", "tim", "tp", "st", "name", "ts", "T", "m", "time", "dt", "d", "x", "h", "l", "y", "f", "port", "tz", "c", "e", "table", "task", "temp", "tt", "trial", "tower", "tc", "tf", "template", "ta", "z", "k", "nt", "type", "r", "tu", "the", "window", "mt", "g", "j", "s", "b", "v", "pt", "title", "u", "tm", "n", "ut", "test", "int", "bot", "qt", "token"], "interested_row": ["interestededrow", " interested_set", "interest_section", "mentioned_set", "interested67ro", "interested_rows", "interest_none", "interestedianrow", "interested67set", "mentioned_rows", "interested67rows", "mentioned_server", "interested_ro", " interested_ro", "interest_cell", "interestededcell", "interestediannone", "interestedingrow", "interested_server", "interestededsection", "interestedingsection", "interested_none", "interestededrows", "interestedianrows", "interested_section", " interested_rows", "interest_row", "interested_cell", "interested_set", "interested67row", "interestedingcell", "interestediancol", "interestedingrows", "interest_col", "mentioned_row", "interested_col", "interest_rows"], "i": ["p", "o", "ui", "li", "chi", "start", "id", "ci", "ix", "col", "index", "ki", "oi", "ori", "q", "cli", "m", "ini", "phi", "ai", "multi", "bi", "x", "d", "ind", "y", "ri", "l", "I", "gi", "f", "h", "ii", "c", "ti", "e", "yi", "zi", "anti", "ie", "uri", "mini", "di", "pi", "xi", "info", "k", "z", "r", "ni", "a", "j", "hi", "mi", "v", "u", "ip", "qi", "n", "si", "io", "int", "iu"], "row": ["p", "up", "array", "image", "id", "ow", "tr", "group", "col", "sw", "user", "month", "pair", "entry", "view", "sc", "q", "channel", "ro", "container", "raw", "record", "f", "port", "data", "ry", "ward", "ha", "seed", "va", "key", "batch", "wheel", "rows", "set", "cell", "hub", "input", "r", "arrow", "column", "w", "Row", "instance", "server", "line", "sync", "dd", "reader", "block", "feed", "page", "bug", "result", "section", "coll"], "first_set": ["firstJsize", "primary_setting", "primaryLname", "firstLSet", "first_Set", "first___sc", "smallJblock", "small_size", "first_name", "smallJset", "primary_name", "primaryLSet", "first___size", "first_sc", "primary_Set", "first___block", "firstJblock", "primary_set", "small_block", "firstJsc", "primaryLset", "small_set", "first_block", "small_sc", "smallJsc", "firstJset", "smallJsize", "primaryLsetting", "first___set", "firstLset", "first_setting", "first_size", "firstLsetting", "firstLname"], "second_set": ["second_setting", " second_setting", " second_pack", "second__set", " second_sc", "second_sc", " second_row", "second__sc", "second__setting", " second_case", "second_row", "second_case", "second_pack"], "ans_set": ["an_part", "ans_setting", "an_setting", "ans2list", "ans2match", "an_list", "an_row", "an_match", "ans_list", "ans_seen", "an_et", "ans2seen", "an_seen", "an_sche", "ans_et", "ans2set", "ans_match", "ans_row", "ans_sche", "ans_part", "an_set"]}}
{"code": " \\n  \\n  def read_str(): return stdin.readline().rstrip('\\n')\\n  def read_int(): return int(stdin.readline())\\n  def read_ints(): return map(int, stdin.readline().split())\\n  def read_floats(): return map(float, stdin.readline().split())\\n  \\n  \\n  def atos(A):\\n      return '\\n'.join([''.join(row) for row in A])\\n      \\n  \\n  def get_field(r, c):\\n      field = [['.'] * c for i in range(r)]\\n      field[0][0] = 'c'\\n      return field\\n      \\n      \\n  def is_forbidden(i, j):\\n      return i == 0 and j == 0 or i == 0 and j == 1 or \\\\n          i == 1 and j == 0 or i == 1 and j == 1\\n      \\n      \\n  def fill(field, r, c, m):\\n      left = m\\n      for ii in range(r - 1, -1, -1):\\n          i = ii\\n          j = c - 1\\n          while i < r and j >= 0:\\n              if is_forbidden(i, j):\\n                  i += 1\\n                  j -= 1\\n                  continue\\n              if left == 0:\\n                  return 0\\n              field[i][j] = '*'\\n              left -= 1\\n              \\n              i += 1\\n              j -= 1\\n              \\n          if ii == 0:\\n              for jj in range(c - 2, 1, -1):\\n                  i = ii\\n                  j = jj\\n                  while i < r and j >= 0:\\n                      if is_forbidden(i, j):\\n                          i += 1\\n                          j -= 1\\n                          continue\\n                      if left == 0:\\n                          return 0\\n                      field[i][j] = '*'\\n                      left -= 1\\n                      \\n                      i += 1\\n                      j -= 1\\n              \\n      if r * c == m + 1:\\n          if r > 1:\\n              field[1][0] = '*'\\n          if c > 1:\\n              field[0][1] = '*'\\n          if r > 1 and c > 1:\\n              field[1][1] = '*'\\n          return 0\\n              \\n      return left\\n  \\n      \\n  def solve_case():\\n      r, c, m = read_ints()\\n      \\n      field = get_field(r, c)\\n          \\n      left = fill(field, r, c, m)\\n          \\n      return 'Impossible' if left != 0 else atos(field)\\n      \\n      \\n  def main():\\n      cases = read_int()\\n      for case in range(1, cases + 1):\\n          print('Case #{}:\\n{}'.format(case, solve_case()))\\n  \\n          \\n  main()\\n", "substitutes": {"A": ["AA", "Z", "P", "AB", "R", "array", "S", "B", "T", "AR", "As", "L", "AC", "mA", "F", "I", "alpha", "ram", "K", "area", "grid", "This", "analysis", "D", "M", "G", "AD", "AN", "LA", "Y", "CA", "a", "C", "H", "W", "N", "n", "an", "NA", "Ar", "ac"], "row": ["rown", "array", "node", "ow", "uu", "col", "mm", "rc", "entry", "board", "ro", "x", "xxxxxxxx", "record", "raw", " rows", "f", "arr", "insert", "rew", " Row", "rows", "obj", "round", "ud", "cell", "input", "column", "object", "Row", "instance", "line", "model", "reader", "rw", "block", "feed", "result", "df", "gram"], "r": ["err", "p", "br", "R", "rb", "dr", "tr", "range", "rc", "q", "ar", "gr", "mr", "d", "x", "h", "l", "y", "f", "ru", "cr", "fr", "right", "nr", "e", "ir", "str", "t", "arr", "adr", "rec", "ur", "rr", "rh", "z", "rg", "a", "w", "g", "sr", "b", "v", "re", "hr", "u", "pr", "rm", "lr", "n", "rs", "er", "yr"], "c": ["cu", "p", "o", "ci", "ch", "cc", "col", "cf", "lc", "dc", "nc", "cn", "rc", "q", "d", "x", "arc", "h", "l", "y", "f", "cp", "cr", "uc", "right", "e", "end", "t", "ce", "ec", "k", "z", "con", "cm", "a", "co", "w", "C", "s", "b", "v", "u", "ca", "n", "cs", "mc", "ac", "cy"], "field": ["element", "all", "sort", "force", "list", "user", "document", "machine", "time", "player", "true", "default", "day", "play", "inner", "key", "part", "match", "fill", "v", "page", "ed", "er", "slice", "comment", "lock", "fields", "data", "end", "table", "FIELD", "form", "module", "column", "object", "load", "root", "number", "fix", "diff", "result", "int", "layer", "term", "manager", "p", "li", "label", "file", "man", "function", "d", "record", "f", "message", "e", "post", "cell", "input", "line", "section", "word", "ff", "option", "err", "child", "group", "q", "null", "cover", "x", "rule", "condition", "round", "type", "value", "g", "Field", "model", "string", "block", "patch", "source", "change"], "i": ["p", "it", "o", "ui", "li", "id", "ci", "ix", "ia", "oi", "ki", "ori", "ini", "ji", "d", "ai", "phi", "x", "bi", "multi", "ind", "l", "y", "f", "I", "ri", "gi", "iv", "ti", "vi", "e", "ir", "eni", "yi", "zi", "anti", "ie", "api", "ik", "mini", "uri", "pi", "xi", "di", "info", "z", "ic", "ni", "fi", "a", "ij", "ib", "s", "b", "v", "mi", "ip", "u", "qi", "n", "si", "int", "io", "iu"], "j": ["p", "o", "it", "off", "br", "li", "all", "ci", "ch", "ix", "js", "jc", "q", "jp", "ji", "ot", "name", "d", "J", "x", "bj", "h", "oj", "l", "y", "f", "ah", "adj", "e", "t", "jl", "aj", "key", "ie", "jen", "el", "obj", "k", "z", "note", "ja", "je", "part", "a", "ij", "dj", "g", "b", "v", "pt", "jo", "line", "u", "jet", "on", "page", "n", "si", "ne", "jon", "uj"], "m": ["p", "o", "mu", "mm", "range", "q", "machine", "man", "mr", "d", "x", "h", "l", "y", "f", "ym", "e", "t", "middle", "um", "M", "z", "cm", "a", "w", "g", "im", "mi", "b", "v", "re", "ms", "u", "tm", "n", "mc"], "left": ["all", "ix", "lc", "shell", "cel", "missing", "default", "code", "cost", "inner", "ell", "no", "used", "wrong", "self", "z", "leave", " Left", "length", "plus", "min", "lt", "ignore", "pl", "offset", "id", "full", "ul", "fields", "right", "member", "end", "skip", "diff", "joined", "n", "p", "li", "label", "copy", "col", "len", "function", "false", "only", "e", "fl", "none", "two", "partial", "cell", "size", "cl", "low", "small", "line", "le", "error", "lo", "err", "o", "child", "Left", "center", "null", "L", "x", "l", "found", "hide", "shift", "rule", "after", "Right", "empty", "obj", "fe", "url", "last"], "ii": ["img", "err", "p", "ig", "iq", "say", "illi", "li", "id", "ci", "ix", "col", "cf", "qa", "ei", "iii", "init", "center", "ice", "ini", "ji", "d", "ai", "ind", "h", "l", "y", "iv", "gi", "f", "ri", "vi", "end", "eni", "circle", "inner", "after", "ili", "middle", "fl", "ie", "mini", "di", "z", "ni", "cycle", "cm", "fi", "sci", "ort", "size", "II", "url", "b", "ani", "iw", "qi", "bug", "n", "inf", "sil", "si", "yy", "ignore"], "jj": ["p", "qq", "ix", "cc", "gm", "jc", "mm", "q", "jp", "ji", "man", "JC", "d", "J", "x", "h", "y", "cp", "right", "jl", "rec", "aj", "ja", "bb", "cm", "ij", "JJ", "dj", "g", "b", "jo", "tm", "n", "uj", "gn"], "cases": ["tests", "child", "lines", "path", "fields", "counter", "times", "stack", "count", "shift", "rule", "inner", "ends", "values", "trial", "rows", "rules", "options", "sections", "children", "size", "Case", "instance", "cells", "mat", "section", "test"], "case": ["_", "all", "index", "right", "end", "pos"]}}
{"code": " \\n  def read_str(): return stdin.readline().rstrip('\\n')\\n  def read_int(): return int(stdin.readline())\\n  def read_ints(): return map(int, stdin.readline().split())\\n  \\n  def read_cards():\\n      cards = []\\n      for i in range(4):\\n          cards.append(read_ints())\\n      return cards\\n  \\n  def main():\\n      cases = read_int()\\n      for case in range(1, cases + 1):\\n          row = read_int() - 1\\n          cards = read_cards()\\n          candidates1 = set(cards[row])\\n          \\n          row = read_int() - 1\\n          cards = read_cards()\\n          candidates2 = set(cards[row])\\n          \\n          candidates = candidates1.intersection(candidates2)\\n          if len(candidates) == 1:\\n              ans = list(candidates)[0]\\n          elif len(candidates) == 0:\\n              ans = 'Volunteer cheated!'\\n          else:\\n              ans = 'Bad magician!'\\n          \\n          print('Case #{}: {}'.format(case, ans))\\n          \\n  main()\\n", "substitutes": {"cards": ["tests", "steps", "array", "all", "files", "list", "ickets", "books", "default", "reads", "items", "holes", "carry", "comments", "cas", "acs", "grades", "cs", "cross", "rooms", "ards", "pieces", "limits", "card", "fields", "stars", "parents", "c", "ays", "rules", "quarters", "bags", "groups", "months", "changes", "lines", "hands", "codes", " card", "ids", "cons", "events", "checks", "cell", "cats", "charges", "balls", "rings", "guards", "lists", "caps", "features", "cf", "styles", "yards", "games", "times", "phones", "cuts", "packs", "rows", "clips", "types", "lights", "letters", "settings", "liners", "boxes", "s", "kids", "attacks", "cells", "Card", "breaks"], "i": ["p", "it", "li", "id", "ix", "col", "index", " ii", "ice", "x", "ind", " I", "I", "c", "ace", "e", "ic", " ic", "j", "bc", "line", "pos", "u", "ip", "char", "n", "int"], "cases": ["tests", "steps", "features", "rooms", "forms", "ls", "runs", "lines", "classes", "ches", "tips", "cus", "fields", "times", "ces", "points", "events", "checks", "packs", "ends", "values", "rows", "shape", "sections", "types", "blocks", "groups", "xs", "settings", "ases", "boxes", "Case", "cells", "days", "shows", "test", "cs", "chains", "breaks"], "case": ["start", "li", "id", "address", "col", "division", "index", "sea", "sc", "ice", "time", "X", "position", "c", "core", "ace", "code", "mode", "trial", "ce", "rows", "shape", "cell", "match", "ape", " c", "length", "Case", "instance", "line", "pos", "race", "ase", "loc", "cas", "ca", "ride", "bug", "test", "section", "slice"], "row": ["box", "id", "ow", "where", "group", "col", "uu", "rank", "month", "index", "range", "rc", "entry", "sc", "order", "ro", "head", "x", "slice", "step", "port", " rows", "uc", "ry", "scale", "ward", "key", "batch", "mode", "win", "rows", "shape", "post", "round", "roll", "cell", "r", "column", "Row", "instance", "line", "race", "loc", "block", "feed", "bug", "test", "section", "week", "coll"], "candidates1": ["candidatesone", "candidate2", "candores0", "candodes2", "candotes1", "candidates0", "candotes0", "candotes3", "candidate1", "candidates3", "candices2", "Candidates1", "candodesone", "candices1", "Candidate0", "candidate3", "candores2", "Candidates3", "Candidates2", "Candidatesone", "candotes2", "candoresone", "candices0", "Candidates0", "candices3", "Candidate1", "candidate0", "candidateone", "Candidate2", "Candidate3", "candodes1", "Candidateone", "candores1", "candodes0"], "candidates2": ["candidate2", "candriesTwo", "candodes2", "candidates0", "candidate1", "Candidates1", "Candidate0", "candates0", "candles1", "Candidates02", "candates02", "candlesTwo", "Candidates2", "CandidatesTwo", "candries2", "candidatesTwo", "candidate02", "Candidate02", "candries0", "candidateTwo", "Candidates0", "candates1", "candles2", "Candidate1", "candidate0", "candries1", "candidates02", "Candidate2", "candodes1", "candodes02", "candates2", "CandidateTwo", "candles0", "candodes0"], "candidates": ["charles", "Candidate", "contracticates", "candicates", "candores", "candates", "charales", "matidates", "variations", "variidates", "contractidate", "charations", "charores", "valididate", "candles", "validles", "charidate", "indations", "Candles", "variances", "candidate", "charates", "candales", "variates", "indidates", "contractidates", "matates", "charidates", "matidate", "Candidates", "Candicates", "valididates", "candances", "Candores", "indates", "candations", "charicates", "contractores", "charances", "validales", "indances", "Candales", "Candates", "matles"], "ans": ["les", "aning", "aces", "amps", "plan", "san", "na", "ations", "aus", "ns", "ins", "anas", "ean", "ain", "ai", " Ans", "ams", "cus", "ano", "nan", "nas", "aos", "ann", "lan", "anus", "sk", "ang", " ang", "ania", "leans", "atan", " sins", "os", "ants", "can", "anc", "AN", " means", "ars", "ani", "aned", "ANS", "ats", "ana", "an", "ras", "cross", "ane", "lang"]}}
{"code": "T = int(input())\\n  \\n  def solve(R,C,M):\\n      if R>C:\\n          flipboard = solve(C,R,M)\\n          if flipboard:\\n              return [[flipboard[j][i] for j in range(C)] for i in range(R)]\\n          else:\\n              return\\n      if M==0:\\n          board = [['.']*C for i in range(R)]\\n          board[-1][-1] = 'c'\\n          return board\\n      if R == 1:\\n          board = ['*' if i<M else '.' for i in range(R*C)]\\n          board[-1] = 'c'\\n          return [board]\\n      if R == 2:\\n          if R*C==M+1:\\n              board = [['*']*C for i in range(R)]\\n              board[-1][-1] = 'c'\\n              return board\\n          if (M%2) or (M+2)==(R*C):\\n              return\\n          board = [['*' if i<(M/2) else '.' for i in range(C)] for j in range(R)]\\n          board[-1][-1] = 'c'\\n          return board\\n      if M>=R:\\n          subboard = solve(R,C-1,M-R)\\n          if subboard:\\n              return [['*']+r for r in subboard]\\n          return\\n      if (R,C,M) == (3,3,2):\\n          return\\n      k = min(M,C-2)\\n      board = [['*']*k+['.']*(C-k)]\\n      for i in range(M-k):\\n          board.append(['*']+['.']*(C-1))\\n      while len(board)<R:\\n          board.append(['.']*(C))\\n      board[-1][-1] = 'c'\\n      return board\\n      \\n           \\n      \\n  \\n  for case in range(1,T+1):\\n      print(\"Case #\",case,\": \",sep='')\\n      R,C,M = (int(x) for x in input().split())\\n      ans = solve(R,C,M)\\n      if ans:\\n          for r in ans:\\n              print(''.join(r))\\n      else:\\n          print('Impossible')\\n  \\n  \\n", "substitutes": {"T": ["Z", "P", "O", "A", "TT", "S", "B", "Type", "L", "TB", "TM", "F", "X", "I", "t", "TS", "E", "CT", "TN", "D", "G", "U", "Y", "V", "H", "Q", " t", "N", "W", "TI", "test", "Time"], "R": ["P", "O", "A", "CR", "Cr", "WR", "KR", "S", "JR", "B", "Ra", "MR", "RA", "AR", "m", "Rule", "J", "L", "RR", "RE", "Run", "CL", "F", "X", "RN", "K", "I", "RP", "ER", "c", "RW", "Mor", "Rs", "E", "IR", "NR", "RH", "Right", "DR", "RO", "TR", "D", "G", "Rh", "U", "Y", "GR", "Cl", "RS", "V", "H", "RL", "RT", "RG", "Q", "W", "N", "SR", "Re", "RM", "Range"], "C": ["CC", "Z", "P", "O", "A", "CR", "Cr", "CW", "CS", "S", "B", "COR", "CI", "JC", "DC", "L", "CL", "CM", "AC", "X", "F", "K", "I", "Sc", "c", "Ch", "CU", "E", "CT", "CN", "CO", "CNN", "VC", "D", "NC", "G", "EC", "MC", "CAR", "U", "Count", "Y", "CA", "Cl", "V", "H", "Co", "Cu", "CE", "Size", "Q", "W", "N", "CV"], "M": ["Mo", "Z", "P", "O", "LM", "A", "VM", "Me", "MF", "S", "MN", "AM", "B", "ID", "MO", "MR", "m", "J", "L", "MA", "CL", "CM", "TM", "F", "X", "Model", "I", "K", "DM", "Man", "IM", "c", "Ch", "Mor", "JM", "E", "ME", "MM", "D", "G", "MI", "MS", "MD", "MC", "OR", "OM", "U", "cm", "Y", "V", "H", "MB", "Q", "NM", "W", "N", "MX", "RM", "FM", "Mi"], "flipboard": ["flippcart", "fliphole", "flippingrow", "flipboards", " flipline", "flippedboard", "Flipphole", "flipBoard", "flippback", "Flipcart", "flideboards", "flippingline", "flipperboard", " flippingboard", "flippedline", "flippboards", "Flippcart", "flideBoard", "flippinghole", "flippercart", "flippedboards", "flipphole", "flippingback", "flipprow", "slipboards", "Flipboards", "slideBoard", "flippedBoard", "flipback", "slipBoard", "flippedback", "fliprow", " flippingline", "flippline", "flippingboard", "flipcart", "flipperhole", "flipperboards", "Fliphole", " flippingrow", " flippingback", "slideboards", "Flippboard", "flippingcart", "Flippboards", "flippboard", " fliprow", " flipback", "slipboard", "flipline", "flippingboards", "flippedrow", "slideboard", "Flipboard", "flippBoard", "flideboard"], "j": ["p", "o", "li", "js", "jc", "q", "jp", "m", "ji", "J", "kj", "ind", "oj", "l", "y", "f", "h", "adj", "ii", "c", "e", "ir", "jl", "aj", "ie", "xi", "obj", "z", "jj", "je", "ja", "ni", "ij", "g", "im", "b", "v", "qi", "n", "uj"], "i": ["p", "o", "it", "iq", "ui", "li", "chi", "id", "ci", "ei", "index", "ori", "m", "ji", "d", "ai", "phi", "bi", "ri", "l", "f", "I", "gi", "ii", "c", "ti", "e", "yi", "zi", "ie", "ik", "pi", "di", "xi", "ni", "g", "ib", "im", "b", "v", "u", "ip", "iw", "qi", "n", "si", "io", "int", "iu"], "board": ["stroke", "lay", "node", "all", "list", "layout", "document", "ode", "stream", "head", "player", "boards", "uc", "day", "play", "room", "code", "ward", "frame", "join", "control", "ban", "length", "bug", "clean", "page", "home", "cross", "comment", "plan", "ko", "view", "une", "menu", "card", "c", "core", "ack", "table", "back", "form", "hole", "video", "Board", "hack", "bc", "object", "flow", "result", "p", "pool", "ide", "valid", "boarding", "file", "function", "d", "que", "f", "port", "custom", "flo", "client", "e", "bo", "chain", "ba", "post", "cart", "check", "phone", "work", "row", "line", "word", "coll", "one", "box", "off", "child", "val", " clipboard", "deck", "rank", "ion", "channel", "loop", "null", "foot", "road", "rock", "game", "rows", "che", "round", "co", "bar", "b", "model", "design", "land", "bank", "block", "feed", "lane"], "subboard": ["ubview", "searchrow", "ubboard", "subview", "subline", "subBoard", "ubBoard", "subcart", "ubrow", "searchview", " subcart", " subview", "ubline", "superboard", "ubboards", " subboards", "Subboards", " subBoard", "superrow", " subline", " subrow", "supercart", "superBoard", "searchline", "subboards", "Subboard", "Subrow", "ubcart", "searchboard", "subrow"], "r": ["p", "P", "br", "ear", "id", "res", "array", "rb", "range", "run", "rc", "q", "ar", "m", "gr", "ro", "mr", "d", "kr", "ring", "h", "l", "f", "cr", "ru", "c", "nr", "al", "right", "e", "ir", "chain", "ur", "nor", "ner", "Rh", "a", "w", "g", "im", " c", "re", "sr", "v", "s", "b", "u", "n", "rs", "er", "result", "ac"], "k": ["p", "o", "it", "ch", "rank", "ko", "q", "m", "d", "ku", "max", "l", "y", "f", "K", "kw", "ke", "c", "sk", "e", "end", "t", "key", "ak", "mk", "ck", "z", "ok", "ka", "ks", "work", "w", "g", "s", "b", "kk", "v", "u", "block", "n", " K", "km", "ac"], "case": ["p", "P", "switch", "id", "pe", "path", "name", "ice", "time", "text", "X", "position", "c", "ace", "e", "code", "choice", "E", "key", "mode", "trial", "ce", "shape", "type", "match", "size", " c", "Case", "instance", "race", " CASE", "ase", "loc", "test", "section", "cases", "tc", "one"], "x": ["p", "ax", "xxx", "index", "q", "d", "h", "ex", "y", "X", "l", "f", "wx", "xt", "xa", "e", "xi", "z", "ic", "xs", "xc", " X", "rx", "w", "g", "a", " c", "xy", "v", "xp", "u", "xx", "n", "xb", "int"], "ans": ["aces", "aning", "ons", "ls", "plan", "na", "aus", "ns", "ins", "man", "ano", "ai", "ents", "span", "cus", "ops", "nas", "ids", "ann", "lan", "sk", "scan", " scans", "ania", "ians", "ays", "cons", "ions", "os", "ants", "can", "ens", "AN", " means", "anc", "con", "ks", "ases", "anes", "ani", "aned", "ANS", "ms", "ats", "ana", "ase", "cas", "an", "ras", "ds", "ane", "lang"]}}
{"code": "T = int(input())\\n  for case in range(1,T+1):\\n      row1 = int(input())\\n      for i in range(1,5):\\n          l = input()\\n          if i==row1:\\n              first = set(int(x) for x in l.split())\\n      row2 = int(input())\\n      for i in range(1,5):\\n          l = input()\\n          if i==row2:\\n              second = set(int(x) for x in l.split())\\n      poss = first & second\\n      if len(poss) ==0:\\n          ans = 'Volunteer cheated!'\\n      elif len(poss) >1:\\n          ans = 'Bad magician!'\\n      else:\\n          ans = min(poss)\\n      print(\"Case #\",case,\": \",ans,sep = '')\\n", "substitutes": {"T": ["Z", "P", "TT", "A", "O", "R", "S", "WT", "B", "CI", "time", "L", "F", "X", "K", "I", " L", "t", "TS", "E", "trial", "D", "M", "Y", "C", "V", "H", "Case", "W", "N", "TI", "Time"], "case": ["p", "se", "ci", "pe", "st", "pair", "name", "ice", "time", "ai", "X", "gi", "c", "vi", "ace", "ti", "e", "end", "code", "choice", "yi", "uc", "series", "zi", "trial", "ce", "pi", "type", "match", "U", "xc", "a", "bc", "length", "Case", "b", "instance", "line", "u", " CASE", " Case", "ase", "cas", "section", "test", "cases", "zip"], "row1": ["rank1", "rank0", "row0", "Rowone", "entry0", "Row1", "entryFirst", "post1", "postA", "post0", "entry1", " row0", "Row0", " rowone", "entryA", "rowone", "rankone", "rowFirst", " rowA", "rowA", "postFirst", " rowFirst"], "i": ["p", "it", "o", "ui", "li", "start", "chi", "id", "ci", "index", "ori", "m", "phi", "ai", "bi", "ind", "y", "f", "I", "ii", "c", "ti", "end", "e", "t", "yi", "zi", "ie", "xi", "pi", "di", "z", "ic", "a", "b", "v", "ip", "u", "si", "int", "iu"], "l": ["il", "p", "o", "la", "li", "ls", "lin", "lc", "log", "m", "ll", "d", "L", "y", "f", "rl", "c", "e", "t", "ell", "ln", "el", "nl", "z", "r", "kl", "w", "g", "j", "dl", "lp", "s", "b", "v", "ol", "line", "lu", "u", "le", "n", "sl"], "first": ["split", "p", "latest", "up", "start", "full", "current", "st", "fifth", "next", "max", "third", "default", "right", "only", "final", "none", "front", "prev", "part", "initial", "a", "top", "left", "last", "sum", "s", "th", "u", "lower", "primary", "now", "First", "one"], "x": ["p", "ph", "ww", "se", "id", "ci", "unc", "ax", "full", "sw", "xxx", "q", "m", "text", "lex", "xt", "ex", "y", "X", "f", "ux", "h", "wx", "c", "e", "t", "xes", "k", "z", "input", "xs", "xc", "rx", "w", "a", "work", "s", "xy", "b", "xp", "u", "sex", "xml", "n", "xx", "int", "ct", "cross"], "row2": ["error1", "col2", "row0", "coltwo", "row5", "block62", "ow1", " row62", "error2", "block2", "ro62", "col1", "block5", "ro5", "row4", "ow2", "ro4", "ow0", "owtwo", "error0", " row5", "errortwo", "ro2", " row4", "block4", "rowtwo", "row62", "col0"], "second": ["split", "bis", "latest", "long", "Second", "len", "loss", "later", "slice", "double", "follow", "next", "between", "secret", "mini", "two", "secondary", "sec", "danger", "size", "url", "six", "future", "left", "last", "low", "small", "lower", "species", "south", "letter", "seconds", "old"], "poss": ["cpOSS", "fOSS", "pose", "paose", "pocr", "Possession", "Pass", "prass", " passo", "paasso", "possession", "POSS", " pocr", "foss", "Pocol", "paoss", "prOSS", "iposs", "paossession", "Passo", "ipocol", "cposs", "Pocr", "pross", "cpos", "pOSS", "cpass", " pOSS", "passo", "ipose", "fass", "Pose", "paocol", "ipass", "pos", "pocol", "paass", "procr", "Poss", "paOSS", "fos", " possession", " pos"], "ans": ["aces", "aning", "les", "ons", "ls", "amps", "eps", "plan", "san", "lc", "na", "params", "aus", "ns", "ins", "anas", "ain", "ai", "ents", "ams", "cus", "es", "nas", "ann", "lan", "sk", "asin", "ant", "ania", "atan", "ays", "cons", "anne", "os", "ants", "can", "ast", "anc", "AN", "support", "ks", "ases", "a", "s", "ani", "ars", "aned", "ANS", "ana", "oss", "ase", "act", "cas", "acs", "ass", "an", "cs", "ras", "ane"]}}
{"code": "filename = raw_input(\"Name of file: \")\\n  infile = open(filename, \"r\")\\n  outfile = open(filename + \".out\", \"w\")\\n  \\n  \\n  T = int(infile.readline()[:-1])\\n  \\n  def addMinesDiagonally(r, c, m):\\n      field = []\\n      for i in range (r):\\n          row = []\\n          for j in range(c):\\n              row += [\".\"]\\n          field += [row]\\n          \\n      for i in range (r + c):\\n          ver = min (i, r - 1)\\n          hor = max (0, 1 + i - r)\\n          while ver >= 0 and hor <= c - 1 and m > 0:\\n              if m == 1 and hor == c - 2 and ver == r - 2:\\n                  ver -= 1\\n                  hor += 1\\n              field[ver][hor] = \"*\"\\n              ver -= 1\\n              hor += 1\\n              m -= 1\\n          \\n      return field\\n  \\n  def isPossible(field):\\n      if field[-1][-1] != \".\":\\n          return False\\n      up = True\\n      left = True\\n      diag = True\\n      if len(field) > 1 and field[-2][-1] != \".\":\\n              up = len(field[-1]) <= 1\\n      if len(field[-1]) > 1 and field[-1][-2] != \".\":\\n              left = len(field) <= 1\\n      if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != \".\":\\n          diag = False\\n      return (up and left and diag) or \\\\n             ((not up) and (not left) and (not diag))\\n      \\n  \\n  for t in range(1, T + 1):\\n      items = infile.readline()[:-1].split(\" \")\\n      r = int(items[0])\\n      c = int(items[1])\\n      m = int(items[2])\\n      field = addMinesDiagonally(r, c, m)\\n      if isPossible(field):\\n          field[-1][-1] = \"c\"\\n          s = \"\"\\n          for line in field:\\n              for cell in line:\\n                  s += cell\\n              s += \"\\n\"\\n          outfile.write(\"Case #%d:\\n%s\\n\" %(t, s[:-1]))\\n      else:\\n          s = \"IMPOSSIBLE!!!!\\n\"\\n          for line in field:\\n              for cell in line:\\n                  s += cell\\n              s += \"\\n\"\\n          outfile.write(\"Case #%d:\\n%s\\n\" %(t, s[:-1]))\\n      \\n          \\n      \\n  \\n  outfile.close()\\n  infile.close()\\n", "substitutes": {"filename": ["il", "fp", "subject", "ames", "files", "kn", "path", "document", "ername", "name", "file", "phrase", "knife", "fn", "dll", "stem", "mble", "lace", "f", "fd", "amer", "directory", "jl", "ln", "utf", "download", "pal", "nil", "sql", "figure", "selection", "til", "FILE", "kl", "Filename", "itled", "username", "SourceFile", "doi", "that", "title", "sheet", "jet", "sf", "wl", "ename", "database", "fil", "slice", "which", "binary", "tail"], "infile": ["outline", "outFile", "infilename", "infiles", " infiles", "Infiles", "outfilename", "Inline", " inline", "outstream", " inFile", "InFile", "Infilename", " infilename", "instream", " instream", "outfiles", "inline", "Instream", "Infile", "inFile"], "outfile": ["OUTfile", "outline", " outFile", "outFile", "Outline", "OUTFile", "outstream", "Outf", "Outstream", "Outfile", "outf", "instream", " outletter", "inline", "OUTletter", " outf", "OUTstream", "inletter", "outletter", "inf", " outstream", "inFile", " outline"], "T": ["Z", "P", "O", "A", "TT", "R", "Length", "S", "WT", "B", "L", "F", "X", "I", "K", "TS", "E", "CT", "TN", "TR", "G", "M", "D", "U", "Y", "C", "V", "H", "Size", "Q", "W", "N"], "r": ["p", "o", "rb", "R", "ra", "tr", "range", "rc", "ar", "ro", "d", "x", "h", "ri", "l", "f", "ru", "cr", "rd", "right", "nr", "fr", "e", "ir", "rec", "ur", "rr", "k", "rh", "rt", "rn", "a", "w", "b", "v", "sr", "re", "u", "pr", "n", "rs", "er"], "c": ["p", "o", "cu", "ci", "ch", "cc", "col", "lc", "dc", "nc", "cn", "rc", "center", "q", "d", "ct", "x", "h", "en", "l", "y", "f", "cr", "cp", "uc", "e", "ce", "k", "z", "cat", "con", "cm", "a", "w", "g", "C", "b", "v", "u", "n", "cs", "mc", "ac", "cy"], "m": ["p", "o", "mm", "range", "fm", "machine", "q", "mr", "d", "x", "h", "y", "l", "f", "en", "am", "meter", "e", "end", "bm", "dm", "pi", "um", "M", "z", "k", "cm", "a", "w", "g", "im", "mon", "mi", "b", "v", "re", "min", "u", "om", "vm", "tm", "rm", "n", "er", "an", "mc"], "field": ["element", "format", "array", "all", "node", "force", "case", "sort", "list", "user", "range", "document", "event", "machine", "order", "cel", "time", "feature", "player", "area", "play", "seed", "key", "frame", "um", "part", "pick", "match", "length", "this", "v", "pull", "er", "style", "slice", "comment", "service", "flower", "ld", "eff", "space", "lock", "fields", "data", "end", "table", "FIELD", "form", "module", "bf", "object", "load", "number", "fix", "diff", "result", "layer", "manager", "p", "label", "file", "man", "function", "record", "f", "message", "update", "package", "post", "input", "section", "error", "word", "ff", "coll", "zip", "option", "box", "off", "child", "group", "null", "util", "rule", "condition", "type", "value", "url", "wire", "Field", "model", "uf", "string", "block", "patch", "source", "change"], "i": ["p", "o", "li", "id", "ci", "range", "ar", "d", "phi", "x", "h", "l", "ri", "ind", "I", "f", "y", "ii", "e", "ir", "ie", "pi", "xi", "di", "k", "z", "w", "g", "im", "b", "v", "ip", "u", "qi", "n", "io", "int", "si", "iu"], "row": ["element", "box", "array", "child", "query", "id", "ow", "tr", "group", "col", "rank", "month", "range", "index", "rc", "our", "sc", "order", "ro", "feature", "x", "h", "max", "step", "ul", "port", "f", "cr", "uc", "key", "form", "num", "rows", "value", "column", "w", "Row", "server", "model", "block", "feed", "cur", "coll"], "j": ["p", "o", "cc", "jc", "cf", "jac", "q", "y", "f", "e", "code", "year", "k", "z", "sec", "je", "cycle", "cm", "co", "ij", "g", "ib", "b", "v", "jam", "ct", "ac", "cy"], "ver": ["err", "iter", "air", "conv", "br", "cv", "res", "dr", "cher", "col", "range", "version", "av", "aver", "Ver", "gr", "gener", "cover", "mr", "feature", "x", "car", "h", "f", "cr", "ever", "fr", "VER", "ir", "ter", "vert", "ur", "num", "var", "browser", "reach", "type", "con", "vers", "ve", "re", "b", "v", "inter", "min", "root", "pr", "om", "oy", "er", "vr", "iver", "test", "cur", "coll", "over"], "hor": ["air", "ov", "ho", "cv", "dom", "vor", "br", "ra", "cor", "mir", "hover", "version", "shadow", "aver", "broad", "mr", "d", "Hor", "car", "h", "dy", "ri", "cr", "ever", "ior", "hide", "meter", "chrom", "ir", "dir", "hom", "far", "floor", "vert", "ur", "tri", "mor", "orient", "uri", "um", "cro", "nor", "oor", "reach", "hub", "door", "bor", "low", "hi", "mi", "v", "lor", "xy", "hr", "dim", "pr", "om", "rum", "oh", "oy", "vr", "rub", "lo", "cur", "home", "over"], "up": ["p", "ma", "coll", "all", "op", "ra", "user", "uph", "ame", "ups", "ahead", "ama", "ap", "parent", "lock", "equal", "area", "around", "UP", "upp", "floor", "api", "back", "ure", "pre", "Up", "um", "sup", "down", "own", "move", "top", "upe", "length", "union", "plus", "flow", " Up", "upt", "u", "ip", "upper", "mp", "home", "one", "over"], "left": ["pl", "il", "o", "p", "la", "li", "level", "all", "long", "lic", "lim", "len", "Left", "log", "lon", "ly", "led", "d", "L", "double", "out", "l", "ul", "law", "right", "hide", "limited", "byn", "ell", "fl", "wrong", "el", "two", "nl", "ge", "ner", "rel", "down", "leave", "limit", "url", "cl", "low", "length", "plus", "NL", "pos", "lu", "flow", "loc", "le", "sl", "lt", "lo", "exp", "where"], "diag": ["liagg", " diap", "liags", "diags", " diog", "liag", " diags", "siag", "siagg", "Diag", "diagg", "siagn", "Diagram", "Diap", "diagram", "liig", " diagn", "siig", "liap", "biog", "biagn", "diog", "Diags", " diagram", "diap", "biags", "diagn", "liog", "siags", "Diagn", "siagram", "liagn", "diig", "biag", " diig", " diagg"], "t": ["p", "o", "tr", "col", "st", "ts", "ot", "time", "dt", "d", "text", "x", "h", "y", "l", "f", "tz", "e", "table", "tt", "tf", "ta", "z", "nt", "type", "w", "b", "v", "tl", "title", "u", "ty", "n", "int"], "items": ["steps", "bands", "features", "images", "files", "docs", "lines", "js", "eps", "Items", "plugins", "lists", "pieces", "qs", "ips", "ins", "styles", "opens", "strings", "ops", "fields", "ids", "phones", "names", "flows", "models", "events", "values", "articles", "sites", "json", "objects", "rows", "keys", "bytes", "cats", "bars", "abs", "blocks", "groups", "gets", "links", "boxes", "orders", "words", "cells", "photos", "comments", "apps", "item", "amples", "results", "pages"], "s": ["format", "_", "single", "ws", "ips", "ins", "us", "z", "services", "w", "v", "comments", "u", "sf", "sv", "ed", "slice", "id", "ss", "sb", "states", "es", "sets", "parts", "sample", "ing", "n", "sym", "p", "ls", "lines", "S", "spec", "d", "strings", "ops", "X", "f", "e", "gs", "ses", "input", "blocks", "a", "ments", "si", "o", "sp", "ns", "x", "l", "add", "series", "rows", "ps", "types", "settings", "g", "b", "append", "cells", "string", "ds"], "line": ["li", "unit", "case", "lines", "group", "lin", "col", "ine", "range", "len", "file", " inline", "Line", "struct", "loop", "cel", "point", "un", "write", "l", "f", "lace", "liner", "end", "code", "rule", "chain", "frame", "el", "lined", "inline", "cycle", "column", "co", "string", "block", "n", "lo", "layer"], "cell": ["child", "all", "unit", "case", "div", "long", "label", "ch", "group", "col", "Cell", "entry", "struct", "cel", "text", "un", "chart", "add", "count", "character", "str", "code", "cond", "ell", "z", "input", "cat", "match", "inline", "column", "length", "Field", "v", "cells", "char", "pattern", "string", "call", "block", "feed", "tab"]}}
{"code": "filename = raw_input(\"Name of file: \")\\n  f = open(filename, \"r\")\\n  o = open(filename + \".out\", \"w\")\\n  \\n  \\n  T = int(f.readline()[:-1])\\n  \\n  many_possible = \"Bad magician!\"\\n  zero_possible = \"Volunteer cheated!\"\\n  \\n  for t in range(1, T + 1):\\n      first = int(f.readline()[:-1]) - 1\\n      grid1 = []\\n      for i in range(4):\\n          grid1 += [f.readline()[:-1].split(\" \")]\\n          \\n      second = int(f.readline()[:-1]) - 1\\n      grid2 = []\\n      for i in range(4):\\n          grid2 += [f.readline()[:-1].split(\" \")]\\n  \\n      possible = []\\n      for num in grid1[first]:\\n          if num in grid2[second]:\\n              possible += [num]\\n  \\n      if len(possible) == 1:\\n          o.write(\"Case #%d: %s\\n\" %(t, possible[0]))\\n      elif len(possible) == 0:\\n          o.write(\"Case #%d: %s\\n\" %(t, zero_possible))\\n      else:\\n          o.write(\"Case #%d: %s\\n\" %(t, many_possible))\\n          \\n      \\n  \\n  o.close()\\n  f.close()\\n", "substitutes": {"filename": ["il", "prefix", "fp", "ames", "files", "kn", "feat", "ame", "path", "document", "ername", "file", "name", "phrase", "knife", "fn", "dll", "mble", "stem", "fd", "amer", "directory", "jl", "dyl", "utf", "download", "shaw", "nil", "til", "bf", "kl", "url", "Filename", "tty", "username", "doi", "sheet", "title", "jet", "email", "sf", "string", "ename", "wl", "database", "fil", "sole", "which", "binary", "tail"], "f": ["p", "fp", "lf", "files", "fu", "fast", "full", "of", "fm", "file", "m", "function", "d", "fx", "rf", "h", "F", "l", "fo", "fn", "http", "c", "fr", "fd", "fa", "e", "fb", "form", "os", "fw", "fc", "info", "self", "tf", "z", "r", "bf", "fe", "conf", "fs", "w", "g", "s", "v", "b", "u", "sf", "feed", "fen", "io", "inf", "df", "folder", "af"], "o": ["p", "O", "off", "mo", "op", "ow", "online", "so", "to", "oi", "ko", "file", "m", "ro", "office", "yo", "out", "ob", "oo", "y", "l", "fo", "ooo", "c", "lo", "e", "bo", "no", "do", "os", "po", "oe", "info", "output", "obj", "z", "ao", "auto", "w", "object", "b", "oa", "v", "ol", "line", "u", "n", "io", "ilo", "vo", "ou"], "T": ["Z", "O", "P", "A", "TT", "R", "S", "B", "Type", "time", "L", "TB", "F", "X", "DT", "I", "K", "TS", "E", "Num", "CT", "TN", "D", "M", "G", "UTC", "Y", "V", "C", "length", "H", "W", "N", "Time", "NT"], "many_possible": ["many__peatch", "many_cossibility", "many_peatch", "many_patch", "many_possibly", "many__patch", "many_Possibly", "many__possible", "many_Possible", "many_spowed", "many_catch", "many_spossible", "many__peossible", "many_cossibly", "many_Pausible", "many__possibility", "many_spossibility", "many__peossibly", "many_potausible", "many_Possibility", "many__peossibility", "many_peossibility", "many_Powed", "many_cossible", "many_Patch", "many_potossibility", "many_potowed", "many_peossible", "many_potossible", "many__possibly", "many_spausible", "many_pausible", "many_possibility", "many_powed", "many_peossibly"], "zero_possible": ["zero_ported", "zero_towed", "zero_Pable", "zero_tossibility", "zero_sported", "zero_Possibility", "zero_tossible", "zero_spossible", "zero_cowed", "zero_table", "zero_Ported", "zero_spossibility", "zero_pable", "zero_spable", "zero_Possible", "zero_cable", "zero_powed", "zero_Powed", "zero_cossible", "zero_corted", "zero_possibility", "zero_cossibility"], "t": ["p", "_", "ts", "m", "dt", "time", "ot", "d", "x", "h", "l", "y", "c", "e", "tt", "tower", "ta", "tf", "k", "z", "the", "type", "a", "w", "j", "s", "b", "v", "pt", "title", "u", "n", "int", "test", "total", "now"], "first": ["p", "up", "start", "full", "st", "current", "fifth", "x", "max", "next", "parent", "third", "right", "only", "middle", "front", "prev", "part", "size", "top", "a", "last", "s", "b", "th", "min", "lower", "now", "First", "one"], "grid1": ["grid6", "house2", "houseone", "line2", "range81", "row2", "range1", "lineone", "house1", "line6", "row1", "Gridone", "line0", "gridpart", "Grid2", " grid0", " gridone", "rowone", "range2", "grid0", "Grid81", "Grid1", "Gridpart", "gridone", " gridpart", "line1", " grid6", "rangeone", "linepart", "house0", "Grid6", "row81", "grid81"], "i": ["p", "it", "ui", "li", "id", "ci", "ai", "multi", "x", "l", "I", "gi", "ii", "ti", "e", "yi", "xi", "pi", "di", "r", "g", "j", "v", "ip", "u", "n", "io", "int"], "second": ["offset", "latest", "Second", "current", "fifth", "later", "next", "follow", "between", "third", "secret", "other", "final", "after", "middle", "front", "two", "secondary", "fourth", "sec", "part", "size", "future", "j", "left", "last", "low", "v", "now", "lower", "south", "seconds"], "grid2": ["age1", "module1", "grid4", "row2", "module2", "rowsecond", "gridsecond", "row5", "age2", " gridsecond", "row1", "product1", "draw5", "moduletwo", "agesecond", "row4", " grid5", "modulesecond", "drawsecond", "draw4", "producttwo", "draw2", "age4", "productsecond", " gridtwo", "grid5", " grid4", "gridtwo", "product2"], "possible": ["pausible", "psicky", "apossible", " pected", "Pausible", "ppossible", "Pected", "paossibly", "nossible", "Piped", "paected", "pected", "apossibility", "apausible", "picky", "apossibly", "Picky", "nausible", "piped", "nossibly", " possibly", "nossibility", "pential", "Possibility", "Possibly", "Pential", "psossibility", " possibility", " picky", "ppential", "Possible", "possibly", "paossibility", " piped", "niped", "possibility", "psossible", "ppossibility", "psossibly", "ppossibly", "paossible", " pential"], "num": ["offset", "nu", "unit", "id", "col", "nc", "index", "name", "nm", "m", "nb", "null", "np", "text", "multi", "x", "d", "max", "missing", "ram", "count", "nr", "inal", "code", "Num", "no", "inc", "none", "draw", "um", "tu", "nt", "nom", "atom", "size", "mult", "length", "anch", "sum", "number", "dim", "u", "nam", "loc", "block", "n", "NUM", "int", "result", "mom", "term"]}}
{"code": " \\n  def DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines ):\\n    x = []\\n    numSpaces = 0\\n    numMines = 0\\n  \\n    gridRows = max( R-2, 0 )\\n    gridCols = max( C-2, 0 )\\n  \\n    for r in xrange( 0, R ):\\n      x.append( [] )\\n      for c in xrange( 0, C ):\\n        x[ r ].append( '.' )\\n        numSpaces += 1\\n  \\n    if gridMines > 0:\\n      for r in xrange( 0, gridRows ):\\n        if numMines >= gridMines:\\n          break;\\n        for c in xrange( 0, gridCols ):\\n          x[ r ][ c ] = '*'\\n          numMines += 1\\n          numSpaces -= 1\\n          if numMines >= gridMines:\\n            break;\\n  \\n    for r in xrange( 0, R ):\\n      if sideMines <= 0:\\n        break\\n      for c in xrange( gridCols, C ):\\n        x[ r ][ c ] = '*'\\n        numMines += 1\\n        numSpaces -= 1\\n        sideMines -= 1\\n        if sideMines <= 0:\\n          break\\n  \\n    for c in xrange( 0, C ):\\n      if bottomMines <= 0:\\n        break\\n      for r in xrange( gridRows, R ):\\n        x[ r ][ c ] = '*'\\n        numMines += 1\\n        numSpaces -= 1\\n        bottomMines -= 1\\n        if bottomMines <= 0:\\n          break\\n      \\n    x[ R - 1][ C - 1 ] = 'c'\\n    \\n    if numMines != M and ( R * C ) - M != 1:\\n      print \"ERROR!!!!!!!!!!!!!!!!!!!!!!!!\"\\n      print ( R * C ) - M\\n  \\n  \\n    o = \"\"\\n  \\n    if Flip:\\n      for c in xrange( 0, C ):\\n        for r in xrange( 0, R ):\\n           o += x[ r ][ c ]\\n        o += '\\n'\\n    else:\\n      for r in xrange( 0, R ):\\n        for c in xrange( 0, C ):\\n           o += x[ r ][ c ]\\n        o += '\\n'\\n  \\n    return o[:-1] #strip the extra newline\\n  \\n  \\n  \\n  \\n  numCases = input()\\n  for case in xrange( 1, numCases + 1 ):\\n    R, C, M = [int(x) for x in raw_input().split()]\\n  \\n    Output = None\\n  \\n    Flip = C > R\\n    if Flip:\\n      temp = R\\n      R = C\\n      C = temp\\n  \\n    NonMines = ( R * C ) - M\\n    if ( NonMines == 0 ):\\n      Output = \"Impossible\"\\n    elif ( C == 1 ):\\n      gridMines = 0\\n      extraMines = M - gridMines\\n      Output = DrawMines( R, C, M, Flip, gridMines, extraMines, 0 )\\n    elif ( NonMines == 2 or  NonMines == 3 ):\\n      Output = \"Impossible\"\\n    else:\\n      maxGridCols = max( 0, C - 2 )\\n      maxGridRows = max( 0, R - 2 )\\n      gridMines = min( M, maxGridCols * maxGridRows )\\n      extraMines = M - gridMines\\n      extraPairs = ( extraMines + 1 ) / 2\\n      extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )\\n      extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )\\n      safeExtraPairs = extraPairsSide + extraPairsBottom\\n      blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )\\n      blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )\\n      blockingPairs = blockingPairsSide + blockingPairsBottom\\n      totalPairs = safeExtraPairs + blockingPairs\\n  \\n      \\n      if ( gridMines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):\\n        extraMines += 1\\n        gridMines -= 1\\n  \\n      if ( NonMines == 1 ):\\n        if extraMines % 2 != 0:\\n          extraMines += 1\\n        blockingPairsSide += 1\\n        blockingPairsBottom += 1\\n      \\n      if extraMines % 2 == 0:\\n        sideMines = 2 * ( extraPairsSide + blockingPairsSide )\\n        bottomMines = 2 * ( extraPairsBottom + blockingPairsBottom )\\n        Output = DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines )\\n      else:\\n        Output = \"Impossible\"\\n  \\n    output = \"\\n\" + Output\\n    print 'Case #' + str( case ) + ': ' + str( output )\\n", "substitutes": {"R": ["P", "A", "CR", "S", "JR", "B", "Ra", "MR", "RA", "T", "J", "L", "RR", "LR", "F", "X", "K", "RP", "ER", "RW", "Rs", "E", "IR", "NR", "RH", "Right", "DR", "RO", "D", "G", "Rh", "U", "GR", "Y", "RS", "V", "H", "Row", "RL", "RG", "Q", "W", "N", "SR", "RC", "RM", "Range"], "C": ["CC", "Z", "O", "P", "SC", "CR", "Cr", "CW", "A", "CS", "S", "B", "Cs", "CI", "COR", "JC", "T", "DC", "L", "CL", "CM", "AC", "X", "F", "K", "I", "CV", "Ch", "CU", "E", "CT", "CN", "VC", "D", "G", "NC", "EC", "MC", "U", "Y", "CA", "V", "H", "Co", "Cu", "Q", "W", "N", "RC", "CE"], "M": ["Mo", "Z", "P", "O", "A", "S", "MN", "B", "MR", "T", "m", "J", "L", "CM", "F", "X", "DM", "I", "Man", "E", "MM", "Mode", "D", "G", "MI", "MC", "U", "Y", "V", "H", "MT", "Q", "W", "N", "n", "RM"], "Flip": [" Flipped", "Lop", "Lip", "flop", " FlIP", " Flop", "Flipped", " Flide", "FLip", "flip", "FLIP", "Flop", "FLipped", "flipping", "Flide", "FLide", "Lipping", "FlIP", "flIP", " Flipping", "LIP", "Flipping", "flipped", "flide"], "gridMines": ["gridVins", "customMines", "gridMinks", "numRains", "customTains", "latFins", "latFines", "customMains", "clientmanes", "gridWines", "gridLains", "gridTine", "customMites", "clientManes", "gridTites", "gridmines", "numHomine", "gridFines", "gridVines", "gridFins", "gridTinks", "gridminks", "clientMines", "numLines", "gridTines", "customTine", "gridVined", "numLine", "gridDains", "numRine", "gridLinks", "gridDinks", "gridLine", "gridTins", "gridmanes", "clientmines", "latMins", "numHomains", "customMine", "gridFinks", "gridMains", "numHominers", "gridWites", "gridMins", "gridMine", "gridFined", "gridWains", "clientminks", "customTines", "gridTains", "gridLines", "clientMains", "numHomines", "numLains", "gridLanes", "numRiners", "gridmains", "numRines", "gridMiners", "gridDanes", "numMine", "numMiners", "gridDines", "gridManes", "latMined", "gridLites", "latFinks", "customTites", "gridLiners", "clientMinks", "latFined", "latMines", "numLiners", "numMains", "latMinks", "gridMined", "gridTined", "clientmains", "gridVinks", "gridMites", "gridWine"], "sideMines": ["sideMirails", "sidemines", "sideLines", " sideLine", " sideLlines", " sideManes", "sidePlinos", "sidePline", "ideMine", "sidemlines", "sideLine", "sideMlines", "numMucks", "sideLucks", "sidePlucks", "sideMains", "mainMines", "mainmines", "sideMunes", "sideRanes", "mainMipes", "sideMsucks", "numLines", "sideMirunes", "ideLines", "numLine", "sideRails", "sideMine", "sideMiripes", "sidemails", "sideNine", "sideRine", "sideRines", "ideLine", "numLinos", "sideRlines", "sideMucks", "sideLlines", "ideLails", "sideMsine", "sidemunes", " sideLanes", "sideMsinos", "sideLails", "mainMails", "sidemine", "sideRunes", "sideNains", "numMinos", "sideLinos", "sideMinos", "ideLains", "sidePlines", "sideManes", "ideMails", "ideMines", "sideLanes", " sideMine", "sideLains", "ideMains", "sidemanes", "numMine", "sideMirines", "sideMsines", "sideNines", "mainmunes", "mainmails", " sideLines", "mainMunes", "sideRipes", "sideMails", " sideMlines", "sidemipes", "sideNails", "numLucks", "sideMipes", "mainmipes"], "bottomMines": ["bottomHomines", "bottomDines", "sideLines", "bottomDined", "bottomFMinos", "latMining", "leftDemins", "bottomHominos", "bottomFMains", "latmins", "bottomNined", "innerMine", "innerMizes", "bottommine", "sideMains", "bottommines", "bottomFMines", "bottomWizes", "bottomLines", "bottomManes", "bottomWine", "bottomNining", "bottomNines", "bottomMine", "innermanes", "bottomMined", "bottomMining", "bottomLanes", "bottomPains", "bottommanes", "bottomMains", "leftDemanes", "bottomDemains", "bottomLides", "leftMins", "bottomPines", "bottommined", "bottomLains", "bottomWanes", "latMins", "bottomDemanes", "bottomHomides", "bottomDining", "bottomLinos", "bottomDins", "innermine", "bottommining", "bottomDemins", "bottomWines", "latmining", "bottommins", "bottomFMides", "sideLides", "sideLinos", "sideMinos", "innermines", "leftManes", "latmines", "bottomNins", "leftMines", "bottommizes", "bottomLizes", "bottomMides", "bottommains", "bottomMins", "innerMines", "sideLains", "leftDemines", "bottomMizes", "bottomHomains", "bottomDemines", "latMined", "bottomLine", "latMines", "leftDemains", "latmined", "bottomMinos", "innermizes", "bottomPins", "leftMains", "sideMides", "bottomPanes", "innerManes"], "x": ["p", "array", "case", "val", "ix", "list", "ax", "pe", "index", "q", "view", "m", "python", "d", "fx", "point", "xt", "ex", "y", "X", "f", "l", "ux", "wx", "data", "php", "e", "t", "code", "xes", "abc", "px", "xi", "xe", "k", "z", "check", "ic", "xs", "xc", "wa", "rx", "w", "g", "work", "create", " X", "xy", "b", "v", "plus", "xp", "pos", "u", "content", "on", "xml", "xx", "n", "xb", "int", "cross", "tx", "change"], "numSpaces": ["numFaces", "numMans", "numSPans", "NumSpaces", "numMaces", "numPacing", "numPlans", "numPlace", "numMacing", "numChacer", " numSpines", " numPines", "NumSPaces", "numPipes", "NumSPace", "numSPases", " numPlays", "numPaces", " numPlace", " numPipes", "numPlaces", "numSpacing", "numSpacements", "numSpans", " numPacing", "namSpacing", " numSpacer", "numSPays", "namspacing", "namSpases", "numChans", "numSpases", " numSpace", " numPacer", "numSPaces", " numPlans", " numPlaces", "numSPace", "numPlacing", "namSpace", "numPans", " numPaces", "numPlacements", "numSpace", " numSpipes", "NumSpacements", "numSpacer", "numspines", "numSpays", "numspaces", " numSpacing", "numFacing", "numspases", " numSpans", "numspace", "numspipes", "numSpines", "numPlases", "numspacements", "numMacer", "numChacing", "namspace", "numPace", " numSpays", "NumSpace", "NumSPacements", "numPlays", "numChaces", "numspacing", "namspases", "numSpipes", "namspaces", "numSPacing", "NumSPacing", "numSPacements", "numPays", "numFipes", "namSpaces", "NumSpacing", "numPacer", " numPans", "numPines", "numFines"], "numMines": ["numChine", "numTined", "numNains", "numMaces", "numChines", "numberMains", "matMsines", "multiMines", "numPine", "numMsipes", "numMipes", "numTine", "numbermines", "numPipes", "numTains", "numberMine", "matMines", "numLined", "numPaces", "numChments", "matMaces", "NumMined", "numbermains", "matMsaces", "numDine", "nummments", " numLipes", "numNipes", "nummine", "numMments", " numLains", " numLines", "NumLines", "NumLined", "numLines", "NumLine", "NumLipes", "numPined", " numMine", "nummains", "numLine", " numLine", "NumMaces", "NumMines", "multiMinks", "numNine", "numDipes", "numNiners", " numMipes", "numberMines", "numDains", "numPinks", "NumLaces", "multiMine", "NumLains", "numChipes", "multiDine", "multiDines", "matMine", "multiMains", "numPains", "numDaces", "nummines", "numminers", " numMains", "numLains", "numTines", "numberminers", "NumLments", "numChains", "numMine", "numMiners", "numbermine", "numLments", "multiDinks", "numMined", "NumMine", "numLaces", "numChaces", "multiDains", "matMsipes", "numMsines", "NumMains", "numMains", "numLiners", "numLipes", "numMinks", "matMipes", "numberMiners", "NumMipes", "numNines", "numMsine", "matMsine", "NumMments", "numDines", "numDinks", "numLinks", "numMsaces", "numPines"], "gridRows": ["gridRocks", "numLries", "gridRhOWS", "gridRhaces", "gridNays", "gridLays", "GridRaces", "gridColries", "gridNows", "gridRays", "gridLaces", "GridCocks", "gridLOWS", "GridCows", "gridFaces", "gridCows", "numLrows", "numLows", "gridNrows", "numLaces", "GridRows", "GridCaces", "gridRhows", "numROWS", "gridColrows", "gridLries", "gridNaces", "gridFows", "gridNries", "gridROWS", "gridColays", "gridRrows", "GridRocks", "numRaces", "gridFOWS", "gridCOWS", "gridCaces", "numRries", "numRays", "gridRries", "GridROWS", "gridFocks", "gridColows", "numLOWS", "gridLows", "gridCocks", "numLays", "GridCOWS", "numRrows", "gridNOWS", "gridRaces", "gridLrows", "gridRhocks", "numRows"], "gridCols": ["updateColl", "numCols", "gridWidths", "groupCOLn", "gridColumnl", "numcolows", "gridColk", "gridColumnn", "gridCOLows", "updateColw", "gridcols", "gridCOLw", "updateCOLw", "gridColl", "gridcoln", "gridCOLl", "gridCold", "gridColn", "groupCols", "updateCOLl", "groupColn", "gridcolws", "gridWidthl", "gridcolows", "gridCOLd", "groupCold", "gridCOLn", "gridColumnk", "updateCols", "gridColws", "gridWidthk", "gridColumnws", "groupCOLws", "gridOptw", "groupCOLd", "gridOpts", "gridColw", "gridCOLk", "updateColk", "gridColows", "gridWidthw", "gridColumns", "updateCOLk", "gridcolw", "gridCOLs", "groupCOLs", "numColows", "groupColws", "gridColumnd", "numcolw", "gridcold", "gridCOLws", "gridOptows", "numColw", "gridColumnw", "numcols", "updateCOLs"], "r": ["err", "p", "rb", "br", "ver", "dr", "range", "run", "rc", "oc", "ar", "gr", "m", "ro", "d", "rf", "h", "l", "ru", "f", "cr", "fr", "nr", "right", "e", "ir", "t", "ur", "i", "rr", "ner", "k", "z", "rar", "rg", "rn", "a", "w", "g", "j", "row", "b", "sr", "v", "re", "s", "u", "pr", "lr", "resource", "n", "rs", "er", "yr"], "c": ["p", "cu", "case", "ci", "ch", "cc", "unc", "cor", "col", "cf", "lc", "nc", "dc", "rc", "cn", "sc", "q", "ar", "m", "name", "oc", "d", "arc", "h", "l", "y", "f", "cr", "count", "cp", "uc", "e", "ir", "t", "code", "rec", "ur", "cache", "i", "ce", "fc", "ec", "k", "z", "type", "cat", "cm", "rn", "co", "w", "cl", "g", "a", "s", "b", "v", "u", "n", "cs", "ct", "cur", "pc", "ac"], "o": ["p", "O", "off", "mo", "ho", "op", " O", "so", "to", "oc", "m", "ro", "d", "yo", "h", " i", "oo", "ando", "f", "out", "y", "l", "ooo", "e", "bo", "t", " yo", "no", "do", "i", "po", "os", " m", "obj", "k", "go", "auto", "a", "co", "object", "b", "oid", "v", "oa", "u", "vo", "n", "io", "error", "lo", "one"]}}
{"code": " \\n  numCases = input()\\n  for case in range( 1, numCases + 1 ):\\n    row1 = input()\\n    grid1 = []\\n    for i in range( 0, 4 ):\\n      grid1.append( raw_input().split() )\\n  \\n    cards = grid1[ row1 - 1 ]\\n  \\n    row2 = input()\\n    grid2 = []\\n    for i in range( 0, 4 ):\\n      grid2.append( raw_input().split() )\\n  \\n    bad = True\\n        \\n    cards2 = grid2[ row2 - 1 ]\\n  \\n    numPossibleAnswers = 0\\n    for card in cards:\\n      for card2 in cards2:\\n        if ( card == card2 ):\\n          if numPossibleAnswers == 0:\\n            output = card\\n          numPossibleAnswers += 1\\n          break\\n  \\n    if numPossibleAnswers == 0:\\n      output = \"Volunteer cheated!\"\\n    elif numPossibleAnswers > 1:\\n      output = \"Bad magician!\"\\n  \\n    print 'Case #' + str( case ) + ': ' + str( output )\\n", "substitutes": {"numCases": ["numAcasing", "numCsases", "numCase", "numChases", "numCased", "numAcases", "numScased", "numChodes", "numcased", " numcase", "numCsasing", "numChased", " numcasing", "numScase", "numScasing", "numCasing", " numcased", "numChasing", "numScases", "numCsased", " numCased", " numCodes", " numCsases", " numcases", "numcases", " numCsodes", "numAcodes", "numcase", "numCsodes", "numcasing", " numCsasing", " numCsased", " numCasing", "numCodes", " numCase", "numChase", "numAcased"], "case": ["address", "lc", "division", "config", "catch", "name", "ice", "x", "count", "c", "day", "ace", "core", "code", "choice", "rule", "charge", "num", "mode", "ce", "trial", "shape", "cell", "sequence", "match", "Case", "row", "instance", "line", "number", "ase", "page", "result", "test", "section", "word", "error", "cases"], "row1": ["row3", "card1", " row01", "range01", "range1", "rowsone", "low1", "grid01", "lowone", "low01", "rows1", "rowone", "card01", "rows01", "row01", " row3", "rangeone", "grid3", "card3"], "grid1": ["rowOne", "row3", "card1", "Grid3", "cell1", "cardOne", " grid81", " gridOne", "cell2", " grid01", "grid01", "Grid2", " grid3", "gridOne", " gridone", "rowone", "card01", "Grid81", "Grid1", "gridone", "row01", "cellOne", "cellone", "row81", "grid81", "grid3"], "i": ["p", "it", "o", "li", "id", "ci", "index", "d", "ai", "x", "ind", "l", "f", "I", "gi", "ii", "c", "ti", "e", "num", "di", "pi", "r", "a", "g", "j", "s", "b", "v", "ip", "u", "int", "iu"], "cards": ["caps", "tests", "rooms", "features", "ards", "files", "lines", "reports", "lc", "lists", "pieces", "codes", "games", "fields", "ids", "parents", "cuts", "names", "items", "ays", "events", "checks", "ends", "frames", "rows", "rules", "cats", "letters", "groups", "orders", "words", "cells", "comments", "balls", "changes", "days", "cases", "breaks"], "row2": [" rowTwo", "row3", "cell02", "cellTwo", "rows3", "rowsTwo", "row82", "row02", "cell2", "raw02", "row4", "rows2", " row82", "rawTwo", "cell3", "raw2", "rows4", "cell4", "cell82", " row3", "rowTwo", " row4", "raw82", " row02"], "grid2": ["graph2", "groupTwo", "house2", "cell1", "cellTwo", "grid4", "group2", "rowsecond", "hangTwo", "cellsecond", "gridsecond", "graph1", " gridsecond", "house3", "cell2", "group3", "graphsecond", "hangsecond", "houseTwo", " grid3", "hang1", "gridTwo", " gridTwo", "graphTwo", "rowTwo", "group4", " grid4", "house4", "hang2", "grid3"], "bad": ["err", "start", "valid", "problem", "Bad", "broken", "log", "fail", "kill", "good", "no", "negative", "better", "wrong", "debug", "ok", "ad", "best", " good", "big", "nice", "got", "diff", "pos", "bug", "clean", "error", " Bad"], "cards2": [" cardstwo", "cardtwo", "card1", "cards4", " cards1", " card1", "roads2", " card3", " cards4", "cardstwo", "card4", "cards1", " card4", "roads4", "roads1", "roadstwo", " cards3", "cards3", "card3"], "numPossibleAnswers": ["numPossiblyEnalyses", "numPossibleACswers", "numPossibilityANAnswer", "numPossibleAnches", "numPossibleAnnalyses", "numPossibleCorrectches", "numPossibleEnimates", "numPantAnAnswer", "numPossibleCorrectAnswer", "numPossibleAnnAnswer", "numPossibleAnAnswer", "numPossibleCorrectimates", "numPossiblyEnimates", "numPossibleAnnimates", "numPossibleAcches", "numPossibleAcswers", "numPossibleAnnswers", "numPossibleEnAnswer", "numPantAnnalyses", "numPossibleAcimates", "numPossibleACimates", "numPantAnswers", "numPossibilityANswers", "numPossibleAcAnswer", "numPantAnnAnswer", "numPossibleAnalyses", "numPossibilityAnimates", "numPossibilityAnswers", "numPossibleEnalyses", "numPantAnnswers", "numPossibilityAcAnswer", "numPossibleAnnches", "numPossibleAnimates", "numPossibleANswers", "numPossibilityAnches", "numPossibilityAnAnswer", "numPossibleACalyses", "numPossiblyAnswers", "numPossiblyAnalyses", "numPossibilityAcches", "numPossibleEnswers", "numPossiblyEnswers", "numPossibleCorrectswers", "numPantAnalyses", "numPossibilityAcimates", "numPossibleAcalyses", "numPossiblyAnimates", "numPossibilityAcswers", "numPossibleANAnswer"], "card": ["gen", "comment", "div", "id", "list", "contact", "group", "col", "cf", "category", "catch", "index", "order", "d", "arc", "x", "parent", "max", "record", "custom", "count", "character", "add", "c", "day", "default", "rule", "code", "charge", "num", "draw", "cell", "input", "check", "match", "cat", "carry", "cd", "field", "row", "line", "number", "char", "Card", "ard", "bug", "letter", "result", "int", "word"], "card2": ["Card4", "Card0", "card1", "cards4", "Card_", " card0", " card1", "cards_", "card0", " card_", "card4", "cards1", "Card1", "card_", "Card2", " card4", "cards0"], "output": ["format", "conference", "response", "new", "four", "unit", "comment", "outer", "category", "config", "current", "log", "console", "null", "function", "text", "double", "write", "out", "again", "message", "hide", "code", "reason", "cut", "ln", "display", "draw", "wrong", "debug", "control", "Output", "module", "note", "input", "summary", "column", "contract", "warning", "object", "model", "number", "complete", "operation", "put", "production", "string", "come", "letter", "error", "style", "result", "word", "ou", "ignore"]}}
{"code": " \\n  def mines_refill(board, xr, xc, nfree):\\n      to_refill = xr*xc - nfree\\n      for r in reversed(range(2, xr)):\\n          for c in reversed(range(2, xc)):\\n              if not to_refill:\\n                  return\\n              assert(board[r][c] == '.')\\n              board[r][c] = '*'\\n              to_refill -= 1\\n      for r in reversed(range(xr)):\\n          for c in reversed(range(xc)):\\n              if not to_refill:\\n                  return\\n              if board[r][c] == '.':\\n                  board[r][c] = '*'\\n                  to_refill -= 1\\n      assert(to_refill == 0)\\n      \\n  def generate_board(nrows, ncols, nmines):\\n      nfree = nrows*ncols - nmines\\n      xr=1; xc=1;\\n      while True:\\n          if xr*xc >= nfree:\\n              break\\n          if xr < nrows:\\n              xr += 1\\n          if xr*xc >= nfree:\\n              break\\n          if xc < ncols:\\n              xc += 1\\n      board = [['*' for c in range(ncols)] for r in range(nrows)]\\n      for r in range(xr):\\n          for c in range(xc):\\n              board[r][c] = '.'\\n      mines_refill(board, xr, xc, nfree)\\n      board[0][0] = 'c'\\n      return board\\n          \\n  def find_click_point(board):\\n      nrows = len(board)\\n      ncols = len(board[0])\\n      for r in range(nrows):\\n          for c in range(ncols):\\n              if board[r][c] == 'c':\\n                  return (r,c)\\n      raise ValueError('Start point not present')\\n  \\n  def enum_neighbour_coords(r0, c0, nrows, ncols):\\n      for r in range(r0-1, r0+2):\\n          if r<0 or r>=nrows:\\n              continue\\n          for c in range(c0-1, c0+2):\\n              if c<0 or c>=ncols:\\n                  continue\\n              yield (r,c)\\n  \\n  def click_board(board, click_coords):\\n      nrows = len(board)\\n      ncols = len(board[0])\\n      points = [click_coords]\\n      while points:\\n          r0,c0 = points.pop()\\n          mines_cnt = 0\\n          for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\\n              if board[r][c] == '*':\\n                  mines_cnt += 1\\n          board[r0][c0] = str(mines_cnt)\\n          if not mines_cnt:\\n              for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\\n                  if board[r][c] == '.':\\n                      points.append((r,c))\\n  \\n  def all_fields_checked(board):\\n      nrows = len(board)\\n      ncols = len(board[0])\\n      for r in range(nrows):\\n          for c in range(ncols):\\n              if board[r][c] == '.':\\n                  return False\\n      return True\\n  \\n  def is_board_oneclick(original_board):\\n      board = [row[:] for row in original_board] # deep copy\\n      assert(board[0][0] == 'c')\\n      r,c = find_click_point(board)\\n      click_board(board, (r,c))\\n      is_oneclick = all_fields_checked(board)\\n      return is_oneclick\\n  \\n  def board2result(board):\\n      return [''.join(row) for row in board]\\n  \\n  def process_case(nrows, ncols, nmines):\\n      board = generate_board(nrows, ncols, nmines)\\n      if is_board_oneclick(board):\\n          result = board2result(board)\\n      else:\\n          result = ['Impossible']\\n      return result\\n  \\n  def result_gen(lines):\\n      ncases = int(next(lines))\\n      for ci in range(1,ncases+1):\\n          R, C, M = line_of_numbers(next(lines))\\n          result = process_case(R, C, M)\\n          yield 'Case #{0}:\\n'.format(ci, result)\\n          for res_line in result:\\n              yield res_line + '\\n'\\n      \\n  def line_of_numbers(s):\\n      return [int(sub) for sub in s.split()]\\n  \\n  def input_gen(f_in):\\n      for line in f_in:\\n          if line.endswith('\\n'):\\n              line = line[:-1]\\n          yield line\\n  \\n  def start(basename):\\n      infile = basename + '.in'\\n      outfile = basename + '.out'\\n      f_in = open(infile, 'r')\\n      f_out = open(outfile, 'w')\\n      f_out.writelines(result_gen(input_gen(f_in)))\\n      f_in.close()\\n      f_out.close()\\n  \\n  start('C-small-attempt0')\\n", "substitutes": {"board": ["stroke", "array", "node", "image", "case", "all", "list", "layout", "index", "entry", "stream", "head", "player", "when", "boards", "day", "room", "code", "ward", "frame", "draw", "join", "control", "self", "ban", "buffer", "length", "panel", "bug", "clean", "home", "comment", "plan", "ko", "view", "du", "body", "card", "core", "ack", "table", "back", "form", "wall", "hole", "sequence", "video", "Board", "window", "object", "flow", "pos", "number", "result", "pool", "ide", "boarding", "config", "function", "que", "d", "custom", "flo", "bo", "ck", "post", "cell", "hub", "cart", "phone", "line", "word", "coll", "box", "child", "new", "square", "dom", " clipboard", "group", "deck", "rank", "channel", "loop", "null", "foot", "rule", "oard", "game", "ault", "rows", "che", "g", "server", "model", "design", "boy", "land", "bank", "block", " dashboard", "lane"], "xr": ["xra", "axnr", "ysr", " Xr", "zrt", "winre", "sexpr", "sexr", "uxre", "xrb", "wwrs", " xrs", "wwr", "xxre", " XR", "axr", "xer", "oxrs", "ynr", "xnr", "txr", "yer", "wxrs", " Xrb", "wxsr", "wxrb", "yra", "xxrs", "exnr", "wxnr", "dxra", "Xra", " Xrs", "xsr", "axrs", "zr", " xnor", "uxrt", "exr", "axrb", "axre", "nexr", "oxsr", "rxer", "Xrb", " xpr", "xpr", "dxr", "uxr", "ypr", "uxrs", "nexrt", "xnor", "xrt", "Xrs", "wwra", "sexrs", "dxer", "rxrs", "xR", "dxre", "xxr", "wxR", "rxr", "exrb", "Xer", "rxnor", "exrt", "yr", "rxnr", "winrs", "wxr", " xer", "Xpr", "dxrs", "nexrb", " xre", "xrs", "txnr", "winr", "yrs", "dxnor", "wxpr", " xrb", "nexnr", "xre", "oxr", "axra", "zrb", "axpr", "txrs", "oxra", "Xr", "xxrt", "rxpr", "Xnr", " xsr", " xra", "winrt", "sexsr", " xR", "txpr", "znr", "yrb"], "xc": ["cu", "zx", "rb", "ci", "unc", "cf", "lc", "dc", "xf", "nc", "wy", "rc", "cmp", "oc", "x", "xt", "xa", "wx", "icc", "dq", "cr", "uc", "vc", "fb", "adr", "xes", "rec", "abc", "vin", "fc", "tc", "xe", "usc", "rh", "xd", "sec", "cin", "rt", "cre", "ic", "con", "exc", "xs", "cb", "rx", "bc", "wb", "xp", "ctx", "ctrl", "loc", "xb", "ct", "ince", "enc", "pc", "ac"], "nfree": ["nfe", "nused", "wfree", "unfree", "Nfloor", "Nfree", "nskip", "nnfree", "rnused", "ntgrid", "wfe", "nanfree", " nfe", "Nused", "ntFree", "lfree", " nskip", "ntfree", "Nvalid", " nvalid", "lFree", "wFree", "lused", " nfine", "unFree", "nleft", "Nfe", "nnFree", "rnfree", "nanFree", "NFree", "ntfine", " nfloor", "nfine", " nleft", "nanleft", "nvalid", " nused", "nfloor", "wrows", "ungrid", "unfine", "Nskip", "rnfloor", "lvalid", "nFree", " nFree", "ngrid", " ngrid", "rnFree", "Nleft", "nnused", "Nrows", "nnskip", "nanused"], "to_refill": ["to_reilling", "to_reiller", "to_fill", "to_compill", "to_rewul", "to_reilled", "to_relilling", "to_Refilled", "to_bfail", "to_rewiller", "to_refilled", "to_bfil", "to_reul", "to_reail", "to_bfill", "to_reills", "to_lfil", "to_reil", "to_relill", "to_ffill", "to_filler", "to_Refil", "to_fil", "to_reffill", "to_relil", "to_compilling", "to_compail", "to_relul", "to_rewill", "to_reful", "to_rewil", "to_fills", "to_refil", "to_bfiller", "to_compilled", "to_reill", "to_refail", "to_filling", "to_compil", "to_refills", "to_refiller", "to_reliller", "to_bfilling", "to_Refilling", "to_refilling", "to_lffill", "to_relail", "to_lfills", "to_compiller", "to_Refill", "to_lfill"], "r": ["err", "p", "o", "br", "R", "rb", "dr", "ra", "range", "pair", "rc", "q", "ar", "m", "gr", "ro", "mr", "kr", "d", "x", "rf", "h", "arc", "l", "ru", "cr", "f", "wr", "rl", "rd", "fr", "right", "nr", "e", "ir", "t", "str", "ur", "rr", "self", "ner", "nor", "rh", "z", "rt", "rg", "rn", "a", "w", "g", "j", "re", "b", "v", "sr", "s", "hr", "attr", "u", "pr", "lr", "resource", "n", "rs", "er", "vr", "result", "yr"], "c": ["ch", "cc", "lc", "name", "arc", "h", "y", "cr", "uc", "vc", "code", "z", "ic", "con", "cm", "w", "v", "u", "ca", "cs", "ac", "cy", "unc", "dc", "nc", "oc", "m", "rec", "i", "fc", "C", "n", "ct", "cu", "p", "ci", "col", "config", "cn", "ar", "d", "f", "e", "t", "cent", "chain", "ur", "ce", "cl", "enc", "pc", "o", "cv", "cf", "current", "rc", "sc", "q", "x", "l", "cont", "cp", "cache", "ec", "k", "cat", "type", "co", "g", "s", "b", "mc", "cur"], "nrows": [" nrs", "maxrows", "maxows", "Nows", "nonblocks", " nrow", "Nfree", "numows", "lrow", "Ncells", "numblocks", "lcells", "numrow", "nefree", "ncows", "nrs", "ncrows", "Nblocks", "ncrow", "numrows", "nccells", "ncells", "neblocks", "Nrows", "lrows", " nows", "nrow", "nonrows", "maxblocks", "nerow", " ncells", "lows", "nonows", "numfree", "ners", "Nrs", "nonfree", "Nrow", "numcells", " nblocks", "maxcells", "neows", "nows", "nerows", "nblocks"], "ncols": ["NColi", "nColts", "nColths", "ncolths", "ncoles", "Ncolths", "nfild", "ncolls", "nColows", "ndrawes", " ncolumnters", " ncolumnts", "NColths", "Ncoli", "ncolsb", "nwells", "nllops", "ndraws", "nlls", "ncolumnses", "nwellts", "Ncolses", "Ncolumns", "Ncolumnts", "nColses", "Ncolumnses", "ncolows", " ncolumnsb", "ncolops", "ncollows", "ncoln", "Ncolumnows", "ncolld", "ncold", "numcoles", "nColsi", "ncoli", "ncollts", "ncolsi", "ncolses", "ngallts", "npools", "nwellsb", " ncolsi", "Ncolts", "ncolumnters", "ncolumns", "ncolumnd", "npoolsi", " ncolumnsi", " ncolumnops", "npoolows", "ncolumnops", "numcols", "ncolumnts", "ncolles", "ncolumnows", " ncolumnows", " ncolters", "nfils", "nwellters", "nColes", "nfiln", "Ncolows", " ncolsb", "NColes", "ncolumnn", " ncolows", "nllses", "Ncolumnd", "numcolts", " ncolumns", "nfilops", "ncolumnes", "Ncoln", "nfiles", "nllows", "nfilses", "Ncold", "NColses", "numCols", "ngallters", "numCold", "ncolumnsi", "ncolumnths", "nColi", "Ncolumnops", "numcold", "Ncolumnn", "ncolumnsb", "numColes", "ndrawths", "ngallsb", "nColops", "ndrawi", "ncolters", "numColts", "ngalls", "NCols", "ncolumni", "nCols", "Ncoles", " ncolts", "Ncolops", " ncolops", "Ncolumnes", "Ncols", "npoolops", "nCold", "ncolts", "nfili"], "nmines": ["nconnectes", "numlins", "nmined", "nconnectxes", "ncoles", "numlinxes", "Nmins", "ncolxes", "numlines", "nminss", "ncolations", "nminsed", "nlinions", "nmins", "nummins", "Ncolations", "numminions", "numlinions", "Nmined", "Ncoled", "nlinxes", "npris", "ncoled", "Nmines", "nlins", "nminations", "ncolions", "Ncoles", "nummines", "numminxes", "npriations", "nminions", "nminses", "npries", "nconnections", "nminsations", "Ncols", "nlines", "npried", "nminxes", "nconnects", "Nminations"], "r0": ["x1", "ruii", "r50", "pr0", "x0", "ru50", " rold", "c02", " r100", "ra0", " r50", "c1", "h0", "ruold", "r1", "rii", " r1", "rold", "x02", "r100", "ra100", "r02", "prold", "pr50", "h1", "ra1", " rii", "c100", "ru0", "h02", "prii"], "c0": ["cne", "h50", "c00", "cr0", "f00", "col18", "y50", " c00", "c50", "f90", "p63", " c90", "y63", " cne", "colne", "p50", "cr00", "h63", "c18", "con18", "h0", "f0", "c10", "con0", "y0", " c10", "p0", "c63", "col10", "con10", "c90", "cr63", "cr90", "f63", "conne", " c63", " c18", "col0"]}}
{"code": " \\n  def process_case(row1, tab1, row2, tab2):\\n      s1 = set(tab1[row1])\\n      s2 = set(tab2[row2])\\n      xset = s1 & s2\\n      if len(xset) == 1:\\n          result = xset.pop()\\n      elif len(xset) == 0:\\n          result = 'Volunteer cheated!'\\n      else:\\n          result = 'Bad magician!'\\n      return result\\n  \\n  def result_gen(lines):\\n      ncases = int(next(lines))\\n      for ci in range(1,ncases+1):\\n          row1 = int(next(lines)) - 1\\n          tab1 = [line_of_numbers(next(lines)) for i in range(4)]\\n          row2 = int(next(lines)) - 1\\n          tab2 = [line_of_numbers(next(lines)) for i in range(4)]\\n          result = process_case(row1, tab1, row2, tab2)\\n          yield 'Case #{0}: {1}\\n'.format(ci, result)\\n      \\n  def line_of_numbers(s):\\n      return [int(sub) for sub in s.split()]\\n  \\n  def input_gen(f_in):\\n      for line in f_in:\\n          if line.endswith('\\n'):\\n              line = line[:-1]\\n          yield line\\n  \\n  def start(basename):\\n      infile = basename + '.in'\\n      outfile = basename + '.out'\\n      f_in = open(infile, 'r')\\n      f_out = open(outfile, 'w')\\n      f_out.writelines(result_gen(input_gen(f_in)))\\n      f_in.close()\\n      f_out.close()\\n  \\n  start('A-small-attempt0')\\n", "substitutes": {"row1": ["rowOne", "col01", "wardOne", "col2", "pageOne", "Row01", "cell1", "tabOne", " row01", "range01", "RowOne", "Rowone", "range1", "Row1", "cell2", "tab01", " rowOne", "col1", "wardone", "page1", "tabone", " rowone", "rowone", "pageone", "page01", "ward1", "rangeOne", "row01", "cellOne", "rangeone", "cellone", "cell01"], "tab1": ["rowOne", "col2", "tabOne", "row0", "cell1", "tab3", " tab0", "Tab2", "table0", "Tab1", "tableup", "tab0", "cell2", "tableone", " tabup", "table3", "col1", "table1", "tabone", "table2", "TabOne", " tab3", "Tabone", "cellup", "colOne", "rowone", "cell3", "tabup", " tabone", "tableOne", "cellOne", " tabOne", "cellone", "colone", "col0"], "row2": [" rowTwo", "ro0", "col2", " rowb", "cell02", "round02", "Row182", " row182", "row0", "tabb", "ow4", "row20", "owTwo", " rowtwo", "rowtwo", "tab0", "row02", "tab4", "ow182", "round2", "cell0", "cell2", "roundtwo", "colb", "col1", "row4", "col4", "ow2", "round4", "rowb", "RowTwo", "ro02", "tab20", "tab02", "Row4", "row182", "rowTwo", "ro2", "ro20", " row4", " row02", "tabtwo", "Row2", "cell20"], "tab2": ["circ3", "col2", "tabsecond", "tabb", "tab3", "tabTwo", "Tab2", "Tabsecond", "coltwo", "Tab1", "scrolltwo", "scroll2", "absb", "circ2", "row02", " tabsecond", "tab4", "col1", "abs02", " tabTwo", "table2", "circsecond", "tableb", "row4", " tab3", "rowb", "table02", "Tab3", "tab02", "circ1", " tab4", " tabtwo", "scrollTwo", "scroll4", "colTwo", "scroll1", "tabtwo", "abs2", "rowtwo"], "s1": ["p1", "ns0", "g01", " s01", "ns1", "p01", "ns3", "s3", " s0", "ses3", "s0", "g0", "g3", "ses01", "s01", "ns01", "ses1", "p3", " s3", "g1"], "s2": ["ss0", "p1", "ss2", "S2", "S1", " s0", "p2", "s02", "s0", "S0", "sTwo", "f2", "f0", "p0", "f1", "ss1", "pTwo", " s02", "ssTwo", " sTwo", "S02", "f02"], "xset": ["exmatch", "rxlist", "xSet", "exset", "yxint", "yxset", "sparse", "xparse", "sset", "wparse", "xpSet", "xpmatch", "xpset", "XSet", "xcase", " xcheck", "xtest", " xparse", " xSet", "ymatch", "ySet", "xint", "xlist", "xmatch", "yxmatch", "ysets", "sSet", "rxcase", "xcheck", "Xcheck", "Xint", " xcase", " xtest", "xpsets", "wlist", "scheck", "Xmatch", "rxparse", "rxset", "yset", "yxtest", "xsets", "Xtest", "Xset", " xlist", "wset", " xint", "exsets", "exSet", "Xparse", "wcase", " xmatch"], "result": ["err", "replace", "date", "format", "desc", "response", "comment", "res", "case", "main", "list", "score", "report", "rc", "spec", "su", "name", "function", "text", "success", "grade", "true", "counter", "message", "default", "data", "answer", "end", "code", "reason", "final", "package", "status", "dict", "output", "description", " Result", "ult", "info", "sign", "r", "match", "value", "df", "warning", "Result", "row", "Results", "diff", "root", "compl", "content", "number", "page", "cup", "error", "test", "results", "term"], "lines": ["notes", "les", "steps", "bands", "forms", "files", "sheets", "ls", "runs", "lin", "lc", "scenes", "mails", "limits", "states", "users", "ns", "ins", "books", "codes", "styles", "text", "pins", "strings", "es", "locks", "faces", "cycles", "points", "breaks", "items", "flows", "models", "lins", "frames", "objects", "rows", "posts", "verts", "rules", "lined", "sections", "los", "lights", "holes", "groups", "blocks", "liners", "ines", "words", "cells", "balls", "shows", "results", "rings", "cases", "pages"], "ncases": ["nase", "incased", "NCasing", "necase", "ncased", "nicase", "ncase", "NCamps", "dcases", "necased", "necasing", "NCase", "dcase", "nases", "incasing", "incases", "ncasing", "NCases", "dcamps", "necases", "nasing", "nicased", "ncamps", "dcasing", "nicasing", "nicases", "incase", "namps"], "ci": ["cu", "li", "ix", "cc", "col", "cf", "lc", "nc", "iii", "cci", "rc", "sc", "entry", "ice", "cli", "ini", "d", "ai", "slice", "ind", "cont", "cr", "ii", "c", "code", "yi", "zi", "ie", "num", "uri", "di", "xi", "cin", "cat", "ic", "cm", "co", "a", "mi", "u", "loc", "ca", "cod", "inf", "si", "cia", "ou"], "i": ["il", "it", "_", "li", "id", "ai", "x", "bi", "ind", "l", "f", "I", "ii", "c", "ti", "e", "di", "pi", "ic", "im", "ip", "u", "qi", "n", "si", "int", "inf", "iu"], "s": ["p", "tests", "single", "ls", "ws", "S", "ples", "ss", "sb", "ches", "spec", "sc", "su", "second", "sing", "space", "strings", "l", "c", "e", "ses", "sets", "items", "series", "sites", "sup", "sequence", "sec", "r", "a", "g", "sg", "b", "words", "cells", "comments", "string", "ments", "n", "si"], "sub": ["desc", "child", "case", "id", "sd", "sim", " subs", "ss", "sb", "seq", "spec", "sc", "su", "struct", "name", "suff", "src", "sing", "text", " Sub", "search", "uc", "code", "ses", "num", "sup", "cell", "sec", "type", "ub", " subst", "sum", "small", "number", "loc", "string", "sl", "section", "test", "Sub", "slice", "sel"], "f_in": [" f_ini", "f24ini", "fockagain", "f_In", "f__out", "c_In", "f___out", "f_login", "f__in", "input_In", "f_IN", "fayout", "fockout", "fayin", "c__login", "f24line", "fayinner", "f___in", " f_IN", "c__in", "focklogin", "c_login", " f_ins", "f24out", "f_inner", " f_line", "c_out", " f_inner", "f_ini", "f_line", "f24in", "f_again", "input_again", "f___IN", "f__In", "input_out", "fockIn", " f_nin", "input_in", "f_ins", "fayins", "c__In", "f_nin", "f__login", "c_in", "f___nin", "c__out", "fockin"], "line": ["lf", "li", "comment", "case", "unit", "link", " Line", "all", "lin", "lc", "ine", "range", "log", "entry", " inline", "name", "file", "Line", "text", "base", "out", "next", "l", "point", "f", "message", "liner", "str", "end", "e", "code", "data", "frame", "output", "lined", "LINE", "cell", "part", "input", "inline", "value", "buffer", "object", "row", "number", "string", "page", "block", "item", "section", "error", "n", "word", "source", "change"], "basename": ["binemark", "Basemark", "basemark", "basame", "baseette", "binename", "Baseline", "baseeme", "batame", "batename", "basname", "baseeline", "baseename", "baseline", " baseme", "batemark", " basette", "binname", "binette", " basame", "biname", "bineme", "Basname", " baseline", "baseame", "batname", "Baseme", "basette", "Basename", "baseme", "Basame"], "infile": ["infilename", "outbase", "outdata", " inf", "outfilename", " indata", "outstream", "substream", "outf", "insfile", "subdata", "inbase", " infilename", "insfilename", "instream", "subfilename", "insf", "subfile", " instream", " inbase", "indata", "insbase", "inf"], "outfile": ["outfolder", "inputtemplate", "OUTfile", " outFile", "intemplate", "outFile", "infilename", "OUTFile", "outfilename", "inputfolder", "againfile", "OUTlive", " outfolder", "outtemplate", "outlive", "againFile", "againfolder", "OUTfolder", " outtemplate", "inputfilename", " outlive", " outfilename", "againlive", "inputfile", "infolder"], "f_out": ["fockoutput", "f_Out", " f_nin", " f_Out", " f_again", "fockout", " f_w", "fockw", "f_w", "flexoutput", " f_off", "f_nin", "f_again", " f_output", "focknin", "f_off", "fockoff", "flexout", "flexin", "f_output", "fockin", "flexnin"]}}
{"code": " \\n  \\n  \\n  \\n  \\n  \\n  \\n  class memoize(object):\\n     \"\"\"Decorator. Caches a function's return value each time it is called.\\n     If called later with the same arguments, the cached value is returned\\n     (not reevaluated).\\n     \"\"\"\\n     def __init__(self, func):\\n        self.func = func\\n        self.cache = {}\\n     def __call__(self, *args):\\n        if not isinstance(args, collections.Hashable):\\n           return self.func(*args)\\n        if args in self.cache:\\n           return self.cache[args]\\n        else:\\n           value = self.func(*args)\\n           self.cache[args] = value\\n           return value\\n     def __repr__(self):\\n        '''Return the function's docstring.'''\\n        return self.func.__doc__\\n     def __get__(self, obj, objtype):\\n        '''Support instance methods.'''\\n        return functools.partial(self.__call__, obj)\\n  \\n  \\n  def precalculate():\\n      \"\"\"Perform any calculations that need to be performed before the main path\\n      (e.g., preparing lookup tables, etc.)\\n      \\n      N.B. Make sure you make any important variables global so that other\\n      functions can access them.\\n      \"\"\"\\n      pass\\n  \\n  def read_input(infile):\\n      \"\"\"This function should take an open input file, load in all of the\\n      relevant information for a single case of the problem, and output it\\n      as a single object.    \\n      \"\"\"\\n      def read_int():\\n          return int(infile.readline().strip())\\n      def read_ints():\\n          return np.array(infile.readline().split(), dtype=int)\\n      def read_bigints(): #For ints that won't fit directly in an int32 array\\n          line = infile.readline().split()\\n          return np.array(map(lambda x: int(x), line))\\n      def read_float():\\n          return float(infile.readline().strip())\\n      def read_floats():\\n          return np.array(infile.readline().split(), dtype=float)\\n      def read_string():\\n          return infile.readline().strip()\\n      def read_strings():\\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\\n      \\n      R, C, M = read_ints()\\n      \\n      return R, C, M\\n  \\n  def solve_case(case):\\n      \"\"\"Take the input data (structured in case) and perform any necessary\\n      calculations to obtain the desired output, formatted as the appropriate\\n      string.    \\n      \"\"\"\\n      R, C, M = case\\n      \\n      free = R * C - M\\n      assert free >= 1\\n      \\n      board = np.zeros((R, C), dtype=int) - 1\\n      \\n      def write_board(board):\\n          d = {0:'.', 1:'c', 2:'*'}\\n          s = \"\\n\"\\n          for row in board:\\n              for num in row:\\n                  try:\\n                      s += d[num]\\n                  except KeyError:\\n                      raise ValueError(\"Board not filled in!\")\\n              s += \"\\n\"\\n          return s\\n      \\n      board[0,0] = 1\\n      \\n      if M == 0:\\n          board[board == -1] = 0\\n          return write_board(board)\\n      \\n      if free == 1:\\n          board[board == -1] = 2\\n          return write_board(board)\\n          \\n      \\n      while min(R, C) <= M:\\n          if R < C:\\n              board[:,C-1] = 2\\n              C -= 1\\n              M -= R\\n          elif C <= R:\\n              board[R-1,:] = 2\\n              R -= 1\\n              M -= C\\n      \\n      def cascades(board, r, c):\\n          rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]\\n          cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]\\n          for r in rows:\\n              for c in cols:\\n                  if board[r,c] == 2: #Mine next to given position\\n                      return False\\n          return True\\n      \\n      if M == 0:\\n          board[board == -1] = 0\\n          if cascades(board, 0, 0):\\n              return write_board(board)\\n          else:\\n              return \"\\nImpossible\"\\n      \\n      \\n      if M > (R + C - 5):\\n          return \"\\nImpossible\"\\n          \\n      if M > 0 and (R <= 2 or C <= 2):\\n          return \"\\nImpossible\"\\n          \\n      print M, R + C - 5\\n      fill_num = min(M, R - 2)\\n      print M, fill_num\\n      board[(R - fill_num):,C-1] = 2\\n      M -= fill_num\\n      \\n      fill_num = min(M, C - 3)\\n      print M, fill_num\\n      board[R-1,(C - fill_num - 1):] = 2\\n      M -= fill_num\\n      \\n      board[board == -1] = 0\\n      return write_board(board)\\n  \\n  \\n  if __name__ == \"__main__\":\\n      precalculate()\\n      \\n      assert len(sys.argv) == 2 #only one argument\\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\\n      infile = open(\"%s\" % sys.argv[1], 'r')\\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\\n      \\n      cases = int(infile.readline().strip('\\n'))\\n      for i in range(cases):\\n          \\n          case = read_input(infile)\\n          \\n          output = solve_case(case)\\n          \\n          outfile.write('Case #%i: %s\\n' % (i+1, output))\\n          print 'Case #%i: %s\\n' % (i+1, output)\\n      \\n      infile.close()\\n      outfile.close()\\n", "substitutes": {"self": ["me", "_", "all", "node", "ws", "user", "event", "name", "h", "parent", "default", "key", "os", "part", "w", "public", "this", "v", "plus", "item", "er", "worker", "Self", "full", "resp", "ss", "app", "view", "python", "lock", "right", "c", "data", "ack", "form", "ng", "plugin", "proc", "module", "ok", "org", "object", "load", "instance", "pos", "ctx", "remote", "result", "layer", "results", "p", "op", "py", "config", "spec", "function", "d", "per", "f", "host", "client", "e", "package", "none", "wrapper", "work", "cl", "call", "error", "now", "ref", "o", "parse", "val", "process", "q", "ns", "http", "other", "shared", "ps", "k", "type", "g", "context", "field", "s", "master", "block", "patch", "method"], "func": ["mod", "parse", "wrap", "conv", "rb", "node", "val", "cc", "unc", "cf", "doc", "xxx", "aux", "name", "loop", "python", "function", "addr", "fn", "f", "default", "c", "uc", "data", "parser", "util", "code", "package", "var", "callback", "wrapper", "partial", "proc", "module", "acl", "pkg", "job", "sec", "expr", "conn", "con", "conf", "part", "super", "cb", "Function", "fun", "object", "this", "instance", "attr", "ctx", "exec", "call", "amd", "enc", "pc", "method"], "cache": ["parse", "pool", "session", "image", "query", "list", "config", "db", "index", "proxy", "css", "base", "body", "parent", "lock", "get", "count", "stack", "c", "data", "play", "site", "table", "lib", "chain", "hash", "ache", "map", "wrapper", "dict", "Cache", "source", "module", "conf", "con", "cycle", "buffer", "attr", "sync", "gc", "store", "call", "block", "enc", "ac"], "value": ["element", "response", "array", "start", "exp", "val", "new", "all", "child", "valid", "index", "current", "weight", "name", "function", "null", "true", "parent", "message", "default", "data", "member", "key", "values", "none", "VALUE", "media", "output", "type", "create", "object", "this", "v", "instance", "root", "number", "content", "resource", "result", "reference", "Value", "one"], "args": ["_", "ig", "array", "extra", "files", "all", "cards", "pack", "doc", "name", "ins", "actions", "names", "points", "items", "var", "arg", "words", "v", "item", "ass", "cs", "ras", "vals", "params", "alls", "body", "fields", "parents", "arr", "data", "values", "keys", "module", "ages", "groups", "parts", "attr", "changes", "results", "p", " arguments", "lines", "len", "qs", "ar", "function", "ids", "kw", "gs", "events", "argument", "none", "__", "axis", "blocks", "xs", "atts", "ars", "loc", "call", "now", "parse", "aults", "ns", "ams", "include", "objects", "rows", "empty", "links", "Args", "members", "ds"], "obj": ["mod", "p", "o", "Obj", "node", "op", "val", "py", "js", "init", "name", "function", "base", "parent", "fn", "data", "str", "typ", "pointer", "key", "api", "os", "po", " Obj", "objects", "dict", "module", "tmp", "type", "static", "j", "object", "instance", "Object", "ctx", " object"], "objtype": ["modType", " objType", "objectType", "objectval", "modval", " objval", "objval", "objecttype", "modtype", "objType"], "infile": ["outline", "infilename", "infiles", " inf", " infiles", "Infiles", "Inline", " inline", "outstream", "outf", "Infilename", " infilename", "Inf", "instream", "Infolder", "INfiles", " instream", " infolder", "INfolder", "inline", "INstream", "INfile", "Instream", "INfilename", "Infile", "inf", "outfile", "infolder"]}}
{"code": " \\n  \\n  \\n  \\n  \\n  \\n  \\n  class memoize(object):\\n     \"\"\"Decorator. Caches a function's return value each time it is called.\\n     If called later with the same arguments, the cached value is returned\\n     (not reevaluated).\\n     \"\"\"\\n     def __init__(self, func):\\n        self.func = func\\n        self.cache = {}\\n     def __call__(self, *args):\\n        if not isinstance(args, collections.Hashable):\\n           return self.func(*args)\\n        if args in self.cache:\\n           return self.cache[args]\\n        else:\\n           value = self.func(*args)\\n           self.cache[args] = value\\n           return value\\n     def __repr__(self):\\n        '''Return the function's docstring.'''\\n        return self.func.__doc__\\n     def __get__(self, obj, objtype):\\n        '''Support instance methods.'''\\n        return functools.partial(self.__call__, obj)\\n  \\n  \\n  def precalculate():\\n      \"\"\"Perform any calculations that need to be performed before the main path\\n      (e.g., preparing lookup tables, etc.)\\n      \\n      N.B. Make sure you make any important variables global so that other\\n      functions can access them.\\n      \"\"\"\\n      pass\\n  \\n  def read_input(infile):\\n      \"\"\"This function should take an open input file, load in all of the\\n      relevant information for a single case of the problem, and output it\\n      as a single object.    \\n      \"\"\"\\n      def read_int():\\n          return int(infile.readline().strip())\\n      def read_ints():\\n          return np.array(infile.readline().split(), dtype=int)\\n      def read_bigints(): #For ints that won't fit directly in an int32 array\\n          line = infile.readline().split()\\n          return np.array(map(lambda x: int(x), line))\\n      def read_float():\\n          return float(infile.readline().strip())\\n      def read_floats():\\n          return np.array(infile.readline().split(), dtype=float)\\n      def read_string():\\n          return infile.readline().strip()\\n      def read_strings():\\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\\n      \\n      ans1 = read_int()\\n      grid1 = np.zeros((4,4), dtype=int)\\n      for i in range(4):\\n          grid1[i] = read_ints()\\n      \\n      ans2 = read_int()\\n      grid2 = np.zeros((4,4), dtype=int)\\n      for i in range(4):\\n          grid2[i] = read_ints()\\n      \\n      \\n      case = (ans1, grid1, ans2, grid2)\\n      \\n      return case\\n  \\n  def solve_case(case):\\n      \"\"\"Take the input data (structured in case) and perform any necessary\\n      calculations to obtain the desired output, formatted as the appropriate\\n      string.    \\n      \"\"\"\\n      \\n      ans1, grid1, ans2, grid2 = case\\n      \\n      valid = set(grid1[ans1-1]) & set(grid2[ans2-1])\\n      \\n      \\n      if len(valid) == 1:\\n          output = valid.pop()\\n      elif len(valid) > 1:\\n          output = \"Bad magician!\"\\n      elif len(valid) < 1:\\n          output = \"Volunteer cheated!\"\\n      return output\\n  \\n  \\n  if __name__ == \"__main__\":\\n      precalculate()\\n      \\n      assert len(sys.argv) == 2 #only one argument\\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\\n      infile = open(\"%s\" % sys.argv[1], 'r')\\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\\n      \\n      cases = int(infile.readline().strip('\\n'))\\n      for i in range(cases):\\n          \\n          case = read_input(infile)\\n          \\n          output = solve_case(case)\\n          \\n          outfile.write('Case #%i: %s\\n' % (i+1, output))\\n          print 'Case #%i: %s\\n' % (i+1, output)\\n      \\n      infile.close()\\n      outfile.close()\\n", "substitutes": {"self": ["me", "_", "all", "node", "ws", "user", "event", "name", "h", "parent", "default", "key", "os", "part", "w", "public", "this", "v", "plus", "item", "er", "worker", "Self", "full", "resp", "ss", "app", "view", "python", "lock", "right", "c", "data", "ack", "form", "ng", "plugin", "proc", "module", "ok", "org", "object", "load", "instance", "pos", "ctx", "remote", "result", "layer", "results", "p", "op", "py", "config", "spec", "function", "d", "per", "f", "host", "client", "e", "package", "none", "wrapper", "work", "cl", "call", "error", "now", "ref", "o", "parse", "val", "process", "q", "ns", "http", "other", "shared", "ps", "k", "type", "g", "context", "field", "s", "master", "block", "patch", "method"], "func": ["mod", "parse", "wrap", "conv", "rb", "node", "val", "cc", "unc", "cf", "doc", "xxx", "aux", "name", "loop", "python", "function", "addr", "fn", "f", "default", "c", "uc", "data", "parser", "util", "code", "package", "var", "callback", "wrapper", "partial", "proc", "module", "acl", "pkg", "job", "sec", "expr", "conn", "con", "conf", "part", "super", "cb", "Function", "fun", "object", "this", "instance", "attr", "ctx", "exec", "call", "amd", "enc", "pc", "method"], "cache": ["parse", "pool", "session", "image", "query", "list", "config", "db", "index", "proxy", "css", "base", "body", "parent", "lock", "get", "count", "stack", "c", "data", "play", "site", "table", "lib", "chain", "hash", "ache", "map", "wrapper", "dict", "Cache", "source", "module", "conf", "con", "cycle", "buffer", "attr", "sync", "gc", "store", "call", "block", "enc", "ac"], "value": ["element", "response", "array", "start", "exp", "val", "new", "all", "child", "valid", "index", "current", "weight", "name", "function", "null", "true", "parent", "message", "default", "data", "member", "key", "values", "none", "VALUE", "media", "output", "type", "create", "object", "this", "v", "instance", "root", "number", "content", "resource", "result", "reference", "Value", "one"], "args": ["_", "ig", "array", "extra", "files", "all", "cards", "pack", "doc", "name", "ins", "actions", "names", "points", "items", "var", "arg", "words", "v", "item", "ass", "cs", "ras", "vals", "params", "alls", "body", "fields", "parents", "arr", "data", "values", "keys", "module", "ages", "groups", "parts", "attr", "changes", "results", "p", " arguments", "lines", "len", "qs", "ar", "function", "ids", "kw", "gs", "events", "argument", "none", "__", "axis", "blocks", "xs", "atts", "ars", "loc", "call", "now", "parse", "aults", "ns", "ams", "include", "objects", "rows", "empty", "links", "Args", "members", "ds"], "obj": ["mod", "p", "o", "Obj", "node", "op", "val", "py", "js", "init", "name", "function", "base", "parent", "fn", "data", "str", "typ", "pointer", "key", "api", "os", "po", " Obj", "objects", "dict", "module", "tmp", "type", "static", "j", "object", "instance", "Object", "ctx", " object"], "objtype": ["modType", " objType", "objectType", "objectval", "modval", " objval", "objval", "objecttype", "modtype", "objType"], "infile": ["outline", "infilename", "infiles", " inf", " infiles", "Infiles", "Inline", " inline", "outstream", "outf", "Infilename", " infilename", "Inf", "instream", "Infolder", "INfiles", " instream", " infolder", "INfolder", "inline", "INstream", "INfile", "Instream", "INfilename", "Infile", "inf", "outfile", "infolder"]}}
{"code": " \\n  T = int(raw_input())\\n  for test_case in xrange(1, T + 1):\\n      R, C, M = map(int, raw_input().split())\\n      N = R * C\\n      B = N - M\\n  \\n      W, H = (C, R) if R <= C else (R, C)\\n  \\n      if H == 1:\\n          answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]\\n      elif M == N - 1:\\n          answer = [['*'] * W for r in xrange(H)]\\n          answer[0][0] = 'c'\\n      elif B < 4 or B in (5, 7):\\n          answer = None\\n      elif H == 2:\\n          if M % 2 == 0:\\n              bw = B / 2\\n              answer = [\\n                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\\n                  ['.'] * bw + ['*'] * (W - bw),\\n              ]\\n          else:\\n              answer = None\\n      else:\\n          answer = [['*'] * W for y in xrange(H)]\\n          answer[0][0] = 'c'\\n          answer[0][1] = answer[1][0] = answer[1][1] = '.'\\n          left = B - 4\\n          if 2 <= left:\\n              answer[0][2] = answer[1][2] = '.'\\n              left -= 2\\n          if 2 <= left:\\n              answer[2][0] = answer[2][1] = '.'\\n              left -= 2\\n  \\n          x = y = 3\\n          while (x < W or y < H) and 2 <= left:\\n              if x < W and 2 <= left:\\n                  answer[0][x] = answer[1][x] = '.'\\n                  left -= 2\\n                  x += 1\\n              if y < H and 2 <= left:\\n                  answer[y][0] = answer[y][1] = '.'\\n                  left -= 2\\n                  y += 1\\n  \\n          y = 2\\n          while 0 < left and y < H:\\n              x = 2\\n              while 0 < left and x < W:\\n                  answer[y][x] = '.'\\n                  left -= 1\\n                  x += 1\\n              y += 1\\n  \\n      if answer is None:\\n          answer = 'Impossible'\\n      else:\\n          if W == R:\\n              answer = map(list, zip(*answer))\\n          assert len(answer) == R\\n          assert len(answer[0]) == C\\n          assert sum(row.count('*') for row in answer) == M\\n          answer = '\\n'.join([''.join(row) for row in answer])\\n      print 'Case #{}:\\n{}'.format(test_case, answer)\\n", "substitutes": {"T": ["Z", "TT", "P", "O", "A", "TC", "S", "WT", "L", "TB", "F", "X", "K", "TS", "t", "E", "TN", "TH", "D", "U", "Y", "V", "Time", "NT"], "test_case": ["testvalchoice", "est_choice", "test_choice", "test_ab", "estmatchab", "testmatchchoice", "testmatchcase", "testmatchab", "estmatchchoice", "estmatchcase", "est_ab", "testvalcase", "est_length", "estmatchlength", "testmatchlength", "testvallength", "testvalab", "est_case", "test_length"], "R": ["P", "O", "A", "CR", "S", "RA", "L", "RR", "F", "X", "RN", "K", "Rs", "E", "NR", "RO", "D", "G", "U", "Y", "RS", "V", "Q", "SR", "RM"], "C": ["CC", "Z", "P", "O", "A", "CR", "S", "Cs", "CI", "DC", "L", "CL", "CM", "X", "F", "K", "I", "c", "CU", "E", "CT", "CN", "CO", "CNN", "VC", "D", "G", "NC", "U", "CA", "V", "Co", "Q", "CE"], "M": ["Z", "P", "O", "LM", "A", "S", "MN", "m", "J", "L", "MA", "CM", "F", "X", "K", "I", "E", "SM", "D", "G", "MC", "MD", "U", "Y", "V", "MT", "MB", "Q", "RM"], "N": ["Z", "P", "O", "A", "S", "MN", "Ns", "Ne", "NN", "J", "L", "F", "X", "RN", "K", "I", "E", "NH", "NC", "G", "D", "U", "Y", "Wh", "V", "NE", "NL", "NM", "NS", "n", "Ni", "NT"], "B": ["Z", "Sp", "P", "NB", "A", "AB", "O", "S", "BF", "mb", "J", "L", "BB", "BC", "F", "X", "Bl", "I", "K", "ob", "TB", "BL", "Base", "E", "BI", "D", "G", "ub", "bb", " b", "GB", "U", "Two", "Y", "V", "b", "WB", "MB", "Q", "Ab", "Bs", "BM"], "W": ["Z", "P", "O", "BW", "A", "WR", "WM", "CW", "NW", "WT", "S", "TW", "WS", "sw", "Weight", "We", "L", "Web", "F", "X", "WC", "K", "GW", "Word", "Win", "E", " w", "WH", "VW", "Tw", "DW", "tw", "G", "D", "wh", "U", "Wi", "Wh", "Y", "w", "FW", "V", "Wa", "Width", "WB", "Sw", "Q", "MW", "SW", "WA", "WE"], "H": ["EH", "Z", "HI", "P", "O", "A", "HS", "S", "J", "L", "HK", "h", "F", "X", "K", "HC", "Ha", "Ch", "E", "RH", "WH", "TH", "G", "D", "DH", "MH", "U", "OH", "Y", "Wh", "V", "CH", "Sw", "Q", "SH", "HH", "GH", "HP"], "answer": ["duration", "element", "A", "response", "array", "image", "swers", "evidence", " Answer", " result", "document", "event", "entry", "account", "office", "grade", "next", "energy", "question", "information", "ell", "article", "do", "output", "issue", "attribute", "episode", "z", "ee", "adapt", "page", "align", "comment", "request", "address", "expression", "enum", "accept", "example", "une", "answered", "data", " explanation", "remember", "archive", "form", "ew", "edition", "description", "video", "support", "Y", "object", "number", "memory", "result", "results", "replace", "open", "ae", "uit", "message", "equ", " answering", "update", "edge", "e", "evaluate", "respond", "music", "knowledge", "username", "altern", "bet", "content", "reply", "error", "reference", "word", "correct", "option", "err", "Answer", "audio", "agree", "average", "offer", "null", "cover", "search", "after", "cache", "see", "value", "settings", "field", "complete", "string", " answers", "activity"], "r": ["p", "ow", "m", "d", "h", "X", "rd", "c", "e", "ir", "ur", "i", "k", "z", "Y", "a", "g", "re", "b", "s", "u", "n", "rs", "int"], "bw": ["fwe", "fW", "bws", "bbW", "BW", "ww", "cw", "bW", "cwe", "bbw", "bbwa", "wws", "fsw", "bwin", "pW", "dw", "Bws", "pw", " bW", "Bwl", "cwa", " bws", "bp", " bwa", " bsw", "wwin", "Bw", "dwa", " bwe", "csw", "bwe", "fw", "bbwl", "Bwin", "bsw", "Bp", " bp", "wp", "dW", "pwa", "fwd", "fwa", "pwd", "dwl", " bwd", " bwin", "bwa", "Bwa", "bwl", "bwd"], "y": ["p", "o", "py", "ow", "height", "fy", "sy", "col", "hy", "ly", "m", "ye", "ay", "ish", "d", "ot", "ny", "ya", "ind", "dy", "vy", "h", "yo", "l", "X", "iny", "yt", "c", "ry", "ym", "e", "ate", "t", "ii", "yi", "key", "i", "year", "yp", "yd", "z", "rot", "type", "Y", "gy", "w", "yl", "j", "ey", "any", "yn", "xy", "b", "v", "iy", "ys", "zy", "ty", "xx", "oy", "n", "yy", "yr", "cy"], "left": ["Z", "inside", "all", "level", "list", "path", "next", "default", "cost", "inner", "ell", "no", "key", "wrong", "both", "join", "self", " Left", "leave", "length", "plus", "min", "NL", "rights", "local", "lt", "bottom", "cross", "ignore", "pl", "full", "width", "out", "right", "end", "wall", "down", "auto", "column", "exp", "p", "S", "col", "st", " right", "function", "text", "Lo", "X", "f", "str", "fl", "none", "el", "two", "rel", "cl", "low", "elt", "small", "line", "lower", "le", "error", "lo", "outside", "one", "off", "o", "P", "Left", "center", "null", "ST", "L", "l", "Right", "FT", "value", "top"], "x": ["p", "o", "dx", "id", "ix", "ax", "xxx", "yx", "index", "na", "name", "q", "m", "any", "ay", "width", "d", "fx", "h", "en", "X", "f", "l", "step", "ex", "ya", "c", "wx", "right", "e", "t", "no", "key", "i", "px", "xi", "z", "k", "xs", "xc", "Y", "rx", "w", "a", "wa", "yl", "ey", "j", "xy", "b", "v", "s", "my", "xp", "on", "xx", "sex", "n", "int", "cross", "one", "cy"]}}
{"code": " \\n  T = int(raw_input())\\n  for test_case in xrange(1, T + 1):\\n      N1 = int(raw_input())\\n      for i in xrange(4):\\n          if i + 1 == N1:\\n              R1 = map(int, raw_input().split(' '))\\n          else:\\n              raw_input()\\n      N2 = int(raw_input())\\n      for i in xrange(4):\\n          if i + 1 == N2:\\n              R2 = map(int, raw_input().split(' '))\\n          else:\\n              raw_input()\\n      assert 1 <= N1 <= 4\\n      assert 1 <= N2 <= 4\\n      assert len(R1) == len(R2) == 4\\n  \\n      num = set(R1) & set(R2)\\n      if len(num) == 1:\\n          answer = num.pop()\\n      elif 1 < len(num):\\n          answer = 'Bad magician!'\\n      else:\\n          answer = 'Volunteer cheated!'\\n      print 'Case #{}: {}'.format(test_case, answer)\\n", "substitutes": {"T": ["Test", "P", "O", "A", "R", "S", "WT", "B", "L", "F", "X", "I", "t", "E", "TN", "IP", "Ti", "D", "M", "G", "Y", "IT", "C", "V", "H", "Q", "W", "N", "TI", "n", "test", "Time"], "test_case": ["testcaseinstance", " test_number", "testtestcase", "test_test", "testvalmatch", "testcasenumber", " test_test", "test_instance", "testcasecase", " test_instance", " testcasematch", "testvalnumber", "testvalcase", " testcasecase", " test_match", "testtestnumber", "test_number", " testcaseinstance", "test_match", "testcasematch", "testtestinstance", " test_trial", "test_trial", " testcasenumber", "testvalinstance", "testtestmatch"], "N1": ["n1", "Ni1", "N3", "N11", "n2", " N0", "n0", "R11", "NumberFirst", "n11", "N01", "n3", "NE2", "Ni01", "NFirst", " N11", "N0", "none", "Rone", "NEone", "R01", "RFirst", "Number01", "Numberart", "NiFirst", "Nart", "R3", "Rart", "R0", "Niart", "Number1", "NE3", "NE1"], "i": ["p", "it", "ui", "li", "chi", "id", "ci", "ix", "index", "ori", "m", "phi", "ai", "d", "x", "bi", "ind", "l", "y", "f", "I", "ii", "c", "ti", "e", "t", "yi", "ie", "xi", "di", "pi", "z", "r", "a", "j", "b", "v", "ip", "u", "qi", "n", "si", "io", "int", "iu"], "R1": ["r71", "r51", "N81", " R0", " R81", "r0", "r81", " R71", " R100", " R51", "N0", "RR1", "R51", "r2", "N51", "r1", "R8", "R71", "r8", "RR71", "r100", "R100", "R0", "R10", " R8", " R10", "RR100", "N10", "RR8", "R81", "r10"], "N2": ["n1", "n2", " NTwo", "NoTwo", "Ne4", "NE4", "KTwo", "NE02", "NII", "No2", "NE2", "Ktwo", "K96", "N02", "Len2", "Ne2", "Len1", "N96", " NII", "No96", " Ntwo", "K2", "LenII", "Notwo", "NTwo", "R02", "ntwo", " N96", "Lentwo", "Ne02", "N4", "Ntwo", "nII", "R4"], "R2": ["N20", " R0", "r0", "r102", " RTwo", " R102", "N102", "r20", "RR1", "N0", "rTwo", "RR20", "R102", "r2", "RR2", "RR0", "r1", "RSecond", "NTwo", "R0", "RTwo", "R20", "NSecond", "RRSecond", "rSecond"], "num": ["split", "err", "p", "box", "off", "mix", "prefix", "nu", "new", "dom", "div", "id", "unit", "node", "valid", "index", "init", "range", "na", "name", "comb", "norm", "np", "text", "net", "x", "multi", "coord", "ru", "count", "hex", "data", "bin", "Num", "temp", "hom", "no", "form", "um", "nom", "r", "buf", "cart", "check", "con", "a", "mon", "sum", "b", "pos", "number", "dim", "zero", "nam", "NUM", "n", "common", "sam", "test", "result", "rub", "mom"], "answer": ["err", "Answer", "duration", "response", "array", "agree", "comment", "case", "swers", "address", "say", "average", "evidence", "score", "expression", "version", "accept", "name", "ae", "su", "account", "asm", "example", "pole", "grade", "next", "answered", "message", "equ", "default", "area", "update", "question", "eni", " answered", "assembly", "truth", "cache", "status", "output", "description", "issue", "cash", "username", "term", "number", "fix", "string", "reply", "result", "test", "error", " answers", " Answer"]}}
{"code": " \\n  def put_mines_last_step(R, C, M, grid):\\n  \tif M == 0:\\n  \t\treturn\\n  \tR -= 1\\n  \tC -= 1\\n  \tgrid[R][C] = '*'\\n  \tM -= 1\\n  \tr = R - 1\\n  \tc = C - 1\\n  \twhile M > 0:\\n  \t\tif r > c:\\n  \t\t\tgrid[r][C] = '*'\\n  \t\t\tr -= 1\\n  \t\telse:\\n  \t\t\tgrid[R][c] = '*'\\n  \t\t\tc -= 1\\n  \t\tM -= 1\\n  \\n  def put_mines(R, C, M, grid):\\n  \tif R > C:\\n  \t\tif M < C:\\n  \t\t\tput_mines_last_step(R, C, M, grid)\\n  \t\t\treturn\\n  \t\tfor i in range(C):\\n  \t\t\tgrid[R - 1][i] = '*'\\n  \t\tput_mines(R - 1, C, M - C, grid)\\n  \t\treturn\\n  \tif M < R:\\n  \t\tput_mines_last_step(R, C, M, grid)\\n  \t\treturn\\n  \tfor i in range(R):\\n  \t\tgrid[i][C - 1] = '*'\\n  \tput_mines(R, C - 1, M - R, grid)\\n  \treturn\\n  \\n  def process(R, C, M):\\n  \trlt = ''\\n  \tgrid = []\\n  \tfor i in range(R):\\n  \t\tgrid.append(['.'] * C)\\n  \tput_mines(R, C, M, grid)\\n  \tif not C == 1:\\n  \t\tfor i in range(R):\\n  \t\t\tif not grid[i][0] == '.':\\n  \t\t\t\tbreak\\n  \t\t\tif not grid[i][1] == '.':\\n  \t\t\t\treturn '\\nImpossible'\\n  \tif not R == 1:\\n  \t\tfor i in range(C):\\n  \t\t\tif not grid[0][i] == '.':\\n  \t\t\t\tbreak\\n  \t\t\tif not grid[1][i] == '.':\\n  \t\t\t\treturn '\\nImpossible'\\n  \tgrid[0][0] = 'c'\\n  \tfor i in grid:\\n  \t\trlt += '\\n' + ''.join(i)\\n  \treturn rlt\\n  \\n  input_file = open(sys.argv[1], 'r')\\n  T = int(input_file.readline())\\n  for i in range(T):\\n  \t(R, C, M) = map(int, input_file.readline().split())\\n  \tprint 'Case #%d:' % (i + 1), process(R, C, M)\\n", "substitutes": {"R": ["p", "P", "A", "CR", "WR", "Cr", "S", "JR", "B", "Ra", "Region", "MR", "RA", "AR", "Rule", "RE", "L", "RR", "x", "LR", "F", "X", "RN", "K", "I", "Run", "Gr", "Rec", "ER", "RW", "RP", "e", "Rs", "E", "IR", "NR", "RH", "Right", "DR", "RO", "D", "G", "Rh", "U", "Y", "GR", "RS", "H", "V", "RT", "Row", "RL", "RG", "Q", "Re", "SR", "N", "W", "RF", "RM", "Res", "RC", "Range"], "C": ["CC", "Z", "P", "O", "Cr", "A", "CR", "SC", "CF", "CW", "S", "B", "Cs", "CI", "YC", "m", "d", "DC", "L", "CL", "CM", "Code", "F", "X", "K", "I", "AC", "CV", "Sc", "Ch", "GC", "CU", "E", "CT", "CN", "CNN", "Cont", "VC", "G", "D", "NC", "EC", "MC", "Rh", "U", "Y", "CA", "Cl", "V", "H", "Co", "Chain", "Cu", "Mc", "Q", "W", "N", "RC", "CE"], "M": ["Mo", "P", "O", "LM", "A", "MF", "AM", "S", "MN", "B", "MR", "Ms", "m", "Me", "L", "J", "RR", "CM", "VM", "F", "X", "I", "DM", "K", "Man", "Mor", "JM", "E", "MOD", "Multi", "ME", "MM", "G", "D", "OM", "MI", "MC", "Meta", "MD", "OR", "MS", "U", "cm", "Y", "V", "H", "EM", "MB", "Mc", "CL", "Q", "NM", "W", "N", "AMD", "RM", "FM", "Mi", "Module"], "grid": ["format", "array", "node", "unit", "case", "query", "div", "image", "list", "lc", "plot", "ID", "range", "mu", "crop", "layout", "cli", "order", "gr", "arc", "grade", "law", "cr", "cfg", "fit", "play", "code", "frame", "draw", "age", "reg", "cm", "script", "u", "rid", "xml", "bug", "ac", "stage", "id", "hold", "export", "db", "m", "live", "product", "multi", "card", "data", "table", "mag", "form", "ga", "G", "module", "auto", "column", "mid", "flow", "diff", "cum", "remote", "df", "layer", "json", "lat", "p", "filter", "ci", "sim", "active", "valid", "config", "mm", "file", "man", "hard", "flat", "F", "record", "f", "count", "Grid", "message", "update", "edge", "client", "str", "chain", "final", "cell", "graph", "cart", "input", "work", "standard", "row", "line", " Grid", "gap", "heat", "mat", "date", "zip", "mod", "medium", "house", "parse", "group", "rank", "run", "report", "press", "q", "gui", "x", "rule", "csv", "cache", "move", "cube", "static", "g", "wire", "storage", "server", "model", "cells", " module", "string", "block", "gage", "close", "site"], "r": ["p", "o", "P", "Cr", "rb", "CR", "br", "rc", "MR", "ar", "m", "mr", "d", "x", "RR", "h", "l", "f", "cr", "ru", "nr", "right", "e", "ir", "Rs", "rr", "rh", "Rh", "cm", "w", "b", "sr", "v", "u", "W", "lr", "n", "rs", "er", "yr"], "c": ["CC", "p", "o", "P", "Cr", "cu", "ci", "cc", "lc", "dc", "nc", "rc", "q", "m", "d", "x", "h", "l", "f", "cr", "y", "I", "uc", "right", "e", "t", "chain", "rec", "z", "k", "cm", "U", "a", "w", "s", "b", "v", "u", "N", "n", "mc", "ac", "cy"], "i": ["it", "_", "iq", "chi", "ix", "index", "name", "cli", "ai", "h", "y", "ti", "eni", "zi", "uri", "xi", "z", "ic", "mi", "v", "ip", "u", "io", "gu", "slice", "ui", "id", "B", "init", "CI", "m", "ini", "phi", "multi", "bi", "ind", "gi", "yi", "ie", "module", "fi", "hi", "n", "int", "il", "p", "li", "ci", "ei", "ar", "d", "f", "I", "e", "t", "mini", "di", "info", "input", "ni", "a", "im", "j", "si", "o", "LI", "gui", "x", " I", "l", "ri", "ii", "ir", "pi", "g", "s", "b", "model", "iw", "qi", "iu"], "rlt": [" rlett", "clt", "Relt", "rmin", " relt", "Rmin", "RLT", "melt", "celt", "cmin", "Rlet", "rlet", "cLT", "mLT", "mlett", "relt", "clet", " rlet", "rLT", " rLT", "Rlett", " rmin", "mlt", "rlett", "Rlt"], "input_file": [" input_File", "input1files", " input_files", "inputfilefiles", "input_File", "input_filename", "inputedhandler", "inputachandler", "inputacbuffer", "inputingfile", "inputedfiles", "inputfilemodule", "input1File", "input1module", " inputingfilename", "input___buffer", "inputingfilename", " input_fp", "inputinghandler", "inputedfilename", " inputingfile", "inputacfile", "input___file", "input___fp", "input_files", "inputedfile", "input1file", " inputingfiles", " input_module", "input_module", "inputfilefile", " input_buffer", "inputingfiles", " inputinghandler", "input___handler", " input_filename", "input_buffer", "input_handler", "input_fp", "inputfileFile", " input_handler", "inputacfp"], "T": ["Z", "P", "TT", "O", "A", "TC", "S", "WT", "B", "TA", "L", "TB", "F", "X", "DT", "K", "I", "t", "TS", "E", "Total", "TH", "TN", "TR", "G", "D", "U", "Y", "V", "H", "Q", "W", "N", "Time", "NT"]}}
{"code": " \\n  \\n  def process(chosen_row_1, arrange_1, chosen_row_2, arrange_2):\\n  \trlt = 'Volunteer cheated!'\\n  \tfound = False\\n  \tfor i in arrange_1[chosen_row_1]:\\n  \t\tif i in arrange_2[chosen_row_2]:\\n  \t\t\tif not found:\\n  \t\t\t\trlt = i\\n  \t\t\t\tfound = True\\n  \t\t\telse:\\n  \t\t\t\trlt = 'Bad magician!'\\n  \t\t\t\tbreak\\n  \treturn rlt\\n  \\n  input_file = open(sys.argv[1], 'r')\\n  T = int(input_file.readline())\\n  for i in range(T):\\n  \tchosen_row_1 = int(input_file.readline()) - 1\\n  \tarrange_1 = []\\n  \tarrange_1.append(map(int, input_file.readline().split()))\\n  \tarrange_1.append(map(int, input_file.readline().split()))\\n  \tarrange_1.append(map(int, input_file.readline().split()))\\n  \tarrange_1.append(map(int, input_file.readline().split()))\\n  \tchosen_row_2 = int(input_file.readline()) - 1\\n  \tarrange_2 = []\\n  \tarrange_2.append(map(int, input_file.readline().split()))\\n  \tarrange_2.append(map(int, input_file.readline().split()))\\n  \tarrange_2.append(map(int, input_file.readline().split()))\\n  \tarrange_2.append(map(int, input_file.readline().split()))\\n  \tprint 'Case #%d:' % (i + 1), process(chosen_row_1, arrange_1, chosen_row_2, arrange_2)\\n", "substitutes": {"chosen_row_1": ["chosen_col_7", "chosen_col_1", "chosen_col_one", "chosen_row_4", "chosen_col_part", "chosen_row_part", "chosen_row_7", "chosen_col_0", "chosen_col_4", "chosen_row_one", "chosen_row_01", "chosen_col_01", "chosen_row_0", "chosen_col_2"], "arrange_1": ["arrange_5", "arrange_01", "arrange_One", "arrrange_one", "arrange__81", "arrrange_8", "arrange_0", "arrrange_91", "arrrage_1", "arrrange_01", "arrange_91", "arrange_one", "arrrange_5", "arrange_3", "arrrange_0", "arrange__1", "arrange_first", "arrrage_one", "arrrange_3", "arrange_10", "arrange_81", "arrange__2", "arrrange_One", "arrange_8", "arrrange_first", "arrange__one", "arrrange_10", "arrrage_2", "arrrange_81", "arrrange_2", "arrrange_1", "arrrage_8"], "chosen_row_2": ["chosen_row_second", "chosen_col_1", "chosen_row_22", "chosen_row_two", "chosen_row_4", "chosen_row122", "chosen_row_32", "chosen_col_22", "chosen_col_two", "chosen_col_02", "chosen_row12", "chosen_col_4", "chosen_row_02", "chosen_row11", "chosen_col_second", "chosen_row132", "chosen_col_32", "chosen_col_2"], "arrange_2": ["arrange_5", "arrange_second", "arrange_9", "arrange_all", "arrrange_22", "arrase_3", "arrain_second", "arrenge_5", "arrange_diff", "arrain_2", "arrase_02", "arrenge_1", "arrrange_diff", "arrange_62", "arrange__two", "arranne_62", "arrrange_02", "arrange_02", "arrange_3", "arrange_two", "arrange__1", "arranne_2", "arrase_1", "arrange_13", "arrangePdiff", "arranne_two", "arrange__62", "arrangeJ2", "arrase_2", "arrain_13", "arrrange_3", "arrange___2", "arrrange_20", "arrange___20", "arrange__2", "arrangeJ1", "arrangeJtwo", "arrangeP3", "arrain_1", "arrange___22", "arrangeJ9", "arrange_22", "arrange_20", "arrrange_9", "arrange___1", "arrangeP1", "arrrange_2", "arrenge_two", "arrrange_1", "arrangeP2", "arrrange_two", "arranne_1", "arrenge_2", "arrrange_all"], "rlt": [" rdl", "ardl", "Rld", " Relt", "rld", " rld", "Relt", " relt", " Rlt", "RLT", "rrilt", "erut", " rtd", "arelt", "selt", "rilt", "rtl", "rrLT", "rtd", "erelt", " RLT", " Rtd", "artl", "rdl", " rut", "sdl", "arlt", "erlt", "rrelt", "rut", "relt", " rilt", "stl", "erld", "Rut", "slt", "rLT", " rLT", " rtl", "Rilt", "Rtd", "rrlt", "Rlt"], "found": ["defined", "connected", "new", "all", " find", "old", "where", "valid", " Found", "index", "required", "expected", "ound", "printed", "missing", "F", "l", "f", "search", "confirmed", "given", "Found", "default", "count", "successful", "false", "finding", "end", "only", "Find", "good", "built", "sect", "source", "local", "fall", "find", "fe", "left", "first", "field", "failed", "finder", "error", "loaded", "result", "done"], "i": ["il", "p", "it", "iq", "li", "id", "ci", "col", "ia", "ei", "index", "cli", "m", "ini", "d", "ai", "multi", "x", "bi", "ind", "l", "h", "f", "I", "y", "ii", "c", "ti", "e", "ir", "t", "eni", "yi", "ie", "include", "uri", "mini", "num", "di", "pi", "xi", "z", "r", "ni", "a", "g", "j", "im", "ib", "b", "iy", "inter", "ip", "iw", "u", "qi", "n", "io", "int", "gu", "iu", "slice", "ignore"], "input_file": ["inputsstream", "inputfilefiles", "inputfilestream", "inputlexsocket", "inner_reader", "inputflowtable", "input_user", "inputingstream", "sourcesstream", "input64file", "inputedfile", "input_socket", "inputlinereader", "inputinghttp", "inputfilefile", "Input_files", "source_folder", " input_resource", "view_filename", " input_handler", "view_reader", "input_handle", "intlexsocket", "input_channel", "input64folder", "inputfilefolder", "inputlexfile", "inputlinechannel", "resourceinghttp", "output_File", "inputflowresource", "int_data", "inputfchannel", "source_file", " input_folder", "sourcesfile", "inner_file", "input_resource", "int_file", "Input_stream", "inputfileresource", " inputshandle", " input_handle", "inputlexuser", "resource_stream", "inputedstream", "input64filename", "view_file", "inputsobject", "intlexfile", "inputfilereader", "input_http", "inputsreader", "source_reader", "sourcesfolder", "input64reader", "intlexuser", "output_file", "sourcesreader", " input_stream", "input_File", "inputingsocket", "int_user", "Input_folder", "input_lane", "inputingfile", "input_table", "inputflowhandler", "int_socket", "Input_file", " input_table", "input_stream", "inputffile", "inputsresource", "inputsfile", "inputfilesocket", "source_stream", "inputfilehandle", "inputsfolder", "resourceingfile", " input_socket", "resource_http", "resourceingstream", "inputinguser", " input_user", "inputfilehandler", "input_handler", "input_folder", "inputflowfile", "source_handle", "inner_lane", "inputedhttp", "inputlinefile", "inputsFile", "source_object", " inputsfile", "inputfreader", "input_filename", "resource_file", "output_filename", "inputfileuser", " inputsstream", "input_files", "intlexdata", "input_data", "inputfiletable", "output_stream", " inputsresource", "input_object", "inputfileobject", "input_reader", "inputshandle", "inputlexdata", "inputingdata", "inputsfilename", "inputflane", "inputlinelane", "view_folder", "inner_channel"], "T": ["Z", "P", "O", "A", "TT", "R", "Length", "S", "B", "L", "F", "X", "I", "t", "E", "Total", "CT", "TN", "D", "M", "G", "UTC", "U", "Y", "IT", "C", "H", "W", "N", "Time", "NT"]}}
{"code": "inputFile = open('C-small-attempt8.in', 'r')\\n  lines = inputFile.readlines()\\n  inputFile.close()\\n  \\n  outputFile = open('C-small-attempt8.out', 'w')\\n  \\n  numTests = int(lines[0])\\n  \\n  for i in range(1, numTests+1):\\n      [r, c, m] = map(lambda x: int(x), lines[i].split())\\n  \\n      openCells = r*c - m\\n  \\n      works = False\\n      matrix = [['*']*c for j in range(r)]\\n      if r >= 3 and c >= 3:\\n          order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),\\n                   (2,0), (2,1)]\\n          if openCells == 1 or openCells == 4 or openCells == 6:\\n              works = True\\n              for (x,y) in order[:openCells]:\\n                  matrix[x][y] = '.'\\n              matrix[0][0] = 'c'\\n              \\n          elif openCells >= 8:\\n              works = True\\n              filledRows = openCells / c\\n              if filledRows >= 2:\\n                  if filledRows == r:\\n                      matrix = [['.']*c for j in range(r)]\\n                      matrix[0][0] = 'c'\\n                  else:\\n                      remainder = openCells%c\\n                      if not remainder == 1:\\n                          for j in range(filledRows):\\n                              matrix[j] = ['.']*c\\n                          matrix[filledRows] = ['.']*remainder + ['*'] * (c-remainder)\\n                      elif filledRows > 2:\\n                          for j in range(filledRows-1):\\n                              matrix[j] = ['.']*c\\n                          matrix[filledRows-1] = ['.']*(c-1) + ['*']\\n                          matrix[filledRows] = ['.', '.'] + ['*']*(c-2)\\n                      else:\\n                          matrix[0] = ['.']*(c-1) + ['*']                        \\n                          matrix[1] = ['.']*(c-1) + ['*']\\n                          matrix[2] = ['.', '.', '.'] + ['*']*(c-3)\\n                      matrix[0][0] = 'c'\\n                  \\n              else:\\n                  for (x,y) in order:\\n                      matrix[x][y] = '.'\\n                  remainingOpen = openCells - 8\\n                  if remainingOpen % 2 == 0:\\n                      for j in range(remainingOpen/2):\\n                          matrix[0][j+3] = '.'\\n                          matrix[1][j+3] = '.'\\n                  else:\\n                      matrix[2][2] = '.'\\n                      remainingOpen -= 1\\n                      for j in range(remainingOpen/2):\\n                          matrix[0][j+3] = '.'\\n                          matrix[1][j+3] = '.'\\n                  matrix[0][0] = 'c'\\n  \\n      elif r == 1:\\n          works = True\\n          matrix[0] = ['.']*(c-m) + ['*']*m\\n          matrix[0][0] = 'c'\\n      elif c == 1:\\n          works = True\\n          for j in range(r-m):\\n              matrix[j][0] = '.'\\n          matrix[0][0] = 'c'\\n  \\n      elif r == 2 and c == 2:\\n          if m == 3:\\n              works = True\\n              matrix[0][0] = 'c'\\n          elif m == 0:\\n              works = True\\n              matrix = [['c', '.'], ['.', '.']]\\n      elif r == 2:\\n          if m % 2 == 0 and r*c-m > 2:\\n              works = True\\n              matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)\\n              matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)\\n              matrix[0][0] = 'c'\\n          elif r*c-m == 1:\\n              works = True\\n              matrix[0][0] = 'c'\\n      elif c == 2:\\n          if m % 2 == 0 and r*c-m > 2:\\n              works = True\\n              for j in range((r*c-m)/2):\\n                  matrix[j] = ['.', '.']\\n              matrix[0][0] = 'c'\\n          elif r*c-m == 1:\\n              works = True\\n              matrix[0][0] = 'c'\\n      \\n  \\n      outputFile.write('Case #'+str(i)+':\\n')\\n      '''if len(matrix) != r:\\n          print i, matrix\\n      count = 0\\n      for j in range(len(matrix)):\\n          for k in range(len(matrix[j])):\\n              if matrix[j][k] == '*':\\n                  count += 1\\n      if count != m:\\n          print i, matrix'''\\n      if not works:\\n          outputFile.write('Impossible\\n')\\n      else:\\n          for x in range(len(matrix)):\\n              for y in range(len(matrix[0])):\\n                  outputFile.write(matrix[x][y])\\n              outputFile.write('\\n')\\n  outputFile.close()\\n              \\n", "substitutes": {"inputFile": [" inputDirectory", "outputDirectory", "inputDirectory", " inputHandle", "InputLine", "InputFile", "InputStream", "InputDir", "inputFolder", "InputHandle", "inputStream", "outputHandle", "sourceDirectory", " inputFolder", " inputStream", " inputLine", "InputFiles", "inputFiles", "outputDir", "outputStream", " inputDir", "inputLine", "sourceFolder", "sourceFiles", "inputDir", "outputLine", "sourceFile", "outputFiles", " inputFiles", "outputFolder", "inputHandle"], "lines": ["les", "tests", "steps", "features", "files", "sheets", "vals", "ls", "runs", "lin", "reports", "log", "limits", "params", "strings", "l", "cases", "reads", "locks", "faces", "points", "args", "breaks", "items", "ses", "models", "objects", "rows", "posts", "elines", "rules", "letters", "blocks", "zip", "groups", "headers", "ines", " Lines", "s", "words", "cells", "line", "results", "ipes", "pages"], "outputFile": ["errorFile", "errorfile", "outputDir", "errorFiles", "errorDir", "outputfile", " outputDir", "OutputDir", "Outputfile", "OutputFile", "outputFiles", " outputfile", "OutputFiles", " outputFiles"], "numTests": ["numTickets", " numTipes", " numNesters", "numFests", "numtickets", "numTipes", "numTches", " numTches", "numFches", "numTriesters", " numFests", "numNickets", "numTrainesters", "numTrainickets", "numTriches", "numtasks", " numNasks", "numTasks", " numFesters", "numtesters", "numNasks", "numTesters", "numPatipes", "numTriipes", " numFches", "numTriests", "numtests", "numPatches", " numNests", "numFesters", " numTasks", " numTesters", " numFipes", "numFipes", "numTrainasks", "numPatests", "numNesters", "numPatesters", "numNests", " numNickets", " numTickets", "numTrainests"], "i": ["p", "li", "start", "id", "ci", "ix", "index", "ini", "d", "ai", "ind", "l", "gi", "I", "ri", "ii", "ti", "e", "end", "ir", "pi", "xi", "k", "z", "ij", "b", "ip", "u", "qi", "n", "si", "int", "iu"], "r": ["p", "o", "rb", "R", "br", "range", "rc", "q", "ar", "mr", "d", "h", "l", "ru", "f", "cr", "right", "nr", "fr", "e", "ir", "t", "ur", "rr", "k", "z", "rg", "rn", "a", "w", "g", "s", "b", "sr", "v", "re", "u", "n", "rs", "er"], "c": ["p", "o", "cu", "ci", "ch", "cc", "col", "cf", "lc", "dc", "nc", "cn", "sc", "q", "d", "arc", "h", "max", "l", "f", "cr", "count", "cp", "uc", "e", "t", "cache", "ce", "fc", "ec", "k", "z", "cat", "ic", "con", "cycle", "cm", "co", "w", "cl", "C", "g", "a", "s", "b", "v", "u", "n", "cs", "mc", "ac"], "m": ["mod", "p", "o", "mm", "q", "mr", "d", "h", "l", "f", "cr", "e", "t", "M", "z", "k", "cm", "w", "g", "im", "C", "mi", "b", "v", "s", "u", "n", "mc"], "x": ["p", "o", "dx", "val", "ix", "xxx", "yx", "index", "q", "d", "h", "ex", "X", "l", "f", "data", "e", "code", "t", "key", "el", "xi", "k", "z", "xs", "xc", "a", "w", "work", "rx", "xy", "b", "v", "s", "xp", "ctx", "xx", "n", "int"], "openCells": ["openCcells", "openCell", " openCipes", "OpenCodes", "openRipes", "openChcells", " openTells", "openedcells", "OpenCalls", "closeRels", "openSels", "openPodes", "openTells", "openedRches", "openChhips", "openedRells", "OpenCcells", "openedCalls", "openNels", "openPatches", "closedRalls", " openTodes", "closedRaches", "openNells", "openTodes", "opencodes", "closeRomes", "openCatches", "OpenTatches", "openRaches", "closeComes", "openCodes", "OpenSches", "openNows", "openedChips", "closedCalls", "openedcels", "openedCels", "openedRhips", "closedCaches", "closeRows", "openCipes", "openCows", "openedCells", "openTches", "openRalls", "OpenCches", "OpenTcells", "openWalls", "openedRalls", "openPches", "OpenSodes", "closedRhips", "openNomes", "closedChips", "openShips", "openTipes", "openRhips", " openCodes", "OpenTells", "OpenCels", "openCels", "closeCows", "openCalls", "OpenCatches", "openRell", "openPcells", "openPels", "openSipes", "openRodes", "openedcalls", "closeCells", "openTels", "opencels", "openRows", "openRches", "OpenSell", " openTels", "closedRells", "openSodes", "openComes", "OpenSells", "closeRells", "opencells", "openChips", "openRells", "openRels", "OpenTalls", " openTipes", "closeCels", "openChatches", "openChches", "closedCells", "openChaches", "openWells", "openSches", "openChalls", " openCels", "openedCches", "openRomes", "openTcells", "openedcodes", "opencell", "openWodes", "openWels", "openWhips", "OpenCells", "openTatches", "OpenCell", "openCaches", "opencalls", "openSows", "OpenSels", "openPalls", "openChells", "openCches", "openWaches", "openedCodes", "openSells", "openPells", "openSalls", "openTalls", "openSell", "openSomes", "OpenSalls"], "works": ["aces", " contracts", "features", " runs", " chains", "forms", "workers", "res", "ws", " starts", "makes", " weights", "hands", "ches", "hops", "working", "width", "ns", "nn", "WORK", "jobs", " moves", "ops", "results", "es", " squares", "reads", "right", " coordinates", "checks", "batch", "Works", "mask", " spins", "shape", "dates", " covers", " results", "holes", "wh", "blocks", "acts", " turns", " features", " patches", " workers", "work", "w", " networks", "words", "cells", "days", "planes", "shows", "cs", "worker", "cases", "breaks"], "matrix": ["catrix", "mrices", "Matrices", " matov", "Matrice", "Matri", "MATograph", "donpack", "calrics", "MatMatrix", " matrices", "materialrix", "scheograph", "memric", " matrice", "calrices", "calrix", "atrices", "formatrix", "catric", "memrix", "schelas", "atcost", "attric", " matpack", "matric", " matensor", " matrics", "matMatrix", "MATrices", "calric", "atrix", "matpack", " matric", "applicationensor", "matcost", "matrics", "materialensor", "matrow", "attrix", "matensor", "donensor", "matri", "MATric", "matov", " matri", "matrice", "scheric", "materialomo", "utric", "mitric", "utribution", "scherices", " matcost", "Maturation", "donric", "formatrics", "applicationric", "Matomo", "matfix", "scherix", "formatcost", "matrices", "MATlab", "atric", "MATrow", "MATuration", "applicationomo", "MATlas", "atrice", "mitix", "Matlas", "Matensor", "matnn", "MATri", "formatric", "utray", " matfix", " matlab", "catensor", "MATov", "matograph", "materialov", "Matlab", "MATfix", " matMatrix", "mrow", "atMatrix", "matix", "scheix", " matnn", "Matrix", "Matric", " matrow", "matribution", "materialric", "matomo", " matix", "matlas", "schepack", "mitpack", "Matfix", "Matograph", "materialrices", "utrix", "matray", " maturation", "applicationrix", "maturation", "memray", "mitrix", "matlab", "attribution", "donrix", "formatrices", "MATnn", "catpack", "memribution", "mnn", "mrix", "attray", "MATrix"], "j": ["p", "it", "_", "o", "br", "li", "ch", "js", "jc", "col", "index", "q", "jp", "ji", "d", "J", "un", "h", "l", "f", "adj", "ii", "e", "jl", "aj", "key", "ie", "k", "cell", "z", "jj", "ja", "cm", "co", "w", "g", "im", "ij", "dj", "b", "v", "jo", "u", "n", "ct", "uj"], "order": ["p", "acc", "ordering", "array", "sort", "unit", "case", "id", "address", "all", "ow", "tr", "rank", "index", "ode", "center", "q", "comb", "random", "h", "record", "cr", "position", "right", "e", "rule", "ord", "code", "ordered", "shape", "Order", "axis", "type", "w", "work", "row", "orders", "v", "b", "direction", "n"], "y": ["p", "o", "ch", "col", "q", "ye", "ay", "d", "ny", "ya", "dy", "yo", "vy", "l", "yt", "e", "yi", "year", "z", "Y", "yl", "w", "ey", "xy", "b", "v", "ty", "oy", "n", "yy", "yr", "cy"], "filledRows": ["filledLays", "filledMow", "filledLow", "loadedRrows", "closedRows", "workedrucks", "filledRow", "filledRsells", "workedRucks", " filledCow", "filledNows", "filledNOWS", "loadedCells", "filledRsays", "loadedRays", "workedrrows", "workedRows", "filledChOWS", "filledralls", "filledCOWS", "filledMows", "workedrocks", "fillMow", "filledCucks", " filledRow", "filledRells", "filledCows", "filledChells", "filledEnducks", "loadedCows", "confirmedRays", "filledLows", "filledNells", "closedCalls", "filledRucks", "filledRays", "closedCOWS", "loadedCays", " filledCrows", "filledChows", "filledLells", "filledRsows", "closedCrows", "filledNrows", "closedCows", "confirmedRells", "filledRsrows", "filledCocks", "loadedCow", "loadedRows", "filledrucks", "loadedRells", "filledrows", "filledEndocks", "filledCrows", "fillROWS", "filledRocks", " filledCows", " filledRells", "fillRows", " filledRays", "filledLOWS", "filledEndows", "loadedCrows", " filledROWS", "filledLrows", "filledrocks", "fillRow", "fillRells", "filledROWS", "closedRrows", "fillMows", "confirmedROWS", "workedRocks", "filledRalls", "workedrows", "filledRsow", "loadedROWS", "filledCays", "filledCalls", "workedRrows", " filledCells", "filledrrows", "confirmedRows", "closedROWS", "filledMOWS", " filledCays", " filledCOWS", "filledEndrows", "loadedRow", "fillMOWS", "filledChays", "filledRsOWS", "filledRrows", "filledCow", "filledCells", "filledMells", "loadedCOWS", "filledrOWS", " filledRrows", "fillMells", "closedRalls"], "remainder": ["remainingcer", " remainDER", "remainsser", "REMainsder", "remainser", "remainingser", "remamanter", "demainner", "demainder", "remAINner", "remainingDER", "remAINDER", "remainler", "remainster", "remainedcer", " remainster", "mainke", "remamancer", "mainster", "remainerke", "demrainser", "demraincer", "remAINler", "REMainsDER", " remainscer", "remainerter", "mainser", " remainter", "remainingder", "remainedDER", "REMainsner", "remrainner", "remainsder", "mainsser", "demaincer", "REMainsler", "remainedler", "mainder", " remainsder", "demrainder", "remainedner", "remainsDER", "mainske", "remainerser", "remaincer", "remainscer", "remainingter", " remainsDER", "remAINder", "remainerder", "remraincer", "remainner", "remainsler", "REMainder", "REMainDER", "remrainser", "remainske", "remainedder", "mainsder", "demainser", "remainingke", "REMainler", "remainke", "remrainder", "remainsner", "REMainner", "mainter", " remaincer", "remainter", "remainDER", "remamanDER", "remainedser", "demrainner", "remamander"]}}
{"code": "inputFile = open('A-small-attempt0.in', 'r')\\n  lines = inputFile.readlines()\\n  inputFile.close()\\n  \\n  outputFile = open('A-small-attempt0.out', 'w')\\n  \\n  numTests = int(lines[0])\\n  \\n  \\n  currLine = 1\\n  for i in range(1, numTests+1):\\n      firstRow = lines[int(lines[currLine])+currLine]\\n      currLine += 5\\n      secondRow = lines[int(lines[currLine])+currLine]\\n      currLine += 5\\n  \\n      firstNums = map(lambda x: int(x), firstRow.split())\\n      secondNums = map(lambda x: int(x), secondRow.split())\\n      \\n      intersect = [v for v in firstNums if v in secondNums]\\n  \\n      outputFile.write('Case #'+str(i)+': ')\\n      if len(intersect) == 1:\\n          outputFile.write(str(intersect[0])+'\\n')\\n      elif len(intersect) == 0:\\n          outputFile.write('Volunteer cheated!\\n')\\n      else:\\n          outputFile.write('Bad magician!\\n')\\n  \\n  outputFile.close()\\n      \\n", "substitutes": {"inputFile": [" inputDirectory", "tempfile", "outputDirectory", "inputDirectory", "InputFile", "InputStream", "inputStream", " inputfile", "sourceDirectory", " inputStream", "readerFiles", "readerDirectory", "InputFiles", "inputFiles", "tempFiles", "tempFile", "tempDirectory", "readerfile", "outputfile", "readerFile", "outputStream", "sourcefile", "InputDirectory", "sourceFiles", "sourceFile", "outputFiles", " inputFiles", "inputfile"], "lines": ["notes", "les", "tests", "steps", "bands", "forms", "files", "vals", "ls", "lists", "log", "mails", "limits", "params", "users", "pins", "books", "styles", "codes", "works", "strings", "ids", "reads", "locks", "data", "points", "cycles", "breaks", "items", "flows", "models", "values", "lins", "frames", "objects", "rows", "posts", "verts", "elines", "rules", "sections", "years", "holes", "lights", "letters", "blocks", "groups", "xs", "headers", "ines", "s", "words", "cells", "line", "balls", "shows", "results", "loads", "pages"], "outputFile": ["OutputStream", "productionFile", "writefile", "OutputDirectory", "outFile", "officeLine", "outputDirectory", " outputDir", "productionLine", "productionFiles", "productionFilename", "OutputLine", "resourceLock", "fullDir", "writeFile", "officeLock", " outputStream", " outputDirectory", "responseStream", "outputLock", "outLine", "OutputModel", " outputPlace", "productionDirectory", "resourceLine", "responseLine", " outputLock", "outModel", " outputFilename", "outStream", "outputFilename", " outputLine", "writeDirectory", "outputDir", "responseFile", "resourceFile", "productionPlace", "outputStream", "outputfile", "resourcefile", "officeFile", "OutputPlace", " outputModel", "OutputFile", "OutputFilename", " outputfile", "fullDirectory", "responsePlace", "fullFile", "outputModel", "outputLine", "productionStream", "fullfile", "writeDir", "outputFiles", "outputPlace", "OutputFiles", "officefile", " outputFiles"], "numTests": ["numMatrams", "numUnitches", "NumNests", "numUnitcases", "numTches", "numTries", "numNcases", "numMatries", "numPasks", "numtches", "numtits", " numNasks", "numTasks", "numTcases", "numNasks", "NumTches", "NumTests", "numTits", " numNrams", "numtcases", "numNits", "numtests", "numUnitits", "numUnitests", "NumTcases", " numNests", "numNches", "numNries", "numMatasks", " numNries", "numTrams", "numPests", " numTasks", "NumNcases", "numPries", "NumNches", "NumTits", "numNrams", "numPrams", " numTrams", "numNests", "NumNits", " numTries", "numMatests"], "currLine": ["currdL", " currWrite", " currLink", "curreRow", " curreFile", "curreL", "currRow", " currsBlock", "curinLine", "currdFile", " curreLink", "curreLine", "curreHalf", " currPage", "currePage", "currdRow", "curreBlock", "CurreLine", "currerLine", "currerline", "currsPage", " curreL", "curruBlock", "currWrite", "currnChar", " currLin", " curreRow", "curruLine", "currChar", "curreLink", "CurryLine", "currantL", "currsLink", "curinRow", " currline", " currFile", "curnerLin", "curinBlock", " currePage", "curreWrite", "currPage", "curruFile", "currsBlock", " curreline", "curreFile", " curreWrite", "CurrRow", " currsHalf", "CurrLink", "currLink", "curruLin", "currL", "currHalf", "currsRow", "curnerLine", "CurryBlock", "curruRow", "CurryRow", "currLin", "CurrLine", "CurreLink", "curryBlock", "currBlock", "CurreFile", "currantLine", " currBlock", "currerRow", " currL", "curnerWrite", "currantRow", " currsRow", "CurrChar", "curreline", "currnRow", "curryLine", "currantline", "curruWrite", "curnerFile", "CurrBlock", "currnLine", "curryLink", "currdLine", "CurreRow", "curreLin", " curreLin", "CurrFile", "currsLine", "currantLink", "currsHalf", " currRow", "currline", "curruL", "currantFile", "currFile", "curryPage", " currHalf", "curryChar", "currnBlock", "currerL", " curreLine", "currsFile", "curinHalf", "curruChar", "CurryChar", " currsLine", "curryRow"], "i": ["p", "it", "iq", "chi", "li", "start", "id", "ci", "index", "m", "d", "x", "ind", "h", "l", "gi", "I", "f", "ii", "c", "ti", "e", "t", "num", "uri", "trial", "pi", "k", "j", "b", "ip", "u", "qi", "n", "si", "int", "iu"], "firstRow": [" firstCell", "lastRow", "lastBlock", "secondLine", "firstBlock", "lastCell", "firstLine", "secondPage", "lastLine", " firstPage", "lastPage", " firstBlock", "secondBlock", "firstCell", "secondCell", "firstPage", " firstLine"], "secondRow": ["secondaryCell", " secondCell", "fourthCell", "secondColumn", "SecondLine", "Secondrow", "secondLine", "secondaryColumn", " secondColumn", "SecondCell", "secondaryRow", "fourthrow", "secondrow", "fourthLine", "secondaryLine", "SecondRow", "SecondColumn", "fourthRow", " secondrow", " secondLine", "secondCell"], "firstNums": ["FirstNum", "FirstNams", "firstnoms", "firstComs", "firstnums", "FirstNumbers", "Firstnumbers", "firstNoms", "firstCumbers", "firstSams", "firstCams", "firstSumbers", "Firstnums", "firstNum", "firstSums", "firstCum", "firstNams", "Firstnum", "firstNumbers", "Firstnoms", "FirstNums", "firstnum", "firstnams", "Firstnams", "firstSoms", "firstnumbers", "FirstNoms", "firstCums", "firstSum"], "secondNums": ["secondNames", " secondnumbers", "secondnums", " secondNumbers", "secondCues", " secondRoms", "secondRums", "secondnames", " secondNues", "secondSum", "secondnumbers", " secondRums", "secondRumbers", "secondNum", " secondnum", "secondRames", "secondNues", "secondCames", "secondCums", "secondNumbers", "secondCumbers", " secondnues", " secondRames", "secondSumbers", " secondNoms", " secondnums", "secondComs", "secondSues", "secondNoms", " secondNum", " secondRumbers", "secondnum", "secondCum", "secondnues", "secondSums", "secondRoms", "secondnoms", " secondNames"], "intersect": ["Interrupt", "separsection", "diffsect", "diffect", "interection", "conect", "subsect", "interect", "consection", "conection", "separcept", "separsect", "subcept", "subrupt", "subsection", "consect", "intercept", "Interection", "diffsection", "transsect", "diffcept", "separrupt", "intersection", "transcept", "transection", "transect", "concept", "interrupt", "Intersection", "transsection", "Intercept", "Intersect", "Interect", "conrupt"], "v": ["p", "it", "ov", "case", "id", "vs", "val", "vt", "version", "nv", "q", "m", "d", "x", "h", "l", "f", "iv", "c", "vi", "lv", "volt", "t", "tv", "uv", "key", "var", "age", "vid", "k", "z", "match", "value", "inv", "ve", "g", "j", "V", "b", "vv", "u", "sv", "n", "int", "word"]}}
{"code": " \\n  INPUT = 'C-small-attempt0.in'\\n  OUTPUT = 'C-small-attempt0.out'\\n  \\n  \\n  def solve(R, C, M):\\n      grid = [[0 for c in range(C)] for r in range(R)]\\n  \\n      def get_cell(cell_r, cell_c):\\n          if not(0 <= cell_r < R):\\n              return None\\n          if not(0 <= cell_c < C):\\n              return None\\n          return grid[cell_r][cell_c]\\n  \\n      def for_each_neighbour(cell_r, cell_c, func):\\n          ret = []\\n          coords = (\\n              (cell_r - 1, cell_c - 1), (cell_r - 1, cell_c), (cell_r - 1, cell_c + 1),\\n              (cell_r, cell_c - 1), (cell_r, cell_c + 1),\\n              (cell_r + 1, cell_c - 1), (cell_r + 1, cell_c), (cell_r + 1, cell_c + 1)\\n          )\\n          for nb in coords:\\n              if get_cell(nb[0], nb[1]) is not None:\\n                  ret.append(func(nb[0], nb[1]))\\n          return ret\\n  \\n      def mark_dirty(cell_r, cell_c):\\n          if grid[cell_r][cell_c] != '*':\\n              grid[cell_r][cell_c] += 1\\n      \\n      def unmark_dirty(cell_r, cell_c):\\n          if grid[cell_r][cell_c] != '*':\\n              grid[cell_r][cell_c] -= 1\\n  \\n      def check_empty_neighbours(cell_r, cell_c):\\n          return (0 in for_each_neighbour(cell_r, cell_c, lambda r, c: get_cell(r, c)))\\n  \\n      def click():\\n          for i, row in enumerate(grid):\\n              for j, cell in enumerate(row):\\n                  if cell != '*':\\n                      if cell == 0 or ((R * C - M) == 1):\\n                          grid[i][j] = 'c'\\n                          return\\n  \\n      def place_mine():\\n          for i, row in enumerate(grid):\\n              for j, cell in enumerate(row):\\n                  if cell == '*':\\n                      continue\\n                  prevstate = grid[i][j]\\n                  grid[i][j] = '*'\\n                  for_each_neighbour(i, j, mark_dirty)\\n                  if not (True in for_each_neighbour(i, j, check_empty_neighbours)):\\n                      grid[i][j] = prevstate\\n                      for_each_neighbour(i, j, unmark_dirty)\\n                  else:\\n                      return True\\n          return False\\n  \\n      for m in range(M):\\n          if not place_mine():\\n              return 'Impossible\\n'\\n  \\n      click()\\n  \\n      ret = ''\\n      for row in grid:\\n          ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\\n'\\n  \\n      return ret\\n  \\n  \\n  if __name__ == '__main__':\\n      inp = open(INPUT)\\n      out = open(OUTPUT, 'w')\\n      \\n      T = int(inp.readline())\\n  \\n      for case in range(T):\\n          sol = solve(*map(int, inp.readline().split()))\\n          out.write('Case #%i:\\n%s' % (case + 1, sol))\\n", "substitutes": {"INPUT": [" INOU", " OUTCT", "INOU", "inPUT", " OUTOU", "INST", " INST", " INCT", "INCT", " OUTST", "inOU", "inST", "inCT"], "OUTPUT": [" OUTTAOT", "OUTROT", "OUTATE", "OUPLUT", "OUTPOT", "OUPLOT", " OUTTAURE", "OUTRURE", " OUTTAUT", "OUTAUT", "OUTPTE", " OUTTATE", "OUTRTE", " OUTTPTE", " OUTTPOT", "OUTAOT", "OUTAURE", "OUTRUT", "OUPLTE", "OUPLURE", " OUTTPURE", " OUTTPUT", "OUTPURE"], "R": ["P", "A", "CR", "S", "B", "MR", "RA", "L", "RR", "F", "X", "RN", "K", "Rs", "E", "NR", "RH", "DR", "RO", "D", "G", "Rh", "U", "GR", "Y", "V", "H", "RG", "Q", "W", "N", "SR", "RC", "RM"], "C": ["CC", "Z", "P", "A", "Cr", "CR", "SC", "S", "B", "CI", "JC", "DC", "L", "CL", "CM", "AC", "X", "F", "K", "I", "CU", "E", "CT", "CN", "CO", "VC", "UC", "D", "G", "NC", "EC", "MC", "U", "Y", "CA", "V", "H", "CP", "Q", "W", "N", "CV"], "M": ["Z", "P", "O", "LM", "CR", "A", "S", "MN", "B", "MR", "J", "L", "CM", "F", "X", "I", "K", "E", "D", "G", "MC", "U", "Y", "V", "H", "Q", "W", "N", "RM"], "grid": ["house", "box", "align", "array", "node", "query", "res", "div", "unit", "hold", "lay", "list", "group", "gm", "export", "col", "layout", "range", "db", "press", "entry", "file", "surface", "gui", "gr", "q", "domain", "slice", "Grid", "arr", "data", "edge", "client", "table", "rule", "mag", "chain", "book", "complex", "cache", "draw", "age", "map", "grain", "ge", "dict", "graph", "module", "input", "cart", "cube", "window", "column", "reg", "auto", "g", "cm", "storage", "server", "model", "line", "panel", "gap", "mat", "block", "gu", "df", "station", "vg", "layer", "site"], "c": ["err", "p", "cu", "ci", "ch", "cc", "col", "cf", "lc", "nc", "dc", "rc", "cn", "ar", "d", "ct", "x", "h", "l", "f", "cr", "cp", "uc", "e", "rr", "ce", "ec", "rh", "cin", "anc", "con", "cm", "xc", "rn", "w", "b", "v", "ca", "n", "cs", "mc", "pc", "ac", "cy"], "r": ["err", "p", "rb", "ra", "range", "run", "rc", "ar", "mr", "kr", "d", "usr", "rf", "ri", "f", "cr", "ru", "rd", "nr", "fr", "e", "ir", "rr", "rar", "rh", "rt", "k", "rg", "cm", "co", "w", "re", "sr", "b", "hr", "u", "pr", "resource", "n", "rs", "er", "yr"], "cell_r": ["char_r", "charalrec", "char64c", "cell_o", "cell_ro", "cell_ar", "cell_l", "cell9rt", "cel_er", "cel_dr", "cellJro", "save_r", "cel_hr", "cell_ur", "client_rt", "save_nr", "save_ro", "cellJnr", "client9hr", "client_ro", " cell_rb", "cellJhr", "cellalr", "cel_c", "client9rt", "cellJr", "cell_rb", "cel_sr", "charalrc", "char_rc", "cellalrc", "charalr", "cellJc", "charge_nr", "cel_ro", "cell9hr", "cell1nr", "cellalrec", "cel_r", "charalt", "cellinghr", " cell_rc", "char_t", "cellingsr", "cell_rh", "cell_hr", "cellalt", "cel_ur", "char64dr", "cel_nr", "char_c", "cel_ar", "cel_rt", "draw_n", "cell_d", "case_ro", "charge_right", "cell_sr", "cellingc", "cell64h", "draw_ro", "cell_er", "client_hr", "char64nr", "cell_nr", "draw_r", "char_nr", "cell_rt", "cell1rw", "client9ro", "cell64c", "case_r", "charge_r", "save_rh", "char64r", " cell_ar", "cell64dr", "client_r", "cell_t", "cel_o", "charge_rb", "cell_rec", "cel_rw", "cellJrh", " cell_nr", "cell1c", "cel_right", "cell9ro", "cell_rc", "cell_n", "cell_rw", "cellJdr", "cell1r", "cellingdr", "char_rec", "cel_l", "cell_right", " cell_l", "case_c", "case_d", "cell64ar", "draw_nr", "cell64nr", "cell_h", "cell9r", "char_dr", "cellingr", "cel_h", "cell_dr", "cellJrt", "cell64r", "client9r"], "cell_c": ["cell67i", "cel_1", " cell_i", "cellWm", "iceJw", "cellAcc", " cell_cin", "cellFr", "cell_pc", " cell_center", "save_c", " cell_rec", "cellIPchain", "cell25c", "cell53ci", "Cell_c", "cell_t", "cellLcin", "cell_ci", "cel_i", "save_r", "cell54t", "cellScenter", "Cell_r", "CellIPc", "cellAi", "cell54r", "ice_w", "cellWc", "contact_chain", "cellIdpc", "cell25d", "cellXrec", "cel_c", " cell_cc", "cellDm", "cel_b", "cellAcenter", "save67r", " cell_fc", "cellAfc", "cell67c", "ice_center", "cell_center", "cell25r", "cell_1", "cell_con", "cell67ci", "cellJc", "cellJcenter", "cellXC", "cellAci", "cell_nc", "cellSc", "cell_fc", "cell_cur", "cell_dc", "cellDr", "cellacc", "cellIPcu", "ell_cur", "save_t", "cell67r", "pixel_cin", "iceJc", " cell_m", "cel_r", "CellIPr", "contact_n", "ell_c", "cell_C", "cell_cu", "cell25ci", "cell54c", "cel_fc", "cellIPfc", "cellXc", "cellIPr", "cell67fc", "cellLc", "cell67nc", "cel_dc", "cell25fc", " cell_pc", "cell54nc", "Cell_cs", "cellFci", "cell25center", "cellWr", "cell_i", "contact_c", "cellXcc", "cellAr", "cellIdr", "cel_d", "cell_d", "pixel_r", "save67t", "save_nc", "cellIPC", "Cell_cu", "cellIPcs", "cel_ct", "cell67center", "cellIPcur", "ice_c", "iceJcur", "cell_cin", "iceJcenter", "cellSw", "cell67cin", "cell_w", "cel_center", "cellWcon", "cel_ec", "CellIPcu", "cell_cs", "cellFfc", "contact_cs", "cel_ci", "cel_cu", "cell25i", "cell67ec", "cellDcon", "cellJw", "cellLr", "pixel_d", "CellIPcs", "ice_cur", "cell_rec", "cell53c", "cellIPc", "cell_cc", "pixel_c", "cell67t", "cell25b", "cellIPcin", "cell_n", "cellDc", "save67c", "cellAc", "cel_C", "cell67cu", " cell_C", "cellScur", " cell_con", "cel_cin", "cellacr", "cell53cin", "cellJcur", "cell_m", "save67nc", "cellArec", "cellacdc", "cellFc", "cell_ec", "cellAC", "cellIdw", "cell53r", " cell_ci", "cellIdc", "ell_chain", "cell_chain", "cellac1", "ell_C", "cell_ct", " cell_w", "cell_b"], "func": ["conv", "node", "val", "cc", "unc", "cf", "nc", "worker", "dec", "loop", "comb", "function", "slice", "fn", "f", "code", "callback", "aug", "map", "wrapper", "fc", "proc", "self", "obj", "module", "sec", "apply", "con", "cb", "super", "Function", "work", "fun", "bc", "exec", "sys", "loc", "df", " function", "layer", "pc", "method"], "ret": ["ref", "array", "all", "val", "res", "group", "resp", "db", "len", "gt", "ext", "d", "alt", "true", "fn", "rets", "default", "arr", "data", "str", "end", "repl", "el", "dict", "output", "obj", "rt", "nt", "part", "Ret", "arg", "bf", "reg", "det", "fab", "fun", "last", "union", "b", "re", "reply", "mat", "detail", "RET", "result", "rep"], "coords": ["loccoord", "coordorder", "Coord", "coordords", "Cocoord", "coord", " cocoord", "Coords", "coinates", "locord", "coorder", " coinates", " coord", " coorder", "coordinates", "Coinates", "locinates", "locords", "cocoord", "coordord", "locorder"], "nb": ["nob", "NB", "iq", "nu", "node", "eb", "sn", "qq", "bg", "nc", "sb", "db", "cn", "gb", "nm", "ns", "nit", "nn", "np", "ny", "bi", "mb", "ob", "fn", "lab", "adj", "nr", "bin", "bm", "byn", "bp", "batch", "num", "nl", "bs", "obj", "bb", "bf", "ni", "cb", "abb", "ab", "bc", "ib", "nd", "wb", "bn", "b", "number", "n", "kb", "ne", "bd", "net", "dn", "binary"], "i": ["p", "o", "ui", "li", "ci", "ini", "ai", "x", "bi", "l", "ri", "f", "I", "gi", "y", "ii", "e", "yi", "xi", "di", "pi", "k", "mi", "b", "v", "u", "n", "si", "io", "iu"], "row": ["child", "array", "node", "id", "user", "group", "col", "index", "range", "entry", "q", "order", "x", "raw", "data", "ell", "key", "rows", "post", "roll", "k", "input", "cube", "auto", "column", "object", "Row", "v", "ray", "line", "flow", "block", "item", "feed", "bug", "slice"], "j": ["p", "o", "li", "ch", "jc", "q", "jp", "ji", "d", "J", "x", "kj", "h", "l", "y", "f", "ii", "adj", "e", "jl", "aj", "el", "job", "k", "z", "jj", "ja", "ij", "dj", "left", "b", "v", "jet", "n", "si", "uj"], "cell": ["p", "o", "offset", "ver", "node", "ci", "label", "cc", "group", "col", "lc", "Cell", "index", "entry", "q", "ice", "cel", "x", "un", "ind", "l", "f", "count", "uc", "charge", "ell", "key", "inc", "form", "cache", "num", "component", "k", "z", "sec", "column", "co", "g", " Cell", "field", "v", "line", "cells", "model", "call", "pixel", "slice", "cal"]}}
{"code": " \\n  INPUT = 'A-small-attempt0.in'\\n  OUTPUT = 'A-small-attempt0.out'\\n  \\n  \\n  def solve(answer1, arr1, answer2, arr2):\\n      ret = None\\n  \\n      for card in arr1[answer1 - 1]:\\n          if card in arr2[answer2 - 1]:\\n              if ret is not None:\\n                  return 'Bad magician!'\\n              else:\\n                  ret = card\\n      if ret is None:\\n          return 'Volunteer cheated!'\\n      return ret\\n  \\n  if __name__ == '__main__':\\n      inp = open(INPUT)\\n      out = open(OUTPUT, 'w')\\n      \\n      T = int(inp.readline())\\n  \\n      def read_answer_and_arr():\\n          answer = int(inp.readline())\\n          arr = []\\n          for i in range(4):\\n              arr.append( map(int, inp.readline().split()) )\\n          return answer, arr\\n  \\n      for case in range(T):\\n          answer1, arr1 = read_answer_and_arr()\\n          answer2, arr2 = read_answer_and_arr()\\n  \\n          out.write('Case #%i: %s\\n' % \\\\n                          (case + 1, solve(answer1, arr1, answer2, arr2)))\\n", "substitutes": {"INPUT": ["INFILE", "InFT", "InLINE", " INFT", " INUT", "inFIG", "InUT", "inFILE", "INFT", " INFIG", " INFILE", "inUT", "inPUT", " INLINE", "INLINE", "INFIG", "InFIG", "InFILE", "inLINE", "inFT", "InPUT", "INUT"], "OUTPUT": ["OUSPORT", "OUDCJECT", " OUTTHTH", "OUTTPJECT", "OUTDPOUT", "OUTPORT", "OUDCPUT", "OUTCJECT", "OUTCUT", "OUSPut", "OUTHORT", "OUTPPUT", "OUIPUT", " OUTTPut", "OUTHTH", "OUTHUT", "OUDCUT", "OUTDPPUT", "OUIPut", "OUTPOUT", "OUTDPUT", " OUTTPORT", "OUDCOUT", "OUTTPUT", "OUTPTH", "OUSPUT", "OUDPUT", "OUTTPPUT", "OUTCPUT", " OUTTHut", "OUDPPUT", "OUSPTH", "OUTPut", "OUTCOUT", " OUTTHUT", "OUTTPOUT", "OUTHut", "OUDPOUT", " OUTTPTH", "OUDPJECT", "OUIPTH", " OUTTPUT", "OUTPJECT", " OUTTHORT", "OUIPORT", "OUTDPJECT"], "answer1": ["answerb", "Answer1", "Answerone", "response1", "array2", "address1", " answerX", "answerone", "response2", "resultOne", "response3", "Answer01", "address01", "arrayX", "answerX", "resultb", "question3", "answerOne", "result1", "responseOne", " answer01", " answerone", "resultX", "result3", "question1", "question2", "questionOne", "answer01", "arrb", "result2", "answer3", "array1", "addressone", "responseb"], "arr1": ["array2", "str2", "arone", "arr3", "answerone", "ar2", "err2", "arrn", "answerOne", "arr9", "ar1", "arrayn", "arn", "answer9", " arrOne", "strone", "answern", "arrayone", "arrone", "arrayOne", "str3", "err1", "array9", "errone", "answer3", "array3", "array1", "arrOne", "str1", "err3", " arr9"], "answer2": ["answerb", "arr02", "response1", "question5", "arr5", "answer0", "responseTwo", "response2", "arr52", "reply0", " answer5", " answer62", " answersecond", "replyTwo", "reply62", "arr0", "reply2", " answer0", " answer52", "addresssecond", "answersecond", "address2", "addressTwo", "answerTwo", "question0", "question02", "answer52", "response52", "question2", "answer02", "arrb", "replysecond", "answer62", "answer5", " answer02", " answerb", "arrTwo", "replyb", "arr62", " answerTwo"], "arr2": ["array4", "arr82", "adr2", "arr4", "ar8", "arraytwo", "array2", "arr3", "arr5", "answer0", "rr1", "err5", "ar2", "adr82", "rr2", "err2", "adrtwo", " arr5", "ar5", "arr0", "rr0", "arrtwo", "ar0", "ar1", "errTwo", "ar4", "err4", "answer4", "adr1", " arr4", "err1", "answer8", "arr8", "answer3", "rr8", "array3", "array1", "array82", "arch82", "err3", "arrTwo", "archtwo", " arrTwo", "arTwo", "arch2", "arch1"], "ret": ["res", " result", "rest", "lit", "arc", "orig", "rets", "default", "fit", "code", "part", "nt", "let", "arg", "match", "reg", "fun", "test", "comment", "id", "resp", "python", "gt", "msg", "opt", "data", "end", "vert", "back", "capt", "mel", "mt", "det", "pret", "ut", "result", "token", "rep", "bad", "ver", "valid", "hard", "f", "str", "et", "final", "__", "best", "crit", "mat", "reply", "pat", "ref", "err", "art", "val", "ert", "feat", " RET", "red", "alt", "mart", " Ret", "oret", "Ret", "cat", "exit", "re", "compl", "RET"], "card": ["gen", "parse", "comment", "div", "cards", "list", "valid", "aqu", "catch", "std", "circ", "du", "cue", "man", "any", "null", "arc", "orig", "coord", "parent", "missing", "cont", "custom", "default", "c", "author", "reason", "mart", "ck", "draw", "empty", "ult", "cmp", "cart", "cat", "match", "check", "aff", "mult", "vard", "co", "par", "C", "compl", "Card", "ard", "char", "crit", "bug", "n", "gu", "error", "word", "coll"], "inp": ["inb", "insv", "INv", "Inpt", "logpp", "inpo", "incP", "INc", "Inp", "innps", " inc", "minpt", "inncp", "incv", "innpp", " incp", "insc", "logfp", " inb", "incp", "inccp", "Inb", "inc", "INP", "insp", "incc", "inpt", "logp", " inpo", "innc", "INp", "minb", "innp", "inv", "inP", "minc", "infp", "inpp", " inps", "minp", " infp", " inpp", "Inc", "innfp", " inpt", "inps", "insP", "logps", "innpo", "incpo"], "out": ["err", "img", "o", "prefix", "up", "new", "outs", "copy", "at", "doc", "log", "file", "name", "ext", "again", "ex", "parent", "lock", "orig", "wx", "next", "opt", "str", "temp", "trial", "output", "obj", "part", "window", "w", "Out", "OUT", "v", "call", "io", "error", "int", "exp"], "T": ["TT", "P", "A", "O", "R", "Length", "unit", "S", "WT", "B", "TA", "L", "F", "X", "I", "t", "E", "TN", "TX", "D", "M", "type", "Y", "V", "C", "length", "Case", "H", "number", "Q", "W", "N", "NT"], "answer": ["duration", "Answer", "err", "air", "offset", "response", "array", "audio", "address", "evidence", "score", "index", "order", "time", "au", "une", "true", "next", "en", "record", "nr", "question", "eni", "ace", "choice", "ell", "after", "abc", "round", "r", "ee", "value", "a", "length", "rue", "number", "reply", "result", "test", "int", "now", " answers"], "arr": ["err", "Array", "air", "acc", "br", "array", "res", "list", "aaa", "yr", "tr", "app", "ARR", "ar", "gr", "au", "ext", "arc", "stack", "adv", "fr", "data", "str", "adr", "att", "aj", "ell", "abc", "cache", "rr", "obj", "r", "dat", "arg", "par", "ab", "append", "attr", "xml", "int", "test", "Ar", "ras", "train", "enc", "aa", "rep"], "i": ["it", "iq", "li", "id", "ci", "index", "q", "ice", "d", "ai", "x", "ind", "I", "c", "ti", "e", "code", "ie", "num", "k", "r", "ic", "a", "j", "ib", "ip", "char"], "case": ["ASE", "me", "address", "rice", "app", "ACE", "CI", "name", "ice", "order", "su", "time", "example", "x", "position", "ace", "end", "nce", "code", "choice", "num", "trial", "ce", "shape", "match", "USE", "length", "Case", "instance", "line", "CE", "use", "rand", "race", " CASE", "ase", "result", "section", "test", "slice", "cases"]}}
{"code": " \\n  \\n  \\n  def check(R, C, M, _board):\\n      board = [line[:] for line in _board]\\n  \\n      pos = [(0, 0)]\\n      while pos:\\n          row, col = pos.pop()\\n          neighbor = []\\n          for r in (-1, 0, 1):\\n              r += row\\n              for c in (-1, 0, 1):\\n                  c += col\\n                  if r >= 0 and r < R and c >= 0 and c < C:\\n                      neighbor.append((r, c))\\n          count = len([1 for r, c in neighbor if board[r][c] == '*'])\\n          board[row][col] = str(count)\\n          if count == 0:\\n              for r, c in neighbor:\\n                  if board[r][c] == '.':\\n                      pos.append((r, c))\\n  \\n      flat = ''.join(''.join(line) for line in board)\\n      result = not flat.count('.')\\n      if not result and False: # for DEBUG\\n          print '-' * 20\\n          print R, C, M\\n          print '\\n'.join(''.join(line) for line in _board)\\n          print '-' * 20\\n      assert flat.count('*') == M\\n      return result\\n  \\n  \\n  def solve(R, C, M):\\n      board = [['.'] * C for row in range(R)]\\n      board[0][0] = 'c'\\n      row = R\\n      col = C\\n      mine = M\\n  \\n      while mine:\\n          if 0 < row <= col and mine >= row:\\n              for r in range(row):\\n                  board[row - r - 1][col - 1] = '*'\\n              mine -= row\\n              col -= 1\\n          elif 0 < col <= row and mine >= col:\\n              for c in range(col):\\n                  board[row - 1][col - c - 1] = '*'\\n              mine -= col\\n              row -= 1\\n          else:\\n              break\\n  \\n      if mine:\\n          while mine and row > 2:\\n              for r in range(min(mine, row - 2)):\\n                  board[row - r - 1][col - 1] = '*'\\n                  mine -= 1\\n              col -= 1\\n          while mine and col > 2:\\n              for c in range(min(mine, col - 2)):\\n                  board[row - 1][col - c - 1] = '*'\\n                  mine -= 1\\n              row -= 1\\n  \\n      if mine:\\n          if mine:\\n              board[1][1] = '*'\\n              mine -= 1\\n          if mine:\\n              board[1][0] = '*'\\n              mine -= 1\\n          if mine:\\n              board[0][1] = '*'\\n              mine -= 1\\n  \\n      assert mine == 0\\n      return '\\n'.join(''.join(line) for line in board) if check(R, C, M, board) else 'Impossible'\\n  \\n  \\n  def main(IN, OUT):\\n      T = int(IN.readline())\\n      for index in range(T):\\n          R, C, M = map(int, IN.readline().split())\\n          OUT.write('Case #%d:\\n%s\\n' % (index + 1, solve(R, C, M)))\\n  \\n  \\n  def makesample(maxSize=5, T=230):\\n      print T\\n      for index in range(T):\\n          R = random.randint(1, maxSize)\\n          C = random.randint(1, maxSize)\\n          print R, C, random.randint(0, R * C - 1)\\n  \\n  \\n  def makesample():\\n      pattern = []\\n      for R in range(1, 5+1):\\n          for C in range(1, 5+1):\\n              for M in range(R * C):\\n                  pattern.append((R, C, M))\\n      print len(pattern)\\n      for R, C, M in pattern:\\n          print R, C, M\\n  \\n  \\n  if __name__ == '__main__':\\n      if '-makesample' in sys.argv[1:]:\\n          makesample()\\n      else:\\n          main(sys.stdin, sys.stdout)\\n  \\n", "substitutes": {"R": ["P", "A", "CR", "Col", "S", "B", "RA", "T", "L", "RR", "F", "X", "K", "I", "Rs", "E", "NR", "RH", "RO", "TR", "D", "G", "Rh", "U", "Y", "V", "H", "Row", "Q", "W", "N"], "C": ["CC", "P", "O", "A", "Col", "CR", "SC", "S", "B", "CI", "T", "DC", "L", "CL", "CM", "AC", "X", "F", "K", "I", "CU", "E", "CN", "D", "G", "NC", "U", "Y", "V", "H", "W", "N"], "M": ["P", "O", "A", "S", "B", "center", "T", "m", "man", "d", "F", "I", "E", "MM", "G", "D", "MC", "cm", "U", "Y", "V", "H", "W", "N", "n", "mc"], "_board": ["_row", " _block", "drow", " _row", " _deck", " _card", " _line", "_card", "dline", "_line", "dboard", "_deck", "_block"], "board": ["p", "pool", "array", "node", "coll", "case", "word", "ide", "list", "deck", "rank", "layout", "config", "pair", "boarding", "channel", "loop", "ro", "stream", "que", "nn", "player", "body", "base", "menu", "card", "custom", "position", "boards", "core", "flo", "data", "ack", "bo", "table", "form", "po", "game", "join", "hole", "rows", "sequence", "Board", "cart", "check", "video", "co", "buffer", "object", "union", "flow", "panel", "reader", "design", "bank", "feed", "clean", "block", "bug", "database", "style", "lane", "home"], "line": ["coll", "word", "comment", "unit", "case", "link", "li", "lines", "user", "ded", "lin", "plan", "lc", "pe", "ine", "range", "len", "log", "group", "entry", "Line", "nee", "live", "que", "une", "point", "base", "l", "position", "liner", "lo", "code", "fl", "frame", "do", "po", "nl", "ze", "ner", "cell", "LINE", "lined", "cle", "inline", "list", "call", "page", "block", "ne", "clean", "le", "ge", "slice", "source", "change"], "pos": ["iter", "p", "o", "coll", "all", "unit", "val", "pose", "list", "lines", "pack", "plan", "ss", "index", "len", "Position", "pins", "loop", "player", "point", "body", "parent", "l", "f", "position", "data", "pointer", "cond", "no", " positions", "none", "cache", " position", "os", "po", "neg", "post", "ps", "down", "part", "object", "strip", "diff", "POS", "loc", " pack", "block", "n", "feed", "Pos", "slice", "source"], "row": ["p", "o", "ow", "ra", "tr", "user", "cor", "rank", "index", "range", "rc", "entry", "q", "order", "sc", "ro", "d", "x", "h", "y", "raw", "f", "cr", "ru", "nr", "ry", "uc", "e", "key", "rr", "rows", "ner", "post", "k", "rh", "w", "Row", "b", "v", "u", "loc", "feed", "n", "cur", "coll"], "col": ["ref", "p", "Col", "ci", "ch", "cor", "cf", "lc", "index", "q", "x", "max", "y", "l", "f", "cr", "character", "chain", "num", "el", "year", "rot", "cell", "cin", "cat", "con", "cycle", "column", "co", "cl", "b", "ol", "loc", "n", "int", "ct", "cur", "coll", "ac", "cy"], "neighbor": ["noneighbour", "neongbor", "nborbor", "noneearbors", "necigar", "necibr", "newaybor", "neigenbor", "neisbors", "Neighbors", "neigenbors", "neighbors", "newaybour", "noighbour", "neonggar", "Neighbour", "necorebour", "Neigenbor", "noneighbor", "neborbour", "nighbor", "Neighbor", "nighmember", "neisbor", "Neigenbors", "neisbour", "Neighgar", "nocibors", "Neigenbour", "necibors", "neighthbr", "noighbor", "neighthored", "neighthbour", "newayored", "neighthbors", "noneearbor", "neisbr", "nighbour", "necibor", "Neigengar", "neearored", "neighthbor", "neongbors", "neighmember", "nocibr", "noighbr", "nborbour", "neearbors", "necoremember", "nocibour", "neighored", "noneighbors", "noneighored", "nbormember", "nocibor", "newaybors", "neongbour", "neigengar", "nebormember", "neearbour", "neearbor", "neighbour", "neborbor", "noighbors", "noneearbour", "necorebor", "neighgar", "neigenbour", "newaymember", "neighbr", "noneearored", "necibour"], "r": ["err", "p", "rb", "br", "dr", "tr", "range", "rc", "ar", "m", "ro", "mr", "d", "kr", "x", "rf", "h", "l", "f", "cr", "ru", "rl", "rd", "nr", "fr", "right", "e", "ir", "t", "rec", "ur", "rr", "z", "rt", "rg", "rn", "a", "w", "sr", "v", "re", "b", "hr", "u", "pr", "s", "rm", "lr", "n", "rs", "er", "cur", "yr"], "c": ["ch", "cc", "lc", "arc", "h", "y", "cr", "uc", "vc", "z", "cm", "w", "v", "u", "ca", "cs", "ac", "cy", "unc", "cor", "dc", "nc", "oc", "m", "rec", "i", "fc", "can", "xc", "n", "ct", "cu", "p", "ci", "cn", "ar", "d", "f", "e", "t", "chain", "ce", "cell", "course", "cd", "loc", "coll", "pc", "err", "cf", "rc", "sc", "q", "x", "l", "cp", "cont", "cache", "ec", "k", "rn", "co", "s", "b", "roc", "mc", "cur"], "count": ["err", "split", "depth", "start", "all", "case", "val", "cc", "list", "where", "group", "score", "index", "len", "weight", "catch", "name", "width", "any", "base", "max", "counter", "f", "found", "core", "code", "cond", "cache", "num", "every", "find", "nt", "type", "check", "cmp", "conn", "limit", "size", "match", "Count", "part", "cat", "length", "first", "last", "sum", "b", "agg", "number", "content", "loc", "call", "n", "test", "frac", "total", "int", "coll"], "flat": ["iter", "fin", "format", "single", "op", "unit", "filter", "fast", "py", "full", "multiple", "plan", "at", "layout", "layer", "live", "float", "multi", "dot", "lat", "base", "blank", "f", "fit", "plane", "fine", "fl", "form", "atten", "empty", "fat", "buff", "cat", "plain", "inline", "flush", "kat", "feed", "mat", "slice", "pat", "lie", "zip"], "result": ["err", "mate", "ver", "response", "new", "array", "case", "res", "list", "pack", "score", "catch", "range", "weight", "our", "order", "mark", "success", "grade", "counter", "data", "dist", "ret", "inc", "num", "draw", "particip", "ault", "atten", "match", "rate", "df", "work", "future", "Result", "root", "diff", "number", "compl", "const", "page", "test", "results", "date", "source"]}}
{"code": " \\n  \\n  \\n  def solve(arrange):\\n      board, row = arrange[0]\\n      before = board[row - 1]\\n      board, row = arrange[1]\\n      after = board[row - 1]\\n      dup = set(before) & set(after)\\n      if len(dup) == 1:\\n          return dup.pop()\\n      elif len(dup) >= 2:\\n          return 'Bad magician!'\\n      else:\\n          return 'Volunteer cheated!'\\n  \\n  \\n  def main(IN, OUT):\\n      T = int(IN.readline())\\n      for index in range(T):\\n          arrange = []\\n          for n in range(2):\\n              row = int(IN.readline())\\n              board = []\\n              for line in range(4):\\n                  board.append(map(int, IN.readline().split()))\\n              arrange.append((board, row))\\n          OUT.write('Case #%d: %s\\n' % (index + 1, solve(arrange)))\\n  \\n  \\n  def makesample(T=100):\\n      print T\\n      for index in range(T):\\n          for n in range(2):\\n              print random.randint(1, 4)\\n              board = list(range(1, 16+1))\\n              random.shuffle(board)\\n              while board:\\n                  print ' '.join(map(str, board[:4]))\\n                  board = board[4:]\\n  \\n  \\n  if __name__ == '__main__':\\n      if '-makesample' in sys.argv[1:]:\\n          makesample()\\n      else:\\n          main(sys.stdin, sys.stdout)\\n  \\n", "substitutes": {"arrange": ["arrayrange", "arranges", "arrayanged", "arrice", "arone", "dranged", "irrage", "aranch", "arase", "arride", "aranne", "arrace", "Arange", "arange", "Arice", "errrange", "strrage", "aranged", "arrase", "Arase", "apprage", " arranch", " arrice", "arrrange", "errrage", "arrayange", "drrange", " arranges", "arace", "drange", "arrayanges", "dranne", "arranch", "appange", "earange", "apprange", "earanne", "earride", "arrone", "aranges", "arrayride", "irrange", " arrrange", "arice", "arranne", "arrage", "Arrange", "irone", " arrase", "errone", "earrange", "irange", "arranged", "appace", "arrayanch", "arrride", "strrange", "errange", "arrrage", "strange", "strace", "arrayanne"], "board": ["stroke", "array", "node", "case", "list", "layout", "range", "head", "boards", "uc", "room", "code", "ward", "frame", "draw", "wheel", "control", "ban", "length", "buffer", "lane", "bug", "clean", "test", "slice", "where", "home", "comment", "id", "view", "ro", "body", "out", "menu", "card", "core", "data", "ack", "table", "back", "form", "hole", "roll", "down", "sequence", "Board", "poll", " block", "bc", "object", "flow", "pos", "bow", "up", "ide", "col", "boarding", "function", "message", "flo", "bo", "ck", "post", "cart", "ride", "word", "coll", "one", "off", "box", "o", " clipboard", "group", "deck", "loop", "channel", "raw", " loop", "rule", "batch", "game", "rows", "che", "bar", "b", "model", "design", "feed", "block"], "row": ["off", "offset", "id", "ow", "user", "group", "col", "tr", "rank", "month", "range", "rc", "run", "view", "order", "ro", "head", "x", "step", "port", "pri", "right", "ry", "end", "ward", "key", "batch", "form", "num", "rows", "year", "post", "round", "roll", "cell", "rot", "r", "value", "column", "length", "Row", "flow", "sync", "number", "pos", "server", "block", "page", "feed", "bug", "error", "slice", "where", "one"], "before": ["off", "p", "Before", "start", "range", "view", "head", "false", "here", "between", "right", "data", "around", "table", "below", "back", "none", "front", "prev", "pre", "info", "self", "size", "length", "left", "now", "above", "slice"], "after": ["p", "off", "all", "range", "run", "version", "later", "d", "head", "out", "next", "step", "when", "between", "right", "data", "around", "end", "pre", "post", "round", "module", "size", "future", "length", "left", "last", "After", "model", "on", "until", "string", "above", "option"], "dup": [" depr", " dep", "duP", "trips", "dops", "dc", "doc", "udps", "udpe", " duping", "dupe", "Duping", "udP", "trip", "udp", "duping", "tric", "dope", " duP", "dP", "dups", " deping", "Dups", "dupr", "udc", "diec", "DuP", "udping", "dp", "Dup", "Dupr", "duc", "tripe", "dps", "dop", " deps", "dpe", "diepe", "dieP", " dupr", " dups", "diep"], "IN": ["GEN", "NG", "Client", "GO", "MN", "Input", "URI", "RAW", "ins", "READ", "HTTP", "DL", "CL", "out", "AC", "INT", "IND", "IM", "String", "INS", "inner", "CON", "UL", "IO", "PIN", "EN", "LINE", "DATA", "URL", "AN", "FILE", "OSS", "MC", "MIN", "STR", "Reader", "IL", "Out", "In", "OU", "UID", "LIN", "WIN", "FS", "FIN"], "OUT": ["NG", "GER", "outer", "EX", "UN", "RAW", "READ", "DC", "EXT", "out", "PUT", "INT", "TABLE", "END", "INS", "BL", "DIR", "AL", "APP", "UL", "IO", "Output", "LINE", "TER", "DATA", "FILE", "OSS", "STR", "TEXT", "IL", "Out", "OU", "In", "OS", "STDOUT", "NAME", "Q", "FS", "TF"], "T": ["_", "P", "O", "A", "R", "TT", "TC", "S", "TW", "B", "time", "L", "F", "X", "I", "K", "Index", "t", "TS", "E", "TN", "TH", "D", "M", "SIZE", "sequence", "G", "type", "size", "U", "Y", "C", "length", "Row", "V", "H", "number", "Q", "W", "N", "total", "TF", "Time"], "index": ["iter", "prefix", "offset", "unit", "case", "id", "ci", "outer", "range", "name", "order", "loop", "ini", "null", "head", "x", "point", "ind", "foot", "Index", "position", "insert", "end", "table", "t", "num", "i", "rows", "axis", "type", "input", "match", "size", "toc", "length", "instance", "pos", "number", "pattern", "loc", "block", "page", "int", "test", "section", "word", "slice", "tc", "site"], "n": ["p", "o", "nin", "lin", "nc", "na", "len", "ns", "nb", "m", "nn", "un", "en", "l", "nan", "f", "c", "ln", "num", "i", "nor", "ner", "z", "nt", "nw", "r", "rn", "non", "nd", "b", "u", "N", "an", "dn"], "line": ["li", "lines", "lin", "col", "range", "len", "name", "Line", "x", "un", "out", "l", "blank", "code", "num", "obj", "ner", "inline", "size", "non", "length", "nd", "sync", "number", "block"]}}
{"code": " \\n  \\n  def neighbours(grid, (i, j), n, m):\\n      for a in range(max(i-1, 0), min(i+2, n)):\\n          for b in range(max(j-1, 0), min(j+2, m)):\\n              if (a != i or b != j):\\n                  yield (a, b)\\n  \\n  def isGridCorrect(grid):\\n      g = list(grid)\\n      n = len(g)\\n      m = len(g[0])\\n      queue = [(0, 0)]\\n  \\n      while queue:\\n          v = queue.pop(0)\\n          g[v[0]][v[1]] = 'r'\\n          bomb = False\\n          for (i, j) in neighbours(g, v, n, m):\\n              if g[i][j] == '*':\\n                  bomb = True\\n          if not bomb:\\n              for (i, j) in neighbours(g, v, n, m):\\n                  if g[i][j] != 'r':\\n                      queue.append((i, j))\\n  \\n      for i in range(n):\\n          for j in range(m):\\n              if g[i][j] != 'r' and g[i][j] != '*':\\n                  return 'WRONG'\\n  \\n      return 'Right'\\n  \\n  def createGrid(R, C, s):\\n      field = []\\n      for i in range(R):\\n          field.append([s] * C)\\n      field[0][0] = 'c'\\n      return field\\n  \\n  def draw(grid):\\n      s = \"\"\\n      for row in grid:\\n          s += \"\\n\" + ''.join(row)\\n      return s\\n  \\n  def reduceRows(grid, k, l, M):\\n      if k <= 2:\\n          return (grid, k, l, M)\\n      \\n  \\n      for j in range(l):\\n          grid[k-1][j] = '*'\\n      k -= 1\\n      M -= l\\n      return (grid, k, l, M)\\n  \\n  def reduceCols(grid, k, l, M):\\n      if l <= 2:\\n          return (grid, k, l, M)\\n      \\n  \\n      for i in range(k):\\n          grid[i][l-1] = '*'\\n      l -= 1\\n      M -= k\\n      return (grid, k, l, M)\\n  \\n  def solve(R, C, M):\\n      mp = M\\n      if M == 0:\\n          f = createGrid(R, C, '.')\\n          return draw(f)\\n      elif M == R*C - 1:\\n          f = createGrid(R, C, '*')\\n          return draw(f)\\n      elif (R == 2 or C == 2) and (M % 2 == 1 or M == R*C - 2):\\n          return \"\\n\" + 'Impossible' #+ '1: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n      elif R > 2 and C > 2 and (M == R*C - 2 or M == R*C - 3 or M == R*C - 5 or M == R*C - 7):\\n          return \"\\n\" + 'Impossible' #+ '2: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n      else:\\n          grid = createGrid(R, C, '.')\\n  \\n  \\n          k = R\\n          l = C\\n  \\n          while (M >= l and k > 2) or (M >= k and l > 2):\\n              if l >= k:\\n                  (grid, k, l, M) = reduceCols(grid, k, l, M)\\n              elif k > l:\\n                  (grid, k, l, M) = reduceRows(grid, k, l, M)\\n  \\n  \\n          if M == 0:\\n              return draw(grid)\\n          if M < l - 1 and k > 2:\\n              for j in range(l - M, l):\\n                  grid[k-1][j] = '*'\\n          elif M < k - 1 and l > 2:\\n              for i in range(k - M, k):\\n                  grid[i][l-1] = '*'\\n          elif l > 3 and k > 3:\\n              for i in range(2, k):\\n                  grid[i][l-1] = '*'\\n              M -= k - 2\\n              for j in range(l - M - 1, l - 1):\\n                  grid[k-1][j] = '*'\\n          else:\\n              return \"\\n\" + 'Impossible' #+ '3: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n  \\n          return draw(grid)\\n  \\n  def main():\\n      N = int(sys.stdin.readline()) # number of testcases\\n      for i in range(N):\\n          [R, C, M] = [int(x) for x in sys.stdin.readline().rstrip().split()]\\n  \\n          result = solve(R, C, M)\\n          print (\"Case #%s:%s\" % (i+1, result))\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "substitutes": {"grid": ["array", "node", "query", "div", "unit", "list", "gm", "layout", "cli", "grade", "play", "code", "frame", "uri", "age", "draw", "ht", "panel", "u", "xml", "bug", "gu", "slice", "id", "db", "live", "multi", "lock", "card", "c", "data", "table", "form", "ga", "module", "window", "column", "remote", "json", "layer", "filter", "spec", "file", "d", "flat", "gae", "record", "Grid", "update", "edge", "client", "chain", "cell", "graph", "cart", "input", "line", "sync", "dim", "gap", "ge", "magic", "zip", "mod", "house", "parse", "dom", "contact", "group", "q", "gui", "connection", "rule", "csv", "cache", "game", "cube", "storage", "server", "model", "block", "site"], "n": ["p", "o", "mn", "sn", "nc", "len", "nm", "q", "ns", "d", "np", "x", "h", "en", "y", "un", "c", "e", "t", "ln", "num", "z", "nt", "r", "ni", "size", "w", "u", "on", "N", "ne", "an"], "m": ["p", "o", "pm", "mn", "mm", "fm", "nm", "sm", "d", "h", "en", "y", "c", "ym", "e", "z", "r", "size", "cm", "w", "im", "mi", "min", "dim", "ms", "u", "om", "tm", "N", "an", "mc"], "a": ["p", "A", "ma", "ax", "ia", "na", "aa", "ae", "sa", "ar", "au", "d", "ai", "pa", "ap", "am", "y", "asa", "alpha", "c", "area", "fa", "e", "va", "aj", "ba", "ak", "ga", "ad", "ab", "u", "ca", "an", "da", "ac", "af"], "b": ["bis", "p", "o", "be", "rb", "eb", "aaa", "B", "sb", "lb", "nb", "d", "mb", "bi", "x", "body", "h", "am", "y", "ob", "c", "e", "fb", "bp", "ba", "beta", "bs", "ga", "z", "r", "bb", "bf", "w", "ab", "ib", "wb", "abb", "u", "bd", "aa"], "g": ["erg", "p", "ig", "bg", "group", "gm", "gb", "q", "gr", "d", "x", "h", "gae", "y", "gi", "cfg", "msg", "c", "gas", "play", "e", "gs", "gh", "game", "gp", "ga", "G", "graph", "go", "gg", "r", "og", "reg", "rg", "w", "sg", "u", "vg", "item", "gu", "ge"], "queue": ["p", "pool", "array", "all", "force", "foo", "stage", "main", "list", "group", "ping", "config", "seq", "event", "enabled", "layer", "q", "file", "cli", "gui", "delay", "live", "que", "order", "out", "parent", "menu", "stack", "message", "update", "chain", "Queue", "wait", "cache", "status", "ue", "job", "module", "sequence", "buf", "graph", "match", "buffer", "load", "server", "line", "master", "complete", "Q", "block", "progress", "result", "worker", "manager"], "v": ["p", "o", "ov", "ver", "li", "vp", "val", "dev", "vs", "nv", "av", "q", "qv", "d", "x", "h", "y", "iv", "c", "vi", "e", "lv", "t", "va", "uv", "vin", "z", "video", "r", "ev", "vd", "w", "ve", "V", "vv", "u", "vm", "sv", "vg"], "bomb": ["leaf", "bad", "prefix", "timeout", "unit", " Bomb", "foo", "az", "aaa", "zone", "storm", "Bomb", "broken", "null", "fail", "bi", "bird", "body", "pill", "blank", "less", "flash", "clone", "bell", "secret", "bo", "charge", "riot", "enemy", "controller", "mass", "atom", "ash", "hack", "bang", "moon", "ball", "beat", "osion", "rocket", "pattern", "attack", "blog", "rupt", "critical", "bug", "error", " bombs", "aa"], "i": ["il", "p", "o", "it", "ui", "li", "id", "ci", "ix", "ia", "ei", "ki", "ori", "ini", "ji", "d", "ai", "x", "bi", "h", "y", "I", "ri", "gi", "iv", "c", "ii", "vi", "ti", "e", "eni", "yi", "zi", "ie", "api", "ik", "xi", "di", "pi", "info", "z", "ni", "ij", "im", "mi", "u", "ip", "qi", "si", "io", "int", "iu", "lo"], "j": ["p", "o", "br", "li", "ci", "ch", "js", "jc", "ion", "q", "jp", "ji", "name", "d", "J", "x", "kj", "L", "h", "oj", "y", "false", "c", "ii", "fr", "adj", "e", "jl", "sh", "aj", "ie", "el", "xi", "obj", "z", "note", "em", "je", "ja", "r", "jj", "kl", "im", "ij", "ol", "jo", "u", "jet", "qi", "ne", "uj"], "R": ["_", "P", "A", "all", "id", "S", "B", "T", "J", "L", "RR", "F", "X", "add", "K", "I", "c", "str", "end", "Rs", "E", "Right", "join", "D", "G", "r", " r", "Rh", "format", "U", "url", "RS", "V", "H", "Q", "W", "N", "Res", "SR"], "C": ["CC", "Z", "P", "A", "CR", "CF", "CS", "S", "B", "Cs", "T", "d", "DC", "L", "X", "F", "I", "K", "c", "Ch", "E", "CT", "D", "G", "U", " c", "V", "Q", "W", "N", "CE"], "s": ["p", "o", "_", "sq", "ws", "lines", "S", "ss", "sb", "states", "spec", "sc", "su", "q", "ns", "details", "d", "es", "strings", "y", "fields", "h", "c", "e", "t", "csv", "gs", "sets", "series", "us", "rows", "G", "ps", "z", "sequence", "secondary", "r", "conf", "summary", "settings", "fs", "w", "sg", "ing", "comments", "u", "sf", "string", "sv", "si", "sym", "ed", "cs", "slice", "ds"], "field": ["element", "format", "box", "p", "_", "array", "div", "force", "id", "group", "file", "function", "d", "slice", "fields", "record", "card", "c", "data", "str", "end", "rule", "key", "FIELD", "condition", "form", "source", "cell", "z", "type", "input", "match", "column", "w", "Field", "object", "sum", "load", "line", "model", "string", "block", "patch", "layer"], "row": ["array", "query", "group", "col", "range", "entry", "q", "sc", "x", "record", "raw", "card", "data", "key", "form", "draw", "rows", "round", "cell", "input", "r", "cube", "column", "object", "Row", "instance", "server", "line", "model", "string", "page", "block", "item", "feed", "result", "slice"], "k": ["p", "o", "kn", "id", "ch", "ki", "ko", "q", "d", "x", "h", "y", "K", "kw", "c", "sk", "ek", "e", "t", "dk", "sh", "key", "ak", "ck", "mk", "ik", "ky", "z", "r", "ok", "ka", "ks", "kl", "w", "work", "kk", "u", "ke"], "l": ["il", "p", "o", "pl", "li", "ls", "lin", "lc", "ly", "q", "ail", "d", "ll", "L", "ml", "h", "ul", "y", "c", "al", "e", "t", "ell", "ln", "el", "nl", "z", "r", "kl", "yl", "dl", "lp", "ol", "lu", "u", "sl"], "M": ["Z", "P", "O", "LM", "A", "MF", "S", "AM", "MN", "B", "mm", "MR", "T", "J", "L", "CM", "TM", "F", "X", "K", "I", "DM", "IM", "JM", "E", "SM", "MM", "D", "G", "MS", "OM", "MD", "MC", "U", "cm", "Y", "V", "H", "EM", "ML", "GM", "MB", "Q", "NM", "W", "N", "FM", "Mi"]}}
{"code": " \\n  \\n  def solve(row1, row2):\\n      common = [x for x in row1 if x in row2]\\n      num_common = len(common)\\n      if num_common == 0:\\n          return 'Volunteer cheated!'\\n      elif num_common > 1:\\n          return 'Bad magician!'\\n      else:\\n          return common[0]\\n  \\n  def main():\\n      N = int(sys.stdin.readline()) # number of testcases\\n      for i in range(N):\\n          row_index1 = int(sys.stdin.readline())\\n          row1 = list()\\n          for j in range(4):\\n              if row_index1 == j + 1:\\n                  row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]\\n              else:\\n                  sys.stdin.readline()\\n  \\n          row_index2 = int(sys.stdin.readline())\\n          row2 = list()\\n          for j in range(4):\\n              if row_index2 == j + 1:\\n                  row2 = [int(x) for x in sys.stdin.readline().rstrip().split()]\\n              else:\\n                  sys.stdin.readline()\\n  \\n          result = solve(row1, row2)\\n          print (\"Case #%s: %s\" % (i+1, result))\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "substitutes": {"row1": ["rowOne", "row3", "Row01", "row0", " row01", "entryOne", "rows3", "RowOne", "Row1", "entry1", " rowOne", "rows1", "entry3", "Row0", "rows2", "entry01", "rows0", "row01", " row3", "Row2", " row0", "Row3"], "row2": ["col2", "row0", "rowsecond", "round1", "round2", "Row1", "entry1", "col1", "entrysecond", "Row0", "entry2", " rowsecond", "roundsecond", "Row2", " row0", "col0"], "common": ["mod", "desc", "prefix", "new", "extra", "comment", "command", "valid", "lc", "Common", "document", "basic", "com", "name", "broad", "norm", "central", "record", "raw", "similar", "family", "custom", "connection", "data", "specific", "compatible", "dist", "complex", "form", "known", "shared", "num", "media", "rows", "con", "conf", "cm", "summary", "recent", "public", "unique", "standard", "low", "fun", "union", "diff", "general", "normal", "ctx", "loc", "generic", "result", "local", "tc"], "x": ["p", "dx", " xx", "id", "long", "ci", "ax", " cx", "index", " tx", "na", " ax", "d", "xt", "ex", "y", "X", "max", "ux", "wx", "xa", "c", "xes", "mx", "abc", "px", " xp", "oint", "www", "xi", "yp", "k", "check", "rex", "nex", "xs", "xc", "rx", "work", "co", "ys", "xp", "ctx", "xx", "sex", "n", "xb", "test", "cross", "tx"], "num_common": ["nc_union", "num_general", "numFunion", "len_valid", "nc_common", "numFcommon", "num_often", "numFcon", " num_global", "nc_con", "num_unique", "len_general", "len_often", "num_global", "len_common", "num_union", "num_valid", " num_unique", "num_con"], "N": ["P", "O", "A", "R", "S", " n", "Ns", "T", "Line", "L", "F", "X", "K", "I", "Num", "NO", "D", "M", "network", "C", "NL", "Number", "NM", "NS", "NUM", "n", "NA", "NT"]}}
{"code": "CACHE = {(1, 1, 0): ['c'],\\n   (1, 2, 0): ['c.'],\\n   (1, 2, 1): ['*c'],\\n   (1, 3, 0): ['c..'],\\n   (1, 3, 1): ['*.c'],\\n   (1, 3, 2): ['**c'],\\n   (1, 4, 0): ['c...'],\\n   (1, 4, 1): ['*.c.'],\\n   (1, 4, 2): ['**.c'],\\n   (1, 4, 3): ['***c'],\\n   (1, 5, 0): ['c....'],\\n   (1, 5, 1): ['*.c..'],\\n   (1, 5, 2): ['**.c.'],\\n   (1, 5, 3): ['***.c'],\\n   (1, 5, 4): ['****c'],\\n   (2, 1, 0): ['c', '.'],\\n   (2, 1, 1): ['*', 'c'],\\n   (2, 2, 0): ['c.', '..'],\\n   (2, 2, 1): None,\\n   (2, 2, 2): None,\\n   (2, 2, 3): ['**', '*c'],\\n   (2, 3, 0): ['c..', '...'],\\n   (2, 3, 1): None,\\n   (2, 3, 2): ['*.c', '*..'],\\n   (2, 3, 3): None,\\n   (2, 3, 4): None,\\n   (2, 3, 5): ['***', '**c'],\\n   (2, 4, 0): ['c...', '....'],\\n   (2, 4, 1): None,\\n   (2, 4, 2): ['*.c.', '*...'],\\n   (2, 4, 3): None,\\n   (2, 4, 4): ['**.c', '**..'],\\n   (2, 4, 5): None,\\n   (2, 4, 6): None,\\n   (2, 4, 7): ['****', '***c'],\\n   (2, 5, 0): ['c....', '.....'],\\n   (2, 5, 1): None,\\n   (2, 5, 2): ['*.c..', '*....'],\\n   (2, 5, 3): None,\\n   (2, 5, 4): ['**.c.', '**...'],\\n   (2, 5, 5): None,\\n   (2, 5, 6): ['***.c', '***..'],\\n   (2, 5, 7): None,\\n   (2, 5, 8): None,\\n   (2, 5, 9): ['*****', '****c'],\\n   (3, 1, 0): ['c', '.', '.'],\\n   (3, 1, 1): ['*', '.', 'c'],\\n   (3, 1, 2): ['*', '*', 'c'],\\n   (3, 2, 0): ['c.', '..', '..'],\\n   (3, 2, 1): None,\\n   (3, 2, 2): ['**', '..', 'c.'],\\n   (3, 2, 3): None,\\n   (3, 2, 4): None,\\n   (3, 2, 5): ['**', '**', '*c'],\\n   (3, 3, 0): ['c..', '...', '...'],\\n   (3, 3, 1): ['*.c', '...', '...'],\\n   (3, 3, 2): None,\\n   (3, 3, 3): ['***', '...', 'c..'],\\n   (3, 3, 4): None,\\n   (3, 3, 5): ['***', '*..', '*.c'],\\n   (3, 3, 6): None,\\n   (3, 3, 7): None,\\n   (3, 3, 8): ['***', '***', '**c'],\\n   (3, 4, 0): ['c...', '....', '....'],\\n   (3, 4, 1): ['*.c.', '....', '....'],\\n   (3, 4, 2): ['**.c', '....', '....'],\\n   (3, 4, 3): ['*.c.', '*...', '*...'],\\n   (3, 4, 4): ['****', '....', 'c...'],\\n   (3, 4, 5): None,\\n   (3, 4, 6): ['****', '*...', '*.c.'],\\n   (3, 4, 7): None,\\n   (3, 4, 8): ['****', '**..', '**.c'],\\n   (3, 4, 9): None,\\n   (3, 4, 10): None,\\n   (3, 4, 11): ['****', '****', '***c'],\\n   (3, 5, 0): ['c....', '.....', '.....'],\\n   (3, 5, 1): ['*.c..', '.....', '.....'],\\n   (3, 5, 2): ['**.c.', '.....', '.....'],\\n   (3, 5, 3): ['***.c', '.....', '.....'],\\n   (3, 5, 4): ['**.c.', '*....', '*....'],\\n   (3, 5, 5): ['*****', '.....', 'c....'],\\n   (3, 5, 6): ['**.c.', '**...', '**...'],\\n   (3, 5, 7): ['*****', '*....', '*.c..'],\\n   (3, 5, 8): None,\\n   (3, 5, 9): ['*****', '**...', '**.c.'],\\n   (3, 5, 10): None,\\n   (3, 5, 11): ['*****', '***..', '***.c'],\\n   (3, 5, 12): None,\\n   (3, 5, 13): None,\\n   (3, 5, 14): ['*****', '*****', '****c'],\\n   (4, 1, 0): ['c', '.', '.', '.'],\\n   (4, 1, 1): ['*', '.', 'c', '.'],\\n   (4, 1, 2): ['*', '*', '.', 'c'],\\n   (4, 1, 3): ['*', '*', '*', 'c'],\\n   (4, 2, 0): ['c.', '..', '..', '..'],\\n   (4, 2, 1): None,\\n   (4, 2, 2): ['**', '..', 'c.', '..'],\\n   (4, 2, 3): None,\\n   (4, 2, 4): ['**', '**', '..', 'c.'],\\n   (4, 2, 5): None,\\n   (4, 2, 6): None,\\n   (4, 2, 7): ['**', '**', '**', '*c'],\\n   (4, 3, 0): ['c..', '...', '...', '...'],\\n   (4, 3, 1): ['*.c', '...', '...', '...'],\\n   (4, 3, 2): ['*.c', '*..', '...', '...'],\\n   (4, 3, 3): ['***', '...', 'c..', '...'],\\n   (4, 3, 4): ['***', '*..', '..c', '...'],\\n   (4, 3, 5): None,\\n   (4, 3, 6): ['***', '***', '...', 'c..'],\\n   (4, 3, 7): None,\\n   (4, 3, 8): ['***', '***', '*..', '*.c'],\\n   (4, 3, 9): None,\\n   (4, 3, 10): None,\\n   (4, 3, 11): ['***', '***', '***', '**c'],\\n   (4, 4, 0): ['c...', '....', '....', '....'],\\n   (4, 4, 1): ['*.c.', '....', '....', '....'],\\n   (4, 4, 2): ['**.c', '....', '....', '....'],\\n   (4, 4, 3): ['**.c', '*...', '....', '....'],\\n   (4, 4, 4): ['****', '....', 'c...', '....'],\\n   (4, 4, 5): ['****', '*...', '..c.', '....'],\\n   (4, 4, 6): ['****', '**..', '...c', '....'],\\n   (4, 4, 7): ['****', '*...', '*.c.', '*...'],\\n   (4, 4, 8): ['****', '****', '....', 'c...'],\\n   (4, 4, 9): None,\\n   (4, 4, 10): ['****', '****', '*...', '*.c.'],\\n   (4, 4, 11): None,\\n   (4, 4, 12): ['****', '****', '**..', '**.c'],\\n   (4, 4, 13): None,\\n   (4, 4, 14): None,\\n   (4, 4, 15): ['****', '****', '****', '***c'],\\n   (4, 5, 0): ['c....', '.....', '.....', '.....'],\\n   (4, 5, 1): ['*.c..', '.....', '.....', '.....'],\\n   (4, 5, 2): ['**.c.', '.....', '.....', '.....'],\\n   (4, 5, 3): ['***.c', '.....', '.....', '.....'],\\n   (4, 5, 4): ['***.c', '*....', '.....', '.....'],\\n   (4, 5, 5): ['*****', '.....', 'c....', '.....'],\\n   (4, 5, 6): ['*****', '*....', '..c..', '.....'],\\n   (4, 5, 7): ['*****', '**...', '...c.', '.....'],\\n   (4, 5, 8): ['*****', '***..', '....c', '.....'],\\n   (4, 5, 9): ['*****', '**...', '*..c.', '*....'],\\n   (4, 5, 10): ['*****', '*****', '.....', 'c....'],\\n   (4, 5, 11): ['*****', '**...', '**.c.', '**...'],\\n   (4, 5, 12): ['*****', '*****', '*....', '*.c..'],\\n   (4, 5, 13): None,\\n   (4, 5, 14): ['*****', '*****', '**...', '**.c.'],\\n   (4, 5, 15): None,\\n   (4, 5, 16): ['*****', '*****', '***..', '***.c'],\\n   (4, 5, 17): None,\\n   (4, 5, 18): None,\\n   (4, 5, 19): ['*****', '*****', '*****', '****c'],\\n   (5, 1, 0): ['c', '.', '.', '.', '.'],\\n   (5, 1, 1): ['*', '.', 'c', '.', '.'],\\n   (5, 1, 2): ['*', '*', '.', 'c', '.'],\\n   (5, 1, 3): ['*', '*', '*', '.', 'c'],\\n   (5, 1, 4): ['*', '*', '*', '*', 'c'],\\n   (5, 2, 0): ['c.', '..', '..', '..', '..'],\\n   (5, 2, 1): None,\\n   (5, 2, 2): ['**', '..', 'c.', '..', '..'],\\n   (5, 2, 3): None,\\n   (5, 2, 4): ['**', '**', '..', 'c.', '..'],\\n   (5, 2, 5): None,\\n   (5, 2, 6): ['**', '**', '**', '..', 'c.'],\\n   (5, 2, 7): None,\\n   (5, 2, 8): None,\\n   (5, 2, 9): ['**', '**', '**', '**', '*c'],\\n   (5, 3, 0): ['c..', '...', '...', '...', '...'],\\n   (5, 3, 1): ['*.c', '...', '...', '...', '...'],\\n   (5, 3, 2): ['*.c', '*..', '...', '...', '...'],\\n   (5, 3, 3): ['***', '...', 'c..', '...', '...'],\\n   (5, 3, 4): ['***', '*..', '..c', '...', '...'],\\n   (5, 3, 5): ['***', '*..', '*.c', '...', '...'],\\n   (5, 3, 6): ['***', '***', '...', 'c..', '...'],\\n   (5, 3, 7): ['***', '***', '*..', '..c', '...'],\\n   (5, 3, 8): None,\\n   (5, 3, 9): ['***', '***', '***', '...', 'c..'],\\n   (5, 3, 10): None,\\n   (5, 3, 11): ['***', '***', '***', '*..', '*.c'],\\n   (5, 3, 12): None,\\n   (5, 3, 13): None,\\n   (5, 3, 14): ['***', '***', '***', '***', '**c'],\\n   (5, 4, 0): ['c...', '....', '....', '....', '....'],\\n   (5, 4, 1): ['*.c.', '....', '....', '....', '....'],\\n   (5, 4, 2): ['**.c', '....', '....', '....', '....'],\\n   (5, 4, 3): ['**.c', '*...', '....', '....', '....'],\\n   (5, 4, 4): ['****', '....', 'c...', '....', '....'],\\n   (5, 4, 5): ['****', '*...', '..c.', '....', '....'],\\n   (5, 4, 6): ['****', '**..', '...c', '....', '....'],\\n   (5, 4, 7): ['****', '**..', '*..c', '....', '....'],\\n   (5, 4, 8): ['****', '****', '....', 'c...', '....'],\\n   (5, 4, 9): ['****', '****', '*...', '..c.', '....'],\\n   (5, 4, 10): ['****', '****', '**..', '...c', '....'],\\n   (5, 4, 11): ['****', '****', '*...', '*.c.', '*...'],\\n   (5, 4, 12): ['****', '****', '****', '....', 'c...'],\\n   (5, 4, 13): None,\\n   (5, 4, 14): ['****', '****', '****', '*...', '*.c.'],\\n   (5, 4, 15): None,\\n   (5, 4, 16): ['****', '****', '****', '**..', '**.c'],\\n   (5, 4, 17): None,\\n   (5, 4, 18): None,\\n   (5, 4, 19): ['****', '****', '****', '****', '***c'],\\n   (5, 5, 0): ['c....', '.....', '.....', '.....', '.....'],\\n   (5, 5, 1): ['*.c..', '.....', '.....', '.....', '.....'],\\n   (5, 5, 2): ['**.c.', '.....', '.....', '.....', '.....'],\\n   (5, 5, 3): ['***.c', '.....', '.....', '.....', '.....'],\\n   (5, 5, 4): ['***.c', '*....', '.....', '.....', '.....'],\\n   (5, 5, 5): ['*****', '.....', 'c....', '.....', '.....'],\\n   (5, 5, 6): ['*****', '*....', '..c..', '.....', '.....'],\\n   (5, 5, 7): ['*****', '**...', '...c.', '.....', '.....'],\\n   (5, 5, 8): ['*****', '***..', '....c', '.....', '.....'],\\n   (5, 5, 9): ['*****', '***..', '*...c', '.....', '.....'],\\n   (5, 5, 10): ['*****', '*****', '.....', 'c....', '.....'],\\n   (5, 5, 11): ['*****', '*****', '*....', '..c..', '.....'],\\n   (5, 5, 12): ['*****', '*****', '**...', '...c.', '.....'],\\n   (5, 5, 13): ['*****', '*****', '***..', '....c', '.....'],\\n   (5, 5, 14): ['*****', '*****', '**...', '*..c.', '*....'],\\n   (5, 5, 15): ['*****', '*****', '*****', '.....', 'c....'],\\n   (5, 5, 16): ['*****', '*****', '**...', '**.c.', '**...'],\\n   (5, 5, 17): ['*****', '*****', '*****', '*....', '*.c..'],\\n   (5, 5, 18): None,\\n   (5, 5, 19): ['*****', '*****', '*****', '**...', '**.c.'],\\n   (5, 5, 20): None,\\n   (5, 5, 21): ['*****', '*****', '*****', '***..', '***.c'],\\n   (5, 5, 22): None,\\n   (5, 5, 23): None,\\n   (5, 5, 24): ['*****', '*****', '*****', '*****', '****c']}\\n  \\n  \\n  T = int(input())\\n  for i in range(T):\\n  \tR, C, M = map(int, input().split())\\n  \tprint('Case #{}:'.format(i + 1))\\n  \ttry:\\n  \t\tprint('\\n'.join(CACHE[(R, C, M)]))\\n  \texcept:\\n  \t\tprint('Impossible')\\n", "substitutes": {"CACHE": ["CASK", "CAGCH", "CACHES", "CAGHE", "HEACK", "CACHK", "HEACCH", "CASHE", "CACHHE", "CAGK", "CAGES", "CACHCH", "CASES", "CACES", "CACCH", "HEACES", "CACK", "HEACHE", "HEACHES", "HEACHHE", "HEACHK", "HEACHCH", "CASCH"]}}
{"code": "T = int(input())\\n  \\n  for i in range(T):\\n      a1 = int(input())\\n      mat1 = [list(map(int, input().split())) for k in range(4)]\\n      a2 = int(input())\\n      mat2 = [list(map(int, input().split())) for k in range(4)]\\n      final_set = set(mat1[a1 - 1]) & set(mat2[a2 - 1])\\n      if not len(final_set):\\n          s = 'Volunteer cheated!'\\n      elif len(final_set) > 1:\\n          s = 'Bad magician!'\\n      else:\\n          s = list(final_set)[0]\\n      print('Case #{}: {}'.format(i + 1, s))\\n", "substitutes": {"T": ["Z", "P", "O", "A", "R", "S", "WT", "B", "L", "F", "X", "I", "K", "t", "Total", "Num", "TN", "num", "D", "M", "G", "U", "Y", "C", "V", "H", "Q", "W", "N", "TI", "n", "Time"], "i": ["p", "chi", "li", "id", "ci", "index", "q", "d", "ai", "phi", "x", "bi", "ind", "y", "l", "f", "I", "gi", "ii", "c", "ti", "e", "t", "key", "mini", "ik", "pi", "xi", "z", "type", "a", "im", "j", "v", "u", "ip", "n", "si", "int", "iu"], "a1": [" a01", "p1", "A2", " a11", "a01", "A01", "A1", "p2", "aone", "alpha3", "alpha11", "p11", " a3", "alphaone", "alpha2", " aone", "Aone", "a3", "alpha01", "p3", "alpha1", "a11"], "mat1": ["match1", "ha3", "mapup", "aOne", "map3", "matchup", "mat0", "match0", "haup", "ma1", "Mat2", "Mat1", "MatOne", "matone", "aone", "maOne", "mat3", "match3", "Matone", "ha1", "map1", "matOne", "matup", "map0", "maone", "ha0", "ma2"], "k": ["p", "it", "_", "kn", "q", "un", "ku", "get", "K", "kw", "sk", "c", "unk", "ak", "ck", "ok", "ka", "ks", "ked", "w", "kt", "g", "work", "j", "b", "kk", "king", "n", "km", "kin", "kil", "ke"], "a2": ["aisecond", "Asecond", "a4", "A4", "A2", " a256", " asecond", "ai2", "A1", "asecond", "wa256", "wa2", "wa4", "A256", " a4", "a256", "ai1"], "mat2": ["Matl", "a4", "wa0", "na2", "mat0", "Mat2", "Mat1", "na0", "na4", "matl", "al", "wa1", " mat4", "wa2", "mat4", "wa4", "na1", "a0", " matl", "Mat4"], "final_set": ["final_SET", "last_sc", " final_sample", "final_match", "finalfulsample", "final_case", "finalescase", " final_case", " final_sett", "total_test", "last_set", " final_sets", "final_sett", "final_type", "final_test", "finalfulsets", "total_SET", " final_type", "finalfulcase", "finalactest", "total_set", "final_sc", "finalestype", "finalfulset", "last_list", "total_case", "finalessett", "finalacSET", "final_sets", "last_match", "finalaccase", "finalesset", "final_sample", "finalacset", "final_list"], "s": ["p", "o", "side", "session", "new", "single", "comment", "sort", "se", "ls", "sq", "ws", "S", "ss", "sb", "spec", "ds", "su", "name", "ns", "d", "sing", "space", "strings", "l", "y", "f", "c", "str", "e", "t", "ses", "ssl", "status", "set", "sign", "summary", "a", "w", "g", "sg", "sin", "v", "sync", "comments", "title", "string", "sf", "south", "sl", "si", "sym", "n", "sv", "rs", "source", "site"]}}
